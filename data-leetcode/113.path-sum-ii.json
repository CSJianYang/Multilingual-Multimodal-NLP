[
    {
        "title": "Roman to Integer",
        "question_content": "Roman numerals are represented by seven different symbols:&nbsp;I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,&nbsp;2 is written as II&nbsp;in Roman numeral, just two ones added together. 12 is written as&nbsp;XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n\tI can be placed before V (5) and X (10) to make 4 and 9.&nbsp;\n\tX can be placed before L (50) and C (100) to make 40 and 90.&nbsp;\n\tC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer.\n&nbsp;\nExample 1:\n\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\n\nExample 2:\n\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n\nExample 3:\n\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 15\n\ts contains only&nbsp;the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\n\tIt is guaranteed&nbsp;that s is a valid roman numeral in the range [1, 3999].",
        "solutions": [
            {
                "id": 264743,
                "title": "clean-python-beats-99-78",
                "content": "The Romans would most likely be angered by how it butchers their numeric system. Sorry guys.\\n\\n```Python\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        translations = {\\n            \"I\": 1,\\n            \"V\": 5,\\n            \"X\": 10,\\n            \"L\": 50,\\n            \"C\": 100,\\n            \"D\": 500,\\n            \"M\": 1000\\n        }\\n        number = 0\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\\n        s = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\\n        s = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n        for char in s:\\n            number += translations[char]\\n        return number\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        translations = {\\n            \"I\": 1,\\n            \"V\": 5,\\n            \"X\": 10,\\n            \"L\": 50,\\n            \"C\": 100,\\n            \"D\": 500,\\n            \"M\": 1000\\n        }\\n        number = 0\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\\n        s = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\\n        s = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n        for char in s:\\n            number += translations[char]\\n        return number\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632431,
                "title": "java-90-faster-solution",
                "content": "```\\n public int romanToInt(String s) {\\n         int ans = 0, num = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            switch(s.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) ans -= num;\\n            else ans += num;\\n        }\\n        return ans;\\n    }\\n```\\n\\nplease upvote if you liked the solution.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int romanToInt(String s) {\\n         int ans = 0, num = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            switch(s.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) ans -= num;\\n            else ans += num;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651672,
                "title": "best-method-c-java-python-beginner-friendly",
                "content": "**Certainly! Let\\'s break down the code and provide a clear intuition and explanation, using the examples \"IX\" and \"XI\" to demonstrate its functionality.**\\n\\n# Intuition:\\nThe key intuition lies in the fact that in Roman numerals, when a smaller value appears before a larger value, it represents subtraction, while when a smaller value appears after or equal to a larger value, it represents addition.\\n\\n# Explanation:\\n\\n1. The unordered map `m` is created and initialized with mappings between Roman numeral characters and their corresponding integer values. For example, \\'I\\' is mapped to 1, \\'V\\' to 5, \\'X\\' to 10, and so on.\\n2. The variable `ans` is initialized to 0. This variable will accumulate the final integer value of the Roman numeral string.\\n3. The for loop iterates over each character in the input string `s`.\\n   **For the example \"IX\":**\\n   \\n     - When `i` is 0, the current character `s[i]` is \\'I\\'. Since there is a next character (\\'X\\'), and the value of \\'I\\' (1) is less than the value of \\'X\\' (10), the condition `m[s[i]] < m[s[i+1]]` is true. In this case, we subtract the value of the current character from `ans`.\\n     \\n       `ans -= m[s[i]];`\\n       `ans -= m[\\'I\\'];`\\n       `ans -= 1;`\\n       `ans` becomes -1.\\n     \\n     - When `i` is 1, the current character `s[i]` is \\'X\\'. This is the last character in the string, so there is no next character to compare. Since there is no next character, we don\\'t need to evaluate the condition. In this case, we add the value of the current character to `ans`.\\n     \\n       `ans += m[s[i]];`\\n       `ans += m[\\'X\\'];`\\n       `ans += 10;`\\n       `ans` becomes 9.\\n       \\n   **For the example \"XI\":**\\n   \\n     - When `i` is 0, the current character `s[i]` is \\'X\\'. Since there is a next character (\\'I\\'), and the value of \\'X\\' (10) is greater than the value of \\'I\\' (1), the condition `m[s[i]] < m[s[i+1]]` is false. In this case, we add the value of the current character to `ans`.\\n     \\n       `ans += m[s[i]];`\\n       `ans += m[\\'X\\'];`\\n       `ans += 10;`\\n       `ans` becomes 10.\\n     \\n     - When `i` is 1, the current character `s[i]` is \\'I\\'. This is the last character in the string, so there is no next character to compare. Since there is no next character, we don\\'t need to evaluate the condition. In this case, we add the value of the current character to `ans`.\\n     \\n       `ans += m[s[i]];`\\n       `ans += m[\\'I\\'];`\\n       `ans += 1;`\\n       `ans` becomes 11.\\n\\n4. After the for loop, the accumulated value in `ans` represents the integer conversion of the Roman numeral string, and it is returned as the result.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char, int> m;\\n        \\n        m[\\'I\\'] = 1;\\n        m[\\'V\\'] = 5;\\n        m[\\'X\\'] = 10;\\n        m[\\'L\\'] = 50;\\n        m[\\'C\\'] = 100;\\n        m[\\'D\\'] = 500;\\n        m[\\'M\\'] = 1000;\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(m[s[i]] < m[s[i+1]]){\\n                ans -= m[s[i]];\\n            }\\n            else{\\n                ans += m[s[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> m = new HashMap<>();\\n        \\n        m.put(\\'I\\', 1);\\n        m.put(\\'V\\', 5);\\n        m.put(\\'X\\', 10);\\n        m.put(\\'L\\', 50);\\n        m.put(\\'C\\', 100);\\n        m.put(\\'D\\', 500);\\n        m.put(\\'M\\', 1000);\\n        \\n        int ans = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (i < s.length() - 1 && m.get(s.charAt(i)) < m.get(s.charAt(i + 1))) {\\n                ans -= m.get(s.charAt(i));\\n            } else {\\n                ans += m.get(s.charAt(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        m = {\\n            \\'I\\': 1,\\n            \\'V\\': 5,\\n            \\'X\\': 10,\\n            \\'L\\': 50,\\n            \\'C\\': 100,\\n            \\'D\\': 500,\\n            \\'M\\': 1000\\n        }\\n        \\n        ans = 0\\n        \\n        for i in range(len(s)):\\n            if i < len(s) - 1 and m[s[i]] < m[s[i+1]]:\\n                ans -= m[s[i]]\\n            else:\\n                ans += m[s[i]]\\n        \\n        return ans\\n```\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/54624a63-8635-4039-b17e-344ebb2a19d9_1687076744.9965477.png)\\n\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\n10. **Practice them in a row for better understanding and please Upvote for more questions.**\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char, int> m;\\n        \\n        m[\\'I\\'] = 1;\\n        m[\\'V\\'] = 5;\\n        m[\\'X\\'] = 10;\\n        m[\\'L\\'] = 50;\\n        m[\\'C\\'] = 100;\\n        m[\\'D\\'] = 500;\\n        m[\\'M\\'] = 1000;\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(m[s[i]] < m[s[i+1]]){\\n                ans -= m[s[i]];\\n            }\\n            else{\\n                ans += m[s[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> m = new HashMap<>();\\n        \\n        m.put(\\'I\\', 1);\\n        m.put(\\'V\\', 5);\\n        m.put(\\'X\\', 10);\\n        m.put(\\'L\\', 50);\\n        m.put(\\'C\\', 100);\\n        m.put(\\'D\\', 500);\\n        m.put(\\'M\\', 1000);\\n        \\n        int ans = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (i < s.length() - 1 && m.get(s.charAt(i)) < m.get(s.charAt(i + 1))) {\\n                ans -= m.get(s.charAt(i));\\n            } else {\\n                ans += m.get(s.charAt(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        m = {\\n            \\'I\\': 1,\\n            \\'V\\': 5,\\n            \\'X\\': 10,\\n            \\'L\\': 50,\\n            \\'C\\': 100,\\n            \\'D\\': 500,\\n            \\'M\\': 1000\\n        }\\n        \\n        ans = 0\\n        \\n        for i in range(len(s)):\\n            if i < len(s) - 1 and m[s[i]] < m[s[i+1]]:\\n                ans -= m[s[i]]\\n            else:\\n                ans += m[s[i]]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6537,
                "title": "my-straightforward-python-solution",
                "content": "\\n    class Solution:\\n    # @param {string} s\\n    # @return {integer}\\n    def romanToInt(self, s):\\n        roman = {'M': 1000,'D': 500 ,'C': 100,'L': 50,'X': 10,'V': 5,'I': 1}\\n        z = 0\\n        for i in range(0, len(s) - 1):\\n            if roman[s[i]] < roman[s[i+1]]:\\n                z -= roman[s[i]]\\n            else:\\n                z += roman[s[i]]\\n        return z + roman[s[-1]]\\n\\n\\n*Note: The trick is that the last letter is always added. Except the last one, if one letter is less than its latter one, this letter is subtracted.",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 6547,
                "title": "clean-o-n-c-solution",
                "content": "Problem is simpler to solve by working the string from back to front and using a map.  Runtime speed is 88 ms.\\n\\n\\n\\n    int romanToInt(string s) \\n    {\\n        unordered_map<char, int> T = { { 'I' , 1 },\\n                                       { 'V' , 5 },\\n                                       { 'X' , 10 },\\n                                       { 'L' , 50 },\\n                                       { 'C' , 100 },\\n                                       { 'D' , 500 },\\n                                       { 'M' , 1000 } };\\n                                       \\n       int sum = T[s.back()];\\n       for (int i = s.length() - 2; i >= 0; --i) \\n       {\\n           if (T[s[i]] < T[s[i + 1]])\\n           {\\n               sum -= T[s[i]];\\n           }\\n           else\\n           {\\n               sum += T[s[i]];\\n           }\\n       }\\n       \\n       return sum;\\n    }",
                "solutionTags": [],
                "code": "Problem is simpler to solve by working the string from back to front and using a map.  Runtime speed is 88 ms.\\n\\n\\n\\n    int romanToInt(string s) \\n    {\\n        unordered_map<char, int> T = { { 'I' , 1 },\\n                                       { 'V' , 5 },\\n                                       { 'X' , 10 },\\n                                       { 'L' , 50 },\\n                                       { 'C' , 100 },\\n                                       { 'D' , 500 },\\n                                       { 'M' , 1000 } };\\n                                       \\n       int sum = T[s.back()];\\n       for (int i = s.length() - 2; i >= 0; --i) \\n       {\\n           if (T[s[i]] < T[s[i + 1]])\\n           {\\n               sum -= T[s[i]];\\n           }\\n           else\\n           {\\n               sum += T[s[i]];\\n           }\\n       }\\n       \\n       return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 6509,
                "title": "7ms-solution-in-java-easy-to-understand",
                "content": "     public int romanToInt(String s) {\\n        int nums[]=new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            switch (s.charAt(i)){\\n                case 'M':\\n                    nums[i]=1000;\\n                    break;\\n                case 'D':\\n                    nums[i]=500;\\n                    break;\\n                case 'C':\\n                    nums[i]=100;\\n                    break;\\n                case 'L':\\n                    nums[i]=50;\\n                    break;\\n                case 'X' :\\n                    nums[i]=10;\\n                    break;\\n                case 'V':\\n                    nums[i]=5;\\n                    break;\\n                case 'I':\\n                    nums[i]=1;\\n                    break;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]<nums[i+1])\\n                sum-=nums[i];\\n            else\\n                sum+=nums[i];\\n        }\\n        return sum+nums[nums.length-1];\\n    }",
                "solutionTags": [],
                "code": "     public int romanToInt(String s) {\\n        int nums[]=new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            switch (s.charAt(i)){\\n                case 'M':\\n                    nums[i]=1000;\\n                    break;\\n                case 'D':\\n                    nums[i]=500;\\n                    break;\\n                case 'C':\\n                    nums[i]=100;\\n                    break;\\n                case 'L':\\n                    nums[i]=50;\\n                    break;\\n                case 'X' :\\n                    nums[i]=10;\\n                    break;\\n                case 'V':\\n                    nums[i]=5;\\n                    break;\\n                case 'I':\\n                    nums[i]=1;\\n                    break;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]<nums[i+1])\\n                sum-=nums[i];\\n            else\\n                sum+=nums[i];\\n        }\\n        return sum+nums[nums.length-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2428756,
                "title": "python-easily-understood-faster-than-98-less-than-76-o-n",
                "content": "Code:\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        roman_to_integer = {\\n            \\'I\\': 1,\\n            \\'V\\': 5,\\n            \\'X\\': 10,\\n            \\'L\\': 50,\\n            \\'C\\': 100,\\n            \\'D\\': 500,\\n            \\'M\\': 1000,\\n        }\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\").replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\").replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n        return sum(map(lambda x: roman_to_integer[x], s))\\n```\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(1)`\\n<br/>\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        roman_to_integer = {\\n            \\'I\\': 1,\\n            \\'V\\': 5,\\n            \\'X\\': 10,\\n            \\'L\\': 50,\\n            \\'C\\': 100,\\n            \\'D\\': 500,\\n            \\'M\\': 1000,\\n        }\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\").replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\").replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n        return sum(map(lambda x: roman_to_integer[x], s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051142,
                "title": "easy-c-solution-with-short-code",
                "content": "\\n# Approach\\nIf there are Numbers such as XL, IV, etc. \\nSimply subtract the smaller number and add the larger number in next step. \\nFor example, if there is XL, ans =-10 in first step, ans=-10+50=40 in next step.\\n\\nOtherwise, just add the numbers. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans=0;\\n        unordered_map <char,int> mp{\\n        {\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},{\\'M\\',1000}};\\n\\n    for(int i=0;i<s.size();i++){\\n        if(mp[s[i]]<mp[s[i+1]]){\\n            //for cases such as IV,CM, XL, etc...\\n            ans=ans-mp[s[i]];\\n        }\\n        else{\\n            ans=ans+mp[s[i]];\\n        }\\n    }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans=0;\\n        unordered_map <char,int> mp{\\n        {\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},{\\'M\\',1000}};\\n\\n    for(int i=0;i<s.size();i++){\\n        if(mp[s[i]]<mp[s[i+1]]){\\n            //for cases such as IV,CM, XL, etc...\\n            ans=ans-mp[s[i]];\\n        }\\n        else{\\n            ans=ans+mp[s[i]];\\n        }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6529,
                "title": "my-solution-for-this-question-but-i-don-t-know-is-there-any-easier-way",
                "content": "count every Symbol and add its value to the sum, and minus the extra part of special cases. \\n\\n    public int romanToInt(String s) {\\n         int sum=0;\\n        if(s.indexOf(\"IV\")!=-1){sum-=2;}\\n        if(s.indexOf(\"IX\")!=-1){sum-=2;}\\n        if(s.indexOf(\"XL\")!=-1){sum-=20;}\\n        if(s.indexOf(\"XC\")!=-1){sum-=20;}\\n        if(s.indexOf(\"CD\")!=-1){sum-=200;}\\n        if(s.indexOf(\"CM\")!=-1){sum-=200;}\\n        \\n        char c[]=s.toCharArray();\\n        int count=0;\\n        \\n       for(;count<=s.length()-1;count++){\\n           if(c[count]=='M') sum+=1000;\\n           if(c[count]=='D') sum+=500;\\n           if(c[count]=='C') sum+=100;\\n           if(c[count]=='L') sum+=50;\\n           if(c[count]=='X') sum+=10;\\n           if(c[count]=='V') sum+=5;\\n           if(c[count]=='I') sum+=1;\\n           \\n       }\\n       \\n       return sum;\\n        \\n    }",
                "solutionTags": [],
                "code": "count every Symbol and add its value to the sum, and minus the extra part of special cases. \\n\\n    public int romanToInt(String s) {\\n         int sum=0;\\n        if(s.indexOf(\"IV\")!=-1){sum-=2;}\\n        if(s.indexOf(\"IX\")!=-1){sum-=2;}\\n        if(s.indexOf(\"XL\")!=-1){sum-=20;}\\n        if(s.indexOf(\"XC\")!=-1){sum-=20;}\\n        if(s.indexOf(\"CD\")!=-1){sum-=200;}\\n        if(s.indexOf(\"CM\")!=-1){sum-=200;}\\n        \\n        char c[]=s.toCharArray();\\n        int count=0;\\n        \\n       for(;count<=s.length()-1;count++){\\n           if(c[count]=='M') sum+=1000;\\n           if(c[count]=='D') sum+=500;\\n           if(c[count]=='C') sum+=100;\\n           if(c[count]=='L') sum+=50;\\n           if(c[count]=='X') sum+=10;\\n           if(c[count]=='V') sum+=5;\\n           if(c[count]=='I') sum+=1;\\n           \\n       }\\n       \\n       return sum;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2426521,
                "title": "c-o-n-short-code-clean-code-fast-and-easy",
                "content": "**Intuitive**\\nRoman numerals are usually written largest to smallest from left to right, for example: XII (7), XXVII (27), III (3)...\\nIf a small value is placed before a bigger value then it\\'s a combine number, for exampe: IV (4), IX (9), XIV (14)...\\nIV = -1 + 5\\nVI = 5 + 1\\nXL = -10 + 50\\nLX = 50 + 10\\nSo, if a smaller number appears before a larger number, it indicates that the number is smaller by a quantity used as a suffix to it, which made going backwards seem easy.\\n\\n\\t\\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n    int romanToInt(string s) {\\n        unordered_map<char,int> mp{\\n            {\\'I\\',1},\\n            {\\'V\\',5},\\n            {\\'X\\',10},\\n            {\\'L\\',50},\\n            {\\'C\\',100},\\n            {\\'D\\',500},\\n            {\\'M\\',1000},\\n        };\\n        int ans =0;\\n        for(int i=0;i<s.size();i++){\\n            if(mp[s[i]]<mp[s[i+1]])\\n                ans-=mp[s[i]];\\n            else\\n                ans+=mp[s[i]];\\n        }\\n        return ans;\\n        \\n    }\\n\\t};\\n\\t\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). \\nHAPPY CODING:)**\\n\\n*Any suggestions and improvements are always welcome*\\n\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int romanToInt(string s) {\\n        unordered_map<char,int> mp{\\n            {\\'I\\',1}",
                "codeTag": "Java"
            },
            {
                "id": 326345,
                "title": "simple-javascript-solution-easy-understanding",
                "content": "```\\nsymbols = {\\n    \"I\": 1,\\n    \"V\": 5,\\n    \"X\": 10,\\n    \"L\": 50,\\n    \"C\": 100,\\n    \"D\": 500,\\n    \"M\": 1000\\n};\\n\\nvar romanToInt = function(s) {\\n    value = 0;\\n    for(let i = 0; i < s.length; i+=1){\\n        symbols[s[i]] < symbols[s[i+1]] ? value -= symbols[s[i]]: value += symbols[s[i]]\\n    }\\n    return value\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nsymbols = {\\n    \"I\": 1,\\n    \"V\": 5,\\n    \"X\": 10,\\n    \"L\": 50,\\n    \"C\": 100,\\n    \"D\": 500,\\n    \"M\": 1000\\n};\\n\\nvar romanToInt = function(s) {\\n    value = 0;\\n    for(let i = 0; i < s.length; i+=1){\\n        symbols[s[i]] < symbols[s[i+1]] ? value -= symbols[s[i]]: value += symbols[s[i]]\\n    }\\n    return value\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3421656,
                "title": "hash-table-concept-python3",
                "content": "\\n# Hash Table in python\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        roman={\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000}\\n        number=0\\n        for i in range(len(s)-1):\\n            if roman[s[i]] < roman[s[(i+1)]]:\\n                number-=roman[s[i]]\\n            else:\\n                number+=roman[s[i]]\\n        return number+roman[s[-1]]\\n\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        roman={\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000}\\n        number=0\\n        for i in range(len(s)-1):\\n            if roman[s[i]] < roman[s[(i+1)]]:\\n                number-=roman[s[i]]\\n            else:\\n                number+=roman[s[i]]\\n        return number+roman[s[-1]]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706813,
                "title": "js-hash-table-with-exlanation",
                "content": "To solve this problem, we need to create a hash table, the characters in which will correspond to a certain number. Passing along the line, we will check the current and the next character at once, if the current one is greater than the next one, then everything is fine, we add it to the result (it is initially equal to 0), otherwise, we subtract the current value from the next value (for example, the current 10, and the next 100 , we do 100 - 10, and we get 90), we also add to the result and additionally increase the index **by 1**. As a result, at the end of the loop, we will get the result we need.\\n\\nI hope the picture below will help you understand in more detail!)\\n\\n![image](https://assets.leetcode.com/users/images/ff64e9f4-d8eb-4f36-9d2f-810267ea0427_1665853020.385802.png)\\n\\n```\\nvar romanToInt = function(s) {\\n      const sym = {\\n        \\'I\\': 1,\\n        \\'V\\': 5,\\n        \\'X\\': 10,\\n        \\'L\\': 50,\\n        \\'C\\': 100,\\n        \\'D\\': 500,\\n        \\'M\\': 1000\\n    }\\n\\n    let result = 0;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        const cur = sym[s[i]];\\n        const next = sym[s[i + 1]];\\n\\n        if (cur < next) {\\n            result += next - cur;\\n            i++;\\n        } else {\\n            result += cur;\\n        }\\n    }\\n\\n    return result;\\n};\\n```\\n\\nI hope I was able to explain clearly.\\n**Happy coding!** \\uD83D\\uDE43\\n",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nvar romanToInt = function(s) {\\n      const sym = {\\n        \\'I\\': 1,\\n        \\'V\\': 5,\\n        \\'X\\': 10,\\n        \\'L\\': 50,\\n        \\'C\\': 100,\\n        \\'D\\': 500,\\n        \\'M\\': 1000\\n    }\\n\\n    let result = 0;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        const cur = sym[s[i]];\\n        const next = sym[s[i + 1]];\\n\\n        if (cur < next) {\\n            result += next - cur;\\n            i++;\\n        } else {\\n            result += cur;\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6542,
                "title": "4-lines-in-python",
                "content": "    d = {'M':1000, 'D':500, 'C':100, 'L':50, 'X':10, 'V':5, 'I':1}\\n    \\n    def romanToInt(self, s):\\n        res, p = 0, 'I'\\n        for c in s[::-1]:\\n            res, p = res - d[c] if d[c] < d[p] else res + d[c], c\\n        return res",
                "solutionTags": [],
                "code": "    d = {'M':1000, 'D':500, 'C':100, 'L':50, 'X':10, 'V':5, 'I':1}\\n    \\n    def romanToInt(self, s):\\n        res, p = 0, 'I'\\n        for c in s[::-1]:\\n            res, p = res - d[c] if d[c] < d[p] else res + d[c], c\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 6520,
                "title": "java-easy-version-to-understand",
                "content": "    \\tpublic static int romanToInt(String s) {\\n\\t\\tif (s == null || s.length() == 0)\\n\\t\\t\\treturn -1;\\n\\t\\tHashMap<Character, Integer> map = new HashMap<Character, Integer>();\\n\\t\\tmap.put('I', 1);\\n\\t\\tmap.put('V', 5);\\n\\t\\tmap.put('X', 10);\\n\\t\\tmap.put('L', 50);\\n\\t\\tmap.put('C', 100);\\n\\t\\tmap.put('D', 500);\\n\\t\\tmap.put('M', 1000);\\n\\t\\tint len = s.length(), result = map.get(s.charAt(len - 1));\\n\\t\\tfor (int i = len - 2; i >= 0; i--) {\\n\\t\\t\\tif (map.get(s.charAt(i)) >= map.get(s.charAt(i + 1)))\\n\\t\\t\\t\\tresult += map.get(s.charAt(i));\\n\\t\\t\\telse\\n\\t\\t\\t\\tresult -= map.get(s.charAt(i));\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    \\tpublic static int romanToInt(String s) {\\n\\t\\tif (s == null || s.length() == 0)\\n\\t\\t\\treturn -1;\\n\\t\\tHashMap<Character, Integer> map = new HashMap<Character, Integer>();\\n\\t\\tmap.put('I', 1);\\n\\t\\tmap.put('V', 5);\\n\\t\\tmap.put('X', 10);\\n\\t\\tmap.put('L', 50);\\n\\t\\tmap.put('C', 100);\\n\\t\\tmap.put('D', 500);\\n\\t\\tmap.put('M', 1000);\\n\\t\\tint len = s.length(), result = map.get(s.charAt(len - 1));\\n\\t\\tfor (int i = len - 2; i >= 0; i--) {\\n\\t\\t\\tif (map.get(s.charAt(i)) >= map.get(s.charAt(i + 1)))\\n\\t\\t\\t\\tresult += map.get(s.charAt(i));\\n\\t\\t\\telse\\n\\t\\t\\t\\tresult -= map.get(s.charAt(i));\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 450264,
                "title": "python-beginner-98-fast-100-memo",
                "content": "```\\ndef romanToInt(self, s: str) -> int:\\n\\tres, prev = 0, 0\\n\\tdict = {\\'I\\':1, \\'V\\':5, \\'X\\':10, \\'L\\':50, \\'C\\':100, \\'D\\':500, \\'M\\':1000}\\n\\tfor i in s[::-1]:          # rev the s\\n\\t\\tif dict[i] >= prev:\\n\\t\\t\\tres += dict[i]     # sum the value iff previous value same or more\\n\\t\\telse:\\n\\t\\t\\tres -= dict[i]     # substract when value is like \"IV\" --> 5-1, \"IX\" --> 10 -1 etc \\n\\t\\tprev = dict[i]\\n\\treturn res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef romanToInt(self, s: str) -> int:\\n\\tres, prev = 0, 0\\n\\tdict = {\\'I\\':1, \\'V\\':5, \\'X\\':10, \\'L\\':50, \\'C\\':100, \\'D\\':500, \\'M\\':1000}\\n\\tfor i in s[::-1]:          # rev the s\\n\\t\\tif dict[i] >= prev:\\n\\t\\t\\tres += dict[i]     # sum the value iff previous value same or more\\n\\t\\telse:\\n\\t\\t\\tres -= dict[i]     # substract when value is like \"IV\" --> 5-1, \"IX\" --> 10 -1 etc \\n\\t\\tprev = dict[i]\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 317457,
                "title": "c-concise-solution",
                "content": "```\\nint romanToInt(string s) {\\n\\tunordered_map<char, int> mp = {{\\'M\\', 1000}, {\\'D\\', 500}, {\\'C\\', 100}, {\\'L\\', 50}, {\\'X\\', 10}, {\\'V\\', 5}, {\\'I\\', 1}};\\n\\tint res = mp[s.back()];\\n\\tfor(int i = 0; i < s.size() - 1; i++) {\\n\\t\\tif(mp[s[i]] < mp[s[i + 1]]) res -= mp[s[i]];\\n\\t\\telse res += mp[s[i]];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint romanToInt(string s) {\\n\\tunordered_map<char, int> mp = {{\\'M\\', 1000}, {\\'D\\', 500}, {\\'C\\', 100}, {\\'L\\', 50}, {\\'X\\', 10}, {\\'V\\', 5}, {\\'I\\', 1}};\\n\\tint res = mp[s.back()];\\n\\tfor(int i = 0; i < s.size() - 1; i++) {\\n\\t\\tif(mp[s[i]] < mp[s[i + 1]]) res -= mp[s[i]];\\n\\t\\telse res += mp[s[i]];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3202671,
                "title": "best-c-solution-hash-table-math-string-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using String + Hash Table + Math.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(1), The maximum length of the string(s) can be 15 (as per the Constgraint), therefore, the worst case time complexity can be O(15) or O(1).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), We are using unordered_map(map) to store the Roman symbols and their corresponding integer values but there are only 7 symbols hence the worst case space complexity can be O(7) which is equivalent to O(1).\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(1), The maximum length of the string(s) can be 15 (as per the Constgraint), therefore, the\\n    worst case time complexity can be O(15) or O(1).\\n\\n    Space Complexity : O(1), We are using unordered_map(map) to store the Roman symbols and their corresponding\\n    integer values but there are only 7 symbols hence the worst case space complexity can be O(7) which is\\n    equivalent to O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char, int> map;\\n\\n        map[\\'I\\'] = 1;\\n        map[\\'V\\'] = 5;\\n        map[\\'X\\'] = 10;\\n        map[\\'L\\'] = 50;\\n        map[\\'C\\'] = 100;\\n        map[\\'D\\'] = 500;\\n        map[\\'M\\'] = 1000;\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(map[s[i]] < map[s[i+1]]){\\n                ans -= map[s[i]];\\n            }\\n            else{\\n                ans += map[s[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(1), The maximum length of the string(s) can be 15 (as per the Constgraint), therefore, the\\n    worst case time complexity can be O(15) or O(1).\\n\\n    Space Complexity : O(1), We are using unordered_map(map) to store the Roman symbols and their corresponding\\n    integer values but there are only 7 symbols hence the worst case space complexity can be O(7) which is\\n    equivalent to O(1).\\n\\n    Solved using String + Hash Table + Math.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char, int> map;\\n\\n        map[\\'I\\'] = 1;\\n        map[\\'V\\'] = 5;\\n        map[\\'X\\'] = 10;\\n        map[\\'L\\'] = 50;\\n        map[\\'C\\'] = 100;\\n        map[\\'D\\'] = 500;\\n        map[\\'M\\'] = 1000;\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(map[s[i]] < map[s[i+1]]){\\n                ans -= map[s[i]];\\n            }\\n            else{\\n                ans += map[s[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579590,
                "title": "java-efficient-easy-to-understand-with-explaination",
                "content": "First we use a hashmap to map the conversions of roman digits to integer.\\nNow, if a numeral with smaller value precedes one with a larger value, we subtract the value from the total, otherwise we add the value to the total.\\nAt the end, we still have to add the last character value.\\n```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        \\n        Map<Character, Integer> map = new HashMap();\\n        map.put(\\'I\\', 1);\\n        map.put(\\'V\\', 5);\\n        map.put(\\'X\\', 10);\\n        map.put(\\'L\\', 50);\\n        map.put(\\'C\\', 100);\\n        map.put(\\'D\\', 500);\\n        map.put(\\'M\\', 1000);\\n        \\n        int res = 0;\\n        for(int i = 0; i < s.length()-1; i++){\\n            if(map.get(s.charAt(i)) < map.get(s.charAt(i+1))) res -= map.get(s.charAt(i));\\n            else res += map.get(s.charAt(i));\\n        }\\n        return res + map.get(s.charAt(s.length()-1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        \\n        Map<Character, Integer> map = new HashMap();\\n        map.put(\\'I\\', 1);\\n        map.put(\\'V\\', 5);\\n        map.put(\\'X\\', 10);\\n        map.put(\\'L\\', 50);\\n        map.put(\\'C\\', 100);\\n        map.put(\\'D\\', 500);\\n        map.put(\\'M\\', 1000);\\n        \\n        int res = 0;\\n        for(int i = 0; i < s.length()-1; i++){\\n            if(map.get(s.charAt(i)) < map.get(s.charAt(i+1))) res -= map.get(s.charAt(i));\\n            else res += map.get(s.charAt(i));\\n        }\\n        return res + map.get(s.charAt(s.length()-1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136349,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    \\n    private let dict: [Character:Int] = [\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000]\\n    \\n    func romanToInt(_ s: String) -> Int {\\n        var prev = 0, out = 0\\n        for i in s {\\n            let val = dict[i] ?? 0\\n            out += val <= prev ? prev : -prev\\n            prev = val\\n        }\\n        out += prev\\n        return out\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.007 (0.008) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // III = 3\\n    func test0() {\\n        let value = solution.romanToInt(\"III\")\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    // L = 50, V = 5, III = 3\\n    func test1() {\\n        let value = solution.romanToInt(\"LVIII\")\\n        XCTAssertEqual(value, 58)\\n    }\\n    \\n    // M = 1000, CM = 900, XC = 90 and IV = 4\\n    func test2() {\\n        let value = solution.romanToInt(\"MCMXCIV\")\\n        XCTAssertEqual(value, 1994)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    \\n    private let dict: [Character:Int] = [\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000]\\n    \\n    func romanToInt(_ s: String) -> Int {\\n        var prev = 0, out = 0\\n        for i in s {\\n            let val = dict[i] ?? 0\\n            out += val <= prev ? prev : -prev\\n            prev = val\\n        }\\n        out += prev\\n        return out\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // III = 3\\n    func test0() {\\n        let value = solution.romanToInt(\"III\")\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    // L = 50, V = 5, III = 3\\n    func test1() {\\n        let value = solution.romanToInt(\"LVIII\")\\n        XCTAssertEqual(value, 58)\\n    }\\n    \\n    // M = 1000, CM = 900, XC = 90 and IV = 4\\n    func test2() {\\n        let value = solution.romanToInt(\"MCMXCIV\")\\n        XCTAssertEqual(value, 1994)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549678,
                "title": "python-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef romanToInt(self, s: str) -> int:\\n\\troman_dict = {\\n\\t\\t\\'I\\' :1,\\n\\t\\t\\'V\\' :5,\\n\\t\\t\\'X\\' :10,\\n\\t\\t\\'L\\' :50,\\n\\t\\t\\'C\\' :100,\\n\\t\\t\\'D\\' :500,\\n\\t\\t\\'M\\' :1000\\n\\t}\\n\\n\\ts = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"IIIIIIIII\")\\n\\ts = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"XXXXXXXXX\")\\n\\ts = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"CCCCCCCCC\")\\n\\n\\tres = 0\\n\\tfor char in s:\\n\\t\\tres += roman_dict[char]\\n\\n\\treturn res\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef romanToInt(self, s: str) -> int:\\n\\troman_dict = {\\n\\t\\t\\'I\\' :1,\\n\\t\\t\\'V\\' :5,\\n\\t\\t\\'X\\' :10,\\n\\t\\t\\'L\\' :50,\\n\\t\\t\\'C\\' :100,\\n\\t\\t\\'D\\' :500,\\n\\t\\t\\'M\\' :1000\\n\\t}\\n\\n\\ts = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"IIIIIIIII\")\\n\\ts = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"XXXXXXXXX\")\\n\\ts = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"CCCCCCCCC\")\\n\\n\\tres = 0\\n\\tfor char in s:\\n\\t\\tres += roman_dict[char]\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1960876,
                "title": "c-100-hashtable-solution-o-n",
                "content": "```\\nint romanToInt(char * s)\\n{\\n    int t[\\'X\\' + 1] = {\\n        [\\'I\\'] = 1,\\n        [\\'V\\'] = 5,\\n        [\\'X\\'] = 10,\\n        [\\'L\\'] = 50,\\n        [\\'C\\'] = 100,\\n        [\\'D\\'] = 500,\\n        [\\'M\\'] = 1000,\\n    };\\n    int res = 0;\\n    for (int i = 0; s[i]; i++) {\\n        if (t[s[i]] < t[s[i+1]])\\n            res -= t[s[i]];\\n        else\\n            res += t[s[i]];\\n    }\\n    return res;\\n}\\n```\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint romanToInt(char * s)\\n{\\n    int t[\\'X\\' + 1] = {\\n        [\\'I\\'] = 1,\\n        [\\'V\\'] = 5,\\n        [\\'X\\'] = 10,\\n        [\\'L\\'] = 50,\\n        [\\'C\\'] = 100,\\n        [\\'D\\'] = 500,\\n        [\\'M\\'] = 1000,\\n    };\\n    int res = 0;\\n    for (int i = 0; s[i]; i++) {\\n        if (t[s[i]] < t[s[i+1]])\\n            res -= t[s[i]];\\n        else\\n            res += t[s[i]];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271721,
                "title": "c-solution",
                "content": "Runtime: 12 ms, faster than 100.00% of C online submissions for Roman to Integer.\\nMemory Usage: 7 MB, less than 100.00% of C online submissions for Roman to Integer\\n```\\nint romanToInt(char* s) {\\n    int value[100];\\n    value[\\'I\\'] = 1;\\n    value[\\'V\\'] = 5;\\n    value[\\'X\\'] = 10;\\n    value[\\'L\\'] = 50;\\n    value[\\'C\\'] = 100;\\n    value[\\'D\\'] = 500;\\n    value[\\'M\\'] = 1000;\\n    value[\\'\\\\0\\'] = 0;\\n    int sum = 0;\\n    for(int i = 0; s[i] !=\\'\\\\0\\'; i++){\\n        if(value[s[i]] < value[s[i + 1]])\\n            sum = sum - value[s[i]];\\n        else\\n            sum += value[s[i]];\\n    }\\n    return sum;\\n}",
                "solutionTags": [],
                "code": "Runtime: 12 ms, faster than 100.00% of C online submissions for Roman to Integer.\\nMemory Usage: 7 MB, less than 100.00% of C online submissions for Roman to Integer\\n```\\nint romanToInt(char* s) {\\n    int value[100];\\n    value[\\'I\\'] = 1;\\n    value[\\'V\\'] = 5;\\n    value[\\'X\\'] = 10;\\n    value[\\'L\\'] = 50;\\n    value[\\'C\\'] = 100;\\n    value[\\'D\\'] = 500;\\n    value[\\'M\\'] = 1000;\\n    value[\\'\\\\0\\'] = 0;\\n    int sum = 0;\\n    for(int i = 0; s[i] !=\\'\\\\0\\'; i++){\\n        if(value[s[i]] < value[s[i + 1]])\\n            sum = sum - value[s[i]];\\n        else\\n            sum += value[s[i]];\\n    }\\n    return sum;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2869607,
                "title": "easiest-faang-method-ever",
                "content": "\\n# \\uD83D\\uDDEF\\uFE0FComplexity :-\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\uD83D\\uDDEF\\uFE0FCode :-\\n```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int res=0;\\n        s+=\\' \\';\\n        for(int i=0;i<s.size();){\\n            if(s[i]==\\'I\\' && s[i+1]==\\'V\\') { res+=4; i+=2;}\\n            else if(s[i]==\\'I\\' && s[i+1]==\\'X\\') { res+=9; i+=2;}\\n            else if(s[i]==\\'I\\') { res++; i++;}\\n            else if(s[i]==\\'V\\') { res+=5; i++;}\\n            else if(s[i]==\\'X\\' && s[i+1]==\\'L\\') { res+=40; i+=2;}\\n            else if(s[i]==\\'X\\' && s[i+1]==\\'C\\') { res+=90; i+=2;}\\n            else if(s[i]==\\'X\\') { res+=10; i++;} \\n            else if(s[i]==\\'L\\') { res+=50; i++;}\\n            else if(s[i]==\\'C\\' && s[i+1]==\\'M\\') { res+=900; i+=2;}\\n            else if(s[i]==\\'C\\' && s[i+1]==\\'D\\') { res+=400; i+=2;}\\n            else if(s[i]==\\'C\\') { res+=100; i++;}\\n            else if(s[i]==\\'D\\') { res+=500; i++;}\\n            else if(s[i]==\\'M\\') { res+=1000; i++;}\\n            else if(s[i]==\\' \\') break;\\n        }\\n        return res;\\n    }\\n};\\n```\\n# ***Please Upvote if it helps :) \\u2764\\uFE0F***\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int res=0;\\n        s+=\\' \\';\\n        for(int i=0;i<s.size();){\\n            if(s[i]==\\'I\\' && s[i+1]==\\'V\\') { res+=4; i+=2;}\\n            else if(s[i]==\\'I\\' && s[i+1]==\\'X\\') { res+=9; i+=2;}\\n            else if(s[i]==\\'I\\') { res++; i++;}\\n            else if(s[i]==\\'V\\') { res+=5; i++;}\\n            else if(s[i]==\\'X\\' && s[i+1]==\\'L\\') { res+=40; i+=2;}\\n            else if(s[i]==\\'X\\' && s[i+1]==\\'C\\') { res+=90; i+=2;}\\n            else if(s[i]==\\'X\\') { res+=10; i++;} \\n            else if(s[i]==\\'L\\') { res+=50; i++;}\\n            else if(s[i]==\\'C\\' && s[i+1]==\\'M\\') { res+=900; i+=2;}\\n            else if(s[i]==\\'C\\' && s[i+1]==\\'D\\') { res+=400; i+=2;}\\n            else if(s[i]==\\'C\\') { res+=100; i++;}\\n            else if(s[i]==\\'D\\') { res+=500; i++;}\\n            else if(s[i]==\\'M\\') { res+=1000; i++;}\\n            else if(s[i]==\\' \\') break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057336,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Python ***\\n\\n```\\n\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        translations = {\\n            \"I\": 1,\\n            \"V\": 5,\\n            \"X\": 10,\\n            \"L\": 50,\\n            \"C\": 100,\\n            \"D\": 500,\\n            \"M\": 1000\\n        }\\n        number = 0\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\\n        s = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\\n        s = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n        for char in s:\\n            number += translations[char]\\n        return number\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n***\"We are Anonymous. We are legion. We do not forgive. We do not forget. Expect us. Open your eyes..\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        translations = {\\n            \"I\": 1,\\n            \"V\": 5,\\n            \"X\": 10,\\n            \"L\": 50,\\n            \"C\": 100,\\n            \"D\": 500,\\n            \"M\": 1000\\n        }\\n        number = 0\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\\n        s = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\\n        s = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n        for char in s:\\n            number += translations[char]\\n        return number\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801395,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar romanToInt = function(s) {\\n    const map = { \\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000};\\n    let num = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        const curr = map[s[i]], next = map[s[i+1]];\\n        if(curr < next) num -= curr;\\n        else num += curr;\\n    }\\n    return num;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar romanToInt = function(s) {\\n    const map = { \\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000};\\n    let num = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        const curr = map[s[i]], next = map[s[i+1]];\\n        if(curr < next) num -= curr;\\n        else num += curr;\\n    }\\n    return num;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2109445,
                "title": "nice-and-clean-ts-js",
                "content": "You don\\'t need to map `CM`, `XC`, `\"IX\"`, `\"IV\"` separately. Eg.\\nwhen you parse `\"MCMXCIV\"` to an array of integers you get:\\n`[1000, 100, 1000, 10, 100, 1, 5]`, if you add them together (from left to right),\\nyou just need to check if next number is bigger, if so then you simply subtract\\nthat number: `1000 - 100 + 1000 - 10 + 100 - 1 + 5 = 1994`.\\n\\n```typescript\\nconst roman = {\\n  I: 1,\\n  V: 5,\\n  X: 10,\\n  L: 50,\\n  C: 100,\\n  D: 500,\\n  M: 1000,\\n};\\n\\nfunction romanToInt(s: string): number {\\n  const integers = s.split(\\'\\').map(c => roman[c]);\\n  \\n  return integers.reduce((acc, x, i) => x < integers[i+1] ? acc - x : acc + x, 0);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nconst roman = {\\n  I: 1,\\n  V: 5,\\n  X: 10,\\n  L: 50,\\n  C: 100,\\n  D: 500,\\n  M: 1000,\\n};\\n\\nfunction romanToInt(s: string): number {\\n  const integers = s.split(\\'\\').map(c => roman[c]);\\n  \\n  return integers.reduce((acc, x, i) => x < integers[i+1] ? acc - x : acc + x, 0);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6811,
                "title": "my-easy-to-understand-c-solutions",
                "content": "       class Solution {\\n        public:\\n            int romanToInt(string s) {\\n                int num = 0;\\n                int size = s.size();\\n                \\n                for (int i = 0; i < size; i++) {\\n                \\tif (i < (size - 1) && romanCharToInt(s[i]) < romanCharToInt(s[i + 1])) {\\n                \\t\\tnum -= romanCharToInt(s[i]);\\n                \\t} else {\\n        \\t\\t\\t\\tnum += romanCharToInt(s[i]);\\n        \\t\\t\\t}\\n                }\\n                return num;\\n            }\\n            \\n            int romanCharToInt(char c) {\\n            \\tswitch (c) {\\n            \\t\\tcase 'I': \\treturn 1;\\n            \\t\\tcase 'V':\\treturn 5;\\n            \\t\\tcase 'X':\\treturn 10;\\n            \\t\\tcase 'L':\\treturn 50;\\n            \\t\\tcase 'C':\\treturn 100;\\n            \\t\\tcase 'D':\\treturn 500;\\n            \\t\\tcase 'M':\\treturn 1000;\\n            \\t\\tdefault:\\treturn 0;\\n            \\t}\\n            }\\n        };\\n\\n[The code is faster][1] if the body of the for loop is replaced with:\\n\\n    \\tif (i < (size - 1) && (\\n    \\t\\t'I' == s[i] && ('V' == s[i + 1] || 'X' == s[i + 1]) ||\\n    \\t\\t'X' == s[i] && ('L' == s[i + 1] || 'C' == s[i + 1]) ||\\n    \\t\\t'C' == s[i] && ('D' == s[i + 1] || 'M' == s[i + 1]) )) {\\n    \\t\\tnum -= romanCharToInt(s[i]);\\n    \\t} else {\\n\\t\\t\\tnum += romanCharToInt(s[i]);\\n\\t\\t}\\n\\n \\n\\n\\n  [1]: http://xiaohuiliucuriosity.blogspot.com/2014/12/problem-given-roman-numeral-convert-it.html",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int romanToInt(string s) {\\n                int num = 0;\\n                int size = s.size();\\n                \\n                for (int i = 0; i < size; i++) {\\n                \\tif (i < (size - 1) && romanCharToInt(s[i]) < romanCharToInt(s[i + 1])) {\\n                \\t\\tnum -= romanCharToInt(s[i]);\\n                \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3016037,
                "title": "very-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe essentially start scanning adding all of the corresponding values for each character regardless of order. (e.g. \"IX\" is 11 not 9) Then, we check the order of the elements, and if we find that the order is reversed (i.e. \"IX\"), we make the necessary adjustment (e.g. for \"IX,\" we subtract 2)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Introduce the total sum variable, and the dictionary containing the corresponding number values for each Roman letter\\n2) We add all of the corresponding number values together regardless of order of elements\\n3) We check if certain ordered pairs are in the Roman number and make the adjustments if necessary\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        total = 0\\n        theDict = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n\\n        for i in s:\\n            total += theDict[i]\\n\\n        if \"IV\" in s:\\n            total -= 2\\n        if \"IX\" in s:\\n            total -= 2\\n        if \"XL\" in s:\\n            total -= 20\\n        if \"XC\" in s:\\n            total -= 20\\n        if \"CD\" in s:\\n            total -= 200\\n        if \"CM\" in s:\\n            total -= 200\\n\\n        \\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        total = 0\\n        theDict = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n\\n        for i in s:\\n            total += theDict[i]\\n\\n        if \"IV\" in s:\\n            total -= 2\\n        if \"IX\" in s:\\n            total -= 2\\n        if \"XL\" in s:\\n            total -= 20\\n        if \"XC\" in s:\\n            total -= 20\\n        if \"CD\" in s:\\n            total -= 200\\n        if \"CM\" in s:\\n            total -= 200\\n\\n        \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216662,
                "title": "easiest-beginner-friendly-sol-hashmap-c-java-python",
                "content": "# Intuition of this Problem:\\nThe given code is implementing the conversion of a Roman numeral string into an integer. It uses an unordered map to store the mapping between Roman numerals and their corresponding integer values. The algorithm takes advantage of the fact that in a valid Roman numeral string, the larger numeral always appears before the smaller numeral if the smaller numeral is subtracted from the larger one. Thus, it starts with the last character in the string and adds the corresponding value to the integer variable. Then, it iterates through the remaining characters from right to left and checks whether the current numeral is greater than or equal to the previous numeral. If it is greater, then it adds the corresponding value to the integer variable, otherwise, it subtracts the corresponding value from the integer variable.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Create an unordered map and store the mapping between Roman numerals and their corresponding integer values.\\n2. Reverse the input Roman numeral string.\\n3. Initialize an integer variable to 0.\\n4. Add the integer value corresponding to the last character in the string to the integer variable.\\n5. Iterate through the remaining characters from right to left.\\n6. Check whether the integer value corresponding to the current character is greater than or equal to the integer value corresponding to the previous character.\\n7. If it is greater, add the integer value to the integer variable.\\n8. If it is smaller, subtract the integer value from the integer variable.\\n9. Return the final integer variable.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char, int> storeKeyValue;\\n        storeKeyValue[\\'I\\'] = 1;\\n        storeKeyValue[\\'V\\'] = 5;\\n        storeKeyValue[\\'X\\'] = 10;\\n        storeKeyValue[\\'L\\'] = 50;\\n        storeKeyValue[\\'C\\'] = 100;\\n        storeKeyValue[\\'D\\'] = 500;\\n        storeKeyValue[\\'M\\'] = 1000;\\n        reverse(s.begin(), s.end());\\n        int integer = 0;\\n        integer += storeKeyValue[s[0]];\\n        for (int i = 1; i < s.length(); i++) {\\n            if(storeKeyValue[s[i]] >= storeKeyValue[s[i-1]])\\n                integer += storeKeyValue[s[i]];\\n            else\\n                integer -= storeKeyValue[s[i]];\\n        }\\n        return integer;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int romanToInt(String s) {\\n        HashMap<Character, Integer> storeKeyValue = new HashMap<>();\\n        storeKeyValue.put(\\'I\\', 1);\\n        storeKeyValue.put(\\'V\\', 5);\\n        storeKeyValue.put(\\'X\\', 10);\\n        storeKeyValue.put(\\'L\\', 50);\\n        storeKeyValue.put(\\'C\\', 100);\\n        storeKeyValue.put(\\'D\\', 500);\\n        storeKeyValue.put(\\'M\\', 1000);\\n        int integer = 0;\\n        integer += storeKeyValue.get(s.charAt(0));\\n        for (int i = 1; i < s.length(); i++) {\\n            if(storeKeyValue.get(s.charAt(i)) >= storeKeyValue.get(s.charAt(i-1)))\\n                integer += storeKeyValue.get(s.charAt(i));\\n            else\\n                integer -= storeKeyValue.get(s.charAt(i));\\n        }\\n        return integer;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        storeKeyValue = {}\\n        storeKeyValue[\\'I\\'] = 1\\n        storeKeyValue[\\'V\\'] = 5\\n        storeKeyValue[\\'X\\'] = 10\\n        storeKeyValue[\\'L\\'] = 50\\n        storeKeyValue[\\'C\\'] = 100\\n        storeKeyValue[\\'D\\'] = 500\\n        storeKeyValue[\\'M\\'] = 1000\\n        s = s[::-1]\\n        integer = 0\\n        integer += storeKeyValue[s[0]]\\n        for i in range(1, len(s)):\\n            if storeKeyValue[s[i]] >= storeKeyValue[s[i-1]]:\\n                integer += storeKeyValue[s[i]]\\n            else:\\n                integer -= storeKeyValue[s[i]]\\n        return integer\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(s.length()) = O(15) = O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(7) = O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char, int> storeKeyValue;\\n        storeKeyValue[\\'I\\'] = 1;\\n        storeKeyValue[\\'V\\'] = 5;\\n        storeKeyValue[\\'X\\'] = 10;\\n        storeKeyValue[\\'L\\'] = 50;\\n        storeKeyValue[\\'C\\'] = 100;\\n        storeKeyValue[\\'D\\'] = 500;\\n        storeKeyValue[\\'M\\'] = 1000;\\n        reverse(s.begin(), s.end());\\n        int integer = 0;\\n        integer += storeKeyValue[s[0]];\\n        for (int i = 1; i < s.length(); i++) {\\n            if(storeKeyValue[s[i]] >= storeKeyValue[s[i-1]])\\n                integer += storeKeyValue[s[i]];\\n            else\\n                integer -= storeKeyValue[s[i]];\\n        }\\n        return integer;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int romanToInt(String s) {\\n        HashMap<Character, Integer> storeKeyValue = new HashMap<>();\\n        storeKeyValue.put(\\'I\\', 1);\\n        storeKeyValue.put(\\'V\\', 5);\\n        storeKeyValue.put(\\'X\\', 10);\\n        storeKeyValue.put(\\'L\\', 50);\\n        storeKeyValue.put(\\'C\\', 100);\\n        storeKeyValue.put(\\'D\\', 500);\\n        storeKeyValue.put(\\'M\\', 1000);\\n        int integer = 0;\\n        integer += storeKeyValue.get(s.charAt(0));\\n        for (int i = 1; i < s.length(); i++) {\\n            if(storeKeyValue.get(s.charAt(i)) >= storeKeyValue.get(s.charAt(i-1)))\\n                integer += storeKeyValue.get(s.charAt(i));\\n            else\\n                integer -= storeKeyValue.get(s.charAt(i));\\n        }\\n        return integer;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        storeKeyValue = {}\\n        storeKeyValue[\\'I\\'] = 1\\n        storeKeyValue[\\'V\\'] = 5\\n        storeKeyValue[\\'X\\'] = 10\\n        storeKeyValue[\\'L\\'] = 50\\n        storeKeyValue[\\'C\\'] = 100\\n        storeKeyValue[\\'D\\'] = 500\\n        storeKeyValue[\\'M\\'] = 1000\\n        s = s[::-1]\\n        integer = 0\\n        integer += storeKeyValue[s[0]]\\n        for i in range(1, len(s)):\\n            if storeKeyValue[s[i]] >= storeKeyValue[s[i-1]]:\\n                integer += storeKeyValue[s[i]]\\n            else:\\n                integer -= storeKeyValue[s[i]]\\n        return integer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965594,
                "title": "python",
                "content": "Python\\n```\\n        rd = {\\n            \"I\" : 1,\\n            \"V\" : 5,\\n            \"X\" : 10,\\n            \"L\" : 50,\\n            \"C\" : 100,\\n            \"D\" : 500,\\n            \"M\" : 1000\\n        }\\n        \\n        n = len(s)\\n        rt = 0\\n        for i in range(n):\\n            if  i==n-1 or rd[s[i]] >= rd[s[i+1]] :\\n                rt += rd[s[i]]\\n            else :\\n                rt -= rd[s[i]]\\n                \\n        return rt\\n```",
                "solutionTags": [],
                "code": "```\\n        rd = {\\n            \"I\" : 1,\\n            \"V\" : 5,\\n            \"X\" : 10,\\n            \"L\" : 50,\\n            \"C\" : 100,\\n            \"D\" : 500,\\n            \"M\" : 1000\\n        }\\n        \\n        n = len(s)\\n        rt = 0\\n        for i in range(n):\\n            if  i==n-1 or rd[s[i]] >= rd[s[i+1]] :\\n                rt += rd[s[i]]\\n            else :\\n                rt -= rd[s[i]]\\n                \\n        return rt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 173267,
                "title": "javascript-solution",
                "content": "```javascript\\nconst romanToInt = s => {\\n  if (!s || s.length === 0) {\\n    return 0;\\n  }\\n\\n  const map = new Map([[\\'I\\', 1], [\\'V\\', 5], [\\'X\\', 10], [\\'L\\', 50], [\\'C\\', 100], [\\'D\\', 500], [\\'M\\', 1000]]);\\n\\n  let i = s.length - 1;\\n  let result = map.get(s[i]);\\n\\n  while (i > 0) {\\n    const curr = map.get(s[i]);\\n    const prev = map.get(s[i - 1]);\\n\\n    if (prev >= curr) {\\n      result += prev;\\n    } else {\\n      result -= prev;\\n    }\\n\\n    i--;\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst romanToInt = s => {\\n  if (!s || s.length === 0) {\\n    return 0;\\n  }\\n\\n  const map = new Map([[\\'I\\', 1], [\\'V\\', 5], [\\'X\\', 10], [\\'L\\', 50], [\\'C\\', 100], [\\'D\\', 500], [\\'M\\', 1000]]);\\n\\n  let i = s.length - 1;\\n  let result = map.get(s[i]);\\n\\n  while (i > 0) {\\n    const curr = map.get(s[i]);\\n    const prev = map.get(s[i - 1]);\\n\\n    if (prev >= curr) {\\n      result += prev;\\n    } else {\\n      result -= prev;\\n    }\\n\\n    i--;\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791875,
                "title": "python-3-simple-and-detailed-explanation",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nFirst things first: Because we need to look up the value of each roman charater multiple times, let\\'s store them in a dictionary called sym to have O(1) lookup.\\n\\nExample:\\nLooking at these characters is confusing. To come up with an algorithm, FIRST replace these characters with their numeral values and then forget about the roman letters.\\nLVIII: 50, 5, 1, 1, 1\\nXIV:  10, 1, 5\\nMCMXCIV: 1000, 100, 1000, 10, 100, 1, 5\\n\\nJust keep referencing the numbers and you\\'ll see that you have 2 choices to add the numbers:\\n1. left-to-right. I\\'ll leave left-to-right for you to solve and debate.\\n2. right-to-left.\\n\\nWhen we go right-to-left, we see the pattern:\\n1. we need to add current number if it is bigger than previous number or if both are same.\\n2. we subtract current number if current number is smaller than the previous number.\\n\\nExample: XIV (10, 1, 5)\\n1. We first add 5\\n2. In the next iteration, current is 1 and previous is 5. So, we subtract 1 from result\\n3. In next iteration, current is 10 and previous is 1. So, we add 10 to the result\\n\\nNow try this with other example: MCMXCIV.\\n\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sym = {\\n            \"I\" : 1,\\n            \"V\" : 5,\\n            \"X\" : 10,\\n            \"L\" : 50,\\n            \"C\" : 100,\\n            \"D\" : 500,\\n            \"M\" : 1000\\n        }\\n        \\n        result = 0\\n        prev = 0\\n        \\n        for c in reversed(s):\\n            if sym[c] >= prev:\\n                result += sym[c]\\n            else:\\n                result -= sym[c]\\n            prev = sym[c]\\n            \\n        return result\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sym = {\\n            \"I\" : 1,\\n            \"V\" : 5,\\n            \"X\" : 10,\\n            \"L\" : 50,\\n            \"C\" : 100,\\n            \"D\" : 500,\\n            \"M\" : 1000\\n        }\\n        \\n        result = 0\\n        prev = 0\\n        \\n        for c in reversed(s):\\n            if sym[c] >= prev:\\n                result += sym[c]\\n            else:\\n                result -= sym[c]\\n            prev = sym[c]\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362651,
                "title": "c-runtime-94-and-memory-98-o-n",
                "content": "This solution uses a switch case to reduce memory usage as well as a method scope `currentValue` Variable which enables the code to reuse the memory and thus drastically reduce memory usage. Simple for loop means solution is O(n), n being the length of the string.\\n\\nThe Results : \\nRuntime: 80 ms, faster than 93.83% of C# online submissions for Roman to Integer.\\nMemory Usage: 25.9 MB, less than 97.87% of C# online submissions for Roman to Integer.\\n\\n```\\npublic class Solution {\\n    public int RomanToInt(string s) {\\n\\n        var chars = s.ToCharArray();\\n        var result = 0;\\n        var currentValue = 0;\\n        for(var i = 0; i < chars.Length - 1; i++){\\n            currentValue = RomanNumerals(chars[i]);\\n            result += (RomanNumerals(chars[i+1]) > currentValue ? -1 : 1) * currentValue;\\n        }\\n        \\n        return result +  RomanNumerals(chars[chars.Length - 1]);\\n    }\\n    \\n    public int RomanNumerals(char c)\\n    {\\n        switch(c){\\n            case \\'I\\' : return 1;\\n            case \\'V\\' : return 5;\\n            case \\'X\\' : return 10;\\n            case \\'L\\' : return 50;\\n            case \\'C\\' : return 100;\\n            case \\'D\\' : return 500;\\n            case \\'M\\' : return 1000;\\n        };  \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int RomanToInt(string s) {\\n\\n        var chars = s.ToCharArray();\\n        var result = 0;\\n        var currentValue = 0;\\n        for(var i = 0; i < chars.Length - 1; i++){\\n            currentValue = RomanNumerals(chars[i]);\\n            result += (RomanNumerals(chars[i+1]) > currentValue ? -1 : 1) * currentValue;\\n        }\\n        \\n        return result +  RomanNumerals(chars[chars.Length - 1]);\\n    }\\n    \\n    public int RomanNumerals(char c)\\n    {\\n        switch(c){\\n            case \\'I\\' : return 1;\\n            case \\'V\\' : return 5;\\n            case \\'X\\' : return 10;\\n            case \\'L\\' : return 50;\\n            case \\'C\\' : return 100;\\n            case \\'D\\' : return 500;\\n            case \\'M\\' : return 1000;\\n        };  \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968469,
                "title": "javascript",
                "content": "Runtime: 172 ms, faster than 48.97% of JavaScript online submissions for Roman to Integer.\\nMemory Usage: 43.7 MB, less than 97.40% of JavaScript online submissions for Roman to Integer.\\n\\n```function romanToInt(s) {\\n  const legend = {\\n    I:1,\\n    V:5,\\n    X:10,\\n    L:50,\\n    C:100,\\n    D:500,\\n    M:1000\\n  };\\n  let total = 0;\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (legend[s[i]] < legend[s[i+1]]) {\\n      total += legend[s[i+1]] - legend[s[i]];\\n      i++;\\n    } else {\\n      total += legend[s[i]];\\n    }\\n  }\\n\\n  return total;\\n};",
                "solutionTags": [],
                "code": "Runtime: 172 ms, faster than 48.97% of JavaScript online submissions for Roman to Integer.\\nMemory Usage: 43.7 MB, less than 97.40% of JavaScript online submissions for Roman to Integer.\\n\\n```function romanToInt(s) {\\n  const legend = {\\n    I:1,\\n    V:5,\\n    X:10,\\n    L:50,\\n    C:100,\\n    D:500,\\n    M:1000\\n  };\\n  let total = 0;\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (legend[s[i]] < legend[s[i+1]]) {\\n      total += legend[s[i+1]] - legend[s[i]];\\n      i++;\\n    } else {\\n      total += legend[s[i]];\\n    }\\n  }\\n\\n  return total;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 6802,
                "title": "java-solution-clean-and-simple-7-ms",
                "content": "    public int romanToInt(String str) {\\n        int[] a = new int[26];\\n        a['I' - 'A'] = 1;\\n        a['V' - 'A'] = 5;\\n        a['X' - 'A'] = 10;\\n        a['L' - 'A'] = 50;\\n        a['C' - 'A'] = 100;\\n        a['D' - 'A'] = 500;\\n        a['M' - 'A'] = 1000;\\n        char prev = 'A';\\n        int sum = 0;\\n        for(char s : str.toCharArray()) {\\n            if(a[s - 'A'] > a[prev - 'A']) {\\n                sum = sum - 2 * a[prev - 'A'];\\n            }\\n            sum = sum + a[s - 'A'];\\n            prev = s;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int romanToInt(String str) {\\n        int[] a = new int[26];\\n        a['I' - 'A'] = 1;\\n        a['V' - 'A'] = 5;\\n        a['X' - 'A'] = 10;\\n        a['L' - 'A'] = 50;\\n        a['C' - 'A'] = 100;\\n        a['D' - 'A'] = 500;\\n        a['M' - 'A'] = 1000;\\n        char prev = 'A';\\n        int sum = 0;\\n        for(char s : str.toCharArray()) {\\n            if(a[s - 'A'] > a[prev - 'A']) {\\n                sum = sum - 2 * a[prev - 'A'];\\n            }\\n            sum = sum + a[s - 'A'];\\n            prev = s;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1691350,
                "title": "python-fastest-solution",
                "content": "IV and VI both were being treated as 6. \\nSimilarly IX and XI both were treated as 11.\\n\\nSo I put a condition whenever it encounters IV or IX then subtract 2\\n\\nSimilarily if XL or XC then subtract 20, \\'CD\\' or \\'CM\\' then subtract 200\\n\\nLike my logic? An upvote won\\'t cost you anything ;)\\n```\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        roman_dict={\\'I\\':1,\\'V\\':5,\\'X\\':10,\\'L\\':50,\\'C\\':100,\\'D\\':500,\\'M\\':1000}\\n        x=0\\n        \\n        for i in s:\\n           x+=roman_dict[i]\\n        \\n        \\n        if \\'IV\\' in s or \\'IX\\' in s:\\n            \\n            x-=2\\n        if \\'XL\\' in s or \\'XC\\' in s:\\n            \\n            x-=20\\n        if \\'CD\\' in s or \\'CM\\' in s:\\n            \\n            x-=200\\n        \\n        return x\\n```\\nLike my logic? An upvote won\\'t cost you anything",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        roman_dict={\\'I\\':1,\\'V\\':5,\\'X\\':10,\\'L\\':50,\\'C\\':100,\\'D\\':500,\\'M\\':1000}\\n        x=0\\n        \\n        for i in s:\\n           x+=roman_dict[i]\\n        \\n        \\n        if \\'IV\\' in s or \\'IX\\' in s:\\n            \\n            x-=2\\n        if \\'XL\\' in s or \\'XC\\' in s:\\n            \\n            x-=20\\n        if \\'CD\\' in s or \\'CM\\' in s:\\n            \\n            x-=200\\n        \\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745583,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        r={\\'I\\':1,\\'V\\':5,\\'X\\':10,\\'L\\':50,\\'C\\':100,\\'D\\':500,\\'M\\':1000}\\n        tot=0\\n        for i in range(len(s)-1):\\n            if r[s[i]] < r[s[i+1]]:\\n                tot-=r[s[i]]\\n            else:\\n                tot+=r[s[i]]\\n        tot+=r[s[-1]]\\n        return tot\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        r={\\'I\\':1,\\'V\\':5,\\'X\\':10,\\'L\\':50,\\'C\\':100,\\'D\\':500,\\'M\\':1000}\\n        tot=0\\n        for i in range(len(s)-1):\\n            if r[s[i]] < r[s[i+1]]:\\n                tot-=r[s[i]]\\n            else:\\n                tot+=r[s[i]]\\n        tot+=r[s[-1]]\\n        return tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941583,
                "title": "python-3-solution-less-than-98-memory-usage-with-explanation",
                "content": "Take one example:\\nPre-calculate for \"IV\" which represent -2.\\nNote: If you traversal from string, you will count \"I\", \"V\", \"IV\" => 5 + 1 + (-2) = 4.\\nSo I put \"IV\" to -2.\\n\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        mapping = {\\n            \"I\": 1,\\n            \"V\": 5,\\n            \"X\": 10,\\n            \"L\": 50,\\n            \"C\": 100,\\n            \"D\": 500,\\n            \"M\": 1000,\\n            \"IV\": -2,\\n            \"IX\": -2,\\n            \"XL\": -20,\\n            \"XC\": -20,\\n            \"CD\": -200,\\n            \"CM\": -200,\\n        }\\n        sum = 0\\n        for symbol, val in mapping.items():\\n            sum += s.count(symbol) * val\\n        return sum\\n```\\n\\nIf you like it please upvote!\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        mapping = {\\n            \"I\": 1,\\n            \"V\": 5,\\n            \"X\": 10,\\n            \"L\": 50,\\n            \"C\": 100,\\n            \"D\": 500,\\n            \"M\": 1000,\\n            \"IV\": -2,\\n            \"IX\": -2,\\n            \"XL\": -20,\\n            \"XC\": -20,\\n            \"CD\": -200,\\n            \"CM\": -200,\\n        }\\n        sum = 0\\n        for symbol, val in mapping.items():\\n            sum += s.count(symbol) * val\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917058,
                "title": "easy-c-solution",
                "content": "We can parse the string from right to left and then subtract from grand total if the last value parsed is bigger than the current value.\\n```\\n    public int RomanToInt(string s) {\\n        var map = new Dictionary<char, int>();\\n            map.Add(\\'I\\', 1);\\n            map.Add(\\'V\\', 5);\\n            map.Add(\\'X\\', 10);\\n            map.Add(\\'L\\', 50);\\n            map.Add(\\'C\\', 100);\\n            map.Add(\\'D\\', 500);\\n            map.Add(\\'M\\', 1000);\\n            int sum = 0;\\n            int last = 0;\\n            for (int i = s.Length - 1; i >= 0; i--)\\n            {\\n                int current = map[s[i]];\\n                if ( current < last)\\n                {\\n                    sum -= current;\\n                }\\n                else\\n                {\\n                    sum += current;\\n                }\\n\\n                last = current;\\n            }\\n            return sum;\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n    public int RomanToInt(string s) {\\n        var map = new Dictionary<char, int>();\\n            map.Add(\\'I\\', 1);\\n            map.Add(\\'V\\', 5);\\n            map.Add(\\'X\\', 10);\\n            map.Add(\\'L\\', 50);\\n            map.Add(\\'C\\', 100);\\n            map.Add(\\'D\\', 500);\\n            map.Add(\\'M\\', 1000);\\n            int sum = 0;\\n            int last = 0;\\n            for (int i = s.Length - 1; i >= 0; i--)\\n            {\\n                int current = map[s[i]];\\n                if ( current < last)\\n                {\\n                    sum -= current;\\n                }\\n                else\\n                {\\n                    sum += current;\\n                }\\n\\n                last = current;\\n            }\\n            return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 281138,
                "title": "simple-java-solution-100-time",
                "content": "```\\npublic int romanToInt(String s) {\\n        int n = 0;\\n        char prev = \\' \\';\\n        for (byte i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            n += getValue(c, prev);\\n            prev = c;\\n        }\\n        \\n        return n;\\n    }\\n    \\n    private int getValue(char c, char prev) {\\n        switch (c) {\\n            case \\'I\\':\\n                return 1;\\n            case \\'V\\':\\n                return prev == \\'I\\' ? 3 : 5;\\n            case \\'X\\':\\n                return prev == \\'I\\' ? 8 : 10;\\n            case \\'L\\':\\n                return prev == \\'X\\' ? 30 : 50;\\n            case \\'C\\':\\n                return prev == \\'X\\' ? 80 : 100;\\n            case \\'D\\':\\n                return prev == \\'C\\' ? 300 : 500;\\n            case \\'M\\':\\n                return prev == \\'C\\' ? 800 : 1000;\\n        }\\n        \\n        throw new IllegalArgumentException();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int romanToInt(String s) {\\n        int n = 0;\\n        char prev = \\' \\';\\n        for (byte i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            n += getValue(c, prev);\\n            prev = c;\\n        }\\n        \\n        return n;\\n    }\\n    \\n    private int getValue(char c, char prev) {\\n        switch (c) {\\n            case \\'I\\':\\n                return 1;\\n            case \\'V\\':\\n                return prev == \\'I\\' ? 3 : 5;\\n            case \\'X\\':\\n                return prev == \\'I\\' ? 8 : 10;\\n            case \\'L\\':\\n                return prev == \\'X\\' ? 30 : 50;\\n            case \\'C\\':\\n                return prev == \\'X\\' ? 80 : 100;\\n            case \\'D\\':\\n                return prev == \\'C\\' ? 300 : 500;\\n            case \\'M\\':\\n                return prev == \\'C\\' ? 800 : 1000;\\n        }\\n        \\n        throw new IllegalArgumentException();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6776,
                "title": "java-clean-and-fast-solution",
                "content": "        public int romanToInt(String s) {\\n            int num = 0;\\n            int l = s.length();\\n            int last = 1000;\\n            for (int i = 0; i < l; i++){\\n                int v = getValue(s.charAt(i));\\n                if (v > last) num = num - last * 2;\\n                num = num + v;\\n                last = v;\\n            }\\n            return num;\\n        }\\n        private int getValue(char c){\\n            switch(c){\\n                case 'I' : return 1;\\n                case 'V' : return 5;\\n                case 'X' : return 10;\\n                case 'L' : return 50;\\n                case 'C' : return 100;\\n                case 'D' : return 500;\\n                case 'M' : return 1000;\\n                default : return 0;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        public int romanToInt(String s) {\\n            int num = 0;\\n            int l = s.length();\\n            int last = 1000;\\n            for (int i = 0; i < l; i++){\\n                int v = getValue(s.charAt(i));\\n                if (v > last) num = num - last * 2;\\n                num = num + v;\\n                last = v;\\n            }\\n            return num;\\n        }\\n        private int getValue(char c){\\n            switch(c){\\n                case 'I' : return 1;\\n                case 'V' : return 5;\\n                case 'X' : return 10;\\n                case 'L' : return 50;\\n                case 'C' : return 100;\\n                case 'D' : return 500;\\n                case 'M' : return 1000;\\n                default : return 0;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2396734,
                "title": "java-solution-using-haspmap-faster-than-100-easy-to-understand",
                "content": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer>map=new HashMap<>();\\n        map.put(\\'I\\', 1);\\n        map.put(\\'V\\', 5);\\n        map.put(\\'X\\', 10);\\n        map.put(\\'L\\', 50);\\n        map.put(\\'C\\', 100);\\n        map.put(\\'D\\', 500);\\n        map.put(\\'M\\', 1000);\\n        \\n        \\n        int result=map.get(s.charAt(s.length()-1));\\n        \\n        for(int i=s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                result-=map.get(s.charAt(i));\\n            }else{\\n                result+=map.get(s.charAt(i));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\'\\'\\'\\n.****Plz upvote if you find it USEFUL. May you will get all you deserve .Hard work will payOff",
                "solutionTags": [],
                "code": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer>map=new HashMap<>();\\n        map.put(\\'I\\', 1);\\n        map.put(\\'V\\', 5);\\n        map.put(\\'X\\', 10);\\n        map.put(\\'L\\', 50);\\n        map.put(\\'C\\', 100);\\n        map.put(\\'D\\', 500);\\n        map.put(\\'M\\', 1000);\\n        \\n        \\n        int result=map.get(s.charAt(s.length()-1));\\n        \\n        for(int i=s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                result-=map.get(s.charAt(i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3302492,
                "title": "hashmap-solution-java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer>map=new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int value=0;\\n        for(int i=0;i<s.length();i++){\\n            if(i<s.length()-1 && map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                value-=map.get(s.charAt(i));\\n            }\\n            else{\\n                value+=map.get(s.charAt(i));\\n            }\\n        }\\n        return value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer>map=new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int value=0;\\n        for(int i=0;i<s.length();i++){\\n            if(i<s.length()-1 && map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                value-=map.get(s.charAt(i));\\n            }\\n            else{\\n                value+=map.get(s.charAt(i));\\n            }\\n        }\\n        return value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283708,
                "title": "java-without-map-3ms",
                "content": "We don\\'t need to use Extra memory. This problem can be solved easily without using any Map.\\nHelper method:\\n```\\n int getValue(char c){\\n        if(c==\\'I\\') return 1;\\n        else if(c==\\'V\\') return 5;\\n        else if(c==\\'X\\') return 10;\\n        else if(c==\\'L\\') return 50;\\n        else if(c==\\'C\\') return 100;\\n        else if(c==\\'D\\') return 500;\\n        else return 1000;\\n    }\\n```\\n\\nMain logic \\n```\\nfor(int i=0;i<n-1;i++){\\n            int a = getValue(s.charAt(i));\\n            int b = getValue(s.charAt(i+1));\\n            if(a<b){\\n                res-=a;\\n            }else{\\n                res+=a;\\n            }           \\n        }\\n        res += getValue(s.charAt(n-1)); \\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n int getValue(char c){\\n        if(c==\\'I\\') return 1;\\n        else if(c==\\'V\\') return 5;\\n        else if(c==\\'X\\') return 10;\\n        else if(c==\\'L\\') return 50;\\n        else if(c==\\'C\\') return 100;\\n        else if(c==\\'D\\') return 500;\\n        else return 1000;\\n    }\\n```\n```\\nfor(int i=0;i<n-1;i++){\\n            int a = getValue(s.charAt(i));\\n            int b = getValue(s.charAt(i+1));\\n            if(a<b){\\n                res-=a;\\n            }else{\\n                res+=a;\\n            }           \\n        }\\n        res += getValue(s.charAt(n-1)); \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 357734,
                "title": "python-solution-with-explanantion",
                "content": "The idea is to walk each letter of the roman integer in sequence and undo previous addition in the case the previous roman numeral is less than the current one.\\n\\n```python\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        roman_to_int = {\\n            \\'I\\' : 1,\\n            \\'V\\' : 5,\\n            \\'X\\' : 10,\\n            \\'L\\' : 50,\\n            \\'C\\' : 100,\\n            \\'D\\' : 500,\\n            \\'M\\' : 1000\\n        }\\n        \\n        result = 0\\n        prev_value = 0\\n        for letter in s:\\n            value = roman_to_int[letter]\\n            result += value\\n            if value > prev_value:\\n                # preceding roman nummber is smaller\\n                # we need to undo the previous addition\\n                # and substract the preceding roman char\\n                # from the current one, i.e. we need to\\n                # substract twice the previous roman char\\n                result -= 2 * prev_value\\n            prev_value = value\\n        return result\\n```\\n\\nFor other solutions you can have a look at my other post\\n\\n[Other solutions](https://leetcode.com/problems/roman-to-integer/discuss/323556/Python-solution-based-on-dictionary-with-look-ahead)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        roman_to_int = {\\n            \\'I\\' : 1,\\n            \\'V\\' : 5,\\n            \\'X\\' : 10,\\n            \\'L\\' : 50,\\n            \\'C\\' : 100,\\n            \\'D\\' : 500,\\n            \\'M\\' : 1000\\n        }\\n        \\n        result = 0\\n        prev_value = 0\\n        for letter in s:\\n            value = roman_to_int[letter]\\n            result += value\\n            if value > prev_value:\\n                # preceding roman nummber is smaller\\n                # we need to undo the previous addition\\n                # and substract the preceding roman char\\n                # from the current one, i.e. we need to\\n                # substract twice the previous roman char\\n                result -= 2 * prev_value\\n            prev_value = value\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642767,
                "title": "golang-solution-0ms",
                "content": "To avoid many check I use ```var lv``` (last value) for define sign of current operations.\\n\\nRuntime: 0 ms, faster than 100.00% \\nMemory Usage: 3 MB, less than 40.11% (removing usages ```h,lv,cv``` variables doesn\\'t help to improve memory usage)\\n\\n```\\nfunc romanToInt(s string) int {\\n\\tvar v, lv, cv int\\n\\th := map[uint8]int{\\n\\t\\t\\'I\\': 1,\\n\\t\\t\\'V\\': 5,\\n\\t\\t\\'X\\': 10,\\n\\t\\t\\'L\\': 50,\\n\\t\\t\\'C\\': 100,\\n\\t\\t\\'D\\': 500,\\n\\t\\t\\'M\\': 1000,\\n\\t}\\n\\n    for i := len(s) - 1; i >= 0; i-- {\\n\\t\\tcv = h[s[i]]\\n\\t\\tif cv < lv {\\n\\t\\t\\tv -= cv\\n\\t\\t} else {\\n\\t\\t\\tv += cv\\n\\t\\t}\\n\\t\\tlv = cv\\n\\t}\\n\\n\\treturn v\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```var lv```\n```h,lv,cv```\n```\\nfunc romanToInt(s string) int {\\n\\tvar v, lv, cv int\\n\\th := map[uint8]int{\\n\\t\\t\\'I\\': 1,\\n\\t\\t\\'V\\': 5,\\n\\t\\t\\'X\\': 10,\\n\\t\\t\\'L\\': 50,\\n\\t\\t\\'C\\': 100,\\n\\t\\t\\'D\\': 500,\\n\\t\\t\\'M\\': 1000,\\n\\t}\\n\\n    for i := len(s) - 1; i >= 0; i-- {\\n\\t\\tcv = h[s[i]]\\n\\t\\tif cv < lv {\\n\\t\\t\\tv -= cv\\n\\t\\t} else {\\n\\t\\t\\tv += cv\\n\\t\\t}\\n\\t\\tlv = cv\\n\\t}\\n\\n\\treturn v\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426510,
                "title": "daily-leetcoding-challenge-august-day-15",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/roman-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left-to-Right Pass\n\n  \n**Approach 2:** Left-to-Right Pass Improved\n\n  \n**Approach 3:** Right-to-Left Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/roman-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 374718,
                "title": "rust-pattern-matching-without-extra-allocation",
                "content": "- With only 2.3MiB memory usage and 100% ranking\\n- Only use pattern guard expression (MatchArmGuard)\\n\\n```rust\\nimpl Solution {\\n    pub fn roman_to_int(s: String) -> i32 {\\n        s.chars().rfold(0, |acc, c| {\\n            acc + match c {\\n                \\'I\\' if acc >= 5 => -1,\\n                \\'I\\' => 1,\\n                \\'V\\' => 5,\\n                \\'X\\' if acc >= 50 => -10,\\n                \\'X\\' => 10,\\n                \\'L\\' => 50,\\n                \\'C\\' if acc >= 500 => -100,\\n                \\'C\\' => 100,\\n                \\'D\\' => 500,\\n                \\'M\\' => 1000,\\n                _ => 0,\\n            }\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn roman_to_int(s: String) -> i32 {\\n        s.chars().rfold(0, |acc, c| {\\n            acc + match c {\\n                \\'I\\' if acc >= 5 => -1,\\n                \\'I\\' => 1,\\n                \\'V\\' => 5,\\n                \\'X\\' if acc >= 50 => -10,\\n                \\'X\\' => 10,\\n                \\'L\\' => 50,\\n                \\'C\\' if acc >= 500 => -100,\\n                \\'C\\' => 100,\\n                \\'D\\' => 500,\\n                \\'M\\' => 1000,\\n                _ => 0,\\n            }\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6862,
                "title": "python-solution",
                "content": "        def romanToInt(self, s):\\n\\n            romans = {'M': 1000, 'D': 500 , 'C': 100, 'L': 50, 'X': 10,'V': 5,'I': 1}\\n\\n            prev_value = running_total =0\\n            \\n            for i in range(len(s)-1, -1, -1):\\n                int_val = romans[s[i]]\\n                if int_val < prev_value:\\n                    running_total -= int_val\\n                else:\\n                    running_total += int_val\\n                prev_value = int_val\\n            \\n            return running_total",
                "solutionTags": [],
                "code": "        def romanToInt(self, s):\\n\\n            romans = {'M': 1000, 'D': 500 , 'C': 100, 'L': 50, 'X': 10,'V': 5,'I': 1}\\n\\n            prev_value = running_total =0\\n            \\n            for i in range(len(s)-1, -1, -1):\\n                int_val = romans[s[i]]\\n                if int_val < prev_value:\\n                    running_total -= int_val\\n                else:\\n                    running_total += int_val\\n                prev_value = int_val\\n            \\n            return running_total",
                "codeTag": "Python3"
            },
            {
                "id": 2727174,
                "title": "c-java-python3-javascript-solution-easy-understanding",
                "content": "### C#,Java,Python3,JavaScript different solution with explanation\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/)\\u2B50**\\n\\n**\\uD83E\\uDDE1See next question solution - [Zyrastory-Longest Common Prefix](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)**\\n\\n\\n#### **Example : C# Code ( You can also find an easier solution in the post )**\\n```\\npublic class Solution {\\n    private readonly Dictionary<char, int> dict = new Dictionary<char, int>{{\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},{\\'M\\',1000}};\\n    \\n    public int RomanToInt(string s) {\\n   \\n        char[] ch = s.ToCharArray();\\n    \\n        int result = 0;\\n        int intVal,nextIntVal;\\n            \\n        for(int i = 0; i <ch.Length ; i++){\\n            intVal = dict[ch[i]];\\n            \\n            if(i != ch.Length-1)\\n            {\\n                nextIntVal = dict[ch[i+1]];\\n                \\n                if(nextIntVal>intVal){\\n                    intVal = nextIntVal-intVal;\\n                    i = i+1;\\n                }\\n            }\\n             result = result + intVal;\\n        }\\n        return result;\\n    }\\n}\\n```\\n**\\u2B06To see other languages please click the link above\\u2B06**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know (leave comment or messenger me).\\n\\n**Thanks!**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\npublic class Solution {\\n    private readonly Dictionary<char, int> dict = new Dictionary<char, int>{{\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},{\\'M\\',1000}};\\n    \\n    public int RomanToInt(string s) {\\n   \\n        char[] ch = s.ToCharArray();\\n    \\n        int result = 0;\\n        int intVal,nextIntVal;\\n            \\n        for(int i = 0; i <ch.Length ; i++){\\n            intVal = dict[ch[i]];\\n            \\n            if(i != ch.Length-1)\\n            {\\n                nextIntVal = dict[ch[i+1]];\\n                \\n                if(nextIntVal>intVal){\\n                    intVal = nextIntVal-intVal;\\n                    i = i+1;\\n                }\\n            }\\n             result = result + intVal;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869577,
                "title": "easy-solution-hashmap-10ms-java",
                "content": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int sum = 0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(i<s.length()-1 && map.get(s.charAt(i)) < map.get(s.charAt(i+1)))\\n            {\\n                sum -= map.get(s.charAt(i));\\n            }\\n            else{\\n                sum += map.get(s.charAt(i));\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```\\n**If you liked my solution Please UPVOTE**\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int sum = 0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(i<s.length()-1 && map.get(s.charAt(i)) < map.get(s.charAt(i+1)))\\n            {\\n                sum -= map.get(s.charAt(i));\\n            }\\n            else{\\n                sum += map.get(s.charAt(i));\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092109,
                "title": "c-solution-using-a-switch-statement",
                "content": "```\\nint getValue(const char * s){\\n    switch(*s) {\\n        case \\'I\\': return (s[1] == \\'V\\' || s[1] == \\'X\\') ? -1 : 1;\\n        case \\'X\\': return (s[1] == \\'L\\' || s[1] == \\'C\\') ? -10 : 10;\\n        case \\'C\\': return (s[1] == \\'D\\' || s[1] == \\'M\\') ? -100 : 100;\\n        case \\'V\\': return 5;\\n        case \\'L\\': return 50;\\n        case \\'D\\': return 500;\\n        case \\'M\\': return 1000;\\n    }\\n    return 0;\\n}\\n\\nint romanToInt(char * s){\\n    int result = 0; \\n    \\n    for(;*s != \\'\\\\0\\'; ++s) {\\n        result += getValue(s);\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint getValue(const char * s){\\n    switch(*s) {\\n        case \\'I\\': return (s[1] == \\'V\\' || s[1] == \\'X\\') ? -1 : 1;\\n        case \\'X\\': return (s[1] == \\'L\\' || s[1] == \\'C\\') ? -10 : 10;\\n        case \\'C\\': return (s[1] == \\'D\\' || s[1] == \\'M\\') ? -100 : 100;\\n        case \\'V\\': return 5;\\n        case \\'L\\': return 50;\\n        case \\'D\\': return 500;\\n        case \\'M\\': return 1000;\\n    }\\n    return 0;\\n}\\n\\nint romanToInt(char * s){\\n    int result = 0; \\n    \\n    for(;*s != \\'\\\\0\\'; ++s) {\\n        result += getValue(s);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123615,
                "title": "my-java-solution",
                "content": "```\\nprivate static final Map<Character, Integer> NUMS = new HashMap<Character, Integer>(){{\\n    put(\\'I\\', 1);\\n    put(\\'V\\', 5);\\n    put(\\'X\\', 10);\\n    put(\\'L\\', 50);\\n    put(\\'C\\', 100);\\n    put(\\'D\\', 500);\\n    put(\\'M\\', 1000);\\n}};\\n\\nprivate static int convertToInt(String s) {\\n\\tint r = 0;\\n\\tint prev = 0;\\n\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tint v = NUMS.get(c);\\n        r = ((v > prev) ? r - prev + (v - prev) : r + v);\\n        prev = v;\\n\\t}\\n\\n\\treturn r;\\n}\\n```\\n\\nIt\\'s full code",
                "solutionTags": [],
                "code": "```\\nprivate static final Map<Character, Integer> NUMS = new HashMap<Character, Integer>(){{\\n    put(\\'I\\', 1);\\n    put(\\'V\\', 5);\\n    put(\\'X\\', 10);\\n    put(\\'L\\', 50);\\n    put(\\'C\\', 100);\\n    put(\\'D\\', 500);\\n    put(\\'M\\', 1000);\\n}};\\n\\nprivate static int convertToInt(String s) {\\n\\tint r = 0;\\n\\tint prev = 0;\\n\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tint v = NUMS.get(c);\\n        r = ((v > prev) ? r - prev + (v - prev) : r + v);\\n        prev = v;\\n\\t}\\n\\n\\treturn r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 580404,
                "title": "golang-simplest-and-efficient-solution-100-faster",
                "content": "```\\nfunc romanToInt(s string) int {\\n    var romanMap = map[byte]int{\\'I\\':1, \\'V\\':5, \\'X\\':10, \\'L\\':50, \\'C\\':100, \\'D\\':500, \\'M\\':1000}\\n    var result = romanMap[s[len(s)-1]]\\n    \\n    for i := len(s)-2; i >= 0; i-- {\\n        if romanMap[s[i]] < romanMap[s[i+1]] {\\n            result -= romanMap[s[i]]\\n        } else {\\n            result += romanMap[s[i]]\\n        }\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc romanToInt(s string) int {\\n    var romanMap = map[byte]int{\\'I\\':1, \\'V\\':5, \\'X\\':10, \\'L\\':50, \\'C\\':100, \\'D\\':500, \\'M\\':1000}\\n    var result = romanMap[s[len(s)-1]]\\n    \\n    for i := len(s)-2; i >= 0; i-- {\\n        if romanMap[s[i]] < romanMap[s[i+1]] {\\n            result -= romanMap[s[i]]\\n        } else {\\n            result += romanMap[s[i]]\\n        }\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3550693,
                "title": "java-descriptive-easy-99-more-efficient",
                "content": "# Intuition\\nFirstly I tried to implement \"CORE LOGIC\" of this problem then tried to enhance the solution with different approach. So I\\'m sharing two solutions.\\n\\n# Approaches\\n1. The solution iterates through the Roman numeral string from `right to left` and applies the necessary additions and subtractions based on the current symbol.  The algorithm correctly handles the cases where subtraction is required, ensuring accurate conversion.\\n\\n2. The second approach utilizes map to store the symbol-value mappings for the seven Roman numeral symbols. The algorithm iterates through the input Roman numeral string from `left to right`, performing the necessary additions and subtractions based on the symbol values. By comparing each symbol with the next one, it accurately handles the subtraction cases.\\n\\n# Complexity\\n- Time complexity:\\nit is O(n) for both approaches \\n\\n- Space complexity:\\nO(1) for both\\n\\n# Code for SOLUTION 1\\n```\\n        int result = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            switch (s.charAt(i)) {\\n                case \\'I\\' -> {\\n                    if (result >= 5)result-= 1;\\n                    else result += 1;\\n                }case \\'V\\' -> {\\n                    if (result >= 10)result-= 5;\\n                    else result += 5;\\n                }case \\'X\\' -> {\\n                    if (result >= 50)result-= 10;\\n                    else result += 10;\\n                }case \\'L\\' -> {\\n                    if (result > 100)result-= 50;\\n                    else result += 50;\\n                }case \\'C\\' -> {\\n                    if (result >= 500)result-= 100;\\n                    else result += 100;                    \\n                }case \\'D\\' -> {\\n                    if (result >= 1000)result-= 500;\\n                    else result += 500;\\n                }case \\'M\\' -> {\\n                    result += 1000;\\n                }\\n            }\\n        }\\n        return result;\\n```\\n\\n# Code for SOLUTION 2\\n\\nWe iterate through each character of s using a for loop, checking if the current character is smaller than the next character. If so, it subtracts the corresponding value from the result. This is because in Roman numerals, when a smaller numeral appears before a larger one, it indicates subtraction. Otherwise, it adds the corresponding value to the result. eg: IX => 1(I) < 10(X) => result = -1 => result = -1 + 10 = 9\\n\\n```\\n        Map<Character, Integer> map = new HashMap<>() {{\\n            put(\\'I\\', 1);\\n            put(\\'V\\', 5);\\n            put(\\'X\\', 10);\\n            put(\\'L\\', 50);\\n            put(\\'C\\', 100);\\n            put(\\'D\\', 500);\\n            put(\\'M\\', 1000);\\n        }};\\n        int result = 0, n = s.length();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i < n - 1 && map.get(s.charAt(i)) < map.get(s.charAt(i + 1))) {\\n                result -= map.get(s.charAt(i));\\n            } else {\\n                result += map.get(s.charAt(i));\\n            }\\n        }\\n\\n        return result;\\n```\\n\\n***Your upvote is appraciated if you like the solution!***",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\n        int result = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            switch (s.charAt(i)) {\\n                case \\'I\\' -> {\\n                    if (result >= 5)result-= 1;\\n                    else result += 1;\\n                }case \\'V\\' -> {\\n                    if (result >= 10)result-= 5;\\n                    else result += 5;\\n                }case \\'X\\' -> {\\n                    if (result >= 50)result-= 10;\\n                    else result += 10;\\n                }case \\'L\\' -> {\\n                    if (result > 100)result-= 50;\\n                    else result += 50;\\n                }case \\'C\\' -> {\\n                    if (result >= 500)result-= 100;\\n                    else result += 100;                    \\n                }case \\'D\\' -> {\\n                    if (result >= 1000)result-= 500;\\n                    else result += 500;\\n                }case \\'M\\' -> {\\n                    result += 1000;\\n                }\\n            }\\n        }\\n        return result;\\n```\n```\\n        Map<Character, Integer> map = new HashMap<>() {{\\n            put(\\'I\\', 1);\\n            put(\\'V\\', 5);\\n            put(\\'X\\', 10);\\n            put(\\'L\\', 50);\\n            put(\\'C\\', 100);\\n            put(\\'D\\', 500);\\n            put(\\'M\\', 1000);\\n        }};\\n        int result = 0, n = s.length();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i < n - 1 && map.get(s.charAt(i)) < map.get(s.charAt(i + 1))) {\\n                result -= map.get(s.charAt(i));\\n            } else {\\n                result += map.get(s.charAt(i));\\n            }\\n        }\\n\\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2428601,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=Nc35iWWqT78\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n       unordered_map<char, int> um;\\n        um[\\'I\\']= 1;\\n        um[\\'V\\']= 5;\\n        um[\\'X\\']= 10;\\n        um[\\'L\\']=50;\\n        um[\\'C\\']= 100;\\n        um[\\'D\\']= 500;\\n        um[\\'M\\']= 1000;\\n        int ans=0;\\n        for(int i=s.size()-1; i>=0; i--){\\n            if(i!=0 && um[s[i-1]]<um[s[i]] ){\\n                 ans= ans+  um[s[i]]-um[s[i-1]]; \\n                i--;\\n                continue;\\n            }\\n            ans=ans+ um[s[i]];\\n        }\\n        return ans;\\n    }\\n};\\n    \\n```\\n**JAVA**(Copied)\\n```\\npublic int romanToInt(String s) {\\n        Map<Character, Integer> alphabet = initAlphabet();\\n        int result = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (alphabet.get(s.charAt(i)) < alphabet.get(s.charAt(i + 1)))\\n                result = result - alphabet.get(s.charAt(i));\\n            else \\n                result = result + alphabet.get(s.charAt(i));\\n        }\\n        return result + alphabet.get(s.charAt(s.length() - 1));\\n    }\\n\\n    private Map<Character, Integer> initAlphabet() {\\n        return Map.of(\\'I\\', 1, \\'V\\', 5, \\'X\\', 10, \\'L\\', 50, \\'C\\', 100, \\'D\\', 500, \\'M\\', 1000);\\n    }\\n```\\n**PYTHON**((Copied)\\n```\\nclass Solution:\\n\\t\\n\\n\\tROMAN_TO_INTEGER = {\\n\\t\\t\\'I\\':  1,\\n\\t\\t\\'IV\\': 4,\\n\\t\\t\\'V\\':  5,\\n\\t\\t\\'IX\\': 9,\\n\\t\\t\\'X\\':  10,\\n\\t\\t\\'XL\\': 40,\\n\\t\\t\\'L\\':  50,\\n\\t\\t\\'XC\\': 90,\\n\\t\\t\\'C\\':  100,\\n\\t\\t\\'CD\\': 400,\\n\\t\\t\\'D\\':  500,\\n\\t\\t\\'CM\\': 900,\\n\\t\\t\\'M\\':  1000,\\n\\t}\\n\\n\\tdef romanToInt(self, s: str) -> int:\\n\\t\\tconverted = 0\\n\\n\\t\\tfor roman, integer in self.ROMAN_TO_INTEGER.items():\\n\\t\\t\\twhile s.endswith(roman):\\n\\t\\t\\t\\ts = s.removesuffix(roman)\\n\\t\\t\\t\\tconverted += integer\\n\\n\\t\\treturn converted\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n       unordered_map<char, int> um;\\n        um[\\'I\\']= 1;\\n        um[\\'V\\']= 5;\\n        um[\\'X\\']= 10;\\n        um[\\'L\\']=50;\\n        um[\\'C\\']= 100;\\n        um[\\'D\\']= 500;\\n        um[\\'M\\']= 1000;\\n        int ans=0;\\n        for(int i=s.size()-1; i>=0; i--){\\n            if(i!=0 && um[s[i-1]]<um[s[i]] ){\\n                 ans= ans+  um[s[i]]-um[s[i-1]]; \\n                i--;\\n                continue;\\n            }\\n            ans=ans+ um[s[i]];\\n        }\\n        return ans;\\n    }\\n};\\n    \\n```\n```\\npublic int romanToInt(String s) {\\n        Map<Character, Integer> alphabet = initAlphabet();\\n        int result = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (alphabet.get(s.charAt(i)) < alphabet.get(s.charAt(i + 1)))\\n                result = result - alphabet.get(s.charAt(i));\\n            else \\n                result = result + alphabet.get(s.charAt(i));\\n        }\\n        return result + alphabet.get(s.charAt(s.length() - 1));\\n    }\\n\\n    private Map<Character, Integer> initAlphabet() {\\n        return Map.of(\\'I\\', 1, \\'V\\', 5, \\'X\\', 10, \\'L\\', 50, \\'C\\', 100, \\'D\\', 500, \\'M\\', 1000);\\n    }\\n```\n```\\nclass Solution:\\n\\t\\n\\n\\tROMAN_TO_INTEGER = {\\n\\t\\t\\'I\\':  1,\\n\\t\\t\\'IV\\': 4,\\n\\t\\t\\'V\\':  5,\\n\\t\\t\\'IX\\': 9,\\n\\t\\t\\'X\\':  10,\\n\\t\\t\\'XL\\': 40,\\n\\t\\t\\'L\\':  50,\\n\\t\\t\\'XC\\': 90,\\n\\t\\t\\'C\\':  100,\\n\\t\\t\\'CD\\': 400,\\n\\t\\t\\'D\\':  500,\\n\\t\\t\\'CM\\': 900,\\n\\t\\t\\'M\\':  1000,\\n\\t}\\n\\n\\tdef romanToInt(self, s: str) -> int:\\n\\t\\tconverted = 0\\n\\n\\t\\tfor roman, integer in self.ROMAN_TO_INTEGER.items():\\n\\t\\t\\twhile s.endswith(roman):\\n\\t\\t\\t\\ts = s.removesuffix(roman)\\n\\t\\t\\t\\tconverted += integer\\n\\n\\t\\treturn converted\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342712,
                "title": "simple-and-clean-solution-typescript-javascript",
                "content": "```\\nfunction romanToInt(s: string): number {\\nconst map = {\\n    \\'I\\':1,\\n    \\'V\\':5,\\n    \\'X\\':10,\\n    \\'L\\':50,\\n    \\'C\\':100,\\n    \\'D\\':500,\\n    \\'M\\':1000,\\n    \\'IV\\':4,\\n    \\'IX\\':9,\\n    \\'XL\\':40,\\n    \\'XC\\':90,\\n    \\'CD\\':400,\\n    \\'CM\\':900\\n}\\n\\n    let sum = 0;\\n    for (let i = 0; i< s.length;){\\n        const index = s[i] + s[i+1];\\n        const word = map[index] ? index: s[i];\\n        sum += map[word];\\n        i+=word.length;\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction romanToInt(s: string): number {\\nconst map = {\\n    \\'I\\':1,\\n    \\'V\\':5,\\n    \\'X\\':10,\\n    \\'L\\':50,\\n    \\'C\\':100,\\n    \\'D\\':500,\\n    \\'M\\':1000,\\n    \\'IV\\':4,\\n    \\'IX\\':9,\\n    \\'XL\\':40,\\n    \\'XC\\':90,\\n    \\'CD\\':400,\\n    \\'CM\\':900\\n}\\n\\n    let sum = 0;\\n    for (let i = 0; i< s.length;){\\n        const index = s[i] + s[i+1];\\n        const word = map[index] ? index: s[i];\\n        sum += map[word];\\n        i+=word.length;\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1131238,
                "title": "easy-to-understand-w-explanation-12-lines-faster-than-98",
                "content": "**Approach:**\\n1. Scan the given roman numeral string from left to right character by character and add the corresponding integer value to `ans`.\\n2. Record previous added value in `prev` so that it can be compared with another value in the next iteration. If `curr` value is greater than `prev`, it means we have numerals like \\'IV\\', \\'IX\\', \\'XL\\', \\'CD\\', \\'CM\\' etc. In that case, subtract previously added value from `ans` and add the difference between `curr` and `prev`.\\n \\n   E.g. If we had \\'XL\\' then we\\'d subtract \\'X\\' i.e. 10 from `ans` and add 40 (\\'L\\' i.e. 50 - \\'X\\' i.e. 10 = 40)\\n\\n```\\ndef romanToInt(self, s: str) -> int:\\n      values = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n      prev, ans = -1, 0\\n      for c in s:\\n          curr = values[c]\\n          if prev != -1 and curr > prev:\\n              ans -= prev\\n              ans += curr - prev\\n          else:\\n              ans += curr\\n          prev = curr\\n      return ans\\n```\\n\\n**P.S. If you found this approach helpful, consider upvoting it. :)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef romanToInt(self, s: str) -> int:\\n      values = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n      prev, ans = -1, 0\\n      for c in s:\\n          curr = values[c]\\n          if prev != -1 and curr > prev:\\n              ans -= prev\\n              ans += curr - prev\\n          else:\\n              ans += curr\\n          prev = curr\\n      return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 705118,
                "title": "easiest-map-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map <char, int> dict {\\n            {\\'I\\', 1},\\n            {\\'V\\', 5},\\n            {\\'X\\', 10},\\n            {\\'L\\', 50},\\n            {\\'C\\', 100},\\n            {\\'D\\', 500},\\n            {\\'M\\', 1000},\\n        };\\n        \\n        int result = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (dict[s[i]] < dict[s[i+1]]) result -= dict[s[i]];\\n            else { result += dict[s[i]]; }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map <char, int> dict {\\n            {\\'I\\', 1},\\n            {\\'V\\', 5},\\n            {\\'X\\', 10},\\n            {\\'L\\', 50},\\n            {\\'C\\', 100},\\n            {\\'D\\', 500},\\n            {\\'M\\', 1000},\\n        };\\n        \\n        int result = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (dict[s[i]] < dict[s[i+1]]) result -= dict[s[i]];\\n            else { result += dict[s[i]]; }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272944,
                "title": "python-3-beats-99-13-easy-to-understand",
                "content": "Runtime: **44 ms, faster than 99.13%** of Python3 online submissions for Roman to Integer.\\nMemory Usage: **13.9 MB, less than 76.17%** of Python3 online submissions for Roman to Integer.\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        a, r = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000, \"IV\": -2, \"IX\": -2, \"XL\": -20, \"XC\": -20, \"CD\": -200, \"CM\": -200}, 0\\n        for d, e in a.items():\\n            r += s.count(d) * e\\n        return r\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        a, r = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000, \"IV\": -2, \"IX\": -2, \"XL\": -20, \"XC\": -20, \"CD\": -200, \"CM\": -200}, 0\\n        for d, e in a.items():\\n            r += s.count(d) * e\\n        return r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056135,
                "title": "kotlin-simple",
                "content": "```\\nfun romanToInt(s: String): Int {\\n        val map = mutableMapOf(\\n            \\'I\\' to 1, \\'V\\' to 5, \\'X\\' to 10, \\'L\\' to 50, \\'C\\' to 100, \\'D\\' to 500, \\'M\\' to 1000\\n        )\\n        var number = 0\\n        var last = 1000\\n        s.forEach {\\n            val value = map[it] ?: 0\\n            if (value > last) number -= last * 2\\n            number += value\\n            last = value\\n        }\\n\\n        return number\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun romanToInt(s: String): Int {\\n        val map = mutableMapOf(\\n            \\'I\\' to 1, \\'V\\' to 5, \\'X\\' to 10, \\'L\\' to 50, \\'C\\' to 100, \\'D\\' to 500, \\'M\\' to 1000\\n        )\\n        var number = 0\\n        var last = 1000\\n        s.forEach {\\n            val value = map[it] ?: 0\\n            if (value > last) number -= last * 2\\n            number += value\\n            last = value\\n        }\\n\\n        return number\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161474,
                "title": "javascript-simple-decrementing-while-loop",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n    const map = {\\n        I: 1,\\n        V: 5,\\n        X: 10,\\n        L: 50,\\n        C: 100,\\n        D: 500,\\n        M: 1000\\n    };\\n    let i = s.length;\\n    let result = 0;\\n    \\n    while (i--) {\\n        const curr = map[s.charAt(i)];\\n        const prev = map[s.charAt(i - 1)];\\n        \\n        result += curr; \\n        \\n        if (prev < curr) {\\n            result -= prev; \\n            i -= 1;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n    const map = {\\n        I: 1,\\n        V: 5,\\n        X: 10,\\n        L: 50,\\n        C: 100,\\n        D: 500,\\n        M: 1000\\n    };\\n    let i = s.length;\\n    let result = 0;\\n    \\n    while (i--) {\\n        const curr = map[s.charAt(i)];\\n        const prev = map[s.charAt(i - 1)];\\n        \\n        result += curr; \\n        \\n        if (prev < curr) {\\n            result -= prev; \\n            i -= 1;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3243349,
                "title": "c-simple-and-easy-solution",
                "content": "\\n\\n# Code\\n```\\n\\nint DecimalNumericalPlace(char roman_np_value)\\n    {\\n        switch(roman_np_value)\\n        {\\n            case \\'M\\':\\n            return 1000;\\n            break;\\n\\n             case \\'D\\':\\n            return 500;\\n            break;\\n\\n            case \\'C\\':\\n            return 100;\\n            break;\\n\\n             case \\'L\\':\\n            return 50;\\n            break;\\n\\n             case \\'X\\':\\n            return 10;\\n            break;\\n\\n             case \\'V\\':\\n            return 5;\\n            break;\\n\\n            case \\'I\\':\\n            return 1;\\n            break;\\n            default :\\n            return -1;\\n        }\\n    }\\nint romanToInt(char * s)\\n{\\n    int len=strlen(s);\\n    int sum=0;\\n   for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n       if(DecimalNumericalPlace(s[i]) < DecimalNumericalPlace(s[i+1])){\\n       sum = sum-DecimalNumericalPlace(s[i]);\\n   }\\n   else{\\n   sum+=DecimalNumericalPlace(s[i]);\\n   }\\n   }\\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint DecimalNumericalPlace(char roman_np_value)\\n    {\\n        switch(roman_np_value)\\n        {\\n            case \\'M\\':\\n            return 1000;\\n            break;\\n\\n             case \\'D\\':\\n            return 500;\\n            break;\\n\\n            case \\'C\\':\\n            return 100;\\n            break;\\n\\n             case \\'L\\':\\n            return 50;\\n            break;\\n\\n             case \\'X\\':\\n            return 10;\\n            break;\\n\\n             case \\'V\\':\\n            return 5;\\n            break;\\n\\n            case \\'I\\':\\n            return 1;\\n            break;\\n            default :\\n            return -1;\\n        }\\n    }\\nint romanToInt(char * s)\\n{\\n    int len=strlen(s);\\n    int sum=0;\\n   for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n       if(DecimalNumericalPlace(s[i]) < DecimalNumericalPlace(s[i+1])){\\n       sum = sum-DecimalNumericalPlace(s[i]);\\n   }\\n   else{\\n   sum+=DecimalNumericalPlace(s[i]);\\n   }\\n   }\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074075,
                "title": "java-python-short-solution-clean-concise",
                "content": "**Intuitive**\\n-  Roman numerals are usually written largest to smallest from left to right, for example: `XII (7)`, `XXVII (27)`, `III (3)`...\\n-  If a small value is placed before a bigger value then it\\'s a combine number, for exampe: `IV (4)`, `IX (9)`, `XIV (14)`...\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 15` is the length of string `s`\\n- Space: `O(1)`\\n\\n**Java**\\n```java\\nclass Solution {\\n    static Map<Character, Integer> values = new HashMap<>();\\n    static {\\n        values.put(\\'I\\', 1);\\n        values.put(\\'V\\', 5);\\n        values.put(\\'X\\', 10);\\n        values.put(\\'L\\', 50);\\n        values.put(\\'C\\', 100);\\n        values.put(\\'D\\', 500);\\n        values.put(\\'M\\', 1000);\\n    }\\n\\n    public int romanToInt(String s) {\\n        int ans = 0, n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            if (i+1 < n && values.get(s.charAt(i)) < values.get(s.charAt(i+1))) {\\n\\t\\t\\t\\t// If current is a small value and next is a bigger value -> It\\'s a combine number\\n                ans -= values.get(s.charAt(i));\\n            } else {\\n                ans += values.get(s.charAt(i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Python**\\n```python\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        values = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        ans, n = 0, len(s)\\n        for i in range(n):\\n            if i+1 < n and values[s[i]] < values[s[i+1]]:\\n                # If current is a small value and next is a bigger value -> It\\'s a combine number\\n                ans -= values[s[i]]\\n            else:\\n                ans += values[s[i]]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    static Map<Character, Integer> values = new HashMap<>();\\n    static {\\n        values.put(\\'I\\', 1);\\n        values.put(\\'V\\', 5);\\n        values.put(\\'X\\', 10);\\n        values.put(\\'L\\', 50);\\n        values.put(\\'C\\', 100);\\n        values.put(\\'D\\', 500);\\n        values.put(\\'M\\', 1000);\\n    }\\n\\n    public int romanToInt(String s) {\\n        int ans = 0, n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            if (i+1 < n && values.get(s.charAt(i)) < values.get(s.charAt(i+1))) {\\n\\t\\t\\t\\t// If current is a small value and next is a bigger value -> It\\'s a combine number\\n                ans -= values.get(s.charAt(i));\\n            } else {\\n                ans += values.get(s.charAt(i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```python\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        values = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        ans, n = 0, len(s)\\n        for i in range(n):\\n            if i+1 < n and values[s[i]] < values[s[i+1]]:\\n                # If current is a small value and next is a bigger value -> It\\'s a combine number\\n                ans -= values[s[i]]\\n            else:\\n                ans += values[s[i]]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367403,
                "title": "c-fast-easy-to-understand-4ms-98-8-3mb-90",
                "content": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ret = 0;        // to store the return value\\n        int temp = 0;       // to store the previous value\\n        \\n        for (size_t i = 0; i < s.size(); i++) {\\n            char curr = s[i];\\n            int pos = 0;     // to store the current value\\n            \\n            switch(curr) {\\n                case \\'I\\': pos = 1; break;\\n                case \\'V\\': pos = 5; break;\\n                case \\'X\\': pos = 10; break;\\n                case \\'L\\': pos = 50; break;\\n                case \\'C\\': pos = 100; break;\\n                case \\'D\\': pos = 500; break;\\n                case \\'M\\': pos = 1000; break;\\n                default: return 0;\\n            }\\n            \\n            ret += pos;\\n            if (temp < pos)\\n                ret -= temp*2;     // ex: IV, ret = 1 + 5 - 1*2 = 4\\n            temp = pos;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ret = 0;        // to store the return value\\n        int temp = 0;       // to store the previous value\\n        \\n        for (size_t i = 0; i < s.size(); i++) {\\n            char curr = s[i];\\n            int pos = 0;     // to store the current value\\n            \\n            switch(curr) {\\n                case \\'I\\': pos = 1; break;\\n                case \\'V\\': pos = 5; break;\\n                case \\'X\\': pos = 10; break;\\n                case \\'L\\': pos = 50; break;\\n                case \\'C\\': pos = 100; break;\\n                case \\'D\\': pos = 500; break;\\n                case \\'M\\': pos = 1000; break;\\n                default: return 0;\\n            }\\n            \\n            ret += pos;\\n            if (temp < pos)\\n                ret -= temp*2;     // ex: IV, ret = 1 + 5 - 1*2 = 4\\n            temp = pos;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979573,
                "title": "java-c-python-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***C++***\\n```\\nclass Solution {\\npublic:\\n    int romanToInt(string S) {\\n        int ans = 0, num = 0;\\n        for (int i = S.size()-1; ~i; i--) {\\n            switch(S[i]) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) ans -= num;\\n            else ans += num;\\n        }\\n        return ans;        \\n    }\\n};\\n```\\n\\n***Java***\\n```\\nclass Solution {\\n    public int romanToInt(String S) {\\n        int ans = 0, num = 0;\\n        for (int i = S.length()-1; i >= 0; i--) {\\n            switch(S.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) ans -= num;\\n            else ans += num;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n***Python***\\n```\\nroman = {\\'I\\':1,\\'V\\':5,\\'X\\':10,\\'L\\':50,\\'C\\':100,\\'D\\':500,\\'M\\':1000}\\n\\nclass Solution:\\n    def romanToInt(self, S: str) -> int:\\n        ans = 0\\n        for i in range(len(S)-1,-1,-1):\\n            num = roman[S[i]]\\n            if 4 * num < ans: ans -= num\\n            else: ans += num\\n        return ans\\n```\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string S) {\\n        int ans = 0, num = 0;\\n        for (int i = S.size()-1; ~i; i--) {\\n            switch(S[i]) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) ans -= num;\\n            else ans += num;\\n        }\\n        return ans;        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int romanToInt(String S) {\\n        int ans = 0, num = 0;\\n        for (int i = S.length()-1; i >= 0; i--) {\\n            switch(S.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) ans -= num;\\n            else ans += num;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nroman = {\\'I\\':1,\\'V\\':5,\\'X\\':10,\\'L\\':50,\\'C\\':100,\\'D\\':500,\\'M\\':1000}\\n\\nclass Solution:\\n    def romanToInt(self, S: str) -> int:\\n        ans = 0\\n        for i in range(len(S)-1,-1,-1):\\n            num = roman[S[i]]\\n            if 4 * num < ans: ans -= num\\n            else: ans += num\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6506,
                "title": "straightforward-java-solution-using-recursion-139ms",
                "content": "```\\nclass Solution\\n{\\n    public int romanToInt(String s)\\n    {\\n        if(s.length() == 0)     return 0;\\n        \\n        if(s.length() > 1)\\n        {\\n            if(s.substring(0,2).equals(\"CM\"))  return 900 + romanToInt(s.substring(2));\\n            if(s.substring(0,2).equals(\"CD\"))  return 400 + romanToInt(s.substring(2));\\n            if(s.substring(0,2).equals(\"XC\"))  return 90 + romanToInt(s.substring(2));\\n            if(s.substring(0,2).equals(\"XL\"))  return 40 + romanToInt(s.substring(2));\\n            if(s.substring(0,2).equals(\"IX\"))  return 9 + romanToInt(s.substring(2));\\n            if(s.substring(0,2).equals(\"IV\"))  return 4 + romanToInt(s.substring(2));\\n        }\\n        \\n        if(s.charAt(0) == 'M')  return 1000 + romanToInt(s.substring(1));\\n        if(s.charAt(0) == 'D')  return 500 + romanToInt(s.substring(1));\\n        if(s.charAt(0) == 'C')  return 100 + romanToInt(s.substring(1));\\n        if(s.charAt(0) == 'L')  return 50 + romanToInt(s.substring(1));\\n        if(s.charAt(0) == 'X')  return 10 + romanToInt(s.substring(1));\\n        if(s.charAt(0) == 'V')  return 5 + romanToInt(s.substring(1));\\n        if(s.charAt(0) == 'I')  return 1 + romanToInt(s.substring(1));\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int romanToInt(String s)\\n    {\\n        if(s.length() == 0)     return 0;\\n        \\n        if(s.length() > 1)\\n        {\\n            if(s.substring(0,2).equals(\"CM\"))  return 900 + romanToInt(s.substring(2));\\n            if(s.substring(0,2).equals(\"CD\"))  return 400 + romanToInt(s.substring(2));\\n            if(s.substring(0,2).equals(\"XC\"))  return 90 + romanToInt(s.substring(2));\\n            if(s.substring(0,2).equals(\"XL\"))  return 40 + romanToInt(s.substring(2));\\n            if(s.substring(0,2).equals(\"IX\"))  return 9 + romanToInt(s.substring(2));\\n            if(s.substring(0,2).equals(\"IV\"))  return 4 + romanToInt(s.substring(2));\\n        }\\n        \\n        if(s.charAt(0) == 'M')  return 1000 + romanToInt(s.substring(1));\\n        if(s.charAt(0) == 'D')  return 500 + romanToInt(s.substring(1));\\n        if(s.charAt(0) == 'C')  return 100 + romanToInt(s.substring(1));\\n        if(s.charAt(0) == 'L')  return 50 + romanToInt(s.substring(1));\\n        if(s.charAt(0) == 'X')  return 10 + romanToInt(s.substring(1));\\n        if(s.charAt(0) == 'V')  return 5 + romanToInt(s.substring(1));\\n        if(s.charAt(0) == 'I')  return 1 + romanToInt(s.substring(1));\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6518,
                "title": "python3-the-way-the-romans-do-it",
                "content": "Here is my solution. Beat 99.43% of submissions.\\n\\n1. Iterate through the string from right to left. \\n2. Whenever the current letter is larger than the previous letter, add it to the total. \\n3. Whenever the current letter is smaller than the previous, subtract it from the total.\\n\\n```\\nclass Solution:\\n\\n    charToNum = {\\n        'I': 1,\\n        'V': 5,\\n        'X': 10,\\n        'L': 50,\\n        'C': 100,\\n        'D': 500,\\n        'M': 1000\\n    }\\n\\n    def romanToInt(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        prev = 0\\n        total = 0\\n        for numeral in s[::-1]:\\n            cur = self.charToNum[numeral]\\n            total += cur if cur >= prev else -1*cur\\n            prev = cur\\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    charToNum = {\\n        'I': 1,\\n        'V': 5,\\n        'X': 10,\\n        'L': 50,\\n        'C': 100,\\n        'D': 500,\\n        'M': 1000\\n    }\\n\\n    def romanToInt(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        prev = 0\\n        total = 0\\n        for numeral in s[::-1]:\\n            cur = self.charToNum[numeral]\\n            total += cur if cur >= prev else -1*cur\\n            prev = cur\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328097,
                "title": "c-java-c-python-clean-solutions-fast-short-code-easy-to-understand",
                "content": "# Frequently encountered in technical interviews\\n```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Amazon\", 5},\\n    {\"Adobe\", 16},\\n    {\"Apple\", 13},\\n    {\"Google\", 10},\\n    {\"Bloomberg \", 10},\\n    {\"Facebook\", 8},\\n    {\"Microsoft\", 6},\\n    {\"tiktok \", 5},\\n    {\"Yahoo \", 4}    \\n};\\n```\\n\\n# Solution\\nThe implementation uses two integer arrays \"Key\" and \"value\" to map the Roman numeral characters to their corresponding integer values. \\n\\nThe code converts Roman numerals to integers. It iterates over the input string from right to left and uses the arrays to calculate the integer value of each character. If a character has a lower index than the previous character, its value is subtracted from the result, otherwise it is added.\\n\\n![13322339-A25A-4346-BDE6-E18256ED2A00.jpeg](https://assets.leetcode.com/users/images/f295ebb5-2013-4ca9-9080-ccc9035f57fc_1682609461.9821985.jpeg)\\n\\n**Time complexity:** O(n)\\n\\n**Space complexity:** O(1)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        vector<int> Key = {8,21,23,11,2,3,12};\\n        vector<int> value = {1, 5, 10, 50, 100, 500, 1000};\\n        int res = 0, tKey = 0;\\n\\n        // Iterate through the characters of the input string in reverse order\\n        for (int i = s.size() - 1; i >= 0; i--) {\\n            // Find the current character in the Key vector\\n            auto cKey = find(Key.begin(), Key.end(), (s[i] - \\'A\\'));\\n\\n            // If the character is found\\n            if (cKey != Key.end()) {\\n                // Calculate the index of the character in the Key vector\\n                int index = distance(Key.begin(), cKey);\\n\\n                // Compare the current index with the previous index\\n                // to determine the appropriate value to add or subtract\\n                if (tKey > index)\\n                    res -= value[index];\\n                else\\n                    res += value[index];\\n\\n                // Update the previous index\\n                tKey = index;\\n            }\\n        }\\n\\n        // Return the final result\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int Key[]={8,21,23,11,2,3,12};\\n        int value[]={1,5,10,50,100,500,1000};\\n        int res=0,tKey=0;\\n        for (int i=s.length()-1;i>=0;i--) {\\n            int cKey = findIndex(Key,(int)(s.charAt(i) - \\'A\\'));\\n            if (tKey>cKey) res -= Math.abs(value[cKey]);\\n            else res += value[cKey];\\n            tKey = cKey;\\n        }\\n        return res;\\n    }\\n    int findIndex(int arr[],int value) {\\n        for (int i=0;i<7;i++)\\n            if (arr[i]==value) return i;\\n        return -1; \\n    }\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    public int RomanToInt(string s) {\\n        int[] Key=new int[]{8,21,23,11,2,3,12};\\n        int[] value=new int[]{1,5,10,50,100,500,1000};\\n        int res=0,tKey=0;\\n        for (int i=s.Length-1;i>=0;i--) {\\n            int cKey = Array.IndexOf(Key,(s[i]-\\'A\\'));\\n            if (tKey>cKey) res -= Math.Abs(value[cKey]);\\n            else res += value[cKey];\\n            tKey = cKey;\\n        }\\n        return res;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        Key, value = [8,21,23,11,2,3,12], [1,5,10,50,100,500,1000]\\n        res, tKey = 0, 0\\n        for i in range(len(s) - 1, -1, -1):\\n            cKey = Key.index(ord(s[i]) - ord(\\'A\\'))\\n            if (tKey <= cKey): res += value[cKey]\\n            else: res -= abs(value[cKey])\\n            tKey = cKey\\n        return res\\n```\\n**Time complexity:** O(n), where n is the length of the input string.\\n**Space complexity:** O(1).\\n```C++ []\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char, int> map = {\\n            { \\'I\\' , 1 }, { \\'V\\' , 5 }, { \\'X\\' , 10 },\\n            { \\'L\\' , 50 }, { \\'C\\' , 100 }, { \\'D\\' , 500 },\\n            { \\'M\\' , 1000 }\\n        };\\n\\n        int sum = map[s.back()];  // Initialize the sum with the value of the last character\\n\\n        // Iterate through the string in reverse order, starting from the second-to-last character\\n        for (int i = s.length() - 2; i >= 0; --i) {\\n            // If the current character has a smaller value than the next character, subtract it from the sum\\n            if (map[s[i]] < map[s[i + 1]])\\n                sum -= map[s[i]];\\n            // Otherwise, add it to the sum\\n            else\\n                sum += map[s[i]];\\n        }\\n\\n        return sum;  // Return the final sum\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    public int romanToInt(String s) {\\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>() {{\\n            put(\\'I\\', 1);\\n            put(\\'V\\', 5);\\n            put(\\'X\\', 10);\\n            put(\\'L\\', 50);\\n            put(\\'C\\', 100);\\n            put(\\'D\\', 500);\\n            put(\\'M\\', 1000);\\n        }};        \\n        int sum=map.get(s.charAt(s.length() - 1));\\n        for (int i=s.length()-2; i>= 0;--i) {\\n            if (map.get(s.charAt(i)) < map.get(s.charAt(i + 1))) sum -= map.get(s.charAt(i));\\n            else sum += map.get(s.charAt(i));\\n        }           \\n        return sum;\\n    }\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    public int RomanToInt(string s) {\\n        var map = new Dictionary<Char, int> { \\n        { \\'I\\' , 1 }, { \\'V\\' , 5 }, { \\'X\\' , 10 }, { \\'L\\' , 50 }, { \\'C\\' , 100 }, { \\'D\\' , 500 }, { \\'M\\' , 1000 } };                                   \\n        int sum=map[s.LastOrDefault()];\\n        for (int i = s.Length-2; i >= 0; --i) {\\n            if (map[s[i]] < map[s[i + 1]]) sum -= map[s[i]];\\n            else sum += map[s[i]];\\n        }   \\n        return sum;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        res, prev = 0, 0\\n        map  = {\\'I\\':1, \\'V\\':5, \\'X\\':10, \\'L\\':50, \\'C\\':100, \\'D\\':500, \\'M\\':1000}\\n        for i in s[::-1]:          \\n            if map[i] >= prev: res += map[i]     \\n            else: res -= map[i]     \\n            prev = map[i]\\n        return res\\n```\\n**Time complexity:** O(n), where n is the length of the input string.\\n**Space complexity:** O(1).\\n```C++ []\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char, int> map = {\\n            { \\'I\\' , 1 }, { \\'V\\' , 5 }, { \\'X\\' , 10 },\\n            { \\'L\\' , 50 }, { \\'C\\' , 100 }, { \\'D\\' , 500 },\\n            { \\'M\\' , 1000 }\\n        };\\n\\n        int sum = 0;  // Initialize the sum to zero\\n\\n        // Replace the special Roman numeral substrings with their simplified forms\\n        s = regex_replace(regex_replace(regex_replace(regex_replace(regex_replace(regex_replace\\n            (s, regex(\"CM\"), \"DCCCC\"), regex(\"CD\"), \"CCCC\"), regex(\"XC\"), \"LXXXX\"), regex(\"XL\"), \"XXXX\"),\\n            regex(\"IX\"), \"VIIII\"), regex(\"IV\"), \"IIII\");\\n\\n        // Iterate through each character in the modified string and add its corresponding value to the sum\\n        for (auto c : s)\\n            sum += map[c];\\n\\n        return sum;  // Return the final sum\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> hashMap  = new HashMap<Character, Integer>() {{ \\n            put(\\'I\\', 1);put(\\'V\\', 5);put(\\'X\\', 10);put(\\'L\\', 50);put(\\'C\\', 100);put(\\'D\\', 500);put(\\'M\\', 1000);\\n            }};                                   \\n        int sum=0;\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\\n            .replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\\n            .replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\");\\n        for (char c:s.toCharArray()) \\n            sum += hashMap.get(c);\\n        return sum;\\n    }\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    public int RomanToInt(string s) {\\n        var map = new Dictionary<Char, int> { \\n        { \\'I\\' , 1 }, { \\'V\\' , 5 }, { \\'X\\' , 10 }, { \\'L\\' , 50 }, { \\'C\\' , 100 }, { \\'D\\' , 500 }, { \\'M\\' , 1000 } };                                   \\n        int sum = 0;\\n        s = s.Replace(\"IV\", \"IIII\").Replace(\"IX\", \"VIIII\")\\n            .Replace(\"XL\", \"XXXX\").Replace(\"XC\", \"LXXXX\")\\n            .Replace(\"CD\", \"CCCC\").Replace(\"CM\", \"DCCCC\");\\n        foreach(var c in s) sum+=map[c];         \\n        return sum;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\") \\\\\\n            .replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\") \\\\\\n            .replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n        Key,value,res,tKey = [8,21,23,11,2,3,12],[1,5,10,50,100,500,1000],0,0\\n        for char in s:\\n            res += value[Key.index(ord(char)-ord(\\'A\\'))]\\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Amazon\", 5},\\n    {\"Adobe\", 16},\\n    {\"Apple\", 13},\\n    {\"Google\", 10},\\n    {\"Bloomberg \", 10},\\n    {\"Facebook\", 8},\\n    {\"Microsoft\", 6},\\n    {\"tiktok \", 5},\\n    {\"Yahoo \", 4}    \\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        vector<int> Key = {8,21,23,11,2,3,12};\\n        vector<int> value = {1, 5, 10, 50, 100, 500, 1000};\\n        int res = 0, tKey = 0;\\n\\n        // Iterate through the characters of the input string in reverse order\\n        for (int i = s.size() - 1; i >= 0; i--) {\\n            // Find the current character in the Key vector\\n            auto cKey = find(Key.begin(), Key.end(), (s[i] - \\'A\\'));\\n\\n            // If the character is found\\n            if (cKey != Key.end()) {\\n                // Calculate the index of the character in the Key vector\\n                int index = distance(Key.begin(), cKey);\\n\\n                // Compare the current index with the previous index\\n                // to determine the appropriate value to add or subtract\\n                if (tKey > index)\\n                    res -= value[index];\\n                else\\n                    res += value[index];\\n\\n                // Update the previous index\\n                tKey = index;\\n            }\\n        }\\n\\n        // Return the final result\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int Key[]={8,21,23,11,2,3,12};\\n        int value[]={1,5,10,50,100,500,1000};\\n        int res=0,tKey=0;\\n        for (int i=s.length()-1;i>=0;i--) {\\n            int cKey = findIndex(Key,(int)(s.charAt(i) - \\'A\\'));\\n            if (tKey>cKey) res -= Math.abs(value[cKey]);\\n            else res += value[cKey];\\n            tKey = cKey;\\n        }\\n        return res;\\n    }\\n    int findIndex(int arr[],int value) {\\n        for (int i=0;i<7;i++)\\n            if (arr[i]==value) return i;\\n        return -1; \\n    }\\n}\\n```\n```csharp []\\npublic class Solution {\\n    public int RomanToInt(string s) {\\n        int[] Key=new int[]{8,21,23,11,2,3,12};\\n        int[] value=new int[]{1,5,10,50,100,500,1000};\\n        int res=0,tKey=0;\\n        for (int i=s.Length-1;i>=0;i--) {\\n            int cKey = Array.IndexOf(Key,(s[i]-\\'A\\'));\\n            if (tKey>cKey) res -= Math.Abs(value[cKey]);\\n            else res += value[cKey];\\n            tKey = cKey;\\n        }\\n        return res;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        Key, value = [8,21,23,11,2,3,12], [1,5,10,50,100,500,1000]\\n        res, tKey = 0, 0\\n        for i in range(len(s) - 1, -1, -1):\\n            cKey = Key.index(ord(s[i]) - ord(\\'A\\'))\\n            if (tKey <= cKey): res += value[cKey]\\n            else: res -= abs(value[cKey])\\n            tKey = cKey\\n        return res\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char, int> map = {\\n            { \\'I\\' , 1 }, { \\'V\\' , 5 }, { \\'X\\' , 10 },\\n            { \\'L\\' , 50 }, { \\'C\\' , 100 }, { \\'D\\' , 500 },\\n            { \\'M\\' , 1000 }\\n        };\\n\\n        int sum = map[s.back()];  // Initialize the sum with the value of the last character\\n\\n        // Iterate through the string in reverse order, starting from the second-to-last character\\n        for (int i = s.length() - 2; i >= 0; --i) {\\n            // If the current character has a smaller value than the next character, subtract it from the sum\\n            if (map[s[i]] < map[s[i + 1]])\\n                sum -= map[s[i]];\\n            // Otherwise, add it to the sum\\n            else\\n                sum += map[s[i]];\\n        }\\n\\n        return sum;  // Return the final sum\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    public int romanToInt(String s) {\\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>() {{\\n            put(\\'I\\', 1);\\n            put(\\'V\\', 5);\\n            put(\\'X\\', 10);\\n            put(\\'L\\', 50);\\n            put(\\'C\\', 100);\\n            put(\\'D\\', 500);\\n            put(\\'M\\', 1000);\\n        }};        \\n        int sum=map.get(s.charAt(s.length() - 1));\\n        for (int i=s.length()-2; i>= 0;--i) {\\n            if (map.get(s.charAt(i)) < map.get(s.charAt(i + 1))) sum -= map.get(s.charAt(i));\\n            else sum += map.get(s.charAt(i));\\n        }           \\n        return sum;\\n    }\\n}\\n```\n```csharp []\\npublic class Solution {\\n    public int RomanToInt(string s) {\\n        var map = new Dictionary<Char, int> { \\n        { \\'I\\' , 1 }, { \\'V\\' , 5 }, { \\'X\\' , 10 }, { \\'L\\' , 50 }, { \\'C\\' , 100 }, { \\'D\\' , 500 }, { \\'M\\' , 1000 } };                                   \\n        int sum=map[s.LastOrDefault()];\\n        for (int i = s.Length-2; i >= 0; --i) {\\n            if (map[s[i]] < map[s[i + 1]]) sum -= map[s[i]];\\n            else sum += map[s[i]];\\n        }   \\n        return sum;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        res, prev = 0, 0\\n        map  = {\\'I\\':1, \\'V\\':5, \\'X\\':10, \\'L\\':50, \\'C\\':100, \\'D\\':500, \\'M\\':1000}\\n        for i in s[::-1]:          \\n            if map[i] >= prev: res += map[i]     \\n            else: res -= map[i]     \\n            prev = map[i]\\n        return res\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char, int> map = {\\n            { \\'I\\' , 1 }, { \\'V\\' , 5 }, { \\'X\\' , 10 },\\n            { \\'L\\' , 50 }, { \\'C\\' , 100 }, { \\'D\\' , 500 },\\n            { \\'M\\' , 1000 }\\n        };\\n\\n        int sum = 0;  // Initialize the sum to zero\\n\\n        // Replace the special Roman numeral substrings with their simplified forms\\n        s = regex_replace(regex_replace(regex_replace(regex_replace(regex_replace(regex_replace\\n            (s, regex(\"CM\"), \"DCCCC\"), regex(\"CD\"), \"CCCC\"), regex(\"XC\"), \"LXXXX\"), regex(\"XL\"), \"XXXX\"),\\n            regex(\"IX\"), \"VIIII\"), regex(\"IV\"), \"IIII\");\\n\\n        // Iterate through each character in the modified string and add its corresponding value to the sum\\n        for (auto c : s)\\n            sum += map[c];\\n\\n        return sum;  // Return the final sum\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> hashMap  = new HashMap<Character, Integer>() {{ \\n            put(\\'I\\', 1);put(\\'V\\', 5);put(\\'X\\', 10);put(\\'L\\', 50);put(\\'C\\', 100);put(\\'D\\', 500);put(\\'M\\', 1000);\\n            }};                                   \\n        int sum=0;\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\\n            .replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\\n            .replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\");\\n        for (char c:s.toCharArray()) \\n            sum += hashMap.get(c);\\n        return sum;\\n    }\\n}\\n```\n```csharp []\\npublic class Solution {\\n    public int RomanToInt(string s) {\\n        var map = new Dictionary<Char, int> { \\n        { \\'I\\' , 1 }, { \\'V\\' , 5 }, { \\'X\\' , 10 }, { \\'L\\' , 50 }, { \\'C\\' , 100 }, { \\'D\\' , 500 }, { \\'M\\' , 1000 } };                                   \\n        int sum = 0;\\n        s = s.Replace(\"IV\", \"IIII\").Replace(\"IX\", \"VIIII\")\\n            .Replace(\"XL\", \"XXXX\").Replace(\"XC\", \"LXXXX\")\\n            .Replace(\"CD\", \"CCCC\").Replace(\"CM\", \"DCCCC\");\\n        foreach(var c in s) sum+=map[c];         \\n        return sum;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\") \\\\\\n            .replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\") \\\\\\n            .replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n        Key,value,res,tKey = [8,21,23,11,2,3,12],[1,5,10,50,100,500,1000],0,0\\n        for char in s:\\n            res += value[Key.index(ord(char)-ord(\\'A\\'))]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501355,
                "title": "python-c-java-easy-solution-87-30",
                "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity O(n)**\\n\\n**Please UPVOTE (^_^)**\\n\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        d={\\'I\\':1,\\'V\\':5,\\'X\\':10,\\'L\\':50,\\'C\\':100,\\'D\\':500,\\'M\\':1000}\\n        c=0\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\\n        s = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\\n        s = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n        for i in s:\\n            c=c+d[i]\\n        return c\\n```\\n\\n\\n**Runtime: 54 ms, faster than 87.04% of Python3 online submissions for Roman to Integer.\\nMemory Usage: 13.8 MB, less than 76.15% of Python3 online submissions for Roman to Integer.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        d={\\'I\\':1,\\'V\\':5,\\'X\\':10,\\'L\\':50,\\'C\\':100,\\'D\\':500,\\'M\\':1000}\\n        c=0\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\\n        s = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\\n        s = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n        for i in s:\\n            c=c+d[i]\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426677,
                "title": "4-easy-solution-explained-beginner-friendly-dictionary-arithmetic-logic",
                "content": "\\n**Brutal force:**\\n* In this solution, we just need a bunch of if statement.\\n* If we encounter  `I`, we need to check if there are `V` and `X` after it.\\n* If we encounter  `X`, we need to check if there are `L` and `C` after it.\\n* If we encounter  `C`, we need to check if there are `D` and `M` after it.\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        \\n        i, ans = 0, 0\\n        while i < len(s):\\n            if s[i] == \\'I\\':\\n                if i < len(s) - 1 and s[i + 1] == \\'V\\':\\n                    ans += 4\\n                    i += 1\\n                elif i < len(s) - 1 and s[i + 1] == \\'X\\':\\n                    ans += 9\\n                    i += 1\\n                else:\\n                    ans += 1\\n            elif s[i] == \\'V\\':\\n                ans += 5\\n            elif s[i] == \\'X\\':\\n                if i < len(s) - 1 and s[i + 1] == \\'L\\':\\n                    ans += 40\\n                    i += 1\\n                elif i < len(s) - 1 and s[i + 1] == \\'C\\':\\n                    ans += 90\\n                    i += 1\\n                else:\\n                    ans += 10\\n            elif s[i] == \\'L\\':\\n                ans += 50\\n            elif s[i] == \\'C\\':\\n                if i < len(s) - 1 and s[i + 1] == \\'D\\':\\n                    ans += 400\\n                    i += 1\\n                elif i < len(s) - 1 and s[i + 1] == \\'M\\':\\n                    ans += 900\\n                    i += 1\\n                else:\\n                    ans += 100\\n            elif s[i] == \\'D\\':\\n                ans += 500\\n            elif s[i] == \\'M\\':\\n                ans += 1000\\n            i += 1\\n                \\n        return ans\\n```\\n\\n**Dictionary solution:**\\n* We add every possible numbers in the dictionary.\\n* Then just use a while loop to calculate the sum.\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        \\n        res, i = 0, 0\\n        map = {\\n            \\'I\\': 1,\\n            \\'IV\\': 4,\\n            \\'V\\': 5, \\n            \\'IX\\': 9, \\n            \\'X\\': 10,\\n            \\'XL\\': 40,\\n            \\'L\\': 50, \\n            \\'XC\\': 90,\\n            \\'C\\': 100,\\n            \\'CD\\': 400,\\n            \\'D\\': 500,\\n            \\'CM\\': 900,\\n            \\'M\\': 1000\\n              }\\n        \\n        while i < len(s):\\n            if s[i:i+2] in map:\\n                res += map[s[i:i+2]]\\n                i += 2\\n            else:\\n                res += map[s[i]]\\n                i += 1\\n        \\n        return res\\n```\\n\\n**Arithmetic logic solution:**\\n* We build a dictionary, but without those need to subtract.\\n* If the number in the back is 5 times or 10 times bigger than the front, we need to subtract the number.\\n```\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        map = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\": 500, \"M\": 1000 }\\n        \\n        res, i = 0, 0\\n        while i < len(s)-1:\\n            if float(map[s[i]])/map[s[i+1]] == 0.2 or float(map[s[i]])/map[s[i+1]] == 0.1:\\n                res -= map[s[i]]\\n            else:\\n                res += map[s[i]]\\n            i += 1\\n        res += map[s[i]]\\n\\t\\t\\n        return(res)\\n```\\n\\n**String operation solution:**\\n* Replace `IV`, `IX`, `XL`,`XC`,`CD`,`CM`, so we can just calculate the sum.\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        #create dictionary\\n        values = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000} \\n\\t\\t\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\").replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\").replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n\\t\\t\\n        res = 0\\n        for c in s:\\n            res += values[c]\\n            \\n        return res\\n```\\n**Please UPVOTE if you LIKE!!**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        \\n        i, ans = 0, 0\\n        while i < len(s):\\n            if s[i] == \\'I\\':\\n                if i < len(s) - 1 and s[i + 1] == \\'V\\':\\n                    ans += 4\\n                    i += 1\\n                elif i < len(s) - 1 and s[i + 1] == \\'X\\':\\n                    ans += 9\\n                    i += 1\\n                else:\\n                    ans += 1\\n            elif s[i] == \\'V\\':\\n                ans += 5\\n            elif s[i] == \\'X\\':\\n                if i < len(s) - 1 and s[i + 1] == \\'L\\':\\n                    ans += 40\\n                    i += 1\\n                elif i < len(s) - 1 and s[i + 1] == \\'C\\':\\n                    ans += 90\\n                    i += 1\\n                else:\\n                    ans += 10\\n            elif s[i] == \\'L\\':\\n                ans += 50\\n            elif s[i] == \\'C\\':\\n                if i < len(s) - 1 and s[i + 1] == \\'D\\':\\n                    ans += 400\\n                    i += 1\\n                elif i < len(s) - 1 and s[i + 1] == \\'M\\':\\n                    ans += 900\\n                    i += 1\\n                else:\\n                    ans += 100\\n            elif s[i] == \\'D\\':\\n                ans += 500\\n            elif s[i] == \\'M\\':\\n                ans += 1000\\n            i += 1\\n                \\n        return ans\\n```\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        \\n        res, i = 0, 0\\n        map = {\\n            \\'I\\': 1,\\n            \\'IV\\': 4,\\n            \\'V\\': 5, \\n            \\'IX\\': 9, \\n            \\'X\\': 10,\\n            \\'XL\\': 40,\\n            \\'L\\': 50, \\n            \\'XC\\': 90,\\n            \\'C\\': 100,\\n            \\'CD\\': 400,\\n            \\'D\\': 500,\\n            \\'CM\\': 900,\\n            \\'M\\': 1000\\n              }\\n        \\n        while i < len(s):\\n            if s[i:i+2] in map:\\n                res += map[s[i:i+2]]\\n                i += 2\\n            else:\\n                res += map[s[i]]\\n                i += 1\\n        \\n        return res\\n```\n```\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        map = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\": 500, \"M\": 1000 }\\n        \\n        res, i = 0, 0\\n        while i < len(s)-1:\\n            if float(map[s[i]])/map[s[i+1]] == 0.2 or float(map[s[i]])/map[s[i+1]] == 0.1:\\n                res -= map[s[i]]\\n            else:\\n                res += map[s[i]]\\n            i += 1\\n        res += map[s[i]]\\n\\t\\t\\n        return(res)\\n```\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        #create dictionary\\n        values = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000} \\n\\t\\t\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\").replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\").replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n\\t\\t\\n        res = 0\\n        for c in s:\\n            res += values[c]\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871007,
                "title": "easiest-c-code-explained-with-comments-hashmap-approach",
                "content": "Here is my complete code, explained with comments at each step. Just go through the code and you will easily get this.\\nAlso Upvote, if this helps.\\n\\n```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        // creating a map to store the character and its value\\n        unordered_map<char,int> m;\\n        m[\\'I\\']=1;\\n        m[\\'V\\']=5;\\n        m[\\'X\\']=10;\\n        m[\\'L\\']=50;\\n        m[\\'C\\']=100;\\n        m[\\'D\\']=500;\\n        m[\\'M\\']=1000;\\n        int n=s.length();\\n        int ans=0;\\n        for(int i=0;i<n;)\\n        {\\n            // if the value of the next element is greater than previous one \\n            // for example if we encounter IX , then basically we need to subtract the value of \\'I\\' from value of \\'X\\' and then add to answer and then also increment the iterator i by 2 , as we have already considered i+1 element\\n            // \\'IX\\'= 10-1=9\\n            // \\'XL\\'= 50-10=40\\n            // \\'IV\\'= 5-1=4\\n            if(i+1<n && m[s[i]]<m[s[i+1]])\\n            {\\n                ans=ans+m[s[i+1]]-m[s[i]];\\n                i=i+2;\\n            }\\n            // else we can simply add the value of s[i] to answer and increment i by 1\\n            // example- \\'VIII\\' = 5+1+1+1 = 8\\n            //          \\'LX\\' = 50+10=60    \\n            else\\n            {\\n                ans=ans+m[s[i]];\\n                i++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        // creating a map to store the character and its value\\n        unordered_map<char,int> m;\\n        m[\\'I\\']=1;\\n        m[\\'V\\']=5;\\n        m[\\'X\\']=10;\\n        m[\\'L\\']=50;\\n        m[\\'C\\']=100;\\n        m[\\'D\\']=500;\\n        m[\\'M\\']=1000;\\n        int n=s.length();\\n        int ans=0;\\n        for(int i=0;i<n;)\\n        {\\n            // if the value of the next element is greater than previous one \\n            // for example if we encounter IX , then basically we need to subtract the value of \\'I\\' from value of \\'X\\' and then add to answer and then also increment the iterator i by 2 , as we have already considered i+1 element\\n            // \\'IX\\'= 10-1=9\\n            // \\'XL\\'= 50-10=40\\n            // \\'IV\\'= 5-1=4\\n            if(i+1<n && m[s[i]]<m[s[i+1]])\\n            {\\n                ans=ans+m[s[i+1]]-m[s[i]];\\n                i=i+2;\\n            }\\n            // else we can simply add the value of s[i] to answer and increment i by 1\\n            // example- \\'VIII\\' = 5+1+1+1 = 8\\n            //          \\'LX\\' = 50+10=60    \\n            else\\n            {\\n                ans=ans+m[s[i]];\\n                i++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486974,
                "title": "c-100",
                "content": "class Solution \\n{\\n    private:\\n    \\n    int fun(const char a)\\n    {\\n        if(a == \\'I\\') return 1;\\n        if(a == \\'V\\') return 5;\\n        if(a == \\'X\\') return 10;\\n        if(a == \\'L\\') return 50;\\n        if(a == \\'C\\') return 100;\\n        if(a == \\'D\\') return 500;\\n        if(a == \\'M\\') return 1000;\\n        \\n        return 0;\\n    }\\n    \\n    public:\\n    \\n    int romanToInt(std::string s) \\n    {\\n        int res = 0;\\n        int dim = s.size();\\n        \\n        for(int i = 0; i < dim; i++)\\n        {\\n            if(i < (dim - 1) && \\n               fun(s[i]) < fun(s[i+1]))\\n            {\\n                res -= fun(s[i]);\\n            }\\n            else\\n            {\\n                res += fun(s[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution \\n{\\n    private:\\n    \\n    int fun(const char a)\\n    {\\n        if(a == \\'I\\') return 1;\\n        if(a == \\'V\\') return 5;\\n        if(a == \\'X\\') return 10;\\n        if(a == \\'L\\') return 50;\\n        if(a == \\'C\\') return 100;\\n        if(a == \\'D\\') return 500;\\n        if(a == \\'M\\') return 1000;\\n        \\n        return 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 6507,
                "title": "easy-to-understand-java",
                "content": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        HashMap<Character, Integer> m = new HashMap<Character, Integer>();\\n        m.put('I',1);\\n        m.put('V',5);\\n        m.put('X',10);\\n        m.put('L',50);\\n        m.put('C',100);\\n        m.put('D',500);\\n        m.put('M',1000);\\n        char [] c = s.toCharArray();\\n        int [] n = new int[c.length];\\n        for(int i=0;i<n.length;i++)n[i]=m.get(c[i]);\\n        int sum=0;\\n        for(int i=0;i<n.length;i++)sum = i==c.length-1||n[i]>=n[i+1]?sum+n[i]:sum-n[i];\\n        return sum;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int romanToInt(String s) {\\n        HashMap<Character, Integer> m = new HashMap<Character, Integer>();\\n        m.put('I',1);\\n        m.put('V',5);\\n        m.put('X',10);\\n        m.put('L',50);\\n        m.put('C',100);\\n        m.put('D',500);\\n        m.put('M',1000);\\n        char [] c = s.toCharArray();\\n        int [] n = new int[c.length];\\n        for(int i=0;i<n.length;i++)n[i]=m.get(c[i]);\\n        int sum=0;\\n        for(int i=0;i<n.length;i++)sum = i==c.length-1||n[i]>=n[i+1]?sum+n[i]:sum-n[i];\\n        return sum;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2427245,
                "title": "java-3-4-liner-solution-using-switch-case",
                "content": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n      int ans = 0, num = 0;\\n      for(int i = s.length() - 1; i >= 0; i --) {\\n        switch(s.charAt(i)) {\\n          case \\'I\\' : num = 1; break;\\n          case \\'V\\' : num = 5; break;\\n          case \\'X\\' : num = 10; break;\\n          case \\'L\\' : num = 50; break;\\n          case \\'C\\' : num = 100; break;\\n          case \\'D\\' : num = 500; break;\\n          case \\'M\\' : num = 1000; break;\\n        }\\n        if(4 * num < ans) ans -= num;\\n        else ans += num;\\n      }\\n      return ans;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n      int ans = 0, num = 0;\\n      for(int i = s.length() - 1; i >= 0; i --) {\\n        switch(s.charAt(i)) {\\n          case \\'I\\' : num = 1; break;\\n          case \\'V\\' : num = 5; break;\\n          case \\'X\\' : num = 10; break;\\n          case \\'L\\' : num = 50; break;\\n          case \\'C\\' : num = 100; break;\\n          case \\'D\\' : num = 500; break;\\n          case \\'M\\' : num = 1000; break;\\n        }\\n        if(4 * num < ans) ans -= num;\\n        else ans += num;\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301102,
                "title": "java-explained-fastest-loops",
                "content": "```\\n\\n```class Solution {\\n    public int romanToInt(String s) {\\n      \\n       int[] ar = new int[s.length()];\\n        \\n\\t\\t//we store the value in  array so it easy for us to add numbers\\n        for(int i=0;i<ar.length;i++){\\n            char c = s.charAt(i);\\n            switch(c){\\n                case \\'I\\' : ar[i]=1;\\n                    break;\\n                case \\'V\\': ar[i]=5;\\n                    break;\\n                case \\'X\\': ar[i]=10;\\n                    break;\\n                case \\'L\\' : ar[i]=50;\\n                    break;\\n                case \\'C\\' : ar[i]=100;\\n                    break;\\n                case \\'D\\' : ar[i]=500;\\n                    break;\\n                case \\'M\\' : ar[i]=1000;\\n                    break;\\n            }\\n        }\\n        int result =ar[ar.length-1];\\n        \\n        //we itirate  from back bcoz roman number is written from right to left\\n        \\n        for(int i=ar.length-2;i>=0;i--){\\n            if(ar[i+1]>ar[i]){\\n                result-=ar[i];\\n            }else{\\n                result+=ar[i];\\n            }\\n                \\n            \\n        }\\n        return result;\\n    }\\n}\\n**KINDLY UPVOTE IF FIND HELPFUL**",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 973042,
                "title": "c-solution",
                "content": "Runtime: 4 ms, faster than 87.28% of C online submissions for Roman to Integer.\\nMemory Usage: 5.8 MB, less than 98.48% of C online submissions for Roman to Integer.\\n```c=\\nint value(char opcode){\\n    switch(opcode){\\n        case \\'I\\': \\n                return 1;\\n        case \\'V\\': \\n                return 5;\\n        case \\'X\\': \\n                return 10;\\n        case \\'L\\': \\n                return 50;\\n        case \\'C\\': \\n                return 100;\\n        case \\'D\\': \\n                return 500;\\n        case \\'M\\': \\n                return 1000;\\n        }\\n    return 0;\\n}\\nint romanToInt(char * s){\\n    int sum = 0;\\n    for(int i = 0; s[i] !=\\'\\\\0\\'; i++){\\n        if(value(s[i]) < value(s[i + 1]))\\n            sum = sum - value(s[i]);\\n        else\\n            sum += value(s[i]);\\n    }\\n    return sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```c=\\nint value(char opcode){\\n    switch(opcode){\\n        case \\'I\\': \\n                return 1;\\n        case \\'V\\': \\n                return 5;\\n        case \\'X\\': \\n                return 10;\\n        case \\'L\\': \\n                return 50;\\n        case \\'C\\': \\n                return 100;\\n        case \\'D\\': \\n                return 500;\\n        case \\'M\\': \\n                return 1000;\\n        }\\n    return 0;\\n}\\nint romanToInt(char * s){\\n    int sum = 0;\\n    for(int i = 0; s[i] !=\\'\\\\0\\'; i++){\\n        if(value(s[i]) < value(s[i + 1]))\\n            sum = sum - value(s[i]);\\n        else\\n            sum += value(s[i]);\\n    }\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3003093,
                "title": "o-n-solution-easy-string-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to store roman values first at a place to calculate the value\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStored elements in hashmap\\ntraversed string from back,if current element is of less value than the prev(case:\"IV\") we subtract current number from are answer otherwise(case:\"C\") add it we also store the prev elements value in a prev to make decision\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        if(s.length()==0)return 0;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n         map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int prev=0;\\n        int x=0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(prev>map.get(s.charAt(i))){\\n                x-=map.get(s.charAt(i));\\n            }\\n            else{\\n                 x+=map.get(s.charAt(i));\\n            }\\n            prev=map.get(s.charAt(i));\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        if(s.length()==0)return 0;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n         map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int prev=0;\\n        int x=0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(prev>map.get(s.charAt(i))){\\n                x-=map.get(s.charAt(i));\\n            }\\n            else{\\n                 x+=map.get(s.charAt(i));\\n            }\\n            prev=map.get(s.charAt(i));\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429803,
                "title": "python-99-beginner-friendly-4-solution-explained-easy-to-understand",
                "content": "**Brutal force:**\\n* In this solution, we just need a bunch of if statement.\\n* If we encounter  `I`, we need to check if there are `V` and `X` after it.\\n* If we encounter  `X`, we need to check if there are `L` and `C` after it.\\n* If we encounter  `C`, we need to check if there are `D` and `M` after it.\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        \\n        i, ans = 0, 0\\n        while i < len(s):\\n            if s[i] == \\'I\\':\\n                if i < len(s) - 1 and s[i + 1] == \\'V\\':\\n                    ans += 4\\n                    i += 1\\n                elif i < len(s) - 1 and s[i + 1] == \\'X\\':\\n                    ans += 9\\n                    i += 1\\n                else:\\n                    ans += 1\\n            elif s[i] == \\'V\\':\\n                ans += 5\\n            elif s[i] == \\'X\\':\\n                if i < len(s) - 1 and s[i + 1] == \\'L\\':\\n                    ans += 40\\n                    i += 1\\n                elif i < len(s) - 1 and s[i + 1] == \\'C\\':\\n                    ans += 90\\n                    i += 1\\n                else:\\n                    ans += 10\\n            elif s[i] == \\'L\\':\\n                ans += 50\\n            elif s[i] == \\'C\\':\\n                if i < len(s) - 1 and s[i + 1] == \\'D\\':\\n                    ans += 400\\n                    i += 1\\n                elif i < len(s) - 1 and s[i + 1] == \\'M\\':\\n                    ans += 900\\n                    i += 1\\n                else:\\n                    ans += 100\\n            elif s[i] == \\'D\\':\\n                ans += 500\\n            elif s[i] == \\'M\\':\\n                ans += 1000\\n            i += 1\\n                \\n        return ans\\n```\\n\\n**Dictionary solution:**\\n* We add every possible numbers in the dictionary.\\n* Then just use a while loop to calculate the sum.\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        \\n        res, i = 0, 0\\n        map = {\\n            \\'I\\': 1,\\n            \\'IV\\': 4,\\n            \\'V\\': 5, \\n            \\'IX\\': 9, \\n            \\'X\\': 10,\\n            \\'XL\\': 40,\\n            \\'L\\': 50, \\n            \\'XC\\': 90,\\n            \\'C\\': 100,\\n            \\'CD\\': 400,\\n            \\'D\\': 500,\\n            \\'CM\\': 900,\\n            \\'M\\': 1000\\n              }\\n        \\n        while i < len(s):\\n            if s[i:i+2] in map:\\n                res += map[s[i:i+2]]\\n                i += 2\\n            else:\\n                res += map[s[i]]\\n                i += 1\\n        \\n        return res\\n```\\n\\n**Arithmetic logic solution:**\\n* We build a dictionary, but without those need to subtract.\\n* If the number in the back is 5 times or 10 times bigger than the front, we need to subtract the number.\\n```\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        map = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\": 500, \"M\": 1000 }\\n        \\n        res, i = 0, 0\\n        while i < len(s)-1:\\n            if float(map[s[i]])/map[s[i+1]] == 0.2 or float(map[s[i]])/map[s[i+1]] == 0.1:\\n                res -= map[s[i]]\\n            else:\\n                res += map[s[i]]\\n            i += 1\\n        res += map[s[i]]\\n\\t\\t\\n        return(res)\\n```\\n\\n**String operation solution:**\\n* Replace `IV`, `IX`, `XL`,`XC`,`CD`,`CM`, so we can just calculate the sum.\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        #create dictionary\\n        values = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000} \\n\\t\\t\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\").replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\").replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n\\t\\t\\n        res = 0\\n        for c in s:\\n            res += values[c]\\n            \\n        return res\\n```\\n**Please UPVOTE if you LIKE!!**\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        \\n        i, ans = 0, 0\\n        while i < len(s):\\n            if s[i] == \\'I\\':\\n                if i < len(s) - 1 and s[i + 1] == \\'V\\':\\n                    ans += 4\\n                    i += 1\\n                elif i < len(s) - 1 and s[i + 1] == \\'X\\':\\n                    ans += 9\\n                    i += 1\\n                else:\\n                    ans += 1\\n            elif s[i] == \\'V\\':\\n                ans += 5\\n            elif s[i] == \\'X\\':\\n                if i < len(s) - 1 and s[i + 1] == \\'L\\':\\n                    ans += 40\\n                    i += 1\\n                elif i < len(s) - 1 and s[i + 1] == \\'C\\':\\n                    ans += 90\\n                    i += 1\\n                else:\\n                    ans += 10\\n            elif s[i] == \\'L\\':\\n                ans += 50\\n            elif s[i] == \\'C\\':\\n                if i < len(s) - 1 and s[i + 1] == \\'D\\':\\n                    ans += 400\\n                    i += 1\\n                elif i < len(s) - 1 and s[i + 1] == \\'M\\':\\n                    ans += 900\\n                    i += 1\\n                else:\\n                    ans += 100\\n            elif s[i] == \\'D\\':\\n                ans += 500\\n            elif s[i] == \\'M\\':\\n                ans += 1000\\n            i += 1\\n                \\n        return ans\\n```\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        \\n        res, i = 0, 0\\n        map = {\\n            \\'I\\': 1,\\n            \\'IV\\': 4,\\n            \\'V\\': 5, \\n            \\'IX\\': 9, \\n            \\'X\\': 10,\\n            \\'XL\\': 40,\\n            \\'L\\': 50, \\n            \\'XC\\': 90,\\n            \\'C\\': 100,\\n            \\'CD\\': 400,\\n            \\'D\\': 500,\\n            \\'CM\\': 900,\\n            \\'M\\': 1000\\n              }\\n        \\n        while i < len(s):\\n            if s[i:i+2] in map:\\n                res += map[s[i:i+2]]\\n                i += 2\\n            else:\\n                res += map[s[i]]\\n                i += 1\\n        \\n        return res\\n```\n```\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        map = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\": 500, \"M\": 1000 }\\n        \\n        res, i = 0, 0\\n        while i < len(s)-1:\\n            if float(map[s[i]])/map[s[i+1]] == 0.2 or float(map[s[i]])/map[s[i+1]] == 0.1:\\n                res -= map[s[i]]\\n            else:\\n                res += map[s[i]]\\n            i += 1\\n        res += map[s[i]]\\n\\t\\t\\n        return(res)\\n```\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        #create dictionary\\n        values = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000} \\n\\t\\t\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\").replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\").replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n\\t\\t\\n        res = 0\\n        for c in s:\\n            res += values[c]\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329728,
                "title": "c-java-python3-javascript-solution-easy",
                "content": "### C#,Java,Python3,JavaScript different solution with explanation\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/)\\u2B50**\\n\\n**\\uD83E\\uDDE1See next question solution - [Zyrastory-Longest Common Prefix](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**Thanks!**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "### C#,Java,Python3,JavaScript different solution with explanation\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/)\\u2B50**\\n\\n**\\uD83E\\uDDE1See next question solution - [Zyrastory-Longest Common Prefix](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**Thanks!**",
                "codeTag": "Unknown"
            },
            {
                "id": 1074841,
                "title": "python-super-simple-easy-to-understand-explained-solution",
                "content": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        num_dict = {   \\'I\\' : 1,\\n                       \\'V\\' : 5,\\n                       \\'X\\' : 10,\\n                       \\'L\\' : 50,\\n                       \\'C\\' : 100,\\n                       \\'D\\' : 500,\\n                       \\'M\\' : 1000 }\\n        res=0\\n        i = 0\\n        \\n        while i < len(s)-1:\\n            if num_dict[s[i]] >= num_dict[s[i+1]]: # just add number to res\\n                res += num_dict[s[i]]\\n                i+=1\\n            else:\\n                res += num_dict[s[i+1]]-num_dict[s[i]] # if s[i]<s[i+1]: subtract from next number\\n                i+=2\\n                \\n        if i < len(s): # if last digit left\\n            res += num_dict[s[i]]\\n            \\n        return res\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        num_dict = {   \\'I\\' : 1,\\n                       \\'V\\' : 5,\\n                       \\'X\\' : 10,\\n                       \\'L\\' : 50,\\n                       \\'C\\' : 100,\\n                       \\'D\\' : 500,\\n                       \\'M\\' : 1000 }\\n        res=0\\n        i = 0\\n        \\n        while i < len(s)-1:\\n            if num_dict[s[i]] >= num_dict[s[i+1]]: # just add number to res\\n                res += num_dict[s[i]]\\n                i+=1\\n            else:\\n                res += num_dict[s[i+1]]-num_dict[s[i]] # if s[i]<s[i+1]: subtract from next number\\n                i+=2\\n                \\n        if i < len(s): # if last digit left\\n            res += num_dict[s[i]]\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373635,
                "title": "javascript-runtime-95",
                "content": "```\\n/**\\n * Runtime: 128 ms, faster than 95.62% of JavaScript online submissions for Roman to Integer.\\n * Memory Usage: 39.7 MB, less than 61.70% of JavaScript online submissions for Roman to Integer.\\n */\\nvar romanToInt = function(s) {\\n    let hash ={I:1, V:5, X:10, L:50, C:100, D:500, M:1000}\\n    let ans = 0, cur = 0, prev = 0, j = s.length - 1\\n    for( ; j >= 0; j-=1){\\n        cur = hash[s[j]]\\n        cur < prev ? ans -= cur : ans += cur\\n        prev = cur\\n    }\\n    return ans;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Runtime: 128 ms, faster than 95.62% of JavaScript online submissions for Roman to Integer.\\n * Memory Usage: 39.7 MB, less than 61.70% of JavaScript online submissions for Roman to Integer.\\n */\\nvar romanToInt = function(s) {\\n    let hash ={I:1, V:5, X:10, L:50, C:100, D:500, M:1000}\\n    let ans = 0, cur = 0, prev = 0, j = s.length - 1\\n    for( ; j >= 0; j-=1){\\n        cur = hash[s[j]]\\n        cur < prev ? ans -= cur : ans += cur\\n        prev = cur\\n    }\\n    return ans;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 373357,
                "title": "simple-javascript-solution",
                "content": "```\\nvar romanToInt = function(s) {\\n    let table = {\\n        I: 1,\\n        V: 5,\\n        X: 10,\\n        L: 50,\\n        C: 100,\\n        D: 500,\\n        M: 1000\\n    }\\n    \\n    let result = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        //if the next roman numeral is larger, then we know we have to subtract this number\\n        if (table[s[i]] < table[s[i+1]]) {\\n            result-=table[s[i]]\\n        } \\n        //otherwise, add like normal. \\n        else {\\n            result+=table[s[i]]\\n        }\\n    }\\n    return result\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar romanToInt = function(s) {\\n    let table = {\\n        I: 1,\\n        V: 5,\\n        X: 10,\\n        L: 50,\\n        C: 100,\\n        D: 500,\\n        M: 1000\\n    }\\n    \\n    let result = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        //if the next roman numeral is larger, then we know we have to subtract this number\\n        if (table[s[i]] < table[s[i+1]]) {\\n            result-=table[s[i]]\\n        } \\n        //otherwise, add like normal. \\n        else {\\n            result+=table[s[i]]\\n        }\\n    }\\n    return result\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6851,
                "title": "simple-56ms-c-solution",
                "content": "Processing the roman number from right to left turns out to be a bit easier since we can easily tell when to add or subtract:\\n\\n    class Solution {\\n    public:\\n        int romanToInt(string s) {\\n            if (s.empty()) { return 0; }\\n            unordered_map<char, int> mp { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000} };\\n            int sum = mp[s.back()];\\n            for (int i = s.size() - 2; i >= 0; --i) {\\n                sum += mp[s[i]] >= mp[s[i + 1]] ? mp[s[i]] : -mp[s[i]];\\n            }\\n            return sum;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int romanToInt(string s) {\\n            if (s.empty()) { return 0; }",
                "codeTag": "Java"
            },
            {
                "id": 2372626,
                "title": "clean-efficient-and-easy-to-read-python-beats-99-5",
                "content": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        \\'\\'\\' faster solution which doesn\\'t require iterating through every element of s (currently faster than 99.49% of submissions\\'\\'\\'\\n\\n        # store all possible conversions\\n        roman_conversion = {\"IV\": 4, \"IX\": 9, \"XL\": 40, \"XC\": 90, \"CD\": 400, \"CM\": 900, \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n\\n        ret = 0\\n\\n        # dictionary is ordered, so we find if string contains special cases first\\n        for k, v in roman_conversion.items():\\n            if k in s:\\n                ret += s.count(k) * v\\n                s = s.replace(k, \"\")\\n\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        \\'\\'\\' faster solution which doesn\\'t require iterating through every element of s (currently faster than 99.49% of submissions\\'\\'\\'\\n\\n        # store all possible conversions\\n        roman_conversion = {\"IV\": 4, \"IX\": 9, \"XL\": 40, \"XC\": 90, \"CD\": 400, \"CM\": 900, \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n\\n        ret = 0\\n\\n        # dictionary is ordered, so we find if string contains special cases first\\n        for k, v in roman_conversion.items():\\n            if k in s:\\n                ret += s.count(k) * v\\n                s = s.replace(k, \"\")\\n\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899590,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func romanToInt(_ s: String) -> Int {\\n\\t\\tvar num: Int = 0\\n\\t\\tvar prev: Character = \" \"\\n\\t\\tlet map: [Character : Int] = [\\n\\t\\t\\t\"I\": 1,\\n\\t\\t\\t\"V\": 5,\\n\\t\\t\\t\"X\": 10,\\n\\t\\t\\t\"L\": 50,\\n\\t\\t\\t\"C\": 100,\\n\\t\\t\\t\"D\": 500,\\n\\t\\t\\t\"M\": 1000,\\n\\t\\t]\\n\\t\\t        \\n\\t\\tfor c in s {\\n\\t\\t\\tif prev == \"I\" && (c == \"V\" || c == \"X\") {\\n\\t\\t\\t\\tnum += (map[c]! - 2 * map[prev]!)\\n\\t\\t\\t} else if prev == \"X\" && (c == \"L\" || c == \"C\") {\\n\\t\\t\\t\\tnum += (map[c]! - 2 * map[prev]!) \\n\\t\\t\\t} else if prev == \"C\" && (c == \"D\" || c == \"M\") {\\n\\t\\t\\t\\tnum += (map[c]! - 2 * map[prev]!)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnum += map[c]!\\n\\t\\t\\t}\\n\\t\\t\\tprev = c\\n\\t\\t}\\n        \\n        return num\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func romanToInt(_ s: String) -> Int {\\n\\t\\tvar num: Int = 0\\n\\t\\tvar prev: Character = \" \"\\n\\t\\tlet map: [Character : Int] = [\\n\\t\\t\\t\"I\": 1,\\n\\t\\t\\t\"V\": 5,\\n\\t\\t\\t\"X\": 10,\\n\\t\\t\\t\"L\": 50,\\n\\t\\t\\t\"C\": 100,\\n\\t\\t\\t\"D\": 500,\\n\\t\\t\\t\"M\": 1000,\\n\\t\\t]\\n\\t\\t        \\n\\t\\tfor c in s {\\n\\t\\t\\tif prev == \"I\" && (c == \"V\" || c == \"X\") {\\n\\t\\t\\t\\tnum += (map[c]! - 2 * map[prev]!)\\n\\t\\t\\t} else if prev == \"X\" && (c == \"L\" || c == \"C\") {\\n\\t\\t\\t\\tnum += (map[c]! - 2 * map[prev]!) \\n\\t\\t\\t} else if prev == \"C\" && (c == \"D\" || c == \"M\") {\\n\\t\\t\\t\\tnum += (map[c]! - 2 * map[prev]!)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnum += map[c]!\\n\\t\\t\\t}\\n\\t\\t\\tprev = c\\n\\t\\t}\\n        \\n        return num\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313491,
                "title": "c-time-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n    vector<int>v(256);\\n    v[\\'I\\']=1,v[\\'V\\']=5,v[\\'X\\']=10,v[\\'L\\']=50,v[\\'C\\']=100,v[\\'D\\']=500,v[\\'M\\']=1000;\\n        int sum=0;\\n        for(int i=0;i<s.length();i++){\\n            if(v[s[i]]<v[s[i+1]]){\\n                sum=sum-v[s[i]];\\n            }\\n            else{\\n                sum=sum+v[s[i]];\\n            }\\n        }\\n        return sum;  \\n    }\\n};\\n```\\nif you like the solution upvote it and encourage me.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n    vector<int>v(256);\\n    v[\\'I\\']=1,v[\\'V\\']=5,v[\\'X\\']=10,v[\\'L\\']=50,v[\\'C\\']=100,v[\\'D\\']=500,v[\\'M\\']=1000;\\n        int sum=0;\\n        for(int i=0;i<s.length();i++){\\n            if(v[s[i]]<v[s[i+1]]){\\n                sum=sum-v[s[i]];\\n            }\\n            else{\\n                sum=sum+v[s[i]];\\n            }\\n        }\\n        return sum;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684734,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int RomanToInt(string s) {\\n        if (s == null || s == string.Empty)\\n            return 0;\\n        \\n        Dictionary<string, int> dict = new Dictionary<string, int>();\\n        int result = 0;\\n        \\n        dict.Add(\"I\", 1);\\n        dict.Add(\"V\", 5);\\n        dict.Add(\"X\", 10);\\n        dict.Add(\"L\", 50);\\n        dict.Add(\"C\", 100);\\n        dict.Add(\"D\", 500);\\n        dict.Add(\"M\", 1000);\\n        dict.Add(\"IV\", 4);\\n        dict.Add(\"IX\", 9);\\n        dict.Add(\"XL\", 40);\\n        dict.Add(\"XC\", 90);\\n        dict.Add(\"CD\", 400);\\n        dict.Add(\"CM\", 900);\\n        \\n        for (int i = 0; i < s.Length; i++)\\n            if ((s[i] == \\'I\\' || s[i] == \\'X\\' || s[i] == \\'C\\') && i < s.Length - 1 && dict.ContainsKey(s.Substring(i, 2)))\\n                result += dict[s.Substring(i++, 2)];\\n            else\\n                result += dict[s[i].ToString()];\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int RomanToInt(string s) {\\n        if (s == null || s == string.Empty)\\n            return 0;\\n        \\n        Dictionary<string, int> dict = new Dictionary<string, int>();\\n        int result = 0;\\n        \\n        dict.Add(\"I\", 1);\\n        dict.Add(\"V\", 5);\\n        dict.Add(\"X\", 10);\\n        dict.Add(\"L\", 50);\\n        dict.Add(\"C\", 100);\\n        dict.Add(\"D\", 500);\\n        dict.Add(\"M\", 1000);\\n        dict.Add(\"IV\", 4);\\n        dict.Add(\"IX\", 9);\\n        dict.Add(\"XL\", 40);\\n        dict.Add(\"XC\", 90);\\n        dict.Add(\"CD\", 400);\\n        dict.Add(\"CM\", 900);\\n        \\n        for (int i = 0; i < s.Length; i++)\\n            if ((s[i] == \\'I\\' || s[i] == \\'X\\' || s[i] == \\'C\\') && i < s.Length - 1 && dict.ContainsKey(s.Substring(i, 2)))\\n                result += dict[s.Substring(i++, 2)];\\n            else\\n                result += dict[s[i].ToString()];\\n        \\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 529554,
                "title": "javascript-easy-to-understand-o-n-98-56-with-an-explanation-on-medium",
                "content": "[Medium](https://medium.com/@anatoliy841993/leetcode-13-roman-to-integer-javascript-9b8bf3c38773)\\n\\n```\\nconst romanToInt = (s) => {\\n  const map = new Map([\\n    [\\'I\\', 1],\\n    [\\'V\\', 5],\\n    [\\'X\\', 10],\\n    [\\'L\\', 50],\\n    [\\'C\\', 100],\\n    [\\'D\\', 500],\\n    [\\'M\\', 1000],\\n  ]);\\n\\n  let sum = 0;\\n\\n  for (let i = 0; i < s.length; i += 1) {\\n    const curValue = map.get(s[i]);\\n    const nextValue = map.get(s[i + 1]);\\n\\n    if (nextValue > curValue) {\\n      sum = sum + nextValue - curValue;\\n      i += 1;\\n    } else {\\n      sum += curValue;\\n    }\\n  }\\n\\n  return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst romanToInt = (s) => {\\n  const map = new Map([\\n    [\\'I\\', 1],\\n    [\\'V\\', 5],\\n    [\\'X\\', 10],\\n    [\\'L\\', 50],\\n    [\\'C\\', 100],\\n    [\\'D\\', 500],\\n    [\\'M\\', 1000],\\n  ]);\\n\\n  let sum = 0;\\n\\n  for (let i = 0; i < s.length; i += 1) {\\n    const curValue = map.get(s[i]);\\n    const nextValue = map.get(s[i + 1]);\\n\\n    if (nextValue > curValue) {\\n      sum = sum + nextValue - curValue;\\n      i += 1;\\n    } else {\\n      sum += curValue;\\n    }\\n  }\\n\\n  return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282553,
                "title": "java-clean-solution",
                "content": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int[] map = new int[256];\\n        map[\\'I\\'] = 1; map[\\'V\\'] = 5; map[\\'X\\'] = 10; map[\\'L\\'] = 50; map[\\'C\\'] = 100; map[\\'D\\'] = 500; map[\\'M\\'] = 1000;\\n        \\n        int ret = 0, pre = 1;\\n        for (int i = s.length()-1; i >= 0; --i) {\\n            int cur = map[s.charAt(i)];\\n            if (cur < pre) ret -= cur;\\n            else {\\n                pre = cur;\\n                ret += cur;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int[] map = new int[256];\\n        map[\\'I\\'] = 1; map[\\'V\\'] = 5; map[\\'X\\'] = 10; map[\\'L\\'] = 50; map[\\'C\\'] = 100; map[\\'D\\'] = 500; map[\\'M\\'] = 1000;\\n        \\n        int ret = 0, pre = 1;\\n        for (int i = s.length()-1; i >= 0; --i) {\\n            int cur = map[s.charAt(i)];\\n            if (cur < pre) ret -= cur;\\n            else {\\n                pre = cur;\\n                ret += cur;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6771,
                "title": "7-line-python-solution-160ms",
                "content": "First sum up all single roman numerals, then if we find `currValue` > `prevValue`, we subtract `2 * prevValue`, e.g. `CM`, first we get 1100, then we subtract 200, the result is 900.\\n\\n    def romanToInt(self, s):\\n        value, prevValue, result = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}, None, 0\\n        for ch in s:\\n            currValue = value[ch]\\n            result += currValue\\n            if prevValue and currValue > prevValue: result -= 2 * prevValue\\n            prevValue = currValue\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "First sum up all single roman numerals, then if we find `currValue` > `prevValue`, we subtract `2 * prevValue`, e.g. `CM`, first we get 1100, then we subtract 200, the result is 900.\\n\\n    def romanToInt(self, s):\\n        value, prevValue, result = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}, None, 0\\n        for ch in s:\\n            currValue = value[ch]\\n            result += currValue\\n            if prevValue and currValue > prevValue: result -= 2 * prevValue\\n            prevValue = currValue\\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 3453510,
                "title": "easily-understandable-java-sol-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n\\n        int res = map.get(s.charAt(s.length()-1));\\n        for(int i=s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i)) < map.get(s.charAt(i+1))){\\n                res -= map.get(s.charAt(i));\\n            }else{\\n                res += map.get(s.charAt(i));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n\\n        int res = map.get(s.charAt(s.length()-1));\\n        for(int i=s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i)) < map.get(s.charAt(i+1))){\\n                res -= map.get(s.charAt(i));\\n            }else{\\n                res += map.get(s.charAt(i));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706769,
                "title": "java-easy-understandable-solution",
                "content": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        \\n        HashMap<Character,Integer> map=new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n    \\n    int sum=0;\\n    for(int i=0;i<s.length();i++){\\n        char ch=s.charAt(i);\\n        int a=map.get(ch);\\n        \\n        if(i+1<s.length()){\\n            int b=map.get(s.charAt(i+1));\\n            \\n            if(a>=b){\\n                sum=sum+a;\\n            }\\n            else{\\n                sum=sum-a;\\n            }\\n        }\\n        else{\\n            sum=sum+a;\\n        }\\n    }\\n    return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        \\n        HashMap<Character,Integer> map=new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n    \\n    int sum=0;\\n    for(int i=0;i<s.length();i++){\\n        char ch=s.charAt(i);\\n        int a=map.get(ch);\\n        \\n        if(i+1<s.length()){\\n            int b=map.get(s.charAt(i+1));\\n            \\n            if(a>=b){\\n                sum=sum+a;\\n            }\\n            else{\\n                sum=sum-a;\\n            }\\n        }\\n        else{\\n            sum=sum+a;\\n        }\\n    }\\n    return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229226,
                "title": "python3-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        \\n        # create a hashmap for our values\\n        roman = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        # create a result value to be returned\\n        result = 0\\n        \\n        for i in range(len(s)):\\n            # check if there is a \"next value\" (i + 1)\\n            # if there is then check if the next value is greater than the previous\\n            if i + 1 < len(s) and roman[s[i]] < roman[s[i+1]]:\\n                # if the previous value is less, we subtract that value from the result\\n                result -= roman[s[i]]\\n            # otherwise we add it to our result\\n            else: \\n                result += roman[s[i]]\\n            # we return the result we find\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        \\n        # create a hashmap for our values\\n        roman = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        # create a result value to be returned\\n        result = 0\\n        \\n        for i in range(len(s)):\\n            # check if there is a \"next value\" (i + 1)\\n            # if there is then check if the next value is greater than the previous\\n            if i + 1 < len(s) and roman[s[i]] < roman[s[i+1]]:\\n                # if the previous value is less, we subtract that value from the result\\n                result -= roman[s[i]]\\n            # otherwise we add it to our result\\n            else: \\n                result += roman[s[i]]\\n            # we return the result we find\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021425,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        roman = { \\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        res = 0\\n        \\n        for i in range(len(s)):\\n            if i+1 < len(s) and roman[s[i]] < roman[s[i+1]]:\\n                res -= roman[s[i]]\\n            else:\\n                res += roman[s[i]]            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        roman = { \\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        res = 0\\n        \\n        for i in range(len(s)):\\n            if i+1 < len(s) and roman[s[i]] < roman[s[i+1]]:\\n                res -= roman[s[i]]\\n            else:\\n                res += roman[s[i]]            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140243,
                "title": "python-solution-48ms-14-3mb-using-a-reversed-string",
                "content": "##### **Logic:**\\nIV = -1 + 5\\nVI = 5 + 1\\nXL = -10 + 50\\nLX = 50 + 10\\nSo, if a smaller number appears before a larger number, it indicates that the number is smaller by a quantity used as a suffix to it, which made going backwards seem easy.\\n\\n##### **Solution:**\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        dic = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        res, tmp = 0, 0\\n        for i in reversed(s):\\n            if dic[i]>=tmp:\\n                res=res+dic[i]\\n            else:\\n                res=res-dic[i]\\n            tmp=dic[i]\\n        return res\\n```\\n\\nThank you. :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        dic = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        res, tmp = 0, 0\\n        for i in reversed(s):\\n            if dic[i]>=tmp:\\n                res=res+dic[i]\\n            else:\\n                res=res-dic[i]\\n            tmp=dic[i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274007,
                "title": "clean-python-solution",
                "content": "Created a very simple algorithm for converting Roman numerals to integers:\\n1. \\tProcess the string from left to right up to last character. Use accumulator variable for summing total.\\n2. \\tCompare the integer value of the current character to the value of the character at the next index.\\n\\t* If character at next index has larger value, subtract the current character\\'s value from the total.\\n\\t* Else, add the current character\\'s value to the total.\\n3.  Add the value of the last character to the total.\\n\\n```\\n    def romanToInt(self, s: str) -> int:\\n        # Dictionary with values for Roman numerals\\n        ROMANS = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        \\n        # Variable for accumulating total\\n        number = 0\\n        \\n        # Process all characters except the last one\\n        for i in range(len(s) - 1):\\n            if ROMANS[s[i + 1]]  > ROMANS[s[i]]:\\n                number -= ROMANS[s[i]]\\n            else:\\n                number += ROMANS[s[i]]\\n                \\n        # Process last character\\n        number += ROMANS[s[len(s) - 1]]\\n        \\n        return number\\n```",
                "solutionTags": [],
                "code": "```\\n    def romanToInt(self, s: str) -> int:\\n        # Dictionary with values for Roman numerals\\n        ROMANS = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        \\n        # Variable for accumulating total\\n        number = 0\\n        \\n        # Process all characters except the last one\\n        for i in range(len(s) - 1):\\n            if ROMANS[s[i + 1]]  > ROMANS[s[i]]:\\n                number -= ROMANS[s[i]]\\n            else:\\n                number += ROMANS[s[i]]\\n                \\n        # Process last character\\n        number += ROMANS[s[len(s) - 1]]\\n        \\n        return number\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 154749,
                "title": "beautiful-scala",
                "content": "```\\nobject Solution {\\n    \\n    val dict: Map[Char, Int] = Map(\\n        \\'I\\' -> 1,\\n        \\'V\\' -> 5,\\n        \\'X\\' -> 10,\\n        \\'L\\' -> 50,\\n        \\'C\\' -> 100,\\n        \\'D\\' -> 500,\\n        \\'M\\' -> 1000\\n    )\\n\\n    def romanToInt(s: Seq[Char]): Int = s match {\\n      case Seq(a, b, t@_*) if dict(a) < dict(b)  =>  dict(b) - dict(a) + romanToInt(t)\\n      case Seq(a, t@_*) => dict(a) + romanToInt(t)        \\n      case _ => 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    \\n    val dict: Map[Char, Int] = Map(\\n        \\'I\\' -> 1,\\n        \\'V\\' -> 5,\\n        \\'X\\' -> 10,\\n        \\'L\\' -> 50,\\n        \\'C\\' -> 100,\\n        \\'D\\' -> 500,\\n        \\'M\\' -> 1000\\n    )\\n\\n    def romanToInt(s: Seq[Char]): Int = s match {\\n      case Seq(a, b, t@_*) if dict(a) < dict(b)  =>  dict(b) - dict(a) + romanToInt(t)\\n      case Seq(a, t@_*) => dict(a) + romanToInt(t)        \\n      case _ => 0\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 6570,
                "title": "ruby-solution",
                "content": "Here's a 155 ms runtime Ruby solution!  Not sure if it's the best, but I just wanted to contribute and help the Ruby community.\\n\\n```\\nROM_NUMS = {\\n    \"I\" => 1,\\n    \"V\" => 5,\\n    \"X\" => 10,\\n    \"L\" => 50,\\n    \"C\" => 100,\\n    \"D\" => 500,\\n    \"M\" => 1000\\n    }\\n\\ndef roman_to_int(s)\\n    res = 0\\n    temp = 0\\n    s.chars.each_with_index do |el, i|\\n        if ROM_NUMS[s[i + 1]] && ROM_NUMS[el] < ROM_NUMS[s[i+1]]\\n            temp = ROM_NUMS[el]\\n        else\\n            res += (ROM_NUMS[el] - temp)\\n            temp = 0\\n        end\\n    end\\n    res\\nend\\n```",
                "solutionTags": [],
                "code": "```\\nROM_NUMS = {\\n    \"I\" => 1,\\n    \"V\" => 5,\\n    \"X\" => 10,\\n    \"L\" => 50,\\n    \"C\" => 100,\\n    \"D\" => 500,\\n    \"M\" => 1000\\n    }\\n\\ndef roman_to_int(s)\\n    res = 0\\n    temp = 0\\n    s.chars.each_with_index do |el, i|\\n        if ROM_NUMS[s[i + 1]] && ROM_NUMS[el] < ROM_NUMS[s[i+1]]\\n            temp = ROM_NUMS[el]\\n        else\\n            res += (ROM_NUMS[el] - temp)\\n            temp = 0\\n        end\\n    end\\n    res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 6721,
                "title": "o-n-40ms-c-straightforward-solution",
                "content": "FYI :\\n\\n    class Solution {\\n    public:\\n    int romanToInt(string s) {\\n        int result=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            switch(s[i])\\n            {\\n            case 'I' :\\n           if(s[i+1]=='V'||s[i+1]=='X')\\n            result-=1;\\n            else\\n            result+=1;\\n            break;\\n            \\n            case 'V' :\\n            result+=5;\\n            break;\\n\\n            case 'X' :\\n            if(s[i+1]=='C'||s[i+1]=='L')\\n            result-=10;\\n            else\\n            result+=10;\\n            break;\\n            \\n            case 'L' :\\n            result+=50;\\n            break;\\n            \\n            case 'C' :\\n            if(s[i+1]=='D'||s[i+1]=='M')\\n            result-=100;\\n            else\\n            result+=100;\\n            break;\\n            \\n            case 'D' :\\n            result+=500;\\n            break;\\n            \\n            case 'M' :\\n            result+=1000;\\n            break;\\n            \\n            default:\\n            break;\\n            }\\n\\n        }\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    int romanToInt(string s) {\\n        int result=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            switch(s[i])\\n            {\\n            case 'I' :\\n           if(s[i+1]=='V'||s[i+1]=='X')\\n            result-=1;\\n            else\\n            result+=1;\\n            break;\\n            \\n            case 'V' :\\n            result+=5;\\n            break;\\n\\n            case 'X' :\\n            if(s[i+1]=='C'||s[i+1]=='L')\\n            result-=10;\\n            else\\n            result+=10;\\n            break;\\n            \\n            case 'L' :\\n            result+=50;\\n            break;\\n            \\n            case 'C' :\\n            if(s[i+1]=='D'||s[i+1]=='M')\\n            result-=100;\\n            else\\n            result+=100;\\n            break;\\n            \\n            case 'D' :\\n            result+=500;\\n            break;\\n            \\n            case 'M' :\\n            result+=1000;\\n            break;\\n            \\n            default:\\n            break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 6746,
                "title": "easy-to-understand-java-solution-beats-98-well-explained-with-comments",
                "content": "    public int romanToInt(String s) {\\n    \\t\\t  int result = 0 ;\\n    \\t\\t  char[] digits = s.toCharArray();\\n    \\t\\t  if(digits.length > 0){\\n                  /* Initialize value map for Roman chars  */\\n    \\t\\t\\t  int[] valueMap = new int[26];\\n    \\t\\t\\t  valueMap['I' - 'A'] = 1;\\n    \\t\\t\\t  valueMap['V' - 'A'] = 5;\\n    \\t\\t\\t  valueMap['X' - 'A'] = 10;\\n    \\t\\t\\t  valueMap['L' - 'A'] = 50;\\n    \\t\\t\\t  valueMap['C' - 'A'] = 100;\\n    \\t\\t\\t  valueMap['D' - 'A'] = 500;\\n    \\t\\t\\t  valueMap['M' - 'A'] = 1000;\\n    \\t\\t\\t  int lastIndex = digits[0] - 'A';\\n    \\t\\t\\t  result = valueMap[lastIndex];\\n    \\t\\t\\t  for(int i = 1 ; i < digits.length ; i++){\\n    \\t\\t\\t\\t  int currentIndex = digits[i] - 'A'; \\n                      // If previous number was smaller in value then remove the previous and decrease the current value by previous value\\n    \\t\\t\\t\\t  if(valueMap[lastIndex] < valueMap[currentIndex]){ \\n    \\t\\t\\t\\t\\t  result = result - 2*valueMap[lastIndex] + valueMap[currentIndex] ;\\n    \\t\\t\\t\\t  }else{\\n    \\t\\t\\t\\t\\t  result+= valueMap[currentIndex]; // just add the current value\\n    \\t\\t\\t\\t  }\\n    \\t\\t\\t\\t  lastIndex = currentIndex; // update last index\\n    \\t\\t\\t  }\\n    \\t\\t  }\\n    \\t\\t  return result;\\n    \\t  }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int romanToInt(String s) {\\n    \\t\\t  int result = 0 ;\\n    \\t\\t  char[] digits = s.toCharArray();\\n    \\t\\t  if(digits.length > 0){\\n                  /* Initialize value map for Roman chars  */\\n    \\t\\t\\t  int[] valueMap = new int[26];\\n    \\t\\t\\t  valueMap['I' - 'A'] = 1;\\n    \\t\\t\\t  valueMap['V' - 'A'] = 5;\\n    \\t\\t\\t  valueMap['X' - 'A'] = 10;\\n    \\t\\t\\t  valueMap['L' - 'A'] = 50;\\n    \\t\\t\\t  valueMap['C' - 'A'] = 100;\\n    \\t\\t\\t  valueMap['D' - 'A'] = 500;\\n    \\t\\t\\t  valueMap['M' - 'A'] = 1000;\\n    \\t\\t\\t  int lastIndex = digits[0] - 'A';\\n    \\t\\t\\t  result = valueMap[lastIndex];\\n    \\t\\t\\t  for(int i = 1 ; i < digits.length ; i++){\\n    \\t\\t\\t\\t  int currentIndex = digits[i] - 'A'; \\n                      // If previous number was smaller in value then remove the previous and decrease the current value by previous value\\n    \\t\\t\\t\\t  if(valueMap[lastIndex] < valueMap[currentIndex]){ \\n    \\t\\t\\t\\t\\t  result = result - 2*valueMap[lastIndex] + valueMap[currentIndex] ;\\n    \\t\\t\\t\\t  }else{\\n    \\t\\t\\t\\t\\t  result+= valueMap[currentIndex]; // just add the current value\\n    \\t\\t\\t\\t  }\\n    \\t\\t\\t\\t  lastIndex = currentIndex; // update last index\\n    \\t\\t\\t  }\\n    \\t\\t  }\\n    \\t\\t  return result;\\n    \\t  }",
                "codeTag": "Unknown"
            },
            {
                "id": 2669258,
                "title": "python-solution-with-hashmap",
                "content": "IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        alphabet = {\\n            \\'I\\': 1,\\n            \\'V\\': 5,\\n            \\'X\\': 10,\\n            \\'L\\': 50,\\n            \\'C\\': 100,\\n            \\'D\\': 500,\\n            \\'M\\': 1000,\\n        }\\n\\n        dec_number = 0\\n        last_add = 0\\n\\n        for ch in s[::-1]:\\n            if last_add > alphabet[ch]:\\n                dec_number -= alphabet[ch]\\n            else:\\n                dec_number += alphabet[ch]\\n            last_add = alphabet[ch]\\n\\n        return dec_number\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        alphabet = {\\n            \\'I\\': 1,\\n            \\'V\\': 5,\\n            \\'X\\': 10,\\n            \\'L\\': 50,\\n            \\'C\\': 100,\\n            \\'D\\': 500,\\n            \\'M\\': 1000,\\n        }\\n\\n        dec_number = 0\\n        last_add = 0\\n\\n        for ch in s[::-1]:\\n            if last_add > alphabet[ch]:\\n                dec_number -= alphabet[ch]\\n            else:\\n                dec_number += alphabet[ch]\\n            last_add = alphabet[ch]\\n\\n        return dec_number\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568192,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=Nc35iWWqT78\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n       unordered_map<char, int> um;\\n        um[\\'I\\']= 1;\\n        um[\\'V\\']= 5;\\n        um[\\'X\\']= 10;\\n        um[\\'L\\']=50;\\n        um[\\'C\\']= 100;\\n        um[\\'D\\']= 500;\\n        um[\\'M\\']= 1000;\\n        int ans=0;\\n        for(int i=s.size()-1; i>=0; i--){\\n            if(i!=0 && um[s[i-1]]<um[s[i]] ){\\n                 ans= ans+  um[s[i]]-um[s[i-1]]; \\n                i--;\\n                continue;\\n            }\\n            ans=ans+ um[s[i]];\\n        }\\n        return ans;\\n    }\\n};\\n    \\n```\\n**JAVA**(Copied)\\n```\\npublic int romanToInt(String s) {\\n        Map<Character, Integer> alphabet = initAlphabet();\\n        int result = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (alphabet.get(s.charAt(i)) < alphabet.get(s.charAt(i + 1)))\\n                result = result - alphabet.get(s.charAt(i));\\n            else \\n                result = result + alphabet.get(s.charAt(i));\\n        }\\n        return result + alphabet.get(s.charAt(s.length() - 1));\\n    }\\n\\n    private Map<Character, Integer> initAlphabet() {\\n        return Map.of(\\'I\\', 1, \\'V\\', 5, \\'X\\', 10, \\'L\\', 50, \\'C\\', 100, \\'D\\', 500, \\'M\\', 1000);\\n    }\\n```\\n**PYTHON**((Copied)\\n```\\nclass Solution:\\n\\t\\n\\n\\tROMAN_TO_INTEGER = {\\n\\t\\t\\'I\\':  1,\\n\\t\\t\\'IV\\': 4,\\n\\t\\t\\'V\\':  5,\\n\\t\\t\\'IX\\': 9,\\n\\t\\t\\'X\\':  10,\\n\\t\\t\\'XL\\': 40,\\n\\t\\t\\'L\\':  50,\\n\\t\\t\\'XC\\': 90,\\n\\t\\t\\'C\\':  100,\\n\\t\\t\\'CD\\': 400,\\n\\t\\t\\'D\\':  500,\\n\\t\\t\\'CM\\': 900,\\n\\t\\t\\'M\\':  1000,\\n\\t}\\n\\n\\tdef romanToInt(self, s: str) -> int:\\n\\t\\tconverted = 0\\n\\n\\t\\tfor roman, integer in self.ROMAN_TO_INTEGER.items():\\n\\t\\t\\twhile s.endswith(roman):\\n\\t\\t\\t\\ts = s.removesuffix(roman)\\n\\t\\t\\t\\tconverted += integer\\n\\n\\t\\treturn converted\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n       unordered_map<char, int> um;\\n        um[\\'I\\']= 1;\\n        um[\\'V\\']= 5;\\n        um[\\'X\\']= 10;\\n        um[\\'L\\']=50;\\n        um[\\'C\\']= 100;\\n        um[\\'D\\']= 500;\\n        um[\\'M\\']= 1000;\\n        int ans=0;\\n        for(int i=s.size()-1; i>=0; i--){\\n            if(i!=0 && um[s[i-1]]<um[s[i]] ){\\n                 ans= ans+  um[s[i]]-um[s[i-1]]; \\n                i--;\\n                continue;\\n            }\\n            ans=ans+ um[s[i]];\\n        }\\n        return ans;\\n    }\\n};\\n    \\n```\n```\\npublic int romanToInt(String s) {\\n        Map<Character, Integer> alphabet = initAlphabet();\\n        int result = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (alphabet.get(s.charAt(i)) < alphabet.get(s.charAt(i + 1)))\\n                result = result - alphabet.get(s.charAt(i));\\n            else \\n                result = result + alphabet.get(s.charAt(i));\\n        }\\n        return result + alphabet.get(s.charAt(s.length() - 1));\\n    }\\n\\n    private Map<Character, Integer> initAlphabet() {\\n        return Map.of(\\'I\\', 1, \\'V\\', 5, \\'X\\', 10, \\'L\\', 50, \\'C\\', 100, \\'D\\', 500, \\'M\\', 1000);\\n    }\\n```\n```\\nclass Solution:\\n\\t\\n\\n\\tROMAN_TO_INTEGER = {\\n\\t\\t\\'I\\':  1,\\n\\t\\t\\'IV\\': 4,\\n\\t\\t\\'V\\':  5,\\n\\t\\t\\'IX\\': 9,\\n\\t\\t\\'X\\':  10,\\n\\t\\t\\'XL\\': 40,\\n\\t\\t\\'L\\':  50,\\n\\t\\t\\'XC\\': 90,\\n\\t\\t\\'C\\':  100,\\n\\t\\t\\'CD\\': 400,\\n\\t\\t\\'D\\':  500,\\n\\t\\t\\'CM\\': 900,\\n\\t\\t\\'M\\':  1000,\\n\\t}\\n\\n\\tdef romanToInt(self, s: str) -> int:\\n\\t\\tconverted = 0\\n\\n\\t\\tfor roman, integer in self.ROMAN_TO_INTEGER.items():\\n\\t\\t\\twhile s.endswith(roman):\\n\\t\\t\\t\\ts = s.removesuffix(roman)\\n\\t\\t\\t\\tconverted += integer\\n\\n\\t\\treturn converted\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396026,
                "title": "java-switch-case",
                "content": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int res=0;\\n        int a=getVal(s.charAt(0));\\n        for(int i=1; i<s.length();i++){\\n            int b=getVal(s.charAt(i));\\n            if(a<b){\\n               res=res-a;\\n            }\\n            else{\\n                res=res+a;\\n            }\\n            a=b;\\n        }\\n         res += a;\\n         return res;\\n    }\\n    private int getVal(char c){\\n        switch(c){\\n            case \\'I\\':\\n                return 1;\\n             case \\'V\\':\\n                return 5;\\n             case \\'X\\':\\n                return 10;\\n             case \\'L\\':\\n                return 50;\\n             case \\'C\\':\\n                return 100;\\n             case \\'D\\':\\n                return 500;\\n             case \\'M\\':\\n                return 1000;\\n            default:\\n                return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int res=0;\\n        int a=getVal(s.charAt(0));\\n        for(int i=1; i<s.length();i++){\\n            int b=getVal(s.charAt(i));\\n            if(a<b){\\n               res=res-a;\\n            }\\n            else{\\n                res=res+a;\\n            }\\n            a=b;\\n        }\\n         res += a;\\n         return res;\\n    }\\n    private int getVal(char c){\\n        switch(c){\\n            case \\'I\\':\\n                return 1;\\n             case \\'V\\':\\n                return 5;\\n             case \\'X\\':\\n                return 10;\\n             case \\'L\\':\\n                return 50;\\n             case \\'C\\':\\n                return 100;\\n             case \\'D\\':\\n                return 500;\\n             case \\'M\\':\\n                return 1000;\\n            default:\\n                return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492831,
                "title": "javascript-140ms-using-regex",
                "content": "```\\nconst m = {\\n    I: 1,\\n    V: 5,\\n    X: 10,\\n    L: 50,\\n    C: 100,\\n    D: 500,\\n    M: 1000,\\n    IV: 4,\\n    IX: 9,\\n    XL: 40,\\n    XC: 90,\\n    CD: 400,\\n    CM: 900\\n}\\n\\nvar romanToInt = s => s.split(/(IV|IX|XL|XC|CD|CM|I|V|X|L|C|D|M)/)\\n\\t.filter(Boolean)\\n\\t.map(x => m[x])\\n\\t.reduce((a, b) => a + b, 0)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst m = {\\n    I: 1,\\n    V: 5,\\n    X: 10,\\n    L: 50,\\n    C: 100,\\n    D: 500,\\n    M: 1000,\\n    IV: 4,\\n    IX: 9,\\n    XL: 40,\\n    XC: 90,\\n    CD: 400,\\n    CM: 900\\n}\\n\\nvar romanToInt = s => s.split(/(IV|IX|XL|XC|CD|CM|I|V|X|L|C|D|M)/)\\n\\t.filter(Boolean)\\n\\t.map(x => m[x])\\n\\t.reduce((a, b) => a + b, 0)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 423299,
                "title": "ruby-solution-52ms",
                "content": "Ruby solution with\\n\\t- Runtime: 52 ms\\n\\t- Memory Usage: 9.3 MB\\n```\\ndef roman_to_int(s)\\n  hash = {\\n    \\'I\\'=> 1,\\n    \\'V\\'=> 5,\\n    \\'X\\'=> 10,\\n    \\'L\\'=> 50,\\n    \\'C\\'=> 100,\\n    \\'D\\'=> 500,\\n    \\'M\\'=> 1000\\n  }\\n\\n  total = 0\\n  i = 0\\n  while i < s.length\\n    if i + 1 < s.length && hash[s[i]] < hash[s[i+1]]\\n      total += hash[s[i+1]] - hash[s[i]]\\n      i += 1\\n    else\\n      total += hash[s[i]]\\n    end\\n\\n    i += 1\\n  end\\n\\n  total\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef roman_to_int(s)\\n  hash = {\\n    \\'I\\'=> 1,\\n    \\'V\\'=> 5,\\n    \\'X\\'=> 10,\\n    \\'L\\'=> 50,\\n    \\'C\\'=> 100,\\n    \\'D\\'=> 500,\\n    \\'M\\'=> 1000\\n  }\\n\\n  total = 0\\n  i = 0\\n  while i < s.length\\n    if i + 1 < s.length && hash[s[i]] < hash[s[i+1]]\\n      total += hash[s[i+1]] - hash[s[i]]\\n      i += 1\\n    else\\n      total += hash[s[i]]\\n    end\\n\\n    i += 1\\n  end\\n\\n  total\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 6515,
                "title": "my-straightforward-java-solution-using-hashmap",
                "content": "I am quite strange to Roman numeric, I came up with this solution after I referred to Wikipedia. This solution is quite straightforward. Run-time: 452 ms\\n\\n    public int romanToInt(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        map.put('I', 1);\\n        map.put('V', 5);\\n        map.put('X', 10);\\n        map.put('L', 50);\\n        map.put('C', 100);\\n        map.put('D', 500);\\n        map.put('M', 1000);\\n        int len = s.length();\\n        int index = 0, result = 0;\\n        while (index < len) {\\n            Character chCur = s.charAt(index);\\n            Character chNext = null;\\n            if (index + 1 < len)\\n                chNext = s.charAt(index + 1);\\n            if(chNext != null && map.get(chCur) < map.get(chNext))\\n                result -= map.get(chCur);\\n            else\\n                result += map.get(chCur);\\n            index++;\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I am quite strange to Roman numeric, I came up with this solution after I referred to Wikipedia. This solution is quite straightforward. Run-time: 452 ms\\n\\n    public int romanToInt(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        map.put('I', 1);\\n        map.put('V', 5);\\n        map.put('X', 10);\\n        map.put('L', 50);\\n        map.put('C', 100);\\n        map.put('D', 500);\\n        map.put('M', 1000);\\n        int len = s.length();\\n        int index = 0, result = 0;\\n        while (index < len) {\\n            Character chCur = s.charAt(index);\\n            Character chNext = null;\\n            if (index + 1 < len)\\n                chNext = s.charAt(index + 1);\\n            if(chNext != null && map.get(chCur) < map.get(chNext))\\n                result -= map.get(chCur);\\n            else\\n                result += map.get(chCur);\\n            index++;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3791145,
                "title": "using-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n\\n        int n = s.length();\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            if(i < n-1 && map.get(s.charAt(i)) < map.get(s.charAt(i+1))){\\n                ans = ans - map.get(s.charAt(i));\\n            } else{\\n                ans = ans + map.get(s.charAt(i));\\n            }\\n\\n        }\\n        System.out.println(map); //Checking the output\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/539bc15d-1677-4947-b269-fe68849adc78_1689777081.6770382.jpeg)",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n\\n        int n = s.length();\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            if(i < n-1 && map.get(s.charAt(i)) < map.get(s.charAt(i+1))){\\n                ans = ans - map.get(s.charAt(i));\\n            } else{\\n                ans = ans + map.get(s.charAt(i));\\n            }\\n\\n        }\\n        System.out.println(map); //Checking the output\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523099,
                "title": "c-shortest-code-best-explanation-uzbek",
                "content": "#### 1-usul\\nBu usul eng qisqa kodni beradi. Loop orqali oxirigi xonadan bir xona oldingacha hamma rim raqamlarini tekshiramiz `for(int i = 0; i < s.Length - 1; i++)`:\\n- agar joriy rim raqamining qiymati keyingi rim raqamining qiymatidan kichik bo\\'lsa, unda natijadan joriy rim raqami qiymatini ayiramiz. Masalan $XIX$ raqamida joriy raqam $I$ bo\\'lsa, uning qiymati keyingi raqam qiymatidan kam, shuning natijadan 1ni ayiramiz. `if(romanDigits[s[i]] < romanDigits[s[i + 1]])  result -= romanDigits[s[i]];`\\n- agar yuqoridagi to\\'g\\'ri bo\\'lmasa natijaga joriy rim raqami qiymatini qo\\'shamiz `else result += romanDigits[s[i]];`.\\n\\nYuqoridagi $XIX$ misolni olsak:\\n1. Natijaga $X$ qiymati qo\\'shiladi. Natija = 10.\\n2. $I$ ning qiymati $X$dan kichkina bo\\'lgani uchun natijadan $I$ qiymati ayriladi. Natija  = 9. \\n3. Natijaga $X$ qiymati qo\\'shiladi. Natija = 19.\\n\\nVa nihoyat, loop oxirigi raqamgacha tekshirmagani uchun, oxirigi rim raqam qiymatini natijaga qo\\'shishni unutmaymiz.\\n\\n### Code\\n```cs\\npublic class Solution \\n{\\n        \\n    static Dictionary<char, int> romanDigits = new()\\n    {\\n        { \\'I\\', 1 },\\n        { \\'V\\', 5 },\\n        { \\'X\\', 10 },\\n        { \\'L\\', 50 },\\n        { \\'C\\', 100 },\\n        { \\'D\\', 500 },\\n        { \\'M\\', 1000 }\\n    };\\n    \\n    public int RomanToInt(string s)\\n    {\\n        var result = 0;\\n\\n        for(int i = 0; i < s.Length - 1; i++)\\n        {\\n            if(romanDigits[s[i]] < romanDigits[s[i + 1]])\\n                result -= romanDigits[s[i]];\\n            else\\n                result += romanDigits[s[i]];\\n        }\\n\\n        return result + romanDigits[s[s.Length - 1]];\\n    }\\n}\\n```\\n\\n---\\n\\n#### 2-usul\\nAlgoritm juda oddiy, rim raqamarli tugaguncha har bir raqamni tekshiramiz. Quyadiga 4 xil holat bor:\\n- agar joriy = $I$ va keyingisi $V$ yoki $X$ bo\\'lsa, keyingi raqam qiymatidan 1ni ayrib natijaga qo\\'ashamiz\\n- agar joriy = $X$ va keyingisi $L$ yoki $C$ bo\\'lsa, keyingi raqam qiymatidan 10ni ayrib natijaga qo\\'shamiz\\n- agar joriy = $C$ va keyingisi $D$ yoki $M$ bo\\'lsa, keyingi raqam qiymatidan 100ni ayrib natijaga qo\\'shamiz\\n\\nAgar yuqoridagilardan birontasi to\\'g\\'ri bo\\'lsa, pointerni bitta oldinga surib qo\\'yishimiz kerak. Sababi biz 2 ta rim raqamini bittada hisoblab ketdik va endi bitta sakrab ketishimiz kerak.\\n\\n- agar yuqoridagi shartlarni birontasi ham to\\'g\\'ri bo\\'lmasa, natijaga shunchaki joriy rim raqami qiymatini qo\\'shib davom etamiz. \\n\\n> Doim joriy rim raqamini keyingi o\\'rindagi rim raqamiga solishtirganimiz uchun, loop raqamlar oxiridan bitta oldingi elementgacha boradi holos. Agar oxirigacha borsa, keyingi rim raqamini tekshirishda arraydan tashqariga chiqib ketib qoladi `i < s.Length - 1;`\\n\\nLoop oxirgi elementgacha tekshirib bormagani uchun loop tugagandan so\\'ng oxirgi elementni qiymatini natijaga qo\\'shib qo\\'yishimiz kerak. Lekin agar loop tugashidan avval eng tepadagi 3 ta shartdan biri to\\'g\\'ri bo\\'lib, biz 2 ta rim raqamini bitta hisoblab ketgan bo\\'lsak, unda oxirigi raqamni qiymatini qo\\'shmaymiz. Sababi u loop ichida qo\\'shib ketilgan `i < s.Length ? result + romanDigits[s[s.Length - 1]] : result;`.\\n\\n### Code\\n```cs\\npublic class Solution {\\n        \\n    static Dictionary<char, int> romanDigits = new()\\n    {\\n        { \\'I\\', 1 },\\n        { \\'V\\', 5 },\\n        { \\'X\\', 10 },\\n        { \\'L\\', 50 },\\n        { \\'C\\', 100 },\\n        { \\'D\\', 500 },\\n        { \\'M\\', 1000 }\\n    };\\n    \\n    public int RomanToInt(string s)\\n    {\\n        int i, result = 0;\\n\\n        for(i = 0; i < s.Length - 1; i++)\\n        {\\n            if(s[i] == \\'I\\' && (s[i + 1] == \\'V\\' || s[i + 1] == \\'X\\'))\\n            {\\n                result += romanDigits[s[i + 1]] - romanDigits[s[i]];\\n                i++;\\n            }\\n            else if(s[i] == \\'X\\' && (s[i + 1] == \\'L\\' || s[i + 1] == \\'C\\'))\\n            {\\n                result += romanDigits[s[i + 1]] - romanDigits[s[i]];\\n                i++;\\n            }\\n            else if(s[i] == \\'C\\' && (s[i + 1] == \\'D\\' || s[i + 1] == \\'M\\'))\\n            {\\n                result += romanDigits[s[i + 1]] - romanDigits[s[i]];\\n                i++;\\n            }\\n            else\\n                result += romanDigits[s[i]];\\n        }\\n\\n        return i < s.Length ? result + romanDigits[s[s.Length - 1]] : result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```cs\\npublic class Solution \\n{\\n        \\n    static Dictionary<char, int> romanDigits = new()\\n    {\\n        { \\'I\\', 1 },\\n        { \\'V\\', 5 },\\n        { \\'X\\', 10 },\\n        { \\'L\\', 50 },\\n        { \\'C\\', 100 },\\n        { \\'D\\', 500 },\\n        { \\'M\\', 1000 }\\n    };\\n    \\n    public int RomanToInt(string s)\\n    {\\n        var result = 0;\\n\\n        for(int i = 0; i < s.Length - 1; i++)\\n        {\\n            if(romanDigits[s[i]] < romanDigits[s[i + 1]])\\n                result -= romanDigits[s[i]];\\n            else\\n                result += romanDigits[s[i]];\\n        }\\n\\n        return result + romanDigits[s[s.Length - 1]];\\n    }\\n}\\n```\n```cs\\npublic class Solution {\\n        \\n    static Dictionary<char, int> romanDigits = new()\\n    {\\n        { \\'I\\', 1 },\\n        { \\'V\\', 5 },\\n        { \\'X\\', 10 },\\n        { \\'L\\', 50 },\\n        { \\'C\\', 100 },\\n        { \\'D\\', 500 },\\n        { \\'M\\', 1000 }\\n    };\\n    \\n    public int RomanToInt(string s)\\n    {\\n        int i, result = 0;\\n\\n        for(i = 0; i < s.Length - 1; i++)\\n        {\\n            if(s[i] == \\'I\\' && (s[i + 1] == \\'V\\' || s[i + 1] == \\'X\\'))\\n            {\\n                result += romanDigits[s[i + 1]] - romanDigits[s[i]];\\n                i++;\\n            }\\n            else if(s[i] == \\'X\\' && (s[i + 1] == \\'L\\' || s[i + 1] == \\'C\\'))\\n            {\\n                result += romanDigits[s[i + 1]] - romanDigits[s[i]];\\n                i++;\\n            }\\n            else if(s[i] == \\'C\\' && (s[i + 1] == \\'D\\' || s[i + 1] == \\'M\\'))\\n            {\\n                result += romanDigits[s[i + 1]] - romanDigits[s[i]];\\n                i++;\\n            }\\n            else\\n                result += romanDigits[s[i]];\\n        }\\n\\n        return i < s.Length ? result + romanDigits[s[s.Length - 1]] : result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321648,
                "title": "typescript-map-letters-reduce-calc",
                "content": "# Code\\n```\\nconst romans = {\\n    I: 1,\\n    V: 5,\\n    X: 10,\\n    L: 50,\\n    C: 100,\\n    D: 500,\\n    M: 1000\\n};\\n\\nfunction romanToInt(s: string): number {\\n    const numbers: number[] = s.split(\\'\\').map(v => romans[v]);\\n    return numbers.reduce((acc, num, index) => num < numbers[index + 1] ?? 0 ? acc - num : acc + num, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst romans = {\\n    I: 1,\\n    V: 5,\\n    X: 10,\\n    L: 50,\\n    C: 100,\\n    D: 500,\\n    M: 1000\\n};\\n\\nfunction romanToInt(s: string): number {\\n    const numbers: number[] = s.split(\\'\\').map(v => romans[v]);\\n    return numbers.reduce((acc, num, index) => num < numbers[index + 1] ?? 0 ? acc - num : acc + num, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2763222,
                "title": "c-most-easy-solution-only-if-elseif-else",
                "content": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int sum = 0;\\n        int size = s.size();\\n        \\n        \\n        for(int i=0; i<size; i++)\\n        {\\n            if(s[i] == \\'I\\')\\n            {\\n                sum +=1;\\n            }\\n            else if(s[i] == \\'V\\')\\n            {\\n                if(i>0 && s[i-1] == \\'I\\')\\n                {\\n                    sum = sum +5 -2;\\n                }\\n                else\\n                {\\n                    sum = sum+5;\\n                }\\n            }\\n            else if(s[i] == \\'X\\')\\n            {\\n                if(i>0 && s[i-1] == \\'I\\')\\n                {\\n                    sum = sum +10 -2;\\n                }\\n                else\\n                {\\n                    sum = sum+10;\\n                }\\n            }\\n            else if(s[i] == \\'L\\')\\n            {\\n                if(i>0 && s[i-1] == \\'X\\')\\n                {\\n                    sum = sum +50-20;\\n                }\\n                else\\n                {\\n                    sum = sum+50;\\n                }\\n            }\\n            else if(s[i] == \\'C\\')\\n            {\\n                if(i>0 && s[i-1] == \\'X\\')\\n                {\\n                    sum = sum +100-20;\\n                }\\n                else\\n                {\\n                    sum = sum+100;\\n                }\\n            }\\n            else if(s[i] == \\'D\\')\\n            {\\n                if(i>0 && s[i-1] == \\'C\\')\\n                {\\n                    sum = sum +500-200;\\n                }\\n                else\\n                {\\n                    sum = sum+500;\\n                }\\n            }\\n            else if(s[i] == \\'M\\')\\n            {\\n                if(i>0 && s[i-1] == \\'C\\')\\n                {\\n                    sum = sum +1000-200;\\n                }\\n                else\\n                {\\n                    sum = sum+1000;\\n                }\\n            }\\n            \\n        }\\n       \\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int sum = 0;\\n        int size = s.size();\\n        \\n        \\n        for(int i=0; i<size; i++)\\n        {\\n            if(s[i] == \\'I\\')\\n            {\\n                sum +=1;\\n            }\\n            else if(s[i] == \\'V\\')\\n            {\\n                if(i>0 && s[i-1] == \\'I\\')\\n                {\\n                    sum = sum +5 -2;\\n                }\\n                else\\n                {\\n                    sum = sum+5;\\n                }\\n            }\\n            else if(s[i] == \\'X\\')\\n            {\\n                if(i>0 && s[i-1] == \\'I\\')\\n                {\\n                    sum = sum +10 -2;\\n                }\\n                else\\n                {\\n                    sum = sum+10;\\n                }\\n            }\\n            else if(s[i] == \\'L\\')\\n            {\\n                if(i>0 && s[i-1] == \\'X\\')\\n                {\\n                    sum = sum +50-20;\\n                }\\n                else\\n                {\\n                    sum = sum+50;\\n                }\\n            }\\n            else if(s[i] == \\'C\\')\\n            {\\n                if(i>0 && s[i-1] == \\'X\\')\\n                {\\n                    sum = sum +100-20;\\n                }\\n                else\\n                {\\n                    sum = sum+100;\\n                }\\n            }\\n            else if(s[i] == \\'D\\')\\n            {\\n                if(i>0 && s[i-1] == \\'C\\')\\n                {\\n                    sum = sum +500-200;\\n                }\\n                else\\n                {\\n                    sum = sum+500;\\n                }\\n            }\\n            else if(s[i] == \\'M\\')\\n            {\\n                if(i>0 && s[i-1] == \\'C\\')\\n                {\\n                    sum = sum +1000-200;\\n                }\\n                else\\n                {\\n                    sum = sum+1000;\\n                }\\n            }\\n            \\n        }\\n       \\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327866,
                "title": "python-solution-without-extensive-if-else-logic",
                "content": "```\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        numerals = {\\'I\\' : 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        total = 0\\n        \\n        for index, numeral in enumerate(s):\\n            \\n            #Iterating over each character in the input string. I check if the character is the last character is the last in the string\\n            #if not I check if the next character is \"greater than\" the value of the current character. If it is I subtract the value of the\\n            #current character otherwise add it to the total.w\\n        \\n            if (index < len(s) - 1 and numerals[numeral] < numerals[s[index+1]]):\\n                total -= numerals[numeral]\\n            else: \\n                total += numerals[numeral]\\n                \\n        return total\\n\\t\\t",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def romanToInt(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        numerals = {\\'I\\' : 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}",
                "codeTag": "Java"
            },
            {
                "id": 2257561,
                "title": "faster-than-99-76",
                "content": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        hashmap = {\\n            \"I\"  :   1,\\n            \"V\"  :   5,\\n            \"X\"  :   10,\\n            \"L\"  :   50,\\n            \"C\"  :   100,\\n            \"D\"  :   500,\\n            \"M\"  :   1000,\\n        }\\n        \\n        ans = 0\\n        for i in range(1,len(s)):\\n            if hashmap[s[i]] > hashmap[s[i-1]]:\\n                ans -= hashmap[s[i-1]]\\n            else:\\n                ans += hashmap[s[i-1]]\\n        ans += hashmap[s[-1]]\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        hashmap = {\\n            \"I\"  :   1,\\n            \"V\"  :   5,\\n            \"X\"  :   10,\\n            \"L\"  :   50,\\n            \"C\"  :   100,\\n            \"D\"  :   500,\\n            \"M\"  :   1000,\\n        }\\n        \\n        ans = 0\\n        for i in range(1,len(s)):\\n            if hashmap[s[i]] > hashmap[s[i-1]]:\\n                ans -= hashmap[s[i-1]]\\n            else:\\n                ans += hashmap[s[i-1]]\\n        ans += hashmap[s[-1]]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205315,
                "title": "rust-one-liner-with-comments",
                "content": "EDIT 2022-08-15: Celebrating that this is the problem of the day by doing a more elegant and fully functional solution. As hinted below in the original solution, I use a state machine approach to avoid complicating things with having to look at pairs. My definition of a one-liner is that are no semicolons ending expressions in the solution. So I regard this as a one-liner, which always is its own reward. :)\\n\\n**Functional \"One-Liner\"**\\n\\n```\\nimpl Solution {\\n    pub fn roman_to_int(s: String) -> i32 {\\n        s.as_bytes().iter().fold([0; 4], |[m, c, x, i], b| {\\n            match *b {\\n                b\\'M\\' => [m + 1000 - c, 0, x, i],\\n                b\\'D\\' => [m + 500 - c, 0, x, i],\\n                b\\'C\\' => [m, c + 100 - x, 0, i],\\n                b\\'L\\' => [m, c + 50 - x, 0, i],\\n                b\\'X\\' => [m, c, x + 10 - i, 0],\\n                b\\'V\\' => [m, c, x + 5 - i, 0],\\n                _ => [m, c, x, i + 1],\\n            }\\n        }).into_iter().sum::<i32>()\\n    }\\n}\\n```\\n\\n**Original Solution**\\n\\nQuite happy to note that I made a solution that is efficient, yet a bit different from the other ones posted. Instead of looking at pairs of characters in one way or another, I treat the accumulated \"lower\" digits as negative when I encounter a \"higher\" digit.\\n\\n```\\nimpl Solution {\\n    pub fn roman_to_int(s: String) -> i32 {\\n        let (mut m, mut c, mut x, mut i) = (0, 0, 0, 0);\\n        for b in s.as_bytes() {\\n            match b {\\n                b\\'M\\' => { m += 1000 - c; c = 0; },\\n                b\\'D\\' => { m += 500 - c; c = 0; },\\n                b\\'C\\' => { c += 100 - x; x = 0; },\\n                b\\'L\\' => { c += 50 - x; x = 0; }\\n                b\\'X\\' => { x += 10 - i; i = 0; }\\n                b\\'V\\' => { x += 5 - i; i = 0; }\\n                _ => i += 1,\\n            }\\n        }\\n        m + c + x + i\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn roman_to_int(s: String) -> i32 {\\n        s.as_bytes().iter().fold([0; 4], |[m, c, x, i], b| {\\n            match *b {\\n                b\\'M\\' => [m + 1000 - c, 0, x, i],\\n                b\\'D\\' => [m + 500 - c, 0, x, i],\\n                b\\'C\\' => [m, c + 100 - x, 0, i],\\n                b\\'L\\' => [m, c + 50 - x, 0, i],\\n                b\\'X\\' => [m, c, x + 10 - i, 0],\\n                b\\'V\\' => [m, c, x + 5 - i, 0],\\n                _ => [m, c, x, i + 1],\\n            }\\n        }).into_iter().sum::<i32>()\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn roman_to_int(s: String) -> i32 {\\n        let (mut m, mut c, mut x, mut i) = (0, 0, 0, 0);\\n        for b in s.as_bytes() {\\n            match b {\\n                b\\'M\\' => { m += 1000 - c; c = 0; },\\n                b\\'D\\' => { m += 500 - c; c = 0; },\\n                b\\'C\\' => { c += 100 - x; x = 0; },\\n                b\\'L\\' => { c += 50 - x; x = 0; }\\n                b\\'X\\' => { x += 10 - i; i = 0; }\\n                b\\'V\\' => { x += 5 - i; i = 0; }\\n                _ => i += 1,\\n            }\\n        }\\n        m + c + x + i\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061551,
                "title": "c-solution-to-roman-to-integer",
                "content": "Runtime: 79 ms, faster than 79.66% of C# online submissions for Roman to Integer.\\nMemory Usage: 47.9 MB, less than 11.26% of C# online submissions for Roman to Integer.\\n\\nHere\\'s the code:\\n```\\npublic class Solution {\\n    public int RomanToInt(string s) {\\n        var dictionary = new Dictionary<char, int>();\\n        dictionary.Add(\\'I\\', 1);\\n        dictionary.Add(\\'V\\', 5);\\n        dictionary.Add(\\'X\\', 10);\\n        dictionary.Add(\\'L\\', 50);\\n        dictionary.Add(\\'C\\', 100);\\n        dictionary.Add(\\'D\\', 500);\\n        dictionary.Add(\\'M\\', 1000);\\n        \\n        int solution = 0;\\n        \\n        /*\\n            They practically solved it, all we had to do was to read the question:\\n                I can be placed before V (5) and X (10) to make 4 and 9. \\n                X can be placed before L (50) and C (100) to make 40 and 90. \\n                C can be placed before D (500) and M (1000) to make 400 and 900.\\n        */\\n        s = s.Replace(\"IV\",\"IIII\")\\n            .Replace(\"IX\", \"VIIII\")\\n            .Replace(\"XL\", \"XXXX\")\\n            .Replace(\"XC\", \"LXXXX\")\\n            .Replace(\"CD\", \"CCCC\")\\n            .Replace(\"CM\", \"DCCCC\");\\n        \\n        foreach(char c in s){\\n            solution += dictionary[c];\\n        }\\n        \\n        return solution;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic class Solution {\\n    public int RomanToInt(string s) {\\n        var dictionary = new Dictionary<char, int>();\\n        dictionary.Add(\\'I\\', 1);\\n        dictionary.Add(\\'V\\', 5);\\n        dictionary.Add(\\'X\\', 10);\\n        dictionary.Add(\\'L\\', 50);\\n        dictionary.Add(\\'C\\', 100);\\n        dictionary.Add(\\'D\\', 500);\\n        dictionary.Add(\\'M\\', 1000);\\n        \\n        int solution = 0;\\n        \\n        /*\\n            They practically solved it, all we had to do was to read the question:\\n                I can be placed before V (5) and X (10) to make 4 and 9. \\n                X can be placed before L (50) and C (100) to make 40 and 90. \\n                C can be placed before D (500) and M (1000) to make 400 and 900.\\n        */\\n        s = s.Replace(\"IV\",\"IIII\")\\n            .Replace(\"IX\", \"VIIII\")\\n            .Replace(\"XL\", \"XXXX\")\\n            .Replace(\"XC\", \"LXXXX\")\\n            .Replace(\"CD\", \"CCCC\")\\n            .Replace(\"CM\", \"DCCCC\");\\n        \\n        foreach(char c in s){\\n            solution += dictionary[c];\\n        }\\n        \\n        return solution;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888710,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nconst multipliers: { [key: string]: number } = {\\n  IV: 4,\\n  IX: 9,\\n  XL: 40,\\n  XC: 90,\\n  CD: 400,\\n  CM: 900,\\n  I: 1,\\n  V: 5,\\n  X: 10,\\n  L: 50,\\n  C: 100,\\n  D: 500,\\n  M: 1000,\\n}\\n\\nconst tokens = Object.keys(multipliers)\\n\\nfunction romanToInt(s: string): number {\\n\\tfunction next(): string {\\n\\t\\tfor (const token of tokens) {\\n\\t\\t\\tif (s.startsWith(token)) {\\n\\t\\t\\t\\ts = s.substr(token.length)\\n\\t\\t\\t\\treturn token\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthrow new Error(`Unknown token: $(s)`)\\n\\t}\\n\\n\\tconst chars: string[] = []\\n\\n\\twhile (s.length > 0) { chars.push(next()) }\\n\\n\\treturn chars.reduce((sum, char) => {\\n\\t\\treturn sum += multipliers[char]\\n\\t}, 0)\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst multipliers: { [key: string]: number } = {\\n  IV: 4,\\n  IX: 9,\\n  XL: 40,\\n  XC: 90,\\n  CD: 400,\\n  CM: 900,\\n  I: 1,\\n  V: 5,\\n  X: 10,\\n  L: 50,\\n  C: 100,\\n  D: 500,\\n  M: 1000,\\n}\\n\\nconst tokens = Object.keys(multipliers)\\n\\nfunction romanToInt(s: string): number {\\n\\tfunction next(): string {\\n\\t\\tfor (const token of tokens) {\\n\\t\\t\\tif (s.startsWith(token)) {\\n\\t\\t\\t\\ts = s.substr(token.length)\\n\\t\\t\\t\\treturn token\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthrow new Error(`Unknown token: $(s)`)\\n\\t}\\n\\n\\tconst chars: string[] = []\\n\\n\\twhile (s.length > 0) { chars.push(next()) }\\n\\n\\treturn chars.reduce((sum, char) => {\\n\\t\\treturn sum += multipliers[char]\\n\\t}, 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1298123,
                "title": "python3-super-fast-than-99",
                "content": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        letters = list(s)\\n        romans = {\\'I\\':1, \\'V\\':5, \\'X\\':10, \\'L\\':50, \\'C\\':100, \\'D\\':500, \\'M\\':1000}\\n        sum_let = 0\\n        prev = None\\n        for lets in letters:\\n            if prev is not None and romans[prev] <  romans[lets]:\\n                sum_let+=(romans[lets]-(romans[prev]*2))\\n            else:\\n                sum_let+=romans[lets]\\n            prev = lets\\n        return sum_let\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        letters = list(s)\\n        romans = {\\'I\\':1, \\'V\\':5, \\'X\\':10, \\'L\\':50, \\'C\\':100, \\'D\\':500, \\'M\\':1000}\\n        sum_let = 0\\n        prev = None\\n        for lets in letters:\\n            if prev is not None and romans[prev] <  romans[lets]:\\n                sum_let+=(romans[lets]-(romans[prev]*2))\\n            else:\\n                sum_let+=romans[lets]\\n            prev = lets\\n        return sum_let\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080759,
                "title": "swift-easy-to-understand-solution-with-switch",
                "content": "```\\nclass Solution {\\n    func romanToInt(_ s: String) -> Int {\\n        \\n        var answer = 0\\n\\n        s.forEach{\\n            switch $0 {\\n                case \"I\":\\n                    answer += 1\\n                case \"V\":\\n                    answer += 5\\n                case \"X\":\\n                    answer += 10\\n                case \"L\":\\n                    answer += 50\\n                case \"C\":\\n                    answer += 100\\n                case \"D\":\\n                    answer += 500\\n                case \"M\":\\n                    answer += 1000\\n                default: break\\n            }\\n        }\\n\\n        if s.contains(\"IV\") { answer -= 2 }\\n        if s.contains(\"IX\") { answer -= 2 }\\n        if s.contains(\"XL\") { answer -= 20 }\\n        if s.contains(\"XC\") { answer -= 20 }\\n        if s.contains(\"CD\") { answer -= 200 }\\n        if s.contains(\"CM\") { answer -= 200 }\\n\\n        return answer\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func romanToInt(_ s: String) -> Int {\\n        \\n        var answer = 0\\n\\n        s.forEach{\\n            switch $0 {\\n                case \"I\":\\n                    answer += 1\\n                case \"V\":\\n                    answer += 5\\n                case \"X\":\\n                    answer += 10\\n                case \"L\":\\n                    answer += 50\\n                case \"C\":\\n                    answer += 100\\n                case \"D\":\\n                    answer += 500\\n                case \"M\":\\n                    answer += 1000\\n                default: break\\n            }\\n        }\\n\\n        if s.contains(\"IV\") { answer -= 2 }\\n        if s.contains(\"IX\") { answer -= 2 }\\n        if s.contains(\"XL\") { answer -= 20 }\\n        if s.contains(\"XC\") { answer -= 20 }\\n        if s.contains(\"CD\") { answer -= 200 }\\n        if s.contains(\"CM\") { answer -= 200 }\\n\\n        return answer\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074139,
                "title": "python-short-solution-explained",
                "content": "Let us calculate number in two steps:\\n\\n1. We know that `I` equal to `1`, `V` equal to `5` and so on, so let us just iterate over string and add value to final answer.\\n2. There is something we need to fix now, for example if we have `IX`, it is equal to `9`, but we added `11`, so we need to subtract `2`. Similar for `IV`, `XL, XC, CD, CM`.\\n\\n**Complexity**: time and space complexity is just `O(1)`, because string length is always no more than `10`. Imagine now, that we can have `k` different symbols for powers of `10` and `5` multiplied by power of `10`. Then first pass wil be `O(k)` and the second is also `O(k)`: we check all `O(k)` pairs of adjacent elements and check if they are in `fix` dictionary, so final time and space complexity in general case will be `O(k)`.\\n\\n```\\nclass Solution:\\n    def romanToInt(self, s):\\n        dic = {\"I\":1, \"V\":5, \"X\":10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        fix = {\"IX\": 2, \"IV\": 2, \"XL\": 20, \"XC\": 20, \"CD\": 200, \"CM\": 200}\\n        ans = 0\\n        for elem in s: ans += dic[elem]\\n        for i, j in zip(s, s[1:]):\\n            if i + j in fix: ans -= fix[i + j]\\n        return ans  \\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s):\\n        dic = {\"I\":1, \"V\":5, \"X\":10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        fix = {\"IX\": 2, \"IV\": 2, \"XL\": 20, \"XC\": 20, \"CD\": 200, \"CM\": 200}\\n        ans = 0\\n        for elem in s: ans += dic[elem]\\n        for i, j in zip(s, s[1:]):\\n            if i + j in fix: ans -= fix[i + j]\\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074100,
                "title": "c-simple-pattern-o-n-0ms-beats-100-explanation",
                "content": "**EXPLANATION**\\nBefore understanding the code, you should know about few things.\\n- **string.find(\"something\")** : returns the *index of first occurence* of sub-string \"something\" if found, else returns **`string::npos`**, that is **-1**.\\n- **string::npos** : is a *constant static member* value with the highest possible value for an element of type *size_t*, here *size_t* is an unsigned integral type, and -1 is the largest possible representable value for this type. So, `string::npos` returns -1 (here).\\n\\n\\nNow, just **do as the question** says, along with few **special cases** as shown below:\\n- **4 = -2 + 1 + 5** implies **IV = -2 + I + V**\\n- **9 = -2 + 1 + 10** implies **IX = -2 + I + X**\\n- **40 = -20 + 10 + 50** implies **XL = -20 + X + L**\\n- **90 = -20 + 10 + 100**  implies **XC = -20 + X + C**\\n- **400 = -200 + 100 + 500**  implies **CD = -200 + C+ D**\\n- **900 = -200 + 100 +1000**  implies **CM = -200 + C+ M**\\nYou can clearly see the **pattern** above.\\n\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans=0;\\n        \\n        // handle few special cases\\n        if(s.find(\"IV\")!=string::npos) // 4 = -2 + 1 + 5\\n           ans-=2;\\n        if(s.find(\"IX\")!=string::npos) // 9 = -2 + 1 + 10\\n           ans-=2;\\n        if(s.find(\"XL\")!=string::npos) // 40 = -20 + 10 + 50\\n           ans-=20;\\n        if(s.find(\"XC\")!=string::npos) // 90 = -20 + 10 + 100\\n           ans-=20;\\n        if(s.find(\"CD\")!=string::npos) // 400 = -200 + 100 + 500\\n           ans-=200;\\n        if(s.find(\"CM\")!=string::npos) // 900 = -200 + 100 + 1000\\n           ans-=200;\\n\\n        // Do according to the question\\n        for(int count=0;count<s.length();++count){\\n            if(s[count]==\\'M\\') ans+=1000;\\n            if(s[count]==\\'D\\') ans+=500;\\n            if(s[count]==\\'C\\') ans+=100;\\n            if(s[count]==\\'L\\') ans+=50;\\n            if(s[count]==\\'X\\') ans+=10;\\n            if(s[count]==\\'V\\') ans+=5;\\n            if(s[count]==\\'I\\') ans+=1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Note** : In above,`s.find(\"something\") != string::npos` can be replaced with `s.find(\"something\") != -1` .\\n\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans=0;\\n        \\n        // handle few special cases\\n        if(s.find(\"IV\")!=string::npos) // 4 = -2 + 1 + 5\\n           ans-=2;\\n        if(s.find(\"IX\")!=string::npos) // 9 = -2 + 1 + 10\\n           ans-=2;\\n        if(s.find(\"XL\")!=string::npos) // 40 = -20 + 10 + 50\\n           ans-=20;\\n        if(s.find(\"XC\")!=string::npos) // 90 = -20 + 10 + 100\\n           ans-=20;\\n        if(s.find(\"CD\")!=string::npos) // 400 = -200 + 100 + 500\\n           ans-=200;\\n        if(s.find(\"CM\")!=string::npos) // 900 = -200 + 100 + 1000\\n           ans-=200;\\n\\n        // Do according to the question\\n        for(int count=0;count<s.length();++count){\\n            if(s[count]==\\'M\\') ans+=1000;\\n            if(s[count]==\\'D\\') ans+=500;\\n            if(s[count]==\\'C\\') ans+=100;\\n            if(s[count]==\\'L\\') ans+=50;\\n            if(s[count]==\\'X\\') ans+=10;\\n            if(s[count]==\\'V\\') ans+=5;\\n            if(s[count]==\\'I\\') ans+=1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346702,
                "title": "javascript-solution-runtime-98-24-faster-memory-usage-95-53-less",
                "content": "```\\nvar romanToInt = function(s) {\\n    var map = {\\n        \\'I\\': 1,\\n        \\'V\\': 5,\\n        \\'X\\': 10,\\n        \\'L\\': 50,\\n        \\'C\\': 100,\\n        \\'D\\': 500,\\n        \\'M\\': 1000\\n    }\\n    var number = 0;\\n    var index;\\n    if (s.indexOf(\\'CM\\')!= -1) number -= 200;\\n    if (s.indexOf(\\'CD\\')!= -1) number -= 200\\n    if (s.indexOf(\\'XC\\')!= -1) number -= 20;\\n    if (s.indexOf(\\'XL\\')!= -1) number -= 20;\\n    if (s.indexOf(\\'IX\\')!= -1) number -= 2;\\n    if (s.indexOf(\\'IV\\')!= -1) number -= 2;\\n    for (var i = 0; i < s.length; i++) {\\n        number += map[s[i]];\\n    }\\n    return number;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar romanToInt = function(s) {\\n    var map = {\\n        \\'I\\': 1,\\n        \\'V\\': 5,\\n        \\'X\\': 10,\\n        \\'L\\': 50,\\n        \\'C\\': 100,\\n        \\'D\\': 500,\\n        \\'M\\': 1000\\n    }\\n    var number = 0;\\n    var index;\\n    if (s.indexOf(\\'CM\\')!= -1) number -= 200;\\n    if (s.indexOf(\\'CD\\')!= -1) number -= 200\\n    if (s.indexOf(\\'XC\\')!= -1) number -= 20;\\n    if (s.indexOf(\\'XL\\')!= -1) number -= 20;\\n    if (s.indexOf(\\'IX\\')!= -1) number -= 2;\\n    if (s.indexOf(\\'IV\\')!= -1) number -= 2;\\n    for (var i = 0; i < s.length; i++) {\\n        number += map[s[i]];\\n    }\\n    return number;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6521,
                "title": "a-36ms-c-solution-no-hashmap-clean-to-understand",
                "content": "The key is to check if the `i-th` char is smaller than `(i+1)th`, If so, then it should be a negative.     \\nAdd them all is the result.\\n\\n    class Solution {\\n    public:\\n\\t    int romanToInt(string s) {\\n\\t\\t    int num[256] = { 0 };\\n\\t\\t    int result = 0;\\n\\t\\t    num['I'] = 1; num['V'] = 5; num['X'] = 10; num['L']=50;\\n\\t\\t    num['C'] = 100; num['D'] = 500; num['M'] = 1000;\\n\\t\\t    int i = 0;\\n\\t\\t    while (i < s.size()){\\n\\t\\t\\t    if (num[s[i]] < num[s[i+1]])\\n\\t\\t\\t\\t    result -= num[s[i]];\\n\\t\\t\\t    else\\n\\t\\t\\t\\t    result += num[s[i]];\\n\\t\\t\\t    i++;\\n\\t\\t    }\\n\\t\\t    return result;\\n\\t    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n\\t    int romanToInt(string s) {\\n\\t\\t    int num[256] = { 0 }",
                "codeTag": "Java"
            },
            {
                "id": 4032384,
                "title": "video-step-by-step-explanation-two-different-solutions",
                "content": "https://www.youtube.com/watch?v=tsmrUi5M1JU\\n\\n<b>Method 1:</b>\\nThis solution takes the approach incorporating the general logic of roman numerals into the algorithm.  We first create a dictionary that maps each roman numeral to the corresponding integer.  We also create a total variable set to 0.\\n\\nWe then loop over each numeral and check if the one <i>after</i> it is bigger or smaller.  If it\\'s bigger, we can just add it to our total.  If it\\'s smaller, that means we have to <i>subtract</i> it from our total instead.\\n\\nThe loop stops at the second to last numeral and returns the total + the last numeral (since the last numeral always has to be added)\\n\\n```\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        roman = {\\n            \"I\": 1,\\n            \"V\": 5,\\n            \"X\": 10,\\n            \"L\": 50,\\n            \"C\": 100,\\n            \"D\": 500,\\n            \"M\": 1000\\n        }\\n        total = 0\\n        for i in range(len(s) - 1):\\n            if roman[s[i]] < roman[s[i+1]]:\\n                total -= roman[s[i]]\\n            else:\\n                total += roman[s[i]]\\n        return total + roman[s[-1]]\\n```\\n\\n<b>Method 2:</b>\\nThis solution takes the approach of saying \"The logic of roman numerals is too complicated. Let\\'s make it easier by rewriting the numeral so that we only have to <i>add</i> and not worry about subtraction.\\n\\nIt starts off the same way by creating a dictionary and a total variable.  It then performs substring replacement for each of the 6 possible cases that subtraction can be used and replaces it with a version that can just be added together.  For example, IV is converted to IIII, so that all the digits can be added up to 4.  Then we just loop through the string and add up the total.\\n```\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        roman = {\\n            \"I\": 1,\\n            \"V\": 5,\\n            \"X\": 10,\\n            \"L\": 50,\\n            \"C\": 100,\\n            \"D\": 500,\\n            \"M\": 1000\\n        }\\n        total = 0\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\\n        s = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\\n        s = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n        for symbol in s:\\n            total += roman[symbol]\\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        roman = {\\n            \"I\": 1,\\n            \"V\": 5,\\n            \"X\": 10,\\n            \"L\": 50,\\n            \"C\": 100,\\n            \"D\": 500,\\n            \"M\": 1000\\n        }\\n        total = 0\\n        for i in range(len(s) - 1):\\n            if roman[s[i]] < roman[s[i+1]]:\\n                total -= roman[s[i]]\\n            else:\\n                total += roman[s[i]]\\n        return total + roman[s[-1]]\\n```\n```\\nclass Solution(object):\\n    def romanToInt(self, s):\\n        roman = {\\n            \"I\": 1,\\n            \"V\": 5,\\n            \"X\": 10,\\n            \"L\": 50,\\n            \"C\": 100,\\n            \"D\": 500,\\n            \"M\": 1000\\n        }\\n        total = 0\\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\\n        s = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\\n        s = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\\n        for symbol in s:\\n            total += roman[symbol]\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519838,
                "title": "c-converter-for-roman-numbers",
                "content": "# Converter for Roman numbers\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTranslating numbers from the end\\nRuntime Beats ~88.00% (93% - 79%).\\nMamory Beats ~ 99%\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int romanConverter(char c);\\n    int romanToInt(string s);\\n};\\n\\nint Solution::romanConverter(char c) {\\n    switch(c) {\\n        case \\'I\\': return 1;\\n        case \\'V\\': return 5;\\n        case \\'X\\': return 10;\\n        case \\'L\\': return 50;\\n        case \\'C\\': return 100;\\n        case \\'D\\': return 500;\\n        case \\'M\\': return 1000;\\n        default : return 0;\\n    }\\n}\\n\\nint Solution::romanToInt(string s) {\\n    int result = 0;\\n    short num_last = 0;\\n    short num_this = 0;\\n    for (int i = s.size() -1; i >= 0; i--) {\\n        num_this = romanConverter(s[i]);\\n        num_this < num_last?  result -= num_this: result += num_this;\\n        num_last = num_this;\\n    }\\n\\n    return result;\\n}\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanConverter(char c);\\n    int romanToInt(string s);\\n};\\n\\nint Solution::romanConverter(char c) {\\n    switch(c) {\\n        case \\'I\\': return 1;\\n        case \\'V\\': return 5;\\n        case \\'X\\': return 10;\\n        case \\'L\\': return 50;\\n        case \\'C\\': return 100;\\n        case \\'D\\': return 500;\\n        case \\'M\\': return 1000;\\n        default : return 0;\\n    }\\n}\\n\\nint Solution::romanToInt(string s) {\\n    int result = 0;\\n    short num_last = 0;\\n    short num_this = 0;\\n    for (int i = s.size() -1; i >= 0; i--) {\\n        num_this = romanConverter(s[i]);\\n        num_this < num_last?  result -= num_this: result += num_this;\\n        num_last = num_this;\\n    }\\n\\n    return result;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469199,
                "title": "c-using-for-loop-easy",
                "content": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n    int romanToInt(string s) {\\n        int ans=0;\\n        \\n        for(int i=0 ; i<s.length() ; i++){\\n            if(s[i] == \\'I\\'){\\n                ans = ans + 1;\\n            }\\n            if(s[i] == \\'V\\'){\\n                ans = ans + 5;\\n            }\\n            if(s[i] == \\'X\\'){\\n                ans = ans + 10;\\n            }\\n            if(s[i] == \\'L\\'){\\n                ans = ans + 50;\\n            }\\n            if(s[i] == \\'C\\'){\\n                ans = ans + 100;\\n            }\\n            if(s[i] == \\'D\\'){\\n                ans = ans + 500;\\n            }\\n            if(s[i] == \\'M\\'){\\n                ans = ans + 1000;\\n            }\\n            if(s[i] == \\'I\\' && s[i+1]==\\'V\\' || s[i] == \\'I\\' && s[i+1]==\\'X\\'){\\n                ans = ans - 2;\\n            }\\n            if(s[i] == \\'X\\' && s[i+1]==\\'L\\' || s[i] == \\'X\\' && s[i+1]==\\'C\\'){\\n                ans = ans - 20;\\n            }\\n            if(s[i] == \\'C\\' && s[i+1]==\\'D\\' || s[i] == \\'C\\' && s[i+1]==\\'M\\'){\\n                ans = ans - 200;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n\\t};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int romanToInt(string s) {\\n        int ans=0;\\n        \\n        for(int i=0 ; i<s.length() ; i++){\\n            if(s[i] == \\'I\\'){\\n                ans = ans + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2426848,
                "title": "java-easy-solution-using-hashmap",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        HashMap<String, Integer> m = new HashMap<String, Integer>();\\n        m.put(\"I\", 1);\\n        m.put(\"IV\", 4);\\n        m.put(\"V\", 5);\\n        m.put(\"IX\", 9);\\n        m.put(\"X\", 10);\\n        m.put(\"XL\", 40);\\n        m.put(\"L\", 50);\\n        m.put(\"XC\", 90);\\n        m.put(\"C\", 100);\\n        m.put(\"CD\", 400);\\n        m.put(\"D\", 500);\\n        m.put(\"CM\", 900);\\n        m.put(\"M\", 1000);\\n        int res = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            String a = \"\";\\n            String b = \"\";\\n            if(i < s.length()-1){\\n                a += Character.toString(s.charAt(i));\\n                a += Character.toString(s.charAt(i+1));\\n            }\\n            b += Character.toString(s.charAt(i));\\n            if(m.containsKey(a)){\\n                res += m.get(a);\\n                i++;\\n            }\\n            else{\\n                res += m.get(b);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        HashMap<String, Integer> m = new HashMap<String, Integer>();\\n        m.put(\"I\", 1);\\n        m.put(\"IV\", 4);\\n        m.put(\"V\", 5);\\n        m.put(\"IX\", 9);\\n        m.put(\"X\", 10);\\n        m.put(\"XL\", 40);\\n        m.put(\"L\", 50);\\n        m.put(\"XC\", 90);\\n        m.put(\"C\", 100);\\n        m.put(\"CD\", 400);\\n        m.put(\"D\", 500);\\n        m.put(\"CM\", 900);\\n        m.put(\"M\", 1000);\\n        int res = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            String a = \"\";\\n            String b = \"\";\\n            if(i < s.length()-1){\\n                a += Character.toString(s.charAt(i));\\n                a += Character.toString(s.charAt(i+1));\\n            }\\n            b += Character.toString(s.charAt(i));\\n            if(m.containsKey(a)){\\n                res += m.get(a);\\n                i++;\\n            }\\n            else{\\n                res += m.get(b);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157105,
                "title": "python-easy-fast",
                "content": "Easy Python Solution:\\n\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sum = 0\\n        sum = sum + s.count(\"IV\")*4 + s.count(\"IX\")*9 + s.count(\"XL\")*40 + s.count(\"XC\")*90 + s.count(\"CD\")*400 + s.count(\"CM\")*900\\n        s = s.replace(\"IV\", \"\").replace(\"IX\", \"\").replace(\"XL\", \"\").replace(\"XC\", \"\").replace(\"CD\", \"\").replace(\"CM\", \"\")\\n        sum = sum + s.count(\"I\")*1 + s.count(\"V\")*5 + s.count(\"X\")*10 + s.count(\"L\")*50 + s.count(\"C\")*100 + s.count(\"D\")*500 + s.count(\"M\")*1000\\n        return sum\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sum = 0\\n        sum = sum + s.count(\"IV\")*4 + s.count(\"IX\")*9 + s.count(\"XL\")*40 + s.count(\"XC\")*90 + s.count(\"CD\")*400 + s.count(\"CM\")*900\\n        s = s.replace(\"IV\", \"\").replace(\"IX\", \"\").replace(\"XL\", \"\").replace(\"XC\", \"\").replace(\"CD\", \"\").replace(\"CM\", \"\")\\n        sum = sum + s.count(\"I\")*1 + s.count(\"V\")*5 + s.count(\"X\")*10 + s.count(\"L\")*50 + s.count(\"C\")*100 + s.count(\"D\")*500 + s.count(\"M\")*1000\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071677,
                "title": "python-detailed-explanation-two-approaches-hash-table-two-pointers-beginners",
                "content": "***Approach - 1***:\\n* we create a dictionary with roman number values.\\n* we create two pointers a = 0 and b = a+1\\n* Now, we have 6 cases that needs to be subtracted from each other that  are IV(5-1=4), IX(10-1=9), XL(50-10=40), XC(100-10=90), CD(500-100=400), and CM(1000-100 = 900).\\n\\t* for there cases we simply subtract a from b and increments the a pointer by 2, since we checked two elements in the string. And b = a + 1\\n* Apart from these cases for every other case we simply adds the a value to the result and increments the a pointer by 1 and checks the next two elements whether it is present in the above 6 cases.\\n*  And there is one more edge case where a == last element in the string and b > len(string) in that case we simply add the last element\\'s value to the result.\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        result = 0\\n        dictu = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        n = len(s)\\n        a = 0\\n        b = a + 1\\n        while b <= n - 1:\\n            if s[a] == \\'X\\' and (s[b] == \\'L\\' or s[b] == \\'C\\'):\\n                result += dictu[s[b]] - dictu[s[a]]\\n                a += 2\\n            elif s[a] == \\'C\\' and (s[b] == \\'D\\' or s[b] == \\'M\\'):\\n                result += dictu[s[b]] - dictu[s[a]]\\n                a += 2\\n            elif s[a] == \\'I\\' and (s[b] == \\'V\\' or s[b] == \\'X\\'):\\n                result += dictu[s[b]] - dictu[s[a]]\\n                a += 2\\n            else:\\n                result += dictu[s[a]]\\n                a += 1\\n            b = a + 1\\n        if a == n - 1:\\n            result += dictu[s[n-1]]\\n        return result\\n```\\n\\n***Approach-2:***\\n* we simply create another dictionary with 6 cases\\n* we define two pointers \\n* we check whether the concatination of two pointers lie in the second dictionary\\n\\t* if yes we add that to the result and increments the a by 2 since we checked 2 elements \\n\\t* else  add s[a]\\'s value to the result and increment it by 1\\n* and as in the above case we write a condition for edge case to check whether we left out the last element.\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        result = 0\\n        dictu = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        dictu1 = {\\'IV\\': 4, \\'IX\\': 9, \\'XL\\': 40, \\'XC\\': 90, \\'CD\\': 400, \\'CM\\': 900}\\n        n = len(s)\\n        a = 0\\n        b = a + 1\\n        while b <= n - 1:\\n            x = s[a] + s[b]\\n            if x in dictu1:\\n                result += dictu1[x]\\n                a += 2\\n            else:\\n                result += dictu[s[a]]\\n                a += 1\\n            b = a + 1\\n        if a == n - 1:\\n            result += dictu[s[n-1]]\\n        return result\\n```\\n\\nKindly Upvote if it helps :)",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        result = 0\\n        dictu = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        n = len(s)\\n        a = 0\\n        b = a + 1\\n        while b <= n - 1:\\n            if s[a] == \\'X\\' and (s[b] == \\'L\\' or s[b] == \\'C\\'):\\n                result += dictu[s[b]] - dictu[s[a]]\\n                a += 2\\n            elif s[a] == \\'C\\' and (s[b] == \\'D\\' or s[b] == \\'M\\'):\\n                result += dictu[s[b]] - dictu[s[a]]\\n                a += 2\\n            elif s[a] == \\'I\\' and (s[b] == \\'V\\' or s[b] == \\'X\\'):\\n                result += dictu[s[b]] - dictu[s[a]]\\n                a += 2\\n            else:\\n                result += dictu[s[a]]\\n                a += 1\\n            b = a + 1\\n        if a == n - 1:\\n            result += dictu[s[n-1]]\\n        return result\\n```\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        result = 0\\n        dictu = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        dictu1 = {\\'IV\\': 4, \\'IX\\': 9, \\'XL\\': 40, \\'XC\\': 90, \\'CD\\': 400, \\'CM\\': 900}\\n        n = len(s)\\n        a = 0\\n        b = a + 1\\n        while b <= n - 1:\\n            x = s[a] + s[b]\\n            if x in dictu1:\\n                result += dictu1[x]\\n                a += 2\\n            else:\\n                result += dictu[s[a]]\\n                a += 1\\n            b = a + 1\\n        if a == n - 1:\\n            result += dictu[s[n-1]]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405205,
                "title": "99-73-java-clean-solution-w-explanation",
                "content": "\\tpublic int romanToInt(String s) {                                              \\n           //       First, we build an array that stores the integer value\\n           //   of each character in s. \\n           \\n           //       Second, we need to decide if we want to add, or subtract this\\n           //   value to get the final integer representation of \\'s\\'.\\n           \\n           //   Notice, only when the integer value of a character is less than\\n           //   than the integer value of the next character do we want to subtract it.\\n           \\n           //   In the end, only the last character has not been accounted for\\n           //   so we account for it and return.\\n           \\n           int n = s.length();\\n           int arr[] = new int[n];\\n           \\n           for (int i =0 ; i < n; i++){\\n               switch (s.charAt(i)){\\n                   case \\'I\\' :\\n                       arr[i] = 1;\\n                       break;\\n                   case \\'V\\' :\\n                       arr[i] = 5;\\n                       break;\\n                   case \\'X\\' :\\n                       arr[i] = 10;\\n                       break;\\n                   case \\'L\\' :\\n                       arr[i] = 50;\\n                       break;\\n                   case \\'C\\' :\\n                       arr[i] = 100;\\n                       break;\\n                   case \\'D\\' :\\n                       arr[i] = 500;\\n                       break;\\n                   case \\'M\\':\\n                       arr[i] = 1000;\\n                       break;\\n               }\\n           }\\n           \\n           int sol = 0;\\n           int i = 0;\\n           while ( i < n-1 ){\\n               if (arr[i] < arr[i+1]) sol -= arr[i];\\n               else sol += arr[i];\\n               i++;\\n           } \\n           \\n           return sol +arr[i];\\n           \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tpublic int romanToInt(String s) {                                              \\n           //       First, we build an array that stores the integer value\\n           //   of each character in s. \\n           \\n           //       Second, we need to decide if we want to add, or subtract this\\n           //   value to get the final integer representation of \\'s\\'.\\n           \\n           //   Notice, only when the integer value of a character is less than\\n           //   than the integer value of the next character do we want to subtract it.\\n           \\n           //   In the end, only the last character has not been accounted for\\n           //   so we account for it and return.\\n           \\n           int n = s.length();\\n           int arr[] = new int[n];\\n           \\n           for (int i =0 ; i < n; i++){\\n               switch (s.charAt(i)){\\n                   case \\'I\\' :\\n                       arr[i] = 1;\\n                       break;\\n                   case \\'V\\' :\\n                       arr[i] = 5;\\n                       break;\\n                   case \\'X\\' :\\n                       arr[i] = 10;\\n                       break;\\n                   case \\'L\\' :\\n                       arr[i] = 50;\\n                       break;\\n                   case \\'C\\' :\\n                       arr[i] = 100;\\n                       break;\\n                   case \\'D\\' :\\n                       arr[i] = 500;\\n                       break;\\n                   case \\'M\\':\\n                       arr[i] = 1000;\\n                       break;\\n               }\\n           }\\n           \\n           int sol = 0;\\n           int i = 0;\\n           while ( i < n-1 ){\\n               if (arr[i] < arr[i+1]) sol -= arr[i];\\n               else sol += arr[i];\\n               i++;\\n           } \\n           \\n           return sol +arr[i];\\n           \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 859264,
                "title": "python-a-simple-and-amazing-solution",
                "content": "\\tvalues = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n\\t\\n\\tclass Solution:\\n\\t\\tdef romanToInt(self, s: str) -> int:\\n\\t\\t\\tif not s:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tans = 0\\n\\t\\t\\tprev = values.get(s[0])\\n\\t\\t\\tfor num in s:\\n\\t\\t\\t\\tans += values.get(num)\\n\\t\\t\\t\\tif prev < values.get(num):\\n\\t\\t\\t\\t\\tans -= 2 * prev\\n\\t\\t\\t\\tprev = values.get(num)\\n\\t\\t\\t\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tvalues = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n\\t\\n\\tclass Solution:\\n\\t\\tdef romanToInt(self, s: str) -> int:\\n\\t\\t\\tif not s:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tans = 0\\n\\t\\t\\tprev = values.get(s[0])\\n\\t\\t\\tfor num in s:\\n\\t\\t\\t\\tans += values.get(num)\\n\\t\\t\\t\\tif prev < values.get(num):\\n\\t\\t\\t\\t\\tans -= 2 * prev\\n\\t\\t\\t\\tprev = values.get(num)\\n\\t\\t\\t\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 361735,
                "title": "c-runtime-84-ms-faster-than-94-84-memory-usage-23-8-mb-less-than-8-70",
                "content": "C# solution\\n\\nRuntime: 84 ms, faster than 94.84% of C# online submissions for Roman to Integer.\\nMemory Usage: 23.8 MB, less than 8.70% of C# online submissions for Roman to Integer.\\n\\n```\\npublic class Solution {\\n    private static Dictionary<char, int> _map = new Dictionary<char, int>\\n\\t{\\n\\t\\t{\\'I\\', 1},\\n\\t\\t{\\'V\\', 5},\\n\\t\\t{\\'X\\', 10},\\n\\t\\t{\\'L\\', 50},\\n\\t\\t{\\'C\\', 100},\\n\\t\\t{\\'D\\', 500},\\n\\t\\t{\\'M\\', 1000}\\n\\t};\\n    \\n    public int RomanToInt(string input) \\n\\t{\\n        if (input.Length <= 0)\\n\\t\\t{\\n\\t\\t\\tthrow new Exception();\\n\\t\\t}\\n\\n        var total = 0;\\n\\t\\tvar last = 0;\\n\\n\\t\\tforeach (var rn in input)\\n\\t\\t{\\n\\t\\t\\tvar current = TranslateToNumber(rn);\\n\\n\\t\\t\\tif (current > last)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttotal -= last * 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\ttotal += current;\\n\\t\\t\\tlast = current;\\n\\t\\t}\\n\\n\\t\\treturn total;\\n    }\\n    \\n    private static int TranslateToNumber(char c)\\n\\t{\\n\\t\\t\\treturn _map[c];\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private static Dictionary<char, int> _map = new Dictionary<char, int>\\n\\t{\\n\\t\\t{\\'I\\', 1},\\n\\t\\t{\\'V\\', 5},\\n\\t\\t{\\'X\\', 10},\\n\\t\\t{\\'L\\', 50},\\n\\t\\t{\\'C\\', 100},\\n\\t\\t{\\'D\\', 500},\\n\\t\\t{\\'M\\', 1000}\\n\\t};\\n    \\n    public int RomanToInt(string input) \\n\\t{\\n        if (input.Length <= 0)\\n\\t\\t{\\n\\t\\t\\tthrow new Exception();\\n\\t\\t}\\n\\n        var total = 0;\\n\\t\\tvar last = 0;\\n\\n\\t\\tforeach (var rn in input)\\n\\t\\t{\\n\\t\\t\\tvar current = TranslateToNumber(rn);\\n\\n\\t\\t\\tif (current > last)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttotal -= last * 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\ttotal += current;\\n\\t\\t\\tlast = current;\\n\\t\\t}\\n\\n\\t\\treturn total;\\n    }\\n    \\n    private static int TranslateToNumber(char c)\\n\\t{\\n\\t\\t\\treturn _map[c];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163832,
                "title": "my-c-solution-here",
                "content": "My C# solution here\\n\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\n\\t    int result = 0;\\n            char[] Roman = s.ToArray();\\n            for (int i=0;i<Roman.Length;i++)\\n            {\\n                switch (Roman[i])\\n                {\\n                    case \\'M\\':\\n                        result += 1000;\\n                        break;\\n                    case \\'D\\':\\n                        result += 500;\\n                        break;\\n                    case \\'C\\':\\n                        result += 100;\\n                        break;\\n                    case \\'L\\':\\n                        result += 50;\\n                        break;\\n                    case \\'X\\':\\n                        result += 10;\\n                        break;\\n                    case \\'V\\':\\n                        result += 5;\\n                        break;\\n                    case \\'I\\':\\n                        result += 1;\\n                        break;\\n                }\\n            }\\n            if (s.Contains(\"CD\") || s.Contains(\"CM\"))\\n                result -= 200;\\n            if (s.Contains(\"XL\") || s.Contains(\"XC\"))\\n                result -= 20;\\n            if (s.Contains(\"IV\") || s.Contains(\"IX\"))\\n                result -= 2;\\n\\n\\n            return result;\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\n\\t    int result = 0;\\n            char[] Roman = s.ToArray();\\n            for (int i=0;i<Roman.Length;i++)\\n            {\\n                switch (Roman[i])\\n                {\\n                    case \\'M\\':\\n                        result += 1000;\\n                        break;\\n                    case \\'D\\':\\n                        result += 500;\\n                        break;\\n                    case \\'C\\':\\n                        result += 100;\\n                        break;\\n                    case \\'L\\':\\n                        result += 50;\\n                        break;\\n                    case \\'X\\':\\n                        result += 10;\\n                        break;\\n                    case \\'V\\':\\n                        result += 5;\\n                        break;\\n                    case \\'I\\':\\n                        result += 1;\\n                        break;\\n                }\\n            }\\n            if (s.Contains(\"CD\") || s.Contains(\"CM\"))\\n                result -= 200;\\n            if (s.Contains(\"XL\") || s.Contains(\"XC\"))\\n                result -= 20;\\n            if (s.Contains(\"IV\") || s.Contains(\"IX\"))\\n                result -= 2;\\n\\n\\n            return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6504,
                "title": "immutable-js",
                "content": "```\\nconst romanToInt = (num) => {\\n  const base = {M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1};\\n  const iter = (acc, num) => {\\n    const [first, ...restWithoutOne] = num;\\n    const [second, ...restWithoutTwo] = restWithoutOne;\\n    if (num.length === 0) return acc;\\n    return base[first] < base[second] ?\\n      iter(acc + base[first + second], restWithoutTwo):\\n      iter(acc + base[first], restWithoutOne);\\n  }\\n  return iter(0, num);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst romanToInt = (num) => {\\n  const base = {M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1};\\n  const iter = (acc, num) => {\\n    const [first, ...restWithoutOne] = num;\\n    const [second, ...restWithoutTwo] = restWithoutOne;\\n    if (num.length === 0) return acc;\\n    return base[first] < base[second] ?\\n      iter(acc + base[first + second], restWithoutTwo):\\n      iter(acc + base[first], restWithoutOne);\\n  }\\n  return iter(0, num);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6731,
                "title": "beats-93-python-o-n-solution",
                "content": "    def romanToInt(self,s):\\n        \"\"\"\\n        Accoriding to the [wiki] (https://en.wikipedia.org/wiki/Roman_numerals),\\n        there are only three special cases, which are I, X and C. Thus we only need\\n        to handle these cases when needed.\\n        \"\"\"\\n       \\n        result = 0\\n        for i in range(len(s) - 1, -1, -1):\\n            if s[i] == 'I':\\n                result += 1 if result < 5 else -1\\n            elif s[i] == 'V':\\n            \\tresult += 5\\n            elif s[i] == 'X':\\n            \\tresult += 10 if result < 50 else -10\\n            elif s[i] == 'L':\\n            \\tresult += 50 \\n            elif s[i] == 'C':\\n            \\tresult += 100 if result < 500 else -100\\n            elif s[i] == 'D':\\n            \\tresult += 500\\n            else:\\n            \\tresult += 1000\\n        return result",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "    def romanToInt(self,s):\\n        \"\"\"\\n        Accoriding to the [wiki] (https://en.wikipedia.org/wiki/Roman_numerals),\\n        there are only three special cases, which are I, X and C. Thus we only need\\n        to handle these cases when needed.\\n        \"\"\"\\n       \\n        result = 0\\n        for i in range(len(s) - 1, -1, -1):\\n            if s[i] == 'I':\\n                result += 1 if result < 5 else -1\\n            elif s[i] == 'V':\\n            \\tresult += 5\\n            elif s[i] == 'X':\\n            \\tresult += 10 if result < 50 else -10\\n            elif s[i] == 'L':\\n            \\tresult += 50 \\n            elif s[i] == 'C':\\n            \\tresult += 100 if result < 500 else -100\\n            elif s[i] == 'D':\\n            \\tresult += 500\\n            else:\\n            \\tresult += 1000\\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 3945611,
                "title": "java-runtime-5-ms-beats-59-47-hashmap",
                "content": "# Intuition\\nMy initial approach to solving this problem involves mapping each Roman numeral character to its corresponding integer value. By utilizing a HashMap, I can efficiently access these values during the traversal of the input string. I\\'ll iterate through the string character by character, considering the possibility of subtraction for numerals like \"IV\" or \"IX.\" Finally, I\\'ll accumulate the integer representation and return the result.\\n\\n# Approach\\nCreate a HashMap to store the integer values of Roman numerals, where each character is associated with its corresponding value.\\nInitialize a variable total to keep track of the final integer representation.\\nTraverse the input string character by character using a loop.\\nWithin the loop, check if the current numeral\\'s value is less than the next numeral\\'s value. If so, subtract the current numeral\\'s value from the total. This accounts for numerals like \"IV\" or \"IX.\"\\nIf the current numeral\\'s value is not less than the next numeral\\'s value, simply add the current numeral\\'s value to the total.\\nReturn the accumulated total as the integer representation of the given Roman numeral.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n), where n is the length of the input string. We iterate through the string character by character.\\n\\n- Space complexity:\\nThe space complexity is O(1) since we are using a constant amount of extra space for the HashMap and a few integer variables\\n\\n# Code\\n```\\nclass Solution {\\n    public int romanToInt(String s) {\\n    \\n    HashMap<Character, Integer> hashMap = new HashMap<>();\\n    hashMap.put(\\'I\\', 1);\\n    hashMap.put(\\'V\\', 5);\\n    hashMap.put(\\'X\\', 10);\\n    hashMap.put(\\'L\\', 50);\\n    hashMap.put(\\'C\\', 100);\\n    hashMap.put(\\'D\\', 500);\\n    hashMap.put(\\'M\\', 1000);\\n\\n   \\n    int total = 0;\\n\\n    \\n    for (int i = 0; i < s.length(); i++) {\\n      \\n        if (i < s.length() - 1 && hashMap.get(s.charAt(i)) < hashMap.get(s.charAt(i + 1))) {\\n            total -= hashMap.get(s.charAt(i));\\n        } else {\\n        \\n            total += hashMap.get(s.charAt(i));\\n        }\\n    }\\n\\n   \\n    return total;\\n}\\n\\n}\\n\\n\\n```\\n\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n    \\n    HashMap<Character, Integer> hashMap = new HashMap<>();\\n    hashMap.put(\\'I\\', 1);\\n    hashMap.put(\\'V\\', 5);\\n    hashMap.put(\\'X\\', 10);\\n    hashMap.put(\\'L\\', 50);\\n    hashMap.put(\\'C\\', 100);\\n    hashMap.put(\\'D\\', 500);\\n    hashMap.put(\\'M\\', 1000);\\n\\n   \\n    int total = 0;\\n\\n    \\n    for (int i = 0; i < s.length(); i++) {\\n      \\n        if (i < s.length() - 1 && hashMap.get(s.charAt(i)) < hashMap.get(s.charAt(i + 1))) {\\n            total -= hashMap.get(s.charAt(i));\\n        } else {\\n        \\n            total += hashMap.get(s.charAt(i));\\n        }\\n    }\\n\\n   \\n    return total;\\n}\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021507,
                "title": "roman-to-integer-solution-c",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public int RomanToInt(string s) {\\n        int answer = 0;\\n        int num = 0;\\n        for(int i = s.Length-1; i >= 0; i--){\\n            switch(s[i]){\\n            case \\'I\\': num = 1;\\n            break;\\n            case \\'V\\': num = 5;\\n            break;\\n            case \\'X\\': num = 10;\\n            break;\\n            case \\'L\\': num = 50;\\n            break;\\n            case \\'C\\': num = 100;\\n            break;\\n            case \\'D\\': num = 500;\\n            break;\\n            case \\'M\\': num = 1000;\\n            break;\\n        }       \\n        if(4 * num < answer)\\n        {\\n            answer -= num;\\n        }\\n        else\\n        {\\n            answer += num;\\n        }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int RomanToInt(string s) {\\n        int answer = 0;\\n        int num = 0;\\n        for(int i = s.Length-1; i >= 0; i--){\\n            switch(s[i]){\\n            case \\'I\\': num = 1;\\n            break;\\n            case \\'V\\': num = 5;\\n            break;\\n            case \\'X\\': num = 10;\\n            break;\\n            case \\'L\\': num = 50;\\n            break;\\n            case \\'C\\': num = 100;\\n            break;\\n            case \\'D\\': num = 500;\\n            break;\\n            case \\'M\\': num = 1000;\\n            break;\\n        }       \\n        if(4 * num < answer)\\n        {\\n            answer -= num;\\n        }\\n        else\\n        {\\n            answer += num;\\n        }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951733,
                "title": "easy-c-solution-with-time-o-n-and-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to map the string set with their corresponding integer values and return the answer with help of some integer values\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. first we will take a roman array vector which will contain the corresponding integer value of the respective roman string.\\n2. we will take an ***ans*** variable which is initialised to 0 and return the final integer value of the corresponding roman string.\\n3. now we will iterate through every character of the string and check for the corresponding value.\\n        - Now there will be  2 cases\\n   - **case 1-**  if(roman[s[i]]<roman[s[i+1]])\\n                        {\\n                    ans=ans+roman[s[i+1]]-roman[s[i]]-roman[s[i+1]];\\n                        }\\nHere, I have written ans=ans+roman[s[i+1]]-roman[s[i]]-roman[s[i+1]]; just for the sake of better understanding that the characters from index=1 to index=n-1 will be repeated, so they need to cancel out \\nSo the final answer for this case will be: **ans=ans-roman[s[i]]**;\\n     \\n   - **case 2-** if(roman[s[i]]>=roman[s[i+1]])\\n                        {\\n                ans+=roman[s[i]]+roman[s[i+1]]-roman[s[i+1]];\\n            } \\nHere also, I have written ans=ans+roman[s[i]]+roman[s[i+1]]-roman[s[i+1]];as index=2 to index=n are repeating twice,so they need to be subtracted,\\nBut here the integer value corresponding to the roman is either greater or equal to the value with the succeeding index\\nSo the final answer for this case will be: **ans=ans+roman[s[i]]**;\\n\\n\\n# Complexity\\n- Time complexity:\\n    **Time: O(n)**\\nEach character is traversed once only, so linear time complexity.\\n\\n- Space complexity:\\n    **Space: O(128) = O(1)**\\nthere will be only constants i.e roman(128) so only constant space complexity.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        vector<int>roman(128);\\n        int ans=0;\\n        roman[\\'I\\'] = 1;\\n        roman[\\'V\\'] = 5;\\n        roman[\\'X\\'] = 10;\\n        roman[\\'L\\'] = 50;\\n        roman[\\'C\\'] = 100;\\n        roman[\\'D\\'] = 500;\\n        roman[\\'M\\'] = 1000;\\n        for(int i =0;i<s.size();i++)\\n        {\\n            if(roman[s[i]]<roman[s[i+1]])\\n            {\\n                ans=ans+roman[s[i+1]]-roman[s[i]]-roman[s[i+1]];\\n            }\\n            else\\n            {\\n                ans+=roman[s[i]]+roman[s[i+1]]-roman[s[i+1]];\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        vector<int>roman(128);\\n        int ans=0;\\n        roman[\\'I\\'] = 1;\\n        roman[\\'V\\'] = 5;\\n        roman[\\'X\\'] = 10;\\n        roman[\\'L\\'] = 50;\\n        roman[\\'C\\'] = 100;\\n        roman[\\'D\\'] = 500;\\n        roman[\\'M\\'] = 1000;\\n        for(int i =0;i<s.size();i++)\\n        {\\n            if(roman[s[i]]<roman[s[i+1]])\\n            {\\n                ans=ans+roman[s[i+1]]-roman[s[i]]-roman[s[i+1]];\\n            }\\n            else\\n            {\\n                ans+=roman[s[i]]+roman[s[i+1]]-roman[s[i+1]];\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631274,
                "title": "beginner-freindly-approch",
                "content": "**//Beginner Freindly Approch \\n//by using simple if and else **\\n\\nclass Solution {\\npublic:\\n\\n    int romanToInt(string s) {\\n        int ans = 0;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i] == \\'I\\' and s[i+1] == \\'V\\'){\\n                ans+=4;\\n                i++;\\n            }\\n            else if(s[i] == \\'I\\' and s[i+1] == \\'X\\'){\\n                ans+=9;\\n                i++;\\n            }\\n            else if(s[i] == \\'X\\' and s[i+1] == \\'L\\'){\\n                ans+=40;\\n                i++;\\n            }\\n            else if(s[i] == \\'X\\' and s[i+1] == \\'C\\'){\\n                ans+=90;\\n                i++;\\n            }\\n            else if(s[i] == \\'C\\' and s[i+1] == \\'D\\'){\\n                ans+=400;\\n                i++;\\n            }\\n            else if(s[i] == \\'C\\' and s[i+1] == \\'M\\'){\\n                ans+=900;\\n                i++;\\n            }\\n            else if(s[i] == \\'I\\'){\\n                ans+=1;\\n            }\\n            else if(s[i] == \\'V\\'){\\n                ans+=5;\\n            }\\n            else if(s[i] == \\'X\\'){\\n                ans+=10;\\n            }\\n            else if(s[i] == \\'L\\'){\\n                ans+=50;\\n            }\\n            else if(s[i] == \\'C\\'){\\n                ans+=100;\\n            }\\n            else if(s[i] == \\'D\\'){\\n                ans+=500;\\n            }\\n            else if(s[i] == \\'M\\'){\\n                ans+=1000;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int romanToInt(string s) {\\n        int ans = 0;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i] == \\'I\\' and s[i+1] == \\'V\\'){\\n                ans+=4;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2376488,
                "title": "javascript-solution",
                "content": "```\\nvar romanToInt = function(s) {\\n    const map = {\\n        \\'I\\': 1,\\n        \\'V\\': 5,\\n        \\'X\\': 10,\\n        \\'L\\': 50,\\n        \\'C\\': 100,\\n        \\'D\\': 500,\\n        \\'M\\': 1000\\n    }\\n    let result = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        const curr = map[s[i]], next = map[s[i + 1]];\\n        result += curr < next ? - curr : curr;\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar romanToInt = function(s) {\\n    const map = {\\n        \\'I\\': 1,\\n        \\'V\\': 5,\\n        \\'X\\': 10,\\n        \\'L\\': 50,\\n        \\'C\\': 100,\\n        \\'D\\': 500,\\n        \\'M\\': 1000\\n    }\\n    let result = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        const curr = map[s[i]], next = map[s[i + 1]];\\n        result += curr < next ? - curr : curr;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2201162,
                "title": "php-using-str-tr",
                "content": "so i did this and it worked :)\\n\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function romanToInt($s) {\\n        $s = strtr(\\n            $s,\\n            [\\n                \\'M\\' => \\'1000,\\',\\n                \\'CM\\' => \\'900,\\',\\n                \\'D\\' => \\'500,\\',\\n                \\'CD\\' => \\'400,\\',\\n                \\'C\\' => \\'100,\\',\\n                \\'XC\\' => \\'90,\\',\\n                \\'L\\' => \\'50,\\',\\n                \\'XL\\' => \\'40,\\',\\n                \\'X\\' => \\'10,\\',\\n                \\'IX\\' => \\'9,\\',\\n                \\'V\\' => \\'5,\\',\\n                \\'IV\\' => \\'4\\',\\n                \\'I\\' => \\'1,\\'\\n            ]\\n        );\\n        return array_sum(explode(\\',\\', $s));\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function romanToInt($s) {\\n        $s = strtr(\\n            $s,\\n            [\\n                \\'M\\' => \\'1000,\\',\\n                \\'CM\\' => \\'900,\\',\\n                \\'D\\' => \\'500,\\',\\n                \\'CD\\' => \\'400,\\',\\n                \\'C\\' => \\'100,\\',\\n                \\'XC\\' => \\'90,\\',\\n                \\'L\\' => \\'50,\\',\\n                \\'XL\\' => \\'40,\\',\\n                \\'X\\' => \\'10,\\',\\n                \\'IX\\' => \\'9,\\',\\n                \\'V\\' => \\'5,\\',\\n                \\'IV\\' => \\'4\\',\\n                \\'I\\' => \\'1,\\'\\n            ]\\n        );\\n        return array_sum(explode(\\',\\', $s));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147738,
                "title": "python-3-faster-than-99-03",
                "content": "![image](https://assets.leetcode.com/users/images/a75f4790-dceb-4049-8cce-fad11e7d3c1b_1655134696.2122338.png)\\n```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        d = {\\n            \"I\": 1,\\n            \"V\": 5,\\n            \"X\": 10,\\n            \"L\": 50,\\n            \"C\": 100,\\n            \"D\": 500,\\n            \"M\": 1000\\n        }\\n        \\n        count = 0\\n        for i in range(len(s)):\\n            if i+1<len(s) and d[s[i]] < d[s[i+1]]:\\n                count -= d[s[i]]\\n            else:\\n                count += d[s[i]]\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        d = {\\n            \"I\": 1,\\n            \"V\": 5,\\n            \"X\": 10,\\n            \"L\": 50,\\n            \"C\": 100,\\n            \"D\": 500,\\n            \"M\": 1000\\n        }\\n        \\n        count = 0\\n        for i in range(len(s)):\\n            if i+1<len(s) and d[s[i]] < d[s[i+1]]:\\n                count -= d[s[i]]\\n            else:\\n                count += d[s[i]]\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128584,
                "title": "java-clean-and-simple-one-cheaking-only-4ms",
                "content": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int[] arr = new int[\\'A\\' + 26];\\n        arr[\\'I\\'] = 1;\\n        arr[\\'V\\'] = 5;\\n        arr[\\'X\\'] = 10;\\n        arr[\\'L\\'] = 50;\\n        arr[\\'C\\'] = 100;\\n        arr[\\'D\\'] = 500;\\n        arr[\\'M\\'] = 1000;\\n\\n        int result = 0;\\n        int prev = 0;\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            int current = arr[s.charAt(i)];\\n            result += prev > current ? -current : current;\\n            prev = current;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int[] arr = new int[\\'A\\' + 26];\\n        arr[\\'I\\'] = 1;\\n        arr[\\'V\\'] = 5;\\n        arr[\\'X\\'] = 10;\\n        arr[\\'L\\'] = 50;\\n        arr[\\'C\\'] = 100;\\n        arr[\\'D\\'] = 500;\\n        arr[\\'M\\'] = 1000;\\n\\n        int result = 0;\\n        int prev = 0;\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            int current = arr[s.charAt(i)];\\n            result += prev > current ? -current : current;\\n            prev = current;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712858,
                "title": "c-solution-using-hashmap-in-o-n-time",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Store the roman values in HashMap so that we can find them in O(1) time.\\n- We keep the roman character value in num\\n    - if the current character is greater or equal to the next char then store `mp[s[i]]`\\n    - else store `mp[s[i+1]] - mp[s[i]]`\\n- Add num to ans & finally return it.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int n= s.size(), ans=0, i=0, num;\\n        unordered_map<char, int> mp;\\n        mp[\\'I\\']=1 ;mp[\\'V\\']=5 ;mp[\\'X\\']=10 ;mp[\\'L\\']=50 ;mp[\\'C\\']=100 ;mp[\\'D\\']=500 ;mp[\\'M\\']=1000 ;\\n               \\n        while(i<n){\\n            if(i==n-1 || (mp[s[i]]>=mp[s[i+1]])){\\n                num = mp[s[i]];\\n                i++;\\n            }\\n            else{\\n                num = mp[s[i+1]] - mp[s[i]];\\n                i += 2;\\n            }         \\n            ans += num;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int n= s.size(), ans=0, i=0, num;\\n        unordered_map<char, int> mp;\\n        mp[\\'I\\']=1 ;mp[\\'V\\']=5 ;mp[\\'X\\']=10 ;mp[\\'L\\']=50 ;mp[\\'C\\']=100 ;mp[\\'D\\']=500 ;mp[\\'M\\']=1000 ;\\n               \\n        while(i<n){\\n            if(i==n-1 || (mp[s[i]]>=mp[s[i+1]])){\\n                num = mp[s[i]];\\n                i++;\\n            }\\n            else{\\n                num = mp[s[i+1]] - mp[s[i]];\\n                i += 2;\\n            }         \\n            ans += num;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417257,
                "title": "java-easy-simple-to-understand",
                "content": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> m=new HashMap<>();\\n        m.put(\\'I\\',1);\\n        m.put(\\'V\\',5);\\n        m.put(\\'X\\',10);\\n        m.put(\\'L\\',50);\\n        m.put(\\'C\\',100);\\n        m.put(\\'D\\',500);\\n        m.put(\\'M\\',1000);\\n        \\n        s=s.replaceAll(\"IV\",\"IIII\").replaceAll(\"IX\",\"VIIII\")\\n            .replaceAll(\"XL\",\"XXXX\").replaceAll(\"XC\",\"LXXXX\")\\n            .replaceAll(\"CD\",\"CCCC\").replaceAll(\"CM\",\"DCCCC\");\\n      \\n        int num=0;\\n        for(int i=0;i<s.length();i++){\\n            num=num+m.get(s.charAt(i));\\n        }\\n        \\n        \\n     return num;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> m=new HashMap<>();\\n        m.put(\\'I\\',1);\\n        m.put(\\'V\\',5);\\n        m.put(\\'X\\',10);\\n        m.put(\\'L\\',50);\\n        m.put(\\'C\\',100);\\n        m.put(\\'D\\',500);\\n        m.put(\\'M\\',1000);\\n        \\n        s=s.replaceAll(\"IV\",\"IIII\").replaceAll(\"IX\",\"VIIII\")\\n            .replaceAll(\"XL\",\"XXXX\").replaceAll(\"XC\",\"LXXXX\")\\n            .replaceAll(\"CD\",\"CCCC\").replaceAll(\"CM\",\"DCCCC\");\\n      \\n        int num=0;\\n        for(int i=0;i<s.length();i++){\\n            num=num+m.get(s.charAt(i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1337507,
                "title": "simplest-c-solution-using-map-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) \\n    {\\n        map<char,int>map;\\n        map[\\'I\\'] = 1;\\n        map[\\'V\\'] = 5;\\n        map[\\'X\\'] = 10;\\n        map[\\'L\\'] = 50;\\n        map[\\'C\\'] = 100;\\n        map[\\'D\\'] = 500;\\n        map[\\'M\\'] = 1000;\\n        \\n        int ans = 0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(map[s[i]] < map[s[i+1]])\\n            {\\n                ans -= map[s[i]];\\n            }\\n            else\\n            {\\n                ans += map[s[i]];\\n            }\\n        }\\n        return ans + map[s[s.size()-1]];\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) \\n    {\\n        map<char,int>map;\\n        map[\\'I\\'] = 1;\\n        map[\\'V\\'] = 5;\\n        map[\\'X\\'] = 10;\\n        map[\\'L\\'] = 50;\\n        map[\\'C\\'] = 100;\\n        map[\\'D\\'] = 500;\\n        map[\\'M\\'] = 1000;\\n        \\n        int ans = 0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(map[s[i]] < map[s[i+1]])\\n            {\\n                ans -= map[s[i]];\\n            }\\n            else\\n            {\\n                ans += map[s[i]];\\n            }\\n        }\\n        return ans + map[s[s.size()-1]];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880211,
                "title": "c-best-solution-i-can-come-up-with-simple-sol-with-commentary",
                "content": "```\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int count=0;\\n        int preInt =0;         // to store previous char value \\n        //unordered map for finding interger value for roman numerals\\n        unordered_map<char, int> math= {{\\'I\\', 1}, {\\'V\\', 5}, {\\'X\\', 10},{\\'L\\', 50}, {\\'C\\', 100}, {\\'D\\', 500}, {\\'M\\', 1000}};\\n        \\n        // loop from end...starting\\n        for(int i=s.length()-1; i>=0; i--){\\n            char ch= s[i];\\n            int curInt = math[ch];    // store current char integer value\\n            // value is greater or equal to previous value then increment count i.e., II means 1+1\\n            //else in case of IV V=5 and I=1 here 1<5 then else part runs and 5-1=4 is the answer\\n            if(curInt>= preInt)\\n                count+= curInt;\\n            else\\n                count-= curInt;\\n            preInt=curInt;         // update preInt value with current value for next iteration\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int count=0;\\n        int preInt =0;         // to store previous char value \\n        //unordered map for finding interger value for roman numerals\\n        unordered_map<char, int> math= {{\\'I\\', 1}",
                "codeTag": "Java"
            },
            {
                "id": 589035,
                "title": "my-java-solution",
                "content": "```\\nimport java.util.Map;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        \\n        char [] str = s.toCharArray();\\n        \\n        int decimal = 0;\\n        int prev = 0;\\n        \\n        for ( int i = str.length - 1; i >= 0; i--){\\n            if ( map.get(str[i]) < prev ) {\\n                decimal -= map.get(str[i]);\\n            } else {\\n                decimal += map.get(str[i]);\\n            }\\n            prev = map.get(str[i]);\\n        } \\n        return decimal;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Map;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        \\n        char [] str = s.toCharArray();\\n        \\n        int decimal = 0;\\n        int prev = 0;\\n        \\n        for ( int i = str.length - 1; i >= 0; i--){\\n            if ( map.get(str[i]) < prev ) {\\n                decimal -= map.get(str[i]);\\n            } else {\\n                decimal += map.get(str[i]);\\n            }\\n            prev = map.get(str[i]);\\n        } \\n        return decimal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260358,
                "title": "javascript-164ms",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n\\t/* define an object to be dictionary */\\n    const ROMAN_NUMERALS = {\\n        \\'I\\' : 1,\\n        \\'V\\' : 5,\\n        \\'X\\' : 10,\\n        \\'L\\' : 50,\\n        \\'C\\' : 100,\\n        \\'D\\' : 500,\\n        \\'M\\' : 1000,\\n    };\\n    \\n\\t/* define a variable to record result */\\n    let sum = 0;\\n    \\n    /* loop string from end to start */\\n    for(let i = s.length - 1; i >= 0; i--) {\\n        /* get current number and previous number according to the dictionary */\\n        let current = ROMAN_NUMERALS[s[i]], prev = ROMAN_NUMERALS[s[i + 1]];\\n\\n        /* if previous number exists and current number less than privous one, sum minus current value */\\n        if(prev && current < prev ) {\\n            sum -= current;\\n        }\\n\\t\\t/* else sum plus current value */\\n\\t\\telse {\\n            sum += current;\\n        }\\n    }\\n\\t\\n\\t/* return result */\\n    return sum;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n\\t/* define an object to be dictionary */\\n    const ROMAN_NUMERALS = {\\n        \\'I\\' : 1,\\n        \\'V\\' : 5,\\n        \\'X\\' : 10,\\n        \\'L\\' : 50,\\n        \\'C\\' : 100,\\n        \\'D\\' : 500,\\n        \\'M\\' : 1000,\\n    };\\n    \\n\\t/* define a variable to record result */\\n    let sum = 0;\\n    \\n    /* loop string from end to start */\\n    for(let i = s.length - 1; i >= 0; i--) {\\n        /* get current number and previous number according to the dictionary */\\n        let current = ROMAN_NUMERALS[s[i]], prev = ROMAN_NUMERALS[s[i + 1]];\\n\\n        /* if previous number exists and current number less than privous one, sum minus current value */\\n        if(prev && current < prev ) {\\n            sum -= current;\\n        }\\n\\t\\t/* else sum plus current value */\\n\\t\\telse {\\n            sum += current;\\n        }\\n    }\\n\\t\\n\\t/* return result */\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6739,
                "title": "my-python-solution",
                "content": "    class Solution:\\n        # @return an integer\\n        def romanToInt(self, s):\\n            dic = {\\n                'I': lambda i: -1 if s[i + 1] in ['V', 'X'] else 1,\\n                'X': lambda i: -10 if s[i + 1] in ['L', 'C'] else 10,\\n                'C': lambda i: -100 if s[i + 1] in ['D', 'M'] else 100,\\n                'V': lambda i: 5,\\n                'L': lambda i: 50,\\n                'D': lambda i: 500,\\n                'M': lambda i: 1000,\\n            }\\n            x = 0\\n            s += '@'\\n            for i, ch in enumerate(s[:-1]):\\n                x += dic[ch](i)\\n            return x",
                "solutionTags": [],
                "code": "class Solution:\\n        # @return an integer\\n        def romanToInt(self, s):\\n            dic = {\\n                'I': lambda i: -1 if s[i + 1] in ['V', 'X'] else 1,\\n                'X': lambda i: -10 if s[i + 1] in ['L', 'C'] else 10,\\n                'C': lambda i: -100 if s[i + 1] in ['D', 'M'] else 100,\\n                'V': lambda i: 5,\\n                'L': lambda i: 50,\\n                'D': lambda i: 500,\\n                'M': lambda i: 1000,\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1710232,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1783099,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1568833,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1718678,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1687605,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1573710,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1574358,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1568731,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1568832,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1571036,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1710232,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1783099,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1568833,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1718678,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1687605,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1573710,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1574358,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1568731,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1568832,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1571036,
                "content": [
                    {
                        "username": "alienfuyu",
                        "content": "I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others."
                    },
                    {
                        "username": "rakshanch0004",
                        "content": "well said"
                    },
                    {
                        "username": "Levidps",
                        "content": "Not all one liners are about ego. Recently started digging into learning FP and would say a lot of the approach of pure functions results in one liners and those are arguably not just about having an ego."
                    },
                    {
                        "username": "ejrinkus",
                        "content": "The balance between readability and performance is really a question of context.  If the code in question is under active maintenance and might need to be read (and possibly modified) frequently, then sure, increasing readability is a worthy goal and I'd agree with you.\n\nHowever, when I see a function like this specific one, I imagine it is a utility function that gets written once, and should (ideally) be never touched or read again.  In such a context, readability is less of a concern:\n\n - A utility like this is probably getting called numerous times throughout your codebase, possibly millions/billions of times per second (depending on your scale).  As a result, tiny performance improvements become much more impactful and could be worthy of the loss in readability.\n\n- The code will probably never need to change unless exceptional circumstances arise (e.g. a migration to a new revision of your language that breaks the implementation, or that allows the implementation to be even faster).  In these cases, it's probably a deep language expert making the change anyway, and they should already be capable of parsing the less readable implementation to make the necessary changes.\n\n- As noted by [@Juan Ignacio Quinteros Parada](/JuanQP), nobody should ever need to read the function implementation in the first place.  The name is clear, and with good documentation anyone that uses it will know what it does without needing to look at the code.\n\nIt is entirely false to say that all production code should prioritize readability.  There's certainly a large proportion of production code where it's more appropriate to be slightly less performant in the interest of readability, but that code is often supported by lower level utilities that need to be as performant as possible no matter how unreadable the code gets.  So I don't think it's fair to broadly claim that readable solutions are better than unreadable ones.\n\nAs an interviewer, I would never expect to see one of these arcane-and-unreadable but highly-performant solutions.  However, the candidate would likely get a pass from me as long as their solution and algorithm are sound.  They'd simply get bonus points if they could articulate to me the tradeoffs between readability and performance, and when you would prioritize one over the other (regardless of whether or not they're enough of a language expert to actually write the arcane solution).\n\n"
                    },
                    {
                        "username": "falutinraven",
                        "content": "I think things that modify the input are dangerous when you put it in a complete program. we dont know what the results could be. especially this solution. something like making the input array larger than what the original constraints are supposed to be (<=15) could be dangerous. \\n\\nAlthough I do like the creative solution because it promotes thinking outside the box, I would be wary in putting it in production (also the tradeoffs of considering how an elegant solution fits into a whole codebase and if it doesnt break something are non-negligable which means we\\'re spending more time than we need)   \\n\\neven if its a bit faster than the normal solution (which i kinda doubt. I dont know the runtime of the replace function in python, but that is the solution im talking about and im sure its also O(n) at least, and we run it 6 times) we are also making the input much larger. this is fine if memory isnt an issue, but if were going that hard to make an elegant solution to save performance, I doubt that we have the extra memory to make the input array much larger, not even considering how the new array would interact with the rest of the codebase. ive ranted long enough haha."
                    },
                    {
                        "username": "mike_software_test",
                        "content": "+100500"
                    },
                    {
                        "username": "zenverak",
                        "content": "In production I agree, but in a more competitive  sense you do what you want. Having said that, it also depends on how critical certain things are. If your load is sizable enough, you may have to opt for something extremely efficient and barely readable. "
                    },
                    {
                        "username": "alexkoshernosiegov",
                        "content": "That\\'s a competitive coding platform and it always values code performance. Sure, in the real world production code should be a compromise between readability and performance"
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "I think otherwise, i think that if you make a program that runs a big load of processing stuffs, the better would be less memory and CPU usage, the readability is only for humans and dev, but you aren\\'t thinking about the client, that doesn\\'t read the code but want a software that runs smoothly. Especially if you consider systems with low spec."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I think the idea of this kind of problems (most of \"easy\" leet code problems, actually...) is to see if you can come up with a solution that requires to traverse an array just once. It\\'s very \"tempting\" in this kind of problems to iterate a few times the array in order to check certains things, but if you think a little bit more about the problem you can solve it using only one iteration.\\n\\nAlso, once the function is ready, naming it like `romanToInt` is pretty understandable and it will change little to nothing over time. So, yes, it might be a little bit awful to read, but as long it has a good name I think having fast code is worth in this cases."
                    },
                    {
                        "username": "jeffdt",
                        "content": "I think people like to do it just to challenge themselves. That doesn\\'t mean they write production code the same way."
                    },
                    {
                        "username": "KhaledLeet",
                        "content": "My first problem on leetcode :)"
                    },
                    {
                        "username": "crystaldesnow",
                        "content": "me tooo"
                    },
                    {
                        "username": "santwan",
                        "content": "me also"
                    },
                    {
                        "username": "tranduy7102002",
                        "content": "same ^^"
                    },
                    {
                        "username": "Ajmalleonard",
                        "content": "[@eliyoung4](/eliyoung4) I just Wonder why it look like this too, "
                    },
                    {
                        "username": "bryanwu0214",
                        "content": "Same!"
                    },
                    {
                        "username": "edxylom",
                        "content": "Contratulations!"
                    },
                    {
                        "username": "eliyoung4",
                        "content": "[@tmahmoud793](/tmahmoud793) yeah i just opened this problem and am not looking forward to completing it..."
                    },
                    {
                        "username": "tmahmoud793",
                        "content": "+1 but I found really lot of nonesense bugs I dunno why"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "I dont quite understand why the frequency of this problem appeared in real interview is so high.\\n\\nWhat this problem test us?\\n\\nI don't think anyone familiar with the law of roman numbers."
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i agree why do i need to study the question while im practiceing or leanrning how to solve proplems."
                    },
                    {
                        "username": "SophiaCristina",
                        "content": "It is not about roman numbers, it is about your capacity to deal with strings and how you manage to transform characters into numbers...\\nThe problem is not the roman numbers, but the fact you have to deal with an operation that depends of the next index and that may change what you are evaluating on the current index."
                    },
                    {
                        "username": "spellcasters22",
                        "content": "[@chazwinter](/chazwinter) to be fair you have a big advantage going into this question if you have a vague understanding of how they work and only need a refreshers vs the anxiety i imagine someone who truly has never seen them might feel if presented with this in an interview. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I think it\\'s to gauge how a candidate would approach the problem. What type of data structures were used? Logic and edge-case consideration. This problem, although not difficult, requires some thinking, so I could definitely see this as a way for interviewers to get a feel for the type of person you are when approaching problems. "
                    },
                    {
                        "username": "chazwinter",
                        "content": "Your ability to handle an algorithm that sometimes needs to do the opposite of what it \"normally\" does? \nIn my experience, the only people who question the point of an exercise are the ones who can't do it. Just saying.\nAnd it's irrelevant if anyone knows how Roman numerals work, because that information is given in the problem statement. Your job is to execute code that fills the request, not question the request or editorialize."
                    },
                    {
                        "username": "lazoukov",
                        "content": "The task does not prove Roman numbers manipulation, but the general approach of a candidate to manipulate data in various manner. Just and only."
                    },
                    {
                        "username": "dpap",
                        "content": "as a beginner, here are some python hints that might help other newbies start off in the right direction:\\n* use a dictionary for the roman numeral values\\n* use `enumerate` when iterating through the input string (i always forget to use this)\\n* to distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\\n\\n"
                    },
                    {
                        "username": "odecteel",
                        "content": "Great hint(3), thanks"
                    },
                    {
                        "username": "kronozerg",
                        "content": "Another hints!\\n\\nThere are only 6 special case.\\nAnd all of these cases always have the first numerical value that is smaller.\\n\\nThere is no requirement to validate the roman letters."
                    },
                    {
                        "username": "Narendra_Singh_",
                        "content": "JAVA SIMPLEST SOLUTION : -\\n.\\n.\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<Character, Integer>();\\n        int sum=0;\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        s=s.replace(\"IV\",\"IIII\");\\n        s=s.replace(\"IX\",\"VIIII\");\\n        s=s.replace(\"XL\",\"XXXX\");\\n        s=s.replace(\"XC\",\"LXXXX\");\\n        s=s.replace(\"CD\",\"CCCC\");\\n        s=s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            sum = sum + (map.get(s.charAt(i)));\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "edwardstock",
                        "content": "I like it! Despite its not being efficient, I couldn\\'t have come up with a more straightforward solution than this."
                    },
                    {
                        "username": "prince73757",
                        "content": "[@zenverak](/zenverak)  The boy just messing the rule of Discussion area."
                    },
                    {
                        "username": "jaimeherrera1224",
                        "content": "[@meggaspy](/meggaspy) Totally agree with you! That\\'s not efficient in any case, making the string larger extends the for loop execution. What a waste of memory to be honest."
                    },
                    {
                        "username": "SweetTechnique",
                        "content": "It even says here that you should not post a solution. That this is self-evident, I thought until I saw this comment. Now I know that there are users for whom this is probably not so self-evident.\\nIs such behavior perhaps proof that just being able to do mathematics and a bit of programming is no proof of higher intelligence? I ask only out of curiosity."
                    },
                    {
                        "username": "jithujacob73",
                        "content": "You are an intelligent fucking boy\\uD83D\\uDE0E"
                    },
                    {
                        "username": "meggaspy",
                        "content": "you sir are a disgusting human being"
                    },
                    {
                        "username": "zenverak",
                        "content": "I am so proud you could put the solution in the discussion area and not the solution area."
                    },
                    {
                        "username": "bman917",
                        "content": "The roman numeral for 49 is \"XLIX\". \\n\\nReference:\\n* https://roman-numerals.info/49\\n* https://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\\n* https://www.calculateme.com/roman-numerals/to-roman/49\\n\\nHOWEVER, LeetCode\\'s answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\\n\\n* I can be placed before V (5) and X (10) to make 4 and 9. \\n* X can be placed before L (50) and C (100) to make 40 and 90.\\n\\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed."
                    },
                    {
                        "username": "minertyler100",
                        "content": "I don\\'t think it can be assumed. It only states that I can be placed before V and X, nothing else. That is the way I also programmed the solution, to where it only checks letters one or two above the subtractor in question"
                    },
                    {
                        "username": "codyli520",
                        "content": "Tried `\"IM\"` which is not a valid Roman numeral in the testcase console, and it says Expected: 999\\nShouldn\\'t such case return None or -1 to indicate invalid input?"
                    },
                    {
                        "username": "falutinraven",
                        "content": "note the constraint \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\"\\n\\nin theory, ya we should be validating the input, but it is not within the scope of this function since the input already comes prevalidated "
                    },
                    {
                        "username": "lucky_seqr",
                        "content": " \\nI can be placed before V (5) and X (10) to make 4 and 9. \\nX can be placed before L (50) and C (100) to make 40 and 90. \\nC can be placed before D (500) and M (1000) to make 400 and 900.\\nwe substract highest value - lowest value :) in the above condition only.\\nnot IM = 1000-1=999\\nwe correct it into 1+1000=1001"
                    },
                    {
                        "username": "sohailiftikhar",
                        "content": "They clearly mentioned that the string will be valid Roman number."
                    },
                    {
                        "username": "CaptSniper",
                        "content": "[@user3876AH](/user3876AH) The way I understand it is that \"None\" is Python\\'s null pointer"
                    },
                    {
                        "username": "vaszv",
                        "content": "Good point, there are many incorrect cases like: IIII, VV, XXXX, IVV, XM and so on. I think the most complex part here is to validate incorrect cases and this can make this task from Easy to Middle."
                    },
                    {
                        "username": "ravi_22092",
                        "content": "M = 1000\\nI = 1 \\nso IM = 1000-1= 999\\n"
                    },
                    {
                        "username": "user3876AH",
                        "content": "None?"
                    },
                    {
                        "username": "abhishekraj2706",
                        "content": "read constraints; it is mentioned there that it is guaranteed that the  no is a correct roman number"
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "i dont know how leetcode take inputs like\\n[2,3,4,5] kind of"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "here the main method is hidden in case of java from inside the main merthod they trigger the method with it\\'s argument and thats how they inject values from main to external method.\\n "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "Deftster",
                        "content": "As command line arguments. In Java for example  -> public static void main(String args[]){  String s = args[0]}  from running \"java mycode.java some_input\" args[0] would equal \"some_input\""
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "This is basic knowledge:\\n\\nhttps://www.math.nmsu.edu/~pmorandi/math111f01/RomanNumerals.html\\n\\nThese are good for another question **Integer to Roman**:\\n\\nhttp://literacy.kent.edu/Minigrants/Cinci/romanchart.htm\\n\\nhttp://number.webmasters.sk/roman.php"
                    },
                    {
                        "username": "chuckorange",
                        "content": "I don't think \"IIIII\" is a valid input.\\nHowever, the expected answer from leetcode is 5.\\nMany top solutions are simple but don't consider this.\\nMy solution is using a finite state machine."
                    },
                    {
                        "username": "AGorohov",
                        "content": "We have constraint: \"It is guaranteed that s is a valid roman numeral in the range [1, 3999]\""
                    }
                ]
            },
            {
                "id": 1939842,
                "content": [
                    {
                        "username": "Numaira-Nawaz",
                        "content": "My third problem on leetcode :)\\nbut it doesn\\'t look easy :("
                    },
                    {
                        "username": "Titret",
                        "content": "Me too I don\\'t find it easy anymore \\n"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes two different solutions:\nhttps://www.youtube.com/watch?v=tsmrUi5M1JU&t=95s"
                    },
                    {
                        "username": "PriyanshuTiwari01",
                        "content": " here\\'s a detailed answer \\n        rom_val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        int_val = 0\\n        for i in range(len(s)):\\n            if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:\\n                int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\\n            else:\\n                int_val += rom_val[s[i]]\\n        return int_val\\n         "
                    },
                    {
                        "username": "Ramachandra22",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni)  We have already added the number we want to subtract in the previous step(iteration) so we subtract it twice .  I hope it answers"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi I almost came up with the same solution by only missing the `2 * rom_val[s[i-1]`, can you please explain why I have to multiply while subtracting?"
                    },
                    {
                        "username": "meggaspy",
                        "content": "ofc you post the awnser "
                    },
                    {
                        "username": "siva-sagar",
                        "content": "can you explain how did you come up with this logic ?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/\\n"
                    },
                    {
                        "username": "prince73757",
                        "content": "To convert a Roman numeral string to an integer, you can use the following approach:\\n\\n1. Initialize a variable result to store the final integer value.\\nCreate a map that associates each Roman numeral symbol with its corresponding value.\\n2. Iterate through the Roman numeral string from left to right.\\n3. If the current Roman numeral symbol is less than the next symbol, subtract its value from the result.\\nOtherwise, add its value to the result.\\n4. Return the final value stored in result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nice tip"
                    },
                    {
                        "username": "ilirnikolli8",
                        "content": "Times new roma"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i struggled a lot to solve this  one \\uD83D\\uDE14"
                    },
                    {
                        "username": "tami_cp0",
                        "content": "I\\'m so confused at what i\\'m looking at tbh :("
                    },
                    {
                        "username": "Pruss",
                        "content": "A lot of solutions get the tests succeed, but are wrong according to the rules. They just check if a preceeding letter is lower than its successor, and then subtract predecesssor from successor.\\ni.e. \"VX\" is 15 and not 5. You should add more test cases to get a better coverage.  "
                    },
                    {
                        "username": "user8594ir",
                        "content": "No, you\\'re getting the rules wrong, VX is not valid, and 15 is represented as XV."
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int sum = 0;\\n        s = s.replace(\"IV\",\"IIII\");\\n        s = s.replace(\"IX\",\"VIIII\");\\n        s = s.replace(\"XL\",\"XXXX\");\\n        s = s.replace(\"XC\",\"LXXXX\");\\n        s = s.replace(\"CD\",\"CCCC\");\\n        s = s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch ==\\'I\\'){\\n                sum = sum + 1;\\n            }\\n            else if(ch == \\'V\\'){\\n                sum = sum + 5;\\n            }\\n            else if(ch == \\'X\\'){\\n                sum = sum + 10;\\n            }\\n            else if (ch == \\'L\\'){\\n                sum = sum + 50;\\n            }\\n            else if (ch == \\'C\\'){\\n                sum = sum + 100;\\n            }\\n            else if (ch == \\'D\\'){\\n                sum = sum + 500;\\n            }\\n            else if (ch == \\'M\\'){\\n                sum = sum + 1000;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "GeX2016",
                        "content": "IVI = 5 but it is not a Roman number because V already exist. Yes LeetCode catches this, but I am interested on how you would code this manually? How many total similarities are there? LMK, TIA. :)"
                    },
                    {
                        "username": "SusAmogus",
                        "content": "for that specific case  its is easy. Simply if the current number is bigger than the previous make a bool true. Then for the next number if the bool is true  and the number is equal to the two previous number give error. make the bool false when the current number is smaller than the previous."
                    }
                ]
            },
            {
                "id": 1875675,
                "content": [
                    {
                        "username": "Numaira-Nawaz",
                        "content": "My third problem on leetcode :)\\nbut it doesn\\'t look easy :("
                    },
                    {
                        "username": "Titret",
                        "content": "Me too I don\\'t find it easy anymore \\n"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes two different solutions:\nhttps://www.youtube.com/watch?v=tsmrUi5M1JU&t=95s"
                    },
                    {
                        "username": "PriyanshuTiwari01",
                        "content": " here\\'s a detailed answer \\n        rom_val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        int_val = 0\\n        for i in range(len(s)):\\n            if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:\\n                int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\\n            else:\\n                int_val += rom_val[s[i]]\\n        return int_val\\n         "
                    },
                    {
                        "username": "Ramachandra22",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni)  We have already added the number we want to subtract in the previous step(iteration) so we subtract it twice .  I hope it answers"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi I almost came up with the same solution by only missing the `2 * rom_val[s[i-1]`, can you please explain why I have to multiply while subtracting?"
                    },
                    {
                        "username": "meggaspy",
                        "content": "ofc you post the awnser "
                    },
                    {
                        "username": "siva-sagar",
                        "content": "can you explain how did you come up with this logic ?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/\\n"
                    },
                    {
                        "username": "prince73757",
                        "content": "To convert a Roman numeral string to an integer, you can use the following approach:\\n\\n1. Initialize a variable result to store the final integer value.\\nCreate a map that associates each Roman numeral symbol with its corresponding value.\\n2. Iterate through the Roman numeral string from left to right.\\n3. If the current Roman numeral symbol is less than the next symbol, subtract its value from the result.\\nOtherwise, add its value to the result.\\n4. Return the final value stored in result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nice tip"
                    },
                    {
                        "username": "ilirnikolli8",
                        "content": "Times new roma"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i struggled a lot to solve this  one \\uD83D\\uDE14"
                    },
                    {
                        "username": "tami_cp0",
                        "content": "I\\'m so confused at what i\\'m looking at tbh :("
                    },
                    {
                        "username": "Pruss",
                        "content": "A lot of solutions get the tests succeed, but are wrong according to the rules. They just check if a preceeding letter is lower than its successor, and then subtract predecesssor from successor.\\ni.e. \"VX\" is 15 and not 5. You should add more test cases to get a better coverage.  "
                    },
                    {
                        "username": "user8594ir",
                        "content": "No, you\\'re getting the rules wrong, VX is not valid, and 15 is represented as XV."
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int sum = 0;\\n        s = s.replace(\"IV\",\"IIII\");\\n        s = s.replace(\"IX\",\"VIIII\");\\n        s = s.replace(\"XL\",\"XXXX\");\\n        s = s.replace(\"XC\",\"LXXXX\");\\n        s = s.replace(\"CD\",\"CCCC\");\\n        s = s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch ==\\'I\\'){\\n                sum = sum + 1;\\n            }\\n            else if(ch == \\'V\\'){\\n                sum = sum + 5;\\n            }\\n            else if(ch == \\'X\\'){\\n                sum = sum + 10;\\n            }\\n            else if (ch == \\'L\\'){\\n                sum = sum + 50;\\n            }\\n            else if (ch == \\'C\\'){\\n                sum = sum + 100;\\n            }\\n            else if (ch == \\'D\\'){\\n                sum = sum + 500;\\n            }\\n            else if (ch == \\'M\\'){\\n                sum = sum + 1000;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "GeX2016",
                        "content": "IVI = 5 but it is not a Roman number because V already exist. Yes LeetCode catches this, but I am interested on how you would code this manually? How many total similarities are there? LMK, TIA. :)"
                    },
                    {
                        "username": "SusAmogus",
                        "content": "for that specific case  its is easy. Simply if the current number is bigger than the previous make a bool true. Then for the next number if the bool is true  and the number is equal to the two previous number give error. make the bool false when the current number is smaller than the previous."
                    }
                ]
            },
            {
                "id": 1796788,
                "content": [
                    {
                        "username": "Numaira-Nawaz",
                        "content": "My third problem on leetcode :)\\nbut it doesn\\'t look easy :("
                    },
                    {
                        "username": "Titret",
                        "content": "Me too I don\\'t find it easy anymore \\n"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes two different solutions:\nhttps://www.youtube.com/watch?v=tsmrUi5M1JU&t=95s"
                    },
                    {
                        "username": "PriyanshuTiwari01",
                        "content": " here\\'s a detailed answer \\n        rom_val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        int_val = 0\\n        for i in range(len(s)):\\n            if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:\\n                int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\\n            else:\\n                int_val += rom_val[s[i]]\\n        return int_val\\n         "
                    },
                    {
                        "username": "Ramachandra22",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni)  We have already added the number we want to subtract in the previous step(iteration) so we subtract it twice .  I hope it answers"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi I almost came up with the same solution by only missing the `2 * rom_val[s[i-1]`, can you please explain why I have to multiply while subtracting?"
                    },
                    {
                        "username": "meggaspy",
                        "content": "ofc you post the awnser "
                    },
                    {
                        "username": "siva-sagar",
                        "content": "can you explain how did you come up with this logic ?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/\\n"
                    },
                    {
                        "username": "prince73757",
                        "content": "To convert a Roman numeral string to an integer, you can use the following approach:\\n\\n1. Initialize a variable result to store the final integer value.\\nCreate a map that associates each Roman numeral symbol with its corresponding value.\\n2. Iterate through the Roman numeral string from left to right.\\n3. If the current Roman numeral symbol is less than the next symbol, subtract its value from the result.\\nOtherwise, add its value to the result.\\n4. Return the final value stored in result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nice tip"
                    },
                    {
                        "username": "ilirnikolli8",
                        "content": "Times new roma"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i struggled a lot to solve this  one \\uD83D\\uDE14"
                    },
                    {
                        "username": "tami_cp0",
                        "content": "I\\'m so confused at what i\\'m looking at tbh :("
                    },
                    {
                        "username": "Pruss",
                        "content": "A lot of solutions get the tests succeed, but are wrong according to the rules. They just check if a preceeding letter is lower than its successor, and then subtract predecesssor from successor.\\ni.e. \"VX\" is 15 and not 5. You should add more test cases to get a better coverage.  "
                    },
                    {
                        "username": "user8594ir",
                        "content": "No, you\\'re getting the rules wrong, VX is not valid, and 15 is represented as XV."
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int sum = 0;\\n        s = s.replace(\"IV\",\"IIII\");\\n        s = s.replace(\"IX\",\"VIIII\");\\n        s = s.replace(\"XL\",\"XXXX\");\\n        s = s.replace(\"XC\",\"LXXXX\");\\n        s = s.replace(\"CD\",\"CCCC\");\\n        s = s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch ==\\'I\\'){\\n                sum = sum + 1;\\n            }\\n            else if(ch == \\'V\\'){\\n                sum = sum + 5;\\n            }\\n            else if(ch == \\'X\\'){\\n                sum = sum + 10;\\n            }\\n            else if (ch == \\'L\\'){\\n                sum = sum + 50;\\n            }\\n            else if (ch == \\'C\\'){\\n                sum = sum + 100;\\n            }\\n            else if (ch == \\'D\\'){\\n                sum = sum + 500;\\n            }\\n            else if (ch == \\'M\\'){\\n                sum = sum + 1000;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "GeX2016",
                        "content": "IVI = 5 but it is not a Roman number because V already exist. Yes LeetCode catches this, but I am interested on how you would code this manually? How many total similarities are there? LMK, TIA. :)"
                    },
                    {
                        "username": "SusAmogus",
                        "content": "for that specific case  its is easy. Simply if the current number is bigger than the previous make a bool true. Then for the next number if the bool is true  and the number is equal to the two previous number give error. make the bool false when the current number is smaller than the previous."
                    }
                ]
            },
            {
                "id": 1568764,
                "content": [
                    {
                        "username": "Numaira-Nawaz",
                        "content": "My third problem on leetcode :)\\nbut it doesn\\'t look easy :("
                    },
                    {
                        "username": "Titret",
                        "content": "Me too I don\\'t find it easy anymore \\n"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes two different solutions:\nhttps://www.youtube.com/watch?v=tsmrUi5M1JU&t=95s"
                    },
                    {
                        "username": "PriyanshuTiwari01",
                        "content": " here\\'s a detailed answer \\n        rom_val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        int_val = 0\\n        for i in range(len(s)):\\n            if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:\\n                int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\\n            else:\\n                int_val += rom_val[s[i]]\\n        return int_val\\n         "
                    },
                    {
                        "username": "Ramachandra22",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni)  We have already added the number we want to subtract in the previous step(iteration) so we subtract it twice .  I hope it answers"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi I almost came up with the same solution by only missing the `2 * rom_val[s[i-1]`, can you please explain why I have to multiply while subtracting?"
                    },
                    {
                        "username": "meggaspy",
                        "content": "ofc you post the awnser "
                    },
                    {
                        "username": "siva-sagar",
                        "content": "can you explain how did you come up with this logic ?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/\\n"
                    },
                    {
                        "username": "prince73757",
                        "content": "To convert a Roman numeral string to an integer, you can use the following approach:\\n\\n1. Initialize a variable result to store the final integer value.\\nCreate a map that associates each Roman numeral symbol with its corresponding value.\\n2. Iterate through the Roman numeral string from left to right.\\n3. If the current Roman numeral symbol is less than the next symbol, subtract its value from the result.\\nOtherwise, add its value to the result.\\n4. Return the final value stored in result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nice tip"
                    },
                    {
                        "username": "ilirnikolli8",
                        "content": "Times new roma"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i struggled a lot to solve this  one \\uD83D\\uDE14"
                    },
                    {
                        "username": "tami_cp0",
                        "content": "I\\'m so confused at what i\\'m looking at tbh :("
                    },
                    {
                        "username": "Pruss",
                        "content": "A lot of solutions get the tests succeed, but are wrong according to the rules. They just check if a preceeding letter is lower than its successor, and then subtract predecesssor from successor.\\ni.e. \"VX\" is 15 and not 5. You should add more test cases to get a better coverage.  "
                    },
                    {
                        "username": "user8594ir",
                        "content": "No, you\\'re getting the rules wrong, VX is not valid, and 15 is represented as XV."
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int sum = 0;\\n        s = s.replace(\"IV\",\"IIII\");\\n        s = s.replace(\"IX\",\"VIIII\");\\n        s = s.replace(\"XL\",\"XXXX\");\\n        s = s.replace(\"XC\",\"LXXXX\");\\n        s = s.replace(\"CD\",\"CCCC\");\\n        s = s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch ==\\'I\\'){\\n                sum = sum + 1;\\n            }\\n            else if(ch == \\'V\\'){\\n                sum = sum + 5;\\n            }\\n            else if(ch == \\'X\\'){\\n                sum = sum + 10;\\n            }\\n            else if (ch == \\'L\\'){\\n                sum = sum + 50;\\n            }\\n            else if (ch == \\'C\\'){\\n                sum = sum + 100;\\n            }\\n            else if (ch == \\'D\\'){\\n                sum = sum + 500;\\n            }\\n            else if (ch == \\'M\\'){\\n                sum = sum + 1000;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "GeX2016",
                        "content": "IVI = 5 but it is not a Roman number because V already exist. Yes LeetCode catches this, but I am interested on how you would code this manually? How many total similarities are there? LMK, TIA. :)"
                    },
                    {
                        "username": "SusAmogus",
                        "content": "for that specific case  its is easy. Simply if the current number is bigger than the previous make a bool true. Then for the next number if the bool is true  and the number is equal to the two previous number give error. make the bool false when the current number is smaller than the previous."
                    }
                ]
            },
            {
                "id": 1949049,
                "content": [
                    {
                        "username": "Numaira-Nawaz",
                        "content": "My third problem on leetcode :)\\nbut it doesn\\'t look easy :("
                    },
                    {
                        "username": "Titret",
                        "content": "Me too I don\\'t find it easy anymore \\n"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes two different solutions:\nhttps://www.youtube.com/watch?v=tsmrUi5M1JU&t=95s"
                    },
                    {
                        "username": "PriyanshuTiwari01",
                        "content": " here\\'s a detailed answer \\n        rom_val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        int_val = 0\\n        for i in range(len(s)):\\n            if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:\\n                int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\\n            else:\\n                int_val += rom_val[s[i]]\\n        return int_val\\n         "
                    },
                    {
                        "username": "Ramachandra22",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni)  We have already added the number we want to subtract in the previous step(iteration) so we subtract it twice .  I hope it answers"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi I almost came up with the same solution by only missing the `2 * rom_val[s[i-1]`, can you please explain why I have to multiply while subtracting?"
                    },
                    {
                        "username": "meggaspy",
                        "content": "ofc you post the awnser "
                    },
                    {
                        "username": "siva-sagar",
                        "content": "can you explain how did you come up with this logic ?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/\\n"
                    },
                    {
                        "username": "prince73757",
                        "content": "To convert a Roman numeral string to an integer, you can use the following approach:\\n\\n1. Initialize a variable result to store the final integer value.\\nCreate a map that associates each Roman numeral symbol with its corresponding value.\\n2. Iterate through the Roman numeral string from left to right.\\n3. If the current Roman numeral symbol is less than the next symbol, subtract its value from the result.\\nOtherwise, add its value to the result.\\n4. Return the final value stored in result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nice tip"
                    },
                    {
                        "username": "ilirnikolli8",
                        "content": "Times new roma"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i struggled a lot to solve this  one \\uD83D\\uDE14"
                    },
                    {
                        "username": "tami_cp0",
                        "content": "I\\'m so confused at what i\\'m looking at tbh :("
                    },
                    {
                        "username": "Pruss",
                        "content": "A lot of solutions get the tests succeed, but are wrong according to the rules. They just check if a preceeding letter is lower than its successor, and then subtract predecesssor from successor.\\ni.e. \"VX\" is 15 and not 5. You should add more test cases to get a better coverage.  "
                    },
                    {
                        "username": "user8594ir",
                        "content": "No, you\\'re getting the rules wrong, VX is not valid, and 15 is represented as XV."
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int sum = 0;\\n        s = s.replace(\"IV\",\"IIII\");\\n        s = s.replace(\"IX\",\"VIIII\");\\n        s = s.replace(\"XL\",\"XXXX\");\\n        s = s.replace(\"XC\",\"LXXXX\");\\n        s = s.replace(\"CD\",\"CCCC\");\\n        s = s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch ==\\'I\\'){\\n                sum = sum + 1;\\n            }\\n            else if(ch == \\'V\\'){\\n                sum = sum + 5;\\n            }\\n            else if(ch == \\'X\\'){\\n                sum = sum + 10;\\n            }\\n            else if (ch == \\'L\\'){\\n                sum = sum + 50;\\n            }\\n            else if (ch == \\'C\\'){\\n                sum = sum + 100;\\n            }\\n            else if (ch == \\'D\\'){\\n                sum = sum + 500;\\n            }\\n            else if (ch == \\'M\\'){\\n                sum = sum + 1000;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "GeX2016",
                        "content": "IVI = 5 but it is not a Roman number because V already exist. Yes LeetCode catches this, but I am interested on how you would code this manually? How many total similarities are there? LMK, TIA. :)"
                    },
                    {
                        "username": "SusAmogus",
                        "content": "for that specific case  its is easy. Simply if the current number is bigger than the previous make a bool true. Then for the next number if the bool is true  and the number is equal to the two previous number give error. make the bool false when the current number is smaller than the previous."
                    }
                ]
            },
            {
                "id": 1867524,
                "content": [
                    {
                        "username": "Numaira-Nawaz",
                        "content": "My third problem on leetcode :)\\nbut it doesn\\'t look easy :("
                    },
                    {
                        "username": "Titret",
                        "content": "Me too I don\\'t find it easy anymore \\n"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes two different solutions:\nhttps://www.youtube.com/watch?v=tsmrUi5M1JU&t=95s"
                    },
                    {
                        "username": "PriyanshuTiwari01",
                        "content": " here\\'s a detailed answer \\n        rom_val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        int_val = 0\\n        for i in range(len(s)):\\n            if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:\\n                int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\\n            else:\\n                int_val += rom_val[s[i]]\\n        return int_val\\n         "
                    },
                    {
                        "username": "Ramachandra22",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni)  We have already added the number we want to subtract in the previous step(iteration) so we subtract it twice .  I hope it answers"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi I almost came up with the same solution by only missing the `2 * rom_val[s[i-1]`, can you please explain why I have to multiply while subtracting?"
                    },
                    {
                        "username": "meggaspy",
                        "content": "ofc you post the awnser "
                    },
                    {
                        "username": "siva-sagar",
                        "content": "can you explain how did you come up with this logic ?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/\\n"
                    },
                    {
                        "username": "prince73757",
                        "content": "To convert a Roman numeral string to an integer, you can use the following approach:\\n\\n1. Initialize a variable result to store the final integer value.\\nCreate a map that associates each Roman numeral symbol with its corresponding value.\\n2. Iterate through the Roman numeral string from left to right.\\n3. If the current Roman numeral symbol is less than the next symbol, subtract its value from the result.\\nOtherwise, add its value to the result.\\n4. Return the final value stored in result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nice tip"
                    },
                    {
                        "username": "ilirnikolli8",
                        "content": "Times new roma"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i struggled a lot to solve this  one \\uD83D\\uDE14"
                    },
                    {
                        "username": "tami_cp0",
                        "content": "I\\'m so confused at what i\\'m looking at tbh :("
                    },
                    {
                        "username": "Pruss",
                        "content": "A lot of solutions get the tests succeed, but are wrong according to the rules. They just check if a preceeding letter is lower than its successor, and then subtract predecesssor from successor.\\ni.e. \"VX\" is 15 and not 5. You should add more test cases to get a better coverage.  "
                    },
                    {
                        "username": "user8594ir",
                        "content": "No, you\\'re getting the rules wrong, VX is not valid, and 15 is represented as XV."
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int sum = 0;\\n        s = s.replace(\"IV\",\"IIII\");\\n        s = s.replace(\"IX\",\"VIIII\");\\n        s = s.replace(\"XL\",\"XXXX\");\\n        s = s.replace(\"XC\",\"LXXXX\");\\n        s = s.replace(\"CD\",\"CCCC\");\\n        s = s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch ==\\'I\\'){\\n                sum = sum + 1;\\n            }\\n            else if(ch == \\'V\\'){\\n                sum = sum + 5;\\n            }\\n            else if(ch == \\'X\\'){\\n                sum = sum + 10;\\n            }\\n            else if (ch == \\'L\\'){\\n                sum = sum + 50;\\n            }\\n            else if (ch == \\'C\\'){\\n                sum = sum + 100;\\n            }\\n            else if (ch == \\'D\\'){\\n                sum = sum + 500;\\n            }\\n            else if (ch == \\'M\\'){\\n                sum = sum + 1000;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "GeX2016",
                        "content": "IVI = 5 but it is not a Roman number because V already exist. Yes LeetCode catches this, but I am interested on how you would code this manually? How many total similarities are there? LMK, TIA. :)"
                    },
                    {
                        "username": "SusAmogus",
                        "content": "for that specific case  its is easy. Simply if the current number is bigger than the previous make a bool true. Then for the next number if the bool is true  and the number is equal to the two previous number give error. make the bool false when the current number is smaller than the previous."
                    }
                ]
            },
            {
                "id": 1864039,
                "content": [
                    {
                        "username": "Numaira-Nawaz",
                        "content": "My third problem on leetcode :)\\nbut it doesn\\'t look easy :("
                    },
                    {
                        "username": "Titret",
                        "content": "Me too I don\\'t find it easy anymore \\n"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes two different solutions:\nhttps://www.youtube.com/watch?v=tsmrUi5M1JU&t=95s"
                    },
                    {
                        "username": "PriyanshuTiwari01",
                        "content": " here\\'s a detailed answer \\n        rom_val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        int_val = 0\\n        for i in range(len(s)):\\n            if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:\\n                int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\\n            else:\\n                int_val += rom_val[s[i]]\\n        return int_val\\n         "
                    },
                    {
                        "username": "Ramachandra22",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni)  We have already added the number we want to subtract in the previous step(iteration) so we subtract it twice .  I hope it answers"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi I almost came up with the same solution by only missing the `2 * rom_val[s[i-1]`, can you please explain why I have to multiply while subtracting?"
                    },
                    {
                        "username": "meggaspy",
                        "content": "ofc you post the awnser "
                    },
                    {
                        "username": "siva-sagar",
                        "content": "can you explain how did you come up with this logic ?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/\\n"
                    },
                    {
                        "username": "prince73757",
                        "content": "To convert a Roman numeral string to an integer, you can use the following approach:\\n\\n1. Initialize a variable result to store the final integer value.\\nCreate a map that associates each Roman numeral symbol with its corresponding value.\\n2. Iterate through the Roman numeral string from left to right.\\n3. If the current Roman numeral symbol is less than the next symbol, subtract its value from the result.\\nOtherwise, add its value to the result.\\n4. Return the final value stored in result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nice tip"
                    },
                    {
                        "username": "ilirnikolli8",
                        "content": "Times new roma"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i struggled a lot to solve this  one \\uD83D\\uDE14"
                    },
                    {
                        "username": "tami_cp0",
                        "content": "I\\'m so confused at what i\\'m looking at tbh :("
                    },
                    {
                        "username": "Pruss",
                        "content": "A lot of solutions get the tests succeed, but are wrong according to the rules. They just check if a preceeding letter is lower than its successor, and then subtract predecesssor from successor.\\ni.e. \"VX\" is 15 and not 5. You should add more test cases to get a better coverage.  "
                    },
                    {
                        "username": "user8594ir",
                        "content": "No, you\\'re getting the rules wrong, VX is not valid, and 15 is represented as XV."
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int sum = 0;\\n        s = s.replace(\"IV\",\"IIII\");\\n        s = s.replace(\"IX\",\"VIIII\");\\n        s = s.replace(\"XL\",\"XXXX\");\\n        s = s.replace(\"XC\",\"LXXXX\");\\n        s = s.replace(\"CD\",\"CCCC\");\\n        s = s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch ==\\'I\\'){\\n                sum = sum + 1;\\n            }\\n            else if(ch == \\'V\\'){\\n                sum = sum + 5;\\n            }\\n            else if(ch == \\'X\\'){\\n                sum = sum + 10;\\n            }\\n            else if (ch == \\'L\\'){\\n                sum = sum + 50;\\n            }\\n            else if (ch == \\'C\\'){\\n                sum = sum + 100;\\n            }\\n            else if (ch == \\'D\\'){\\n                sum = sum + 500;\\n            }\\n            else if (ch == \\'M\\'){\\n                sum = sum + 1000;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "GeX2016",
                        "content": "IVI = 5 but it is not a Roman number because V already exist. Yes LeetCode catches this, but I am interested on how you would code this manually? How many total similarities are there? LMK, TIA. :)"
                    },
                    {
                        "username": "SusAmogus",
                        "content": "for that specific case  its is easy. Simply if the current number is bigger than the previous make a bool true. Then for the next number if the bool is true  and the number is equal to the two previous number give error. make the bool false when the current number is smaller than the previous."
                    }
                ]
            },
            {
                "id": 1790390,
                "content": [
                    {
                        "username": "Numaira-Nawaz",
                        "content": "My third problem on leetcode :)\\nbut it doesn\\'t look easy :("
                    },
                    {
                        "username": "Titret",
                        "content": "Me too I don\\'t find it easy anymore \\n"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes two different solutions:\nhttps://www.youtube.com/watch?v=tsmrUi5M1JU&t=95s"
                    },
                    {
                        "username": "PriyanshuTiwari01",
                        "content": " here\\'s a detailed answer \\n        rom_val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        int_val = 0\\n        for i in range(len(s)):\\n            if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:\\n                int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\\n            else:\\n                int_val += rom_val[s[i]]\\n        return int_val\\n         "
                    },
                    {
                        "username": "Ramachandra22",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni)  We have already added the number we want to subtract in the previous step(iteration) so we subtract it twice .  I hope it answers"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi I almost came up with the same solution by only missing the `2 * rom_val[s[i-1]`, can you please explain why I have to multiply while subtracting?"
                    },
                    {
                        "username": "meggaspy",
                        "content": "ofc you post the awnser "
                    },
                    {
                        "username": "siva-sagar",
                        "content": "can you explain how did you come up with this logic ?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/\\n"
                    },
                    {
                        "username": "prince73757",
                        "content": "To convert a Roman numeral string to an integer, you can use the following approach:\\n\\n1. Initialize a variable result to store the final integer value.\\nCreate a map that associates each Roman numeral symbol with its corresponding value.\\n2. Iterate through the Roman numeral string from left to right.\\n3. If the current Roman numeral symbol is less than the next symbol, subtract its value from the result.\\nOtherwise, add its value to the result.\\n4. Return the final value stored in result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nice tip"
                    },
                    {
                        "username": "ilirnikolli8",
                        "content": "Times new roma"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i struggled a lot to solve this  one \\uD83D\\uDE14"
                    },
                    {
                        "username": "tami_cp0",
                        "content": "I\\'m so confused at what i\\'m looking at tbh :("
                    },
                    {
                        "username": "Pruss",
                        "content": "A lot of solutions get the tests succeed, but are wrong according to the rules. They just check if a preceeding letter is lower than its successor, and then subtract predecesssor from successor.\\ni.e. \"VX\" is 15 and not 5. You should add more test cases to get a better coverage.  "
                    },
                    {
                        "username": "user8594ir",
                        "content": "No, you\\'re getting the rules wrong, VX is not valid, and 15 is represented as XV."
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int sum = 0;\\n        s = s.replace(\"IV\",\"IIII\");\\n        s = s.replace(\"IX\",\"VIIII\");\\n        s = s.replace(\"XL\",\"XXXX\");\\n        s = s.replace(\"XC\",\"LXXXX\");\\n        s = s.replace(\"CD\",\"CCCC\");\\n        s = s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch ==\\'I\\'){\\n                sum = sum + 1;\\n            }\\n            else if(ch == \\'V\\'){\\n                sum = sum + 5;\\n            }\\n            else if(ch == \\'X\\'){\\n                sum = sum + 10;\\n            }\\n            else if (ch == \\'L\\'){\\n                sum = sum + 50;\\n            }\\n            else if (ch == \\'C\\'){\\n                sum = sum + 100;\\n            }\\n            else if (ch == \\'D\\'){\\n                sum = sum + 500;\\n            }\\n            else if (ch == \\'M\\'){\\n                sum = sum + 1000;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "GeX2016",
                        "content": "IVI = 5 but it is not a Roman number because V already exist. Yes LeetCode catches this, but I am interested on how you would code this manually? How many total similarities are there? LMK, TIA. :)"
                    },
                    {
                        "username": "SusAmogus",
                        "content": "for that specific case  its is easy. Simply if the current number is bigger than the previous make a bool true. Then for the next number if the bool is true  and the number is equal to the two previous number give error. make the bool false when the current number is smaller than the previous."
                    }
                ]
            },
            {
                "id": 1787431,
                "content": [
                    {
                        "username": "Numaira-Nawaz",
                        "content": "My third problem on leetcode :)\\nbut it doesn\\'t look easy :("
                    },
                    {
                        "username": "Titret",
                        "content": "Me too I don\\'t find it easy anymore \\n"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes two different solutions:\nhttps://www.youtube.com/watch?v=tsmrUi5M1JU&t=95s"
                    },
                    {
                        "username": "PriyanshuTiwari01",
                        "content": " here\\'s a detailed answer \\n        rom_val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        int_val = 0\\n        for i in range(len(s)):\\n            if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:\\n                int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\\n            else:\\n                int_val += rom_val[s[i]]\\n        return int_val\\n         "
                    },
                    {
                        "username": "Ramachandra22",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni)  We have already added the number we want to subtract in the previous step(iteration) so we subtract it twice .  I hope it answers"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi I almost came up with the same solution by only missing the `2 * rom_val[s[i-1]`, can you please explain why I have to multiply while subtracting?"
                    },
                    {
                        "username": "meggaspy",
                        "content": "ofc you post the awnser "
                    },
                    {
                        "username": "siva-sagar",
                        "content": "can you explain how did you come up with this logic ?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/\\n"
                    },
                    {
                        "username": "prince73757",
                        "content": "To convert a Roman numeral string to an integer, you can use the following approach:\\n\\n1. Initialize a variable result to store the final integer value.\\nCreate a map that associates each Roman numeral symbol with its corresponding value.\\n2. Iterate through the Roman numeral string from left to right.\\n3. If the current Roman numeral symbol is less than the next symbol, subtract its value from the result.\\nOtherwise, add its value to the result.\\n4. Return the final value stored in result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nice tip"
                    },
                    {
                        "username": "ilirnikolli8",
                        "content": "Times new roma"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i struggled a lot to solve this  one \\uD83D\\uDE14"
                    },
                    {
                        "username": "tami_cp0",
                        "content": "I\\'m so confused at what i\\'m looking at tbh :("
                    },
                    {
                        "username": "Pruss",
                        "content": "A lot of solutions get the tests succeed, but are wrong according to the rules. They just check if a preceeding letter is lower than its successor, and then subtract predecesssor from successor.\\ni.e. \"VX\" is 15 and not 5. You should add more test cases to get a better coverage.  "
                    },
                    {
                        "username": "user8594ir",
                        "content": "No, you\\'re getting the rules wrong, VX is not valid, and 15 is represented as XV."
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int sum = 0;\\n        s = s.replace(\"IV\",\"IIII\");\\n        s = s.replace(\"IX\",\"VIIII\");\\n        s = s.replace(\"XL\",\"XXXX\");\\n        s = s.replace(\"XC\",\"LXXXX\");\\n        s = s.replace(\"CD\",\"CCCC\");\\n        s = s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch ==\\'I\\'){\\n                sum = sum + 1;\\n            }\\n            else if(ch == \\'V\\'){\\n                sum = sum + 5;\\n            }\\n            else if(ch == \\'X\\'){\\n                sum = sum + 10;\\n            }\\n            else if (ch == \\'L\\'){\\n                sum = sum + 50;\\n            }\\n            else if (ch == \\'C\\'){\\n                sum = sum + 100;\\n            }\\n            else if (ch == \\'D\\'){\\n                sum = sum + 500;\\n            }\\n            else if (ch == \\'M\\'){\\n                sum = sum + 1000;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "GeX2016",
                        "content": "IVI = 5 but it is not a Roman number because V already exist. Yes LeetCode catches this, but I am interested on how you would code this manually? How many total similarities are there? LMK, TIA. :)"
                    },
                    {
                        "username": "SusAmogus",
                        "content": "for that specific case  its is easy. Simply if the current number is bigger than the previous make a bool true. Then for the next number if the bool is true  and the number is equal to the two previous number give error. make the bool false when the current number is smaller than the previous."
                    }
                ]
            },
            {
                "id": 1761595,
                "content": [
                    {
                        "username": "Numaira-Nawaz",
                        "content": "My third problem on leetcode :)\\nbut it doesn\\'t look easy :("
                    },
                    {
                        "username": "Titret",
                        "content": "Me too I don\\'t find it easy anymore \\n"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes two different solutions:\nhttps://www.youtube.com/watch?v=tsmrUi5M1JU&t=95s"
                    },
                    {
                        "username": "PriyanshuTiwari01",
                        "content": " here\\'s a detailed answer \\n        rom_val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10, \\'L\\': 50, \\'C\\': 100, \\'D\\': 500, \\'M\\': 1000}\\n        int_val = 0\\n        for i in range(len(s)):\\n            if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:\\n                int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\\n            else:\\n                int_val += rom_val[s[i]]\\n        return int_val\\n         "
                    },
                    {
                        "username": "Ramachandra22",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni)  We have already added the number we want to subtract in the previous step(iteration) so we subtract it twice .  I hope it answers"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi I almost came up with the same solution by only missing the `2 * rom_val[s[i-1]`, can you please explain why I have to multiply while subtracting?"
                    },
                    {
                        "username": "meggaspy",
                        "content": "ofc you post the awnser "
                    },
                    {
                        "username": "siva-sagar",
                        "content": "can you explain how did you come up with this logic ?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/\\n"
                    },
                    {
                        "username": "prince73757",
                        "content": "To convert a Roman numeral string to an integer, you can use the following approach:\\n\\n1. Initialize a variable result to store the final integer value.\\nCreate a map that associates each Roman numeral symbol with its corresponding value.\\n2. Iterate through the Roman numeral string from left to right.\\n3. If the current Roman numeral symbol is less than the next symbol, subtract its value from the result.\\nOtherwise, add its value to the result.\\n4. Return the final value stored in result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Nice tip"
                    },
                    {
                        "username": "ilirnikolli8",
                        "content": "Times new roma"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i struggled a lot to solve this  one \\uD83D\\uDE14"
                    },
                    {
                        "username": "tami_cp0",
                        "content": "I\\'m so confused at what i\\'m looking at tbh :("
                    },
                    {
                        "username": "Pruss",
                        "content": "A lot of solutions get the tests succeed, but are wrong according to the rules. They just check if a preceeding letter is lower than its successor, and then subtract predecesssor from successor.\\ni.e. \"VX\" is 15 and not 5. You should add more test cases to get a better coverage.  "
                    },
                    {
                        "username": "user8594ir",
                        "content": "No, you\\'re getting the rules wrong, VX is not valid, and 15 is represented as XV."
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int sum = 0;\\n        s = s.replace(\"IV\",\"IIII\");\\n        s = s.replace(\"IX\",\"VIIII\");\\n        s = s.replace(\"XL\",\"XXXX\");\\n        s = s.replace(\"XC\",\"LXXXX\");\\n        s = s.replace(\"CD\",\"CCCC\");\\n        s = s.replace(\"CM\",\"DCCCC\");\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch ==\\'I\\'){\\n                sum = sum + 1;\\n            }\\n            else if(ch == \\'V\\'){\\n                sum = sum + 5;\\n            }\\n            else if(ch == \\'X\\'){\\n                sum = sum + 10;\\n            }\\n            else if (ch == \\'L\\'){\\n                sum = sum + 50;\\n            }\\n            else if (ch == \\'C\\'){\\n                sum = sum + 100;\\n            }\\n            else if (ch == \\'D\\'){\\n                sum = sum + 500;\\n            }\\n            else if (ch == \\'M\\'){\\n                sum = sum + 1000;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "GeX2016",
                        "content": "IVI = 5 but it is not a Roman number because V already exist. Yes LeetCode catches this, but I am interested on how you would code this manually? How many total similarities are there? LMK, TIA. :)"
                    },
                    {
                        "username": "SusAmogus",
                        "content": "for that specific case  its is easy. Simply if the current number is bigger than the previous make a bool true. Then for the next number if the bool is true  and the number is equal to the two previous number give error. make the bool false when the current number is smaller than the previous."
                    }
                ]
            },
            {
                "id": 1727999,
                "content": [
                    {
                        "username": "eryzml",
                        "content": "I seem to always start by thinking of solutions which require the least amount of typing. So I reached for a reduce method. Then it occurred to me that I\\'m not directly taking action on each letter of the string. Anyway, that was a half hour down the wrong rabbit hole."
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "That\\'s called the optimize solution \\n"
                    },
                    {
                        "username": "Manoj_TM",
                        "content": "Was good for a brain teaser, and it was good for solution finding."
                    },
                    {
                        "username": "giabach1234",
                        "content": "Can someone please help me debug this code. I\\'m getting java.lang.ArrayIndexOutOfBoundsException at the if statement:\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = 0;\\n        \\n        char[] ch = s.toCharArray();\\n        for(int i = 0; i < ch.length; i++){\\n            if(map.get(ch[i]) < map.get(ch[i+1])){\\n                result -= map.get(ch[i]);\\n            }else{\\n                result += map.get(ch[i]);\\n            }\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "sugMag",
                        "content": "when i =ch.length then when the next line executes \" map.get(ch[i+1])){\" there ch[i+1] is out of bounds."
                    },
                    {
                        "username": "Chris99673",
                        "content": "For the if statement, you have to make sure that \"i\" is not the last index of the character array. The reason why you get that exception is because there are instances where the if statement checks that condition where i is the last index, and when it tries to access the i+1\\'s index, it is out of bounds."
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "HINT :  \"IV\"  =  -1 + 5"
                    },
                    {
                        "username": "Levidps",
                        "content": "This is just one way of thinking about it - can be done with keeping all values as positive integers."
                    },
                    {
                        "username": "pd_mishra",
                        "content": "your output is wrong according to this question"
                    },
                    {
                        "username": "HelloHabib",
                        "content": "Tips for C++ coder.......\\n(1) unordered map\\n(2) store last character value (say in t)\\n(3) reverse loop(start from second last)\\n(4) start comparing (b/w last one and second last)\\nright<left\\nsubstruction second last from t\\nelse\\nadd t and second last\\n.\\n.\\n(continue )\\n\\nand return"
                    },
                    {
                        "username": "ghanasyamk79",
                        "content": "I don\\'t quite understand why the frequency of this problem appeared in real interview is so high.\\nI find a little bit nonsense to try to use the less memory and CPU possible."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution (JavaScript version will update shortly).\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/)\\u2B50\\n\\n**I had already test all the code in my blog, so you can be assured !**\\n\\nHere is the Python3 version fastest submission detail\\n![image](https://assets.leetcode.com/users/images/b8be3282-1c50-4b4f-81e9-943a028adca7_1654367257.0549529.jpeg)\\n\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!"
                    },
                    {
                        "username": "EricCapet",
                        "content": "For example, \"DCXXXXI\" is an invalid string which has 4 repeated in succession of \"X\", but the \"expected answer\" still shows 641. Also the expected answer of \"IC\" is wrong, because the correct Roman numeral of 99 should be \"XCIX\"."
                    },
                    {
                        "username": "Sakura1987",
                        "content": "![image](https://assets.leetcode.com/users/sakura1987/image_1551696463.png)\\n"
                    }
                ]
            },
            {
                "id": 1713356,
                "content": [
                    {
                        "username": "eryzml",
                        "content": "I seem to always start by thinking of solutions which require the least amount of typing. So I reached for a reduce method. Then it occurred to me that I\\'m not directly taking action on each letter of the string. Anyway, that was a half hour down the wrong rabbit hole."
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "That\\'s called the optimize solution \\n"
                    },
                    {
                        "username": "Manoj_TM",
                        "content": "Was good for a brain teaser, and it was good for solution finding."
                    },
                    {
                        "username": "giabach1234",
                        "content": "Can someone please help me debug this code. I\\'m getting java.lang.ArrayIndexOutOfBoundsException at the if statement:\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = 0;\\n        \\n        char[] ch = s.toCharArray();\\n        for(int i = 0; i < ch.length; i++){\\n            if(map.get(ch[i]) < map.get(ch[i+1])){\\n                result -= map.get(ch[i]);\\n            }else{\\n                result += map.get(ch[i]);\\n            }\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "sugMag",
                        "content": "when i =ch.length then when the next line executes \" map.get(ch[i+1])){\" there ch[i+1] is out of bounds."
                    },
                    {
                        "username": "Chris99673",
                        "content": "For the if statement, you have to make sure that \"i\" is not the last index of the character array. The reason why you get that exception is because there are instances where the if statement checks that condition where i is the last index, and when it tries to access the i+1\\'s index, it is out of bounds."
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "HINT :  \"IV\"  =  -1 + 5"
                    },
                    {
                        "username": "Levidps",
                        "content": "This is just one way of thinking about it - can be done with keeping all values as positive integers."
                    },
                    {
                        "username": "pd_mishra",
                        "content": "your output is wrong according to this question"
                    },
                    {
                        "username": "HelloHabib",
                        "content": "Tips for C++ coder.......\\n(1) unordered map\\n(2) store last character value (say in t)\\n(3) reverse loop(start from second last)\\n(4) start comparing (b/w last one and second last)\\nright<left\\nsubstruction second last from t\\nelse\\nadd t and second last\\n.\\n.\\n(continue )\\n\\nand return"
                    },
                    {
                        "username": "ghanasyamk79",
                        "content": "I don\\'t quite understand why the frequency of this problem appeared in real interview is so high.\\nI find a little bit nonsense to try to use the less memory and CPU possible."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution (JavaScript version will update shortly).\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/)\\u2B50\\n\\n**I had already test all the code in my blog, so you can be assured !**\\n\\nHere is the Python3 version fastest submission detail\\n![image](https://assets.leetcode.com/users/images/b8be3282-1c50-4b4f-81e9-943a028adca7_1654367257.0549529.jpeg)\\n\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!"
                    },
                    {
                        "username": "EricCapet",
                        "content": "For example, \"DCXXXXI\" is an invalid string which has 4 repeated in succession of \"X\", but the \"expected answer\" still shows 641. Also the expected answer of \"IC\" is wrong, because the correct Roman numeral of 99 should be \"XCIX\"."
                    },
                    {
                        "username": "Sakura1987",
                        "content": "![image](https://assets.leetcode.com/users/sakura1987/image_1551696463.png)\\n"
                    }
                ]
            },
            {
                "id": 1948706,
                "content": [
                    {
                        "username": "eryzml",
                        "content": "I seem to always start by thinking of solutions which require the least amount of typing. So I reached for a reduce method. Then it occurred to me that I\\'m not directly taking action on each letter of the string. Anyway, that was a half hour down the wrong rabbit hole."
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "That\\'s called the optimize solution \\n"
                    },
                    {
                        "username": "Manoj_TM",
                        "content": "Was good for a brain teaser, and it was good for solution finding."
                    },
                    {
                        "username": "giabach1234",
                        "content": "Can someone please help me debug this code. I\\'m getting java.lang.ArrayIndexOutOfBoundsException at the if statement:\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = 0;\\n        \\n        char[] ch = s.toCharArray();\\n        for(int i = 0; i < ch.length; i++){\\n            if(map.get(ch[i]) < map.get(ch[i+1])){\\n                result -= map.get(ch[i]);\\n            }else{\\n                result += map.get(ch[i]);\\n            }\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "sugMag",
                        "content": "when i =ch.length then when the next line executes \" map.get(ch[i+1])){\" there ch[i+1] is out of bounds."
                    },
                    {
                        "username": "Chris99673",
                        "content": "For the if statement, you have to make sure that \"i\" is not the last index of the character array. The reason why you get that exception is because there are instances where the if statement checks that condition where i is the last index, and when it tries to access the i+1\\'s index, it is out of bounds."
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "HINT :  \"IV\"  =  -1 + 5"
                    },
                    {
                        "username": "Levidps",
                        "content": "This is just one way of thinking about it - can be done with keeping all values as positive integers."
                    },
                    {
                        "username": "pd_mishra",
                        "content": "your output is wrong according to this question"
                    },
                    {
                        "username": "HelloHabib",
                        "content": "Tips for C++ coder.......\\n(1) unordered map\\n(2) store last character value (say in t)\\n(3) reverse loop(start from second last)\\n(4) start comparing (b/w last one and second last)\\nright<left\\nsubstruction second last from t\\nelse\\nadd t and second last\\n.\\n.\\n(continue )\\n\\nand return"
                    },
                    {
                        "username": "ghanasyamk79",
                        "content": "I don\\'t quite understand why the frequency of this problem appeared in real interview is so high.\\nI find a little bit nonsense to try to use the less memory and CPU possible."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution (JavaScript version will update shortly).\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/)\\u2B50\\n\\n**I had already test all the code in my blog, so you can be assured !**\\n\\nHere is the Python3 version fastest submission detail\\n![image](https://assets.leetcode.com/users/images/b8be3282-1c50-4b4f-81e9-943a028adca7_1654367257.0549529.jpeg)\\n\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!"
                    },
                    {
                        "username": "EricCapet",
                        "content": "For example, \"DCXXXXI\" is an invalid string which has 4 repeated in succession of \"X\", but the \"expected answer\" still shows 641. Also the expected answer of \"IC\" is wrong, because the correct Roman numeral of 99 should be \"XCIX\"."
                    },
                    {
                        "username": "Sakura1987",
                        "content": "![image](https://assets.leetcode.com/users/sakura1987/image_1551696463.png)\\n"
                    }
                ]
            },
            {
                "id": 1900066,
                "content": [
                    {
                        "username": "eryzml",
                        "content": "I seem to always start by thinking of solutions which require the least amount of typing. So I reached for a reduce method. Then it occurred to me that I\\'m not directly taking action on each letter of the string. Anyway, that was a half hour down the wrong rabbit hole."
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "That\\'s called the optimize solution \\n"
                    },
                    {
                        "username": "Manoj_TM",
                        "content": "Was good for a brain teaser, and it was good for solution finding."
                    },
                    {
                        "username": "giabach1234",
                        "content": "Can someone please help me debug this code. I\\'m getting java.lang.ArrayIndexOutOfBoundsException at the if statement:\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = 0;\\n        \\n        char[] ch = s.toCharArray();\\n        for(int i = 0; i < ch.length; i++){\\n            if(map.get(ch[i]) < map.get(ch[i+1])){\\n                result -= map.get(ch[i]);\\n            }else{\\n                result += map.get(ch[i]);\\n            }\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "sugMag",
                        "content": "when i =ch.length then when the next line executes \" map.get(ch[i+1])){\" there ch[i+1] is out of bounds."
                    },
                    {
                        "username": "Chris99673",
                        "content": "For the if statement, you have to make sure that \"i\" is not the last index of the character array. The reason why you get that exception is because there are instances where the if statement checks that condition where i is the last index, and when it tries to access the i+1\\'s index, it is out of bounds."
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "HINT :  \"IV\"  =  -1 + 5"
                    },
                    {
                        "username": "Levidps",
                        "content": "This is just one way of thinking about it - can be done with keeping all values as positive integers."
                    },
                    {
                        "username": "pd_mishra",
                        "content": "your output is wrong according to this question"
                    },
                    {
                        "username": "HelloHabib",
                        "content": "Tips for C++ coder.......\\n(1) unordered map\\n(2) store last character value (say in t)\\n(3) reverse loop(start from second last)\\n(4) start comparing (b/w last one and second last)\\nright<left\\nsubstruction second last from t\\nelse\\nadd t and second last\\n.\\n.\\n(continue )\\n\\nand return"
                    },
                    {
                        "username": "ghanasyamk79",
                        "content": "I don\\'t quite understand why the frequency of this problem appeared in real interview is so high.\\nI find a little bit nonsense to try to use the less memory and CPU possible."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution (JavaScript version will update shortly).\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/)\\u2B50\\n\\n**I had already test all the code in my blog, so you can be assured !**\\n\\nHere is the Python3 version fastest submission detail\\n![image](https://assets.leetcode.com/users/images/b8be3282-1c50-4b4f-81e9-943a028adca7_1654367257.0549529.jpeg)\\n\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!"
                    },
                    {
                        "username": "EricCapet",
                        "content": "For example, \"DCXXXXI\" is an invalid string which has 4 repeated in succession of \"X\", but the \"expected answer\" still shows 641. Also the expected answer of \"IC\" is wrong, because the correct Roman numeral of 99 should be \"XCIX\"."
                    },
                    {
                        "username": "Sakura1987",
                        "content": "![image](https://assets.leetcode.com/users/sakura1987/image_1551696463.png)\\n"
                    }
                ]
            },
            {
                "id": 1754050,
                "content": [
                    {
                        "username": "eryzml",
                        "content": "I seem to always start by thinking of solutions which require the least amount of typing. So I reached for a reduce method. Then it occurred to me that I\\'m not directly taking action on each letter of the string. Anyway, that was a half hour down the wrong rabbit hole."
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "That\\'s called the optimize solution \\n"
                    },
                    {
                        "username": "Manoj_TM",
                        "content": "Was good for a brain teaser, and it was good for solution finding."
                    },
                    {
                        "username": "giabach1234",
                        "content": "Can someone please help me debug this code. I\\'m getting java.lang.ArrayIndexOutOfBoundsException at the if statement:\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = 0;\\n        \\n        char[] ch = s.toCharArray();\\n        for(int i = 0; i < ch.length; i++){\\n            if(map.get(ch[i]) < map.get(ch[i+1])){\\n                result -= map.get(ch[i]);\\n            }else{\\n                result += map.get(ch[i]);\\n            }\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "sugMag",
                        "content": "when i =ch.length then when the next line executes \" map.get(ch[i+1])){\" there ch[i+1] is out of bounds."
                    },
                    {
                        "username": "Chris99673",
                        "content": "For the if statement, you have to make sure that \"i\" is not the last index of the character array. The reason why you get that exception is because there are instances where the if statement checks that condition where i is the last index, and when it tries to access the i+1\\'s index, it is out of bounds."
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "HINT :  \"IV\"  =  -1 + 5"
                    },
                    {
                        "username": "Levidps",
                        "content": "This is just one way of thinking about it - can be done with keeping all values as positive integers."
                    },
                    {
                        "username": "pd_mishra",
                        "content": "your output is wrong according to this question"
                    },
                    {
                        "username": "HelloHabib",
                        "content": "Tips for C++ coder.......\\n(1) unordered map\\n(2) store last character value (say in t)\\n(3) reverse loop(start from second last)\\n(4) start comparing (b/w last one and second last)\\nright<left\\nsubstruction second last from t\\nelse\\nadd t and second last\\n.\\n.\\n(continue )\\n\\nand return"
                    },
                    {
                        "username": "ghanasyamk79",
                        "content": "I don\\'t quite understand why the frequency of this problem appeared in real interview is so high.\\nI find a little bit nonsense to try to use the less memory and CPU possible."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution (JavaScript version will update shortly).\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/)\\u2B50\\n\\n**I had already test all the code in my blog, so you can be assured !**\\n\\nHere is the Python3 version fastest submission detail\\n![image](https://assets.leetcode.com/users/images/b8be3282-1c50-4b4f-81e9-943a028adca7_1654367257.0549529.jpeg)\\n\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!"
                    },
                    {
                        "username": "EricCapet",
                        "content": "For example, \"DCXXXXI\" is an invalid string which has 4 repeated in succession of \"X\", but the \"expected answer\" still shows 641. Also the expected answer of \"IC\" is wrong, because the correct Roman numeral of 99 should be \"XCIX\"."
                    },
                    {
                        "username": "Sakura1987",
                        "content": "![image](https://assets.leetcode.com/users/sakura1987/image_1551696463.png)\\n"
                    }
                ]
            },
            {
                "id": 1749816,
                "content": [
                    {
                        "username": "eryzml",
                        "content": "I seem to always start by thinking of solutions which require the least amount of typing. So I reached for a reduce method. Then it occurred to me that I\\'m not directly taking action on each letter of the string. Anyway, that was a half hour down the wrong rabbit hole."
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "That\\'s called the optimize solution \\n"
                    },
                    {
                        "username": "Manoj_TM",
                        "content": "Was good for a brain teaser, and it was good for solution finding."
                    },
                    {
                        "username": "giabach1234",
                        "content": "Can someone please help me debug this code. I\\'m getting java.lang.ArrayIndexOutOfBoundsException at the if statement:\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = 0;\\n        \\n        char[] ch = s.toCharArray();\\n        for(int i = 0; i < ch.length; i++){\\n            if(map.get(ch[i]) < map.get(ch[i+1])){\\n                result -= map.get(ch[i]);\\n            }else{\\n                result += map.get(ch[i]);\\n            }\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "sugMag",
                        "content": "when i =ch.length then when the next line executes \" map.get(ch[i+1])){\" there ch[i+1] is out of bounds."
                    },
                    {
                        "username": "Chris99673",
                        "content": "For the if statement, you have to make sure that \"i\" is not the last index of the character array. The reason why you get that exception is because there are instances where the if statement checks that condition where i is the last index, and when it tries to access the i+1\\'s index, it is out of bounds."
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "HINT :  \"IV\"  =  -1 + 5"
                    },
                    {
                        "username": "Levidps",
                        "content": "This is just one way of thinking about it - can be done with keeping all values as positive integers."
                    },
                    {
                        "username": "pd_mishra",
                        "content": "your output is wrong according to this question"
                    },
                    {
                        "username": "HelloHabib",
                        "content": "Tips for C++ coder.......\\n(1) unordered map\\n(2) store last character value (say in t)\\n(3) reverse loop(start from second last)\\n(4) start comparing (b/w last one and second last)\\nright<left\\nsubstruction second last from t\\nelse\\nadd t and second last\\n.\\n.\\n(continue )\\n\\nand return"
                    },
                    {
                        "username": "ghanasyamk79",
                        "content": "I don\\'t quite understand why the frequency of this problem appeared in real interview is so high.\\nI find a little bit nonsense to try to use the less memory and CPU possible."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution (JavaScript version will update shortly).\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/)\\u2B50\\n\\n**I had already test all the code in my blog, so you can be assured !**\\n\\nHere is the Python3 version fastest submission detail\\n![image](https://assets.leetcode.com/users/images/b8be3282-1c50-4b4f-81e9-943a028adca7_1654367257.0549529.jpeg)\\n\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!"
                    },
                    {
                        "username": "EricCapet",
                        "content": "For example, \"DCXXXXI\" is an invalid string which has 4 repeated in succession of \"X\", but the \"expected answer\" still shows 641. Also the expected answer of \"IC\" is wrong, because the correct Roman numeral of 99 should be \"XCIX\"."
                    },
                    {
                        "username": "Sakura1987",
                        "content": "![image](https://assets.leetcode.com/users/sakura1987/image_1551696463.png)\\n"
                    }
                ]
            },
            {
                "id": 1748426,
                "content": [
                    {
                        "username": "eryzml",
                        "content": "I seem to always start by thinking of solutions which require the least amount of typing. So I reached for a reduce method. Then it occurred to me that I\\'m not directly taking action on each letter of the string. Anyway, that was a half hour down the wrong rabbit hole."
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "That\\'s called the optimize solution \\n"
                    },
                    {
                        "username": "Manoj_TM",
                        "content": "Was good for a brain teaser, and it was good for solution finding."
                    },
                    {
                        "username": "giabach1234",
                        "content": "Can someone please help me debug this code. I\\'m getting java.lang.ArrayIndexOutOfBoundsException at the if statement:\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = 0;\\n        \\n        char[] ch = s.toCharArray();\\n        for(int i = 0; i < ch.length; i++){\\n            if(map.get(ch[i]) < map.get(ch[i+1])){\\n                result -= map.get(ch[i]);\\n            }else{\\n                result += map.get(ch[i]);\\n            }\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "sugMag",
                        "content": "when i =ch.length then when the next line executes \" map.get(ch[i+1])){\" there ch[i+1] is out of bounds."
                    },
                    {
                        "username": "Chris99673",
                        "content": "For the if statement, you have to make sure that \"i\" is not the last index of the character array. The reason why you get that exception is because there are instances where the if statement checks that condition where i is the last index, and when it tries to access the i+1\\'s index, it is out of bounds."
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "HINT :  \"IV\"  =  -1 + 5"
                    },
                    {
                        "username": "Levidps",
                        "content": "This is just one way of thinking about it - can be done with keeping all values as positive integers."
                    },
                    {
                        "username": "pd_mishra",
                        "content": "your output is wrong according to this question"
                    },
                    {
                        "username": "HelloHabib",
                        "content": "Tips for C++ coder.......\\n(1) unordered map\\n(2) store last character value (say in t)\\n(3) reverse loop(start from second last)\\n(4) start comparing (b/w last one and second last)\\nright<left\\nsubstruction second last from t\\nelse\\nadd t and second last\\n.\\n.\\n(continue )\\n\\nand return"
                    },
                    {
                        "username": "ghanasyamk79",
                        "content": "I don\\'t quite understand why the frequency of this problem appeared in real interview is so high.\\nI find a little bit nonsense to try to use the less memory and CPU possible."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution (JavaScript version will update shortly).\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/)\\u2B50\\n\\n**I had already test all the code in my blog, so you can be assured !**\\n\\nHere is the Python3 version fastest submission detail\\n![image](https://assets.leetcode.com/users/images/b8be3282-1c50-4b4f-81e9-943a028adca7_1654367257.0549529.jpeg)\\n\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!"
                    },
                    {
                        "username": "EricCapet",
                        "content": "For example, \"DCXXXXI\" is an invalid string which has 4 repeated in succession of \"X\", but the \"expected answer\" still shows 641. Also the expected answer of \"IC\" is wrong, because the correct Roman numeral of 99 should be \"XCIX\"."
                    },
                    {
                        "username": "Sakura1987",
                        "content": "![image](https://assets.leetcode.com/users/sakura1987/image_1551696463.png)\\n"
                    }
                ]
            },
            {
                "id": 1576851,
                "content": [
                    {
                        "username": "eryzml",
                        "content": "I seem to always start by thinking of solutions which require the least amount of typing. So I reached for a reduce method. Then it occurred to me that I\\'m not directly taking action on each letter of the string. Anyway, that was a half hour down the wrong rabbit hole."
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "That\\'s called the optimize solution \\n"
                    },
                    {
                        "username": "Manoj_TM",
                        "content": "Was good for a brain teaser, and it was good for solution finding."
                    },
                    {
                        "username": "giabach1234",
                        "content": "Can someone please help me debug this code. I\\'m getting java.lang.ArrayIndexOutOfBoundsException at the if statement:\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = 0;\\n        \\n        char[] ch = s.toCharArray();\\n        for(int i = 0; i < ch.length; i++){\\n            if(map.get(ch[i]) < map.get(ch[i+1])){\\n                result -= map.get(ch[i]);\\n            }else{\\n                result += map.get(ch[i]);\\n            }\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "sugMag",
                        "content": "when i =ch.length then when the next line executes \" map.get(ch[i+1])){\" there ch[i+1] is out of bounds."
                    },
                    {
                        "username": "Chris99673",
                        "content": "For the if statement, you have to make sure that \"i\" is not the last index of the character array. The reason why you get that exception is because there are instances where the if statement checks that condition where i is the last index, and when it tries to access the i+1\\'s index, it is out of bounds."
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "HINT :  \"IV\"  =  -1 + 5"
                    },
                    {
                        "username": "Levidps",
                        "content": "This is just one way of thinking about it - can be done with keeping all values as positive integers."
                    },
                    {
                        "username": "pd_mishra",
                        "content": "your output is wrong according to this question"
                    },
                    {
                        "username": "HelloHabib",
                        "content": "Tips for C++ coder.......\\n(1) unordered map\\n(2) store last character value (say in t)\\n(3) reverse loop(start from second last)\\n(4) start comparing (b/w last one and second last)\\nright<left\\nsubstruction second last from t\\nelse\\nadd t and second last\\n.\\n.\\n(continue )\\n\\nand return"
                    },
                    {
                        "username": "ghanasyamk79",
                        "content": "I don\\'t quite understand why the frequency of this problem appeared in real interview is so high.\\nI find a little bit nonsense to try to use the less memory and CPU possible."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution (JavaScript version will update shortly).\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/)\\u2B50\\n\\n**I had already test all the code in my blog, so you can be assured !**\\n\\nHere is the Python3 version fastest submission detail\\n![image](https://assets.leetcode.com/users/images/b8be3282-1c50-4b4f-81e9-943a028adca7_1654367257.0549529.jpeg)\\n\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!"
                    },
                    {
                        "username": "EricCapet",
                        "content": "For example, \"DCXXXXI\" is an invalid string which has 4 repeated in succession of \"X\", but the \"expected answer\" still shows 641. Also the expected answer of \"IC\" is wrong, because the correct Roman numeral of 99 should be \"XCIX\"."
                    },
                    {
                        "username": "Sakura1987",
                        "content": "![image](https://assets.leetcode.com/users/sakura1987/image_1551696463.png)\\n"
                    }
                ]
            },
            {
                "id": 1571037,
                "content": [
                    {
                        "username": "eryzml",
                        "content": "I seem to always start by thinking of solutions which require the least amount of typing. So I reached for a reduce method. Then it occurred to me that I\\'m not directly taking action on each letter of the string. Anyway, that was a half hour down the wrong rabbit hole."
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "That\\'s called the optimize solution \\n"
                    },
                    {
                        "username": "Manoj_TM",
                        "content": "Was good for a brain teaser, and it was good for solution finding."
                    },
                    {
                        "username": "giabach1234",
                        "content": "Can someone please help me debug this code. I\\'m getting java.lang.ArrayIndexOutOfBoundsException at the if statement:\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = 0;\\n        \\n        char[] ch = s.toCharArray();\\n        for(int i = 0; i < ch.length; i++){\\n            if(map.get(ch[i]) < map.get(ch[i+1])){\\n                result -= map.get(ch[i]);\\n            }else{\\n                result += map.get(ch[i]);\\n            }\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "sugMag",
                        "content": "when i =ch.length then when the next line executes \" map.get(ch[i+1])){\" there ch[i+1] is out of bounds."
                    },
                    {
                        "username": "Chris99673",
                        "content": "For the if statement, you have to make sure that \"i\" is not the last index of the character array. The reason why you get that exception is because there are instances where the if statement checks that condition where i is the last index, and when it tries to access the i+1\\'s index, it is out of bounds."
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "HINT :  \"IV\"  =  -1 + 5"
                    },
                    {
                        "username": "Levidps",
                        "content": "This is just one way of thinking about it - can be done with keeping all values as positive integers."
                    },
                    {
                        "username": "pd_mishra",
                        "content": "your output is wrong according to this question"
                    },
                    {
                        "username": "HelloHabib",
                        "content": "Tips for C++ coder.......\\n(1) unordered map\\n(2) store last character value (say in t)\\n(3) reverse loop(start from second last)\\n(4) start comparing (b/w last one and second last)\\nright<left\\nsubstruction second last from t\\nelse\\nadd t and second last\\n.\\n.\\n(continue )\\n\\nand return"
                    },
                    {
                        "username": "ghanasyamk79",
                        "content": "I don\\'t quite understand why the frequency of this problem appeared in real interview is so high.\\nI find a little bit nonsense to try to use the less memory and CPU possible."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution (JavaScript version will update shortly).\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/)\\u2B50\\n\\n**I had already test all the code in my blog, so you can be assured !**\\n\\nHere is the Python3 version fastest submission detail\\n![image](https://assets.leetcode.com/users/images/b8be3282-1c50-4b4f-81e9-943a028adca7_1654367257.0549529.jpeg)\\n\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!"
                    },
                    {
                        "username": "EricCapet",
                        "content": "For example, \"DCXXXXI\" is an invalid string which has 4 repeated in succession of \"X\", but the \"expected answer\" still shows 641. Also the expected answer of \"IC\" is wrong, because the correct Roman numeral of 99 should be \"XCIX\"."
                    },
                    {
                        "username": "Sakura1987",
                        "content": "![image](https://assets.leetcode.com/users/sakura1987/image_1551696463.png)\\n"
                    }
                ]
            },
            {
                "id": 1572496,
                "content": [
                    {
                        "username": "eryzml",
                        "content": "I seem to always start by thinking of solutions which require the least amount of typing. So I reached for a reduce method. Then it occurred to me that I\\'m not directly taking action on each letter of the string. Anyway, that was a half hour down the wrong rabbit hole."
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "That\\'s called the optimize solution \\n"
                    },
                    {
                        "username": "Manoj_TM",
                        "content": "Was good for a brain teaser, and it was good for solution finding."
                    },
                    {
                        "username": "giabach1234",
                        "content": "Can someone please help me debug this code. I\\'m getting java.lang.ArrayIndexOutOfBoundsException at the if statement:\\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = 0;\\n        \\n        char[] ch = s.toCharArray();\\n        for(int i = 0; i < ch.length; i++){\\n            if(map.get(ch[i]) < map.get(ch[i+1])){\\n                result -= map.get(ch[i]);\\n            }else{\\n                result += map.get(ch[i]);\\n            }\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "sugMag",
                        "content": "when i =ch.length then when the next line executes \" map.get(ch[i+1])){\" there ch[i+1] is out of bounds."
                    },
                    {
                        "username": "Chris99673",
                        "content": "For the if statement, you have to make sure that \"i\" is not the last index of the character array. The reason why you get that exception is because there are instances where the if statement checks that condition where i is the last index, and when it tries to access the i+1\\'s index, it is out of bounds."
                    },
                    {
                        "username": "SunilKumawat",
                        "content": "HINT :  \"IV\"  =  -1 + 5"
                    },
                    {
                        "username": "Levidps",
                        "content": "This is just one way of thinking about it - can be done with keeping all values as positive integers."
                    },
                    {
                        "username": "pd_mishra",
                        "content": "your output is wrong according to this question"
                    },
                    {
                        "username": "HelloHabib",
                        "content": "Tips for C++ coder.......\\n(1) unordered map\\n(2) store last character value (say in t)\\n(3) reverse loop(start from second last)\\n(4) start comparing (b/w last one and second last)\\nright<left\\nsubstruction second last from t\\nelse\\nadd t and second last\\n.\\n.\\n(continue )\\n\\nand return"
                    },
                    {
                        "username": "ghanasyamk79",
                        "content": "I don\\'t quite understand why the frequency of this problem appeared in real interview is so high.\\nI find a little bit nonsense to try to use the less memory and CPU possible."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution (JavaScript version will update shortly).\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-13-roman-to-integer-solution-and-explanation-en/)\\u2B50\\n\\n**I had already test all the code in my blog, so you can be assured !**\\n\\nHere is the Python3 version fastest submission detail\\n![image](https://assets.leetcode.com/users/images/b8be3282-1c50-4b4f-81e9-943a028adca7_1654367257.0549529.jpeg)\\n\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!"
                    },
                    {
                        "username": "EricCapet",
                        "content": "For example, \"DCXXXXI\" is an invalid string which has 4 repeated in succession of \"X\", but the \"expected answer\" still shows 641. Also the expected answer of \"IC\" is wrong, because the correct Roman numeral of 99 should be \"XCIX\"."
                    },
                    {
                        "username": "Sakura1987",
                        "content": "![image](https://assets.leetcode.com/users/sakura1987/image_1551696463.png)\\n"
                    }
                ]
            },
            {
                "id": 1571038,
                "content": [
                    {
                        "username": "lc19890306",
                        "content": "In wikipedia [Roman numerals][1], it is clearly stated that \\n\\n - I placed before V or X indicates one less, so four is IV (one less than five) and nine is IX (one less than ten)\\n - X placed before L or C indicates ten less, so forty is XL (ten less than fifty) and ninety is XC (ten less than a hundred)\\n - C placed before D or M indicates a hundred less, so four hundred is CD (a hundred less than five hundred) and nine hundred is CM (a hundred less than a thousand)\\n\\nTherefore, test cases like \"IL\", \"IM\" should be the same as \"LI\", \"MI\", which are 51 and 1001, respectively.\\n\\n  [1]: https://en.wikipedia.org/wiki/Roman_numerals#Roman_numeric_system"
                    },
                    {
                        "username": "orgpark",
                        "content": "Like in the other thread shows many ways to solve the problem, there is slight difference of how it is implemented. They are all O(n). I found this problem very fun and gave me a chance to learn roman numeric. Not too difficult to solve and gave me a good learning."
                    },
                    {
                        "username": "louie33",
                        "content": "The question I think should make it clearer that you will never have a number like this: IIX which logically I\\'d take to be 8 . As 8 will always be VIII. \\n\\ni.e. you will only ever have 1 char before for a subtraction and not 2 or more (like IIX). \\n\\nWithout knowledge of Roman Numerals its not that obvious ( to me anyway!)."
                    },
                    {
                        "username": "akvir",
                        "content": "Can someone explain why that condition always returns true?\\n `list_rom = [\\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\']\\nif list_given[list_given.index(i)+1] or list_given[list_given.index(i)+2] or list_given[list_given.index(i)+3] != list_rom[1] or list_rom[2]:` \\n"
                    },
                    {
                        "username": "user2873HK",
                        "content": "My code (JavaScript): \n`const symbols = s.split('');\nconst _SYMBOLS = {\n 'I': 1,\n'V': 5,\n'X': 10,\n'L': 50,\n'C': 100,\n'D': 500,\n'M': 1000,\n};\n\nlet numerals = [0];\n\nfor (let index = 0; index < symbols.length; index++) {\nconst number = _SYMBOLS[symbols[index]];\nif (number > numerals[numerals.length - 1]) {\nnumerals[numerals.length - 1] = -(numerals[numerals.length - 1]);\n}\nnumerals.push(number);\n}\n\nreturn numerals.reduce((numeral, x) => numeral + x, 0); `"
                    },
                    {
                        "username": "midhilesh1979",
                        "content": " int romanToInt(string s) {\\n       reverse(s.begin(),s.end());\\n       int c=0;\\n       for(int i=0;i<s.size();i++){\\n           switch(s[i]){\\n               case \\'I\\':  c= (i==0 || s[i-1]==\\'I\\')? c+1 : c-1;\\n                 break;\\n               case \\'V\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\')? c+5 : c-5;\\n                 break;\\n               case \\'X\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\')? c+10 : c-10;\\n                 break;\\n               case \\'L\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\' || s[i-1]==\\'L\\')? c+50 : c-50;\\n                 break;\\n               case \\'C\\':c= (i==0)? c+100 : (s[i-1]==\\'D\\' || s[i-1]==\\'M\\' )? c-100 : c+100;\\n                 break;\\n            case \\'D\\': c= (i==0)? c+500 :(s[i-1]==\\'M\\' )? c-500 : c+500;\\n                 break;\\n                 case \\'M\\': c=  c+1000;\\n                 break;\\n       } \\n    }\\n    return c;\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?\\nWhat you\\'ve posted is not a tip at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "why can\\'t i implement dictionary using hashtable? i am getting null pointer exception!\\n"
                    },
                    {
                        "username": "rubayea",
                        "content": " I find this problem interesting however I try to challenge myself to answer it in Python3  since I find it comfortable to solve problems in Java. If anyone could guide me when its suitable to use the different variation of for loops : enumerate() in range() and the normal for loop . \\uD83D\\uDE01"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "we can use queue or stack using this solution, to see next or previous value "
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "It take me almost 20 minute to remove error\\uD83E\\uDD23\\uD83E\\uDD23"
                    }
                ]
            },
            {
                "id": 1571039,
                "content": [
                    {
                        "username": "lc19890306",
                        "content": "In wikipedia [Roman numerals][1], it is clearly stated that \\n\\n - I placed before V or X indicates one less, so four is IV (one less than five) and nine is IX (one less than ten)\\n - X placed before L or C indicates ten less, so forty is XL (ten less than fifty) and ninety is XC (ten less than a hundred)\\n - C placed before D or M indicates a hundred less, so four hundred is CD (a hundred less than five hundred) and nine hundred is CM (a hundred less than a thousand)\\n\\nTherefore, test cases like \"IL\", \"IM\" should be the same as \"LI\", \"MI\", which are 51 and 1001, respectively.\\n\\n  [1]: https://en.wikipedia.org/wiki/Roman_numerals#Roman_numeric_system"
                    },
                    {
                        "username": "orgpark",
                        "content": "Like in the other thread shows many ways to solve the problem, there is slight difference of how it is implemented. They are all O(n). I found this problem very fun and gave me a chance to learn roman numeric. Not too difficult to solve and gave me a good learning."
                    },
                    {
                        "username": "louie33",
                        "content": "The question I think should make it clearer that you will never have a number like this: IIX which logically I\\'d take to be 8 . As 8 will always be VIII. \\n\\ni.e. you will only ever have 1 char before for a subtraction and not 2 or more (like IIX). \\n\\nWithout knowledge of Roman Numerals its not that obvious ( to me anyway!)."
                    },
                    {
                        "username": "akvir",
                        "content": "Can someone explain why that condition always returns true?\\n `list_rom = [\\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\']\\nif list_given[list_given.index(i)+1] or list_given[list_given.index(i)+2] or list_given[list_given.index(i)+3] != list_rom[1] or list_rom[2]:` \\n"
                    },
                    {
                        "username": "user2873HK",
                        "content": "My code (JavaScript): \n`const symbols = s.split('');\nconst _SYMBOLS = {\n 'I': 1,\n'V': 5,\n'X': 10,\n'L': 50,\n'C': 100,\n'D': 500,\n'M': 1000,\n};\n\nlet numerals = [0];\n\nfor (let index = 0; index < symbols.length; index++) {\nconst number = _SYMBOLS[symbols[index]];\nif (number > numerals[numerals.length - 1]) {\nnumerals[numerals.length - 1] = -(numerals[numerals.length - 1]);\n}\nnumerals.push(number);\n}\n\nreturn numerals.reduce((numeral, x) => numeral + x, 0); `"
                    },
                    {
                        "username": "midhilesh1979",
                        "content": " int romanToInt(string s) {\\n       reverse(s.begin(),s.end());\\n       int c=0;\\n       for(int i=0;i<s.size();i++){\\n           switch(s[i]){\\n               case \\'I\\':  c= (i==0 || s[i-1]==\\'I\\')? c+1 : c-1;\\n                 break;\\n               case \\'V\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\')? c+5 : c-5;\\n                 break;\\n               case \\'X\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\')? c+10 : c-10;\\n                 break;\\n               case \\'L\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\' || s[i-1]==\\'L\\')? c+50 : c-50;\\n                 break;\\n               case \\'C\\':c= (i==0)? c+100 : (s[i-1]==\\'D\\' || s[i-1]==\\'M\\' )? c-100 : c+100;\\n                 break;\\n            case \\'D\\': c= (i==0)? c+500 :(s[i-1]==\\'M\\' )? c-500 : c+500;\\n                 break;\\n                 case \\'M\\': c=  c+1000;\\n                 break;\\n       } \\n    }\\n    return c;\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?\\nWhat you\\'ve posted is not a tip at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "why can\\'t i implement dictionary using hashtable? i am getting null pointer exception!\\n"
                    },
                    {
                        "username": "rubayea",
                        "content": " I find this problem interesting however I try to challenge myself to answer it in Python3  since I find it comfortable to solve problems in Java. If anyone could guide me when its suitable to use the different variation of for loops : enumerate() in range() and the normal for loop . \\uD83D\\uDE01"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "we can use queue or stack using this solution, to see next or previous value "
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "It take me almost 20 minute to remove error\\uD83E\\uDD23\\uD83E\\uDD23"
                    }
                ]
            },
            {
                "id": 2071994,
                "content": [
                    {
                        "username": "lc19890306",
                        "content": "In wikipedia [Roman numerals][1], it is clearly stated that \\n\\n - I placed before V or X indicates one less, so four is IV (one less than five) and nine is IX (one less than ten)\\n - X placed before L or C indicates ten less, so forty is XL (ten less than fifty) and ninety is XC (ten less than a hundred)\\n - C placed before D or M indicates a hundred less, so four hundred is CD (a hundred less than five hundred) and nine hundred is CM (a hundred less than a thousand)\\n\\nTherefore, test cases like \"IL\", \"IM\" should be the same as \"LI\", \"MI\", which are 51 and 1001, respectively.\\n\\n  [1]: https://en.wikipedia.org/wiki/Roman_numerals#Roman_numeric_system"
                    },
                    {
                        "username": "orgpark",
                        "content": "Like in the other thread shows many ways to solve the problem, there is slight difference of how it is implemented. They are all O(n). I found this problem very fun and gave me a chance to learn roman numeric. Not too difficult to solve and gave me a good learning."
                    },
                    {
                        "username": "louie33",
                        "content": "The question I think should make it clearer that you will never have a number like this: IIX which logically I\\'d take to be 8 . As 8 will always be VIII. \\n\\ni.e. you will only ever have 1 char before for a subtraction and not 2 or more (like IIX). \\n\\nWithout knowledge of Roman Numerals its not that obvious ( to me anyway!)."
                    },
                    {
                        "username": "akvir",
                        "content": "Can someone explain why that condition always returns true?\\n `list_rom = [\\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\']\\nif list_given[list_given.index(i)+1] or list_given[list_given.index(i)+2] or list_given[list_given.index(i)+3] != list_rom[1] or list_rom[2]:` \\n"
                    },
                    {
                        "username": "user2873HK",
                        "content": "My code (JavaScript): \n`const symbols = s.split('');\nconst _SYMBOLS = {\n 'I': 1,\n'V': 5,\n'X': 10,\n'L': 50,\n'C': 100,\n'D': 500,\n'M': 1000,\n};\n\nlet numerals = [0];\n\nfor (let index = 0; index < symbols.length; index++) {\nconst number = _SYMBOLS[symbols[index]];\nif (number > numerals[numerals.length - 1]) {\nnumerals[numerals.length - 1] = -(numerals[numerals.length - 1]);\n}\nnumerals.push(number);\n}\n\nreturn numerals.reduce((numeral, x) => numeral + x, 0); `"
                    },
                    {
                        "username": "midhilesh1979",
                        "content": " int romanToInt(string s) {\\n       reverse(s.begin(),s.end());\\n       int c=0;\\n       for(int i=0;i<s.size();i++){\\n           switch(s[i]){\\n               case \\'I\\':  c= (i==0 || s[i-1]==\\'I\\')? c+1 : c-1;\\n                 break;\\n               case \\'V\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\')? c+5 : c-5;\\n                 break;\\n               case \\'X\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\')? c+10 : c-10;\\n                 break;\\n               case \\'L\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\' || s[i-1]==\\'L\\')? c+50 : c-50;\\n                 break;\\n               case \\'C\\':c= (i==0)? c+100 : (s[i-1]==\\'D\\' || s[i-1]==\\'M\\' )? c-100 : c+100;\\n                 break;\\n            case \\'D\\': c= (i==0)? c+500 :(s[i-1]==\\'M\\' )? c-500 : c+500;\\n                 break;\\n                 case \\'M\\': c=  c+1000;\\n                 break;\\n       } \\n    }\\n    return c;\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?\\nWhat you\\'ve posted is not a tip at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "why can\\'t i implement dictionary using hashtable? i am getting null pointer exception!\\n"
                    },
                    {
                        "username": "rubayea",
                        "content": " I find this problem interesting however I try to challenge myself to answer it in Python3  since I find it comfortable to solve problems in Java. If anyone could guide me when its suitable to use the different variation of for loops : enumerate() in range() and the normal for loop . \\uD83D\\uDE01"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "we can use queue or stack using this solution, to see next or previous value "
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "It take me almost 20 minute to remove error\\uD83E\\uDD23\\uD83E\\uDD23"
                    }
                ]
            },
            {
                "id": 2071692,
                "content": [
                    {
                        "username": "lc19890306",
                        "content": "In wikipedia [Roman numerals][1], it is clearly stated that \\n\\n - I placed before V or X indicates one less, so four is IV (one less than five) and nine is IX (one less than ten)\\n - X placed before L or C indicates ten less, so forty is XL (ten less than fifty) and ninety is XC (ten less than a hundred)\\n - C placed before D or M indicates a hundred less, so four hundred is CD (a hundred less than five hundred) and nine hundred is CM (a hundred less than a thousand)\\n\\nTherefore, test cases like \"IL\", \"IM\" should be the same as \"LI\", \"MI\", which are 51 and 1001, respectively.\\n\\n  [1]: https://en.wikipedia.org/wiki/Roman_numerals#Roman_numeric_system"
                    },
                    {
                        "username": "orgpark",
                        "content": "Like in the other thread shows many ways to solve the problem, there is slight difference of how it is implemented. They are all O(n). I found this problem very fun and gave me a chance to learn roman numeric. Not too difficult to solve and gave me a good learning."
                    },
                    {
                        "username": "louie33",
                        "content": "The question I think should make it clearer that you will never have a number like this: IIX which logically I\\'d take to be 8 . As 8 will always be VIII. \\n\\ni.e. you will only ever have 1 char before for a subtraction and not 2 or more (like IIX). \\n\\nWithout knowledge of Roman Numerals its not that obvious ( to me anyway!)."
                    },
                    {
                        "username": "akvir",
                        "content": "Can someone explain why that condition always returns true?\\n `list_rom = [\\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\']\\nif list_given[list_given.index(i)+1] or list_given[list_given.index(i)+2] or list_given[list_given.index(i)+3] != list_rom[1] or list_rom[2]:` \\n"
                    },
                    {
                        "username": "user2873HK",
                        "content": "My code (JavaScript): \n`const symbols = s.split('');\nconst _SYMBOLS = {\n 'I': 1,\n'V': 5,\n'X': 10,\n'L': 50,\n'C': 100,\n'D': 500,\n'M': 1000,\n};\n\nlet numerals = [0];\n\nfor (let index = 0; index < symbols.length; index++) {\nconst number = _SYMBOLS[symbols[index]];\nif (number > numerals[numerals.length - 1]) {\nnumerals[numerals.length - 1] = -(numerals[numerals.length - 1]);\n}\nnumerals.push(number);\n}\n\nreturn numerals.reduce((numeral, x) => numeral + x, 0); `"
                    },
                    {
                        "username": "midhilesh1979",
                        "content": " int romanToInt(string s) {\\n       reverse(s.begin(),s.end());\\n       int c=0;\\n       for(int i=0;i<s.size();i++){\\n           switch(s[i]){\\n               case \\'I\\':  c= (i==0 || s[i-1]==\\'I\\')? c+1 : c-1;\\n                 break;\\n               case \\'V\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\')? c+5 : c-5;\\n                 break;\\n               case \\'X\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\')? c+10 : c-10;\\n                 break;\\n               case \\'L\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\' || s[i-1]==\\'L\\')? c+50 : c-50;\\n                 break;\\n               case \\'C\\':c= (i==0)? c+100 : (s[i-1]==\\'D\\' || s[i-1]==\\'M\\' )? c-100 : c+100;\\n                 break;\\n            case \\'D\\': c= (i==0)? c+500 :(s[i-1]==\\'M\\' )? c-500 : c+500;\\n                 break;\\n                 case \\'M\\': c=  c+1000;\\n                 break;\\n       } \\n    }\\n    return c;\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?\\nWhat you\\'ve posted is not a tip at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "why can\\'t i implement dictionary using hashtable? i am getting null pointer exception!\\n"
                    },
                    {
                        "username": "rubayea",
                        "content": " I find this problem interesting however I try to challenge myself to answer it in Python3  since I find it comfortable to solve problems in Java. If anyone could guide me when its suitable to use the different variation of for loops : enumerate() in range() and the normal for loop . \\uD83D\\uDE01"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "we can use queue or stack using this solution, to see next or previous value "
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "It take me almost 20 minute to remove error\\uD83E\\uDD23\\uD83E\\uDD23"
                    }
                ]
            },
            {
                "id": 2064116,
                "content": [
                    {
                        "username": "lc19890306",
                        "content": "In wikipedia [Roman numerals][1], it is clearly stated that \\n\\n - I placed before V or X indicates one less, so four is IV (one less than five) and nine is IX (one less than ten)\\n - X placed before L or C indicates ten less, so forty is XL (ten less than fifty) and ninety is XC (ten less than a hundred)\\n - C placed before D or M indicates a hundred less, so four hundred is CD (a hundred less than five hundred) and nine hundred is CM (a hundred less than a thousand)\\n\\nTherefore, test cases like \"IL\", \"IM\" should be the same as \"LI\", \"MI\", which are 51 and 1001, respectively.\\n\\n  [1]: https://en.wikipedia.org/wiki/Roman_numerals#Roman_numeric_system"
                    },
                    {
                        "username": "orgpark",
                        "content": "Like in the other thread shows many ways to solve the problem, there is slight difference of how it is implemented. They are all O(n). I found this problem very fun and gave me a chance to learn roman numeric. Not too difficult to solve and gave me a good learning."
                    },
                    {
                        "username": "louie33",
                        "content": "The question I think should make it clearer that you will never have a number like this: IIX which logically I\\'d take to be 8 . As 8 will always be VIII. \\n\\ni.e. you will only ever have 1 char before for a subtraction and not 2 or more (like IIX). \\n\\nWithout knowledge of Roman Numerals its not that obvious ( to me anyway!)."
                    },
                    {
                        "username": "akvir",
                        "content": "Can someone explain why that condition always returns true?\\n `list_rom = [\\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\']\\nif list_given[list_given.index(i)+1] or list_given[list_given.index(i)+2] or list_given[list_given.index(i)+3] != list_rom[1] or list_rom[2]:` \\n"
                    },
                    {
                        "username": "user2873HK",
                        "content": "My code (JavaScript): \n`const symbols = s.split('');\nconst _SYMBOLS = {\n 'I': 1,\n'V': 5,\n'X': 10,\n'L': 50,\n'C': 100,\n'D': 500,\n'M': 1000,\n};\n\nlet numerals = [0];\n\nfor (let index = 0; index < symbols.length; index++) {\nconst number = _SYMBOLS[symbols[index]];\nif (number > numerals[numerals.length - 1]) {\nnumerals[numerals.length - 1] = -(numerals[numerals.length - 1]);\n}\nnumerals.push(number);\n}\n\nreturn numerals.reduce((numeral, x) => numeral + x, 0); `"
                    },
                    {
                        "username": "midhilesh1979",
                        "content": " int romanToInt(string s) {\\n       reverse(s.begin(),s.end());\\n       int c=0;\\n       for(int i=0;i<s.size();i++){\\n           switch(s[i]){\\n               case \\'I\\':  c= (i==0 || s[i-1]==\\'I\\')? c+1 : c-1;\\n                 break;\\n               case \\'V\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\')? c+5 : c-5;\\n                 break;\\n               case \\'X\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\')? c+10 : c-10;\\n                 break;\\n               case \\'L\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\' || s[i-1]==\\'L\\')? c+50 : c-50;\\n                 break;\\n               case \\'C\\':c= (i==0)? c+100 : (s[i-1]==\\'D\\' || s[i-1]==\\'M\\' )? c-100 : c+100;\\n                 break;\\n            case \\'D\\': c= (i==0)? c+500 :(s[i-1]==\\'M\\' )? c-500 : c+500;\\n                 break;\\n                 case \\'M\\': c=  c+1000;\\n                 break;\\n       } \\n    }\\n    return c;\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?\\nWhat you\\'ve posted is not a tip at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "why can\\'t i implement dictionary using hashtable? i am getting null pointer exception!\\n"
                    },
                    {
                        "username": "rubayea",
                        "content": " I find this problem interesting however I try to challenge myself to answer it in Python3  since I find it comfortable to solve problems in Java. If anyone could guide me when its suitable to use the different variation of for loops : enumerate() in range() and the normal for loop . \\uD83D\\uDE01"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "we can use queue or stack using this solution, to see next or previous value "
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "It take me almost 20 minute to remove error\\uD83E\\uDD23\\uD83E\\uDD23"
                    }
                ]
            },
            {
                "id": 2063590,
                "content": [
                    {
                        "username": "lc19890306",
                        "content": "In wikipedia [Roman numerals][1], it is clearly stated that \\n\\n - I placed before V or X indicates one less, so four is IV (one less than five) and nine is IX (one less than ten)\\n - X placed before L or C indicates ten less, so forty is XL (ten less than fifty) and ninety is XC (ten less than a hundred)\\n - C placed before D or M indicates a hundred less, so four hundred is CD (a hundred less than five hundred) and nine hundred is CM (a hundred less than a thousand)\\n\\nTherefore, test cases like \"IL\", \"IM\" should be the same as \"LI\", \"MI\", which are 51 and 1001, respectively.\\n\\n  [1]: https://en.wikipedia.org/wiki/Roman_numerals#Roman_numeric_system"
                    },
                    {
                        "username": "orgpark",
                        "content": "Like in the other thread shows many ways to solve the problem, there is slight difference of how it is implemented. They are all O(n). I found this problem very fun and gave me a chance to learn roman numeric. Not too difficult to solve and gave me a good learning."
                    },
                    {
                        "username": "louie33",
                        "content": "The question I think should make it clearer that you will never have a number like this: IIX which logically I\\'d take to be 8 . As 8 will always be VIII. \\n\\ni.e. you will only ever have 1 char before for a subtraction and not 2 or more (like IIX). \\n\\nWithout knowledge of Roman Numerals its not that obvious ( to me anyway!)."
                    },
                    {
                        "username": "akvir",
                        "content": "Can someone explain why that condition always returns true?\\n `list_rom = [\\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\']\\nif list_given[list_given.index(i)+1] or list_given[list_given.index(i)+2] or list_given[list_given.index(i)+3] != list_rom[1] or list_rom[2]:` \\n"
                    },
                    {
                        "username": "user2873HK",
                        "content": "My code (JavaScript): \n`const symbols = s.split('');\nconst _SYMBOLS = {\n 'I': 1,\n'V': 5,\n'X': 10,\n'L': 50,\n'C': 100,\n'D': 500,\n'M': 1000,\n};\n\nlet numerals = [0];\n\nfor (let index = 0; index < symbols.length; index++) {\nconst number = _SYMBOLS[symbols[index]];\nif (number > numerals[numerals.length - 1]) {\nnumerals[numerals.length - 1] = -(numerals[numerals.length - 1]);\n}\nnumerals.push(number);\n}\n\nreturn numerals.reduce((numeral, x) => numeral + x, 0); `"
                    },
                    {
                        "username": "midhilesh1979",
                        "content": " int romanToInt(string s) {\\n       reverse(s.begin(),s.end());\\n       int c=0;\\n       for(int i=0;i<s.size();i++){\\n           switch(s[i]){\\n               case \\'I\\':  c= (i==0 || s[i-1]==\\'I\\')? c+1 : c-1;\\n                 break;\\n               case \\'V\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\')? c+5 : c-5;\\n                 break;\\n               case \\'X\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\')? c+10 : c-10;\\n                 break;\\n               case \\'L\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\' || s[i-1]==\\'L\\')? c+50 : c-50;\\n                 break;\\n               case \\'C\\':c= (i==0)? c+100 : (s[i-1]==\\'D\\' || s[i-1]==\\'M\\' )? c-100 : c+100;\\n                 break;\\n            case \\'D\\': c= (i==0)? c+500 :(s[i-1]==\\'M\\' )? c-500 : c+500;\\n                 break;\\n                 case \\'M\\': c=  c+1000;\\n                 break;\\n       } \\n    }\\n    return c;\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?\\nWhat you\\'ve posted is not a tip at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "why can\\'t i implement dictionary using hashtable? i am getting null pointer exception!\\n"
                    },
                    {
                        "username": "rubayea",
                        "content": " I find this problem interesting however I try to challenge myself to answer it in Python3  since I find it comfortable to solve problems in Java. If anyone could guide me when its suitable to use the different variation of for loops : enumerate() in range() and the normal for loop . \\uD83D\\uDE01"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "we can use queue or stack using this solution, to see next or previous value "
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "It take me almost 20 minute to remove error\\uD83E\\uDD23\\uD83E\\uDD23"
                    }
                ]
            },
            {
                "id": 2062040,
                "content": [
                    {
                        "username": "lc19890306",
                        "content": "In wikipedia [Roman numerals][1], it is clearly stated that \\n\\n - I placed before V or X indicates one less, so four is IV (one less than five) and nine is IX (one less than ten)\\n - X placed before L or C indicates ten less, so forty is XL (ten less than fifty) and ninety is XC (ten less than a hundred)\\n - C placed before D or M indicates a hundred less, so four hundred is CD (a hundred less than five hundred) and nine hundred is CM (a hundred less than a thousand)\\n\\nTherefore, test cases like \"IL\", \"IM\" should be the same as \"LI\", \"MI\", which are 51 and 1001, respectively.\\n\\n  [1]: https://en.wikipedia.org/wiki/Roman_numerals#Roman_numeric_system"
                    },
                    {
                        "username": "orgpark",
                        "content": "Like in the other thread shows many ways to solve the problem, there is slight difference of how it is implemented. They are all O(n). I found this problem very fun and gave me a chance to learn roman numeric. Not too difficult to solve and gave me a good learning."
                    },
                    {
                        "username": "louie33",
                        "content": "The question I think should make it clearer that you will never have a number like this: IIX which logically I\\'d take to be 8 . As 8 will always be VIII. \\n\\ni.e. you will only ever have 1 char before for a subtraction and not 2 or more (like IIX). \\n\\nWithout knowledge of Roman Numerals its not that obvious ( to me anyway!)."
                    },
                    {
                        "username": "akvir",
                        "content": "Can someone explain why that condition always returns true?\\n `list_rom = [\\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\']\\nif list_given[list_given.index(i)+1] or list_given[list_given.index(i)+2] or list_given[list_given.index(i)+3] != list_rom[1] or list_rom[2]:` \\n"
                    },
                    {
                        "username": "user2873HK",
                        "content": "My code (JavaScript): \n`const symbols = s.split('');\nconst _SYMBOLS = {\n 'I': 1,\n'V': 5,\n'X': 10,\n'L': 50,\n'C': 100,\n'D': 500,\n'M': 1000,\n};\n\nlet numerals = [0];\n\nfor (let index = 0; index < symbols.length; index++) {\nconst number = _SYMBOLS[symbols[index]];\nif (number > numerals[numerals.length - 1]) {\nnumerals[numerals.length - 1] = -(numerals[numerals.length - 1]);\n}\nnumerals.push(number);\n}\n\nreturn numerals.reduce((numeral, x) => numeral + x, 0); `"
                    },
                    {
                        "username": "midhilesh1979",
                        "content": " int romanToInt(string s) {\\n       reverse(s.begin(),s.end());\\n       int c=0;\\n       for(int i=0;i<s.size();i++){\\n           switch(s[i]){\\n               case \\'I\\':  c= (i==0 || s[i-1]==\\'I\\')? c+1 : c-1;\\n                 break;\\n               case \\'V\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\')? c+5 : c-5;\\n                 break;\\n               case \\'X\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\')? c+10 : c-10;\\n                 break;\\n               case \\'L\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\' || s[i-1]==\\'L\\')? c+50 : c-50;\\n                 break;\\n               case \\'C\\':c= (i==0)? c+100 : (s[i-1]==\\'D\\' || s[i-1]==\\'M\\' )? c-100 : c+100;\\n                 break;\\n            case \\'D\\': c= (i==0)? c+500 :(s[i-1]==\\'M\\' )? c-500 : c+500;\\n                 break;\\n                 case \\'M\\': c=  c+1000;\\n                 break;\\n       } \\n    }\\n    return c;\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?\\nWhat you\\'ve posted is not a tip at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "why can\\'t i implement dictionary using hashtable? i am getting null pointer exception!\\n"
                    },
                    {
                        "username": "rubayea",
                        "content": " I find this problem interesting however I try to challenge myself to answer it in Python3  since I find it comfortable to solve problems in Java. If anyone could guide me when its suitable to use the different variation of for loops : enumerate() in range() and the normal for loop . \\uD83D\\uDE01"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "we can use queue or stack using this solution, to see next or previous value "
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "It take me almost 20 minute to remove error\\uD83E\\uDD23\\uD83E\\uDD23"
                    }
                ]
            },
            {
                "id": 2055108,
                "content": [
                    {
                        "username": "lc19890306",
                        "content": "In wikipedia [Roman numerals][1], it is clearly stated that \\n\\n - I placed before V or X indicates one less, so four is IV (one less than five) and nine is IX (one less than ten)\\n - X placed before L or C indicates ten less, so forty is XL (ten less than fifty) and ninety is XC (ten less than a hundred)\\n - C placed before D or M indicates a hundred less, so four hundred is CD (a hundred less than five hundred) and nine hundred is CM (a hundred less than a thousand)\\n\\nTherefore, test cases like \"IL\", \"IM\" should be the same as \"LI\", \"MI\", which are 51 and 1001, respectively.\\n\\n  [1]: https://en.wikipedia.org/wiki/Roman_numerals#Roman_numeric_system"
                    },
                    {
                        "username": "orgpark",
                        "content": "Like in the other thread shows many ways to solve the problem, there is slight difference of how it is implemented. They are all O(n). I found this problem very fun and gave me a chance to learn roman numeric. Not too difficult to solve and gave me a good learning."
                    },
                    {
                        "username": "louie33",
                        "content": "The question I think should make it clearer that you will never have a number like this: IIX which logically I\\'d take to be 8 . As 8 will always be VIII. \\n\\ni.e. you will only ever have 1 char before for a subtraction and not 2 or more (like IIX). \\n\\nWithout knowledge of Roman Numerals its not that obvious ( to me anyway!)."
                    },
                    {
                        "username": "akvir",
                        "content": "Can someone explain why that condition always returns true?\\n `list_rom = [\\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\']\\nif list_given[list_given.index(i)+1] or list_given[list_given.index(i)+2] or list_given[list_given.index(i)+3] != list_rom[1] or list_rom[2]:` \\n"
                    },
                    {
                        "username": "user2873HK",
                        "content": "My code (JavaScript): \n`const symbols = s.split('');\nconst _SYMBOLS = {\n 'I': 1,\n'V': 5,\n'X': 10,\n'L': 50,\n'C': 100,\n'D': 500,\n'M': 1000,\n};\n\nlet numerals = [0];\n\nfor (let index = 0; index < symbols.length; index++) {\nconst number = _SYMBOLS[symbols[index]];\nif (number > numerals[numerals.length - 1]) {\nnumerals[numerals.length - 1] = -(numerals[numerals.length - 1]);\n}\nnumerals.push(number);\n}\n\nreturn numerals.reduce((numeral, x) => numeral + x, 0); `"
                    },
                    {
                        "username": "midhilesh1979",
                        "content": " int romanToInt(string s) {\\n       reverse(s.begin(),s.end());\\n       int c=0;\\n       for(int i=0;i<s.size();i++){\\n           switch(s[i]){\\n               case \\'I\\':  c= (i==0 || s[i-1]==\\'I\\')? c+1 : c-1;\\n                 break;\\n               case \\'V\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\')? c+5 : c-5;\\n                 break;\\n               case \\'X\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\')? c+10 : c-10;\\n                 break;\\n               case \\'L\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\' || s[i-1]==\\'L\\')? c+50 : c-50;\\n                 break;\\n               case \\'C\\':c= (i==0)? c+100 : (s[i-1]==\\'D\\' || s[i-1]==\\'M\\' )? c-100 : c+100;\\n                 break;\\n            case \\'D\\': c= (i==0)? c+500 :(s[i-1]==\\'M\\' )? c-500 : c+500;\\n                 break;\\n                 case \\'M\\': c=  c+1000;\\n                 break;\\n       } \\n    }\\n    return c;\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?\\nWhat you\\'ve posted is not a tip at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "why can\\'t i implement dictionary using hashtable? i am getting null pointer exception!\\n"
                    },
                    {
                        "username": "rubayea",
                        "content": " I find this problem interesting however I try to challenge myself to answer it in Python3  since I find it comfortable to solve problems in Java. If anyone could guide me when its suitable to use the different variation of for loops : enumerate() in range() and the normal for loop . \\uD83D\\uDE01"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "we can use queue or stack using this solution, to see next or previous value "
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "It take me almost 20 minute to remove error\\uD83E\\uDD23\\uD83E\\uDD23"
                    }
                ]
            },
            {
                "id": 2054154,
                "content": [
                    {
                        "username": "lc19890306",
                        "content": "In wikipedia [Roman numerals][1], it is clearly stated that \\n\\n - I placed before V or X indicates one less, so four is IV (one less than five) and nine is IX (one less than ten)\\n - X placed before L or C indicates ten less, so forty is XL (ten less than fifty) and ninety is XC (ten less than a hundred)\\n - C placed before D or M indicates a hundred less, so four hundred is CD (a hundred less than five hundred) and nine hundred is CM (a hundred less than a thousand)\\n\\nTherefore, test cases like \"IL\", \"IM\" should be the same as \"LI\", \"MI\", which are 51 and 1001, respectively.\\n\\n  [1]: https://en.wikipedia.org/wiki/Roman_numerals#Roman_numeric_system"
                    },
                    {
                        "username": "orgpark",
                        "content": "Like in the other thread shows many ways to solve the problem, there is slight difference of how it is implemented. They are all O(n). I found this problem very fun and gave me a chance to learn roman numeric. Not too difficult to solve and gave me a good learning."
                    },
                    {
                        "username": "louie33",
                        "content": "The question I think should make it clearer that you will never have a number like this: IIX which logically I\\'d take to be 8 . As 8 will always be VIII. \\n\\ni.e. you will only ever have 1 char before for a subtraction and not 2 or more (like IIX). \\n\\nWithout knowledge of Roman Numerals its not that obvious ( to me anyway!)."
                    },
                    {
                        "username": "akvir",
                        "content": "Can someone explain why that condition always returns true?\\n `list_rom = [\\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\']\\nif list_given[list_given.index(i)+1] or list_given[list_given.index(i)+2] or list_given[list_given.index(i)+3] != list_rom[1] or list_rom[2]:` \\n"
                    },
                    {
                        "username": "user2873HK",
                        "content": "My code (JavaScript): \n`const symbols = s.split('');\nconst _SYMBOLS = {\n 'I': 1,\n'V': 5,\n'X': 10,\n'L': 50,\n'C': 100,\n'D': 500,\n'M': 1000,\n};\n\nlet numerals = [0];\n\nfor (let index = 0; index < symbols.length; index++) {\nconst number = _SYMBOLS[symbols[index]];\nif (number > numerals[numerals.length - 1]) {\nnumerals[numerals.length - 1] = -(numerals[numerals.length - 1]);\n}\nnumerals.push(number);\n}\n\nreturn numerals.reduce((numeral, x) => numeral + x, 0); `"
                    },
                    {
                        "username": "midhilesh1979",
                        "content": " int romanToInt(string s) {\\n       reverse(s.begin(),s.end());\\n       int c=0;\\n       for(int i=0;i<s.size();i++){\\n           switch(s[i]){\\n               case \\'I\\':  c= (i==0 || s[i-1]==\\'I\\')? c+1 : c-1;\\n                 break;\\n               case \\'V\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\')? c+5 : c-5;\\n                 break;\\n               case \\'X\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\')? c+10 : c-10;\\n                 break;\\n               case \\'L\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\' || s[i-1]==\\'L\\')? c+50 : c-50;\\n                 break;\\n               case \\'C\\':c= (i==0)? c+100 : (s[i-1]==\\'D\\' || s[i-1]==\\'M\\' )? c-100 : c+100;\\n                 break;\\n            case \\'D\\': c= (i==0)? c+500 :(s[i-1]==\\'M\\' )? c-500 : c+500;\\n                 break;\\n                 case \\'M\\': c=  c+1000;\\n                 break;\\n       } \\n    }\\n    return c;\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?\\nWhat you\\'ve posted is not a tip at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "why can\\'t i implement dictionary using hashtable? i am getting null pointer exception!\\n"
                    },
                    {
                        "username": "rubayea",
                        "content": " I find this problem interesting however I try to challenge myself to answer it in Python3  since I find it comfortable to solve problems in Java. If anyone could guide me when its suitable to use the different variation of for loops : enumerate() in range() and the normal for loop . \\uD83D\\uDE01"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "we can use queue or stack using this solution, to see next or previous value "
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "It take me almost 20 minute to remove error\\uD83E\\uDD23\\uD83E\\uDD23"
                    }
                ]
            },
            {
                "id": 2031295,
                "content": [
                    {
                        "username": "lc19890306",
                        "content": "In wikipedia [Roman numerals][1], it is clearly stated that \\n\\n - I placed before V or X indicates one less, so four is IV (one less than five) and nine is IX (one less than ten)\\n - X placed before L or C indicates ten less, so forty is XL (ten less than fifty) and ninety is XC (ten less than a hundred)\\n - C placed before D or M indicates a hundred less, so four hundred is CD (a hundred less than five hundred) and nine hundred is CM (a hundred less than a thousand)\\n\\nTherefore, test cases like \"IL\", \"IM\" should be the same as \"LI\", \"MI\", which are 51 and 1001, respectively.\\n\\n  [1]: https://en.wikipedia.org/wiki/Roman_numerals#Roman_numeric_system"
                    },
                    {
                        "username": "orgpark",
                        "content": "Like in the other thread shows many ways to solve the problem, there is slight difference of how it is implemented. They are all O(n). I found this problem very fun and gave me a chance to learn roman numeric. Not too difficult to solve and gave me a good learning."
                    },
                    {
                        "username": "louie33",
                        "content": "The question I think should make it clearer that you will never have a number like this: IIX which logically I\\'d take to be 8 . As 8 will always be VIII. \\n\\ni.e. you will only ever have 1 char before for a subtraction and not 2 or more (like IIX). \\n\\nWithout knowledge of Roman Numerals its not that obvious ( to me anyway!)."
                    },
                    {
                        "username": "akvir",
                        "content": "Can someone explain why that condition always returns true?\\n `list_rom = [\\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\']\\nif list_given[list_given.index(i)+1] or list_given[list_given.index(i)+2] or list_given[list_given.index(i)+3] != list_rom[1] or list_rom[2]:` \\n"
                    },
                    {
                        "username": "user2873HK",
                        "content": "My code (JavaScript): \n`const symbols = s.split('');\nconst _SYMBOLS = {\n 'I': 1,\n'V': 5,\n'X': 10,\n'L': 50,\n'C': 100,\n'D': 500,\n'M': 1000,\n};\n\nlet numerals = [0];\n\nfor (let index = 0; index < symbols.length; index++) {\nconst number = _SYMBOLS[symbols[index]];\nif (number > numerals[numerals.length - 1]) {\nnumerals[numerals.length - 1] = -(numerals[numerals.length - 1]);\n}\nnumerals.push(number);\n}\n\nreturn numerals.reduce((numeral, x) => numeral + x, 0); `"
                    },
                    {
                        "username": "midhilesh1979",
                        "content": " int romanToInt(string s) {\\n       reverse(s.begin(),s.end());\\n       int c=0;\\n       for(int i=0;i<s.size();i++){\\n           switch(s[i]){\\n               case \\'I\\':  c= (i==0 || s[i-1]==\\'I\\')? c+1 : c-1;\\n                 break;\\n               case \\'V\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\')? c+5 : c-5;\\n                 break;\\n               case \\'X\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\')? c+10 : c-10;\\n                 break;\\n               case \\'L\\': c= (i==0 || s[i-1]==\\'I\\' || s[i-1]==\\'V\\' || s[i-1]==\\'X\\' || s[i-1]==\\'L\\')? c+50 : c-50;\\n                 break;\\n               case \\'C\\':c= (i==0)? c+100 : (s[i-1]==\\'D\\' || s[i-1]==\\'M\\' )? c-100 : c+100;\\n                 break;\\n            case \\'D\\': c= (i==0)? c+500 :(s[i-1]==\\'M\\' )? c-500 : c+500;\\n                 break;\\n                 case \\'M\\': c=  c+1000;\\n                 break;\\n       } \\n    }\\n    return c;\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?\\nWhat you\\'ve posted is not a tip at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "why can\\'t i implement dictionary using hashtable? i am getting null pointer exception!\\n"
                    },
                    {
                        "username": "rubayea",
                        "content": " I find this problem interesting however I try to challenge myself to answer it in Python3  since I find it comfortable to solve problems in Java. If anyone could guide me when its suitable to use the different variation of for loops : enumerate() in range() and the normal for loop . \\uD83D\\uDE01"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "we can use queue or stack using this solution, to see next or previous value "
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "It take me almost 20 minute to remove error\\uD83E\\uDD23\\uD83E\\uDD23"
                    }
                ]
            },
            {
                "id": 2028983,
                "content": [
                    {
                        "username": "jnatc1",
                        "content": "As of this writing, there are 3,999 test cases, 3,999. Um...why?"
                    },
                    {
                        "username": "yulan_he",
                        "content": "What\\'s the difference between temp = s[i] + s[i+1] in one line and temp = s[i]; temp += s[i+1] in two lines??? If I use \"temp = s[i] + s[i+1]\" then cannot pass case 3."
                    },
                    {
                        "username": "code_my_z",
                        "content": "slicing method are used for this question\\n"
                    },
                    {
                        "username": "Saiyan_Prince_09_23",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        int ans = 0, num = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            switch(s.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) \\n            ans -= num;\\n            else \\n            ans += num;\\n        }\\n        return ans;\\n    }\\n    \\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        String s=sc.nextLine();\\n        System.out.println(romanToInt(s));\\n    }\\n}\\n\\nWell i want to ask why we just multiply the condition with 4 , Is there any specific logic behind that?   If someone who knows the reason kindly reply back\\n"
                    },
                    {
                        "username": "Eniamza",
                        "content": "So interviewers are Romans mostly? "
                    },
                    {
                        "username": "arpitgzpbhu",
                        "content": "any one tell me why IIII is not a valid integer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "`IV` is 4, not `IIII`"
                    },
                    {
                        "username": "user1278K",
                        "content": "The description is wrong. It should be..\\n\\nWhen a bigger letter precedes a smaller letter, the letters are added. For example: DX, D > X, so DX = D + X = 500 + 10 = 510\\nWhen a smaller letter precedes a bigger letter, the letters are subtracted. For example: CD, C < D, so CD = D - C = 500 - 100 = 400\\nWhen a letter is repeated 2 or 3 times, they get added. For example: CCC = C + C + C = 100 + 100 + 100 = 300\\nThe same letter cannot be used more than three times in succession."
                    },
                    {
                        "username": "yash662001garg",
                        "content": "#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans =0,i;\\n        std::map<char,int> m;\\n        m[\\'I\\']=1;\\n        m[\\'V\\']=5;\\n        m[\\'X\\']=10;\\n        m[\\'L\\']=50;\\n        m[\\'C\\']=100;\\n        m[\\'D\\']=500;\\n        m[\\'M\\']=1000;\\n        for(i=0;i<s.size()-1;i++)\\n        {\\n            if((s[i]==\\'I\\' && (s[i+1]==\\'V\\' || s[i+1]==\\'X\\')) || \\n               (s[i]==\\'X\\' && (s[i+1]==\\'L\\' || s[i+1]==\\'C\\')) ||\\n               (s[i]==\\'C\\' && (s[i+1]==\\'D\\' || s[i+1]==\\'M\\')) )\\n               {\\n                    ans+= m[s[i+1]]-m[s[i]];\\n                    i++;\\n                }\\n            else\\n            ans+= m[s[i]];\\n\\n        }\\n        if (i<s.size())\\n        ans+=m[s[i]];\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "krishna_0403",
                        "content": "Use this hint from the question: Roman numerals are usually written largest to smallest from left to right"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "*************LOGIC*******\nI used hash map for this problem( its easy, and its my first problem of hash map so you can also do it.) \n\n1. There are two cases one is simple one i.e where a normal roman no. is given and 2nd case is when the current roman no. is less then the next roman no. i.e( IV, XL etc).\n\n2. so if we iterate over the string 's' and if the current roman no. is less then the next roman no. then we subtract associated roman value  from the sum, else (all roman no. are in increasing order) we sum the associated value of the roman no. to the sum.\n\n3.BOOM, our sum has the answer, now return it : )\n\n****LIKE IF YOU LIKE******"
                    }
                ]
            },
            {
                "id": 2024920,
                "content": [
                    {
                        "username": "jnatc1",
                        "content": "As of this writing, there are 3,999 test cases, 3,999. Um...why?"
                    },
                    {
                        "username": "yulan_he",
                        "content": "What\\'s the difference between temp = s[i] + s[i+1] in one line and temp = s[i]; temp += s[i+1] in two lines??? If I use \"temp = s[i] + s[i+1]\" then cannot pass case 3."
                    },
                    {
                        "username": "code_my_z",
                        "content": "slicing method are used for this question\\n"
                    },
                    {
                        "username": "Saiyan_Prince_09_23",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        int ans = 0, num = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            switch(s.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) \\n            ans -= num;\\n            else \\n            ans += num;\\n        }\\n        return ans;\\n    }\\n    \\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        String s=sc.nextLine();\\n        System.out.println(romanToInt(s));\\n    }\\n}\\n\\nWell i want to ask why we just multiply the condition with 4 , Is there any specific logic behind that?   If someone who knows the reason kindly reply back\\n"
                    },
                    {
                        "username": "Eniamza",
                        "content": "So interviewers are Romans mostly? "
                    },
                    {
                        "username": "arpitgzpbhu",
                        "content": "any one tell me why IIII is not a valid integer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "`IV` is 4, not `IIII`"
                    },
                    {
                        "username": "user1278K",
                        "content": "The description is wrong. It should be..\\n\\nWhen a bigger letter precedes a smaller letter, the letters are added. For example: DX, D > X, so DX = D + X = 500 + 10 = 510\\nWhen a smaller letter precedes a bigger letter, the letters are subtracted. For example: CD, C < D, so CD = D - C = 500 - 100 = 400\\nWhen a letter is repeated 2 or 3 times, they get added. For example: CCC = C + C + C = 100 + 100 + 100 = 300\\nThe same letter cannot be used more than three times in succession."
                    },
                    {
                        "username": "yash662001garg",
                        "content": "#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans =0,i;\\n        std::map<char,int> m;\\n        m[\\'I\\']=1;\\n        m[\\'V\\']=5;\\n        m[\\'X\\']=10;\\n        m[\\'L\\']=50;\\n        m[\\'C\\']=100;\\n        m[\\'D\\']=500;\\n        m[\\'M\\']=1000;\\n        for(i=0;i<s.size()-1;i++)\\n        {\\n            if((s[i]==\\'I\\' && (s[i+1]==\\'V\\' || s[i+1]==\\'X\\')) || \\n               (s[i]==\\'X\\' && (s[i+1]==\\'L\\' || s[i+1]==\\'C\\')) ||\\n               (s[i]==\\'C\\' && (s[i+1]==\\'D\\' || s[i+1]==\\'M\\')) )\\n               {\\n                    ans+= m[s[i+1]]-m[s[i]];\\n                    i++;\\n                }\\n            else\\n            ans+= m[s[i]];\\n\\n        }\\n        if (i<s.size())\\n        ans+=m[s[i]];\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "krishna_0403",
                        "content": "Use this hint from the question: Roman numerals are usually written largest to smallest from left to right"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "*************LOGIC*******\nI used hash map for this problem( its easy, and its my first problem of hash map so you can also do it.) \n\n1. There are two cases one is simple one i.e where a normal roman no. is given and 2nd case is when the current roman no. is less then the next roman no. i.e( IV, XL etc).\n\n2. so if we iterate over the string 's' and if the current roman no. is less then the next roman no. then we subtract associated roman value  from the sum, else (all roman no. are in increasing order) we sum the associated value of the roman no. to the sum.\n\n3.BOOM, our sum has the answer, now return it : )\n\n****LIKE IF YOU LIKE******"
                    }
                ]
            },
            {
                "id": 2022185,
                "content": [
                    {
                        "username": "jnatc1",
                        "content": "As of this writing, there are 3,999 test cases, 3,999. Um...why?"
                    },
                    {
                        "username": "yulan_he",
                        "content": "What\\'s the difference between temp = s[i] + s[i+1] in one line and temp = s[i]; temp += s[i+1] in two lines??? If I use \"temp = s[i] + s[i+1]\" then cannot pass case 3."
                    },
                    {
                        "username": "code_my_z",
                        "content": "slicing method are used for this question\\n"
                    },
                    {
                        "username": "Saiyan_Prince_09_23",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        int ans = 0, num = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            switch(s.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) \\n            ans -= num;\\n            else \\n            ans += num;\\n        }\\n        return ans;\\n    }\\n    \\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        String s=sc.nextLine();\\n        System.out.println(romanToInt(s));\\n    }\\n}\\n\\nWell i want to ask why we just multiply the condition with 4 , Is there any specific logic behind that?   If someone who knows the reason kindly reply back\\n"
                    },
                    {
                        "username": "Eniamza",
                        "content": "So interviewers are Romans mostly? "
                    },
                    {
                        "username": "arpitgzpbhu",
                        "content": "any one tell me why IIII is not a valid integer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "`IV` is 4, not `IIII`"
                    },
                    {
                        "username": "user1278K",
                        "content": "The description is wrong. It should be..\\n\\nWhen a bigger letter precedes a smaller letter, the letters are added. For example: DX, D > X, so DX = D + X = 500 + 10 = 510\\nWhen a smaller letter precedes a bigger letter, the letters are subtracted. For example: CD, C < D, so CD = D - C = 500 - 100 = 400\\nWhen a letter is repeated 2 or 3 times, they get added. For example: CCC = C + C + C = 100 + 100 + 100 = 300\\nThe same letter cannot be used more than three times in succession."
                    },
                    {
                        "username": "yash662001garg",
                        "content": "#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans =0,i;\\n        std::map<char,int> m;\\n        m[\\'I\\']=1;\\n        m[\\'V\\']=5;\\n        m[\\'X\\']=10;\\n        m[\\'L\\']=50;\\n        m[\\'C\\']=100;\\n        m[\\'D\\']=500;\\n        m[\\'M\\']=1000;\\n        for(i=0;i<s.size()-1;i++)\\n        {\\n            if((s[i]==\\'I\\' && (s[i+1]==\\'V\\' || s[i+1]==\\'X\\')) || \\n               (s[i]==\\'X\\' && (s[i+1]==\\'L\\' || s[i+1]==\\'C\\')) ||\\n               (s[i]==\\'C\\' && (s[i+1]==\\'D\\' || s[i+1]==\\'M\\')) )\\n               {\\n                    ans+= m[s[i+1]]-m[s[i]];\\n                    i++;\\n                }\\n            else\\n            ans+= m[s[i]];\\n\\n        }\\n        if (i<s.size())\\n        ans+=m[s[i]];\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "krishna_0403",
                        "content": "Use this hint from the question: Roman numerals are usually written largest to smallest from left to right"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "*************LOGIC*******\nI used hash map for this problem( its easy, and its my first problem of hash map so you can also do it.) \n\n1. There are two cases one is simple one i.e where a normal roman no. is given and 2nd case is when the current roman no. is less then the next roman no. i.e( IV, XL etc).\n\n2. so if we iterate over the string 's' and if the current roman no. is less then the next roman no. then we subtract associated roman value  from the sum, else (all roman no. are in increasing order) we sum the associated value of the roman no. to the sum.\n\n3.BOOM, our sum has the answer, now return it : )\n\n****LIKE IF YOU LIKE******"
                    }
                ]
            },
            {
                "id": 2020171,
                "content": [
                    {
                        "username": "jnatc1",
                        "content": "As of this writing, there are 3,999 test cases, 3,999. Um...why?"
                    },
                    {
                        "username": "yulan_he",
                        "content": "What\\'s the difference between temp = s[i] + s[i+1] in one line and temp = s[i]; temp += s[i+1] in two lines??? If I use \"temp = s[i] + s[i+1]\" then cannot pass case 3."
                    },
                    {
                        "username": "code_my_z",
                        "content": "slicing method are used for this question\\n"
                    },
                    {
                        "username": "Saiyan_Prince_09_23",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        int ans = 0, num = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            switch(s.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) \\n            ans -= num;\\n            else \\n            ans += num;\\n        }\\n        return ans;\\n    }\\n    \\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        String s=sc.nextLine();\\n        System.out.println(romanToInt(s));\\n    }\\n}\\n\\nWell i want to ask why we just multiply the condition with 4 , Is there any specific logic behind that?   If someone who knows the reason kindly reply back\\n"
                    },
                    {
                        "username": "Eniamza",
                        "content": "So interviewers are Romans mostly? "
                    },
                    {
                        "username": "arpitgzpbhu",
                        "content": "any one tell me why IIII is not a valid integer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "`IV` is 4, not `IIII`"
                    },
                    {
                        "username": "user1278K",
                        "content": "The description is wrong. It should be..\\n\\nWhen a bigger letter precedes a smaller letter, the letters are added. For example: DX, D > X, so DX = D + X = 500 + 10 = 510\\nWhen a smaller letter precedes a bigger letter, the letters are subtracted. For example: CD, C < D, so CD = D - C = 500 - 100 = 400\\nWhen a letter is repeated 2 or 3 times, they get added. For example: CCC = C + C + C = 100 + 100 + 100 = 300\\nThe same letter cannot be used more than three times in succession."
                    },
                    {
                        "username": "yash662001garg",
                        "content": "#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans =0,i;\\n        std::map<char,int> m;\\n        m[\\'I\\']=1;\\n        m[\\'V\\']=5;\\n        m[\\'X\\']=10;\\n        m[\\'L\\']=50;\\n        m[\\'C\\']=100;\\n        m[\\'D\\']=500;\\n        m[\\'M\\']=1000;\\n        for(i=0;i<s.size()-1;i++)\\n        {\\n            if((s[i]==\\'I\\' && (s[i+1]==\\'V\\' || s[i+1]==\\'X\\')) || \\n               (s[i]==\\'X\\' && (s[i+1]==\\'L\\' || s[i+1]==\\'C\\')) ||\\n               (s[i]==\\'C\\' && (s[i+1]==\\'D\\' || s[i+1]==\\'M\\')) )\\n               {\\n                    ans+= m[s[i+1]]-m[s[i]];\\n                    i++;\\n                }\\n            else\\n            ans+= m[s[i]];\\n\\n        }\\n        if (i<s.size())\\n        ans+=m[s[i]];\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "krishna_0403",
                        "content": "Use this hint from the question: Roman numerals are usually written largest to smallest from left to right"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "*************LOGIC*******\nI used hash map for this problem( its easy, and its my first problem of hash map so you can also do it.) \n\n1. There are two cases one is simple one i.e where a normal roman no. is given and 2nd case is when the current roman no. is less then the next roman no. i.e( IV, XL etc).\n\n2. so if we iterate over the string 's' and if the current roman no. is less then the next roman no. then we subtract associated roman value  from the sum, else (all roman no. are in increasing order) we sum the associated value of the roman no. to the sum.\n\n3.BOOM, our sum has the answer, now return it : )\n\n****LIKE IF YOU LIKE******"
                    }
                ]
            },
            {
                "id": 2013849,
                "content": [
                    {
                        "username": "jnatc1",
                        "content": "As of this writing, there are 3,999 test cases, 3,999. Um...why?"
                    },
                    {
                        "username": "yulan_he",
                        "content": "What\\'s the difference between temp = s[i] + s[i+1] in one line and temp = s[i]; temp += s[i+1] in two lines??? If I use \"temp = s[i] + s[i+1]\" then cannot pass case 3."
                    },
                    {
                        "username": "code_my_z",
                        "content": "slicing method are used for this question\\n"
                    },
                    {
                        "username": "Saiyan_Prince_09_23",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        int ans = 0, num = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            switch(s.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) \\n            ans -= num;\\n            else \\n            ans += num;\\n        }\\n        return ans;\\n    }\\n    \\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        String s=sc.nextLine();\\n        System.out.println(romanToInt(s));\\n    }\\n}\\n\\nWell i want to ask why we just multiply the condition with 4 , Is there any specific logic behind that?   If someone who knows the reason kindly reply back\\n"
                    },
                    {
                        "username": "Eniamza",
                        "content": "So interviewers are Romans mostly? "
                    },
                    {
                        "username": "arpitgzpbhu",
                        "content": "any one tell me why IIII is not a valid integer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "`IV` is 4, not `IIII`"
                    },
                    {
                        "username": "user1278K",
                        "content": "The description is wrong. It should be..\\n\\nWhen a bigger letter precedes a smaller letter, the letters are added. For example: DX, D > X, so DX = D + X = 500 + 10 = 510\\nWhen a smaller letter precedes a bigger letter, the letters are subtracted. For example: CD, C < D, so CD = D - C = 500 - 100 = 400\\nWhen a letter is repeated 2 or 3 times, they get added. For example: CCC = C + C + C = 100 + 100 + 100 = 300\\nThe same letter cannot be used more than three times in succession."
                    },
                    {
                        "username": "yash662001garg",
                        "content": "#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans =0,i;\\n        std::map<char,int> m;\\n        m[\\'I\\']=1;\\n        m[\\'V\\']=5;\\n        m[\\'X\\']=10;\\n        m[\\'L\\']=50;\\n        m[\\'C\\']=100;\\n        m[\\'D\\']=500;\\n        m[\\'M\\']=1000;\\n        for(i=0;i<s.size()-1;i++)\\n        {\\n            if((s[i]==\\'I\\' && (s[i+1]==\\'V\\' || s[i+1]==\\'X\\')) || \\n               (s[i]==\\'X\\' && (s[i+1]==\\'L\\' || s[i+1]==\\'C\\')) ||\\n               (s[i]==\\'C\\' && (s[i+1]==\\'D\\' || s[i+1]==\\'M\\')) )\\n               {\\n                    ans+= m[s[i+1]]-m[s[i]];\\n                    i++;\\n                }\\n            else\\n            ans+= m[s[i]];\\n\\n        }\\n        if (i<s.size())\\n        ans+=m[s[i]];\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "krishna_0403",
                        "content": "Use this hint from the question: Roman numerals are usually written largest to smallest from left to right"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "*************LOGIC*******\nI used hash map for this problem( its easy, and its my first problem of hash map so you can also do it.) \n\n1. There are two cases one is simple one i.e where a normal roman no. is given and 2nd case is when the current roman no. is less then the next roman no. i.e( IV, XL etc).\n\n2. so if we iterate over the string 's' and if the current roman no. is less then the next roman no. then we subtract associated roman value  from the sum, else (all roman no. are in increasing order) we sum the associated value of the roman no. to the sum.\n\n3.BOOM, our sum has the answer, now return it : )\n\n****LIKE IF YOU LIKE******"
                    }
                ]
            },
            {
                "id": 1998795,
                "content": [
                    {
                        "username": "jnatc1",
                        "content": "As of this writing, there are 3,999 test cases, 3,999. Um...why?"
                    },
                    {
                        "username": "yulan_he",
                        "content": "What\\'s the difference between temp = s[i] + s[i+1] in one line and temp = s[i]; temp += s[i+1] in two lines??? If I use \"temp = s[i] + s[i+1]\" then cannot pass case 3."
                    },
                    {
                        "username": "code_my_z",
                        "content": "slicing method are used for this question\\n"
                    },
                    {
                        "username": "Saiyan_Prince_09_23",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        int ans = 0, num = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            switch(s.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) \\n            ans -= num;\\n            else \\n            ans += num;\\n        }\\n        return ans;\\n    }\\n    \\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        String s=sc.nextLine();\\n        System.out.println(romanToInt(s));\\n    }\\n}\\n\\nWell i want to ask why we just multiply the condition with 4 , Is there any specific logic behind that?   If someone who knows the reason kindly reply back\\n"
                    },
                    {
                        "username": "Eniamza",
                        "content": "So interviewers are Romans mostly? "
                    },
                    {
                        "username": "arpitgzpbhu",
                        "content": "any one tell me why IIII is not a valid integer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "`IV` is 4, not `IIII`"
                    },
                    {
                        "username": "user1278K",
                        "content": "The description is wrong. It should be..\\n\\nWhen a bigger letter precedes a smaller letter, the letters are added. For example: DX, D > X, so DX = D + X = 500 + 10 = 510\\nWhen a smaller letter precedes a bigger letter, the letters are subtracted. For example: CD, C < D, so CD = D - C = 500 - 100 = 400\\nWhen a letter is repeated 2 or 3 times, they get added. For example: CCC = C + C + C = 100 + 100 + 100 = 300\\nThe same letter cannot be used more than three times in succession."
                    },
                    {
                        "username": "yash662001garg",
                        "content": "#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans =0,i;\\n        std::map<char,int> m;\\n        m[\\'I\\']=1;\\n        m[\\'V\\']=5;\\n        m[\\'X\\']=10;\\n        m[\\'L\\']=50;\\n        m[\\'C\\']=100;\\n        m[\\'D\\']=500;\\n        m[\\'M\\']=1000;\\n        for(i=0;i<s.size()-1;i++)\\n        {\\n            if((s[i]==\\'I\\' && (s[i+1]==\\'V\\' || s[i+1]==\\'X\\')) || \\n               (s[i]==\\'X\\' && (s[i+1]==\\'L\\' || s[i+1]==\\'C\\')) ||\\n               (s[i]==\\'C\\' && (s[i+1]==\\'D\\' || s[i+1]==\\'M\\')) )\\n               {\\n                    ans+= m[s[i+1]]-m[s[i]];\\n                    i++;\\n                }\\n            else\\n            ans+= m[s[i]];\\n\\n        }\\n        if (i<s.size())\\n        ans+=m[s[i]];\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "krishna_0403",
                        "content": "Use this hint from the question: Roman numerals are usually written largest to smallest from left to right"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "*************LOGIC*******\nI used hash map for this problem( its easy, and its my first problem of hash map so you can also do it.) \n\n1. There are two cases one is simple one i.e where a normal roman no. is given and 2nd case is when the current roman no. is less then the next roman no. i.e( IV, XL etc).\n\n2. so if we iterate over the string 's' and if the current roman no. is less then the next roman no. then we subtract associated roman value  from the sum, else (all roman no. are in increasing order) we sum the associated value of the roman no. to the sum.\n\n3.BOOM, our sum has the answer, now return it : )\n\n****LIKE IF YOU LIKE******"
                    }
                ]
            },
            {
                "id": 1994719,
                "content": [
                    {
                        "username": "jnatc1",
                        "content": "As of this writing, there are 3,999 test cases, 3,999. Um...why?"
                    },
                    {
                        "username": "yulan_he",
                        "content": "What\\'s the difference between temp = s[i] + s[i+1] in one line and temp = s[i]; temp += s[i+1] in two lines??? If I use \"temp = s[i] + s[i+1]\" then cannot pass case 3."
                    },
                    {
                        "username": "code_my_z",
                        "content": "slicing method are used for this question\\n"
                    },
                    {
                        "username": "Saiyan_Prince_09_23",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        int ans = 0, num = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            switch(s.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) \\n            ans -= num;\\n            else \\n            ans += num;\\n        }\\n        return ans;\\n    }\\n    \\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        String s=sc.nextLine();\\n        System.out.println(romanToInt(s));\\n    }\\n}\\n\\nWell i want to ask why we just multiply the condition with 4 , Is there any specific logic behind that?   If someone who knows the reason kindly reply back\\n"
                    },
                    {
                        "username": "Eniamza",
                        "content": "So interviewers are Romans mostly? "
                    },
                    {
                        "username": "arpitgzpbhu",
                        "content": "any one tell me why IIII is not a valid integer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "`IV` is 4, not `IIII`"
                    },
                    {
                        "username": "user1278K",
                        "content": "The description is wrong. It should be..\\n\\nWhen a bigger letter precedes a smaller letter, the letters are added. For example: DX, D > X, so DX = D + X = 500 + 10 = 510\\nWhen a smaller letter precedes a bigger letter, the letters are subtracted. For example: CD, C < D, so CD = D - C = 500 - 100 = 400\\nWhen a letter is repeated 2 or 3 times, they get added. For example: CCC = C + C + C = 100 + 100 + 100 = 300\\nThe same letter cannot be used more than three times in succession."
                    },
                    {
                        "username": "yash662001garg",
                        "content": "#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans =0,i;\\n        std::map<char,int> m;\\n        m[\\'I\\']=1;\\n        m[\\'V\\']=5;\\n        m[\\'X\\']=10;\\n        m[\\'L\\']=50;\\n        m[\\'C\\']=100;\\n        m[\\'D\\']=500;\\n        m[\\'M\\']=1000;\\n        for(i=0;i<s.size()-1;i++)\\n        {\\n            if((s[i]==\\'I\\' && (s[i+1]==\\'V\\' || s[i+1]==\\'X\\')) || \\n               (s[i]==\\'X\\' && (s[i+1]==\\'L\\' || s[i+1]==\\'C\\')) ||\\n               (s[i]==\\'C\\' && (s[i+1]==\\'D\\' || s[i+1]==\\'M\\')) )\\n               {\\n                    ans+= m[s[i+1]]-m[s[i]];\\n                    i++;\\n                }\\n            else\\n            ans+= m[s[i]];\\n\\n        }\\n        if (i<s.size())\\n        ans+=m[s[i]];\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "krishna_0403",
                        "content": "Use this hint from the question: Roman numerals are usually written largest to smallest from left to right"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "*************LOGIC*******\nI used hash map for this problem( its easy, and its my first problem of hash map so you can also do it.) \n\n1. There are two cases one is simple one i.e where a normal roman no. is given and 2nd case is when the current roman no. is less then the next roman no. i.e( IV, XL etc).\n\n2. so if we iterate over the string 's' and if the current roman no. is less then the next roman no. then we subtract associated roman value  from the sum, else (all roman no. are in increasing order) we sum the associated value of the roman no. to the sum.\n\n3.BOOM, our sum has the answer, now return it : )\n\n****LIKE IF YOU LIKE******"
                    }
                ]
            },
            {
                "id": 1993486,
                "content": [
                    {
                        "username": "jnatc1",
                        "content": "As of this writing, there are 3,999 test cases, 3,999. Um...why?"
                    },
                    {
                        "username": "yulan_he",
                        "content": "What\\'s the difference between temp = s[i] + s[i+1] in one line and temp = s[i]; temp += s[i+1] in two lines??? If I use \"temp = s[i] + s[i+1]\" then cannot pass case 3."
                    },
                    {
                        "username": "code_my_z",
                        "content": "slicing method are used for this question\\n"
                    },
                    {
                        "username": "Saiyan_Prince_09_23",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        int ans = 0, num = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            switch(s.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) \\n            ans -= num;\\n            else \\n            ans += num;\\n        }\\n        return ans;\\n    }\\n    \\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        String s=sc.nextLine();\\n        System.out.println(romanToInt(s));\\n    }\\n}\\n\\nWell i want to ask why we just multiply the condition with 4 , Is there any specific logic behind that?   If someone who knows the reason kindly reply back\\n"
                    },
                    {
                        "username": "Eniamza",
                        "content": "So interviewers are Romans mostly? "
                    },
                    {
                        "username": "arpitgzpbhu",
                        "content": "any one tell me why IIII is not a valid integer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "`IV` is 4, not `IIII`"
                    },
                    {
                        "username": "user1278K",
                        "content": "The description is wrong. It should be..\\n\\nWhen a bigger letter precedes a smaller letter, the letters are added. For example: DX, D > X, so DX = D + X = 500 + 10 = 510\\nWhen a smaller letter precedes a bigger letter, the letters are subtracted. For example: CD, C < D, so CD = D - C = 500 - 100 = 400\\nWhen a letter is repeated 2 or 3 times, they get added. For example: CCC = C + C + C = 100 + 100 + 100 = 300\\nThe same letter cannot be used more than three times in succession."
                    },
                    {
                        "username": "yash662001garg",
                        "content": "#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans =0,i;\\n        std::map<char,int> m;\\n        m[\\'I\\']=1;\\n        m[\\'V\\']=5;\\n        m[\\'X\\']=10;\\n        m[\\'L\\']=50;\\n        m[\\'C\\']=100;\\n        m[\\'D\\']=500;\\n        m[\\'M\\']=1000;\\n        for(i=0;i<s.size()-1;i++)\\n        {\\n            if((s[i]==\\'I\\' && (s[i+1]==\\'V\\' || s[i+1]==\\'X\\')) || \\n               (s[i]==\\'X\\' && (s[i+1]==\\'L\\' || s[i+1]==\\'C\\')) ||\\n               (s[i]==\\'C\\' && (s[i+1]==\\'D\\' || s[i+1]==\\'M\\')) )\\n               {\\n                    ans+= m[s[i+1]]-m[s[i]];\\n                    i++;\\n                }\\n            else\\n            ans+= m[s[i]];\\n\\n        }\\n        if (i<s.size())\\n        ans+=m[s[i]];\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "krishna_0403",
                        "content": "Use this hint from the question: Roman numerals are usually written largest to smallest from left to right"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "*************LOGIC*******\nI used hash map for this problem( its easy, and its my first problem of hash map so you can also do it.) \n\n1. There are two cases one is simple one i.e where a normal roman no. is given and 2nd case is when the current roman no. is less then the next roman no. i.e( IV, XL etc).\n\n2. so if we iterate over the string 's' and if the current roman no. is less then the next roman no. then we subtract associated roman value  from the sum, else (all roman no. are in increasing order) we sum the associated value of the roman no. to the sum.\n\n3.BOOM, our sum has the answer, now return it : )\n\n****LIKE IF YOU LIKE******"
                    }
                ]
            },
            {
                "id": 1993050,
                "content": [
                    {
                        "username": "jnatc1",
                        "content": "As of this writing, there are 3,999 test cases, 3,999. Um...why?"
                    },
                    {
                        "username": "yulan_he",
                        "content": "What\\'s the difference between temp = s[i] + s[i+1] in one line and temp = s[i]; temp += s[i+1] in two lines??? If I use \"temp = s[i] + s[i+1]\" then cannot pass case 3."
                    },
                    {
                        "username": "code_my_z",
                        "content": "slicing method are used for this question\\n"
                    },
                    {
                        "username": "Saiyan_Prince_09_23",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        int ans = 0, num = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            switch(s.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) \\n            ans -= num;\\n            else \\n            ans += num;\\n        }\\n        return ans;\\n    }\\n    \\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        String s=sc.nextLine();\\n        System.out.println(romanToInt(s));\\n    }\\n}\\n\\nWell i want to ask why we just multiply the condition with 4 , Is there any specific logic behind that?   If someone who knows the reason kindly reply back\\n"
                    },
                    {
                        "username": "Eniamza",
                        "content": "So interviewers are Romans mostly? "
                    },
                    {
                        "username": "arpitgzpbhu",
                        "content": "any one tell me why IIII is not a valid integer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "`IV` is 4, not `IIII`"
                    },
                    {
                        "username": "user1278K",
                        "content": "The description is wrong. It should be..\\n\\nWhen a bigger letter precedes a smaller letter, the letters are added. For example: DX, D > X, so DX = D + X = 500 + 10 = 510\\nWhen a smaller letter precedes a bigger letter, the letters are subtracted. For example: CD, C < D, so CD = D - C = 500 - 100 = 400\\nWhen a letter is repeated 2 or 3 times, they get added. For example: CCC = C + C + C = 100 + 100 + 100 = 300\\nThe same letter cannot be used more than three times in succession."
                    },
                    {
                        "username": "yash662001garg",
                        "content": "#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans =0,i;\\n        std::map<char,int> m;\\n        m[\\'I\\']=1;\\n        m[\\'V\\']=5;\\n        m[\\'X\\']=10;\\n        m[\\'L\\']=50;\\n        m[\\'C\\']=100;\\n        m[\\'D\\']=500;\\n        m[\\'M\\']=1000;\\n        for(i=0;i<s.size()-1;i++)\\n        {\\n            if((s[i]==\\'I\\' && (s[i+1]==\\'V\\' || s[i+1]==\\'X\\')) || \\n               (s[i]==\\'X\\' && (s[i+1]==\\'L\\' || s[i+1]==\\'C\\')) ||\\n               (s[i]==\\'C\\' && (s[i+1]==\\'D\\' || s[i+1]==\\'M\\')) )\\n               {\\n                    ans+= m[s[i+1]]-m[s[i]];\\n                    i++;\\n                }\\n            else\\n            ans+= m[s[i]];\\n\\n        }\\n        if (i<s.size())\\n        ans+=m[s[i]];\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "krishna_0403",
                        "content": "Use this hint from the question: Roman numerals are usually written largest to smallest from left to right"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "*************LOGIC*******\nI used hash map for this problem( its easy, and its my first problem of hash map so you can also do it.) \n\n1. There are two cases one is simple one i.e where a normal roman no. is given and 2nd case is when the current roman no. is less then the next roman no. i.e( IV, XL etc).\n\n2. so if we iterate over the string 's' and if the current roman no. is less then the next roman no. then we subtract associated roman value  from the sum, else (all roman no. are in increasing order) we sum the associated value of the roman no. to the sum.\n\n3.BOOM, our sum has the answer, now return it : )\n\n****LIKE IF YOU LIKE******"
                    }
                ]
            },
            {
                "id": 1991874,
                "content": [
                    {
                        "username": "jnatc1",
                        "content": "As of this writing, there are 3,999 test cases, 3,999. Um...why?"
                    },
                    {
                        "username": "yulan_he",
                        "content": "What\\'s the difference between temp = s[i] + s[i+1] in one line and temp = s[i]; temp += s[i+1] in two lines??? If I use \"temp = s[i] + s[i+1]\" then cannot pass case 3."
                    },
                    {
                        "username": "code_my_z",
                        "content": "slicing method are used for this question\\n"
                    },
                    {
                        "username": "Saiyan_Prince_09_23",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        int ans = 0, num = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            switch(s.charAt(i)) {\\n                case \\'I\\': num = 1; break;\\n                case \\'V\\': num = 5; break;\\n                case \\'X\\': num = 10; break;\\n                case \\'L\\': num = 50; break;\\n                case \\'C\\': num = 100; break;\\n                case \\'D\\': num = 500; break;\\n                case \\'M\\': num = 1000; break;\\n            }\\n            if (4 * num < ans) \\n            ans -= num;\\n            else \\n            ans += num;\\n        }\\n        return ans;\\n    }\\n    \\n    public static void main(String args[]){\\n        Scanner sc=new Scanner(System.in);\\n        String s=sc.nextLine();\\n        System.out.println(romanToInt(s));\\n    }\\n}\\n\\nWell i want to ask why we just multiply the condition with 4 , Is there any specific logic behind that?   If someone who knows the reason kindly reply back\\n"
                    },
                    {
                        "username": "Eniamza",
                        "content": "So interviewers are Romans mostly? "
                    },
                    {
                        "username": "arpitgzpbhu",
                        "content": "any one tell me why IIII is not a valid integer"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "`IV` is 4, not `IIII`"
                    },
                    {
                        "username": "user1278K",
                        "content": "The description is wrong. It should be..\\n\\nWhen a bigger letter precedes a smaller letter, the letters are added. For example: DX, D > X, so DX = D + X = 500 + 10 = 510\\nWhen a smaller letter precedes a bigger letter, the letters are subtracted. For example: CD, C < D, so CD = D - C = 500 - 100 = 400\\nWhen a letter is repeated 2 or 3 times, they get added. For example: CCC = C + C + C = 100 + 100 + 100 = 300\\nThe same letter cannot be used more than three times in succession."
                    },
                    {
                        "username": "yash662001garg",
                        "content": "#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans =0,i;\\n        std::map<char,int> m;\\n        m[\\'I\\']=1;\\n        m[\\'V\\']=5;\\n        m[\\'X\\']=10;\\n        m[\\'L\\']=50;\\n        m[\\'C\\']=100;\\n        m[\\'D\\']=500;\\n        m[\\'M\\']=1000;\\n        for(i=0;i<s.size()-1;i++)\\n        {\\n            if((s[i]==\\'I\\' && (s[i+1]==\\'V\\' || s[i+1]==\\'X\\')) || \\n               (s[i]==\\'X\\' && (s[i+1]==\\'L\\' || s[i+1]==\\'C\\')) ||\\n               (s[i]==\\'C\\' && (s[i+1]==\\'D\\' || s[i+1]==\\'M\\')) )\\n               {\\n                    ans+= m[s[i+1]]-m[s[i]];\\n                    i++;\\n                }\\n            else\\n            ans+= m[s[i]];\\n\\n        }\\n        if (i<s.size())\\n        ans+=m[s[i]];\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "krishna_0403",
                        "content": "Use this hint from the question: Roman numerals are usually written largest to smallest from left to right"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "*************LOGIC*******\nI used hash map for this problem( its easy, and its my first problem of hash map so you can also do it.) \n\n1. There are two cases one is simple one i.e where a normal roman no. is given and 2nd case is when the current roman no. is less then the next roman no. i.e( IV, XL etc).\n\n2. so if we iterate over the string 's' and if the current roman no. is less then the next roman no. then we subtract associated roman value  from the sum, else (all roman no. are in increasing order) we sum the associated value of the roman no. to the sum.\n\n3.BOOM, our sum has the answer, now return it : )\n\n****LIKE IF YOU LIKE******"
                    }
                ]
            },
            {
                "id": 1991165,
                "content": [
                    {
                        "username": "user1278K",
                        "content": "I dont know why leetcode is giving me the error , though it is running fine in other editor\\n\\nimport java.util.*;\\nimport java.lang.*;\\nimport java.io.*;\\n\\n// The main method must be in a class named \"Main\".\\nclass Main {\\n    public static void main(String[] args) {\\n        System.out.println(romanToInt(\"MCMXCIV\"));\\n        \\n    }\\n    \\n     public static int romanToInt(String s) {\\n        \\n        int sum=0;\\n\\n        // initialize a hashmap\\n        Map<String,Integer> hashmap= new HashMap<String,Integer>();\\n        hashmap.put(\"I\",1);\\n        hashmap.put(\"V\",5);\\n        hashmap.put(\"X\",10);\\n        hashmap.put(\"L\",50);\\n        hashmap.put(\"C\",100);\\n        hashmap.put(\"D\",500);\\n        hashmap.put(\"M\",1000);\\n\\n        // iterate the loop \\n        int i=0; \\n        while (i<s.length()){\\n             String c= \"\"+s.charAt(i);\\n            if (c.equals(\"C\") || c.equals(\"X\") || c.equals(\"I\")){\\n              \\n              c= \"\"+s.charAt(i)+s.charAt(i+1); //CM, XC ,IV\\n             int value= hashmap.get(\"\"+s.charAt(i+1)) - hashmap.get(\"\"+s.charAt(i));\\n            sum =sum + value; // 1000+ 900, 1000+ 900+ 90,  1000+ 900+ 90 +4\\n               i =i+2;\\n            }\\n            else\\n          {\\n             c= \"\"+s.charAt(i);\\n            sum =sum + hashmap.get(c); // 1000\\n            i=i+1;\\n          } \\n         \\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "This is the best beginner questions to start with. Very easy with just logical skills required. Roman are written in descending order and if written in ascending then we subtract the value from the total."
                    },
                    {
                        "username": "user3974tS",
                        "content": "Here is my solution in C#\n`public class Solution {\n    public int RomanToInt(string s) {\n        var romanSymbols = new Dictionary<char, int>() {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100 {'D', 500}, {'M', 1000} };\n\n        int sum = 0;\n        for(int i = 0; i < s.Length; i++){\n            if (s.Length == 1) {\n                sum += romanSymbols[s[i]];\n            }\n            else if (i < s.Length - 1 && s.Length != 1){\n                if (romanSymbols[s[i]] > romanSymbols[s[i + 1]] || romanSymbols[s[i]] == romanSymbols[s[i + 1]]) \n                sum += romanSymbols[s[i]];\n            else {\n        sum += romanSymbols[s[i + 1]] - romanSymbols[s[i]];\n        i++;\n        } \n    } \n    else {\n        if (romanSymbols[s[i]] < romanSymbols[s[i - 1]] || romanSymbols[s[i]] == romanSymbols[s[i - 1]]) \n            sum += romanSymbols[s[i]];\n    }\n        }\n        return sum;\n    } }` "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cayyanraj",
                        "content": "what was it complexity?\\n"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "The question would have become more challenging if we were asked to return -1 if the given roman number violated any rule mentioned in question description."
                    },
                    {
                        "username": "askhat1myrzabekov",
                        "content": "why \"MCMXCIV\" is 2216 ? I searched at Google and it is 1994"
                    },
                    {
                        "username": "maurya_laxmi929",
                        "content": "I started my coding Journey on LeetCode with this problem :)"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "#include <iostream>\\n#include <unordered_map>\\n\\nvoid printNewLine() {\\n    std::cout << \"\\\\n\";\\n}\\n\\nint main() {\\n    std::unordered_map<char, int> mStorage = {\\n        {\\'I\\', 1}, {\\'V\\', 5}, {\\'X\\', 10}, {\\'L\\', 50}, {\\'C\\', 100}, {\\'D\\', 500}, {\\'M\\', 1000}\\n    };\\n    std::string sInput(\"\");\\n    int nYear = 0;\\n    int prevValue = 0;\\n\\n    printNewLine();\\n    std::cout << \"---Given storage of details---\" << std::endl;\\n    for(const auto& pair : mStorage){\\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\\n    }\\n    printNewLine();\\n    std::cout << \"---String insertion---\" << std::endl;\\n    std::cout << \"Input Roman numeral: \";\\n    std::getline(std::cin, sInput);\\n    printNewLine();\\n\\n    for (int i = sInput.size() - 1; i >= 0; --i) {\\n        char c = sInput[i];\\n        auto iter = mStorage.find(c);\\n        if (iter != mStorage.end()) {\\n            int currValue = iter->second;\\n            if (currValue < prevValue) {\\n                nYear -= currValue;\\n            }else {\\n                nYear += currValue;\\n                prevValue = currValue;\\n            }\\n        } else {\\n            std::cout << \"---Results---\";\\n            std::cout << \"Invalid Roman numeral: \" << c << std::endl;\\n            return 0;\\n        }\\n    }\\n    std::cout << \"---Results---\" << std::endl;\\n    std::cout << sInput << \" refers to: \" << nYear << \" after calculation.\" << std::endl;\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user6303E",
                        "content": "Java peeps enjoy !\n `your inline code...\n\nclass Solution {\n\n    public int romanToInt(String s) {\n        int ans = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'I') ans += 1;\n            if (s.charAt(i) == 'V') ans += 5;\n            if (s.charAt(i) == 'X') ans += 10;\n            if (s.charAt(i) == 'L') ans += 50;\n            if (s.charAt(i) == 'C') ans += 100;\n            if (s.charAt(i) == 'D') ans += 500;\n            if (s.charAt(i) == 'M') ans += 1000;\n        }\n        if (s.contains(\"IV\") || s.contains(\"IX\")) ans -= 2 * 1;\n        if (s.contains(\"XC\") || s.contains(\"XL\")) ans -= 2 * 10;\n        if (s.contains(\"CD\") || s.contains(\"CM\")) ans -= 2 * 100;\n\n        return ans;\n    }\n}\n\nyour inline code...`\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mxmln",
                        "content": "why additional functions aren\\'t working? \\n"
                    }
                ]
            },
            {
                "id": 1989011,
                "content": [
                    {
                        "username": "user1278K",
                        "content": "I dont know why leetcode is giving me the error , though it is running fine in other editor\\n\\nimport java.util.*;\\nimport java.lang.*;\\nimport java.io.*;\\n\\n// The main method must be in a class named \"Main\".\\nclass Main {\\n    public static void main(String[] args) {\\n        System.out.println(romanToInt(\"MCMXCIV\"));\\n        \\n    }\\n    \\n     public static int romanToInt(String s) {\\n        \\n        int sum=0;\\n\\n        // initialize a hashmap\\n        Map<String,Integer> hashmap= new HashMap<String,Integer>();\\n        hashmap.put(\"I\",1);\\n        hashmap.put(\"V\",5);\\n        hashmap.put(\"X\",10);\\n        hashmap.put(\"L\",50);\\n        hashmap.put(\"C\",100);\\n        hashmap.put(\"D\",500);\\n        hashmap.put(\"M\",1000);\\n\\n        // iterate the loop \\n        int i=0; \\n        while (i<s.length()){\\n             String c= \"\"+s.charAt(i);\\n            if (c.equals(\"C\") || c.equals(\"X\") || c.equals(\"I\")){\\n              \\n              c= \"\"+s.charAt(i)+s.charAt(i+1); //CM, XC ,IV\\n             int value= hashmap.get(\"\"+s.charAt(i+1)) - hashmap.get(\"\"+s.charAt(i));\\n            sum =sum + value; // 1000+ 900, 1000+ 900+ 90,  1000+ 900+ 90 +4\\n               i =i+2;\\n            }\\n            else\\n          {\\n             c= \"\"+s.charAt(i);\\n            sum =sum + hashmap.get(c); // 1000\\n            i=i+1;\\n          } \\n         \\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "This is the best beginner questions to start with. Very easy with just logical skills required. Roman are written in descending order and if written in ascending then we subtract the value from the total."
                    },
                    {
                        "username": "user3974tS",
                        "content": "Here is my solution in C#\n`public class Solution {\n    public int RomanToInt(string s) {\n        var romanSymbols = new Dictionary<char, int>() {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100 {'D', 500}, {'M', 1000} };\n\n        int sum = 0;\n        for(int i = 0; i < s.Length; i++){\n            if (s.Length == 1) {\n                sum += romanSymbols[s[i]];\n            }\n            else if (i < s.Length - 1 && s.Length != 1){\n                if (romanSymbols[s[i]] > romanSymbols[s[i + 1]] || romanSymbols[s[i]] == romanSymbols[s[i + 1]]) \n                sum += romanSymbols[s[i]];\n            else {\n        sum += romanSymbols[s[i + 1]] - romanSymbols[s[i]];\n        i++;\n        } \n    } \n    else {\n        if (romanSymbols[s[i]] < romanSymbols[s[i - 1]] || romanSymbols[s[i]] == romanSymbols[s[i - 1]]) \n            sum += romanSymbols[s[i]];\n    }\n        }\n        return sum;\n    } }` "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cayyanraj",
                        "content": "what was it complexity?\\n"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "The question would have become more challenging if we were asked to return -1 if the given roman number violated any rule mentioned in question description."
                    },
                    {
                        "username": "askhat1myrzabekov",
                        "content": "why \"MCMXCIV\" is 2216 ? I searched at Google and it is 1994"
                    },
                    {
                        "username": "maurya_laxmi929",
                        "content": "I started my coding Journey on LeetCode with this problem :)"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "#include <iostream>\\n#include <unordered_map>\\n\\nvoid printNewLine() {\\n    std::cout << \"\\\\n\";\\n}\\n\\nint main() {\\n    std::unordered_map<char, int> mStorage = {\\n        {\\'I\\', 1}, {\\'V\\', 5}, {\\'X\\', 10}, {\\'L\\', 50}, {\\'C\\', 100}, {\\'D\\', 500}, {\\'M\\', 1000}\\n    };\\n    std::string sInput(\"\");\\n    int nYear = 0;\\n    int prevValue = 0;\\n\\n    printNewLine();\\n    std::cout << \"---Given storage of details---\" << std::endl;\\n    for(const auto& pair : mStorage){\\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\\n    }\\n    printNewLine();\\n    std::cout << \"---String insertion---\" << std::endl;\\n    std::cout << \"Input Roman numeral: \";\\n    std::getline(std::cin, sInput);\\n    printNewLine();\\n\\n    for (int i = sInput.size() - 1; i >= 0; --i) {\\n        char c = sInput[i];\\n        auto iter = mStorage.find(c);\\n        if (iter != mStorage.end()) {\\n            int currValue = iter->second;\\n            if (currValue < prevValue) {\\n                nYear -= currValue;\\n            }else {\\n                nYear += currValue;\\n                prevValue = currValue;\\n            }\\n        } else {\\n            std::cout << \"---Results---\";\\n            std::cout << \"Invalid Roman numeral: \" << c << std::endl;\\n            return 0;\\n        }\\n    }\\n    std::cout << \"---Results---\" << std::endl;\\n    std::cout << sInput << \" refers to: \" << nYear << \" after calculation.\" << std::endl;\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user6303E",
                        "content": "Java peeps enjoy !\n `your inline code...\n\nclass Solution {\n\n    public int romanToInt(String s) {\n        int ans = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'I') ans += 1;\n            if (s.charAt(i) == 'V') ans += 5;\n            if (s.charAt(i) == 'X') ans += 10;\n            if (s.charAt(i) == 'L') ans += 50;\n            if (s.charAt(i) == 'C') ans += 100;\n            if (s.charAt(i) == 'D') ans += 500;\n            if (s.charAt(i) == 'M') ans += 1000;\n        }\n        if (s.contains(\"IV\") || s.contains(\"IX\")) ans -= 2 * 1;\n        if (s.contains(\"XC\") || s.contains(\"XL\")) ans -= 2 * 10;\n        if (s.contains(\"CD\") || s.contains(\"CM\")) ans -= 2 * 100;\n\n        return ans;\n    }\n}\n\nyour inline code...`\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mxmln",
                        "content": "why additional functions aren\\'t working? \\n"
                    }
                ]
            },
            {
                "id": 1976865,
                "content": [
                    {
                        "username": "user1278K",
                        "content": "I dont know why leetcode is giving me the error , though it is running fine in other editor\\n\\nimport java.util.*;\\nimport java.lang.*;\\nimport java.io.*;\\n\\n// The main method must be in a class named \"Main\".\\nclass Main {\\n    public static void main(String[] args) {\\n        System.out.println(romanToInt(\"MCMXCIV\"));\\n        \\n    }\\n    \\n     public static int romanToInt(String s) {\\n        \\n        int sum=0;\\n\\n        // initialize a hashmap\\n        Map<String,Integer> hashmap= new HashMap<String,Integer>();\\n        hashmap.put(\"I\",1);\\n        hashmap.put(\"V\",5);\\n        hashmap.put(\"X\",10);\\n        hashmap.put(\"L\",50);\\n        hashmap.put(\"C\",100);\\n        hashmap.put(\"D\",500);\\n        hashmap.put(\"M\",1000);\\n\\n        // iterate the loop \\n        int i=0; \\n        while (i<s.length()){\\n             String c= \"\"+s.charAt(i);\\n            if (c.equals(\"C\") || c.equals(\"X\") || c.equals(\"I\")){\\n              \\n              c= \"\"+s.charAt(i)+s.charAt(i+1); //CM, XC ,IV\\n             int value= hashmap.get(\"\"+s.charAt(i+1)) - hashmap.get(\"\"+s.charAt(i));\\n            sum =sum + value; // 1000+ 900, 1000+ 900+ 90,  1000+ 900+ 90 +4\\n               i =i+2;\\n            }\\n            else\\n          {\\n             c= \"\"+s.charAt(i);\\n            sum =sum + hashmap.get(c); // 1000\\n            i=i+1;\\n          } \\n         \\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "This is the best beginner questions to start with. Very easy with just logical skills required. Roman are written in descending order and if written in ascending then we subtract the value from the total."
                    },
                    {
                        "username": "user3974tS",
                        "content": "Here is my solution in C#\n`public class Solution {\n    public int RomanToInt(string s) {\n        var romanSymbols = new Dictionary<char, int>() {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100 {'D', 500}, {'M', 1000} };\n\n        int sum = 0;\n        for(int i = 0; i < s.Length; i++){\n            if (s.Length == 1) {\n                sum += romanSymbols[s[i]];\n            }\n            else if (i < s.Length - 1 && s.Length != 1){\n                if (romanSymbols[s[i]] > romanSymbols[s[i + 1]] || romanSymbols[s[i]] == romanSymbols[s[i + 1]]) \n                sum += romanSymbols[s[i]];\n            else {\n        sum += romanSymbols[s[i + 1]] - romanSymbols[s[i]];\n        i++;\n        } \n    } \n    else {\n        if (romanSymbols[s[i]] < romanSymbols[s[i - 1]] || romanSymbols[s[i]] == romanSymbols[s[i - 1]]) \n            sum += romanSymbols[s[i]];\n    }\n        }\n        return sum;\n    } }` "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cayyanraj",
                        "content": "what was it complexity?\\n"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "The question would have become more challenging if we were asked to return -1 if the given roman number violated any rule mentioned in question description."
                    },
                    {
                        "username": "askhat1myrzabekov",
                        "content": "why \"MCMXCIV\" is 2216 ? I searched at Google and it is 1994"
                    },
                    {
                        "username": "maurya_laxmi929",
                        "content": "I started my coding Journey on LeetCode with this problem :)"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "#include <iostream>\\n#include <unordered_map>\\n\\nvoid printNewLine() {\\n    std::cout << \"\\\\n\";\\n}\\n\\nint main() {\\n    std::unordered_map<char, int> mStorage = {\\n        {\\'I\\', 1}, {\\'V\\', 5}, {\\'X\\', 10}, {\\'L\\', 50}, {\\'C\\', 100}, {\\'D\\', 500}, {\\'M\\', 1000}\\n    };\\n    std::string sInput(\"\");\\n    int nYear = 0;\\n    int prevValue = 0;\\n\\n    printNewLine();\\n    std::cout << \"---Given storage of details---\" << std::endl;\\n    for(const auto& pair : mStorage){\\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\\n    }\\n    printNewLine();\\n    std::cout << \"---String insertion---\" << std::endl;\\n    std::cout << \"Input Roman numeral: \";\\n    std::getline(std::cin, sInput);\\n    printNewLine();\\n\\n    for (int i = sInput.size() - 1; i >= 0; --i) {\\n        char c = sInput[i];\\n        auto iter = mStorage.find(c);\\n        if (iter != mStorage.end()) {\\n            int currValue = iter->second;\\n            if (currValue < prevValue) {\\n                nYear -= currValue;\\n            }else {\\n                nYear += currValue;\\n                prevValue = currValue;\\n            }\\n        } else {\\n            std::cout << \"---Results---\";\\n            std::cout << \"Invalid Roman numeral: \" << c << std::endl;\\n            return 0;\\n        }\\n    }\\n    std::cout << \"---Results---\" << std::endl;\\n    std::cout << sInput << \" refers to: \" << nYear << \" after calculation.\" << std::endl;\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user6303E",
                        "content": "Java peeps enjoy !\n `your inline code...\n\nclass Solution {\n\n    public int romanToInt(String s) {\n        int ans = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'I') ans += 1;\n            if (s.charAt(i) == 'V') ans += 5;\n            if (s.charAt(i) == 'X') ans += 10;\n            if (s.charAt(i) == 'L') ans += 50;\n            if (s.charAt(i) == 'C') ans += 100;\n            if (s.charAt(i) == 'D') ans += 500;\n            if (s.charAt(i) == 'M') ans += 1000;\n        }\n        if (s.contains(\"IV\") || s.contains(\"IX\")) ans -= 2 * 1;\n        if (s.contains(\"XC\") || s.contains(\"XL\")) ans -= 2 * 10;\n        if (s.contains(\"CD\") || s.contains(\"CM\")) ans -= 2 * 100;\n\n        return ans;\n    }\n}\n\nyour inline code...`\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mxmln",
                        "content": "why additional functions aren\\'t working? \\n"
                    }
                ]
            },
            {
                "id": 1970498,
                "content": [
                    {
                        "username": "user1278K",
                        "content": "I dont know why leetcode is giving me the error , though it is running fine in other editor\\n\\nimport java.util.*;\\nimport java.lang.*;\\nimport java.io.*;\\n\\n// The main method must be in a class named \"Main\".\\nclass Main {\\n    public static void main(String[] args) {\\n        System.out.println(romanToInt(\"MCMXCIV\"));\\n        \\n    }\\n    \\n     public static int romanToInt(String s) {\\n        \\n        int sum=0;\\n\\n        // initialize a hashmap\\n        Map<String,Integer> hashmap= new HashMap<String,Integer>();\\n        hashmap.put(\"I\",1);\\n        hashmap.put(\"V\",5);\\n        hashmap.put(\"X\",10);\\n        hashmap.put(\"L\",50);\\n        hashmap.put(\"C\",100);\\n        hashmap.put(\"D\",500);\\n        hashmap.put(\"M\",1000);\\n\\n        // iterate the loop \\n        int i=0; \\n        while (i<s.length()){\\n             String c= \"\"+s.charAt(i);\\n            if (c.equals(\"C\") || c.equals(\"X\") || c.equals(\"I\")){\\n              \\n              c= \"\"+s.charAt(i)+s.charAt(i+1); //CM, XC ,IV\\n             int value= hashmap.get(\"\"+s.charAt(i+1)) - hashmap.get(\"\"+s.charAt(i));\\n            sum =sum + value; // 1000+ 900, 1000+ 900+ 90,  1000+ 900+ 90 +4\\n               i =i+2;\\n            }\\n            else\\n          {\\n             c= \"\"+s.charAt(i);\\n            sum =sum + hashmap.get(c); // 1000\\n            i=i+1;\\n          } \\n         \\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "This is the best beginner questions to start with. Very easy with just logical skills required. Roman are written in descending order and if written in ascending then we subtract the value from the total."
                    },
                    {
                        "username": "user3974tS",
                        "content": "Here is my solution in C#\n`public class Solution {\n    public int RomanToInt(string s) {\n        var romanSymbols = new Dictionary<char, int>() {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100 {'D', 500}, {'M', 1000} };\n\n        int sum = 0;\n        for(int i = 0; i < s.Length; i++){\n            if (s.Length == 1) {\n                sum += romanSymbols[s[i]];\n            }\n            else if (i < s.Length - 1 && s.Length != 1){\n                if (romanSymbols[s[i]] > romanSymbols[s[i + 1]] || romanSymbols[s[i]] == romanSymbols[s[i + 1]]) \n                sum += romanSymbols[s[i]];\n            else {\n        sum += romanSymbols[s[i + 1]] - romanSymbols[s[i]];\n        i++;\n        } \n    } \n    else {\n        if (romanSymbols[s[i]] < romanSymbols[s[i - 1]] || romanSymbols[s[i]] == romanSymbols[s[i - 1]]) \n            sum += romanSymbols[s[i]];\n    }\n        }\n        return sum;\n    } }` "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cayyanraj",
                        "content": "what was it complexity?\\n"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "The question would have become more challenging if we were asked to return -1 if the given roman number violated any rule mentioned in question description."
                    },
                    {
                        "username": "askhat1myrzabekov",
                        "content": "why \"MCMXCIV\" is 2216 ? I searched at Google and it is 1994"
                    },
                    {
                        "username": "maurya_laxmi929",
                        "content": "I started my coding Journey on LeetCode with this problem :)"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "#include <iostream>\\n#include <unordered_map>\\n\\nvoid printNewLine() {\\n    std::cout << \"\\\\n\";\\n}\\n\\nint main() {\\n    std::unordered_map<char, int> mStorage = {\\n        {\\'I\\', 1}, {\\'V\\', 5}, {\\'X\\', 10}, {\\'L\\', 50}, {\\'C\\', 100}, {\\'D\\', 500}, {\\'M\\', 1000}\\n    };\\n    std::string sInput(\"\");\\n    int nYear = 0;\\n    int prevValue = 0;\\n\\n    printNewLine();\\n    std::cout << \"---Given storage of details---\" << std::endl;\\n    for(const auto& pair : mStorage){\\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\\n    }\\n    printNewLine();\\n    std::cout << \"---String insertion---\" << std::endl;\\n    std::cout << \"Input Roman numeral: \";\\n    std::getline(std::cin, sInput);\\n    printNewLine();\\n\\n    for (int i = sInput.size() - 1; i >= 0; --i) {\\n        char c = sInput[i];\\n        auto iter = mStorage.find(c);\\n        if (iter != mStorage.end()) {\\n            int currValue = iter->second;\\n            if (currValue < prevValue) {\\n                nYear -= currValue;\\n            }else {\\n                nYear += currValue;\\n                prevValue = currValue;\\n            }\\n        } else {\\n            std::cout << \"---Results---\";\\n            std::cout << \"Invalid Roman numeral: \" << c << std::endl;\\n            return 0;\\n        }\\n    }\\n    std::cout << \"---Results---\" << std::endl;\\n    std::cout << sInput << \" refers to: \" << nYear << \" after calculation.\" << std::endl;\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user6303E",
                        "content": "Java peeps enjoy !\n `your inline code...\n\nclass Solution {\n\n    public int romanToInt(String s) {\n        int ans = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'I') ans += 1;\n            if (s.charAt(i) == 'V') ans += 5;\n            if (s.charAt(i) == 'X') ans += 10;\n            if (s.charAt(i) == 'L') ans += 50;\n            if (s.charAt(i) == 'C') ans += 100;\n            if (s.charAt(i) == 'D') ans += 500;\n            if (s.charAt(i) == 'M') ans += 1000;\n        }\n        if (s.contains(\"IV\") || s.contains(\"IX\")) ans -= 2 * 1;\n        if (s.contains(\"XC\") || s.contains(\"XL\")) ans -= 2 * 10;\n        if (s.contains(\"CD\") || s.contains(\"CM\")) ans -= 2 * 100;\n\n        return ans;\n    }\n}\n\nyour inline code...`\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mxmln",
                        "content": "why additional functions aren\\'t working? \\n"
                    }
                ]
            },
            {
                "id": 1968313,
                "content": [
                    {
                        "username": "user1278K",
                        "content": "I dont know why leetcode is giving me the error , though it is running fine in other editor\\n\\nimport java.util.*;\\nimport java.lang.*;\\nimport java.io.*;\\n\\n// The main method must be in a class named \"Main\".\\nclass Main {\\n    public static void main(String[] args) {\\n        System.out.println(romanToInt(\"MCMXCIV\"));\\n        \\n    }\\n    \\n     public static int romanToInt(String s) {\\n        \\n        int sum=0;\\n\\n        // initialize a hashmap\\n        Map<String,Integer> hashmap= new HashMap<String,Integer>();\\n        hashmap.put(\"I\",1);\\n        hashmap.put(\"V\",5);\\n        hashmap.put(\"X\",10);\\n        hashmap.put(\"L\",50);\\n        hashmap.put(\"C\",100);\\n        hashmap.put(\"D\",500);\\n        hashmap.put(\"M\",1000);\\n\\n        // iterate the loop \\n        int i=0; \\n        while (i<s.length()){\\n             String c= \"\"+s.charAt(i);\\n            if (c.equals(\"C\") || c.equals(\"X\") || c.equals(\"I\")){\\n              \\n              c= \"\"+s.charAt(i)+s.charAt(i+1); //CM, XC ,IV\\n             int value= hashmap.get(\"\"+s.charAt(i+1)) - hashmap.get(\"\"+s.charAt(i));\\n            sum =sum + value; // 1000+ 900, 1000+ 900+ 90,  1000+ 900+ 90 +4\\n               i =i+2;\\n            }\\n            else\\n          {\\n             c= \"\"+s.charAt(i);\\n            sum =sum + hashmap.get(c); // 1000\\n            i=i+1;\\n          } \\n         \\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "This is the best beginner questions to start with. Very easy with just logical skills required. Roman are written in descending order and if written in ascending then we subtract the value from the total."
                    },
                    {
                        "username": "user3974tS",
                        "content": "Here is my solution in C#\n`public class Solution {\n    public int RomanToInt(string s) {\n        var romanSymbols = new Dictionary<char, int>() {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100 {'D', 500}, {'M', 1000} };\n\n        int sum = 0;\n        for(int i = 0; i < s.Length; i++){\n            if (s.Length == 1) {\n                sum += romanSymbols[s[i]];\n            }\n            else if (i < s.Length - 1 && s.Length != 1){\n                if (romanSymbols[s[i]] > romanSymbols[s[i + 1]] || romanSymbols[s[i]] == romanSymbols[s[i + 1]]) \n                sum += romanSymbols[s[i]];\n            else {\n        sum += romanSymbols[s[i + 1]] - romanSymbols[s[i]];\n        i++;\n        } \n    } \n    else {\n        if (romanSymbols[s[i]] < romanSymbols[s[i - 1]] || romanSymbols[s[i]] == romanSymbols[s[i - 1]]) \n            sum += romanSymbols[s[i]];\n    }\n        }\n        return sum;\n    } }` "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cayyanraj",
                        "content": "what was it complexity?\\n"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "The question would have become more challenging if we were asked to return -1 if the given roman number violated any rule mentioned in question description."
                    },
                    {
                        "username": "askhat1myrzabekov",
                        "content": "why \"MCMXCIV\" is 2216 ? I searched at Google and it is 1994"
                    },
                    {
                        "username": "maurya_laxmi929",
                        "content": "I started my coding Journey on LeetCode with this problem :)"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "#include <iostream>\\n#include <unordered_map>\\n\\nvoid printNewLine() {\\n    std::cout << \"\\\\n\";\\n}\\n\\nint main() {\\n    std::unordered_map<char, int> mStorage = {\\n        {\\'I\\', 1}, {\\'V\\', 5}, {\\'X\\', 10}, {\\'L\\', 50}, {\\'C\\', 100}, {\\'D\\', 500}, {\\'M\\', 1000}\\n    };\\n    std::string sInput(\"\");\\n    int nYear = 0;\\n    int prevValue = 0;\\n\\n    printNewLine();\\n    std::cout << \"---Given storage of details---\" << std::endl;\\n    for(const auto& pair : mStorage){\\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\\n    }\\n    printNewLine();\\n    std::cout << \"---String insertion---\" << std::endl;\\n    std::cout << \"Input Roman numeral: \";\\n    std::getline(std::cin, sInput);\\n    printNewLine();\\n\\n    for (int i = sInput.size() - 1; i >= 0; --i) {\\n        char c = sInput[i];\\n        auto iter = mStorage.find(c);\\n        if (iter != mStorage.end()) {\\n            int currValue = iter->second;\\n            if (currValue < prevValue) {\\n                nYear -= currValue;\\n            }else {\\n                nYear += currValue;\\n                prevValue = currValue;\\n            }\\n        } else {\\n            std::cout << \"---Results---\";\\n            std::cout << \"Invalid Roman numeral: \" << c << std::endl;\\n            return 0;\\n        }\\n    }\\n    std::cout << \"---Results---\" << std::endl;\\n    std::cout << sInput << \" refers to: \" << nYear << \" after calculation.\" << std::endl;\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user6303E",
                        "content": "Java peeps enjoy !\n `your inline code...\n\nclass Solution {\n\n    public int romanToInt(String s) {\n        int ans = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'I') ans += 1;\n            if (s.charAt(i) == 'V') ans += 5;\n            if (s.charAt(i) == 'X') ans += 10;\n            if (s.charAt(i) == 'L') ans += 50;\n            if (s.charAt(i) == 'C') ans += 100;\n            if (s.charAt(i) == 'D') ans += 500;\n            if (s.charAt(i) == 'M') ans += 1000;\n        }\n        if (s.contains(\"IV\") || s.contains(\"IX\")) ans -= 2 * 1;\n        if (s.contains(\"XC\") || s.contains(\"XL\")) ans -= 2 * 10;\n        if (s.contains(\"CD\") || s.contains(\"CM\")) ans -= 2 * 100;\n\n        return ans;\n    }\n}\n\nyour inline code...`\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mxmln",
                        "content": "why additional functions aren\\'t working? \\n"
                    }
                ]
            },
            {
                "id": 1968275,
                "content": [
                    {
                        "username": "user1278K",
                        "content": "I dont know why leetcode is giving me the error , though it is running fine in other editor\\n\\nimport java.util.*;\\nimport java.lang.*;\\nimport java.io.*;\\n\\n// The main method must be in a class named \"Main\".\\nclass Main {\\n    public static void main(String[] args) {\\n        System.out.println(romanToInt(\"MCMXCIV\"));\\n        \\n    }\\n    \\n     public static int romanToInt(String s) {\\n        \\n        int sum=0;\\n\\n        // initialize a hashmap\\n        Map<String,Integer> hashmap= new HashMap<String,Integer>();\\n        hashmap.put(\"I\",1);\\n        hashmap.put(\"V\",5);\\n        hashmap.put(\"X\",10);\\n        hashmap.put(\"L\",50);\\n        hashmap.put(\"C\",100);\\n        hashmap.put(\"D\",500);\\n        hashmap.put(\"M\",1000);\\n\\n        // iterate the loop \\n        int i=0; \\n        while (i<s.length()){\\n             String c= \"\"+s.charAt(i);\\n            if (c.equals(\"C\") || c.equals(\"X\") || c.equals(\"I\")){\\n              \\n              c= \"\"+s.charAt(i)+s.charAt(i+1); //CM, XC ,IV\\n             int value= hashmap.get(\"\"+s.charAt(i+1)) - hashmap.get(\"\"+s.charAt(i));\\n            sum =sum + value; // 1000+ 900, 1000+ 900+ 90,  1000+ 900+ 90 +4\\n               i =i+2;\\n            }\\n            else\\n          {\\n             c= \"\"+s.charAt(i);\\n            sum =sum + hashmap.get(c); // 1000\\n            i=i+1;\\n          } \\n         \\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "This is the best beginner questions to start with. Very easy with just logical skills required. Roman are written in descending order and if written in ascending then we subtract the value from the total."
                    },
                    {
                        "username": "user3974tS",
                        "content": "Here is my solution in C#\n`public class Solution {\n    public int RomanToInt(string s) {\n        var romanSymbols = new Dictionary<char, int>() {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100 {'D', 500}, {'M', 1000} };\n\n        int sum = 0;\n        for(int i = 0; i < s.Length; i++){\n            if (s.Length == 1) {\n                sum += romanSymbols[s[i]];\n            }\n            else if (i < s.Length - 1 && s.Length != 1){\n                if (romanSymbols[s[i]] > romanSymbols[s[i + 1]] || romanSymbols[s[i]] == romanSymbols[s[i + 1]]) \n                sum += romanSymbols[s[i]];\n            else {\n        sum += romanSymbols[s[i + 1]] - romanSymbols[s[i]];\n        i++;\n        } \n    } \n    else {\n        if (romanSymbols[s[i]] < romanSymbols[s[i - 1]] || romanSymbols[s[i]] == romanSymbols[s[i - 1]]) \n            sum += romanSymbols[s[i]];\n    }\n        }\n        return sum;\n    } }` "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cayyanraj",
                        "content": "what was it complexity?\\n"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "The question would have become more challenging if we were asked to return -1 if the given roman number violated any rule mentioned in question description."
                    },
                    {
                        "username": "askhat1myrzabekov",
                        "content": "why \"MCMXCIV\" is 2216 ? I searched at Google and it is 1994"
                    },
                    {
                        "username": "maurya_laxmi929",
                        "content": "I started my coding Journey on LeetCode with this problem :)"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "#include <iostream>\\n#include <unordered_map>\\n\\nvoid printNewLine() {\\n    std::cout << \"\\\\n\";\\n}\\n\\nint main() {\\n    std::unordered_map<char, int> mStorage = {\\n        {\\'I\\', 1}, {\\'V\\', 5}, {\\'X\\', 10}, {\\'L\\', 50}, {\\'C\\', 100}, {\\'D\\', 500}, {\\'M\\', 1000}\\n    };\\n    std::string sInput(\"\");\\n    int nYear = 0;\\n    int prevValue = 0;\\n\\n    printNewLine();\\n    std::cout << \"---Given storage of details---\" << std::endl;\\n    for(const auto& pair : mStorage){\\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\\n    }\\n    printNewLine();\\n    std::cout << \"---String insertion---\" << std::endl;\\n    std::cout << \"Input Roman numeral: \";\\n    std::getline(std::cin, sInput);\\n    printNewLine();\\n\\n    for (int i = sInput.size() - 1; i >= 0; --i) {\\n        char c = sInput[i];\\n        auto iter = mStorage.find(c);\\n        if (iter != mStorage.end()) {\\n            int currValue = iter->second;\\n            if (currValue < prevValue) {\\n                nYear -= currValue;\\n            }else {\\n                nYear += currValue;\\n                prevValue = currValue;\\n            }\\n        } else {\\n            std::cout << \"---Results---\";\\n            std::cout << \"Invalid Roman numeral: \" << c << std::endl;\\n            return 0;\\n        }\\n    }\\n    std::cout << \"---Results---\" << std::endl;\\n    std::cout << sInput << \" refers to: \" << nYear << \" after calculation.\" << std::endl;\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user6303E",
                        "content": "Java peeps enjoy !\n `your inline code...\n\nclass Solution {\n\n    public int romanToInt(String s) {\n        int ans = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'I') ans += 1;\n            if (s.charAt(i) == 'V') ans += 5;\n            if (s.charAt(i) == 'X') ans += 10;\n            if (s.charAt(i) == 'L') ans += 50;\n            if (s.charAt(i) == 'C') ans += 100;\n            if (s.charAt(i) == 'D') ans += 500;\n            if (s.charAt(i) == 'M') ans += 1000;\n        }\n        if (s.contains(\"IV\") || s.contains(\"IX\")) ans -= 2 * 1;\n        if (s.contains(\"XC\") || s.contains(\"XL\")) ans -= 2 * 10;\n        if (s.contains(\"CD\") || s.contains(\"CM\")) ans -= 2 * 100;\n\n        return ans;\n    }\n}\n\nyour inline code...`\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mxmln",
                        "content": "why additional functions aren\\'t working? \\n"
                    }
                ]
            },
            {
                "id": 1966029,
                "content": [
                    {
                        "username": "user1278K",
                        "content": "I dont know why leetcode is giving me the error , though it is running fine in other editor\\n\\nimport java.util.*;\\nimport java.lang.*;\\nimport java.io.*;\\n\\n// The main method must be in a class named \"Main\".\\nclass Main {\\n    public static void main(String[] args) {\\n        System.out.println(romanToInt(\"MCMXCIV\"));\\n        \\n    }\\n    \\n     public static int romanToInt(String s) {\\n        \\n        int sum=0;\\n\\n        // initialize a hashmap\\n        Map<String,Integer> hashmap= new HashMap<String,Integer>();\\n        hashmap.put(\"I\",1);\\n        hashmap.put(\"V\",5);\\n        hashmap.put(\"X\",10);\\n        hashmap.put(\"L\",50);\\n        hashmap.put(\"C\",100);\\n        hashmap.put(\"D\",500);\\n        hashmap.put(\"M\",1000);\\n\\n        // iterate the loop \\n        int i=0; \\n        while (i<s.length()){\\n             String c= \"\"+s.charAt(i);\\n            if (c.equals(\"C\") || c.equals(\"X\") || c.equals(\"I\")){\\n              \\n              c= \"\"+s.charAt(i)+s.charAt(i+1); //CM, XC ,IV\\n             int value= hashmap.get(\"\"+s.charAt(i+1)) - hashmap.get(\"\"+s.charAt(i));\\n            sum =sum + value; // 1000+ 900, 1000+ 900+ 90,  1000+ 900+ 90 +4\\n               i =i+2;\\n            }\\n            else\\n          {\\n             c= \"\"+s.charAt(i);\\n            sum =sum + hashmap.get(c); // 1000\\n            i=i+1;\\n          } \\n         \\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "This is the best beginner questions to start with. Very easy with just logical skills required. Roman are written in descending order and if written in ascending then we subtract the value from the total."
                    },
                    {
                        "username": "user3974tS",
                        "content": "Here is my solution in C#\n`public class Solution {\n    public int RomanToInt(string s) {\n        var romanSymbols = new Dictionary<char, int>() {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100 {'D', 500}, {'M', 1000} };\n\n        int sum = 0;\n        for(int i = 0; i < s.Length; i++){\n            if (s.Length == 1) {\n                sum += romanSymbols[s[i]];\n            }\n            else if (i < s.Length - 1 && s.Length != 1){\n                if (romanSymbols[s[i]] > romanSymbols[s[i + 1]] || romanSymbols[s[i]] == romanSymbols[s[i + 1]]) \n                sum += romanSymbols[s[i]];\n            else {\n        sum += romanSymbols[s[i + 1]] - romanSymbols[s[i]];\n        i++;\n        } \n    } \n    else {\n        if (romanSymbols[s[i]] < romanSymbols[s[i - 1]] || romanSymbols[s[i]] == romanSymbols[s[i - 1]]) \n            sum += romanSymbols[s[i]];\n    }\n        }\n        return sum;\n    } }` "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cayyanraj",
                        "content": "what was it complexity?\\n"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "The question would have become more challenging if we were asked to return -1 if the given roman number violated any rule mentioned in question description."
                    },
                    {
                        "username": "askhat1myrzabekov",
                        "content": "why \"MCMXCIV\" is 2216 ? I searched at Google and it is 1994"
                    },
                    {
                        "username": "maurya_laxmi929",
                        "content": "I started my coding Journey on LeetCode with this problem :)"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "#include <iostream>\\n#include <unordered_map>\\n\\nvoid printNewLine() {\\n    std::cout << \"\\\\n\";\\n}\\n\\nint main() {\\n    std::unordered_map<char, int> mStorage = {\\n        {\\'I\\', 1}, {\\'V\\', 5}, {\\'X\\', 10}, {\\'L\\', 50}, {\\'C\\', 100}, {\\'D\\', 500}, {\\'M\\', 1000}\\n    };\\n    std::string sInput(\"\");\\n    int nYear = 0;\\n    int prevValue = 0;\\n\\n    printNewLine();\\n    std::cout << \"---Given storage of details---\" << std::endl;\\n    for(const auto& pair : mStorage){\\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\\n    }\\n    printNewLine();\\n    std::cout << \"---String insertion---\" << std::endl;\\n    std::cout << \"Input Roman numeral: \";\\n    std::getline(std::cin, sInput);\\n    printNewLine();\\n\\n    for (int i = sInput.size() - 1; i >= 0; --i) {\\n        char c = sInput[i];\\n        auto iter = mStorage.find(c);\\n        if (iter != mStorage.end()) {\\n            int currValue = iter->second;\\n            if (currValue < prevValue) {\\n                nYear -= currValue;\\n            }else {\\n                nYear += currValue;\\n                prevValue = currValue;\\n            }\\n        } else {\\n            std::cout << \"---Results---\";\\n            std::cout << \"Invalid Roman numeral: \" << c << std::endl;\\n            return 0;\\n        }\\n    }\\n    std::cout << \"---Results---\" << std::endl;\\n    std::cout << sInput << \" refers to: \" << nYear << \" after calculation.\" << std::endl;\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user6303E",
                        "content": "Java peeps enjoy !\n `your inline code...\n\nclass Solution {\n\n    public int romanToInt(String s) {\n        int ans = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'I') ans += 1;\n            if (s.charAt(i) == 'V') ans += 5;\n            if (s.charAt(i) == 'X') ans += 10;\n            if (s.charAt(i) == 'L') ans += 50;\n            if (s.charAt(i) == 'C') ans += 100;\n            if (s.charAt(i) == 'D') ans += 500;\n            if (s.charAt(i) == 'M') ans += 1000;\n        }\n        if (s.contains(\"IV\") || s.contains(\"IX\")) ans -= 2 * 1;\n        if (s.contains(\"XC\") || s.contains(\"XL\")) ans -= 2 * 10;\n        if (s.contains(\"CD\") || s.contains(\"CM\")) ans -= 2 * 100;\n\n        return ans;\n    }\n}\n\nyour inline code...`\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mxmln",
                        "content": "why additional functions aren\\'t working? \\n"
                    }
                ]
            },
            {
                "id": 1964348,
                "content": [
                    {
                        "username": "user1278K",
                        "content": "I dont know why leetcode is giving me the error , though it is running fine in other editor\\n\\nimport java.util.*;\\nimport java.lang.*;\\nimport java.io.*;\\n\\n// The main method must be in a class named \"Main\".\\nclass Main {\\n    public static void main(String[] args) {\\n        System.out.println(romanToInt(\"MCMXCIV\"));\\n        \\n    }\\n    \\n     public static int romanToInt(String s) {\\n        \\n        int sum=0;\\n\\n        // initialize a hashmap\\n        Map<String,Integer> hashmap= new HashMap<String,Integer>();\\n        hashmap.put(\"I\",1);\\n        hashmap.put(\"V\",5);\\n        hashmap.put(\"X\",10);\\n        hashmap.put(\"L\",50);\\n        hashmap.put(\"C\",100);\\n        hashmap.put(\"D\",500);\\n        hashmap.put(\"M\",1000);\\n\\n        // iterate the loop \\n        int i=0; \\n        while (i<s.length()){\\n             String c= \"\"+s.charAt(i);\\n            if (c.equals(\"C\") || c.equals(\"X\") || c.equals(\"I\")){\\n              \\n              c= \"\"+s.charAt(i)+s.charAt(i+1); //CM, XC ,IV\\n             int value= hashmap.get(\"\"+s.charAt(i+1)) - hashmap.get(\"\"+s.charAt(i));\\n            sum =sum + value; // 1000+ 900, 1000+ 900+ 90,  1000+ 900+ 90 +4\\n               i =i+2;\\n            }\\n            else\\n          {\\n             c= \"\"+s.charAt(i);\\n            sum =sum + hashmap.get(c); // 1000\\n            i=i+1;\\n          } \\n         \\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "This is the best beginner questions to start with. Very easy with just logical skills required. Roman are written in descending order and if written in ascending then we subtract the value from the total."
                    },
                    {
                        "username": "user3974tS",
                        "content": "Here is my solution in C#\n`public class Solution {\n    public int RomanToInt(string s) {\n        var romanSymbols = new Dictionary<char, int>() {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100 {'D', 500}, {'M', 1000} };\n\n        int sum = 0;\n        for(int i = 0; i < s.Length; i++){\n            if (s.Length == 1) {\n                sum += romanSymbols[s[i]];\n            }\n            else if (i < s.Length - 1 && s.Length != 1){\n                if (romanSymbols[s[i]] > romanSymbols[s[i + 1]] || romanSymbols[s[i]] == romanSymbols[s[i + 1]]) \n                sum += romanSymbols[s[i]];\n            else {\n        sum += romanSymbols[s[i + 1]] - romanSymbols[s[i]];\n        i++;\n        } \n    } \n    else {\n        if (romanSymbols[s[i]] < romanSymbols[s[i - 1]] || romanSymbols[s[i]] == romanSymbols[s[i - 1]]) \n            sum += romanSymbols[s[i]];\n    }\n        }\n        return sum;\n    } }` "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cayyanraj",
                        "content": "what was it complexity?\\n"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "The question would have become more challenging if we were asked to return -1 if the given roman number violated any rule mentioned in question description."
                    },
                    {
                        "username": "askhat1myrzabekov",
                        "content": "why \"MCMXCIV\" is 2216 ? I searched at Google and it is 1994"
                    },
                    {
                        "username": "maurya_laxmi929",
                        "content": "I started my coding Journey on LeetCode with this problem :)"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "#include <iostream>\\n#include <unordered_map>\\n\\nvoid printNewLine() {\\n    std::cout << \"\\\\n\";\\n}\\n\\nint main() {\\n    std::unordered_map<char, int> mStorage = {\\n        {\\'I\\', 1}, {\\'V\\', 5}, {\\'X\\', 10}, {\\'L\\', 50}, {\\'C\\', 100}, {\\'D\\', 500}, {\\'M\\', 1000}\\n    };\\n    std::string sInput(\"\");\\n    int nYear = 0;\\n    int prevValue = 0;\\n\\n    printNewLine();\\n    std::cout << \"---Given storage of details---\" << std::endl;\\n    for(const auto& pair : mStorage){\\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\\n    }\\n    printNewLine();\\n    std::cout << \"---String insertion---\" << std::endl;\\n    std::cout << \"Input Roman numeral: \";\\n    std::getline(std::cin, sInput);\\n    printNewLine();\\n\\n    for (int i = sInput.size() - 1; i >= 0; --i) {\\n        char c = sInput[i];\\n        auto iter = mStorage.find(c);\\n        if (iter != mStorage.end()) {\\n            int currValue = iter->second;\\n            if (currValue < prevValue) {\\n                nYear -= currValue;\\n            }else {\\n                nYear += currValue;\\n                prevValue = currValue;\\n            }\\n        } else {\\n            std::cout << \"---Results---\";\\n            std::cout << \"Invalid Roman numeral: \" << c << std::endl;\\n            return 0;\\n        }\\n    }\\n    std::cout << \"---Results---\" << std::endl;\\n    std::cout << sInput << \" refers to: \" << nYear << \" after calculation.\" << std::endl;\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user6303E",
                        "content": "Java peeps enjoy !\n `your inline code...\n\nclass Solution {\n\n    public int romanToInt(String s) {\n        int ans = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'I') ans += 1;\n            if (s.charAt(i) == 'V') ans += 5;\n            if (s.charAt(i) == 'X') ans += 10;\n            if (s.charAt(i) == 'L') ans += 50;\n            if (s.charAt(i) == 'C') ans += 100;\n            if (s.charAt(i) == 'D') ans += 500;\n            if (s.charAt(i) == 'M') ans += 1000;\n        }\n        if (s.contains(\"IV\") || s.contains(\"IX\")) ans -= 2 * 1;\n        if (s.contains(\"XC\") || s.contains(\"XL\")) ans -= 2 * 10;\n        if (s.contains(\"CD\") || s.contains(\"CM\")) ans -= 2 * 100;\n\n        return ans;\n    }\n}\n\nyour inline code...`\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mxmln",
                        "content": "why additional functions aren\\'t working? \\n"
                    }
                ]
            },
            {
                "id": 1963962,
                "content": [
                    {
                        "username": "user1278K",
                        "content": "I dont know why leetcode is giving me the error , though it is running fine in other editor\\n\\nimport java.util.*;\\nimport java.lang.*;\\nimport java.io.*;\\n\\n// The main method must be in a class named \"Main\".\\nclass Main {\\n    public static void main(String[] args) {\\n        System.out.println(romanToInt(\"MCMXCIV\"));\\n        \\n    }\\n    \\n     public static int romanToInt(String s) {\\n        \\n        int sum=0;\\n\\n        // initialize a hashmap\\n        Map<String,Integer> hashmap= new HashMap<String,Integer>();\\n        hashmap.put(\"I\",1);\\n        hashmap.put(\"V\",5);\\n        hashmap.put(\"X\",10);\\n        hashmap.put(\"L\",50);\\n        hashmap.put(\"C\",100);\\n        hashmap.put(\"D\",500);\\n        hashmap.put(\"M\",1000);\\n\\n        // iterate the loop \\n        int i=0; \\n        while (i<s.length()){\\n             String c= \"\"+s.charAt(i);\\n            if (c.equals(\"C\") || c.equals(\"X\") || c.equals(\"I\")){\\n              \\n              c= \"\"+s.charAt(i)+s.charAt(i+1); //CM, XC ,IV\\n             int value= hashmap.get(\"\"+s.charAt(i+1)) - hashmap.get(\"\"+s.charAt(i));\\n            sum =sum + value; // 1000+ 900, 1000+ 900+ 90,  1000+ 900+ 90 +4\\n               i =i+2;\\n            }\\n            else\\n          {\\n             c= \"\"+s.charAt(i);\\n            sum =sum + hashmap.get(c); // 1000\\n            i=i+1;\\n          } \\n         \\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "This is the best beginner questions to start with. Very easy with just logical skills required. Roman are written in descending order and if written in ascending then we subtract the value from the total."
                    },
                    {
                        "username": "user3974tS",
                        "content": "Here is my solution in C#\n`public class Solution {\n    public int RomanToInt(string s) {\n        var romanSymbols = new Dictionary<char, int>() {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100 {'D', 500}, {'M', 1000} };\n\n        int sum = 0;\n        for(int i = 0; i < s.Length; i++){\n            if (s.Length == 1) {\n                sum += romanSymbols[s[i]];\n            }\n            else if (i < s.Length - 1 && s.Length != 1){\n                if (romanSymbols[s[i]] > romanSymbols[s[i + 1]] || romanSymbols[s[i]] == romanSymbols[s[i + 1]]) \n                sum += romanSymbols[s[i]];\n            else {\n        sum += romanSymbols[s[i + 1]] - romanSymbols[s[i]];\n        i++;\n        } \n    } \n    else {\n        if (romanSymbols[s[i]] < romanSymbols[s[i - 1]] || romanSymbols[s[i]] == romanSymbols[s[i - 1]]) \n            sum += romanSymbols[s[i]];\n    }\n        }\n        return sum;\n    } }` "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cayyanraj",
                        "content": "what was it complexity?\\n"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "The question would have become more challenging if we were asked to return -1 if the given roman number violated any rule mentioned in question description."
                    },
                    {
                        "username": "askhat1myrzabekov",
                        "content": "why \"MCMXCIV\" is 2216 ? I searched at Google and it is 1994"
                    },
                    {
                        "username": "maurya_laxmi929",
                        "content": "I started my coding Journey on LeetCode with this problem :)"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "#include <iostream>\\n#include <unordered_map>\\n\\nvoid printNewLine() {\\n    std::cout << \"\\\\n\";\\n}\\n\\nint main() {\\n    std::unordered_map<char, int> mStorage = {\\n        {\\'I\\', 1}, {\\'V\\', 5}, {\\'X\\', 10}, {\\'L\\', 50}, {\\'C\\', 100}, {\\'D\\', 500}, {\\'M\\', 1000}\\n    };\\n    std::string sInput(\"\");\\n    int nYear = 0;\\n    int prevValue = 0;\\n\\n    printNewLine();\\n    std::cout << \"---Given storage of details---\" << std::endl;\\n    for(const auto& pair : mStorage){\\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\\n    }\\n    printNewLine();\\n    std::cout << \"---String insertion---\" << std::endl;\\n    std::cout << \"Input Roman numeral: \";\\n    std::getline(std::cin, sInput);\\n    printNewLine();\\n\\n    for (int i = sInput.size() - 1; i >= 0; --i) {\\n        char c = sInput[i];\\n        auto iter = mStorage.find(c);\\n        if (iter != mStorage.end()) {\\n            int currValue = iter->second;\\n            if (currValue < prevValue) {\\n                nYear -= currValue;\\n            }else {\\n                nYear += currValue;\\n                prevValue = currValue;\\n            }\\n        } else {\\n            std::cout << \"---Results---\";\\n            std::cout << \"Invalid Roman numeral: \" << c << std::endl;\\n            return 0;\\n        }\\n    }\\n    std::cout << \"---Results---\" << std::endl;\\n    std::cout << sInput << \" refers to: \" << nYear << \" after calculation.\" << std::endl;\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user6303E",
                        "content": "Java peeps enjoy !\n `your inline code...\n\nclass Solution {\n\n    public int romanToInt(String s) {\n        int ans = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'I') ans += 1;\n            if (s.charAt(i) == 'V') ans += 5;\n            if (s.charAt(i) == 'X') ans += 10;\n            if (s.charAt(i) == 'L') ans += 50;\n            if (s.charAt(i) == 'C') ans += 100;\n            if (s.charAt(i) == 'D') ans += 500;\n            if (s.charAt(i) == 'M') ans += 1000;\n        }\n        if (s.contains(\"IV\") || s.contains(\"IX\")) ans -= 2 * 1;\n        if (s.contains(\"XC\") || s.contains(\"XL\")) ans -= 2 * 10;\n        if (s.contains(\"CD\") || s.contains(\"CM\")) ans -= 2 * 100;\n\n        return ans;\n    }\n}\n\nyour inline code...`\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mxmln",
                        "content": "why additional functions aren\\'t working? \\n"
                    }
                ]
            },
            {
                "id": 1961686,
                "content": [
                    {
                        "username": "user1278K",
                        "content": "I dont know why leetcode is giving me the error , though it is running fine in other editor\\n\\nimport java.util.*;\\nimport java.lang.*;\\nimport java.io.*;\\n\\n// The main method must be in a class named \"Main\".\\nclass Main {\\n    public static void main(String[] args) {\\n        System.out.println(romanToInt(\"MCMXCIV\"));\\n        \\n    }\\n    \\n     public static int romanToInt(String s) {\\n        \\n        int sum=0;\\n\\n        // initialize a hashmap\\n        Map<String,Integer> hashmap= new HashMap<String,Integer>();\\n        hashmap.put(\"I\",1);\\n        hashmap.put(\"V\",5);\\n        hashmap.put(\"X\",10);\\n        hashmap.put(\"L\",50);\\n        hashmap.put(\"C\",100);\\n        hashmap.put(\"D\",500);\\n        hashmap.put(\"M\",1000);\\n\\n        // iterate the loop \\n        int i=0; \\n        while (i<s.length()){\\n             String c= \"\"+s.charAt(i);\\n            if (c.equals(\"C\") || c.equals(\"X\") || c.equals(\"I\")){\\n              \\n              c= \"\"+s.charAt(i)+s.charAt(i+1); //CM, XC ,IV\\n             int value= hashmap.get(\"\"+s.charAt(i+1)) - hashmap.get(\"\"+s.charAt(i));\\n            sum =sum + value; // 1000+ 900, 1000+ 900+ 90,  1000+ 900+ 90 +4\\n               i =i+2;\\n            }\\n            else\\n          {\\n             c= \"\"+s.charAt(i);\\n            sum =sum + hashmap.get(c); // 1000\\n            i=i+1;\\n          } \\n         \\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "This is the best beginner questions to start with. Very easy with just logical skills required. Roman are written in descending order and if written in ascending then we subtract the value from the total."
                    },
                    {
                        "username": "user3974tS",
                        "content": "Here is my solution in C#\n`public class Solution {\n    public int RomanToInt(string s) {\n        var romanSymbols = new Dictionary<char, int>() {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100 {'D', 500}, {'M', 1000} };\n\n        int sum = 0;\n        for(int i = 0; i < s.Length; i++){\n            if (s.Length == 1) {\n                sum += romanSymbols[s[i]];\n            }\n            else if (i < s.Length - 1 && s.Length != 1){\n                if (romanSymbols[s[i]] > romanSymbols[s[i + 1]] || romanSymbols[s[i]] == romanSymbols[s[i + 1]]) \n                sum += romanSymbols[s[i]];\n            else {\n        sum += romanSymbols[s[i + 1]] - romanSymbols[s[i]];\n        i++;\n        } \n    } \n    else {\n        if (romanSymbols[s[i]] < romanSymbols[s[i - 1]] || romanSymbols[s[i]] == romanSymbols[s[i - 1]]) \n            sum += romanSymbols[s[i]];\n    }\n        }\n        return sum;\n    } }` "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cayyanraj",
                        "content": "what was it complexity?\\n"
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "The question would have become more challenging if we were asked to return -1 if the given roman number violated any rule mentioned in question description."
                    },
                    {
                        "username": "askhat1myrzabekov",
                        "content": "why \"MCMXCIV\" is 2216 ? I searched at Google and it is 1994"
                    },
                    {
                        "username": "maurya_laxmi929",
                        "content": "I started my coding Journey on LeetCode with this problem :)"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "#include <iostream>\\n#include <unordered_map>\\n\\nvoid printNewLine() {\\n    std::cout << \"\\\\n\";\\n}\\n\\nint main() {\\n    std::unordered_map<char, int> mStorage = {\\n        {\\'I\\', 1}, {\\'V\\', 5}, {\\'X\\', 10}, {\\'L\\', 50}, {\\'C\\', 100}, {\\'D\\', 500}, {\\'M\\', 1000}\\n    };\\n    std::string sInput(\"\");\\n    int nYear = 0;\\n    int prevValue = 0;\\n\\n    printNewLine();\\n    std::cout << \"---Given storage of details---\" << std::endl;\\n    for(const auto& pair : mStorage){\\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\\n    }\\n    printNewLine();\\n    std::cout << \"---String insertion---\" << std::endl;\\n    std::cout << \"Input Roman numeral: \";\\n    std::getline(std::cin, sInput);\\n    printNewLine();\\n\\n    for (int i = sInput.size() - 1; i >= 0; --i) {\\n        char c = sInput[i];\\n        auto iter = mStorage.find(c);\\n        if (iter != mStorage.end()) {\\n            int currValue = iter->second;\\n            if (currValue < prevValue) {\\n                nYear -= currValue;\\n            }else {\\n                nYear += currValue;\\n                prevValue = currValue;\\n            }\\n        } else {\\n            std::cout << \"---Results---\";\\n            std::cout << \"Invalid Roman numeral: \" << c << std::endl;\\n            return 0;\\n        }\\n    }\\n    std::cout << \"---Results---\" << std::endl;\\n    std::cout << sInput << \" refers to: \" << nYear << \" after calculation.\" << std::endl;\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user6303E",
                        "content": "Java peeps enjoy !\n `your inline code...\n\nclass Solution {\n\n    public int romanToInt(String s) {\n        int ans = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'I') ans += 1;\n            if (s.charAt(i) == 'V') ans += 5;\n            if (s.charAt(i) == 'X') ans += 10;\n            if (s.charAt(i) == 'L') ans += 50;\n            if (s.charAt(i) == 'C') ans += 100;\n            if (s.charAt(i) == 'D') ans += 500;\n            if (s.charAt(i) == 'M') ans += 1000;\n        }\n        if (s.contains(\"IV\") || s.contains(\"IX\")) ans -= 2 * 1;\n        if (s.contains(\"XC\") || s.contains(\"XL\")) ans -= 2 * 10;\n        if (s.contains(\"CD\") || s.contains(\"CM\")) ans -= 2 * 100;\n\n        return ans;\n    }\n}\n\nyour inline code...`\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mxmln",
                        "content": "why additional functions aren\\'t working? \\n"
                    }
                ]
            },
            {
                "id": 1957987,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "i am not familiar with roman numbers this is difficult for me because of the understanding part"
                    },
                    {
                        "username": "rianrbps",
                        "content": "Time Limit Exceeded, is it because I used a switch case?\\n\\n `int romanToInt(char * s){\\n\\n    int num = 0;\\n    int i = 0;\\n\\n    while(s[i] != \\'\\\\0\\');{\\n        switch (s[i]){\\n            case \\'M\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 900;\\n                }else{\\n                    num += 1000;\\n                }\\n\\n            case \\'D\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 400;\\n                }else{\\n                    num += 500;\\n                }\\n \\n            case \\'C\\':\\n                if(s[i+1] == \\'M\\' || s[i+1] == \\'D\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'X\\'){\\n                        num+=90;\\n                    }else{\\n                        num+= 100;\\n                    }\\n                }\\n            \\n            case \\'L\\':\\n                if(s[i-1] == \\'X\\'){\\n                    num += 40;\\n                }else{\\n                    num += 50;\\n                }\\n\\n            case \\'X\\':\\n                if(s[i+1] == \\'L\\' || s[i+1] == \\'C\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'I\\'){\\n                        num += 9;\\n                    }else{\\n                        num += 10;\\n                    }\\n                }\\n\\n\\n            case \\'V\\':\\n                if(s[i-1] == \\'I\\'){\\n                    num += 4;\\n                }else{\\n                    num += 5;\\n                }\\n\\n\\n            case \\'I\\':\\n                if(s[i+1] == \\'V\\' || s[i+1] == \\'X\\'){\\n                    break;\\n                }else{\\n                    num += 1;\\n                }\\n        }\\n        i++;\\n    }\\n    return num;\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the code runs into an infinite loop, and that\\'s the cause for the Time Limit Exceeded error. The reason is that you have a semicolon `;` right after your `while` condition, which is making the `while` loop run indefinitely without any statements inside it. The code block following this semicolon is then executed as a separate, single-time block, and it\\'s not inside the loop as you intended. This leads to an infinite loop because there\\'s no operation inside the `while` loop that changes the loop\\'s condition (`s[i] != \\'\\\\0\\'`), so it just keeps running.\\n\\nThe correct way to write the `while` loop is:\\n\\n```c\\nwhile(s[i] != \\'\\\\0\\') {\\n    // your switch case and code goes here\\n}\\n```\\nBy fixing this, you should avoid the Time Limit Exceeded error.\\n\\nHowever, there is another logical error in your code related to how you\\'re handling the roman numeral conversion. The switch-case construct doesn\\'t have an automatic break once a case is executed. This means if a case like \\'M\\' or \\'D\\' is hit, the code continues to execute the next cases (\\'C\\', \\'L\\', \\'X\\', \\'V\\', \\'I\\') as well, leading to incorrect results. To avoid this, you need to put a `break` statement at the end of each case:\\n\\n```c\\nswitch (s[i]){\\n    case \\'M\\':\\n        // some code here\\n        break;\\n    case \\'D\\':\\n        // some code here\\n        break;\\n    // similar for other cases\\n}\\n```\\n\\nBy adding these `break` statements, you ensure that the switch-case construct exits after executing a matching case."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you still can\\'t find the way to solve, see my code , I just create a map ( you can create a switch case ) then you will loop full string and compare two adjacent item \\nclass Solution {\\n    public int romanToInt(String s) {\\n    Map<Character,Integer> map = new HashMap<Character, Integer> ();\\n      int sum = 0 ;\\n      int prevValue = 0;\\n      int currValue = 0;\\n      map.put(\\'I\\',1);\\n      map.put(\\'V\\',5);\\n      map.put(\\'X\\',10);\\n      map.put(\\'L\\',50);\\n      map.put(\\'C\\',100);\\n      map.put(\\'D\\',500);\\n      map.put(\\'M\\',1000);\\n\\n      for(int i=0 ; i< s.length(); i++) {\\n        currValue = map.get(s.charAt(i));\\n        if(currValue > prevValue ) {\\n          sum += currValue - 2 * prevValue;\\n        }\\n        else {\\n          sum += currValue;\\n        }\\n        prevValue = currValue;\\n        \\n      }\\n\\n      return sum;\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arvin_draj",
                        "content": "my code works in vs code \\nbut in leetcode the same code for the same test case it dosen\\'t work"
                    },
                    {
                        "username": "harish1402r",
                        "content": "how four is written?\\n"
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "So in Roman four is written by \\'IV\\' and if we split both of these letters then both of them have there own standard values in Roman, so what we have to do is just convert them into \\'IIII\\', and likewise for other values aswell which I have replaced aswell."
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "Hey, here is my answer for this in JS;\\n\\nlet val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10,\\'L\\': 50,\\'C\\': 100,\\'D\\': 500, \\'M\\': 1000};\\nlet sum = 0;\\ns = s.replace(\"IV\",\"IIII\");\\ns = s.replace(\"IX\",\"VIIII\");\\ns = s.replace(\"XL\",\"XXXX\");\\ns = s.replace(\"XC\",\"LXXXX\");\\ns = s.replace(\"CD\",\"CCCC\");\\ns = s.replace(\"CM\",\"DCCCC\");\\n\\nfor(let i = 0; i < s.length; i++){\\n    let z = val[`${s[i]}`];\\n    sum = sum + z;\\n}\\nreturn sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hi!\\nHere are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "santwan",
                        "content": "MY FIRST PROBLEM ON LEET CODE :)"
                    },
                    {
                        "username": "user1840I",
                        "content": "Why is this not being accepted ?\\ns=input()\\n\\nd={\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000}\\ntotal=0\\nprev_value=0\\n\\n\\nfor char in reversed(s) :\\n    if 1 <= len(s) <= 15 and (char in d):\\n         current_value = d[char]\\n         if current_value<prev_value :\\n              total-=current_value\\n            #LIX  XIL\\n\\n         else :\\n             total+=current_value\\n             prev_value=current_value\\n    else :\\n        quit()\\n\\nif total in range(1,4000) :\\n    print(total)\\n\\n\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your Python code is almost correct but needs some minor adjustments. Let\\'s modify it a bit. \\n\\nThe main points are:\\n1. Remove the input length checking inside the loop, we should check this before starting the loop.\\n2. We should remove the `quit()`. This function is used to end a script, and it won\\'t allow you to print the error message. You could use an `else` condition to print an error message.\\n3. The \"total\" value checking at the end is also unnecessary.\\n\\nHere is the modified code:\\n\\n```python\\ns = input()\\n\\nif 1 <= len(s) <= 15:\\n    d = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n    total = 0\\n    prev_value = 0\\n\\n    for char in reversed(s):\\n        if char in d:\\n            current_value = d[char]\\n            if current_value < prev_value:\\n                total -= current_value\\n            else:\\n                total += current_value\\n                prev_value = current_value\\n        else:\\n            print(f\"Invalid input: {char}\")\\n            break\\n    else:\\n        print(total)\\nelse:\\n    print(\"Invalid length of string\")\\n```\\n\\nThis code will print the total value if all the input characters are valid, else it will print an error message."
                    },
                    {
                        "username": "Silver_I0",
                        "content": "am i the only one that used regex?\\n```\\nimport re\\n\\nTHOUSANDS= \\'(M*)\\'\\nHUNDREDS= \\'(C[MD]|D?C{0,3})\\'\\nTENS= \\'(X[CL]|L?X{0,3})\\'\\nUNITS= \\'(I[XV]|V?I{0,3})\\'\\n\\n```\\ni feel like breaking roman numerals (MCDLXVIII) -> 1468\\ninto groups (\\'M\\', \\'CD, \\'LX\\', \\'VIII\\') \\niterating those groups and fetching values from the corresponding dict_keys\\nthen add everything up, was easier."
                    },
                    {
                        "username": "Dragon3000",
                        "content": "This is my first problem ever on leet code. \\n\\nI don\\'t understand what this is. Can anyone explain? Thanks. \\n\\nNameError: global name \\'Solution\\' is not defined\\n    ret = Solution().romanToInt(param_1)\\nLine 22 in _driver (Solution.py)\\n    _driver()\\nLine 32 in <module> (Solution.py)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing is because Python cannot find the definition for the class named \\'Solution\\'.\\n\\nIt seems like you are trying to call a method named `romanToInt` from a class named `Solution`. The error says that Python could not find this class.\\n\\nIn Python, before you can use a class, function, or variable, it must be defined in the current scope. For classes and functions, this means you need to have a `class` or `def` statement executed before you can use the class or function.\\n\\nHere is a simple example of how this works:\\n\\n```python\\nclass Solution:\\n    def romanToInt(self, s):\\n        # Your code here\\n\\n# Now you can use Solution because it has been defined\\nsolution = Solution()\\nret = solution.romanToInt(\"III\")\\n```\\n\\nSo, the error you\\'re seeing indicates that Python couldn\\'t find the class `Solution` at the point in your code where you tried to use it.\\n\\nTo fix this error, you need to ensure that the `Solution` class has been defined before you try to use it. It might be a simple as moving the code that uses `Solution` to a point in your script after the class is defined. Or it might mean importing the `Solution` class from another module if it is defined elsewhere."
                    }
                ]
            },
            {
                "id": 1947984,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "i am not familiar with roman numbers this is difficult for me because of the understanding part"
                    },
                    {
                        "username": "rianrbps",
                        "content": "Time Limit Exceeded, is it because I used a switch case?\\n\\n `int romanToInt(char * s){\\n\\n    int num = 0;\\n    int i = 0;\\n\\n    while(s[i] != \\'\\\\0\\');{\\n        switch (s[i]){\\n            case \\'M\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 900;\\n                }else{\\n                    num += 1000;\\n                }\\n\\n            case \\'D\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 400;\\n                }else{\\n                    num += 500;\\n                }\\n \\n            case \\'C\\':\\n                if(s[i+1] == \\'M\\' || s[i+1] == \\'D\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'X\\'){\\n                        num+=90;\\n                    }else{\\n                        num+= 100;\\n                    }\\n                }\\n            \\n            case \\'L\\':\\n                if(s[i-1] == \\'X\\'){\\n                    num += 40;\\n                }else{\\n                    num += 50;\\n                }\\n\\n            case \\'X\\':\\n                if(s[i+1] == \\'L\\' || s[i+1] == \\'C\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'I\\'){\\n                        num += 9;\\n                    }else{\\n                        num += 10;\\n                    }\\n                }\\n\\n\\n            case \\'V\\':\\n                if(s[i-1] == \\'I\\'){\\n                    num += 4;\\n                }else{\\n                    num += 5;\\n                }\\n\\n\\n            case \\'I\\':\\n                if(s[i+1] == \\'V\\' || s[i+1] == \\'X\\'){\\n                    break;\\n                }else{\\n                    num += 1;\\n                }\\n        }\\n        i++;\\n    }\\n    return num;\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the code runs into an infinite loop, and that\\'s the cause for the Time Limit Exceeded error. The reason is that you have a semicolon `;` right after your `while` condition, which is making the `while` loop run indefinitely without any statements inside it. The code block following this semicolon is then executed as a separate, single-time block, and it\\'s not inside the loop as you intended. This leads to an infinite loop because there\\'s no operation inside the `while` loop that changes the loop\\'s condition (`s[i] != \\'\\\\0\\'`), so it just keeps running.\\n\\nThe correct way to write the `while` loop is:\\n\\n```c\\nwhile(s[i] != \\'\\\\0\\') {\\n    // your switch case and code goes here\\n}\\n```\\nBy fixing this, you should avoid the Time Limit Exceeded error.\\n\\nHowever, there is another logical error in your code related to how you\\'re handling the roman numeral conversion. The switch-case construct doesn\\'t have an automatic break once a case is executed. This means if a case like \\'M\\' or \\'D\\' is hit, the code continues to execute the next cases (\\'C\\', \\'L\\', \\'X\\', \\'V\\', \\'I\\') as well, leading to incorrect results. To avoid this, you need to put a `break` statement at the end of each case:\\n\\n```c\\nswitch (s[i]){\\n    case \\'M\\':\\n        // some code here\\n        break;\\n    case \\'D\\':\\n        // some code here\\n        break;\\n    // similar for other cases\\n}\\n```\\n\\nBy adding these `break` statements, you ensure that the switch-case construct exits after executing a matching case."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you still can\\'t find the way to solve, see my code , I just create a map ( you can create a switch case ) then you will loop full string and compare two adjacent item \\nclass Solution {\\n    public int romanToInt(String s) {\\n    Map<Character,Integer> map = new HashMap<Character, Integer> ();\\n      int sum = 0 ;\\n      int prevValue = 0;\\n      int currValue = 0;\\n      map.put(\\'I\\',1);\\n      map.put(\\'V\\',5);\\n      map.put(\\'X\\',10);\\n      map.put(\\'L\\',50);\\n      map.put(\\'C\\',100);\\n      map.put(\\'D\\',500);\\n      map.put(\\'M\\',1000);\\n\\n      for(int i=0 ; i< s.length(); i++) {\\n        currValue = map.get(s.charAt(i));\\n        if(currValue > prevValue ) {\\n          sum += currValue - 2 * prevValue;\\n        }\\n        else {\\n          sum += currValue;\\n        }\\n        prevValue = currValue;\\n        \\n      }\\n\\n      return sum;\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arvin_draj",
                        "content": "my code works in vs code \\nbut in leetcode the same code for the same test case it dosen\\'t work"
                    },
                    {
                        "username": "harish1402r",
                        "content": "how four is written?\\n"
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "So in Roman four is written by \\'IV\\' and if we split both of these letters then both of them have there own standard values in Roman, so what we have to do is just convert them into \\'IIII\\', and likewise for other values aswell which I have replaced aswell."
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "Hey, here is my answer for this in JS;\\n\\nlet val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10,\\'L\\': 50,\\'C\\': 100,\\'D\\': 500, \\'M\\': 1000};\\nlet sum = 0;\\ns = s.replace(\"IV\",\"IIII\");\\ns = s.replace(\"IX\",\"VIIII\");\\ns = s.replace(\"XL\",\"XXXX\");\\ns = s.replace(\"XC\",\"LXXXX\");\\ns = s.replace(\"CD\",\"CCCC\");\\ns = s.replace(\"CM\",\"DCCCC\");\\n\\nfor(let i = 0; i < s.length; i++){\\n    let z = val[`${s[i]}`];\\n    sum = sum + z;\\n}\\nreturn sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hi!\\nHere are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "santwan",
                        "content": "MY FIRST PROBLEM ON LEET CODE :)"
                    },
                    {
                        "username": "user1840I",
                        "content": "Why is this not being accepted ?\\ns=input()\\n\\nd={\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000}\\ntotal=0\\nprev_value=0\\n\\n\\nfor char in reversed(s) :\\n    if 1 <= len(s) <= 15 and (char in d):\\n         current_value = d[char]\\n         if current_value<prev_value :\\n              total-=current_value\\n            #LIX  XIL\\n\\n         else :\\n             total+=current_value\\n             prev_value=current_value\\n    else :\\n        quit()\\n\\nif total in range(1,4000) :\\n    print(total)\\n\\n\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your Python code is almost correct but needs some minor adjustments. Let\\'s modify it a bit. \\n\\nThe main points are:\\n1. Remove the input length checking inside the loop, we should check this before starting the loop.\\n2. We should remove the `quit()`. This function is used to end a script, and it won\\'t allow you to print the error message. You could use an `else` condition to print an error message.\\n3. The \"total\" value checking at the end is also unnecessary.\\n\\nHere is the modified code:\\n\\n```python\\ns = input()\\n\\nif 1 <= len(s) <= 15:\\n    d = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n    total = 0\\n    prev_value = 0\\n\\n    for char in reversed(s):\\n        if char in d:\\n            current_value = d[char]\\n            if current_value < prev_value:\\n                total -= current_value\\n            else:\\n                total += current_value\\n                prev_value = current_value\\n        else:\\n            print(f\"Invalid input: {char}\")\\n            break\\n    else:\\n        print(total)\\nelse:\\n    print(\"Invalid length of string\")\\n```\\n\\nThis code will print the total value if all the input characters are valid, else it will print an error message."
                    },
                    {
                        "username": "Silver_I0",
                        "content": "am i the only one that used regex?\\n```\\nimport re\\n\\nTHOUSANDS= \\'(M*)\\'\\nHUNDREDS= \\'(C[MD]|D?C{0,3})\\'\\nTENS= \\'(X[CL]|L?X{0,3})\\'\\nUNITS= \\'(I[XV]|V?I{0,3})\\'\\n\\n```\\ni feel like breaking roman numerals (MCDLXVIII) -> 1468\\ninto groups (\\'M\\', \\'CD, \\'LX\\', \\'VIII\\') \\niterating those groups and fetching values from the corresponding dict_keys\\nthen add everything up, was easier."
                    },
                    {
                        "username": "Dragon3000",
                        "content": "This is my first problem ever on leet code. \\n\\nI don\\'t understand what this is. Can anyone explain? Thanks. \\n\\nNameError: global name \\'Solution\\' is not defined\\n    ret = Solution().romanToInt(param_1)\\nLine 22 in _driver (Solution.py)\\n    _driver()\\nLine 32 in <module> (Solution.py)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing is because Python cannot find the definition for the class named \\'Solution\\'.\\n\\nIt seems like you are trying to call a method named `romanToInt` from a class named `Solution`. The error says that Python could not find this class.\\n\\nIn Python, before you can use a class, function, or variable, it must be defined in the current scope. For classes and functions, this means you need to have a `class` or `def` statement executed before you can use the class or function.\\n\\nHere is a simple example of how this works:\\n\\n```python\\nclass Solution:\\n    def romanToInt(self, s):\\n        # Your code here\\n\\n# Now you can use Solution because it has been defined\\nsolution = Solution()\\nret = solution.romanToInt(\"III\")\\n```\\n\\nSo, the error you\\'re seeing indicates that Python couldn\\'t find the class `Solution` at the point in your code where you tried to use it.\\n\\nTo fix this error, you need to ensure that the `Solution` class has been defined before you try to use it. It might be a simple as moving the code that uses `Solution` to a point in your script after the class is defined. Or it might mean importing the `Solution` class from another module if it is defined elsewhere."
                    }
                ]
            },
            {
                "id": 1940036,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "i am not familiar with roman numbers this is difficult for me because of the understanding part"
                    },
                    {
                        "username": "rianrbps",
                        "content": "Time Limit Exceeded, is it because I used a switch case?\\n\\n `int romanToInt(char * s){\\n\\n    int num = 0;\\n    int i = 0;\\n\\n    while(s[i] != \\'\\\\0\\');{\\n        switch (s[i]){\\n            case \\'M\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 900;\\n                }else{\\n                    num += 1000;\\n                }\\n\\n            case \\'D\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 400;\\n                }else{\\n                    num += 500;\\n                }\\n \\n            case \\'C\\':\\n                if(s[i+1] == \\'M\\' || s[i+1] == \\'D\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'X\\'){\\n                        num+=90;\\n                    }else{\\n                        num+= 100;\\n                    }\\n                }\\n            \\n            case \\'L\\':\\n                if(s[i-1] == \\'X\\'){\\n                    num += 40;\\n                }else{\\n                    num += 50;\\n                }\\n\\n            case \\'X\\':\\n                if(s[i+1] == \\'L\\' || s[i+1] == \\'C\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'I\\'){\\n                        num += 9;\\n                    }else{\\n                        num += 10;\\n                    }\\n                }\\n\\n\\n            case \\'V\\':\\n                if(s[i-1] == \\'I\\'){\\n                    num += 4;\\n                }else{\\n                    num += 5;\\n                }\\n\\n\\n            case \\'I\\':\\n                if(s[i+1] == \\'V\\' || s[i+1] == \\'X\\'){\\n                    break;\\n                }else{\\n                    num += 1;\\n                }\\n        }\\n        i++;\\n    }\\n    return num;\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the code runs into an infinite loop, and that\\'s the cause for the Time Limit Exceeded error. The reason is that you have a semicolon `;` right after your `while` condition, which is making the `while` loop run indefinitely without any statements inside it. The code block following this semicolon is then executed as a separate, single-time block, and it\\'s not inside the loop as you intended. This leads to an infinite loop because there\\'s no operation inside the `while` loop that changes the loop\\'s condition (`s[i] != \\'\\\\0\\'`), so it just keeps running.\\n\\nThe correct way to write the `while` loop is:\\n\\n```c\\nwhile(s[i] != \\'\\\\0\\') {\\n    // your switch case and code goes here\\n}\\n```\\nBy fixing this, you should avoid the Time Limit Exceeded error.\\n\\nHowever, there is another logical error in your code related to how you\\'re handling the roman numeral conversion. The switch-case construct doesn\\'t have an automatic break once a case is executed. This means if a case like \\'M\\' or \\'D\\' is hit, the code continues to execute the next cases (\\'C\\', \\'L\\', \\'X\\', \\'V\\', \\'I\\') as well, leading to incorrect results. To avoid this, you need to put a `break` statement at the end of each case:\\n\\n```c\\nswitch (s[i]){\\n    case \\'M\\':\\n        // some code here\\n        break;\\n    case \\'D\\':\\n        // some code here\\n        break;\\n    // similar for other cases\\n}\\n```\\n\\nBy adding these `break` statements, you ensure that the switch-case construct exits after executing a matching case."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you still can\\'t find the way to solve, see my code , I just create a map ( you can create a switch case ) then you will loop full string and compare two adjacent item \\nclass Solution {\\n    public int romanToInt(String s) {\\n    Map<Character,Integer> map = new HashMap<Character, Integer> ();\\n      int sum = 0 ;\\n      int prevValue = 0;\\n      int currValue = 0;\\n      map.put(\\'I\\',1);\\n      map.put(\\'V\\',5);\\n      map.put(\\'X\\',10);\\n      map.put(\\'L\\',50);\\n      map.put(\\'C\\',100);\\n      map.put(\\'D\\',500);\\n      map.put(\\'M\\',1000);\\n\\n      for(int i=0 ; i< s.length(); i++) {\\n        currValue = map.get(s.charAt(i));\\n        if(currValue > prevValue ) {\\n          sum += currValue - 2 * prevValue;\\n        }\\n        else {\\n          sum += currValue;\\n        }\\n        prevValue = currValue;\\n        \\n      }\\n\\n      return sum;\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arvin_draj",
                        "content": "my code works in vs code \\nbut in leetcode the same code for the same test case it dosen\\'t work"
                    },
                    {
                        "username": "harish1402r",
                        "content": "how four is written?\\n"
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "So in Roman four is written by \\'IV\\' and if we split both of these letters then both of them have there own standard values in Roman, so what we have to do is just convert them into \\'IIII\\', and likewise for other values aswell which I have replaced aswell."
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "Hey, here is my answer for this in JS;\\n\\nlet val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10,\\'L\\': 50,\\'C\\': 100,\\'D\\': 500, \\'M\\': 1000};\\nlet sum = 0;\\ns = s.replace(\"IV\",\"IIII\");\\ns = s.replace(\"IX\",\"VIIII\");\\ns = s.replace(\"XL\",\"XXXX\");\\ns = s.replace(\"XC\",\"LXXXX\");\\ns = s.replace(\"CD\",\"CCCC\");\\ns = s.replace(\"CM\",\"DCCCC\");\\n\\nfor(let i = 0; i < s.length; i++){\\n    let z = val[`${s[i]}`];\\n    sum = sum + z;\\n}\\nreturn sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hi!\\nHere are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "santwan",
                        "content": "MY FIRST PROBLEM ON LEET CODE :)"
                    },
                    {
                        "username": "user1840I",
                        "content": "Why is this not being accepted ?\\ns=input()\\n\\nd={\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000}\\ntotal=0\\nprev_value=0\\n\\n\\nfor char in reversed(s) :\\n    if 1 <= len(s) <= 15 and (char in d):\\n         current_value = d[char]\\n         if current_value<prev_value :\\n              total-=current_value\\n            #LIX  XIL\\n\\n         else :\\n             total+=current_value\\n             prev_value=current_value\\n    else :\\n        quit()\\n\\nif total in range(1,4000) :\\n    print(total)\\n\\n\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your Python code is almost correct but needs some minor adjustments. Let\\'s modify it a bit. \\n\\nThe main points are:\\n1. Remove the input length checking inside the loop, we should check this before starting the loop.\\n2. We should remove the `quit()`. This function is used to end a script, and it won\\'t allow you to print the error message. You could use an `else` condition to print an error message.\\n3. The \"total\" value checking at the end is also unnecessary.\\n\\nHere is the modified code:\\n\\n```python\\ns = input()\\n\\nif 1 <= len(s) <= 15:\\n    d = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n    total = 0\\n    prev_value = 0\\n\\n    for char in reversed(s):\\n        if char in d:\\n            current_value = d[char]\\n            if current_value < prev_value:\\n                total -= current_value\\n            else:\\n                total += current_value\\n                prev_value = current_value\\n        else:\\n            print(f\"Invalid input: {char}\")\\n            break\\n    else:\\n        print(total)\\nelse:\\n    print(\"Invalid length of string\")\\n```\\n\\nThis code will print the total value if all the input characters are valid, else it will print an error message."
                    },
                    {
                        "username": "Silver_I0",
                        "content": "am i the only one that used regex?\\n```\\nimport re\\n\\nTHOUSANDS= \\'(M*)\\'\\nHUNDREDS= \\'(C[MD]|D?C{0,3})\\'\\nTENS= \\'(X[CL]|L?X{0,3})\\'\\nUNITS= \\'(I[XV]|V?I{0,3})\\'\\n\\n```\\ni feel like breaking roman numerals (MCDLXVIII) -> 1468\\ninto groups (\\'M\\', \\'CD, \\'LX\\', \\'VIII\\') \\niterating those groups and fetching values from the corresponding dict_keys\\nthen add everything up, was easier."
                    },
                    {
                        "username": "Dragon3000",
                        "content": "This is my first problem ever on leet code. \\n\\nI don\\'t understand what this is. Can anyone explain? Thanks. \\n\\nNameError: global name \\'Solution\\' is not defined\\n    ret = Solution().romanToInt(param_1)\\nLine 22 in _driver (Solution.py)\\n    _driver()\\nLine 32 in <module> (Solution.py)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing is because Python cannot find the definition for the class named \\'Solution\\'.\\n\\nIt seems like you are trying to call a method named `romanToInt` from a class named `Solution`. The error says that Python could not find this class.\\n\\nIn Python, before you can use a class, function, or variable, it must be defined in the current scope. For classes and functions, this means you need to have a `class` or `def` statement executed before you can use the class or function.\\n\\nHere is a simple example of how this works:\\n\\n```python\\nclass Solution:\\n    def romanToInt(self, s):\\n        # Your code here\\n\\n# Now you can use Solution because it has been defined\\nsolution = Solution()\\nret = solution.romanToInt(\"III\")\\n```\\n\\nSo, the error you\\'re seeing indicates that Python couldn\\'t find the class `Solution` at the point in your code where you tried to use it.\\n\\nTo fix this error, you need to ensure that the `Solution` class has been defined before you try to use it. It might be a simple as moving the code that uses `Solution` to a point in your script after the class is defined. Or it might mean importing the `Solution` class from another module if it is defined elsewhere."
                    }
                ]
            },
            {
                "id": 1938867,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "i am not familiar with roman numbers this is difficult for me because of the understanding part"
                    },
                    {
                        "username": "rianrbps",
                        "content": "Time Limit Exceeded, is it because I used a switch case?\\n\\n `int romanToInt(char * s){\\n\\n    int num = 0;\\n    int i = 0;\\n\\n    while(s[i] != \\'\\\\0\\');{\\n        switch (s[i]){\\n            case \\'M\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 900;\\n                }else{\\n                    num += 1000;\\n                }\\n\\n            case \\'D\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 400;\\n                }else{\\n                    num += 500;\\n                }\\n \\n            case \\'C\\':\\n                if(s[i+1] == \\'M\\' || s[i+1] == \\'D\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'X\\'){\\n                        num+=90;\\n                    }else{\\n                        num+= 100;\\n                    }\\n                }\\n            \\n            case \\'L\\':\\n                if(s[i-1] == \\'X\\'){\\n                    num += 40;\\n                }else{\\n                    num += 50;\\n                }\\n\\n            case \\'X\\':\\n                if(s[i+1] == \\'L\\' || s[i+1] == \\'C\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'I\\'){\\n                        num += 9;\\n                    }else{\\n                        num += 10;\\n                    }\\n                }\\n\\n\\n            case \\'V\\':\\n                if(s[i-1] == \\'I\\'){\\n                    num += 4;\\n                }else{\\n                    num += 5;\\n                }\\n\\n\\n            case \\'I\\':\\n                if(s[i+1] == \\'V\\' || s[i+1] == \\'X\\'){\\n                    break;\\n                }else{\\n                    num += 1;\\n                }\\n        }\\n        i++;\\n    }\\n    return num;\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the code runs into an infinite loop, and that\\'s the cause for the Time Limit Exceeded error. The reason is that you have a semicolon `;` right after your `while` condition, which is making the `while` loop run indefinitely without any statements inside it. The code block following this semicolon is then executed as a separate, single-time block, and it\\'s not inside the loop as you intended. This leads to an infinite loop because there\\'s no operation inside the `while` loop that changes the loop\\'s condition (`s[i] != \\'\\\\0\\'`), so it just keeps running.\\n\\nThe correct way to write the `while` loop is:\\n\\n```c\\nwhile(s[i] != \\'\\\\0\\') {\\n    // your switch case and code goes here\\n}\\n```\\nBy fixing this, you should avoid the Time Limit Exceeded error.\\n\\nHowever, there is another logical error in your code related to how you\\'re handling the roman numeral conversion. The switch-case construct doesn\\'t have an automatic break once a case is executed. This means if a case like \\'M\\' or \\'D\\' is hit, the code continues to execute the next cases (\\'C\\', \\'L\\', \\'X\\', \\'V\\', \\'I\\') as well, leading to incorrect results. To avoid this, you need to put a `break` statement at the end of each case:\\n\\n```c\\nswitch (s[i]){\\n    case \\'M\\':\\n        // some code here\\n        break;\\n    case \\'D\\':\\n        // some code here\\n        break;\\n    // similar for other cases\\n}\\n```\\n\\nBy adding these `break` statements, you ensure that the switch-case construct exits after executing a matching case."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you still can\\'t find the way to solve, see my code , I just create a map ( you can create a switch case ) then you will loop full string and compare two adjacent item \\nclass Solution {\\n    public int romanToInt(String s) {\\n    Map<Character,Integer> map = new HashMap<Character, Integer> ();\\n      int sum = 0 ;\\n      int prevValue = 0;\\n      int currValue = 0;\\n      map.put(\\'I\\',1);\\n      map.put(\\'V\\',5);\\n      map.put(\\'X\\',10);\\n      map.put(\\'L\\',50);\\n      map.put(\\'C\\',100);\\n      map.put(\\'D\\',500);\\n      map.put(\\'M\\',1000);\\n\\n      for(int i=0 ; i< s.length(); i++) {\\n        currValue = map.get(s.charAt(i));\\n        if(currValue > prevValue ) {\\n          sum += currValue - 2 * prevValue;\\n        }\\n        else {\\n          sum += currValue;\\n        }\\n        prevValue = currValue;\\n        \\n      }\\n\\n      return sum;\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arvin_draj",
                        "content": "my code works in vs code \\nbut in leetcode the same code for the same test case it dosen\\'t work"
                    },
                    {
                        "username": "harish1402r",
                        "content": "how four is written?\\n"
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "So in Roman four is written by \\'IV\\' and if we split both of these letters then both of them have there own standard values in Roman, so what we have to do is just convert them into \\'IIII\\', and likewise for other values aswell which I have replaced aswell."
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "Hey, here is my answer for this in JS;\\n\\nlet val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10,\\'L\\': 50,\\'C\\': 100,\\'D\\': 500, \\'M\\': 1000};\\nlet sum = 0;\\ns = s.replace(\"IV\",\"IIII\");\\ns = s.replace(\"IX\",\"VIIII\");\\ns = s.replace(\"XL\",\"XXXX\");\\ns = s.replace(\"XC\",\"LXXXX\");\\ns = s.replace(\"CD\",\"CCCC\");\\ns = s.replace(\"CM\",\"DCCCC\");\\n\\nfor(let i = 0; i < s.length; i++){\\n    let z = val[`${s[i]}`];\\n    sum = sum + z;\\n}\\nreturn sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hi!\\nHere are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "santwan",
                        "content": "MY FIRST PROBLEM ON LEET CODE :)"
                    },
                    {
                        "username": "user1840I",
                        "content": "Why is this not being accepted ?\\ns=input()\\n\\nd={\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000}\\ntotal=0\\nprev_value=0\\n\\n\\nfor char in reversed(s) :\\n    if 1 <= len(s) <= 15 and (char in d):\\n         current_value = d[char]\\n         if current_value<prev_value :\\n              total-=current_value\\n            #LIX  XIL\\n\\n         else :\\n             total+=current_value\\n             prev_value=current_value\\n    else :\\n        quit()\\n\\nif total in range(1,4000) :\\n    print(total)\\n\\n\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your Python code is almost correct but needs some minor adjustments. Let\\'s modify it a bit. \\n\\nThe main points are:\\n1. Remove the input length checking inside the loop, we should check this before starting the loop.\\n2. We should remove the `quit()`. This function is used to end a script, and it won\\'t allow you to print the error message. You could use an `else` condition to print an error message.\\n3. The \"total\" value checking at the end is also unnecessary.\\n\\nHere is the modified code:\\n\\n```python\\ns = input()\\n\\nif 1 <= len(s) <= 15:\\n    d = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n    total = 0\\n    prev_value = 0\\n\\n    for char in reversed(s):\\n        if char in d:\\n            current_value = d[char]\\n            if current_value < prev_value:\\n                total -= current_value\\n            else:\\n                total += current_value\\n                prev_value = current_value\\n        else:\\n            print(f\"Invalid input: {char}\")\\n            break\\n    else:\\n        print(total)\\nelse:\\n    print(\"Invalid length of string\")\\n```\\n\\nThis code will print the total value if all the input characters are valid, else it will print an error message."
                    },
                    {
                        "username": "Silver_I0",
                        "content": "am i the only one that used regex?\\n```\\nimport re\\n\\nTHOUSANDS= \\'(M*)\\'\\nHUNDREDS= \\'(C[MD]|D?C{0,3})\\'\\nTENS= \\'(X[CL]|L?X{0,3})\\'\\nUNITS= \\'(I[XV]|V?I{0,3})\\'\\n\\n```\\ni feel like breaking roman numerals (MCDLXVIII) -> 1468\\ninto groups (\\'M\\', \\'CD, \\'LX\\', \\'VIII\\') \\niterating those groups and fetching values from the corresponding dict_keys\\nthen add everything up, was easier."
                    },
                    {
                        "username": "Dragon3000",
                        "content": "This is my first problem ever on leet code. \\n\\nI don\\'t understand what this is. Can anyone explain? Thanks. \\n\\nNameError: global name \\'Solution\\' is not defined\\n    ret = Solution().romanToInt(param_1)\\nLine 22 in _driver (Solution.py)\\n    _driver()\\nLine 32 in <module> (Solution.py)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing is because Python cannot find the definition for the class named \\'Solution\\'.\\n\\nIt seems like you are trying to call a method named `romanToInt` from a class named `Solution`. The error says that Python could not find this class.\\n\\nIn Python, before you can use a class, function, or variable, it must be defined in the current scope. For classes and functions, this means you need to have a `class` or `def` statement executed before you can use the class or function.\\n\\nHere is a simple example of how this works:\\n\\n```python\\nclass Solution:\\n    def romanToInt(self, s):\\n        # Your code here\\n\\n# Now you can use Solution because it has been defined\\nsolution = Solution()\\nret = solution.romanToInt(\"III\")\\n```\\n\\nSo, the error you\\'re seeing indicates that Python couldn\\'t find the class `Solution` at the point in your code where you tried to use it.\\n\\nTo fix this error, you need to ensure that the `Solution` class has been defined before you try to use it. It might be a simple as moving the code that uses `Solution` to a point in your script after the class is defined. Or it might mean importing the `Solution` class from another module if it is defined elsewhere."
                    }
                ]
            },
            {
                "id": 1937337,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "i am not familiar with roman numbers this is difficult for me because of the understanding part"
                    },
                    {
                        "username": "rianrbps",
                        "content": "Time Limit Exceeded, is it because I used a switch case?\\n\\n `int romanToInt(char * s){\\n\\n    int num = 0;\\n    int i = 0;\\n\\n    while(s[i] != \\'\\\\0\\');{\\n        switch (s[i]){\\n            case \\'M\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 900;\\n                }else{\\n                    num += 1000;\\n                }\\n\\n            case \\'D\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 400;\\n                }else{\\n                    num += 500;\\n                }\\n \\n            case \\'C\\':\\n                if(s[i+1] == \\'M\\' || s[i+1] == \\'D\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'X\\'){\\n                        num+=90;\\n                    }else{\\n                        num+= 100;\\n                    }\\n                }\\n            \\n            case \\'L\\':\\n                if(s[i-1] == \\'X\\'){\\n                    num += 40;\\n                }else{\\n                    num += 50;\\n                }\\n\\n            case \\'X\\':\\n                if(s[i+1] == \\'L\\' || s[i+1] == \\'C\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'I\\'){\\n                        num += 9;\\n                    }else{\\n                        num += 10;\\n                    }\\n                }\\n\\n\\n            case \\'V\\':\\n                if(s[i-1] == \\'I\\'){\\n                    num += 4;\\n                }else{\\n                    num += 5;\\n                }\\n\\n\\n            case \\'I\\':\\n                if(s[i+1] == \\'V\\' || s[i+1] == \\'X\\'){\\n                    break;\\n                }else{\\n                    num += 1;\\n                }\\n        }\\n        i++;\\n    }\\n    return num;\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the code runs into an infinite loop, and that\\'s the cause for the Time Limit Exceeded error. The reason is that you have a semicolon `;` right after your `while` condition, which is making the `while` loop run indefinitely without any statements inside it. The code block following this semicolon is then executed as a separate, single-time block, and it\\'s not inside the loop as you intended. This leads to an infinite loop because there\\'s no operation inside the `while` loop that changes the loop\\'s condition (`s[i] != \\'\\\\0\\'`), so it just keeps running.\\n\\nThe correct way to write the `while` loop is:\\n\\n```c\\nwhile(s[i] != \\'\\\\0\\') {\\n    // your switch case and code goes here\\n}\\n```\\nBy fixing this, you should avoid the Time Limit Exceeded error.\\n\\nHowever, there is another logical error in your code related to how you\\'re handling the roman numeral conversion. The switch-case construct doesn\\'t have an automatic break once a case is executed. This means if a case like \\'M\\' or \\'D\\' is hit, the code continues to execute the next cases (\\'C\\', \\'L\\', \\'X\\', \\'V\\', \\'I\\') as well, leading to incorrect results. To avoid this, you need to put a `break` statement at the end of each case:\\n\\n```c\\nswitch (s[i]){\\n    case \\'M\\':\\n        // some code here\\n        break;\\n    case \\'D\\':\\n        // some code here\\n        break;\\n    // similar for other cases\\n}\\n```\\n\\nBy adding these `break` statements, you ensure that the switch-case construct exits after executing a matching case."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you still can\\'t find the way to solve, see my code , I just create a map ( you can create a switch case ) then you will loop full string and compare two adjacent item \\nclass Solution {\\n    public int romanToInt(String s) {\\n    Map<Character,Integer> map = new HashMap<Character, Integer> ();\\n      int sum = 0 ;\\n      int prevValue = 0;\\n      int currValue = 0;\\n      map.put(\\'I\\',1);\\n      map.put(\\'V\\',5);\\n      map.put(\\'X\\',10);\\n      map.put(\\'L\\',50);\\n      map.put(\\'C\\',100);\\n      map.put(\\'D\\',500);\\n      map.put(\\'M\\',1000);\\n\\n      for(int i=0 ; i< s.length(); i++) {\\n        currValue = map.get(s.charAt(i));\\n        if(currValue > prevValue ) {\\n          sum += currValue - 2 * prevValue;\\n        }\\n        else {\\n          sum += currValue;\\n        }\\n        prevValue = currValue;\\n        \\n      }\\n\\n      return sum;\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arvin_draj",
                        "content": "my code works in vs code \\nbut in leetcode the same code for the same test case it dosen\\'t work"
                    },
                    {
                        "username": "harish1402r",
                        "content": "how four is written?\\n"
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "So in Roman four is written by \\'IV\\' and if we split both of these letters then both of them have there own standard values in Roman, so what we have to do is just convert them into \\'IIII\\', and likewise for other values aswell which I have replaced aswell."
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "Hey, here is my answer for this in JS;\\n\\nlet val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10,\\'L\\': 50,\\'C\\': 100,\\'D\\': 500, \\'M\\': 1000};\\nlet sum = 0;\\ns = s.replace(\"IV\",\"IIII\");\\ns = s.replace(\"IX\",\"VIIII\");\\ns = s.replace(\"XL\",\"XXXX\");\\ns = s.replace(\"XC\",\"LXXXX\");\\ns = s.replace(\"CD\",\"CCCC\");\\ns = s.replace(\"CM\",\"DCCCC\");\\n\\nfor(let i = 0; i < s.length; i++){\\n    let z = val[`${s[i]}`];\\n    sum = sum + z;\\n}\\nreturn sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hi!\\nHere are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "santwan",
                        "content": "MY FIRST PROBLEM ON LEET CODE :)"
                    },
                    {
                        "username": "user1840I",
                        "content": "Why is this not being accepted ?\\ns=input()\\n\\nd={\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000}\\ntotal=0\\nprev_value=0\\n\\n\\nfor char in reversed(s) :\\n    if 1 <= len(s) <= 15 and (char in d):\\n         current_value = d[char]\\n         if current_value<prev_value :\\n              total-=current_value\\n            #LIX  XIL\\n\\n         else :\\n             total+=current_value\\n             prev_value=current_value\\n    else :\\n        quit()\\n\\nif total in range(1,4000) :\\n    print(total)\\n\\n\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your Python code is almost correct but needs some minor adjustments. Let\\'s modify it a bit. \\n\\nThe main points are:\\n1. Remove the input length checking inside the loop, we should check this before starting the loop.\\n2. We should remove the `quit()`. This function is used to end a script, and it won\\'t allow you to print the error message. You could use an `else` condition to print an error message.\\n3. The \"total\" value checking at the end is also unnecessary.\\n\\nHere is the modified code:\\n\\n```python\\ns = input()\\n\\nif 1 <= len(s) <= 15:\\n    d = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n    total = 0\\n    prev_value = 0\\n\\n    for char in reversed(s):\\n        if char in d:\\n            current_value = d[char]\\n            if current_value < prev_value:\\n                total -= current_value\\n            else:\\n                total += current_value\\n                prev_value = current_value\\n        else:\\n            print(f\"Invalid input: {char}\")\\n            break\\n    else:\\n        print(total)\\nelse:\\n    print(\"Invalid length of string\")\\n```\\n\\nThis code will print the total value if all the input characters are valid, else it will print an error message."
                    },
                    {
                        "username": "Silver_I0",
                        "content": "am i the only one that used regex?\\n```\\nimport re\\n\\nTHOUSANDS= \\'(M*)\\'\\nHUNDREDS= \\'(C[MD]|D?C{0,3})\\'\\nTENS= \\'(X[CL]|L?X{0,3})\\'\\nUNITS= \\'(I[XV]|V?I{0,3})\\'\\n\\n```\\ni feel like breaking roman numerals (MCDLXVIII) -> 1468\\ninto groups (\\'M\\', \\'CD, \\'LX\\', \\'VIII\\') \\niterating those groups and fetching values from the corresponding dict_keys\\nthen add everything up, was easier."
                    },
                    {
                        "username": "Dragon3000",
                        "content": "This is my first problem ever on leet code. \\n\\nI don\\'t understand what this is. Can anyone explain? Thanks. \\n\\nNameError: global name \\'Solution\\' is not defined\\n    ret = Solution().romanToInt(param_1)\\nLine 22 in _driver (Solution.py)\\n    _driver()\\nLine 32 in <module> (Solution.py)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing is because Python cannot find the definition for the class named \\'Solution\\'.\\n\\nIt seems like you are trying to call a method named `romanToInt` from a class named `Solution`. The error says that Python could not find this class.\\n\\nIn Python, before you can use a class, function, or variable, it must be defined in the current scope. For classes and functions, this means you need to have a `class` or `def` statement executed before you can use the class or function.\\n\\nHere is a simple example of how this works:\\n\\n```python\\nclass Solution:\\n    def romanToInt(self, s):\\n        # Your code here\\n\\n# Now you can use Solution because it has been defined\\nsolution = Solution()\\nret = solution.romanToInt(\"III\")\\n```\\n\\nSo, the error you\\'re seeing indicates that Python couldn\\'t find the class `Solution` at the point in your code where you tried to use it.\\n\\nTo fix this error, you need to ensure that the `Solution` class has been defined before you try to use it. It might be a simple as moving the code that uses `Solution` to a point in your script after the class is defined. Or it might mean importing the `Solution` class from another module if it is defined elsewhere."
                    }
                ]
            },
            {
                "id": 1934991,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "i am not familiar with roman numbers this is difficult for me because of the understanding part"
                    },
                    {
                        "username": "rianrbps",
                        "content": "Time Limit Exceeded, is it because I used a switch case?\\n\\n `int romanToInt(char * s){\\n\\n    int num = 0;\\n    int i = 0;\\n\\n    while(s[i] != \\'\\\\0\\');{\\n        switch (s[i]){\\n            case \\'M\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 900;\\n                }else{\\n                    num += 1000;\\n                }\\n\\n            case \\'D\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 400;\\n                }else{\\n                    num += 500;\\n                }\\n \\n            case \\'C\\':\\n                if(s[i+1] == \\'M\\' || s[i+1] == \\'D\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'X\\'){\\n                        num+=90;\\n                    }else{\\n                        num+= 100;\\n                    }\\n                }\\n            \\n            case \\'L\\':\\n                if(s[i-1] == \\'X\\'){\\n                    num += 40;\\n                }else{\\n                    num += 50;\\n                }\\n\\n            case \\'X\\':\\n                if(s[i+1] == \\'L\\' || s[i+1] == \\'C\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'I\\'){\\n                        num += 9;\\n                    }else{\\n                        num += 10;\\n                    }\\n                }\\n\\n\\n            case \\'V\\':\\n                if(s[i-1] == \\'I\\'){\\n                    num += 4;\\n                }else{\\n                    num += 5;\\n                }\\n\\n\\n            case \\'I\\':\\n                if(s[i+1] == \\'V\\' || s[i+1] == \\'X\\'){\\n                    break;\\n                }else{\\n                    num += 1;\\n                }\\n        }\\n        i++;\\n    }\\n    return num;\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the code runs into an infinite loop, and that\\'s the cause for the Time Limit Exceeded error. The reason is that you have a semicolon `;` right after your `while` condition, which is making the `while` loop run indefinitely without any statements inside it. The code block following this semicolon is then executed as a separate, single-time block, and it\\'s not inside the loop as you intended. This leads to an infinite loop because there\\'s no operation inside the `while` loop that changes the loop\\'s condition (`s[i] != \\'\\\\0\\'`), so it just keeps running.\\n\\nThe correct way to write the `while` loop is:\\n\\n```c\\nwhile(s[i] != \\'\\\\0\\') {\\n    // your switch case and code goes here\\n}\\n```\\nBy fixing this, you should avoid the Time Limit Exceeded error.\\n\\nHowever, there is another logical error in your code related to how you\\'re handling the roman numeral conversion. The switch-case construct doesn\\'t have an automatic break once a case is executed. This means if a case like \\'M\\' or \\'D\\' is hit, the code continues to execute the next cases (\\'C\\', \\'L\\', \\'X\\', \\'V\\', \\'I\\') as well, leading to incorrect results. To avoid this, you need to put a `break` statement at the end of each case:\\n\\n```c\\nswitch (s[i]){\\n    case \\'M\\':\\n        // some code here\\n        break;\\n    case \\'D\\':\\n        // some code here\\n        break;\\n    // similar for other cases\\n}\\n```\\n\\nBy adding these `break` statements, you ensure that the switch-case construct exits after executing a matching case."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you still can\\'t find the way to solve, see my code , I just create a map ( you can create a switch case ) then you will loop full string and compare two adjacent item \\nclass Solution {\\n    public int romanToInt(String s) {\\n    Map<Character,Integer> map = new HashMap<Character, Integer> ();\\n      int sum = 0 ;\\n      int prevValue = 0;\\n      int currValue = 0;\\n      map.put(\\'I\\',1);\\n      map.put(\\'V\\',5);\\n      map.put(\\'X\\',10);\\n      map.put(\\'L\\',50);\\n      map.put(\\'C\\',100);\\n      map.put(\\'D\\',500);\\n      map.put(\\'M\\',1000);\\n\\n      for(int i=0 ; i< s.length(); i++) {\\n        currValue = map.get(s.charAt(i));\\n        if(currValue > prevValue ) {\\n          sum += currValue - 2 * prevValue;\\n        }\\n        else {\\n          sum += currValue;\\n        }\\n        prevValue = currValue;\\n        \\n      }\\n\\n      return sum;\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arvin_draj",
                        "content": "my code works in vs code \\nbut in leetcode the same code for the same test case it dosen\\'t work"
                    },
                    {
                        "username": "harish1402r",
                        "content": "how four is written?\\n"
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "So in Roman four is written by \\'IV\\' and if we split both of these letters then both of them have there own standard values in Roman, so what we have to do is just convert them into \\'IIII\\', and likewise for other values aswell which I have replaced aswell."
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "Hey, here is my answer for this in JS;\\n\\nlet val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10,\\'L\\': 50,\\'C\\': 100,\\'D\\': 500, \\'M\\': 1000};\\nlet sum = 0;\\ns = s.replace(\"IV\",\"IIII\");\\ns = s.replace(\"IX\",\"VIIII\");\\ns = s.replace(\"XL\",\"XXXX\");\\ns = s.replace(\"XC\",\"LXXXX\");\\ns = s.replace(\"CD\",\"CCCC\");\\ns = s.replace(\"CM\",\"DCCCC\");\\n\\nfor(let i = 0; i < s.length; i++){\\n    let z = val[`${s[i]}`];\\n    sum = sum + z;\\n}\\nreturn sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hi!\\nHere are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "santwan",
                        "content": "MY FIRST PROBLEM ON LEET CODE :)"
                    },
                    {
                        "username": "user1840I",
                        "content": "Why is this not being accepted ?\\ns=input()\\n\\nd={\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000}\\ntotal=0\\nprev_value=0\\n\\n\\nfor char in reversed(s) :\\n    if 1 <= len(s) <= 15 and (char in d):\\n         current_value = d[char]\\n         if current_value<prev_value :\\n              total-=current_value\\n            #LIX  XIL\\n\\n         else :\\n             total+=current_value\\n             prev_value=current_value\\n    else :\\n        quit()\\n\\nif total in range(1,4000) :\\n    print(total)\\n\\n\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your Python code is almost correct but needs some minor adjustments. Let\\'s modify it a bit. \\n\\nThe main points are:\\n1. Remove the input length checking inside the loop, we should check this before starting the loop.\\n2. We should remove the `quit()`. This function is used to end a script, and it won\\'t allow you to print the error message. You could use an `else` condition to print an error message.\\n3. The \"total\" value checking at the end is also unnecessary.\\n\\nHere is the modified code:\\n\\n```python\\ns = input()\\n\\nif 1 <= len(s) <= 15:\\n    d = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n    total = 0\\n    prev_value = 0\\n\\n    for char in reversed(s):\\n        if char in d:\\n            current_value = d[char]\\n            if current_value < prev_value:\\n                total -= current_value\\n            else:\\n                total += current_value\\n                prev_value = current_value\\n        else:\\n            print(f\"Invalid input: {char}\")\\n            break\\n    else:\\n        print(total)\\nelse:\\n    print(\"Invalid length of string\")\\n```\\n\\nThis code will print the total value if all the input characters are valid, else it will print an error message."
                    },
                    {
                        "username": "Silver_I0",
                        "content": "am i the only one that used regex?\\n```\\nimport re\\n\\nTHOUSANDS= \\'(M*)\\'\\nHUNDREDS= \\'(C[MD]|D?C{0,3})\\'\\nTENS= \\'(X[CL]|L?X{0,3})\\'\\nUNITS= \\'(I[XV]|V?I{0,3})\\'\\n\\n```\\ni feel like breaking roman numerals (MCDLXVIII) -> 1468\\ninto groups (\\'M\\', \\'CD, \\'LX\\', \\'VIII\\') \\niterating those groups and fetching values from the corresponding dict_keys\\nthen add everything up, was easier."
                    },
                    {
                        "username": "Dragon3000",
                        "content": "This is my first problem ever on leet code. \\n\\nI don\\'t understand what this is. Can anyone explain? Thanks. \\n\\nNameError: global name \\'Solution\\' is not defined\\n    ret = Solution().romanToInt(param_1)\\nLine 22 in _driver (Solution.py)\\n    _driver()\\nLine 32 in <module> (Solution.py)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing is because Python cannot find the definition for the class named \\'Solution\\'.\\n\\nIt seems like you are trying to call a method named `romanToInt` from a class named `Solution`. The error says that Python could not find this class.\\n\\nIn Python, before you can use a class, function, or variable, it must be defined in the current scope. For classes and functions, this means you need to have a `class` or `def` statement executed before you can use the class or function.\\n\\nHere is a simple example of how this works:\\n\\n```python\\nclass Solution:\\n    def romanToInt(self, s):\\n        # Your code here\\n\\n# Now you can use Solution because it has been defined\\nsolution = Solution()\\nret = solution.romanToInt(\"III\")\\n```\\n\\nSo, the error you\\'re seeing indicates that Python couldn\\'t find the class `Solution` at the point in your code where you tried to use it.\\n\\nTo fix this error, you need to ensure that the `Solution` class has been defined before you try to use it. It might be a simple as moving the code that uses `Solution` to a point in your script after the class is defined. Or it might mean importing the `Solution` class from another module if it is defined elsewhere."
                    }
                ]
            },
            {
                "id": 1933063,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "i am not familiar with roman numbers this is difficult for me because of the understanding part"
                    },
                    {
                        "username": "rianrbps",
                        "content": "Time Limit Exceeded, is it because I used a switch case?\\n\\n `int romanToInt(char * s){\\n\\n    int num = 0;\\n    int i = 0;\\n\\n    while(s[i] != \\'\\\\0\\');{\\n        switch (s[i]){\\n            case \\'M\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 900;\\n                }else{\\n                    num += 1000;\\n                }\\n\\n            case \\'D\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 400;\\n                }else{\\n                    num += 500;\\n                }\\n \\n            case \\'C\\':\\n                if(s[i+1] == \\'M\\' || s[i+1] == \\'D\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'X\\'){\\n                        num+=90;\\n                    }else{\\n                        num+= 100;\\n                    }\\n                }\\n            \\n            case \\'L\\':\\n                if(s[i-1] == \\'X\\'){\\n                    num += 40;\\n                }else{\\n                    num += 50;\\n                }\\n\\n            case \\'X\\':\\n                if(s[i+1] == \\'L\\' || s[i+1] == \\'C\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'I\\'){\\n                        num += 9;\\n                    }else{\\n                        num += 10;\\n                    }\\n                }\\n\\n\\n            case \\'V\\':\\n                if(s[i-1] == \\'I\\'){\\n                    num += 4;\\n                }else{\\n                    num += 5;\\n                }\\n\\n\\n            case \\'I\\':\\n                if(s[i+1] == \\'V\\' || s[i+1] == \\'X\\'){\\n                    break;\\n                }else{\\n                    num += 1;\\n                }\\n        }\\n        i++;\\n    }\\n    return num;\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the code runs into an infinite loop, and that\\'s the cause for the Time Limit Exceeded error. The reason is that you have a semicolon `;` right after your `while` condition, which is making the `while` loop run indefinitely without any statements inside it. The code block following this semicolon is then executed as a separate, single-time block, and it\\'s not inside the loop as you intended. This leads to an infinite loop because there\\'s no operation inside the `while` loop that changes the loop\\'s condition (`s[i] != \\'\\\\0\\'`), so it just keeps running.\\n\\nThe correct way to write the `while` loop is:\\n\\n```c\\nwhile(s[i] != \\'\\\\0\\') {\\n    // your switch case and code goes here\\n}\\n```\\nBy fixing this, you should avoid the Time Limit Exceeded error.\\n\\nHowever, there is another logical error in your code related to how you\\'re handling the roman numeral conversion. The switch-case construct doesn\\'t have an automatic break once a case is executed. This means if a case like \\'M\\' or \\'D\\' is hit, the code continues to execute the next cases (\\'C\\', \\'L\\', \\'X\\', \\'V\\', \\'I\\') as well, leading to incorrect results. To avoid this, you need to put a `break` statement at the end of each case:\\n\\n```c\\nswitch (s[i]){\\n    case \\'M\\':\\n        // some code here\\n        break;\\n    case \\'D\\':\\n        // some code here\\n        break;\\n    // similar for other cases\\n}\\n```\\n\\nBy adding these `break` statements, you ensure that the switch-case construct exits after executing a matching case."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you still can\\'t find the way to solve, see my code , I just create a map ( you can create a switch case ) then you will loop full string and compare two adjacent item \\nclass Solution {\\n    public int romanToInt(String s) {\\n    Map<Character,Integer> map = new HashMap<Character, Integer> ();\\n      int sum = 0 ;\\n      int prevValue = 0;\\n      int currValue = 0;\\n      map.put(\\'I\\',1);\\n      map.put(\\'V\\',5);\\n      map.put(\\'X\\',10);\\n      map.put(\\'L\\',50);\\n      map.put(\\'C\\',100);\\n      map.put(\\'D\\',500);\\n      map.put(\\'M\\',1000);\\n\\n      for(int i=0 ; i< s.length(); i++) {\\n        currValue = map.get(s.charAt(i));\\n        if(currValue > prevValue ) {\\n          sum += currValue - 2 * prevValue;\\n        }\\n        else {\\n          sum += currValue;\\n        }\\n        prevValue = currValue;\\n        \\n      }\\n\\n      return sum;\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arvin_draj",
                        "content": "my code works in vs code \\nbut in leetcode the same code for the same test case it dosen\\'t work"
                    },
                    {
                        "username": "harish1402r",
                        "content": "how four is written?\\n"
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "So in Roman four is written by \\'IV\\' and if we split both of these letters then both of them have there own standard values in Roman, so what we have to do is just convert them into \\'IIII\\', and likewise for other values aswell which I have replaced aswell."
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "Hey, here is my answer for this in JS;\\n\\nlet val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10,\\'L\\': 50,\\'C\\': 100,\\'D\\': 500, \\'M\\': 1000};\\nlet sum = 0;\\ns = s.replace(\"IV\",\"IIII\");\\ns = s.replace(\"IX\",\"VIIII\");\\ns = s.replace(\"XL\",\"XXXX\");\\ns = s.replace(\"XC\",\"LXXXX\");\\ns = s.replace(\"CD\",\"CCCC\");\\ns = s.replace(\"CM\",\"DCCCC\");\\n\\nfor(let i = 0; i < s.length; i++){\\n    let z = val[`${s[i]}`];\\n    sum = sum + z;\\n}\\nreturn sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hi!\\nHere are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "santwan",
                        "content": "MY FIRST PROBLEM ON LEET CODE :)"
                    },
                    {
                        "username": "user1840I",
                        "content": "Why is this not being accepted ?\\ns=input()\\n\\nd={\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000}\\ntotal=0\\nprev_value=0\\n\\n\\nfor char in reversed(s) :\\n    if 1 <= len(s) <= 15 and (char in d):\\n         current_value = d[char]\\n         if current_value<prev_value :\\n              total-=current_value\\n            #LIX  XIL\\n\\n         else :\\n             total+=current_value\\n             prev_value=current_value\\n    else :\\n        quit()\\n\\nif total in range(1,4000) :\\n    print(total)\\n\\n\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your Python code is almost correct but needs some minor adjustments. Let\\'s modify it a bit. \\n\\nThe main points are:\\n1. Remove the input length checking inside the loop, we should check this before starting the loop.\\n2. We should remove the `quit()`. This function is used to end a script, and it won\\'t allow you to print the error message. You could use an `else` condition to print an error message.\\n3. The \"total\" value checking at the end is also unnecessary.\\n\\nHere is the modified code:\\n\\n```python\\ns = input()\\n\\nif 1 <= len(s) <= 15:\\n    d = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n    total = 0\\n    prev_value = 0\\n\\n    for char in reversed(s):\\n        if char in d:\\n            current_value = d[char]\\n            if current_value < prev_value:\\n                total -= current_value\\n            else:\\n                total += current_value\\n                prev_value = current_value\\n        else:\\n            print(f\"Invalid input: {char}\")\\n            break\\n    else:\\n        print(total)\\nelse:\\n    print(\"Invalid length of string\")\\n```\\n\\nThis code will print the total value if all the input characters are valid, else it will print an error message."
                    },
                    {
                        "username": "Silver_I0",
                        "content": "am i the only one that used regex?\\n```\\nimport re\\n\\nTHOUSANDS= \\'(M*)\\'\\nHUNDREDS= \\'(C[MD]|D?C{0,3})\\'\\nTENS= \\'(X[CL]|L?X{0,3})\\'\\nUNITS= \\'(I[XV]|V?I{0,3})\\'\\n\\n```\\ni feel like breaking roman numerals (MCDLXVIII) -> 1468\\ninto groups (\\'M\\', \\'CD, \\'LX\\', \\'VIII\\') \\niterating those groups and fetching values from the corresponding dict_keys\\nthen add everything up, was easier."
                    },
                    {
                        "username": "Dragon3000",
                        "content": "This is my first problem ever on leet code. \\n\\nI don\\'t understand what this is. Can anyone explain? Thanks. \\n\\nNameError: global name \\'Solution\\' is not defined\\n    ret = Solution().romanToInt(param_1)\\nLine 22 in _driver (Solution.py)\\n    _driver()\\nLine 32 in <module> (Solution.py)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing is because Python cannot find the definition for the class named \\'Solution\\'.\\n\\nIt seems like you are trying to call a method named `romanToInt` from a class named `Solution`. The error says that Python could not find this class.\\n\\nIn Python, before you can use a class, function, or variable, it must be defined in the current scope. For classes and functions, this means you need to have a `class` or `def` statement executed before you can use the class or function.\\n\\nHere is a simple example of how this works:\\n\\n```python\\nclass Solution:\\n    def romanToInt(self, s):\\n        # Your code here\\n\\n# Now you can use Solution because it has been defined\\nsolution = Solution()\\nret = solution.romanToInt(\"III\")\\n```\\n\\nSo, the error you\\'re seeing indicates that Python couldn\\'t find the class `Solution` at the point in your code where you tried to use it.\\n\\nTo fix this error, you need to ensure that the `Solution` class has been defined before you try to use it. It might be a simple as moving the code that uses `Solution` to a point in your script after the class is defined. Or it might mean importing the `Solution` class from another module if it is defined elsewhere."
                    }
                ]
            },
            {
                "id": 1929620,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "i am not familiar with roman numbers this is difficult for me because of the understanding part"
                    },
                    {
                        "username": "rianrbps",
                        "content": "Time Limit Exceeded, is it because I used a switch case?\\n\\n `int romanToInt(char * s){\\n\\n    int num = 0;\\n    int i = 0;\\n\\n    while(s[i] != \\'\\\\0\\');{\\n        switch (s[i]){\\n            case \\'M\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 900;\\n                }else{\\n                    num += 1000;\\n                }\\n\\n            case \\'D\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 400;\\n                }else{\\n                    num += 500;\\n                }\\n \\n            case \\'C\\':\\n                if(s[i+1] == \\'M\\' || s[i+1] == \\'D\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'X\\'){\\n                        num+=90;\\n                    }else{\\n                        num+= 100;\\n                    }\\n                }\\n            \\n            case \\'L\\':\\n                if(s[i-1] == \\'X\\'){\\n                    num += 40;\\n                }else{\\n                    num += 50;\\n                }\\n\\n            case \\'X\\':\\n                if(s[i+1] == \\'L\\' || s[i+1] == \\'C\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'I\\'){\\n                        num += 9;\\n                    }else{\\n                        num += 10;\\n                    }\\n                }\\n\\n\\n            case \\'V\\':\\n                if(s[i-1] == \\'I\\'){\\n                    num += 4;\\n                }else{\\n                    num += 5;\\n                }\\n\\n\\n            case \\'I\\':\\n                if(s[i+1] == \\'V\\' || s[i+1] == \\'X\\'){\\n                    break;\\n                }else{\\n                    num += 1;\\n                }\\n        }\\n        i++;\\n    }\\n    return num;\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the code runs into an infinite loop, and that\\'s the cause for the Time Limit Exceeded error. The reason is that you have a semicolon `;` right after your `while` condition, which is making the `while` loop run indefinitely without any statements inside it. The code block following this semicolon is then executed as a separate, single-time block, and it\\'s not inside the loop as you intended. This leads to an infinite loop because there\\'s no operation inside the `while` loop that changes the loop\\'s condition (`s[i] != \\'\\\\0\\'`), so it just keeps running.\\n\\nThe correct way to write the `while` loop is:\\n\\n```c\\nwhile(s[i] != \\'\\\\0\\') {\\n    // your switch case and code goes here\\n}\\n```\\nBy fixing this, you should avoid the Time Limit Exceeded error.\\n\\nHowever, there is another logical error in your code related to how you\\'re handling the roman numeral conversion. The switch-case construct doesn\\'t have an automatic break once a case is executed. This means if a case like \\'M\\' or \\'D\\' is hit, the code continues to execute the next cases (\\'C\\', \\'L\\', \\'X\\', \\'V\\', \\'I\\') as well, leading to incorrect results. To avoid this, you need to put a `break` statement at the end of each case:\\n\\n```c\\nswitch (s[i]){\\n    case \\'M\\':\\n        // some code here\\n        break;\\n    case \\'D\\':\\n        // some code here\\n        break;\\n    // similar for other cases\\n}\\n```\\n\\nBy adding these `break` statements, you ensure that the switch-case construct exits after executing a matching case."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you still can\\'t find the way to solve, see my code , I just create a map ( you can create a switch case ) then you will loop full string and compare two adjacent item \\nclass Solution {\\n    public int romanToInt(String s) {\\n    Map<Character,Integer> map = new HashMap<Character, Integer> ();\\n      int sum = 0 ;\\n      int prevValue = 0;\\n      int currValue = 0;\\n      map.put(\\'I\\',1);\\n      map.put(\\'V\\',5);\\n      map.put(\\'X\\',10);\\n      map.put(\\'L\\',50);\\n      map.put(\\'C\\',100);\\n      map.put(\\'D\\',500);\\n      map.put(\\'M\\',1000);\\n\\n      for(int i=0 ; i< s.length(); i++) {\\n        currValue = map.get(s.charAt(i));\\n        if(currValue > prevValue ) {\\n          sum += currValue - 2 * prevValue;\\n        }\\n        else {\\n          sum += currValue;\\n        }\\n        prevValue = currValue;\\n        \\n      }\\n\\n      return sum;\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arvin_draj",
                        "content": "my code works in vs code \\nbut in leetcode the same code for the same test case it dosen\\'t work"
                    },
                    {
                        "username": "harish1402r",
                        "content": "how four is written?\\n"
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "So in Roman four is written by \\'IV\\' and if we split both of these letters then both of them have there own standard values in Roman, so what we have to do is just convert them into \\'IIII\\', and likewise for other values aswell which I have replaced aswell."
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "Hey, here is my answer for this in JS;\\n\\nlet val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10,\\'L\\': 50,\\'C\\': 100,\\'D\\': 500, \\'M\\': 1000};\\nlet sum = 0;\\ns = s.replace(\"IV\",\"IIII\");\\ns = s.replace(\"IX\",\"VIIII\");\\ns = s.replace(\"XL\",\"XXXX\");\\ns = s.replace(\"XC\",\"LXXXX\");\\ns = s.replace(\"CD\",\"CCCC\");\\ns = s.replace(\"CM\",\"DCCCC\");\\n\\nfor(let i = 0; i < s.length; i++){\\n    let z = val[`${s[i]}`];\\n    sum = sum + z;\\n}\\nreturn sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hi!\\nHere are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "santwan",
                        "content": "MY FIRST PROBLEM ON LEET CODE :)"
                    },
                    {
                        "username": "user1840I",
                        "content": "Why is this not being accepted ?\\ns=input()\\n\\nd={\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000}\\ntotal=0\\nprev_value=0\\n\\n\\nfor char in reversed(s) :\\n    if 1 <= len(s) <= 15 and (char in d):\\n         current_value = d[char]\\n         if current_value<prev_value :\\n              total-=current_value\\n            #LIX  XIL\\n\\n         else :\\n             total+=current_value\\n             prev_value=current_value\\n    else :\\n        quit()\\n\\nif total in range(1,4000) :\\n    print(total)\\n\\n\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your Python code is almost correct but needs some minor adjustments. Let\\'s modify it a bit. \\n\\nThe main points are:\\n1. Remove the input length checking inside the loop, we should check this before starting the loop.\\n2. We should remove the `quit()`. This function is used to end a script, and it won\\'t allow you to print the error message. You could use an `else` condition to print an error message.\\n3. The \"total\" value checking at the end is also unnecessary.\\n\\nHere is the modified code:\\n\\n```python\\ns = input()\\n\\nif 1 <= len(s) <= 15:\\n    d = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n    total = 0\\n    prev_value = 0\\n\\n    for char in reversed(s):\\n        if char in d:\\n            current_value = d[char]\\n            if current_value < prev_value:\\n                total -= current_value\\n            else:\\n                total += current_value\\n                prev_value = current_value\\n        else:\\n            print(f\"Invalid input: {char}\")\\n            break\\n    else:\\n        print(total)\\nelse:\\n    print(\"Invalid length of string\")\\n```\\n\\nThis code will print the total value if all the input characters are valid, else it will print an error message."
                    },
                    {
                        "username": "Silver_I0",
                        "content": "am i the only one that used regex?\\n```\\nimport re\\n\\nTHOUSANDS= \\'(M*)\\'\\nHUNDREDS= \\'(C[MD]|D?C{0,3})\\'\\nTENS= \\'(X[CL]|L?X{0,3})\\'\\nUNITS= \\'(I[XV]|V?I{0,3})\\'\\n\\n```\\ni feel like breaking roman numerals (MCDLXVIII) -> 1468\\ninto groups (\\'M\\', \\'CD, \\'LX\\', \\'VIII\\') \\niterating those groups and fetching values from the corresponding dict_keys\\nthen add everything up, was easier."
                    },
                    {
                        "username": "Dragon3000",
                        "content": "This is my first problem ever on leet code. \\n\\nI don\\'t understand what this is. Can anyone explain? Thanks. \\n\\nNameError: global name \\'Solution\\' is not defined\\n    ret = Solution().romanToInt(param_1)\\nLine 22 in _driver (Solution.py)\\n    _driver()\\nLine 32 in <module> (Solution.py)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing is because Python cannot find the definition for the class named \\'Solution\\'.\\n\\nIt seems like you are trying to call a method named `romanToInt` from a class named `Solution`. The error says that Python could not find this class.\\n\\nIn Python, before you can use a class, function, or variable, it must be defined in the current scope. For classes and functions, this means you need to have a `class` or `def` statement executed before you can use the class or function.\\n\\nHere is a simple example of how this works:\\n\\n```python\\nclass Solution:\\n    def romanToInt(self, s):\\n        # Your code here\\n\\n# Now you can use Solution because it has been defined\\nsolution = Solution()\\nret = solution.romanToInt(\"III\")\\n```\\n\\nSo, the error you\\'re seeing indicates that Python couldn\\'t find the class `Solution` at the point in your code where you tried to use it.\\n\\nTo fix this error, you need to ensure that the `Solution` class has been defined before you try to use it. It might be a simple as moving the code that uses `Solution` to a point in your script after the class is defined. Or it might mean importing the `Solution` class from another module if it is defined elsewhere."
                    }
                ]
            },
            {
                "id": 1928773,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "i am not familiar with roman numbers this is difficult for me because of the understanding part"
                    },
                    {
                        "username": "rianrbps",
                        "content": "Time Limit Exceeded, is it because I used a switch case?\\n\\n `int romanToInt(char * s){\\n\\n    int num = 0;\\n    int i = 0;\\n\\n    while(s[i] != \\'\\\\0\\');{\\n        switch (s[i]){\\n            case \\'M\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 900;\\n                }else{\\n                    num += 1000;\\n                }\\n\\n            case \\'D\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 400;\\n                }else{\\n                    num += 500;\\n                }\\n \\n            case \\'C\\':\\n                if(s[i+1] == \\'M\\' || s[i+1] == \\'D\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'X\\'){\\n                        num+=90;\\n                    }else{\\n                        num+= 100;\\n                    }\\n                }\\n            \\n            case \\'L\\':\\n                if(s[i-1] == \\'X\\'){\\n                    num += 40;\\n                }else{\\n                    num += 50;\\n                }\\n\\n            case \\'X\\':\\n                if(s[i+1] == \\'L\\' || s[i+1] == \\'C\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'I\\'){\\n                        num += 9;\\n                    }else{\\n                        num += 10;\\n                    }\\n                }\\n\\n\\n            case \\'V\\':\\n                if(s[i-1] == \\'I\\'){\\n                    num += 4;\\n                }else{\\n                    num += 5;\\n                }\\n\\n\\n            case \\'I\\':\\n                if(s[i+1] == \\'V\\' || s[i+1] == \\'X\\'){\\n                    break;\\n                }else{\\n                    num += 1;\\n                }\\n        }\\n        i++;\\n    }\\n    return num;\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the code runs into an infinite loop, and that\\'s the cause for the Time Limit Exceeded error. The reason is that you have a semicolon `;` right after your `while` condition, which is making the `while` loop run indefinitely without any statements inside it. The code block following this semicolon is then executed as a separate, single-time block, and it\\'s not inside the loop as you intended. This leads to an infinite loop because there\\'s no operation inside the `while` loop that changes the loop\\'s condition (`s[i] != \\'\\\\0\\'`), so it just keeps running.\\n\\nThe correct way to write the `while` loop is:\\n\\n```c\\nwhile(s[i] != \\'\\\\0\\') {\\n    // your switch case and code goes here\\n}\\n```\\nBy fixing this, you should avoid the Time Limit Exceeded error.\\n\\nHowever, there is another logical error in your code related to how you\\'re handling the roman numeral conversion. The switch-case construct doesn\\'t have an automatic break once a case is executed. This means if a case like \\'M\\' or \\'D\\' is hit, the code continues to execute the next cases (\\'C\\', \\'L\\', \\'X\\', \\'V\\', \\'I\\') as well, leading to incorrect results. To avoid this, you need to put a `break` statement at the end of each case:\\n\\n```c\\nswitch (s[i]){\\n    case \\'M\\':\\n        // some code here\\n        break;\\n    case \\'D\\':\\n        // some code here\\n        break;\\n    // similar for other cases\\n}\\n```\\n\\nBy adding these `break` statements, you ensure that the switch-case construct exits after executing a matching case."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you still can\\'t find the way to solve, see my code , I just create a map ( you can create a switch case ) then you will loop full string and compare two adjacent item \\nclass Solution {\\n    public int romanToInt(String s) {\\n    Map<Character,Integer> map = new HashMap<Character, Integer> ();\\n      int sum = 0 ;\\n      int prevValue = 0;\\n      int currValue = 0;\\n      map.put(\\'I\\',1);\\n      map.put(\\'V\\',5);\\n      map.put(\\'X\\',10);\\n      map.put(\\'L\\',50);\\n      map.put(\\'C\\',100);\\n      map.put(\\'D\\',500);\\n      map.put(\\'M\\',1000);\\n\\n      for(int i=0 ; i< s.length(); i++) {\\n        currValue = map.get(s.charAt(i));\\n        if(currValue > prevValue ) {\\n          sum += currValue - 2 * prevValue;\\n        }\\n        else {\\n          sum += currValue;\\n        }\\n        prevValue = currValue;\\n        \\n      }\\n\\n      return sum;\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arvin_draj",
                        "content": "my code works in vs code \\nbut in leetcode the same code for the same test case it dosen\\'t work"
                    },
                    {
                        "username": "harish1402r",
                        "content": "how four is written?\\n"
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "So in Roman four is written by \\'IV\\' and if we split both of these letters then both of them have there own standard values in Roman, so what we have to do is just convert them into \\'IIII\\', and likewise for other values aswell which I have replaced aswell."
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "Hey, here is my answer for this in JS;\\n\\nlet val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10,\\'L\\': 50,\\'C\\': 100,\\'D\\': 500, \\'M\\': 1000};\\nlet sum = 0;\\ns = s.replace(\"IV\",\"IIII\");\\ns = s.replace(\"IX\",\"VIIII\");\\ns = s.replace(\"XL\",\"XXXX\");\\ns = s.replace(\"XC\",\"LXXXX\");\\ns = s.replace(\"CD\",\"CCCC\");\\ns = s.replace(\"CM\",\"DCCCC\");\\n\\nfor(let i = 0; i < s.length; i++){\\n    let z = val[`${s[i]}`];\\n    sum = sum + z;\\n}\\nreturn sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hi!\\nHere are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "santwan",
                        "content": "MY FIRST PROBLEM ON LEET CODE :)"
                    },
                    {
                        "username": "user1840I",
                        "content": "Why is this not being accepted ?\\ns=input()\\n\\nd={\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000}\\ntotal=0\\nprev_value=0\\n\\n\\nfor char in reversed(s) :\\n    if 1 <= len(s) <= 15 and (char in d):\\n         current_value = d[char]\\n         if current_value<prev_value :\\n              total-=current_value\\n            #LIX  XIL\\n\\n         else :\\n             total+=current_value\\n             prev_value=current_value\\n    else :\\n        quit()\\n\\nif total in range(1,4000) :\\n    print(total)\\n\\n\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your Python code is almost correct but needs some minor adjustments. Let\\'s modify it a bit. \\n\\nThe main points are:\\n1. Remove the input length checking inside the loop, we should check this before starting the loop.\\n2. We should remove the `quit()`. This function is used to end a script, and it won\\'t allow you to print the error message. You could use an `else` condition to print an error message.\\n3. The \"total\" value checking at the end is also unnecessary.\\n\\nHere is the modified code:\\n\\n```python\\ns = input()\\n\\nif 1 <= len(s) <= 15:\\n    d = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n    total = 0\\n    prev_value = 0\\n\\n    for char in reversed(s):\\n        if char in d:\\n            current_value = d[char]\\n            if current_value < prev_value:\\n                total -= current_value\\n            else:\\n                total += current_value\\n                prev_value = current_value\\n        else:\\n            print(f\"Invalid input: {char}\")\\n            break\\n    else:\\n        print(total)\\nelse:\\n    print(\"Invalid length of string\")\\n```\\n\\nThis code will print the total value if all the input characters are valid, else it will print an error message."
                    },
                    {
                        "username": "Silver_I0",
                        "content": "am i the only one that used regex?\\n```\\nimport re\\n\\nTHOUSANDS= \\'(M*)\\'\\nHUNDREDS= \\'(C[MD]|D?C{0,3})\\'\\nTENS= \\'(X[CL]|L?X{0,3})\\'\\nUNITS= \\'(I[XV]|V?I{0,3})\\'\\n\\n```\\ni feel like breaking roman numerals (MCDLXVIII) -> 1468\\ninto groups (\\'M\\', \\'CD, \\'LX\\', \\'VIII\\') \\niterating those groups and fetching values from the corresponding dict_keys\\nthen add everything up, was easier."
                    },
                    {
                        "username": "Dragon3000",
                        "content": "This is my first problem ever on leet code. \\n\\nI don\\'t understand what this is. Can anyone explain? Thanks. \\n\\nNameError: global name \\'Solution\\' is not defined\\n    ret = Solution().romanToInt(param_1)\\nLine 22 in _driver (Solution.py)\\n    _driver()\\nLine 32 in <module> (Solution.py)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing is because Python cannot find the definition for the class named \\'Solution\\'.\\n\\nIt seems like you are trying to call a method named `romanToInt` from a class named `Solution`. The error says that Python could not find this class.\\n\\nIn Python, before you can use a class, function, or variable, it must be defined in the current scope. For classes and functions, this means you need to have a `class` or `def` statement executed before you can use the class or function.\\n\\nHere is a simple example of how this works:\\n\\n```python\\nclass Solution:\\n    def romanToInt(self, s):\\n        # Your code here\\n\\n# Now you can use Solution because it has been defined\\nsolution = Solution()\\nret = solution.romanToInt(\"III\")\\n```\\n\\nSo, the error you\\'re seeing indicates that Python couldn\\'t find the class `Solution` at the point in your code where you tried to use it.\\n\\nTo fix this error, you need to ensure that the `Solution` class has been defined before you try to use it. It might be a simple as moving the code that uses `Solution` to a point in your script after the class is defined. Or it might mean importing the `Solution` class from another module if it is defined elsewhere."
                    }
                ]
            },
            {
                "id": 1924308,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "i am not familiar with roman numbers this is difficult for me because of the understanding part"
                    },
                    {
                        "username": "rianrbps",
                        "content": "Time Limit Exceeded, is it because I used a switch case?\\n\\n `int romanToInt(char * s){\\n\\n    int num = 0;\\n    int i = 0;\\n\\n    while(s[i] != \\'\\\\0\\');{\\n        switch (s[i]){\\n            case \\'M\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 900;\\n                }else{\\n                    num += 1000;\\n                }\\n\\n            case \\'D\\':\\n                if(s[i-1] == \\'C\\'){\\n                    num += 400;\\n                }else{\\n                    num += 500;\\n                }\\n \\n            case \\'C\\':\\n                if(s[i+1] == \\'M\\' || s[i+1] == \\'D\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'X\\'){\\n                        num+=90;\\n                    }else{\\n                        num+= 100;\\n                    }\\n                }\\n            \\n            case \\'L\\':\\n                if(s[i-1] == \\'X\\'){\\n                    num += 40;\\n                }else{\\n                    num += 50;\\n                }\\n\\n            case \\'X\\':\\n                if(s[i+1] == \\'L\\' || s[i+1] == \\'C\\'){\\n                    break;\\n                }else{\\n                    if(s[i-1] == \\'I\\'){\\n                        num += 9;\\n                    }else{\\n                        num += 10;\\n                    }\\n                }\\n\\n\\n            case \\'V\\':\\n                if(s[i-1] == \\'I\\'){\\n                    num += 4;\\n                }else{\\n                    num += 5;\\n                }\\n\\n\\n            case \\'I\\':\\n                if(s[i+1] == \\'V\\' || s[i+1] == \\'X\\'){\\n                    break;\\n                }else{\\n                    num += 1;\\n                }\\n        }\\n        i++;\\n    }\\n    return num;\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the code runs into an infinite loop, and that\\'s the cause for the Time Limit Exceeded error. The reason is that you have a semicolon `;` right after your `while` condition, which is making the `while` loop run indefinitely without any statements inside it. The code block following this semicolon is then executed as a separate, single-time block, and it\\'s not inside the loop as you intended. This leads to an infinite loop because there\\'s no operation inside the `while` loop that changes the loop\\'s condition (`s[i] != \\'\\\\0\\'`), so it just keeps running.\\n\\nThe correct way to write the `while` loop is:\\n\\n```c\\nwhile(s[i] != \\'\\\\0\\') {\\n    // your switch case and code goes here\\n}\\n```\\nBy fixing this, you should avoid the Time Limit Exceeded error.\\n\\nHowever, there is another logical error in your code related to how you\\'re handling the roman numeral conversion. The switch-case construct doesn\\'t have an automatic break once a case is executed. This means if a case like \\'M\\' or \\'D\\' is hit, the code continues to execute the next cases (\\'C\\', \\'L\\', \\'X\\', \\'V\\', \\'I\\') as well, leading to incorrect results. To avoid this, you need to put a `break` statement at the end of each case:\\n\\n```c\\nswitch (s[i]){\\n    case \\'M\\':\\n        // some code here\\n        break;\\n    case \\'D\\':\\n        // some code here\\n        break;\\n    // similar for other cases\\n}\\n```\\n\\nBy adding these `break` statements, you ensure that the switch-case construct exits after executing a matching case."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you still can\\'t find the way to solve, see my code , I just create a map ( you can create a switch case ) then you will loop full string and compare two adjacent item \\nclass Solution {\\n    public int romanToInt(String s) {\\n    Map<Character,Integer> map = new HashMap<Character, Integer> ();\\n      int sum = 0 ;\\n      int prevValue = 0;\\n      int currValue = 0;\\n      map.put(\\'I\\',1);\\n      map.put(\\'V\\',5);\\n      map.put(\\'X\\',10);\\n      map.put(\\'L\\',50);\\n      map.put(\\'C\\',100);\\n      map.put(\\'D\\',500);\\n      map.put(\\'M\\',1000);\\n\\n      for(int i=0 ; i< s.length(); i++) {\\n        currValue = map.get(s.charAt(i));\\n        if(currValue > prevValue ) {\\n          sum += currValue - 2 * prevValue;\\n        }\\n        else {\\n          sum += currValue;\\n        }\\n        prevValue = currValue;\\n        \\n      }\\n\\n      return sum;\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arvin_draj",
                        "content": "my code works in vs code \\nbut in leetcode the same code for the same test case it dosen\\'t work"
                    },
                    {
                        "username": "harish1402r",
                        "content": "how four is written?\\n"
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "So in Roman four is written by \\'IV\\' and if we split both of these letters then both of them have there own standard values in Roman, so what we have to do is just convert them into \\'IIII\\', and likewise for other values aswell which I have replaced aswell."
                    },
                    {
                        "username": "khatrisuneel96",
                        "content": "Hey, here is my answer for this in JS;\\n\\nlet val = {\\'I\\': 1, \\'V\\': 5, \\'X\\': 10,\\'L\\': 50,\\'C\\': 100,\\'D\\': 500, \\'M\\': 1000};\\nlet sum = 0;\\ns = s.replace(\"IV\",\"IIII\");\\ns = s.replace(\"IX\",\"VIIII\");\\ns = s.replace(\"XL\",\"XXXX\");\\ns = s.replace(\"XC\",\"LXXXX\");\\ns = s.replace(\"CD\",\"CCCC\");\\ns = s.replace(\"CM\",\"DCCCC\");\\n\\nfor(let i = 0; i < s.length; i++){\\n    let z = val[`${s[i]}`];\\n    sum = sum + z;\\n}\\nreturn sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hi!\\nHere are the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "santwan",
                        "content": "MY FIRST PROBLEM ON LEET CODE :)"
                    },
                    {
                        "username": "user1840I",
                        "content": "Why is this not being accepted ?\\ns=input()\\n\\nd={\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000}\\ntotal=0\\nprev_value=0\\n\\n\\nfor char in reversed(s) :\\n    if 1 <= len(s) <= 15 and (char in d):\\n         current_value = d[char]\\n         if current_value<prev_value :\\n              total-=current_value\\n            #LIX  XIL\\n\\n         else :\\n             total+=current_value\\n             prev_value=current_value\\n    else :\\n        quit()\\n\\nif total in range(1,4000) :\\n    print(total)\\n\\n\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your Python code is almost correct but needs some minor adjustments. Let\\'s modify it a bit. \\n\\nThe main points are:\\n1. Remove the input length checking inside the loop, we should check this before starting the loop.\\n2. We should remove the `quit()`. This function is used to end a script, and it won\\'t allow you to print the error message. You could use an `else` condition to print an error message.\\n3. The \"total\" value checking at the end is also unnecessary.\\n\\nHere is the modified code:\\n\\n```python\\ns = input()\\n\\nif 1 <= len(s) <= 15:\\n    d = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n    total = 0\\n    prev_value = 0\\n\\n    for char in reversed(s):\\n        if char in d:\\n            current_value = d[char]\\n            if current_value < prev_value:\\n                total -= current_value\\n            else:\\n                total += current_value\\n                prev_value = current_value\\n        else:\\n            print(f\"Invalid input: {char}\")\\n            break\\n    else:\\n        print(total)\\nelse:\\n    print(\"Invalid length of string\")\\n```\\n\\nThis code will print the total value if all the input characters are valid, else it will print an error message."
                    },
                    {
                        "username": "Silver_I0",
                        "content": "am i the only one that used regex?\\n```\\nimport re\\n\\nTHOUSANDS= \\'(M*)\\'\\nHUNDREDS= \\'(C[MD]|D?C{0,3})\\'\\nTENS= \\'(X[CL]|L?X{0,3})\\'\\nUNITS= \\'(I[XV]|V?I{0,3})\\'\\n\\n```\\ni feel like breaking roman numerals (MCDLXVIII) -> 1468\\ninto groups (\\'M\\', \\'CD, \\'LX\\', \\'VIII\\') \\niterating those groups and fetching values from the corresponding dict_keys\\nthen add everything up, was easier."
                    },
                    {
                        "username": "Dragon3000",
                        "content": "This is my first problem ever on leet code. \\n\\nI don\\'t understand what this is. Can anyone explain? Thanks. \\n\\nNameError: global name \\'Solution\\' is not defined\\n    ret = Solution().romanToInt(param_1)\\nLine 22 in _driver (Solution.py)\\n    _driver()\\nLine 32 in <module> (Solution.py)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing is because Python cannot find the definition for the class named \\'Solution\\'.\\n\\nIt seems like you are trying to call a method named `romanToInt` from a class named `Solution`. The error says that Python could not find this class.\\n\\nIn Python, before you can use a class, function, or variable, it must be defined in the current scope. For classes and functions, this means you need to have a `class` or `def` statement executed before you can use the class or function.\\n\\nHere is a simple example of how this works:\\n\\n```python\\nclass Solution:\\n    def romanToInt(self, s):\\n        # Your code here\\n\\n# Now you can use Solution because it has been defined\\nsolution = Solution()\\nret = solution.romanToInt(\"III\")\\n```\\n\\nSo, the error you\\'re seeing indicates that Python couldn\\'t find the class `Solution` at the point in your code where you tried to use it.\\n\\nTo fix this error, you need to ensure that the `Solution` class has been defined before you try to use it. It might be a simple as moving the code that uses `Solution` to a point in your script after the class is defined. Or it might mean importing the `Solution` class from another module if it is defined elsewhere."
                    }
                ]
            },
            {
                "id": 1916607,
                "content": [
                    {
                        "username": "GokulCN",
                        "content": "explain the logic"
                    },
                    {
                        "username": "mohamedhamoody0",
                        "content": "\\nWRONG ANSWER IN THIS TEST ?? \"MMMCDXC\" . OUTPUT IS 3290 WHY ?, IT SHOULD BE 3490\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        count = 0 \\n        for i in range (len(s)):\\n            if s[i] == \"I\" :   \\n                  count +=1\\n            elif s[i] == \"V\" and s[i-1] == \"I\": \\n                   count+= 3\\n            elif s[i] == \"V\":\\n                    count+=5\\n            elif s[i] == \"X\" and s[i-1] == \"I\":\\n                count+=8 \\n            elif s[i] == \"X\": \\n                 count +=10\\n            elif s[i] == \"L\" and s[i-1] == \"X\":\\n                count+=30 \\n            elif s[i] == \"L\": \\n                 count +=50\\n            elif s[i] == \"C\" and s[i-1] == \"X\":\\n                count+=80 \\n            elif s[i] == \"C\": \\n                  count +=100\\n            elif s[i] == \"D\" and s[i-1] == \"C\":\\n                 count += 300\\n            elif s[i] == \"D\": \\n                  count +=500\\n            elif s[i] == \"M\" and s[i-1] == \"C\":\\n                count+=800 \\n            elif s[i] == \"M\": \\n                  count +=1000\\n        return count"
                    },
                    {
                        "username": "Satyam1988",
                        "content": "if the constraints get failed what should i return?"
                    },
                    {
                        "username": "anandsharma2686",
                        "content": "s=Xc\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "if(h.get(s.charAt(i)) >= h.get(s.charAt(i+1))){\n                r += h.get(s.charAt(i));  \n                i++;\n}\n\nWhat this problem test us?\nRuntime Error\njava.lang.NullPointerException: Cannot invoke \"java.lang.Integer.intValue()\" because the return value of \"java.util.HashMap.get(Object)\" is null\n  at line 8, Solution.romanToInt\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main "
                    },
                    {
                        "username": "Theleappp",
                        "content": "can any one explain why the third test case is failing for my code\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n      int sum1=0;\\n      int sum2=0;\\n      int sum;\\n      int count=0;\\n      for(int k=0;s[k]!=\\'\\\\0\\';k++)\\n      {\\n        count++;\\n      }\\n      for(int i=0;i<count;i++)\\n      {   if(s[i]==\\'I\\'){\\n          s[i]=1;\\n      }\\n          if(s[i]==\\'V\\'){\\n          s[i]=5;\\n      }\\n           if(s[i]==\\'X\\'){\\n          s[i]=10;\\n      }\\n          if(s[i]==\\'L\\'){\\n          s[i]=50;\\n      }\\n           if(s[i]==\\'C\\'){\\n          s[i]=100;\\n      }\\n          if(s[i]==\\'D\\'){\\n          s[i]=500;\\n      }\\n           if(s[i]==\\'M\\'){\\n          s[i]=1000;\\n      }\\n    }\\n    for(int j=0;j<count-1;j++){\\n    if(s[j]<s[j+1])\\n    {\\n      sum1=sum1+s[j]; \\n    }\\n    if(s[j]>=s[j+1])\\n    {\\n      sum2=sum2+s[j];\\n    }\\n     }\\n       sum2=sum2+s[count-1];\\n        sum=sum2-sum1;\\n         return sum;\\n   }\\n};"
                    },
                    {
                        "username": "paomar",
                        "content": "hi can someone help me to understand why the third case is failed please ?  \\n`class Solution {\\n    fun romanToInt(s: String): Int {\\n        var res = 0\\n        s.map{char ->\\n           res += when(char.toString()){\\n                \"I\" -> 1  \\n                \"V\"   ->          5\\n                \"X\"     ->       10\\n                \"L\"      ->      50\\n                \"C\"     ->     100\\n                \"D\"     ->       500\\n                \"M\"      ->      1000\\n                else -> 0\\n            } \\n        }\\n        return res\\n    }\\n}`"
                    },
                    {
                        "username": "mainsamouel",
                        "content": "why there is a \"ReferenceErrpr: prompt is not defined\""
                    },
                    {
                        "username": "DDKK64",
                        "content": "In case someone need the literal in C++:\\n\\n```C++\\nint weight[128] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,500,0,0,0,0,1,0,0,50,1000,0,0,0,0,0,0,0,0,5,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n```\\n\\ngenerated by Python"
                    },
                    {
                        "username": "KommidiHarshavardhanReddy",
                        "content": "int romanToInt(char * s){\\n int count=0,i;\\n char c[16];\\n for(i=0;i<15;i++)\\n { \\n     if(s[i]!=\\'\\\\0\\')\\n     c[i]=s[i];\\n     else\\n     c[i]=\\'\\\\0\\';\\n }\\n for(i=0;i<15;i++)\\n {\\n     if(c[i]==\\'I\\')\\n     count=count+1;\\n     else if(c[i]==\\'V\\')\\n     count=count+5;\\n     else if(c[i]==\\'X\\')\\n     count=count+10;\\n     else if(c[i]==\\'L\\')\\n     count=count+50;\\n     else if(c[i]==\\'C\\')\\n     count=count+100;\\n     else if(c[i]==\\'D\\')\\n     count=count+500;\\n     else if(c[i]==\\'M\\')\\n     count=count+1000;\\n     else \\n     count+=0;\\n\\n }\\n //printf(\"%d\",count);\\n return count;\\n\\n}\\n\\n\\nRuntime Error\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000014 at pc 0x55edc6088c15 bp 0x7ffe34f817c0 sp 0x7ffe34f817b0\\nREAD of size 1 at 0x602000000014 thread T0\\n    #2 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000014 is located 0 bytes to the right of 4-byte region [0x602000000010,0x602000000014)\\nallocated by thread T0 here:\\n    #0 0x7fe47ae34808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\nwhat is meaning of this error? \\ncan anyone help me out?"
                    },
                    {
                        "username": "serzan",
                        "content": "int romanToInt(char * s){\\nint count=0,i;\\nchar c[16];\\nfor(i=0;i<15;i++)\\n{\\nif(s[i]!=\\'\\\\0\\')\\nc[i]=s[i];\\nelse\\nc[i]=\\'\\\\0\\';\\n}\\nfor(i=0;i<15;i++)\\n{\\nif(c[i]==\\'I\\' && c[i+1]==\\'V\\'){\\ncount=count+4;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\' && c[i+1]==\\'X\\'){\\ncount=count+9;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'L\\'){\\ncount=count+40;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'C\\'){\\ncount=count+90;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'D\\'){\\ncount=count+400;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'M\\'){\\ncount=count+900;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\')\\ncount=count+1;\\nelse if(c[i]==\\'V\\')\\ncount=count+5;\\nelse if(c[i]==\\'X\\')\\ncount=count+10;\\nelse if(c[i]==\\'L\\')\\ncount=count+50;\\nelse if(c[i]==\\'C\\')\\ncount=count+100;\\nelse if(c[i]==\\'D\\')\\ncount=count+500;\\nelse if(c[i]==\\'M\\')\\ncount=count+1000;\\nelse\\ncount+=0;\\n\\n}\\n//printf(\"%d\",count);\\nreturn count;\\n\\n}\\n\\nint main(int argc, char *argv[])\\n{\\nchar s[]=\"MCMXCIV\";\\nint x=romanToInt(s);\\nprintf(\"%d\",x);\\n}"
                    }
                ]
            },
            {
                "id": 1915880,
                "content": [
                    {
                        "username": "GokulCN",
                        "content": "explain the logic"
                    },
                    {
                        "username": "mohamedhamoody0",
                        "content": "\\nWRONG ANSWER IN THIS TEST ?? \"MMMCDXC\" . OUTPUT IS 3290 WHY ?, IT SHOULD BE 3490\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        count = 0 \\n        for i in range (len(s)):\\n            if s[i] == \"I\" :   \\n                  count +=1\\n            elif s[i] == \"V\" and s[i-1] == \"I\": \\n                   count+= 3\\n            elif s[i] == \"V\":\\n                    count+=5\\n            elif s[i] == \"X\" and s[i-1] == \"I\":\\n                count+=8 \\n            elif s[i] == \"X\": \\n                 count +=10\\n            elif s[i] == \"L\" and s[i-1] == \"X\":\\n                count+=30 \\n            elif s[i] == \"L\": \\n                 count +=50\\n            elif s[i] == \"C\" and s[i-1] == \"X\":\\n                count+=80 \\n            elif s[i] == \"C\": \\n                  count +=100\\n            elif s[i] == \"D\" and s[i-1] == \"C\":\\n                 count += 300\\n            elif s[i] == \"D\": \\n                  count +=500\\n            elif s[i] == \"M\" and s[i-1] == \"C\":\\n                count+=800 \\n            elif s[i] == \"M\": \\n                  count +=1000\\n        return count"
                    },
                    {
                        "username": "Satyam1988",
                        "content": "if the constraints get failed what should i return?"
                    },
                    {
                        "username": "anandsharma2686",
                        "content": "s=Xc\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "if(h.get(s.charAt(i)) >= h.get(s.charAt(i+1))){\n                r += h.get(s.charAt(i));  \n                i++;\n}\n\nWhat this problem test us?\nRuntime Error\njava.lang.NullPointerException: Cannot invoke \"java.lang.Integer.intValue()\" because the return value of \"java.util.HashMap.get(Object)\" is null\n  at line 8, Solution.romanToInt\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main "
                    },
                    {
                        "username": "Theleappp",
                        "content": "can any one explain why the third test case is failing for my code\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n      int sum1=0;\\n      int sum2=0;\\n      int sum;\\n      int count=0;\\n      for(int k=0;s[k]!=\\'\\\\0\\';k++)\\n      {\\n        count++;\\n      }\\n      for(int i=0;i<count;i++)\\n      {   if(s[i]==\\'I\\'){\\n          s[i]=1;\\n      }\\n          if(s[i]==\\'V\\'){\\n          s[i]=5;\\n      }\\n           if(s[i]==\\'X\\'){\\n          s[i]=10;\\n      }\\n          if(s[i]==\\'L\\'){\\n          s[i]=50;\\n      }\\n           if(s[i]==\\'C\\'){\\n          s[i]=100;\\n      }\\n          if(s[i]==\\'D\\'){\\n          s[i]=500;\\n      }\\n           if(s[i]==\\'M\\'){\\n          s[i]=1000;\\n      }\\n    }\\n    for(int j=0;j<count-1;j++){\\n    if(s[j]<s[j+1])\\n    {\\n      sum1=sum1+s[j]; \\n    }\\n    if(s[j]>=s[j+1])\\n    {\\n      sum2=sum2+s[j];\\n    }\\n     }\\n       sum2=sum2+s[count-1];\\n        sum=sum2-sum1;\\n         return sum;\\n   }\\n};"
                    },
                    {
                        "username": "paomar",
                        "content": "hi can someone help me to understand why the third case is failed please ?  \\n`class Solution {\\n    fun romanToInt(s: String): Int {\\n        var res = 0\\n        s.map{char ->\\n           res += when(char.toString()){\\n                \"I\" -> 1  \\n                \"V\"   ->          5\\n                \"X\"     ->       10\\n                \"L\"      ->      50\\n                \"C\"     ->     100\\n                \"D\"     ->       500\\n                \"M\"      ->      1000\\n                else -> 0\\n            } \\n        }\\n        return res\\n    }\\n}`"
                    },
                    {
                        "username": "mainsamouel",
                        "content": "why there is a \"ReferenceErrpr: prompt is not defined\""
                    },
                    {
                        "username": "DDKK64",
                        "content": "In case someone need the literal in C++:\\n\\n```C++\\nint weight[128] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,500,0,0,0,0,1,0,0,50,1000,0,0,0,0,0,0,0,0,5,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n```\\n\\ngenerated by Python"
                    },
                    {
                        "username": "KommidiHarshavardhanReddy",
                        "content": "int romanToInt(char * s){\\n int count=0,i;\\n char c[16];\\n for(i=0;i<15;i++)\\n { \\n     if(s[i]!=\\'\\\\0\\')\\n     c[i]=s[i];\\n     else\\n     c[i]=\\'\\\\0\\';\\n }\\n for(i=0;i<15;i++)\\n {\\n     if(c[i]==\\'I\\')\\n     count=count+1;\\n     else if(c[i]==\\'V\\')\\n     count=count+5;\\n     else if(c[i]==\\'X\\')\\n     count=count+10;\\n     else if(c[i]==\\'L\\')\\n     count=count+50;\\n     else if(c[i]==\\'C\\')\\n     count=count+100;\\n     else if(c[i]==\\'D\\')\\n     count=count+500;\\n     else if(c[i]==\\'M\\')\\n     count=count+1000;\\n     else \\n     count+=0;\\n\\n }\\n //printf(\"%d\",count);\\n return count;\\n\\n}\\n\\n\\nRuntime Error\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000014 at pc 0x55edc6088c15 bp 0x7ffe34f817c0 sp 0x7ffe34f817b0\\nREAD of size 1 at 0x602000000014 thread T0\\n    #2 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000014 is located 0 bytes to the right of 4-byte region [0x602000000010,0x602000000014)\\nallocated by thread T0 here:\\n    #0 0x7fe47ae34808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\nwhat is meaning of this error? \\ncan anyone help me out?"
                    },
                    {
                        "username": "serzan",
                        "content": "int romanToInt(char * s){\\nint count=0,i;\\nchar c[16];\\nfor(i=0;i<15;i++)\\n{\\nif(s[i]!=\\'\\\\0\\')\\nc[i]=s[i];\\nelse\\nc[i]=\\'\\\\0\\';\\n}\\nfor(i=0;i<15;i++)\\n{\\nif(c[i]==\\'I\\' && c[i+1]==\\'V\\'){\\ncount=count+4;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\' && c[i+1]==\\'X\\'){\\ncount=count+9;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'L\\'){\\ncount=count+40;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'C\\'){\\ncount=count+90;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'D\\'){\\ncount=count+400;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'M\\'){\\ncount=count+900;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\')\\ncount=count+1;\\nelse if(c[i]==\\'V\\')\\ncount=count+5;\\nelse if(c[i]==\\'X\\')\\ncount=count+10;\\nelse if(c[i]==\\'L\\')\\ncount=count+50;\\nelse if(c[i]==\\'C\\')\\ncount=count+100;\\nelse if(c[i]==\\'D\\')\\ncount=count+500;\\nelse if(c[i]==\\'M\\')\\ncount=count+1000;\\nelse\\ncount+=0;\\n\\n}\\n//printf(\"%d\",count);\\nreturn count;\\n\\n}\\n\\nint main(int argc, char *argv[])\\n{\\nchar s[]=\"MCMXCIV\";\\nint x=romanToInt(s);\\nprintf(\"%d\",x);\\n}"
                    }
                ]
            },
            {
                "id": 1914170,
                "content": [
                    {
                        "username": "GokulCN",
                        "content": "explain the logic"
                    },
                    {
                        "username": "mohamedhamoody0",
                        "content": "\\nWRONG ANSWER IN THIS TEST ?? \"MMMCDXC\" . OUTPUT IS 3290 WHY ?, IT SHOULD BE 3490\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        count = 0 \\n        for i in range (len(s)):\\n            if s[i] == \"I\" :   \\n                  count +=1\\n            elif s[i] == \"V\" and s[i-1] == \"I\": \\n                   count+= 3\\n            elif s[i] == \"V\":\\n                    count+=5\\n            elif s[i] == \"X\" and s[i-1] == \"I\":\\n                count+=8 \\n            elif s[i] == \"X\": \\n                 count +=10\\n            elif s[i] == \"L\" and s[i-1] == \"X\":\\n                count+=30 \\n            elif s[i] == \"L\": \\n                 count +=50\\n            elif s[i] == \"C\" and s[i-1] == \"X\":\\n                count+=80 \\n            elif s[i] == \"C\": \\n                  count +=100\\n            elif s[i] == \"D\" and s[i-1] == \"C\":\\n                 count += 300\\n            elif s[i] == \"D\": \\n                  count +=500\\n            elif s[i] == \"M\" and s[i-1] == \"C\":\\n                count+=800 \\n            elif s[i] == \"M\": \\n                  count +=1000\\n        return count"
                    },
                    {
                        "username": "Satyam1988",
                        "content": "if the constraints get failed what should i return?"
                    },
                    {
                        "username": "anandsharma2686",
                        "content": "s=Xc\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "if(h.get(s.charAt(i)) >= h.get(s.charAt(i+1))){\n                r += h.get(s.charAt(i));  \n                i++;\n}\n\nWhat this problem test us?\nRuntime Error\njava.lang.NullPointerException: Cannot invoke \"java.lang.Integer.intValue()\" because the return value of \"java.util.HashMap.get(Object)\" is null\n  at line 8, Solution.romanToInt\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main "
                    },
                    {
                        "username": "Theleappp",
                        "content": "can any one explain why the third test case is failing for my code\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n      int sum1=0;\\n      int sum2=0;\\n      int sum;\\n      int count=0;\\n      for(int k=0;s[k]!=\\'\\\\0\\';k++)\\n      {\\n        count++;\\n      }\\n      for(int i=0;i<count;i++)\\n      {   if(s[i]==\\'I\\'){\\n          s[i]=1;\\n      }\\n          if(s[i]==\\'V\\'){\\n          s[i]=5;\\n      }\\n           if(s[i]==\\'X\\'){\\n          s[i]=10;\\n      }\\n          if(s[i]==\\'L\\'){\\n          s[i]=50;\\n      }\\n           if(s[i]==\\'C\\'){\\n          s[i]=100;\\n      }\\n          if(s[i]==\\'D\\'){\\n          s[i]=500;\\n      }\\n           if(s[i]==\\'M\\'){\\n          s[i]=1000;\\n      }\\n    }\\n    for(int j=0;j<count-1;j++){\\n    if(s[j]<s[j+1])\\n    {\\n      sum1=sum1+s[j]; \\n    }\\n    if(s[j]>=s[j+1])\\n    {\\n      sum2=sum2+s[j];\\n    }\\n     }\\n       sum2=sum2+s[count-1];\\n        sum=sum2-sum1;\\n         return sum;\\n   }\\n};"
                    },
                    {
                        "username": "paomar",
                        "content": "hi can someone help me to understand why the third case is failed please ?  \\n`class Solution {\\n    fun romanToInt(s: String): Int {\\n        var res = 0\\n        s.map{char ->\\n           res += when(char.toString()){\\n                \"I\" -> 1  \\n                \"V\"   ->          5\\n                \"X\"     ->       10\\n                \"L\"      ->      50\\n                \"C\"     ->     100\\n                \"D\"     ->       500\\n                \"M\"      ->      1000\\n                else -> 0\\n            } \\n        }\\n        return res\\n    }\\n}`"
                    },
                    {
                        "username": "mainsamouel",
                        "content": "why there is a \"ReferenceErrpr: prompt is not defined\""
                    },
                    {
                        "username": "DDKK64",
                        "content": "In case someone need the literal in C++:\\n\\n```C++\\nint weight[128] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,500,0,0,0,0,1,0,0,50,1000,0,0,0,0,0,0,0,0,5,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n```\\n\\ngenerated by Python"
                    },
                    {
                        "username": "KommidiHarshavardhanReddy",
                        "content": "int romanToInt(char * s){\\n int count=0,i;\\n char c[16];\\n for(i=0;i<15;i++)\\n { \\n     if(s[i]!=\\'\\\\0\\')\\n     c[i]=s[i];\\n     else\\n     c[i]=\\'\\\\0\\';\\n }\\n for(i=0;i<15;i++)\\n {\\n     if(c[i]==\\'I\\')\\n     count=count+1;\\n     else if(c[i]==\\'V\\')\\n     count=count+5;\\n     else if(c[i]==\\'X\\')\\n     count=count+10;\\n     else if(c[i]==\\'L\\')\\n     count=count+50;\\n     else if(c[i]==\\'C\\')\\n     count=count+100;\\n     else if(c[i]==\\'D\\')\\n     count=count+500;\\n     else if(c[i]==\\'M\\')\\n     count=count+1000;\\n     else \\n     count+=0;\\n\\n }\\n //printf(\"%d\",count);\\n return count;\\n\\n}\\n\\n\\nRuntime Error\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000014 at pc 0x55edc6088c15 bp 0x7ffe34f817c0 sp 0x7ffe34f817b0\\nREAD of size 1 at 0x602000000014 thread T0\\n    #2 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000014 is located 0 bytes to the right of 4-byte region [0x602000000010,0x602000000014)\\nallocated by thread T0 here:\\n    #0 0x7fe47ae34808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\nwhat is meaning of this error? \\ncan anyone help me out?"
                    },
                    {
                        "username": "serzan",
                        "content": "int romanToInt(char * s){\\nint count=0,i;\\nchar c[16];\\nfor(i=0;i<15;i++)\\n{\\nif(s[i]!=\\'\\\\0\\')\\nc[i]=s[i];\\nelse\\nc[i]=\\'\\\\0\\';\\n}\\nfor(i=0;i<15;i++)\\n{\\nif(c[i]==\\'I\\' && c[i+1]==\\'V\\'){\\ncount=count+4;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\' && c[i+1]==\\'X\\'){\\ncount=count+9;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'L\\'){\\ncount=count+40;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'C\\'){\\ncount=count+90;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'D\\'){\\ncount=count+400;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'M\\'){\\ncount=count+900;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\')\\ncount=count+1;\\nelse if(c[i]==\\'V\\')\\ncount=count+5;\\nelse if(c[i]==\\'X\\')\\ncount=count+10;\\nelse if(c[i]==\\'L\\')\\ncount=count+50;\\nelse if(c[i]==\\'C\\')\\ncount=count+100;\\nelse if(c[i]==\\'D\\')\\ncount=count+500;\\nelse if(c[i]==\\'M\\')\\ncount=count+1000;\\nelse\\ncount+=0;\\n\\n}\\n//printf(\"%d\",count);\\nreturn count;\\n\\n}\\n\\nint main(int argc, char *argv[])\\n{\\nchar s[]=\"MCMXCIV\";\\nint x=romanToInt(s);\\nprintf(\"%d\",x);\\n}"
                    }
                ]
            },
            {
                "id": 1913484,
                "content": [
                    {
                        "username": "GokulCN",
                        "content": "explain the logic"
                    },
                    {
                        "username": "mohamedhamoody0",
                        "content": "\\nWRONG ANSWER IN THIS TEST ?? \"MMMCDXC\" . OUTPUT IS 3290 WHY ?, IT SHOULD BE 3490\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        count = 0 \\n        for i in range (len(s)):\\n            if s[i] == \"I\" :   \\n                  count +=1\\n            elif s[i] == \"V\" and s[i-1] == \"I\": \\n                   count+= 3\\n            elif s[i] == \"V\":\\n                    count+=5\\n            elif s[i] == \"X\" and s[i-1] == \"I\":\\n                count+=8 \\n            elif s[i] == \"X\": \\n                 count +=10\\n            elif s[i] == \"L\" and s[i-1] == \"X\":\\n                count+=30 \\n            elif s[i] == \"L\": \\n                 count +=50\\n            elif s[i] == \"C\" and s[i-1] == \"X\":\\n                count+=80 \\n            elif s[i] == \"C\": \\n                  count +=100\\n            elif s[i] == \"D\" and s[i-1] == \"C\":\\n                 count += 300\\n            elif s[i] == \"D\": \\n                  count +=500\\n            elif s[i] == \"M\" and s[i-1] == \"C\":\\n                count+=800 \\n            elif s[i] == \"M\": \\n                  count +=1000\\n        return count"
                    },
                    {
                        "username": "Satyam1988",
                        "content": "if the constraints get failed what should i return?"
                    },
                    {
                        "username": "anandsharma2686",
                        "content": "s=Xc\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "if(h.get(s.charAt(i)) >= h.get(s.charAt(i+1))){\n                r += h.get(s.charAt(i));  \n                i++;\n}\n\nWhat this problem test us?\nRuntime Error\njava.lang.NullPointerException: Cannot invoke \"java.lang.Integer.intValue()\" because the return value of \"java.util.HashMap.get(Object)\" is null\n  at line 8, Solution.romanToInt\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main "
                    },
                    {
                        "username": "Theleappp",
                        "content": "can any one explain why the third test case is failing for my code\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n      int sum1=0;\\n      int sum2=0;\\n      int sum;\\n      int count=0;\\n      for(int k=0;s[k]!=\\'\\\\0\\';k++)\\n      {\\n        count++;\\n      }\\n      for(int i=0;i<count;i++)\\n      {   if(s[i]==\\'I\\'){\\n          s[i]=1;\\n      }\\n          if(s[i]==\\'V\\'){\\n          s[i]=5;\\n      }\\n           if(s[i]==\\'X\\'){\\n          s[i]=10;\\n      }\\n          if(s[i]==\\'L\\'){\\n          s[i]=50;\\n      }\\n           if(s[i]==\\'C\\'){\\n          s[i]=100;\\n      }\\n          if(s[i]==\\'D\\'){\\n          s[i]=500;\\n      }\\n           if(s[i]==\\'M\\'){\\n          s[i]=1000;\\n      }\\n    }\\n    for(int j=0;j<count-1;j++){\\n    if(s[j]<s[j+1])\\n    {\\n      sum1=sum1+s[j]; \\n    }\\n    if(s[j]>=s[j+1])\\n    {\\n      sum2=sum2+s[j];\\n    }\\n     }\\n       sum2=sum2+s[count-1];\\n        sum=sum2-sum1;\\n         return sum;\\n   }\\n};"
                    },
                    {
                        "username": "paomar",
                        "content": "hi can someone help me to understand why the third case is failed please ?  \\n`class Solution {\\n    fun romanToInt(s: String): Int {\\n        var res = 0\\n        s.map{char ->\\n           res += when(char.toString()){\\n                \"I\" -> 1  \\n                \"V\"   ->          5\\n                \"X\"     ->       10\\n                \"L\"      ->      50\\n                \"C\"     ->     100\\n                \"D\"     ->       500\\n                \"M\"      ->      1000\\n                else -> 0\\n            } \\n        }\\n        return res\\n    }\\n}`"
                    },
                    {
                        "username": "mainsamouel",
                        "content": "why there is a \"ReferenceErrpr: prompt is not defined\""
                    },
                    {
                        "username": "DDKK64",
                        "content": "In case someone need the literal in C++:\\n\\n```C++\\nint weight[128] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,500,0,0,0,0,1,0,0,50,1000,0,0,0,0,0,0,0,0,5,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n```\\n\\ngenerated by Python"
                    },
                    {
                        "username": "KommidiHarshavardhanReddy",
                        "content": "int romanToInt(char * s){\\n int count=0,i;\\n char c[16];\\n for(i=0;i<15;i++)\\n { \\n     if(s[i]!=\\'\\\\0\\')\\n     c[i]=s[i];\\n     else\\n     c[i]=\\'\\\\0\\';\\n }\\n for(i=0;i<15;i++)\\n {\\n     if(c[i]==\\'I\\')\\n     count=count+1;\\n     else if(c[i]==\\'V\\')\\n     count=count+5;\\n     else if(c[i]==\\'X\\')\\n     count=count+10;\\n     else if(c[i]==\\'L\\')\\n     count=count+50;\\n     else if(c[i]==\\'C\\')\\n     count=count+100;\\n     else if(c[i]==\\'D\\')\\n     count=count+500;\\n     else if(c[i]==\\'M\\')\\n     count=count+1000;\\n     else \\n     count+=0;\\n\\n }\\n //printf(\"%d\",count);\\n return count;\\n\\n}\\n\\n\\nRuntime Error\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000014 at pc 0x55edc6088c15 bp 0x7ffe34f817c0 sp 0x7ffe34f817b0\\nREAD of size 1 at 0x602000000014 thread T0\\n    #2 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000014 is located 0 bytes to the right of 4-byte region [0x602000000010,0x602000000014)\\nallocated by thread T0 here:\\n    #0 0x7fe47ae34808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\nwhat is meaning of this error? \\ncan anyone help me out?"
                    },
                    {
                        "username": "serzan",
                        "content": "int romanToInt(char * s){\\nint count=0,i;\\nchar c[16];\\nfor(i=0;i<15;i++)\\n{\\nif(s[i]!=\\'\\\\0\\')\\nc[i]=s[i];\\nelse\\nc[i]=\\'\\\\0\\';\\n}\\nfor(i=0;i<15;i++)\\n{\\nif(c[i]==\\'I\\' && c[i+1]==\\'V\\'){\\ncount=count+4;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\' && c[i+1]==\\'X\\'){\\ncount=count+9;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'L\\'){\\ncount=count+40;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'C\\'){\\ncount=count+90;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'D\\'){\\ncount=count+400;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'M\\'){\\ncount=count+900;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\')\\ncount=count+1;\\nelse if(c[i]==\\'V\\')\\ncount=count+5;\\nelse if(c[i]==\\'X\\')\\ncount=count+10;\\nelse if(c[i]==\\'L\\')\\ncount=count+50;\\nelse if(c[i]==\\'C\\')\\ncount=count+100;\\nelse if(c[i]==\\'D\\')\\ncount=count+500;\\nelse if(c[i]==\\'M\\')\\ncount=count+1000;\\nelse\\ncount+=0;\\n\\n}\\n//printf(\"%d\",count);\\nreturn count;\\n\\n}\\n\\nint main(int argc, char *argv[])\\n{\\nchar s[]=\"MCMXCIV\";\\nint x=romanToInt(s);\\nprintf(\"%d\",x);\\n}"
                    }
                ]
            },
            {
                "id": 1912700,
                "content": [
                    {
                        "username": "GokulCN",
                        "content": "explain the logic"
                    },
                    {
                        "username": "mohamedhamoody0",
                        "content": "\\nWRONG ANSWER IN THIS TEST ?? \"MMMCDXC\" . OUTPUT IS 3290 WHY ?, IT SHOULD BE 3490\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        count = 0 \\n        for i in range (len(s)):\\n            if s[i] == \"I\" :   \\n                  count +=1\\n            elif s[i] == \"V\" and s[i-1] == \"I\": \\n                   count+= 3\\n            elif s[i] == \"V\":\\n                    count+=5\\n            elif s[i] == \"X\" and s[i-1] == \"I\":\\n                count+=8 \\n            elif s[i] == \"X\": \\n                 count +=10\\n            elif s[i] == \"L\" and s[i-1] == \"X\":\\n                count+=30 \\n            elif s[i] == \"L\": \\n                 count +=50\\n            elif s[i] == \"C\" and s[i-1] == \"X\":\\n                count+=80 \\n            elif s[i] == \"C\": \\n                  count +=100\\n            elif s[i] == \"D\" and s[i-1] == \"C\":\\n                 count += 300\\n            elif s[i] == \"D\": \\n                  count +=500\\n            elif s[i] == \"M\" and s[i-1] == \"C\":\\n                count+=800 \\n            elif s[i] == \"M\": \\n                  count +=1000\\n        return count"
                    },
                    {
                        "username": "Satyam1988",
                        "content": "if the constraints get failed what should i return?"
                    },
                    {
                        "username": "anandsharma2686",
                        "content": "s=Xc\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "if(h.get(s.charAt(i)) >= h.get(s.charAt(i+1))){\n                r += h.get(s.charAt(i));  \n                i++;\n}\n\nWhat this problem test us?\nRuntime Error\njava.lang.NullPointerException: Cannot invoke \"java.lang.Integer.intValue()\" because the return value of \"java.util.HashMap.get(Object)\" is null\n  at line 8, Solution.romanToInt\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main "
                    },
                    {
                        "username": "Theleappp",
                        "content": "can any one explain why the third test case is failing for my code\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n      int sum1=0;\\n      int sum2=0;\\n      int sum;\\n      int count=0;\\n      for(int k=0;s[k]!=\\'\\\\0\\';k++)\\n      {\\n        count++;\\n      }\\n      for(int i=0;i<count;i++)\\n      {   if(s[i]==\\'I\\'){\\n          s[i]=1;\\n      }\\n          if(s[i]==\\'V\\'){\\n          s[i]=5;\\n      }\\n           if(s[i]==\\'X\\'){\\n          s[i]=10;\\n      }\\n          if(s[i]==\\'L\\'){\\n          s[i]=50;\\n      }\\n           if(s[i]==\\'C\\'){\\n          s[i]=100;\\n      }\\n          if(s[i]==\\'D\\'){\\n          s[i]=500;\\n      }\\n           if(s[i]==\\'M\\'){\\n          s[i]=1000;\\n      }\\n    }\\n    for(int j=0;j<count-1;j++){\\n    if(s[j]<s[j+1])\\n    {\\n      sum1=sum1+s[j]; \\n    }\\n    if(s[j]>=s[j+1])\\n    {\\n      sum2=sum2+s[j];\\n    }\\n     }\\n       sum2=sum2+s[count-1];\\n        sum=sum2-sum1;\\n         return sum;\\n   }\\n};"
                    },
                    {
                        "username": "paomar",
                        "content": "hi can someone help me to understand why the third case is failed please ?  \\n`class Solution {\\n    fun romanToInt(s: String): Int {\\n        var res = 0\\n        s.map{char ->\\n           res += when(char.toString()){\\n                \"I\" -> 1  \\n                \"V\"   ->          5\\n                \"X\"     ->       10\\n                \"L\"      ->      50\\n                \"C\"     ->     100\\n                \"D\"     ->       500\\n                \"M\"      ->      1000\\n                else -> 0\\n            } \\n        }\\n        return res\\n    }\\n}`"
                    },
                    {
                        "username": "mainsamouel",
                        "content": "why there is a \"ReferenceErrpr: prompt is not defined\""
                    },
                    {
                        "username": "DDKK64",
                        "content": "In case someone need the literal in C++:\\n\\n```C++\\nint weight[128] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,500,0,0,0,0,1,0,0,50,1000,0,0,0,0,0,0,0,0,5,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n```\\n\\ngenerated by Python"
                    },
                    {
                        "username": "KommidiHarshavardhanReddy",
                        "content": "int romanToInt(char * s){\\n int count=0,i;\\n char c[16];\\n for(i=0;i<15;i++)\\n { \\n     if(s[i]!=\\'\\\\0\\')\\n     c[i]=s[i];\\n     else\\n     c[i]=\\'\\\\0\\';\\n }\\n for(i=0;i<15;i++)\\n {\\n     if(c[i]==\\'I\\')\\n     count=count+1;\\n     else if(c[i]==\\'V\\')\\n     count=count+5;\\n     else if(c[i]==\\'X\\')\\n     count=count+10;\\n     else if(c[i]==\\'L\\')\\n     count=count+50;\\n     else if(c[i]==\\'C\\')\\n     count=count+100;\\n     else if(c[i]==\\'D\\')\\n     count=count+500;\\n     else if(c[i]==\\'M\\')\\n     count=count+1000;\\n     else \\n     count+=0;\\n\\n }\\n //printf(\"%d\",count);\\n return count;\\n\\n}\\n\\n\\nRuntime Error\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000014 at pc 0x55edc6088c15 bp 0x7ffe34f817c0 sp 0x7ffe34f817b0\\nREAD of size 1 at 0x602000000014 thread T0\\n    #2 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000014 is located 0 bytes to the right of 4-byte region [0x602000000010,0x602000000014)\\nallocated by thread T0 here:\\n    #0 0x7fe47ae34808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\nwhat is meaning of this error? \\ncan anyone help me out?"
                    },
                    {
                        "username": "serzan",
                        "content": "int romanToInt(char * s){\\nint count=0,i;\\nchar c[16];\\nfor(i=0;i<15;i++)\\n{\\nif(s[i]!=\\'\\\\0\\')\\nc[i]=s[i];\\nelse\\nc[i]=\\'\\\\0\\';\\n}\\nfor(i=0;i<15;i++)\\n{\\nif(c[i]==\\'I\\' && c[i+1]==\\'V\\'){\\ncount=count+4;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\' && c[i+1]==\\'X\\'){\\ncount=count+9;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'L\\'){\\ncount=count+40;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'C\\'){\\ncount=count+90;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'D\\'){\\ncount=count+400;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'M\\'){\\ncount=count+900;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\')\\ncount=count+1;\\nelse if(c[i]==\\'V\\')\\ncount=count+5;\\nelse if(c[i]==\\'X\\')\\ncount=count+10;\\nelse if(c[i]==\\'L\\')\\ncount=count+50;\\nelse if(c[i]==\\'C\\')\\ncount=count+100;\\nelse if(c[i]==\\'D\\')\\ncount=count+500;\\nelse if(c[i]==\\'M\\')\\ncount=count+1000;\\nelse\\ncount+=0;\\n\\n}\\n//printf(\"%d\",count);\\nreturn count;\\n\\n}\\n\\nint main(int argc, char *argv[])\\n{\\nchar s[]=\"MCMXCIV\";\\nint x=romanToInt(s);\\nprintf(\"%d\",x);\\n}"
                    }
                ]
            },
            {
                "id": 1903951,
                "content": [
                    {
                        "username": "GokulCN",
                        "content": "explain the logic"
                    },
                    {
                        "username": "mohamedhamoody0",
                        "content": "\\nWRONG ANSWER IN THIS TEST ?? \"MMMCDXC\" . OUTPUT IS 3290 WHY ?, IT SHOULD BE 3490\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        count = 0 \\n        for i in range (len(s)):\\n            if s[i] == \"I\" :   \\n                  count +=1\\n            elif s[i] == \"V\" and s[i-1] == \"I\": \\n                   count+= 3\\n            elif s[i] == \"V\":\\n                    count+=5\\n            elif s[i] == \"X\" and s[i-1] == \"I\":\\n                count+=8 \\n            elif s[i] == \"X\": \\n                 count +=10\\n            elif s[i] == \"L\" and s[i-1] == \"X\":\\n                count+=30 \\n            elif s[i] == \"L\": \\n                 count +=50\\n            elif s[i] == \"C\" and s[i-1] == \"X\":\\n                count+=80 \\n            elif s[i] == \"C\": \\n                  count +=100\\n            elif s[i] == \"D\" and s[i-1] == \"C\":\\n                 count += 300\\n            elif s[i] == \"D\": \\n                  count +=500\\n            elif s[i] == \"M\" and s[i-1] == \"C\":\\n                count+=800 \\n            elif s[i] == \"M\": \\n                  count +=1000\\n        return count"
                    },
                    {
                        "username": "Satyam1988",
                        "content": "if the constraints get failed what should i return?"
                    },
                    {
                        "username": "anandsharma2686",
                        "content": "s=Xc\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "if(h.get(s.charAt(i)) >= h.get(s.charAt(i+1))){\n                r += h.get(s.charAt(i));  \n                i++;\n}\n\nWhat this problem test us?\nRuntime Error\njava.lang.NullPointerException: Cannot invoke \"java.lang.Integer.intValue()\" because the return value of \"java.util.HashMap.get(Object)\" is null\n  at line 8, Solution.romanToInt\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main "
                    },
                    {
                        "username": "Theleappp",
                        "content": "can any one explain why the third test case is failing for my code\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n      int sum1=0;\\n      int sum2=0;\\n      int sum;\\n      int count=0;\\n      for(int k=0;s[k]!=\\'\\\\0\\';k++)\\n      {\\n        count++;\\n      }\\n      for(int i=0;i<count;i++)\\n      {   if(s[i]==\\'I\\'){\\n          s[i]=1;\\n      }\\n          if(s[i]==\\'V\\'){\\n          s[i]=5;\\n      }\\n           if(s[i]==\\'X\\'){\\n          s[i]=10;\\n      }\\n          if(s[i]==\\'L\\'){\\n          s[i]=50;\\n      }\\n           if(s[i]==\\'C\\'){\\n          s[i]=100;\\n      }\\n          if(s[i]==\\'D\\'){\\n          s[i]=500;\\n      }\\n           if(s[i]==\\'M\\'){\\n          s[i]=1000;\\n      }\\n    }\\n    for(int j=0;j<count-1;j++){\\n    if(s[j]<s[j+1])\\n    {\\n      sum1=sum1+s[j]; \\n    }\\n    if(s[j]>=s[j+1])\\n    {\\n      sum2=sum2+s[j];\\n    }\\n     }\\n       sum2=sum2+s[count-1];\\n        sum=sum2-sum1;\\n         return sum;\\n   }\\n};"
                    },
                    {
                        "username": "paomar",
                        "content": "hi can someone help me to understand why the third case is failed please ?  \\n`class Solution {\\n    fun romanToInt(s: String): Int {\\n        var res = 0\\n        s.map{char ->\\n           res += when(char.toString()){\\n                \"I\" -> 1  \\n                \"V\"   ->          5\\n                \"X\"     ->       10\\n                \"L\"      ->      50\\n                \"C\"     ->     100\\n                \"D\"     ->       500\\n                \"M\"      ->      1000\\n                else -> 0\\n            } \\n        }\\n        return res\\n    }\\n}`"
                    },
                    {
                        "username": "mainsamouel",
                        "content": "why there is a \"ReferenceErrpr: prompt is not defined\""
                    },
                    {
                        "username": "DDKK64",
                        "content": "In case someone need the literal in C++:\\n\\n```C++\\nint weight[128] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,500,0,0,0,0,1,0,0,50,1000,0,0,0,0,0,0,0,0,5,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n```\\n\\ngenerated by Python"
                    },
                    {
                        "username": "KommidiHarshavardhanReddy",
                        "content": "int romanToInt(char * s){\\n int count=0,i;\\n char c[16];\\n for(i=0;i<15;i++)\\n { \\n     if(s[i]!=\\'\\\\0\\')\\n     c[i]=s[i];\\n     else\\n     c[i]=\\'\\\\0\\';\\n }\\n for(i=0;i<15;i++)\\n {\\n     if(c[i]==\\'I\\')\\n     count=count+1;\\n     else if(c[i]==\\'V\\')\\n     count=count+5;\\n     else if(c[i]==\\'X\\')\\n     count=count+10;\\n     else if(c[i]==\\'L\\')\\n     count=count+50;\\n     else if(c[i]==\\'C\\')\\n     count=count+100;\\n     else if(c[i]==\\'D\\')\\n     count=count+500;\\n     else if(c[i]==\\'M\\')\\n     count=count+1000;\\n     else \\n     count+=0;\\n\\n }\\n //printf(\"%d\",count);\\n return count;\\n\\n}\\n\\n\\nRuntime Error\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000014 at pc 0x55edc6088c15 bp 0x7ffe34f817c0 sp 0x7ffe34f817b0\\nREAD of size 1 at 0x602000000014 thread T0\\n    #2 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000014 is located 0 bytes to the right of 4-byte region [0x602000000010,0x602000000014)\\nallocated by thread T0 here:\\n    #0 0x7fe47ae34808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\nwhat is meaning of this error? \\ncan anyone help me out?"
                    },
                    {
                        "username": "serzan",
                        "content": "int romanToInt(char * s){\\nint count=0,i;\\nchar c[16];\\nfor(i=0;i<15;i++)\\n{\\nif(s[i]!=\\'\\\\0\\')\\nc[i]=s[i];\\nelse\\nc[i]=\\'\\\\0\\';\\n}\\nfor(i=0;i<15;i++)\\n{\\nif(c[i]==\\'I\\' && c[i+1]==\\'V\\'){\\ncount=count+4;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\' && c[i+1]==\\'X\\'){\\ncount=count+9;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'L\\'){\\ncount=count+40;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'C\\'){\\ncount=count+90;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'D\\'){\\ncount=count+400;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'M\\'){\\ncount=count+900;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\')\\ncount=count+1;\\nelse if(c[i]==\\'V\\')\\ncount=count+5;\\nelse if(c[i]==\\'X\\')\\ncount=count+10;\\nelse if(c[i]==\\'L\\')\\ncount=count+50;\\nelse if(c[i]==\\'C\\')\\ncount=count+100;\\nelse if(c[i]==\\'D\\')\\ncount=count+500;\\nelse if(c[i]==\\'M\\')\\ncount=count+1000;\\nelse\\ncount+=0;\\n\\n}\\n//printf(\"%d\",count);\\nreturn count;\\n\\n}\\n\\nint main(int argc, char *argv[])\\n{\\nchar s[]=\"MCMXCIV\";\\nint x=romanToInt(s);\\nprintf(\"%d\",x);\\n}"
                    }
                ]
            },
            {
                "id": 1902230,
                "content": [
                    {
                        "username": "GokulCN",
                        "content": "explain the logic"
                    },
                    {
                        "username": "mohamedhamoody0",
                        "content": "\\nWRONG ANSWER IN THIS TEST ?? \"MMMCDXC\" . OUTPUT IS 3290 WHY ?, IT SHOULD BE 3490\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        count = 0 \\n        for i in range (len(s)):\\n            if s[i] == \"I\" :   \\n                  count +=1\\n            elif s[i] == \"V\" and s[i-1] == \"I\": \\n                   count+= 3\\n            elif s[i] == \"V\":\\n                    count+=5\\n            elif s[i] == \"X\" and s[i-1] == \"I\":\\n                count+=8 \\n            elif s[i] == \"X\": \\n                 count +=10\\n            elif s[i] == \"L\" and s[i-1] == \"X\":\\n                count+=30 \\n            elif s[i] == \"L\": \\n                 count +=50\\n            elif s[i] == \"C\" and s[i-1] == \"X\":\\n                count+=80 \\n            elif s[i] == \"C\": \\n                  count +=100\\n            elif s[i] == \"D\" and s[i-1] == \"C\":\\n                 count += 300\\n            elif s[i] == \"D\": \\n                  count +=500\\n            elif s[i] == \"M\" and s[i-1] == \"C\":\\n                count+=800 \\n            elif s[i] == \"M\": \\n                  count +=1000\\n        return count"
                    },
                    {
                        "username": "Satyam1988",
                        "content": "if the constraints get failed what should i return?"
                    },
                    {
                        "username": "anandsharma2686",
                        "content": "s=Xc\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "if(h.get(s.charAt(i)) >= h.get(s.charAt(i+1))){\n                r += h.get(s.charAt(i));  \n                i++;\n}\n\nWhat this problem test us?\nRuntime Error\njava.lang.NullPointerException: Cannot invoke \"java.lang.Integer.intValue()\" because the return value of \"java.util.HashMap.get(Object)\" is null\n  at line 8, Solution.romanToInt\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main "
                    },
                    {
                        "username": "Theleappp",
                        "content": "can any one explain why the third test case is failing for my code\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n      int sum1=0;\\n      int sum2=0;\\n      int sum;\\n      int count=0;\\n      for(int k=0;s[k]!=\\'\\\\0\\';k++)\\n      {\\n        count++;\\n      }\\n      for(int i=0;i<count;i++)\\n      {   if(s[i]==\\'I\\'){\\n          s[i]=1;\\n      }\\n          if(s[i]==\\'V\\'){\\n          s[i]=5;\\n      }\\n           if(s[i]==\\'X\\'){\\n          s[i]=10;\\n      }\\n          if(s[i]==\\'L\\'){\\n          s[i]=50;\\n      }\\n           if(s[i]==\\'C\\'){\\n          s[i]=100;\\n      }\\n          if(s[i]==\\'D\\'){\\n          s[i]=500;\\n      }\\n           if(s[i]==\\'M\\'){\\n          s[i]=1000;\\n      }\\n    }\\n    for(int j=0;j<count-1;j++){\\n    if(s[j]<s[j+1])\\n    {\\n      sum1=sum1+s[j]; \\n    }\\n    if(s[j]>=s[j+1])\\n    {\\n      sum2=sum2+s[j];\\n    }\\n     }\\n       sum2=sum2+s[count-1];\\n        sum=sum2-sum1;\\n         return sum;\\n   }\\n};"
                    },
                    {
                        "username": "paomar",
                        "content": "hi can someone help me to understand why the third case is failed please ?  \\n`class Solution {\\n    fun romanToInt(s: String): Int {\\n        var res = 0\\n        s.map{char ->\\n           res += when(char.toString()){\\n                \"I\" -> 1  \\n                \"V\"   ->          5\\n                \"X\"     ->       10\\n                \"L\"      ->      50\\n                \"C\"     ->     100\\n                \"D\"     ->       500\\n                \"M\"      ->      1000\\n                else -> 0\\n            } \\n        }\\n        return res\\n    }\\n}`"
                    },
                    {
                        "username": "mainsamouel",
                        "content": "why there is a \"ReferenceErrpr: prompt is not defined\""
                    },
                    {
                        "username": "DDKK64",
                        "content": "In case someone need the literal in C++:\\n\\n```C++\\nint weight[128] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,500,0,0,0,0,1,0,0,50,1000,0,0,0,0,0,0,0,0,5,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n```\\n\\ngenerated by Python"
                    },
                    {
                        "username": "KommidiHarshavardhanReddy",
                        "content": "int romanToInt(char * s){\\n int count=0,i;\\n char c[16];\\n for(i=0;i<15;i++)\\n { \\n     if(s[i]!=\\'\\\\0\\')\\n     c[i]=s[i];\\n     else\\n     c[i]=\\'\\\\0\\';\\n }\\n for(i=0;i<15;i++)\\n {\\n     if(c[i]==\\'I\\')\\n     count=count+1;\\n     else if(c[i]==\\'V\\')\\n     count=count+5;\\n     else if(c[i]==\\'X\\')\\n     count=count+10;\\n     else if(c[i]==\\'L\\')\\n     count=count+50;\\n     else if(c[i]==\\'C\\')\\n     count=count+100;\\n     else if(c[i]==\\'D\\')\\n     count=count+500;\\n     else if(c[i]==\\'M\\')\\n     count=count+1000;\\n     else \\n     count+=0;\\n\\n }\\n //printf(\"%d\",count);\\n return count;\\n\\n}\\n\\n\\nRuntime Error\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000014 at pc 0x55edc6088c15 bp 0x7ffe34f817c0 sp 0x7ffe34f817b0\\nREAD of size 1 at 0x602000000014 thread T0\\n    #2 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000014 is located 0 bytes to the right of 4-byte region [0x602000000010,0x602000000014)\\nallocated by thread T0 here:\\n    #0 0x7fe47ae34808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\nwhat is meaning of this error? \\ncan anyone help me out?"
                    },
                    {
                        "username": "serzan",
                        "content": "int romanToInt(char * s){\\nint count=0,i;\\nchar c[16];\\nfor(i=0;i<15;i++)\\n{\\nif(s[i]!=\\'\\\\0\\')\\nc[i]=s[i];\\nelse\\nc[i]=\\'\\\\0\\';\\n}\\nfor(i=0;i<15;i++)\\n{\\nif(c[i]==\\'I\\' && c[i+1]==\\'V\\'){\\ncount=count+4;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\' && c[i+1]==\\'X\\'){\\ncount=count+9;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'L\\'){\\ncount=count+40;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'C\\'){\\ncount=count+90;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'D\\'){\\ncount=count+400;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'M\\'){\\ncount=count+900;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\')\\ncount=count+1;\\nelse if(c[i]==\\'V\\')\\ncount=count+5;\\nelse if(c[i]==\\'X\\')\\ncount=count+10;\\nelse if(c[i]==\\'L\\')\\ncount=count+50;\\nelse if(c[i]==\\'C\\')\\ncount=count+100;\\nelse if(c[i]==\\'D\\')\\ncount=count+500;\\nelse if(c[i]==\\'M\\')\\ncount=count+1000;\\nelse\\ncount+=0;\\n\\n}\\n//printf(\"%d\",count);\\nreturn count;\\n\\n}\\n\\nint main(int argc, char *argv[])\\n{\\nchar s[]=\"MCMXCIV\";\\nint x=romanToInt(s);\\nprintf(\"%d\",x);\\n}"
                    }
                ]
            },
            {
                "id": 1901413,
                "content": [
                    {
                        "username": "GokulCN",
                        "content": "explain the logic"
                    },
                    {
                        "username": "mohamedhamoody0",
                        "content": "\\nWRONG ANSWER IN THIS TEST ?? \"MMMCDXC\" . OUTPUT IS 3290 WHY ?, IT SHOULD BE 3490\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        count = 0 \\n        for i in range (len(s)):\\n            if s[i] == \"I\" :   \\n                  count +=1\\n            elif s[i] == \"V\" and s[i-1] == \"I\": \\n                   count+= 3\\n            elif s[i] == \"V\":\\n                    count+=5\\n            elif s[i] == \"X\" and s[i-1] == \"I\":\\n                count+=8 \\n            elif s[i] == \"X\": \\n                 count +=10\\n            elif s[i] == \"L\" and s[i-1] == \"X\":\\n                count+=30 \\n            elif s[i] == \"L\": \\n                 count +=50\\n            elif s[i] == \"C\" and s[i-1] == \"X\":\\n                count+=80 \\n            elif s[i] == \"C\": \\n                  count +=100\\n            elif s[i] == \"D\" and s[i-1] == \"C\":\\n                 count += 300\\n            elif s[i] == \"D\": \\n                  count +=500\\n            elif s[i] == \"M\" and s[i-1] == \"C\":\\n                count+=800 \\n            elif s[i] == \"M\": \\n                  count +=1000\\n        return count"
                    },
                    {
                        "username": "Satyam1988",
                        "content": "if the constraints get failed what should i return?"
                    },
                    {
                        "username": "anandsharma2686",
                        "content": "s=Xc\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "if(h.get(s.charAt(i)) >= h.get(s.charAt(i+1))){\n                r += h.get(s.charAt(i));  \n                i++;\n}\n\nWhat this problem test us?\nRuntime Error\njava.lang.NullPointerException: Cannot invoke \"java.lang.Integer.intValue()\" because the return value of \"java.util.HashMap.get(Object)\" is null\n  at line 8, Solution.romanToInt\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main "
                    },
                    {
                        "username": "Theleappp",
                        "content": "can any one explain why the third test case is failing for my code\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n      int sum1=0;\\n      int sum2=0;\\n      int sum;\\n      int count=0;\\n      for(int k=0;s[k]!=\\'\\\\0\\';k++)\\n      {\\n        count++;\\n      }\\n      for(int i=0;i<count;i++)\\n      {   if(s[i]==\\'I\\'){\\n          s[i]=1;\\n      }\\n          if(s[i]==\\'V\\'){\\n          s[i]=5;\\n      }\\n           if(s[i]==\\'X\\'){\\n          s[i]=10;\\n      }\\n          if(s[i]==\\'L\\'){\\n          s[i]=50;\\n      }\\n           if(s[i]==\\'C\\'){\\n          s[i]=100;\\n      }\\n          if(s[i]==\\'D\\'){\\n          s[i]=500;\\n      }\\n           if(s[i]==\\'M\\'){\\n          s[i]=1000;\\n      }\\n    }\\n    for(int j=0;j<count-1;j++){\\n    if(s[j]<s[j+1])\\n    {\\n      sum1=sum1+s[j]; \\n    }\\n    if(s[j]>=s[j+1])\\n    {\\n      sum2=sum2+s[j];\\n    }\\n     }\\n       sum2=sum2+s[count-1];\\n        sum=sum2-sum1;\\n         return sum;\\n   }\\n};"
                    },
                    {
                        "username": "paomar",
                        "content": "hi can someone help me to understand why the third case is failed please ?  \\n`class Solution {\\n    fun romanToInt(s: String): Int {\\n        var res = 0\\n        s.map{char ->\\n           res += when(char.toString()){\\n                \"I\" -> 1  \\n                \"V\"   ->          5\\n                \"X\"     ->       10\\n                \"L\"      ->      50\\n                \"C\"     ->     100\\n                \"D\"     ->       500\\n                \"M\"      ->      1000\\n                else -> 0\\n            } \\n        }\\n        return res\\n    }\\n}`"
                    },
                    {
                        "username": "mainsamouel",
                        "content": "why there is a \"ReferenceErrpr: prompt is not defined\""
                    },
                    {
                        "username": "DDKK64",
                        "content": "In case someone need the literal in C++:\\n\\n```C++\\nint weight[128] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,500,0,0,0,0,1,0,0,50,1000,0,0,0,0,0,0,0,0,5,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n```\\n\\ngenerated by Python"
                    },
                    {
                        "username": "KommidiHarshavardhanReddy",
                        "content": "int romanToInt(char * s){\\n int count=0,i;\\n char c[16];\\n for(i=0;i<15;i++)\\n { \\n     if(s[i]!=\\'\\\\0\\')\\n     c[i]=s[i];\\n     else\\n     c[i]=\\'\\\\0\\';\\n }\\n for(i=0;i<15;i++)\\n {\\n     if(c[i]==\\'I\\')\\n     count=count+1;\\n     else if(c[i]==\\'V\\')\\n     count=count+5;\\n     else if(c[i]==\\'X\\')\\n     count=count+10;\\n     else if(c[i]==\\'L\\')\\n     count=count+50;\\n     else if(c[i]==\\'C\\')\\n     count=count+100;\\n     else if(c[i]==\\'D\\')\\n     count=count+500;\\n     else if(c[i]==\\'M\\')\\n     count=count+1000;\\n     else \\n     count+=0;\\n\\n }\\n //printf(\"%d\",count);\\n return count;\\n\\n}\\n\\n\\nRuntime Error\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000014 at pc 0x55edc6088c15 bp 0x7ffe34f817c0 sp 0x7ffe34f817b0\\nREAD of size 1 at 0x602000000014 thread T0\\n    #2 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000014 is located 0 bytes to the right of 4-byte region [0x602000000010,0x602000000014)\\nallocated by thread T0 here:\\n    #0 0x7fe47ae34808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\nwhat is meaning of this error? \\ncan anyone help me out?"
                    },
                    {
                        "username": "serzan",
                        "content": "int romanToInt(char * s){\\nint count=0,i;\\nchar c[16];\\nfor(i=0;i<15;i++)\\n{\\nif(s[i]!=\\'\\\\0\\')\\nc[i]=s[i];\\nelse\\nc[i]=\\'\\\\0\\';\\n}\\nfor(i=0;i<15;i++)\\n{\\nif(c[i]==\\'I\\' && c[i+1]==\\'V\\'){\\ncount=count+4;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\' && c[i+1]==\\'X\\'){\\ncount=count+9;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'L\\'){\\ncount=count+40;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'C\\'){\\ncount=count+90;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'D\\'){\\ncount=count+400;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'M\\'){\\ncount=count+900;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\')\\ncount=count+1;\\nelse if(c[i]==\\'V\\')\\ncount=count+5;\\nelse if(c[i]==\\'X\\')\\ncount=count+10;\\nelse if(c[i]==\\'L\\')\\ncount=count+50;\\nelse if(c[i]==\\'C\\')\\ncount=count+100;\\nelse if(c[i]==\\'D\\')\\ncount=count+500;\\nelse if(c[i]==\\'M\\')\\ncount=count+1000;\\nelse\\ncount+=0;\\n\\n}\\n//printf(\"%d\",count);\\nreturn count;\\n\\n}\\n\\nint main(int argc, char *argv[])\\n{\\nchar s[]=\"MCMXCIV\";\\nint x=romanToInt(s);\\nprintf(\"%d\",x);\\n}"
                    }
                ]
            },
            {
                "id": 1901315,
                "content": [
                    {
                        "username": "GokulCN",
                        "content": "explain the logic"
                    },
                    {
                        "username": "mohamedhamoody0",
                        "content": "\\nWRONG ANSWER IN THIS TEST ?? \"MMMCDXC\" . OUTPUT IS 3290 WHY ?, IT SHOULD BE 3490\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        count = 0 \\n        for i in range (len(s)):\\n            if s[i] == \"I\" :   \\n                  count +=1\\n            elif s[i] == \"V\" and s[i-1] == \"I\": \\n                   count+= 3\\n            elif s[i] == \"V\":\\n                    count+=5\\n            elif s[i] == \"X\" and s[i-1] == \"I\":\\n                count+=8 \\n            elif s[i] == \"X\": \\n                 count +=10\\n            elif s[i] == \"L\" and s[i-1] == \"X\":\\n                count+=30 \\n            elif s[i] == \"L\": \\n                 count +=50\\n            elif s[i] == \"C\" and s[i-1] == \"X\":\\n                count+=80 \\n            elif s[i] == \"C\": \\n                  count +=100\\n            elif s[i] == \"D\" and s[i-1] == \"C\":\\n                 count += 300\\n            elif s[i] == \"D\": \\n                  count +=500\\n            elif s[i] == \"M\" and s[i-1] == \"C\":\\n                count+=800 \\n            elif s[i] == \"M\": \\n                  count +=1000\\n        return count"
                    },
                    {
                        "username": "Satyam1988",
                        "content": "if the constraints get failed what should i return?"
                    },
                    {
                        "username": "anandsharma2686",
                        "content": "s=Xc\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "if(h.get(s.charAt(i)) >= h.get(s.charAt(i+1))){\n                r += h.get(s.charAt(i));  \n                i++;\n}\n\nWhat this problem test us?\nRuntime Error\njava.lang.NullPointerException: Cannot invoke \"java.lang.Integer.intValue()\" because the return value of \"java.util.HashMap.get(Object)\" is null\n  at line 8, Solution.romanToInt\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main "
                    },
                    {
                        "username": "Theleappp",
                        "content": "can any one explain why the third test case is failing for my code\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n      int sum1=0;\\n      int sum2=0;\\n      int sum;\\n      int count=0;\\n      for(int k=0;s[k]!=\\'\\\\0\\';k++)\\n      {\\n        count++;\\n      }\\n      for(int i=0;i<count;i++)\\n      {   if(s[i]==\\'I\\'){\\n          s[i]=1;\\n      }\\n          if(s[i]==\\'V\\'){\\n          s[i]=5;\\n      }\\n           if(s[i]==\\'X\\'){\\n          s[i]=10;\\n      }\\n          if(s[i]==\\'L\\'){\\n          s[i]=50;\\n      }\\n           if(s[i]==\\'C\\'){\\n          s[i]=100;\\n      }\\n          if(s[i]==\\'D\\'){\\n          s[i]=500;\\n      }\\n           if(s[i]==\\'M\\'){\\n          s[i]=1000;\\n      }\\n    }\\n    for(int j=0;j<count-1;j++){\\n    if(s[j]<s[j+1])\\n    {\\n      sum1=sum1+s[j]; \\n    }\\n    if(s[j]>=s[j+1])\\n    {\\n      sum2=sum2+s[j];\\n    }\\n     }\\n       sum2=sum2+s[count-1];\\n        sum=sum2-sum1;\\n         return sum;\\n   }\\n};"
                    },
                    {
                        "username": "paomar",
                        "content": "hi can someone help me to understand why the third case is failed please ?  \\n`class Solution {\\n    fun romanToInt(s: String): Int {\\n        var res = 0\\n        s.map{char ->\\n           res += when(char.toString()){\\n                \"I\" -> 1  \\n                \"V\"   ->          5\\n                \"X\"     ->       10\\n                \"L\"      ->      50\\n                \"C\"     ->     100\\n                \"D\"     ->       500\\n                \"M\"      ->      1000\\n                else -> 0\\n            } \\n        }\\n        return res\\n    }\\n}`"
                    },
                    {
                        "username": "mainsamouel",
                        "content": "why there is a \"ReferenceErrpr: prompt is not defined\""
                    },
                    {
                        "username": "DDKK64",
                        "content": "In case someone need the literal in C++:\\n\\n```C++\\nint weight[128] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,500,0,0,0,0,1,0,0,50,1000,0,0,0,0,0,0,0,0,5,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n```\\n\\ngenerated by Python"
                    },
                    {
                        "username": "KommidiHarshavardhanReddy",
                        "content": "int romanToInt(char * s){\\n int count=0,i;\\n char c[16];\\n for(i=0;i<15;i++)\\n { \\n     if(s[i]!=\\'\\\\0\\')\\n     c[i]=s[i];\\n     else\\n     c[i]=\\'\\\\0\\';\\n }\\n for(i=0;i<15;i++)\\n {\\n     if(c[i]==\\'I\\')\\n     count=count+1;\\n     else if(c[i]==\\'V\\')\\n     count=count+5;\\n     else if(c[i]==\\'X\\')\\n     count=count+10;\\n     else if(c[i]==\\'L\\')\\n     count=count+50;\\n     else if(c[i]==\\'C\\')\\n     count=count+100;\\n     else if(c[i]==\\'D\\')\\n     count=count+500;\\n     else if(c[i]==\\'M\\')\\n     count=count+1000;\\n     else \\n     count+=0;\\n\\n }\\n //printf(\"%d\",count);\\n return count;\\n\\n}\\n\\n\\nRuntime Error\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000014 at pc 0x55edc6088c15 bp 0x7ffe34f817c0 sp 0x7ffe34f817b0\\nREAD of size 1 at 0x602000000014 thread T0\\n    #2 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000014 is located 0 bytes to the right of 4-byte region [0x602000000010,0x602000000014)\\nallocated by thread T0 here:\\n    #0 0x7fe47ae34808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\nwhat is meaning of this error? \\ncan anyone help me out?"
                    },
                    {
                        "username": "serzan",
                        "content": "int romanToInt(char * s){\\nint count=0,i;\\nchar c[16];\\nfor(i=0;i<15;i++)\\n{\\nif(s[i]!=\\'\\\\0\\')\\nc[i]=s[i];\\nelse\\nc[i]=\\'\\\\0\\';\\n}\\nfor(i=0;i<15;i++)\\n{\\nif(c[i]==\\'I\\' && c[i+1]==\\'V\\'){\\ncount=count+4;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\' && c[i+1]==\\'X\\'){\\ncount=count+9;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'L\\'){\\ncount=count+40;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'C\\'){\\ncount=count+90;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'D\\'){\\ncount=count+400;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'M\\'){\\ncount=count+900;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\')\\ncount=count+1;\\nelse if(c[i]==\\'V\\')\\ncount=count+5;\\nelse if(c[i]==\\'X\\')\\ncount=count+10;\\nelse if(c[i]==\\'L\\')\\ncount=count+50;\\nelse if(c[i]==\\'C\\')\\ncount=count+100;\\nelse if(c[i]==\\'D\\')\\ncount=count+500;\\nelse if(c[i]==\\'M\\')\\ncount=count+1000;\\nelse\\ncount+=0;\\n\\n}\\n//printf(\"%d\",count);\\nreturn count;\\n\\n}\\n\\nint main(int argc, char *argv[])\\n{\\nchar s[]=\"MCMXCIV\";\\nint x=romanToInt(s);\\nprintf(\"%d\",x);\\n}"
                    }
                ]
            },
            {
                "id": 1900070,
                "content": [
                    {
                        "username": "GokulCN",
                        "content": "explain the logic"
                    },
                    {
                        "username": "mohamedhamoody0",
                        "content": "\\nWRONG ANSWER IN THIS TEST ?? \"MMMCDXC\" . OUTPUT IS 3290 WHY ?, IT SHOULD BE 3490\\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        count = 0 \\n        for i in range (len(s)):\\n            if s[i] == \"I\" :   \\n                  count +=1\\n            elif s[i] == \"V\" and s[i-1] == \"I\": \\n                   count+= 3\\n            elif s[i] == \"V\":\\n                    count+=5\\n            elif s[i] == \"X\" and s[i-1] == \"I\":\\n                count+=8 \\n            elif s[i] == \"X\": \\n                 count +=10\\n            elif s[i] == \"L\" and s[i-1] == \"X\":\\n                count+=30 \\n            elif s[i] == \"L\": \\n                 count +=50\\n            elif s[i] == \"C\" and s[i-1] == \"X\":\\n                count+=80 \\n            elif s[i] == \"C\": \\n                  count +=100\\n            elif s[i] == \"D\" and s[i-1] == \"C\":\\n                 count += 300\\n            elif s[i] == \"D\": \\n                  count +=500\\n            elif s[i] == \"M\" and s[i-1] == \"C\":\\n                count+=800 \\n            elif s[i] == \"M\": \\n                  count +=1000\\n        return count"
                    },
                    {
                        "username": "Satyam1988",
                        "content": "if the constraints get failed what should i return?"
                    },
                    {
                        "username": "anandsharma2686",
                        "content": "s=Xc\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "if(h.get(s.charAt(i)) >= h.get(s.charAt(i+1))){\n                r += h.get(s.charAt(i));  \n                i++;\n}\n\nWhat this problem test us?\nRuntime Error\njava.lang.NullPointerException: Cannot invoke \"java.lang.Integer.intValue()\" because the return value of \"java.util.HashMap.get(Object)\" is null\n  at line 8, Solution.romanToInt\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main "
                    },
                    {
                        "username": "Theleappp",
                        "content": "can any one explain why the third test case is failing for my code\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n      int sum1=0;\\n      int sum2=0;\\n      int sum;\\n      int count=0;\\n      for(int k=0;s[k]!=\\'\\\\0\\';k++)\\n      {\\n        count++;\\n      }\\n      for(int i=0;i<count;i++)\\n      {   if(s[i]==\\'I\\'){\\n          s[i]=1;\\n      }\\n          if(s[i]==\\'V\\'){\\n          s[i]=5;\\n      }\\n           if(s[i]==\\'X\\'){\\n          s[i]=10;\\n      }\\n          if(s[i]==\\'L\\'){\\n          s[i]=50;\\n      }\\n           if(s[i]==\\'C\\'){\\n          s[i]=100;\\n      }\\n          if(s[i]==\\'D\\'){\\n          s[i]=500;\\n      }\\n           if(s[i]==\\'M\\'){\\n          s[i]=1000;\\n      }\\n    }\\n    for(int j=0;j<count-1;j++){\\n    if(s[j]<s[j+1])\\n    {\\n      sum1=sum1+s[j]; \\n    }\\n    if(s[j]>=s[j+1])\\n    {\\n      sum2=sum2+s[j];\\n    }\\n     }\\n       sum2=sum2+s[count-1];\\n        sum=sum2-sum1;\\n         return sum;\\n   }\\n};"
                    },
                    {
                        "username": "paomar",
                        "content": "hi can someone help me to understand why the third case is failed please ?  \\n`class Solution {\\n    fun romanToInt(s: String): Int {\\n        var res = 0\\n        s.map{char ->\\n           res += when(char.toString()){\\n                \"I\" -> 1  \\n                \"V\"   ->          5\\n                \"X\"     ->       10\\n                \"L\"      ->      50\\n                \"C\"     ->     100\\n                \"D\"     ->       500\\n                \"M\"      ->      1000\\n                else -> 0\\n            } \\n        }\\n        return res\\n    }\\n}`"
                    },
                    {
                        "username": "mainsamouel",
                        "content": "why there is a \"ReferenceErrpr: prompt is not defined\""
                    },
                    {
                        "username": "DDKK64",
                        "content": "In case someone need the literal in C++:\\n\\n```C++\\nint weight[128] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,500,0,0,0,0,1,0,0,50,1000,0,0,0,0,0,0,0,0,5,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n```\\n\\ngenerated by Python"
                    },
                    {
                        "username": "KommidiHarshavardhanReddy",
                        "content": "int romanToInt(char * s){\\n int count=0,i;\\n char c[16];\\n for(i=0;i<15;i++)\\n { \\n     if(s[i]!=\\'\\\\0\\')\\n     c[i]=s[i];\\n     else\\n     c[i]=\\'\\\\0\\';\\n }\\n for(i=0;i<15;i++)\\n {\\n     if(c[i]==\\'I\\')\\n     count=count+1;\\n     else if(c[i]==\\'V\\')\\n     count=count+5;\\n     else if(c[i]==\\'X\\')\\n     count=count+10;\\n     else if(c[i]==\\'L\\')\\n     count=count+50;\\n     else if(c[i]==\\'C\\')\\n     count=count+100;\\n     else if(c[i]==\\'D\\')\\n     count=count+500;\\n     else if(c[i]==\\'M\\')\\n     count=count+1000;\\n     else \\n     count+=0;\\n\\n }\\n //printf(\"%d\",count);\\n return count;\\n\\n}\\n\\n\\nRuntime Error\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000014 at pc 0x55edc6088c15 bp 0x7ffe34f817c0 sp 0x7ffe34f817b0\\nREAD of size 1 at 0x602000000014 thread T0\\n    #2 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000014 is located 0 bytes to the right of 4-byte region [0x602000000010,0x602000000014)\\nallocated by thread T0 here:\\n    #0 0x7fe47ae34808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fe47a1ec082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\nwhat is meaning of this error? \\ncan anyone help me out?"
                    },
                    {
                        "username": "serzan",
                        "content": "int romanToInt(char * s){\\nint count=0,i;\\nchar c[16];\\nfor(i=0;i<15;i++)\\n{\\nif(s[i]!=\\'\\\\0\\')\\nc[i]=s[i];\\nelse\\nc[i]=\\'\\\\0\\';\\n}\\nfor(i=0;i<15;i++)\\n{\\nif(c[i]==\\'I\\' && c[i+1]==\\'V\\'){\\ncount=count+4;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\' && c[i+1]==\\'X\\'){\\ncount=count+9;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'L\\'){\\ncount=count+40;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'X\\' && c[i+1]==\\'C\\'){\\ncount=count+90;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'D\\'){\\ncount=count+400;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'C\\' && c[i+1]==\\'M\\'){\\ncount=count+900;\\ni=i+1;\\ncontinue;}\\n\\nif(c[i]==\\'I\\')\\ncount=count+1;\\nelse if(c[i]==\\'V\\')\\ncount=count+5;\\nelse if(c[i]==\\'X\\')\\ncount=count+10;\\nelse if(c[i]==\\'L\\')\\ncount=count+50;\\nelse if(c[i]==\\'C\\')\\ncount=count+100;\\nelse if(c[i]==\\'D\\')\\ncount=count+500;\\nelse if(c[i]==\\'M\\')\\ncount=count+1000;\\nelse\\ncount+=0;\\n\\n}\\n//printf(\"%d\",count);\\nreturn count;\\n\\n}\\n\\nint main(int argc, char *argv[])\\n{\\nchar s[]=\"MCMXCIV\";\\nint x=romanToInt(s);\\nprintf(\"%d\",x);\\n}"
                    }
                ]
            },
            {
                "id": 1898946,
                "content": [
                    {
                        "username": "user7205pr",
                        "content": "what\\'s use\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ask it on an interview :))"
                    },
                    {
                        "username": "xXbob_the_coderXx",
                        "content": "Use a Dictionary."
                    },
                    {
                        "username": "Ensik",
                        "content": "public class Solution {\n    public int RomanToInt(string s) {\n     Dictionary<char, int> numb = new Dictionary<char, int>()\n        {\n            {'I',1},\n            {'V',5},\n            {'X',10},\n            {'L',50},\n            {'C',100},\n            {'D',500},\n            {'M',1000},\n        };\n    HashSet<string> strings = new HashSet<string>();\n    int result = 0;\n    for (int i = 0; i < s.Length; i++)\n    {\n        int value1 = 0;\n        if (numb.TryGetValue(s[i], out value1))\n        {\n            var search = strings.FirstOrDefault(o => o.Contains($\"{s[i == 0 ? 0 : i - 1]}{s[i]}\"));\n            if (search != null) continue;\n            int value2 = 0;\n            if (i < s.Length-1)\n            {\n                if (numb.TryGetValue(s[i + 1], out value2))\n                { \n                   if (value2 > value1)\n                   {              \n                      strings.Clear();\n                      result += (value2 - value1);\n                      strings.Add($\"{s[i]}{s[i + 1]}\");                      \n                   }\n                    else\n                    {\n                        result += value1;\n                    }\n                }\n            }\n            else\n            {\n                result += value1;\n            }\n        }\n    }\n    strings.Clear();\n    return result;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahambetqwer",
                        "content": "Who knows? Why my code is not running? It works in other compilers (Python3)"
                    },
                    {
                        "username": "gutonon1004",
                        "content": "alguem pode me ajudar com uma solu\\xE7\\xE3o em c?\\n"
                    },
                    {
                        "username": "Pratyush_upadhyaya",
                        "content": "My code is not giving result for same consecutive numbers, but giving result for DCIL(different numbers). why?\\nfor(int i=vec.size()-1;i>0;--i)\\n    {\\n    \\n        if(vec[i]>vec[i-1])\\n        {\\n            vec[i-1]=vec[i]-vec[i-1];\\n            vec.pop_back();\\n        }\\n        else\\n        {\\n            vec[i-1]=vec[i]+vec[i-1];\\n            vec.pop_back();\\n        }\\n    }"
                    },
                    {
                        "username": "adaniel1",
                        "content": "First question on LeetCode!\\n\\nAlthough I had to think about it for a bit, eventually (with a bit of debugging), I got to the solution. Although I did spend maybe an hour on it since I had to reacquaint myself with Java.\\n\\nI still question whether this is \"Easy\". Guess I\\'ll find out as I do more problems lol."
                    },
                    {
                        "username": "IronForce-Auscent",
                        "content": "Tips for beginners:\n- Try to find a way to replace weird values like \"IV\" and \"IX\" to something that is easier to sum, such as \"IV\" -> \"IIII\" and \"IX\" -> \"VIIII\"\n- Use a dictionary to make it easier to find the respective values of each character instead of using if...else statements"
                    },
                    {
                        "username": "wiedzmin1c",
                        "content": "CMLII is 952 not 1152, can`t submit"
                    },
                    {
                        "username": "sanwarjayswal",
                        "content": "good"
                    }
                ]
            },
            {
                "id": 1895147,
                "content": [
                    {
                        "username": "user7205pr",
                        "content": "what\\'s use\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ask it on an interview :))"
                    },
                    {
                        "username": "xXbob_the_coderXx",
                        "content": "Use a Dictionary."
                    },
                    {
                        "username": "Ensik",
                        "content": "public class Solution {\n    public int RomanToInt(string s) {\n     Dictionary<char, int> numb = new Dictionary<char, int>()\n        {\n            {'I',1},\n            {'V',5},\n            {'X',10},\n            {'L',50},\n            {'C',100},\n            {'D',500},\n            {'M',1000},\n        };\n    HashSet<string> strings = new HashSet<string>();\n    int result = 0;\n    for (int i = 0; i < s.Length; i++)\n    {\n        int value1 = 0;\n        if (numb.TryGetValue(s[i], out value1))\n        {\n            var search = strings.FirstOrDefault(o => o.Contains($\"{s[i == 0 ? 0 : i - 1]}{s[i]}\"));\n            if (search != null) continue;\n            int value2 = 0;\n            if (i < s.Length-1)\n            {\n                if (numb.TryGetValue(s[i + 1], out value2))\n                { \n                   if (value2 > value1)\n                   {              \n                      strings.Clear();\n                      result += (value2 - value1);\n                      strings.Add($\"{s[i]}{s[i + 1]}\");                      \n                   }\n                    else\n                    {\n                        result += value1;\n                    }\n                }\n            }\n            else\n            {\n                result += value1;\n            }\n        }\n    }\n    strings.Clear();\n    return result;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahambetqwer",
                        "content": "Who knows? Why my code is not running? It works in other compilers (Python3)"
                    },
                    {
                        "username": "gutonon1004",
                        "content": "alguem pode me ajudar com uma solu\\xE7\\xE3o em c?\\n"
                    },
                    {
                        "username": "Pratyush_upadhyaya",
                        "content": "My code is not giving result for same consecutive numbers, but giving result for DCIL(different numbers). why?\\nfor(int i=vec.size()-1;i>0;--i)\\n    {\\n    \\n        if(vec[i]>vec[i-1])\\n        {\\n            vec[i-1]=vec[i]-vec[i-1];\\n            vec.pop_back();\\n        }\\n        else\\n        {\\n            vec[i-1]=vec[i]+vec[i-1];\\n            vec.pop_back();\\n        }\\n    }"
                    },
                    {
                        "username": "adaniel1",
                        "content": "First question on LeetCode!\\n\\nAlthough I had to think about it for a bit, eventually (with a bit of debugging), I got to the solution. Although I did spend maybe an hour on it since I had to reacquaint myself with Java.\\n\\nI still question whether this is \"Easy\". Guess I\\'ll find out as I do more problems lol."
                    },
                    {
                        "username": "IronForce-Auscent",
                        "content": "Tips for beginners:\n- Try to find a way to replace weird values like \"IV\" and \"IX\" to something that is easier to sum, such as \"IV\" -> \"IIII\" and \"IX\" -> \"VIIII\"\n- Use a dictionary to make it easier to find the respective values of each character instead of using if...else statements"
                    },
                    {
                        "username": "wiedzmin1c",
                        "content": "CMLII is 952 not 1152, can`t submit"
                    },
                    {
                        "username": "sanwarjayswal",
                        "content": "good"
                    }
                ]
            },
            {
                "id": 1894238,
                "content": [
                    {
                        "username": "user7205pr",
                        "content": "what\\'s use\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ask it on an interview :))"
                    },
                    {
                        "username": "xXbob_the_coderXx",
                        "content": "Use a Dictionary."
                    },
                    {
                        "username": "Ensik",
                        "content": "public class Solution {\n    public int RomanToInt(string s) {\n     Dictionary<char, int> numb = new Dictionary<char, int>()\n        {\n            {'I',1},\n            {'V',5},\n            {'X',10},\n            {'L',50},\n            {'C',100},\n            {'D',500},\n            {'M',1000},\n        };\n    HashSet<string> strings = new HashSet<string>();\n    int result = 0;\n    for (int i = 0; i < s.Length; i++)\n    {\n        int value1 = 0;\n        if (numb.TryGetValue(s[i], out value1))\n        {\n            var search = strings.FirstOrDefault(o => o.Contains($\"{s[i == 0 ? 0 : i - 1]}{s[i]}\"));\n            if (search != null) continue;\n            int value2 = 0;\n            if (i < s.Length-1)\n            {\n                if (numb.TryGetValue(s[i + 1], out value2))\n                { \n                   if (value2 > value1)\n                   {              \n                      strings.Clear();\n                      result += (value2 - value1);\n                      strings.Add($\"{s[i]}{s[i + 1]}\");                      \n                   }\n                    else\n                    {\n                        result += value1;\n                    }\n                }\n            }\n            else\n            {\n                result += value1;\n            }\n        }\n    }\n    strings.Clear();\n    return result;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahambetqwer",
                        "content": "Who knows? Why my code is not running? It works in other compilers (Python3)"
                    },
                    {
                        "username": "gutonon1004",
                        "content": "alguem pode me ajudar com uma solu\\xE7\\xE3o em c?\\n"
                    },
                    {
                        "username": "Pratyush_upadhyaya",
                        "content": "My code is not giving result for same consecutive numbers, but giving result for DCIL(different numbers). why?\\nfor(int i=vec.size()-1;i>0;--i)\\n    {\\n    \\n        if(vec[i]>vec[i-1])\\n        {\\n            vec[i-1]=vec[i]-vec[i-1];\\n            vec.pop_back();\\n        }\\n        else\\n        {\\n            vec[i-1]=vec[i]+vec[i-1];\\n            vec.pop_back();\\n        }\\n    }"
                    },
                    {
                        "username": "adaniel1",
                        "content": "First question on LeetCode!\\n\\nAlthough I had to think about it for a bit, eventually (with a bit of debugging), I got to the solution. Although I did spend maybe an hour on it since I had to reacquaint myself with Java.\\n\\nI still question whether this is \"Easy\". Guess I\\'ll find out as I do more problems lol."
                    },
                    {
                        "username": "IronForce-Auscent",
                        "content": "Tips for beginners:\n- Try to find a way to replace weird values like \"IV\" and \"IX\" to something that is easier to sum, such as \"IV\" -> \"IIII\" and \"IX\" -> \"VIIII\"\n- Use a dictionary to make it easier to find the respective values of each character instead of using if...else statements"
                    },
                    {
                        "username": "wiedzmin1c",
                        "content": "CMLII is 952 not 1152, can`t submit"
                    },
                    {
                        "username": "sanwarjayswal",
                        "content": "good"
                    }
                ]
            },
            {
                "id": 1891473,
                "content": [
                    {
                        "username": "user7205pr",
                        "content": "what\\'s use\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ask it on an interview :))"
                    },
                    {
                        "username": "xXbob_the_coderXx",
                        "content": "Use a Dictionary."
                    },
                    {
                        "username": "Ensik",
                        "content": "public class Solution {\n    public int RomanToInt(string s) {\n     Dictionary<char, int> numb = new Dictionary<char, int>()\n        {\n            {'I',1},\n            {'V',5},\n            {'X',10},\n            {'L',50},\n            {'C',100},\n            {'D',500},\n            {'M',1000},\n        };\n    HashSet<string> strings = new HashSet<string>();\n    int result = 0;\n    for (int i = 0; i < s.Length; i++)\n    {\n        int value1 = 0;\n        if (numb.TryGetValue(s[i], out value1))\n        {\n            var search = strings.FirstOrDefault(o => o.Contains($\"{s[i == 0 ? 0 : i - 1]}{s[i]}\"));\n            if (search != null) continue;\n            int value2 = 0;\n            if (i < s.Length-1)\n            {\n                if (numb.TryGetValue(s[i + 1], out value2))\n                { \n                   if (value2 > value1)\n                   {              \n                      strings.Clear();\n                      result += (value2 - value1);\n                      strings.Add($\"{s[i]}{s[i + 1]}\");                      \n                   }\n                    else\n                    {\n                        result += value1;\n                    }\n                }\n            }\n            else\n            {\n                result += value1;\n            }\n        }\n    }\n    strings.Clear();\n    return result;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahambetqwer",
                        "content": "Who knows? Why my code is not running? It works in other compilers (Python3)"
                    },
                    {
                        "username": "gutonon1004",
                        "content": "alguem pode me ajudar com uma solu\\xE7\\xE3o em c?\\n"
                    },
                    {
                        "username": "Pratyush_upadhyaya",
                        "content": "My code is not giving result for same consecutive numbers, but giving result for DCIL(different numbers). why?\\nfor(int i=vec.size()-1;i>0;--i)\\n    {\\n    \\n        if(vec[i]>vec[i-1])\\n        {\\n            vec[i-1]=vec[i]-vec[i-1];\\n            vec.pop_back();\\n        }\\n        else\\n        {\\n            vec[i-1]=vec[i]+vec[i-1];\\n            vec.pop_back();\\n        }\\n    }"
                    },
                    {
                        "username": "adaniel1",
                        "content": "First question on LeetCode!\\n\\nAlthough I had to think about it for a bit, eventually (with a bit of debugging), I got to the solution. Although I did spend maybe an hour on it since I had to reacquaint myself with Java.\\n\\nI still question whether this is \"Easy\". Guess I\\'ll find out as I do more problems lol."
                    },
                    {
                        "username": "IronForce-Auscent",
                        "content": "Tips for beginners:\n- Try to find a way to replace weird values like \"IV\" and \"IX\" to something that is easier to sum, such as \"IV\" -> \"IIII\" and \"IX\" -> \"VIIII\"\n- Use a dictionary to make it easier to find the respective values of each character instead of using if...else statements"
                    },
                    {
                        "username": "wiedzmin1c",
                        "content": "CMLII is 952 not 1152, can`t submit"
                    },
                    {
                        "username": "sanwarjayswal",
                        "content": "good"
                    }
                ]
            },
            {
                "id": 1890486,
                "content": [
                    {
                        "username": "user7205pr",
                        "content": "what\\'s use\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ask it on an interview :))"
                    },
                    {
                        "username": "xXbob_the_coderXx",
                        "content": "Use a Dictionary."
                    },
                    {
                        "username": "Ensik",
                        "content": "public class Solution {\n    public int RomanToInt(string s) {\n     Dictionary<char, int> numb = new Dictionary<char, int>()\n        {\n            {'I',1},\n            {'V',5},\n            {'X',10},\n            {'L',50},\n            {'C',100},\n            {'D',500},\n            {'M',1000},\n        };\n    HashSet<string> strings = new HashSet<string>();\n    int result = 0;\n    for (int i = 0; i < s.Length; i++)\n    {\n        int value1 = 0;\n        if (numb.TryGetValue(s[i], out value1))\n        {\n            var search = strings.FirstOrDefault(o => o.Contains($\"{s[i == 0 ? 0 : i - 1]}{s[i]}\"));\n            if (search != null) continue;\n            int value2 = 0;\n            if (i < s.Length-1)\n            {\n                if (numb.TryGetValue(s[i + 1], out value2))\n                { \n                   if (value2 > value1)\n                   {              \n                      strings.Clear();\n                      result += (value2 - value1);\n                      strings.Add($\"{s[i]}{s[i + 1]}\");                      \n                   }\n                    else\n                    {\n                        result += value1;\n                    }\n                }\n            }\n            else\n            {\n                result += value1;\n            }\n        }\n    }\n    strings.Clear();\n    return result;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahambetqwer",
                        "content": "Who knows? Why my code is not running? It works in other compilers (Python3)"
                    },
                    {
                        "username": "gutonon1004",
                        "content": "alguem pode me ajudar com uma solu\\xE7\\xE3o em c?\\n"
                    },
                    {
                        "username": "Pratyush_upadhyaya",
                        "content": "My code is not giving result for same consecutive numbers, but giving result for DCIL(different numbers). why?\\nfor(int i=vec.size()-1;i>0;--i)\\n    {\\n    \\n        if(vec[i]>vec[i-1])\\n        {\\n            vec[i-1]=vec[i]-vec[i-1];\\n            vec.pop_back();\\n        }\\n        else\\n        {\\n            vec[i-1]=vec[i]+vec[i-1];\\n            vec.pop_back();\\n        }\\n    }"
                    },
                    {
                        "username": "adaniel1",
                        "content": "First question on LeetCode!\\n\\nAlthough I had to think about it for a bit, eventually (with a bit of debugging), I got to the solution. Although I did spend maybe an hour on it since I had to reacquaint myself with Java.\\n\\nI still question whether this is \"Easy\". Guess I\\'ll find out as I do more problems lol."
                    },
                    {
                        "username": "IronForce-Auscent",
                        "content": "Tips for beginners:\n- Try to find a way to replace weird values like \"IV\" and \"IX\" to something that is easier to sum, such as \"IV\" -> \"IIII\" and \"IX\" -> \"VIIII\"\n- Use a dictionary to make it easier to find the respective values of each character instead of using if...else statements"
                    },
                    {
                        "username": "wiedzmin1c",
                        "content": "CMLII is 952 not 1152, can`t submit"
                    },
                    {
                        "username": "sanwarjayswal",
                        "content": "good"
                    }
                ]
            },
            {
                "id": 1890157,
                "content": [
                    {
                        "username": "user7205pr",
                        "content": "what\\'s use\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ask it on an interview :))"
                    },
                    {
                        "username": "xXbob_the_coderXx",
                        "content": "Use a Dictionary."
                    },
                    {
                        "username": "Ensik",
                        "content": "public class Solution {\n    public int RomanToInt(string s) {\n     Dictionary<char, int> numb = new Dictionary<char, int>()\n        {\n            {'I',1},\n            {'V',5},\n            {'X',10},\n            {'L',50},\n            {'C',100},\n            {'D',500},\n            {'M',1000},\n        };\n    HashSet<string> strings = new HashSet<string>();\n    int result = 0;\n    for (int i = 0; i < s.Length; i++)\n    {\n        int value1 = 0;\n        if (numb.TryGetValue(s[i], out value1))\n        {\n            var search = strings.FirstOrDefault(o => o.Contains($\"{s[i == 0 ? 0 : i - 1]}{s[i]}\"));\n            if (search != null) continue;\n            int value2 = 0;\n            if (i < s.Length-1)\n            {\n                if (numb.TryGetValue(s[i + 1], out value2))\n                { \n                   if (value2 > value1)\n                   {              \n                      strings.Clear();\n                      result += (value2 - value1);\n                      strings.Add($\"{s[i]}{s[i + 1]}\");                      \n                   }\n                    else\n                    {\n                        result += value1;\n                    }\n                }\n            }\n            else\n            {\n                result += value1;\n            }\n        }\n    }\n    strings.Clear();\n    return result;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahambetqwer",
                        "content": "Who knows? Why my code is not running? It works in other compilers (Python3)"
                    },
                    {
                        "username": "gutonon1004",
                        "content": "alguem pode me ajudar com uma solu\\xE7\\xE3o em c?\\n"
                    },
                    {
                        "username": "Pratyush_upadhyaya",
                        "content": "My code is not giving result for same consecutive numbers, but giving result for DCIL(different numbers). why?\\nfor(int i=vec.size()-1;i>0;--i)\\n    {\\n    \\n        if(vec[i]>vec[i-1])\\n        {\\n            vec[i-1]=vec[i]-vec[i-1];\\n            vec.pop_back();\\n        }\\n        else\\n        {\\n            vec[i-1]=vec[i]+vec[i-1];\\n            vec.pop_back();\\n        }\\n    }"
                    },
                    {
                        "username": "adaniel1",
                        "content": "First question on LeetCode!\\n\\nAlthough I had to think about it for a bit, eventually (with a bit of debugging), I got to the solution. Although I did spend maybe an hour on it since I had to reacquaint myself with Java.\\n\\nI still question whether this is \"Easy\". Guess I\\'ll find out as I do more problems lol."
                    },
                    {
                        "username": "IronForce-Auscent",
                        "content": "Tips for beginners:\n- Try to find a way to replace weird values like \"IV\" and \"IX\" to something that is easier to sum, such as \"IV\" -> \"IIII\" and \"IX\" -> \"VIIII\"\n- Use a dictionary to make it easier to find the respective values of each character instead of using if...else statements"
                    },
                    {
                        "username": "wiedzmin1c",
                        "content": "CMLII is 952 not 1152, can`t submit"
                    },
                    {
                        "username": "sanwarjayswal",
                        "content": "good"
                    }
                ]
            },
            {
                "id": 1889616,
                "content": [
                    {
                        "username": "user7205pr",
                        "content": "what\\'s use\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ask it on an interview :))"
                    },
                    {
                        "username": "xXbob_the_coderXx",
                        "content": "Use a Dictionary."
                    },
                    {
                        "username": "Ensik",
                        "content": "public class Solution {\n    public int RomanToInt(string s) {\n     Dictionary<char, int> numb = new Dictionary<char, int>()\n        {\n            {'I',1},\n            {'V',5},\n            {'X',10},\n            {'L',50},\n            {'C',100},\n            {'D',500},\n            {'M',1000},\n        };\n    HashSet<string> strings = new HashSet<string>();\n    int result = 0;\n    for (int i = 0; i < s.Length; i++)\n    {\n        int value1 = 0;\n        if (numb.TryGetValue(s[i], out value1))\n        {\n            var search = strings.FirstOrDefault(o => o.Contains($\"{s[i == 0 ? 0 : i - 1]}{s[i]}\"));\n            if (search != null) continue;\n            int value2 = 0;\n            if (i < s.Length-1)\n            {\n                if (numb.TryGetValue(s[i + 1], out value2))\n                { \n                   if (value2 > value1)\n                   {              \n                      strings.Clear();\n                      result += (value2 - value1);\n                      strings.Add($\"{s[i]}{s[i + 1]}\");                      \n                   }\n                    else\n                    {\n                        result += value1;\n                    }\n                }\n            }\n            else\n            {\n                result += value1;\n            }\n        }\n    }\n    strings.Clear();\n    return result;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahambetqwer",
                        "content": "Who knows? Why my code is not running? It works in other compilers (Python3)"
                    },
                    {
                        "username": "gutonon1004",
                        "content": "alguem pode me ajudar com uma solu\\xE7\\xE3o em c?\\n"
                    },
                    {
                        "username": "Pratyush_upadhyaya",
                        "content": "My code is not giving result for same consecutive numbers, but giving result for DCIL(different numbers). why?\\nfor(int i=vec.size()-1;i>0;--i)\\n    {\\n    \\n        if(vec[i]>vec[i-1])\\n        {\\n            vec[i-1]=vec[i]-vec[i-1];\\n            vec.pop_back();\\n        }\\n        else\\n        {\\n            vec[i-1]=vec[i]+vec[i-1];\\n            vec.pop_back();\\n        }\\n    }"
                    },
                    {
                        "username": "adaniel1",
                        "content": "First question on LeetCode!\\n\\nAlthough I had to think about it for a bit, eventually (with a bit of debugging), I got to the solution. Although I did spend maybe an hour on it since I had to reacquaint myself with Java.\\n\\nI still question whether this is \"Easy\". Guess I\\'ll find out as I do more problems lol."
                    },
                    {
                        "username": "IronForce-Auscent",
                        "content": "Tips for beginners:\n- Try to find a way to replace weird values like \"IV\" and \"IX\" to something that is easier to sum, such as \"IV\" -> \"IIII\" and \"IX\" -> \"VIIII\"\n- Use a dictionary to make it easier to find the respective values of each character instead of using if...else statements"
                    },
                    {
                        "username": "wiedzmin1c",
                        "content": "CMLII is 952 not 1152, can`t submit"
                    },
                    {
                        "username": "sanwarjayswal",
                        "content": "good"
                    }
                ]
            },
            {
                "id": 1886589,
                "content": [
                    {
                        "username": "user7205pr",
                        "content": "what\\'s use\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ask it on an interview :))"
                    },
                    {
                        "username": "xXbob_the_coderXx",
                        "content": "Use a Dictionary."
                    },
                    {
                        "username": "Ensik",
                        "content": "public class Solution {\n    public int RomanToInt(string s) {\n     Dictionary<char, int> numb = new Dictionary<char, int>()\n        {\n            {'I',1},\n            {'V',5},\n            {'X',10},\n            {'L',50},\n            {'C',100},\n            {'D',500},\n            {'M',1000},\n        };\n    HashSet<string> strings = new HashSet<string>();\n    int result = 0;\n    for (int i = 0; i < s.Length; i++)\n    {\n        int value1 = 0;\n        if (numb.TryGetValue(s[i], out value1))\n        {\n            var search = strings.FirstOrDefault(o => o.Contains($\"{s[i == 0 ? 0 : i - 1]}{s[i]}\"));\n            if (search != null) continue;\n            int value2 = 0;\n            if (i < s.Length-1)\n            {\n                if (numb.TryGetValue(s[i + 1], out value2))\n                { \n                   if (value2 > value1)\n                   {              \n                      strings.Clear();\n                      result += (value2 - value1);\n                      strings.Add($\"{s[i]}{s[i + 1]}\");                      \n                   }\n                    else\n                    {\n                        result += value1;\n                    }\n                }\n            }\n            else\n            {\n                result += value1;\n            }\n        }\n    }\n    strings.Clear();\n    return result;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahambetqwer",
                        "content": "Who knows? Why my code is not running? It works in other compilers (Python3)"
                    },
                    {
                        "username": "gutonon1004",
                        "content": "alguem pode me ajudar com uma solu\\xE7\\xE3o em c?\\n"
                    },
                    {
                        "username": "Pratyush_upadhyaya",
                        "content": "My code is not giving result for same consecutive numbers, but giving result for DCIL(different numbers). why?\\nfor(int i=vec.size()-1;i>0;--i)\\n    {\\n    \\n        if(vec[i]>vec[i-1])\\n        {\\n            vec[i-1]=vec[i]-vec[i-1];\\n            vec.pop_back();\\n        }\\n        else\\n        {\\n            vec[i-1]=vec[i]+vec[i-1];\\n            vec.pop_back();\\n        }\\n    }"
                    },
                    {
                        "username": "adaniel1",
                        "content": "First question on LeetCode!\\n\\nAlthough I had to think about it for a bit, eventually (with a bit of debugging), I got to the solution. Although I did spend maybe an hour on it since I had to reacquaint myself with Java.\\n\\nI still question whether this is \"Easy\". Guess I\\'ll find out as I do more problems lol."
                    },
                    {
                        "username": "IronForce-Auscent",
                        "content": "Tips for beginners:\n- Try to find a way to replace weird values like \"IV\" and \"IX\" to something that is easier to sum, such as \"IV\" -> \"IIII\" and \"IX\" -> \"VIIII\"\n- Use a dictionary to make it easier to find the respective values of each character instead of using if...else statements"
                    },
                    {
                        "username": "wiedzmin1c",
                        "content": "CMLII is 952 not 1152, can`t submit"
                    },
                    {
                        "username": "sanwarjayswal",
                        "content": "good"
                    }
                ]
            },
            {
                "id": 1884557,
                "content": [
                    {
                        "username": "user7205pr",
                        "content": "what\\'s use\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ask it on an interview :))"
                    },
                    {
                        "username": "xXbob_the_coderXx",
                        "content": "Use a Dictionary."
                    },
                    {
                        "username": "Ensik",
                        "content": "public class Solution {\n    public int RomanToInt(string s) {\n     Dictionary<char, int> numb = new Dictionary<char, int>()\n        {\n            {'I',1},\n            {'V',5},\n            {'X',10},\n            {'L',50},\n            {'C',100},\n            {'D',500},\n            {'M',1000},\n        };\n    HashSet<string> strings = new HashSet<string>();\n    int result = 0;\n    for (int i = 0; i < s.Length; i++)\n    {\n        int value1 = 0;\n        if (numb.TryGetValue(s[i], out value1))\n        {\n            var search = strings.FirstOrDefault(o => o.Contains($\"{s[i == 0 ? 0 : i - 1]}{s[i]}\"));\n            if (search != null) continue;\n            int value2 = 0;\n            if (i < s.Length-1)\n            {\n                if (numb.TryGetValue(s[i + 1], out value2))\n                { \n                   if (value2 > value1)\n                   {              \n                      strings.Clear();\n                      result += (value2 - value1);\n                      strings.Add($\"{s[i]}{s[i + 1]}\");                      \n                   }\n                    else\n                    {\n                        result += value1;\n                    }\n                }\n            }\n            else\n            {\n                result += value1;\n            }\n        }\n    }\n    strings.Clear();\n    return result;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahambetqwer",
                        "content": "Who knows? Why my code is not running? It works in other compilers (Python3)"
                    },
                    {
                        "username": "gutonon1004",
                        "content": "alguem pode me ajudar com uma solu\\xE7\\xE3o em c?\\n"
                    },
                    {
                        "username": "Pratyush_upadhyaya",
                        "content": "My code is not giving result for same consecutive numbers, but giving result for DCIL(different numbers). why?\\nfor(int i=vec.size()-1;i>0;--i)\\n    {\\n    \\n        if(vec[i]>vec[i-1])\\n        {\\n            vec[i-1]=vec[i]-vec[i-1];\\n            vec.pop_back();\\n        }\\n        else\\n        {\\n            vec[i-1]=vec[i]+vec[i-1];\\n            vec.pop_back();\\n        }\\n    }"
                    },
                    {
                        "username": "adaniel1",
                        "content": "First question on LeetCode!\\n\\nAlthough I had to think about it for a bit, eventually (with a bit of debugging), I got to the solution. Although I did spend maybe an hour on it since I had to reacquaint myself with Java.\\n\\nI still question whether this is \"Easy\". Guess I\\'ll find out as I do more problems lol."
                    },
                    {
                        "username": "IronForce-Auscent",
                        "content": "Tips for beginners:\n- Try to find a way to replace weird values like \"IV\" and \"IX\" to something that is easier to sum, such as \"IV\" -> \"IIII\" and \"IX\" -> \"VIIII\"\n- Use a dictionary to make it easier to find the respective values of each character instead of using if...else statements"
                    },
                    {
                        "username": "wiedzmin1c",
                        "content": "CMLII is 952 not 1152, can`t submit"
                    },
                    {
                        "username": "sanwarjayswal",
                        "content": "good"
                    }
                ]
            },
            {
                "id": 1882343,
                "content": [
                    {
                        "username": "user7205pr",
                        "content": "what\\'s use\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ask it on an interview :))"
                    },
                    {
                        "username": "xXbob_the_coderXx",
                        "content": "Use a Dictionary."
                    },
                    {
                        "username": "Ensik",
                        "content": "public class Solution {\n    public int RomanToInt(string s) {\n     Dictionary<char, int> numb = new Dictionary<char, int>()\n        {\n            {'I',1},\n            {'V',5},\n            {'X',10},\n            {'L',50},\n            {'C',100},\n            {'D',500},\n            {'M',1000},\n        };\n    HashSet<string> strings = new HashSet<string>();\n    int result = 0;\n    for (int i = 0; i < s.Length; i++)\n    {\n        int value1 = 0;\n        if (numb.TryGetValue(s[i], out value1))\n        {\n            var search = strings.FirstOrDefault(o => o.Contains($\"{s[i == 0 ? 0 : i - 1]}{s[i]}\"));\n            if (search != null) continue;\n            int value2 = 0;\n            if (i < s.Length-1)\n            {\n                if (numb.TryGetValue(s[i + 1], out value2))\n                { \n                   if (value2 > value1)\n                   {              \n                      strings.Clear();\n                      result += (value2 - value1);\n                      strings.Add($\"{s[i]}{s[i + 1]}\");                      \n                   }\n                    else\n                    {\n                        result += value1;\n                    }\n                }\n            }\n            else\n            {\n                result += value1;\n            }\n        }\n    }\n    strings.Clear();\n    return result;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahambetqwer",
                        "content": "Who knows? Why my code is not running? It works in other compilers (Python3)"
                    },
                    {
                        "username": "gutonon1004",
                        "content": "alguem pode me ajudar com uma solu\\xE7\\xE3o em c?\\n"
                    },
                    {
                        "username": "Pratyush_upadhyaya",
                        "content": "My code is not giving result for same consecutive numbers, but giving result for DCIL(different numbers). why?\\nfor(int i=vec.size()-1;i>0;--i)\\n    {\\n    \\n        if(vec[i]>vec[i-1])\\n        {\\n            vec[i-1]=vec[i]-vec[i-1];\\n            vec.pop_back();\\n        }\\n        else\\n        {\\n            vec[i-1]=vec[i]+vec[i-1];\\n            vec.pop_back();\\n        }\\n    }"
                    },
                    {
                        "username": "adaniel1",
                        "content": "First question on LeetCode!\\n\\nAlthough I had to think about it for a bit, eventually (with a bit of debugging), I got to the solution. Although I did spend maybe an hour on it since I had to reacquaint myself with Java.\\n\\nI still question whether this is \"Easy\". Guess I\\'ll find out as I do more problems lol."
                    },
                    {
                        "username": "IronForce-Auscent",
                        "content": "Tips for beginners:\n- Try to find a way to replace weird values like \"IV\" and \"IX\" to something that is easier to sum, such as \"IV\" -> \"IIII\" and \"IX\" -> \"VIIII\"\n- Use a dictionary to make it easier to find the respective values of each character instead of using if...else statements"
                    },
                    {
                        "username": "wiedzmin1c",
                        "content": "CMLII is 952 not 1152, can`t submit"
                    },
                    {
                        "username": "sanwarjayswal",
                        "content": "good"
                    }
                ]
            },
            {
                "id": 1876950,
                "content": [
                    {
                        "username": "sriramlikhithdhoni",
                        "content": "Line 57: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "kumarneeraj50064",
                        "content": "1666"
                    },
                    {
                        "username": "mancah",
                        "content": "The test do not include cases for invalid combination. So many people use:\\n\\nif (char_to_int_map[i] > char_to_int_map[i+1])\\n{\\n//make it negative\\n}\\n\\n"
                    },
                    {
                        "username": "Yorodoshi",
                        "content": "help me, I\\'m a beginner, and I get an error when executing the program:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 67 in _driver (Solution.py)\\n    _driver()\\nLine 73 in <module> (Solution.py)"
                    },
                    {
                        "username": "hanhln1",
                        "content": "your solution has to include a return __ at the end of it"
                    },
                    {
                        "username": "janhavi_chavan",
                        "content": "Do we have to use nested if statements for solving this problem "
                    },
                    {
                        "username": "krowthebest",
                        "content": "2999 / 3999 testcases passed\\nOMG dude, how did it happen"
                    },
                    {
                        "username": "debaudh",
                        "content": "this is what \"grunt work\" looks like. this is easier than \"easy\" and yet took so long to type all the \\'else if \\' s out :/ "
                    },
                    {
                        "username": "Prashantsubedi79",
                        "content": "I think the logic here is \\nto limit the input to be among \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nmaking condition on input that one number can\\'t be repeated more than 3 time \\nsetting the order of \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nallow only one character to break the order \\nlike IV \\nand in such case take it as a minus command \\nand give the value to each \\n\\ncan\\'t find how to do this in code "
                    },
                    {
                        "username": "Roshan_Rajan",
                        "content": "16666"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def romanToInt(self, son):\\n        dict = {\"I\": 1, \"IV\": 4, \"V\": 5, \"IX\": 9, \"X\": 10, \"XL\": 40, \"L\": 50, \"XC\": 90, \"C\": 100, \"CD\": 400, \"D\": 500,\\n        \"CM\": 900, \"M\": 1000}\\n        result = 0\\n        i = 0\\n        while i < len(son):\\n            try:\\n                result += dict[son[i] + son[i + 1]]\\n                i += 2\\n            except(KeyError, IndexError):\\n                result += dict[son[i]]\\n                i += 1\\n        return result\\n```\\nWith dict\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1875284,
                "content": [
                    {
                        "username": "sriramlikhithdhoni",
                        "content": "Line 57: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "kumarneeraj50064",
                        "content": "1666"
                    },
                    {
                        "username": "mancah",
                        "content": "The test do not include cases for invalid combination. So many people use:\\n\\nif (char_to_int_map[i] > char_to_int_map[i+1])\\n{\\n//make it negative\\n}\\n\\n"
                    },
                    {
                        "username": "Yorodoshi",
                        "content": "help me, I\\'m a beginner, and I get an error when executing the program:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 67 in _driver (Solution.py)\\n    _driver()\\nLine 73 in <module> (Solution.py)"
                    },
                    {
                        "username": "hanhln1",
                        "content": "your solution has to include a return __ at the end of it"
                    },
                    {
                        "username": "janhavi_chavan",
                        "content": "Do we have to use nested if statements for solving this problem "
                    },
                    {
                        "username": "krowthebest",
                        "content": "2999 / 3999 testcases passed\\nOMG dude, how did it happen"
                    },
                    {
                        "username": "debaudh",
                        "content": "this is what \"grunt work\" looks like. this is easier than \"easy\" and yet took so long to type all the \\'else if \\' s out :/ "
                    },
                    {
                        "username": "Prashantsubedi79",
                        "content": "I think the logic here is \\nto limit the input to be among \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nmaking condition on input that one number can\\'t be repeated more than 3 time \\nsetting the order of \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nallow only one character to break the order \\nlike IV \\nand in such case take it as a minus command \\nand give the value to each \\n\\ncan\\'t find how to do this in code "
                    },
                    {
                        "username": "Roshan_Rajan",
                        "content": "16666"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def romanToInt(self, son):\\n        dict = {\"I\": 1, \"IV\": 4, \"V\": 5, \"IX\": 9, \"X\": 10, \"XL\": 40, \"L\": 50, \"XC\": 90, \"C\": 100, \"CD\": 400, \"D\": 500,\\n        \"CM\": 900, \"M\": 1000}\\n        result = 0\\n        i = 0\\n        while i < len(son):\\n            try:\\n                result += dict[son[i] + son[i + 1]]\\n                i += 2\\n            except(KeyError, IndexError):\\n                result += dict[son[i]]\\n                i += 1\\n        return result\\n```\\nWith dict\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1873633,
                "content": [
                    {
                        "username": "sriramlikhithdhoni",
                        "content": "Line 57: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "kumarneeraj50064",
                        "content": "1666"
                    },
                    {
                        "username": "mancah",
                        "content": "The test do not include cases for invalid combination. So many people use:\\n\\nif (char_to_int_map[i] > char_to_int_map[i+1])\\n{\\n//make it negative\\n}\\n\\n"
                    },
                    {
                        "username": "Yorodoshi",
                        "content": "help me, I\\'m a beginner, and I get an error when executing the program:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 67 in _driver (Solution.py)\\n    _driver()\\nLine 73 in <module> (Solution.py)"
                    },
                    {
                        "username": "hanhln1",
                        "content": "your solution has to include a return __ at the end of it"
                    },
                    {
                        "username": "janhavi_chavan",
                        "content": "Do we have to use nested if statements for solving this problem "
                    },
                    {
                        "username": "krowthebest",
                        "content": "2999 / 3999 testcases passed\\nOMG dude, how did it happen"
                    },
                    {
                        "username": "debaudh",
                        "content": "this is what \"grunt work\" looks like. this is easier than \"easy\" and yet took so long to type all the \\'else if \\' s out :/ "
                    },
                    {
                        "username": "Prashantsubedi79",
                        "content": "I think the logic here is \\nto limit the input to be among \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nmaking condition on input that one number can\\'t be repeated more than 3 time \\nsetting the order of \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nallow only one character to break the order \\nlike IV \\nand in such case take it as a minus command \\nand give the value to each \\n\\ncan\\'t find how to do this in code "
                    },
                    {
                        "username": "Roshan_Rajan",
                        "content": "16666"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def romanToInt(self, son):\\n        dict = {\"I\": 1, \"IV\": 4, \"V\": 5, \"IX\": 9, \"X\": 10, \"XL\": 40, \"L\": 50, \"XC\": 90, \"C\": 100, \"CD\": 400, \"D\": 500,\\n        \"CM\": 900, \"M\": 1000}\\n        result = 0\\n        i = 0\\n        while i < len(son):\\n            try:\\n                result += dict[son[i] + son[i + 1]]\\n                i += 2\\n            except(KeyError, IndexError):\\n                result += dict[son[i]]\\n                i += 1\\n        return result\\n```\\nWith dict\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1872348,
                "content": [
                    {
                        "username": "sriramlikhithdhoni",
                        "content": "Line 57: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "kumarneeraj50064",
                        "content": "1666"
                    },
                    {
                        "username": "mancah",
                        "content": "The test do not include cases for invalid combination. So many people use:\\n\\nif (char_to_int_map[i] > char_to_int_map[i+1])\\n{\\n//make it negative\\n}\\n\\n"
                    },
                    {
                        "username": "Yorodoshi",
                        "content": "help me, I\\'m a beginner, and I get an error when executing the program:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 67 in _driver (Solution.py)\\n    _driver()\\nLine 73 in <module> (Solution.py)"
                    },
                    {
                        "username": "hanhln1",
                        "content": "your solution has to include a return __ at the end of it"
                    },
                    {
                        "username": "janhavi_chavan",
                        "content": "Do we have to use nested if statements for solving this problem "
                    },
                    {
                        "username": "krowthebest",
                        "content": "2999 / 3999 testcases passed\\nOMG dude, how did it happen"
                    },
                    {
                        "username": "debaudh",
                        "content": "this is what \"grunt work\" looks like. this is easier than \"easy\" and yet took so long to type all the \\'else if \\' s out :/ "
                    },
                    {
                        "username": "Prashantsubedi79",
                        "content": "I think the logic here is \\nto limit the input to be among \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nmaking condition on input that one number can\\'t be repeated more than 3 time \\nsetting the order of \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nallow only one character to break the order \\nlike IV \\nand in such case take it as a minus command \\nand give the value to each \\n\\ncan\\'t find how to do this in code "
                    },
                    {
                        "username": "Roshan_Rajan",
                        "content": "16666"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def romanToInt(self, son):\\n        dict = {\"I\": 1, \"IV\": 4, \"V\": 5, \"IX\": 9, \"X\": 10, \"XL\": 40, \"L\": 50, \"XC\": 90, \"C\": 100, \"CD\": 400, \"D\": 500,\\n        \"CM\": 900, \"M\": 1000}\\n        result = 0\\n        i = 0\\n        while i < len(son):\\n            try:\\n                result += dict[son[i] + son[i + 1]]\\n                i += 2\\n            except(KeyError, IndexError):\\n                result += dict[son[i]]\\n                i += 1\\n        return result\\n```\\nWith dict\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1870213,
                "content": [
                    {
                        "username": "sriramlikhithdhoni",
                        "content": "Line 57: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "kumarneeraj50064",
                        "content": "1666"
                    },
                    {
                        "username": "mancah",
                        "content": "The test do not include cases for invalid combination. So many people use:\\n\\nif (char_to_int_map[i] > char_to_int_map[i+1])\\n{\\n//make it negative\\n}\\n\\n"
                    },
                    {
                        "username": "Yorodoshi",
                        "content": "help me, I\\'m a beginner, and I get an error when executing the program:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 67 in _driver (Solution.py)\\n    _driver()\\nLine 73 in <module> (Solution.py)"
                    },
                    {
                        "username": "hanhln1",
                        "content": "your solution has to include a return __ at the end of it"
                    },
                    {
                        "username": "janhavi_chavan",
                        "content": "Do we have to use nested if statements for solving this problem "
                    },
                    {
                        "username": "krowthebest",
                        "content": "2999 / 3999 testcases passed\\nOMG dude, how did it happen"
                    },
                    {
                        "username": "debaudh",
                        "content": "this is what \"grunt work\" looks like. this is easier than \"easy\" and yet took so long to type all the \\'else if \\' s out :/ "
                    },
                    {
                        "username": "Prashantsubedi79",
                        "content": "I think the logic here is \\nto limit the input to be among \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nmaking condition on input that one number can\\'t be repeated more than 3 time \\nsetting the order of \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nallow only one character to break the order \\nlike IV \\nand in such case take it as a minus command \\nand give the value to each \\n\\ncan\\'t find how to do this in code "
                    },
                    {
                        "username": "Roshan_Rajan",
                        "content": "16666"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def romanToInt(self, son):\\n        dict = {\"I\": 1, \"IV\": 4, \"V\": 5, \"IX\": 9, \"X\": 10, \"XL\": 40, \"L\": 50, \"XC\": 90, \"C\": 100, \"CD\": 400, \"D\": 500,\\n        \"CM\": 900, \"M\": 1000}\\n        result = 0\\n        i = 0\\n        while i < len(son):\\n            try:\\n                result += dict[son[i] + son[i + 1]]\\n                i += 2\\n            except(KeyError, IndexError):\\n                result += dict[son[i]]\\n                i += 1\\n        return result\\n```\\nWith dict\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1869630,
                "content": [
                    {
                        "username": "sriramlikhithdhoni",
                        "content": "Line 57: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "kumarneeraj50064",
                        "content": "1666"
                    },
                    {
                        "username": "mancah",
                        "content": "The test do not include cases for invalid combination. So many people use:\\n\\nif (char_to_int_map[i] > char_to_int_map[i+1])\\n{\\n//make it negative\\n}\\n\\n"
                    },
                    {
                        "username": "Yorodoshi",
                        "content": "help me, I\\'m a beginner, and I get an error when executing the program:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 67 in _driver (Solution.py)\\n    _driver()\\nLine 73 in <module> (Solution.py)"
                    },
                    {
                        "username": "hanhln1",
                        "content": "your solution has to include a return __ at the end of it"
                    },
                    {
                        "username": "janhavi_chavan",
                        "content": "Do we have to use nested if statements for solving this problem "
                    },
                    {
                        "username": "krowthebest",
                        "content": "2999 / 3999 testcases passed\\nOMG dude, how did it happen"
                    },
                    {
                        "username": "debaudh",
                        "content": "this is what \"grunt work\" looks like. this is easier than \"easy\" and yet took so long to type all the \\'else if \\' s out :/ "
                    },
                    {
                        "username": "Prashantsubedi79",
                        "content": "I think the logic here is \\nto limit the input to be among \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nmaking condition on input that one number can\\'t be repeated more than 3 time \\nsetting the order of \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nallow only one character to break the order \\nlike IV \\nand in such case take it as a minus command \\nand give the value to each \\n\\ncan\\'t find how to do this in code "
                    },
                    {
                        "username": "Roshan_Rajan",
                        "content": "16666"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def romanToInt(self, son):\\n        dict = {\"I\": 1, \"IV\": 4, \"V\": 5, \"IX\": 9, \"X\": 10, \"XL\": 40, \"L\": 50, \"XC\": 90, \"C\": 100, \"CD\": 400, \"D\": 500,\\n        \"CM\": 900, \"M\": 1000}\\n        result = 0\\n        i = 0\\n        while i < len(son):\\n            try:\\n                result += dict[son[i] + son[i + 1]]\\n                i += 2\\n            except(KeyError, IndexError):\\n                result += dict[son[i]]\\n                i += 1\\n        return result\\n```\\nWith dict\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1869374,
                "content": [
                    {
                        "username": "sriramlikhithdhoni",
                        "content": "Line 57: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "kumarneeraj50064",
                        "content": "1666"
                    },
                    {
                        "username": "mancah",
                        "content": "The test do not include cases for invalid combination. So many people use:\\n\\nif (char_to_int_map[i] > char_to_int_map[i+1])\\n{\\n//make it negative\\n}\\n\\n"
                    },
                    {
                        "username": "Yorodoshi",
                        "content": "help me, I\\'m a beginner, and I get an error when executing the program:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 67 in _driver (Solution.py)\\n    _driver()\\nLine 73 in <module> (Solution.py)"
                    },
                    {
                        "username": "hanhln1",
                        "content": "your solution has to include a return __ at the end of it"
                    },
                    {
                        "username": "janhavi_chavan",
                        "content": "Do we have to use nested if statements for solving this problem "
                    },
                    {
                        "username": "krowthebest",
                        "content": "2999 / 3999 testcases passed\\nOMG dude, how did it happen"
                    },
                    {
                        "username": "debaudh",
                        "content": "this is what \"grunt work\" looks like. this is easier than \"easy\" and yet took so long to type all the \\'else if \\' s out :/ "
                    },
                    {
                        "username": "Prashantsubedi79",
                        "content": "I think the logic here is \\nto limit the input to be among \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nmaking condition on input that one number can\\'t be repeated more than 3 time \\nsetting the order of \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nallow only one character to break the order \\nlike IV \\nand in such case take it as a minus command \\nand give the value to each \\n\\ncan\\'t find how to do this in code "
                    },
                    {
                        "username": "Roshan_Rajan",
                        "content": "16666"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def romanToInt(self, son):\\n        dict = {\"I\": 1, \"IV\": 4, \"V\": 5, \"IX\": 9, \"X\": 10, \"XL\": 40, \"L\": 50, \"XC\": 90, \"C\": 100, \"CD\": 400, \"D\": 500,\\n        \"CM\": 900, \"M\": 1000}\\n        result = 0\\n        i = 0\\n        while i < len(son):\\n            try:\\n                result += dict[son[i] + son[i + 1]]\\n                i += 2\\n            except(KeyError, IndexError):\\n                result += dict[son[i]]\\n                i += 1\\n        return result\\n```\\nWith dict\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1868095,
                "content": [
                    {
                        "username": "sriramlikhithdhoni",
                        "content": "Line 57: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "kumarneeraj50064",
                        "content": "1666"
                    },
                    {
                        "username": "mancah",
                        "content": "The test do not include cases for invalid combination. So many people use:\\n\\nif (char_to_int_map[i] > char_to_int_map[i+1])\\n{\\n//make it negative\\n}\\n\\n"
                    },
                    {
                        "username": "Yorodoshi",
                        "content": "help me, I\\'m a beginner, and I get an error when executing the program:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 67 in _driver (Solution.py)\\n    _driver()\\nLine 73 in <module> (Solution.py)"
                    },
                    {
                        "username": "hanhln1",
                        "content": "your solution has to include a return __ at the end of it"
                    },
                    {
                        "username": "janhavi_chavan",
                        "content": "Do we have to use nested if statements for solving this problem "
                    },
                    {
                        "username": "krowthebest",
                        "content": "2999 / 3999 testcases passed\\nOMG dude, how did it happen"
                    },
                    {
                        "username": "debaudh",
                        "content": "this is what \"grunt work\" looks like. this is easier than \"easy\" and yet took so long to type all the \\'else if \\' s out :/ "
                    },
                    {
                        "username": "Prashantsubedi79",
                        "content": "I think the logic here is \\nto limit the input to be among \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nmaking condition on input that one number can\\'t be repeated more than 3 time \\nsetting the order of \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nallow only one character to break the order \\nlike IV \\nand in such case take it as a minus command \\nand give the value to each \\n\\ncan\\'t find how to do this in code "
                    },
                    {
                        "username": "Roshan_Rajan",
                        "content": "16666"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def romanToInt(self, son):\\n        dict = {\"I\": 1, \"IV\": 4, \"V\": 5, \"IX\": 9, \"X\": 10, \"XL\": 40, \"L\": 50, \"XC\": 90, \"C\": 100, \"CD\": 400, \"D\": 500,\\n        \"CM\": 900, \"M\": 1000}\\n        result = 0\\n        i = 0\\n        while i < len(son):\\n            try:\\n                result += dict[son[i] + son[i + 1]]\\n                i += 2\\n            except(KeyError, IndexError):\\n                result += dict[son[i]]\\n                i += 1\\n        return result\\n```\\nWith dict\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1859137,
                "content": [
                    {
                        "username": "sriramlikhithdhoni",
                        "content": "Line 57: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "kumarneeraj50064",
                        "content": "1666"
                    },
                    {
                        "username": "mancah",
                        "content": "The test do not include cases for invalid combination. So many people use:\\n\\nif (char_to_int_map[i] > char_to_int_map[i+1])\\n{\\n//make it negative\\n}\\n\\n"
                    },
                    {
                        "username": "Yorodoshi",
                        "content": "help me, I\\'m a beginner, and I get an error when executing the program:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 67 in _driver (Solution.py)\\n    _driver()\\nLine 73 in <module> (Solution.py)"
                    },
                    {
                        "username": "hanhln1",
                        "content": "your solution has to include a return __ at the end of it"
                    },
                    {
                        "username": "janhavi_chavan",
                        "content": "Do we have to use nested if statements for solving this problem "
                    },
                    {
                        "username": "krowthebest",
                        "content": "2999 / 3999 testcases passed\\nOMG dude, how did it happen"
                    },
                    {
                        "username": "debaudh",
                        "content": "this is what \"grunt work\" looks like. this is easier than \"easy\" and yet took so long to type all the \\'else if \\' s out :/ "
                    },
                    {
                        "username": "Prashantsubedi79",
                        "content": "I think the logic here is \\nto limit the input to be among \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nmaking condition on input that one number can\\'t be repeated more than 3 time \\nsetting the order of \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nallow only one character to break the order \\nlike IV \\nand in such case take it as a minus command \\nand give the value to each \\n\\ncan\\'t find how to do this in code "
                    },
                    {
                        "username": "Roshan_Rajan",
                        "content": "16666"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def romanToInt(self, son):\\n        dict = {\"I\": 1, \"IV\": 4, \"V\": 5, \"IX\": 9, \"X\": 10, \"XL\": 40, \"L\": 50, \"XC\": 90, \"C\": 100, \"CD\": 400, \"D\": 500,\\n        \"CM\": 900, \"M\": 1000}\\n        result = 0\\n        i = 0\\n        while i < len(son):\\n            try:\\n                result += dict[son[i] + son[i + 1]]\\n                i += 2\\n            except(KeyError, IndexError):\\n                result += dict[son[i]]\\n                i += 1\\n        return result\\n```\\nWith dict\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1857631,
                "content": [
                    {
                        "username": "sriramlikhithdhoni",
                        "content": "Line 57: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "kumarneeraj50064",
                        "content": "1666"
                    },
                    {
                        "username": "mancah",
                        "content": "The test do not include cases for invalid combination. So many people use:\\n\\nif (char_to_int_map[i] > char_to_int_map[i+1])\\n{\\n//make it negative\\n}\\n\\n"
                    },
                    {
                        "username": "Yorodoshi",
                        "content": "help me, I\\'m a beginner, and I get an error when executing the program:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 67 in _driver (Solution.py)\\n    _driver()\\nLine 73 in <module> (Solution.py)"
                    },
                    {
                        "username": "hanhln1",
                        "content": "your solution has to include a return __ at the end of it"
                    },
                    {
                        "username": "janhavi_chavan",
                        "content": "Do we have to use nested if statements for solving this problem "
                    },
                    {
                        "username": "krowthebest",
                        "content": "2999 / 3999 testcases passed\\nOMG dude, how did it happen"
                    },
                    {
                        "username": "debaudh",
                        "content": "this is what \"grunt work\" looks like. this is easier than \"easy\" and yet took so long to type all the \\'else if \\' s out :/ "
                    },
                    {
                        "username": "Prashantsubedi79",
                        "content": "I think the logic here is \\nto limit the input to be among \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nmaking condition on input that one number can\\'t be repeated more than 3 time \\nsetting the order of \\'I\\', \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\', \\'M\\'\\nallow only one character to break the order \\nlike IV \\nand in such case take it as a minus command \\nand give the value to each \\n\\ncan\\'t find how to do this in code "
                    },
                    {
                        "username": "Roshan_Rajan",
                        "content": "16666"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def romanToInt(self, son):\\n        dict = {\"I\": 1, \"IV\": 4, \"V\": 5, \"IX\": 9, \"X\": 10, \"XL\": 40, \"L\": 50, \"XC\": 90, \"C\": 100, \"CD\": 400, \"D\": 500,\\n        \"CM\": 900, \"M\": 1000}\\n        result = 0\\n        i = 0\\n        while i < len(son):\\n            try:\\n                result += dict[son[i] + son[i + 1]]\\n                i += 2\\n            except(KeyError, IndexError):\\n                result += dict[son[i]]\\n                i += 1\\n        return result\\n```\\nWith dict\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1845318,
                "content": [
                    {
                        "username": "thirumalesh6775",
                        "content": "simple use replace logic\\n"
                    },
                    {
                        "username": "iamnawed",
                        "content": "I have solved this question using Unordered map ;\\n\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans;\\n        int i=s.length()-1;\\n        unordered_map<char ,int>umap;\\n\\n        umap[\\'I\\']=1;\\n        umap[\\'V\\']=5;\\n        umap[\\'X\\']=10;\\n        umap[\\'L\\']=50;\\n        umap[\\'C\\']=100;\\n        umap[\\'D\\']=500;\\n        umap[\\'M\\']=1000;\\n\\n        ans=umap[s[i]];\\n\\n        for(i;i>0;i--)\\n        {\\n            if(umap[s[i-1]]>=umap[s[i]])\\n            ans+=umap[s[i-1]];\\n\\n            else\\n            {\\n                ans-=umap[s[i-1]];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "alena-shs",
                        "content": "Couldn\\'t even read roman numbers over 49 lmao"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i dont understand why do i need to study the question while im practiceing and studing data strucure to know how to solve proplems. i feel its a wast of time "
                    },
                    {
                        "username": "constantin_md",
                        "content": "The best readability and easy to code in this case is O(n), It is also possible to do it in O(1) if creating two arrays for all roman numerals and numbers from 1 to 1000 (won\\'t work for 1001) and accessing their respective indexes. It\\'s also possible to do O(1) for first 20 roman numbers since this are the most used and then O(n) for the 21 - 1000"
                    },
                    {
                        "username": "choudhary2403",
                        "content": "PYHTON 3 solution using DICTIONARIES \\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        r_num = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        total = 0\\n        for i in range(len(s)-1):\\n            if r_num[s[i]] < r_num[s[i+1]] and i != len(s)-1:\\n                total = total - r_num[s[i]]\\n            else:\\n                total += r_num[s[i]]\\n        return total + r_num[s[len(s)-1]]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "devcomm82",
                        "content": "Rules should clarify that the six subtraction cases are the only times that roman numerals aren\\'t written from largest to smallest.  The rules instead say they are \"usually\" written this way; we can\\'t code for usually.    There are no test cases like \"VX\" and the primary solutions all assume that VX can\\'t exist, so its clear its assumed that \"VX\" isn\\'t allowed, so make it explicit when describing the format for Roman numerals."
                    },
                    {
                        "username": "anurag_ad_01",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffef8c87320 overflowed to 0x7ffef8c8731f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n\\n\\nplease tell me what i am doing  wrong here\\n\\n\\nthis is code \\n\\n int sum=0;\\n\\n    for(int i=s.size()-1;i>=0;i--){\\n\\n   if(s[i]==\\'M\\'){\\n       if(s[i-1]==\\'C\\'){\\n       sum+=900;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=1000;\\n   }\\n   else if(s[i]==\\'D\\'){\\n       if( s[i-1]==\\'C\\'){\\n        sum+=400;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=500;\\n\\n   }\\n   else if(s[i]==\\'C\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=90;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=100;\\n   }\\n   else if(s[i]==\\'L\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=40;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=50;\\n   }\\n   else if(s[i]==\\'X\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=9;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=10;\\n   }\\n   else if(s[i]==\\'V\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=4;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=5;\\n   }\\n   else if(s[i]==\\'I\\'){\\n       sum+=1;\\n   }\\n       \\n\\n}\\nreturn sum;\\n\\n\\n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Whenever I try this problem, the answer is always ignoring the last index. I don\\'t know how to fix it.  May anyone help me please?"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I think it should in Hard ?\\n"
                    }
                ]
            },
            {
                "id": 1840796,
                "content": [
                    {
                        "username": "thirumalesh6775",
                        "content": "simple use replace logic\\n"
                    },
                    {
                        "username": "iamnawed",
                        "content": "I have solved this question using Unordered map ;\\n\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans;\\n        int i=s.length()-1;\\n        unordered_map<char ,int>umap;\\n\\n        umap[\\'I\\']=1;\\n        umap[\\'V\\']=5;\\n        umap[\\'X\\']=10;\\n        umap[\\'L\\']=50;\\n        umap[\\'C\\']=100;\\n        umap[\\'D\\']=500;\\n        umap[\\'M\\']=1000;\\n\\n        ans=umap[s[i]];\\n\\n        for(i;i>0;i--)\\n        {\\n            if(umap[s[i-1]]>=umap[s[i]])\\n            ans+=umap[s[i-1]];\\n\\n            else\\n            {\\n                ans-=umap[s[i-1]];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "alena-shs",
                        "content": "Couldn\\'t even read roman numbers over 49 lmao"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i dont understand why do i need to study the question while im practiceing and studing data strucure to know how to solve proplems. i feel its a wast of time "
                    },
                    {
                        "username": "constantin_md",
                        "content": "The best readability and easy to code in this case is O(n), It is also possible to do it in O(1) if creating two arrays for all roman numerals and numbers from 1 to 1000 (won\\'t work for 1001) and accessing their respective indexes. It\\'s also possible to do O(1) for first 20 roman numbers since this are the most used and then O(n) for the 21 - 1000"
                    },
                    {
                        "username": "choudhary2403",
                        "content": "PYHTON 3 solution using DICTIONARIES \\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        r_num = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        total = 0\\n        for i in range(len(s)-1):\\n            if r_num[s[i]] < r_num[s[i+1]] and i != len(s)-1:\\n                total = total - r_num[s[i]]\\n            else:\\n                total += r_num[s[i]]\\n        return total + r_num[s[len(s)-1]]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "devcomm82",
                        "content": "Rules should clarify that the six subtraction cases are the only times that roman numerals aren\\'t written from largest to smallest.  The rules instead say they are \"usually\" written this way; we can\\'t code for usually.    There are no test cases like \"VX\" and the primary solutions all assume that VX can\\'t exist, so its clear its assumed that \"VX\" isn\\'t allowed, so make it explicit when describing the format for Roman numerals."
                    },
                    {
                        "username": "anurag_ad_01",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffef8c87320 overflowed to 0x7ffef8c8731f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n\\n\\nplease tell me what i am doing  wrong here\\n\\n\\nthis is code \\n\\n int sum=0;\\n\\n    for(int i=s.size()-1;i>=0;i--){\\n\\n   if(s[i]==\\'M\\'){\\n       if(s[i-1]==\\'C\\'){\\n       sum+=900;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=1000;\\n   }\\n   else if(s[i]==\\'D\\'){\\n       if( s[i-1]==\\'C\\'){\\n        sum+=400;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=500;\\n\\n   }\\n   else if(s[i]==\\'C\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=90;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=100;\\n   }\\n   else if(s[i]==\\'L\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=40;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=50;\\n   }\\n   else if(s[i]==\\'X\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=9;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=10;\\n   }\\n   else if(s[i]==\\'V\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=4;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=5;\\n   }\\n   else if(s[i]==\\'I\\'){\\n       sum+=1;\\n   }\\n       \\n\\n}\\nreturn sum;\\n\\n\\n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Whenever I try this problem, the answer is always ignoring the last index. I don\\'t know how to fix it.  May anyone help me please?"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I think it should in Hard ?\\n"
                    }
                ]
            },
            {
                "id": 1838895,
                "content": [
                    {
                        "username": "thirumalesh6775",
                        "content": "simple use replace logic\\n"
                    },
                    {
                        "username": "iamnawed",
                        "content": "I have solved this question using Unordered map ;\\n\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans;\\n        int i=s.length()-1;\\n        unordered_map<char ,int>umap;\\n\\n        umap[\\'I\\']=1;\\n        umap[\\'V\\']=5;\\n        umap[\\'X\\']=10;\\n        umap[\\'L\\']=50;\\n        umap[\\'C\\']=100;\\n        umap[\\'D\\']=500;\\n        umap[\\'M\\']=1000;\\n\\n        ans=umap[s[i]];\\n\\n        for(i;i>0;i--)\\n        {\\n            if(umap[s[i-1]]>=umap[s[i]])\\n            ans+=umap[s[i-1]];\\n\\n            else\\n            {\\n                ans-=umap[s[i-1]];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "alena-shs",
                        "content": "Couldn\\'t even read roman numbers over 49 lmao"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i dont understand why do i need to study the question while im practiceing and studing data strucure to know how to solve proplems. i feel its a wast of time "
                    },
                    {
                        "username": "constantin_md",
                        "content": "The best readability and easy to code in this case is O(n), It is also possible to do it in O(1) if creating two arrays for all roman numerals and numbers from 1 to 1000 (won\\'t work for 1001) and accessing their respective indexes. It\\'s also possible to do O(1) for first 20 roman numbers since this are the most used and then O(n) for the 21 - 1000"
                    },
                    {
                        "username": "choudhary2403",
                        "content": "PYHTON 3 solution using DICTIONARIES \\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        r_num = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        total = 0\\n        for i in range(len(s)-1):\\n            if r_num[s[i]] < r_num[s[i+1]] and i != len(s)-1:\\n                total = total - r_num[s[i]]\\n            else:\\n                total += r_num[s[i]]\\n        return total + r_num[s[len(s)-1]]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "devcomm82",
                        "content": "Rules should clarify that the six subtraction cases are the only times that roman numerals aren\\'t written from largest to smallest.  The rules instead say they are \"usually\" written this way; we can\\'t code for usually.    There are no test cases like \"VX\" and the primary solutions all assume that VX can\\'t exist, so its clear its assumed that \"VX\" isn\\'t allowed, so make it explicit when describing the format for Roman numerals."
                    },
                    {
                        "username": "anurag_ad_01",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffef8c87320 overflowed to 0x7ffef8c8731f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n\\n\\nplease tell me what i am doing  wrong here\\n\\n\\nthis is code \\n\\n int sum=0;\\n\\n    for(int i=s.size()-1;i>=0;i--){\\n\\n   if(s[i]==\\'M\\'){\\n       if(s[i-1]==\\'C\\'){\\n       sum+=900;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=1000;\\n   }\\n   else if(s[i]==\\'D\\'){\\n       if( s[i-1]==\\'C\\'){\\n        sum+=400;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=500;\\n\\n   }\\n   else if(s[i]==\\'C\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=90;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=100;\\n   }\\n   else if(s[i]==\\'L\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=40;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=50;\\n   }\\n   else if(s[i]==\\'X\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=9;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=10;\\n   }\\n   else if(s[i]==\\'V\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=4;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=5;\\n   }\\n   else if(s[i]==\\'I\\'){\\n       sum+=1;\\n   }\\n       \\n\\n}\\nreturn sum;\\n\\n\\n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Whenever I try this problem, the answer is always ignoring the last index. I don\\'t know how to fix it.  May anyone help me please?"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I think it should in Hard ?\\n"
                    }
                ]
            },
            {
                "id": 1835371,
                "content": [
                    {
                        "username": "thirumalesh6775",
                        "content": "simple use replace logic\\n"
                    },
                    {
                        "username": "iamnawed",
                        "content": "I have solved this question using Unordered map ;\\n\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans;\\n        int i=s.length()-1;\\n        unordered_map<char ,int>umap;\\n\\n        umap[\\'I\\']=1;\\n        umap[\\'V\\']=5;\\n        umap[\\'X\\']=10;\\n        umap[\\'L\\']=50;\\n        umap[\\'C\\']=100;\\n        umap[\\'D\\']=500;\\n        umap[\\'M\\']=1000;\\n\\n        ans=umap[s[i]];\\n\\n        for(i;i>0;i--)\\n        {\\n            if(umap[s[i-1]]>=umap[s[i]])\\n            ans+=umap[s[i-1]];\\n\\n            else\\n            {\\n                ans-=umap[s[i-1]];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "alena-shs",
                        "content": "Couldn\\'t even read roman numbers over 49 lmao"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i dont understand why do i need to study the question while im practiceing and studing data strucure to know how to solve proplems. i feel its a wast of time "
                    },
                    {
                        "username": "constantin_md",
                        "content": "The best readability and easy to code in this case is O(n), It is also possible to do it in O(1) if creating two arrays for all roman numerals and numbers from 1 to 1000 (won\\'t work for 1001) and accessing their respective indexes. It\\'s also possible to do O(1) for first 20 roman numbers since this are the most used and then O(n) for the 21 - 1000"
                    },
                    {
                        "username": "choudhary2403",
                        "content": "PYHTON 3 solution using DICTIONARIES \\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        r_num = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        total = 0\\n        for i in range(len(s)-1):\\n            if r_num[s[i]] < r_num[s[i+1]] and i != len(s)-1:\\n                total = total - r_num[s[i]]\\n            else:\\n                total += r_num[s[i]]\\n        return total + r_num[s[len(s)-1]]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "devcomm82",
                        "content": "Rules should clarify that the six subtraction cases are the only times that roman numerals aren\\'t written from largest to smallest.  The rules instead say they are \"usually\" written this way; we can\\'t code for usually.    There are no test cases like \"VX\" and the primary solutions all assume that VX can\\'t exist, so its clear its assumed that \"VX\" isn\\'t allowed, so make it explicit when describing the format for Roman numerals."
                    },
                    {
                        "username": "anurag_ad_01",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffef8c87320 overflowed to 0x7ffef8c8731f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n\\n\\nplease tell me what i am doing  wrong here\\n\\n\\nthis is code \\n\\n int sum=0;\\n\\n    for(int i=s.size()-1;i>=0;i--){\\n\\n   if(s[i]==\\'M\\'){\\n       if(s[i-1]==\\'C\\'){\\n       sum+=900;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=1000;\\n   }\\n   else if(s[i]==\\'D\\'){\\n       if( s[i-1]==\\'C\\'){\\n        sum+=400;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=500;\\n\\n   }\\n   else if(s[i]==\\'C\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=90;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=100;\\n   }\\n   else if(s[i]==\\'L\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=40;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=50;\\n   }\\n   else if(s[i]==\\'X\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=9;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=10;\\n   }\\n   else if(s[i]==\\'V\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=4;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=5;\\n   }\\n   else if(s[i]==\\'I\\'){\\n       sum+=1;\\n   }\\n       \\n\\n}\\nreturn sum;\\n\\n\\n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Whenever I try this problem, the answer is always ignoring the last index. I don\\'t know how to fix it.  May anyone help me please?"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I think it should in Hard ?\\n"
                    }
                ]
            },
            {
                "id": 1818740,
                "content": [
                    {
                        "username": "thirumalesh6775",
                        "content": "simple use replace logic\\n"
                    },
                    {
                        "username": "iamnawed",
                        "content": "I have solved this question using Unordered map ;\\n\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans;\\n        int i=s.length()-1;\\n        unordered_map<char ,int>umap;\\n\\n        umap[\\'I\\']=1;\\n        umap[\\'V\\']=5;\\n        umap[\\'X\\']=10;\\n        umap[\\'L\\']=50;\\n        umap[\\'C\\']=100;\\n        umap[\\'D\\']=500;\\n        umap[\\'M\\']=1000;\\n\\n        ans=umap[s[i]];\\n\\n        for(i;i>0;i--)\\n        {\\n            if(umap[s[i-1]]>=umap[s[i]])\\n            ans+=umap[s[i-1]];\\n\\n            else\\n            {\\n                ans-=umap[s[i-1]];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "alena-shs",
                        "content": "Couldn\\'t even read roman numbers over 49 lmao"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i dont understand why do i need to study the question while im practiceing and studing data strucure to know how to solve proplems. i feel its a wast of time "
                    },
                    {
                        "username": "constantin_md",
                        "content": "The best readability and easy to code in this case is O(n), It is also possible to do it in O(1) if creating two arrays for all roman numerals and numbers from 1 to 1000 (won\\'t work for 1001) and accessing their respective indexes. It\\'s also possible to do O(1) for first 20 roman numbers since this are the most used and then O(n) for the 21 - 1000"
                    },
                    {
                        "username": "choudhary2403",
                        "content": "PYHTON 3 solution using DICTIONARIES \\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        r_num = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        total = 0\\n        for i in range(len(s)-1):\\n            if r_num[s[i]] < r_num[s[i+1]] and i != len(s)-1:\\n                total = total - r_num[s[i]]\\n            else:\\n                total += r_num[s[i]]\\n        return total + r_num[s[len(s)-1]]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "devcomm82",
                        "content": "Rules should clarify that the six subtraction cases are the only times that roman numerals aren\\'t written from largest to smallest.  The rules instead say they are \"usually\" written this way; we can\\'t code for usually.    There are no test cases like \"VX\" and the primary solutions all assume that VX can\\'t exist, so its clear its assumed that \"VX\" isn\\'t allowed, so make it explicit when describing the format for Roman numerals."
                    },
                    {
                        "username": "anurag_ad_01",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffef8c87320 overflowed to 0x7ffef8c8731f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n\\n\\nplease tell me what i am doing  wrong here\\n\\n\\nthis is code \\n\\n int sum=0;\\n\\n    for(int i=s.size()-1;i>=0;i--){\\n\\n   if(s[i]==\\'M\\'){\\n       if(s[i-1]==\\'C\\'){\\n       sum+=900;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=1000;\\n   }\\n   else if(s[i]==\\'D\\'){\\n       if( s[i-1]==\\'C\\'){\\n        sum+=400;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=500;\\n\\n   }\\n   else if(s[i]==\\'C\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=90;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=100;\\n   }\\n   else if(s[i]==\\'L\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=40;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=50;\\n   }\\n   else if(s[i]==\\'X\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=9;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=10;\\n   }\\n   else if(s[i]==\\'V\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=4;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=5;\\n   }\\n   else if(s[i]==\\'I\\'){\\n       sum+=1;\\n   }\\n       \\n\\n}\\nreturn sum;\\n\\n\\n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Whenever I try this problem, the answer is always ignoring the last index. I don\\'t know how to fix it.  May anyone help me please?"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I think it should in Hard ?\\n"
                    }
                ]
            },
            {
                "id": 1818544,
                "content": [
                    {
                        "username": "thirumalesh6775",
                        "content": "simple use replace logic\\n"
                    },
                    {
                        "username": "iamnawed",
                        "content": "I have solved this question using Unordered map ;\\n\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans;\\n        int i=s.length()-1;\\n        unordered_map<char ,int>umap;\\n\\n        umap[\\'I\\']=1;\\n        umap[\\'V\\']=5;\\n        umap[\\'X\\']=10;\\n        umap[\\'L\\']=50;\\n        umap[\\'C\\']=100;\\n        umap[\\'D\\']=500;\\n        umap[\\'M\\']=1000;\\n\\n        ans=umap[s[i]];\\n\\n        for(i;i>0;i--)\\n        {\\n            if(umap[s[i-1]]>=umap[s[i]])\\n            ans+=umap[s[i-1]];\\n\\n            else\\n            {\\n                ans-=umap[s[i-1]];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "alena-shs",
                        "content": "Couldn\\'t even read roman numbers over 49 lmao"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i dont understand why do i need to study the question while im practiceing and studing data strucure to know how to solve proplems. i feel its a wast of time "
                    },
                    {
                        "username": "constantin_md",
                        "content": "The best readability and easy to code in this case is O(n), It is also possible to do it in O(1) if creating two arrays for all roman numerals and numbers from 1 to 1000 (won\\'t work for 1001) and accessing their respective indexes. It\\'s also possible to do O(1) for first 20 roman numbers since this are the most used and then O(n) for the 21 - 1000"
                    },
                    {
                        "username": "choudhary2403",
                        "content": "PYHTON 3 solution using DICTIONARIES \\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        r_num = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        total = 0\\n        for i in range(len(s)-1):\\n            if r_num[s[i]] < r_num[s[i+1]] and i != len(s)-1:\\n                total = total - r_num[s[i]]\\n            else:\\n                total += r_num[s[i]]\\n        return total + r_num[s[len(s)-1]]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "devcomm82",
                        "content": "Rules should clarify that the six subtraction cases are the only times that roman numerals aren\\'t written from largest to smallest.  The rules instead say they are \"usually\" written this way; we can\\'t code for usually.    There are no test cases like \"VX\" and the primary solutions all assume that VX can\\'t exist, so its clear its assumed that \"VX\" isn\\'t allowed, so make it explicit when describing the format for Roman numerals."
                    },
                    {
                        "username": "anurag_ad_01",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffef8c87320 overflowed to 0x7ffef8c8731f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n\\n\\nplease tell me what i am doing  wrong here\\n\\n\\nthis is code \\n\\n int sum=0;\\n\\n    for(int i=s.size()-1;i>=0;i--){\\n\\n   if(s[i]==\\'M\\'){\\n       if(s[i-1]==\\'C\\'){\\n       sum+=900;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=1000;\\n   }\\n   else if(s[i]==\\'D\\'){\\n       if( s[i-1]==\\'C\\'){\\n        sum+=400;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=500;\\n\\n   }\\n   else if(s[i]==\\'C\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=90;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=100;\\n   }\\n   else if(s[i]==\\'L\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=40;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=50;\\n   }\\n   else if(s[i]==\\'X\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=9;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=10;\\n   }\\n   else if(s[i]==\\'V\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=4;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=5;\\n   }\\n   else if(s[i]==\\'I\\'){\\n       sum+=1;\\n   }\\n       \\n\\n}\\nreturn sum;\\n\\n\\n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Whenever I try this problem, the answer is always ignoring the last index. I don\\'t know how to fix it.  May anyone help me please?"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I think it should in Hard ?\\n"
                    }
                ]
            },
            {
                "id": 1816645,
                "content": [
                    {
                        "username": "thirumalesh6775",
                        "content": "simple use replace logic\\n"
                    },
                    {
                        "username": "iamnawed",
                        "content": "I have solved this question using Unordered map ;\\n\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans;\\n        int i=s.length()-1;\\n        unordered_map<char ,int>umap;\\n\\n        umap[\\'I\\']=1;\\n        umap[\\'V\\']=5;\\n        umap[\\'X\\']=10;\\n        umap[\\'L\\']=50;\\n        umap[\\'C\\']=100;\\n        umap[\\'D\\']=500;\\n        umap[\\'M\\']=1000;\\n\\n        ans=umap[s[i]];\\n\\n        for(i;i>0;i--)\\n        {\\n            if(umap[s[i-1]]>=umap[s[i]])\\n            ans+=umap[s[i-1]];\\n\\n            else\\n            {\\n                ans-=umap[s[i-1]];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "alena-shs",
                        "content": "Couldn\\'t even read roman numbers over 49 lmao"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i dont understand why do i need to study the question while im practiceing and studing data strucure to know how to solve proplems. i feel its a wast of time "
                    },
                    {
                        "username": "constantin_md",
                        "content": "The best readability and easy to code in this case is O(n), It is also possible to do it in O(1) if creating two arrays for all roman numerals and numbers from 1 to 1000 (won\\'t work for 1001) and accessing their respective indexes. It\\'s also possible to do O(1) for first 20 roman numbers since this are the most used and then O(n) for the 21 - 1000"
                    },
                    {
                        "username": "choudhary2403",
                        "content": "PYHTON 3 solution using DICTIONARIES \\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        r_num = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        total = 0\\n        for i in range(len(s)-1):\\n            if r_num[s[i]] < r_num[s[i+1]] and i != len(s)-1:\\n                total = total - r_num[s[i]]\\n            else:\\n                total += r_num[s[i]]\\n        return total + r_num[s[len(s)-1]]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "devcomm82",
                        "content": "Rules should clarify that the six subtraction cases are the only times that roman numerals aren\\'t written from largest to smallest.  The rules instead say they are \"usually\" written this way; we can\\'t code for usually.    There are no test cases like \"VX\" and the primary solutions all assume that VX can\\'t exist, so its clear its assumed that \"VX\" isn\\'t allowed, so make it explicit when describing the format for Roman numerals."
                    },
                    {
                        "username": "anurag_ad_01",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffef8c87320 overflowed to 0x7ffef8c8731f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n\\n\\nplease tell me what i am doing  wrong here\\n\\n\\nthis is code \\n\\n int sum=0;\\n\\n    for(int i=s.size()-1;i>=0;i--){\\n\\n   if(s[i]==\\'M\\'){\\n       if(s[i-1]==\\'C\\'){\\n       sum+=900;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=1000;\\n   }\\n   else if(s[i]==\\'D\\'){\\n       if( s[i-1]==\\'C\\'){\\n        sum+=400;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=500;\\n\\n   }\\n   else if(s[i]==\\'C\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=90;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=100;\\n   }\\n   else if(s[i]==\\'L\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=40;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=50;\\n   }\\n   else if(s[i]==\\'X\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=9;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=10;\\n   }\\n   else if(s[i]==\\'V\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=4;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=5;\\n   }\\n   else if(s[i]==\\'I\\'){\\n       sum+=1;\\n   }\\n       \\n\\n}\\nreturn sum;\\n\\n\\n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Whenever I try this problem, the answer is always ignoring the last index. I don\\'t know how to fix it.  May anyone help me please?"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I think it should in Hard ?\\n"
                    }
                ]
            },
            {
                "id": 1811879,
                "content": [
                    {
                        "username": "thirumalesh6775",
                        "content": "simple use replace logic\\n"
                    },
                    {
                        "username": "iamnawed",
                        "content": "I have solved this question using Unordered map ;\\n\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans;\\n        int i=s.length()-1;\\n        unordered_map<char ,int>umap;\\n\\n        umap[\\'I\\']=1;\\n        umap[\\'V\\']=5;\\n        umap[\\'X\\']=10;\\n        umap[\\'L\\']=50;\\n        umap[\\'C\\']=100;\\n        umap[\\'D\\']=500;\\n        umap[\\'M\\']=1000;\\n\\n        ans=umap[s[i]];\\n\\n        for(i;i>0;i--)\\n        {\\n            if(umap[s[i-1]]>=umap[s[i]])\\n            ans+=umap[s[i-1]];\\n\\n            else\\n            {\\n                ans-=umap[s[i-1]];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "alena-shs",
                        "content": "Couldn\\'t even read roman numbers over 49 lmao"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i dont understand why do i need to study the question while im practiceing and studing data strucure to know how to solve proplems. i feel its a wast of time "
                    },
                    {
                        "username": "constantin_md",
                        "content": "The best readability and easy to code in this case is O(n), It is also possible to do it in O(1) if creating two arrays for all roman numerals and numbers from 1 to 1000 (won\\'t work for 1001) and accessing their respective indexes. It\\'s also possible to do O(1) for first 20 roman numbers since this are the most used and then O(n) for the 21 - 1000"
                    },
                    {
                        "username": "choudhary2403",
                        "content": "PYHTON 3 solution using DICTIONARIES \\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        r_num = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        total = 0\\n        for i in range(len(s)-1):\\n            if r_num[s[i]] < r_num[s[i+1]] and i != len(s)-1:\\n                total = total - r_num[s[i]]\\n            else:\\n                total += r_num[s[i]]\\n        return total + r_num[s[len(s)-1]]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "devcomm82",
                        "content": "Rules should clarify that the six subtraction cases are the only times that roman numerals aren\\'t written from largest to smallest.  The rules instead say they are \"usually\" written this way; we can\\'t code for usually.    There are no test cases like \"VX\" and the primary solutions all assume that VX can\\'t exist, so its clear its assumed that \"VX\" isn\\'t allowed, so make it explicit when describing the format for Roman numerals."
                    },
                    {
                        "username": "anurag_ad_01",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffef8c87320 overflowed to 0x7ffef8c8731f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n\\n\\nplease tell me what i am doing  wrong here\\n\\n\\nthis is code \\n\\n int sum=0;\\n\\n    for(int i=s.size()-1;i>=0;i--){\\n\\n   if(s[i]==\\'M\\'){\\n       if(s[i-1]==\\'C\\'){\\n       sum+=900;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=1000;\\n   }\\n   else if(s[i]==\\'D\\'){\\n       if( s[i-1]==\\'C\\'){\\n        sum+=400;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=500;\\n\\n   }\\n   else if(s[i]==\\'C\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=90;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=100;\\n   }\\n   else if(s[i]==\\'L\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=40;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=50;\\n   }\\n   else if(s[i]==\\'X\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=9;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=10;\\n   }\\n   else if(s[i]==\\'V\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=4;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=5;\\n   }\\n   else if(s[i]==\\'I\\'){\\n       sum+=1;\\n   }\\n       \\n\\n}\\nreturn sum;\\n\\n\\n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Whenever I try this problem, the answer is always ignoring the last index. I don\\'t know how to fix it.  May anyone help me please?"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I think it should in Hard ?\\n"
                    }
                ]
            },
            {
                "id": 1811689,
                "content": [
                    {
                        "username": "thirumalesh6775",
                        "content": "simple use replace logic\\n"
                    },
                    {
                        "username": "iamnawed",
                        "content": "I have solved this question using Unordered map ;\\n\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans;\\n        int i=s.length()-1;\\n        unordered_map<char ,int>umap;\\n\\n        umap[\\'I\\']=1;\\n        umap[\\'V\\']=5;\\n        umap[\\'X\\']=10;\\n        umap[\\'L\\']=50;\\n        umap[\\'C\\']=100;\\n        umap[\\'D\\']=500;\\n        umap[\\'M\\']=1000;\\n\\n        ans=umap[s[i]];\\n\\n        for(i;i>0;i--)\\n        {\\n            if(umap[s[i-1]]>=umap[s[i]])\\n            ans+=umap[s[i-1]];\\n\\n            else\\n            {\\n                ans-=umap[s[i-1]];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "alena-shs",
                        "content": "Couldn\\'t even read roman numbers over 49 lmao"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i dont understand why do i need to study the question while im practiceing and studing data strucure to know how to solve proplems. i feel its a wast of time "
                    },
                    {
                        "username": "constantin_md",
                        "content": "The best readability and easy to code in this case is O(n), It is also possible to do it in O(1) if creating two arrays for all roman numerals and numbers from 1 to 1000 (won\\'t work for 1001) and accessing their respective indexes. It\\'s also possible to do O(1) for first 20 roman numbers since this are the most used and then O(n) for the 21 - 1000"
                    },
                    {
                        "username": "choudhary2403",
                        "content": "PYHTON 3 solution using DICTIONARIES \\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        r_num = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        total = 0\\n        for i in range(len(s)-1):\\n            if r_num[s[i]] < r_num[s[i+1]] and i != len(s)-1:\\n                total = total - r_num[s[i]]\\n            else:\\n                total += r_num[s[i]]\\n        return total + r_num[s[len(s)-1]]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "devcomm82",
                        "content": "Rules should clarify that the six subtraction cases are the only times that roman numerals aren\\'t written from largest to smallest.  The rules instead say they are \"usually\" written this way; we can\\'t code for usually.    There are no test cases like \"VX\" and the primary solutions all assume that VX can\\'t exist, so its clear its assumed that \"VX\" isn\\'t allowed, so make it explicit when describing the format for Roman numerals."
                    },
                    {
                        "username": "anurag_ad_01",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffef8c87320 overflowed to 0x7ffef8c8731f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n\\n\\nplease tell me what i am doing  wrong here\\n\\n\\nthis is code \\n\\n int sum=0;\\n\\n    for(int i=s.size()-1;i>=0;i--){\\n\\n   if(s[i]==\\'M\\'){\\n       if(s[i-1]==\\'C\\'){\\n       sum+=900;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=1000;\\n   }\\n   else if(s[i]==\\'D\\'){\\n       if( s[i-1]==\\'C\\'){\\n        sum+=400;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=500;\\n\\n   }\\n   else if(s[i]==\\'C\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=90;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=100;\\n   }\\n   else if(s[i]==\\'L\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=40;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=50;\\n   }\\n   else if(s[i]==\\'X\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=9;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=10;\\n   }\\n   else if(s[i]==\\'V\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=4;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=5;\\n   }\\n   else if(s[i]==\\'I\\'){\\n       sum+=1;\\n   }\\n       \\n\\n}\\nreturn sum;\\n\\n\\n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Whenever I try this problem, the answer is always ignoring the last index. I don\\'t know how to fix it.  May anyone help me please?"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I think it should in Hard ?\\n"
                    }
                ]
            },
            {
                "id": 1808407,
                "content": [
                    {
                        "username": "thirumalesh6775",
                        "content": "simple use replace logic\\n"
                    },
                    {
                        "username": "iamnawed",
                        "content": "I have solved this question using Unordered map ;\\n\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int ans;\\n        int i=s.length()-1;\\n        unordered_map<char ,int>umap;\\n\\n        umap[\\'I\\']=1;\\n        umap[\\'V\\']=5;\\n        umap[\\'X\\']=10;\\n        umap[\\'L\\']=50;\\n        umap[\\'C\\']=100;\\n        umap[\\'D\\']=500;\\n        umap[\\'M\\']=1000;\\n\\n        ans=umap[s[i]];\\n\\n        for(i;i>0;i--)\\n        {\\n            if(umap[s[i-1]]>=umap[s[i]])\\n            ans+=umap[s[i-1]];\\n\\n            else\\n            {\\n                ans-=umap[s[i-1]];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "alena-shs",
                        "content": "Couldn\\'t even read roman numbers over 49 lmao"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "i dont understand why do i need to study the question while im practiceing and studing data strucure to know how to solve proplems. i feel its a wast of time "
                    },
                    {
                        "username": "constantin_md",
                        "content": "The best readability and easy to code in this case is O(n), It is also possible to do it in O(1) if creating two arrays for all roman numerals and numbers from 1 to 1000 (won\\'t work for 1001) and accessing their respective indexes. It\\'s also possible to do O(1) for first 20 roman numbers since this are the most used and then O(n) for the 21 - 1000"
                    },
                    {
                        "username": "choudhary2403",
                        "content": "PYHTON 3 solution using DICTIONARIES \\nclass Solution:\\n    def romanToInt(self, s: str) -> int:\\n        r_num = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\\n        total = 0\\n        for i in range(len(s)-1):\\n            if r_num[s[i]] < r_num[s[i+1]] and i != len(s)-1:\\n                total = total - r_num[s[i]]\\n            else:\\n                total += r_num[s[i]]\\n        return total + r_num[s[len(s)-1]]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "devcomm82",
                        "content": "Rules should clarify that the six subtraction cases are the only times that roman numerals aren\\'t written from largest to smallest.  The rules instead say they are \"usually\" written this way; we can\\'t code for usually.    There are no test cases like \"VX\" and the primary solutions all assume that VX can\\'t exist, so its clear its assumed that \"VX\" isn\\'t allowed, so make it explicit when describing the format for Roman numerals."
                    },
                    {
                        "username": "anurag_ad_01",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffef8c87320 overflowed to 0x7ffef8c8731f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n\\n\\nplease tell me what i am doing  wrong here\\n\\n\\nthis is code \\n\\n int sum=0;\\n\\n    for(int i=s.size()-1;i>=0;i--){\\n\\n   if(s[i]==\\'M\\'){\\n       if(s[i-1]==\\'C\\'){\\n       sum+=900;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=1000;\\n   }\\n   else if(s[i]==\\'D\\'){\\n       if( s[i-1]==\\'C\\'){\\n        sum+=400;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=500;\\n\\n   }\\n   else if(s[i]==\\'C\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=90;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=100;\\n   }\\n   else if(s[i]==\\'L\\'){\\n       if(s[i-1]==\\'X\\'){\\n        sum+=40;\\n        i--;\\n       }\\n       \\n       else \\n       sum+=50;\\n   }\\n   else if(s[i]==\\'X\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=9;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=10;\\n   }\\n   else if(s[i]==\\'V\\'){\\n       if(s[i-1]==\\'I\\'){\\n       sum+=4;\\n       i--;\\n       }\\n       \\n       else \\n       sum+=5;\\n   }\\n   else if(s[i]==\\'I\\'){\\n       sum+=1;\\n   }\\n       \\n\\n}\\nreturn sum;\\n\\n\\n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Whenever I try this problem, the answer is always ignoring the last index. I don\\'t know how to fix it.  May anyone help me please?"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I think it should in Hard ?\\n"
                    }
                ]
            },
            {
                "id": 1808086,
                "content": [
                    {
                        "username": "mohitgarg85",
                        "content": "Use HashMap to store the roman Integers values.\\n\\n"
                    },
                    {
                        "username": "SuperSeb",
                        "content": "In the skeleton provided (python), I read in comment: :type s: str\\nYet this line crashes: assert isinstance(s, str)"
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "I don\\'t understand why this problem is important, there is nothing logic init. all you need to do some remember stuffs.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leave coding, there is no logic in it :)"
                    },
                    {
                        "username": "varunkumarc0508",
                        "content": "Is there any other login to find the value of \\'IV\\' instead of subtracting 2 from \\'VI\\'?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Tell me please\\nWhat algorithm can i use?"
                    },
                    {
                        "username": "kunall31meena",
                        "content": "i am new learner and learning c++ and i am unable to solve this question. anyone help me?"
                    },
                    {
                        "username": "kingbee1",
                        "content": "very soon, it will make sense to you and you will be able to attempt some. "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//most efficient solution\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int counti=0,countv=0,countx=0,countl=0,countc=0,countd=0,countm=0,civ=0,cix=0,cxl=0,cxc=0,ccd=0,ccm=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'I\\'&&s[i+1]==\\'X\\'){\\n                cix++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'&&s[i+1]==\\'V\\'){\\n                civ++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'){\\n                counti++;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                countv++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'L\\'){\\n                cxl++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'C\\'){\\n                cxc++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'){\\n                countx++;\\n            }\\n            else if(s[i]==\\'L\\'){\\n                countl++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                ccd++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'M\\'){\\n                ccm++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'){\\n                countc++; \\n            }\\n            else if(s[i]==\\'D\\'){\\n                countd++;\\n            }\\n            else{\\n                countm++;\\n            }\\n        }\\n        int ans=1*counti+5*countv+10*countx+50*countl+100*countc+500*countd+1000*countm+4*civ+9*cix+40*cxl+90*cxc+400*ccd+900*ccm;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Shriyansh_Shukla",
                        "content": "Why I am getting runtime error while submitting the code ??\\n\\nint romanToInt(char * s){\\n    int n = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n        if (s[i]==\\'M\\')\\n        {\\n            n += 1000; \\n        }\\n        else if (s[i]==\\'D\\')\\n        {\\n            n += 500;\\n        }\\n        else if (s[i]==\\'C\\')\\n        {\\n            n += 100;\\n        } \\n        else if (s[i]==\\'L\\')\\n        {\\n            n += 50;\\n        }\\n        else if (s[i]==\\'X\\')\\n        {\\n            n += 10; \\n        }\\n        else if (s[i]==\\'V\\')\\n        {\\n            n += 5;\\n        }\\n        else if (s[i]==\\'I\\')\\n        {\\n            n += 1;\\n        }  \\n        if (s[i]==\\'I\\' && s[i+1]==\\'V\\' || s[i]==\\'I\\' && s[i+1]==\\'X\\')\\n        {\\n            n -= 2;\\n        }\\n        if (s[i]==\\'X\\' && s[i+1]==\\'L\\' || s[i]==\\'X\\' && s[i+1]==\\'C\\')\\n        {\\n            n -= 20;\\n        }\\n        if (s[i]==\\'C\\' && s[i+1]==\\'D\\' || s[i]==\\'C\\' && s[i+1]==\\'M\\')\\n        {\\n            n -= 200;\\n        }\\n    }\\n    return n;\\n}"
                    },
                    {
                        "username": "hiteshcoder0",
                        "content": "code: \\n```\\nclass Solution\\n{\\npublic:\\n    int romanToInt(string s)\\n    {\\n        int ans = 0;\\n\\n        map<char, int> roman;\\n\\n        roman[\\'I\\'] = 1;\\n        roman[\\'V\\'] = 5;\\n        roman[\\'X\\'] = 10;\\n        roman[\\'L\\'] = 50;\\n        roman[\\'C\\'] = 100;\\n        roman[\\'D\\'] = 500;\\n        roman[\\'M\\'] = 1000;\\n\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n\\n            ans += roman[s[i]];\\n            if (roman[s[i]] > roman[s[i - 1]])\\n            {\\n                ans -= roman[s[i - 1]] * 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n\\n# I am getting this error\\n\\n##Runtime Error\\n```\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff2d67d6a0 overflowed to 0x7fff2d67d69f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n```"
                    },
                    {
                        "username": "user7769x",
                        "content": "int romanToInt(char * s){\\n    int ans = 0;\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++)\\n    {\\n        if (s[i] == \\'I\\')\\n            ans += 1;\\n        else if (s[i] == \\'V\\') \\n            ans += 5;\\n        else if (s[i] == \\'X\\') \\n            ans += 10;\\n        else if (s[i] == \\'L\\') \\n            ans += 50;\\n        else if (s[i] == \\'C\\') \\n            ans += 100;\\n        else if (s[i] == \\'V\\') \\n            ans += 500;\\n        else if (s[i] == \\'M\\')\\n            ans += 1000;\\n        else\\n        {\\n\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1791078,
                "content": [
                    {
                        "username": "mohitgarg85",
                        "content": "Use HashMap to store the roman Integers values.\\n\\n"
                    },
                    {
                        "username": "SuperSeb",
                        "content": "In the skeleton provided (python), I read in comment: :type s: str\\nYet this line crashes: assert isinstance(s, str)"
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "I don\\'t understand why this problem is important, there is nothing logic init. all you need to do some remember stuffs.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leave coding, there is no logic in it :)"
                    },
                    {
                        "username": "varunkumarc0508",
                        "content": "Is there any other login to find the value of \\'IV\\' instead of subtracting 2 from \\'VI\\'?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Tell me please\\nWhat algorithm can i use?"
                    },
                    {
                        "username": "kunall31meena",
                        "content": "i am new learner and learning c++ and i am unable to solve this question. anyone help me?"
                    },
                    {
                        "username": "kingbee1",
                        "content": "very soon, it will make sense to you and you will be able to attempt some. "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//most efficient solution\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int counti=0,countv=0,countx=0,countl=0,countc=0,countd=0,countm=0,civ=0,cix=0,cxl=0,cxc=0,ccd=0,ccm=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'I\\'&&s[i+1]==\\'X\\'){\\n                cix++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'&&s[i+1]==\\'V\\'){\\n                civ++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'){\\n                counti++;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                countv++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'L\\'){\\n                cxl++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'C\\'){\\n                cxc++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'){\\n                countx++;\\n            }\\n            else if(s[i]==\\'L\\'){\\n                countl++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                ccd++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'M\\'){\\n                ccm++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'){\\n                countc++; \\n            }\\n            else if(s[i]==\\'D\\'){\\n                countd++;\\n            }\\n            else{\\n                countm++;\\n            }\\n        }\\n        int ans=1*counti+5*countv+10*countx+50*countl+100*countc+500*countd+1000*countm+4*civ+9*cix+40*cxl+90*cxc+400*ccd+900*ccm;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Shriyansh_Shukla",
                        "content": "Why I am getting runtime error while submitting the code ??\\n\\nint romanToInt(char * s){\\n    int n = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n        if (s[i]==\\'M\\')\\n        {\\n            n += 1000; \\n        }\\n        else if (s[i]==\\'D\\')\\n        {\\n            n += 500;\\n        }\\n        else if (s[i]==\\'C\\')\\n        {\\n            n += 100;\\n        } \\n        else if (s[i]==\\'L\\')\\n        {\\n            n += 50;\\n        }\\n        else if (s[i]==\\'X\\')\\n        {\\n            n += 10; \\n        }\\n        else if (s[i]==\\'V\\')\\n        {\\n            n += 5;\\n        }\\n        else if (s[i]==\\'I\\')\\n        {\\n            n += 1;\\n        }  \\n        if (s[i]==\\'I\\' && s[i+1]==\\'V\\' || s[i]==\\'I\\' && s[i+1]==\\'X\\')\\n        {\\n            n -= 2;\\n        }\\n        if (s[i]==\\'X\\' && s[i+1]==\\'L\\' || s[i]==\\'X\\' && s[i+1]==\\'C\\')\\n        {\\n            n -= 20;\\n        }\\n        if (s[i]==\\'C\\' && s[i+1]==\\'D\\' || s[i]==\\'C\\' && s[i+1]==\\'M\\')\\n        {\\n            n -= 200;\\n        }\\n    }\\n    return n;\\n}"
                    },
                    {
                        "username": "hiteshcoder0",
                        "content": "code: \\n```\\nclass Solution\\n{\\npublic:\\n    int romanToInt(string s)\\n    {\\n        int ans = 0;\\n\\n        map<char, int> roman;\\n\\n        roman[\\'I\\'] = 1;\\n        roman[\\'V\\'] = 5;\\n        roman[\\'X\\'] = 10;\\n        roman[\\'L\\'] = 50;\\n        roman[\\'C\\'] = 100;\\n        roman[\\'D\\'] = 500;\\n        roman[\\'M\\'] = 1000;\\n\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n\\n            ans += roman[s[i]];\\n            if (roman[s[i]] > roman[s[i - 1]])\\n            {\\n                ans -= roman[s[i - 1]] * 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n\\n# I am getting this error\\n\\n##Runtime Error\\n```\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff2d67d6a0 overflowed to 0x7fff2d67d69f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n```"
                    },
                    {
                        "username": "user7769x",
                        "content": "int romanToInt(char * s){\\n    int ans = 0;\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++)\\n    {\\n        if (s[i] == \\'I\\')\\n            ans += 1;\\n        else if (s[i] == \\'V\\') \\n            ans += 5;\\n        else if (s[i] == \\'X\\') \\n            ans += 10;\\n        else if (s[i] == \\'L\\') \\n            ans += 50;\\n        else if (s[i] == \\'C\\') \\n            ans += 100;\\n        else if (s[i] == \\'V\\') \\n            ans += 500;\\n        else if (s[i] == \\'M\\')\\n            ans += 1000;\\n        else\\n        {\\n\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1787433,
                "content": [
                    {
                        "username": "mohitgarg85",
                        "content": "Use HashMap to store the roman Integers values.\\n\\n"
                    },
                    {
                        "username": "SuperSeb",
                        "content": "In the skeleton provided (python), I read in comment: :type s: str\\nYet this line crashes: assert isinstance(s, str)"
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "I don\\'t understand why this problem is important, there is nothing logic init. all you need to do some remember stuffs.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leave coding, there is no logic in it :)"
                    },
                    {
                        "username": "varunkumarc0508",
                        "content": "Is there any other login to find the value of \\'IV\\' instead of subtracting 2 from \\'VI\\'?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Tell me please\\nWhat algorithm can i use?"
                    },
                    {
                        "username": "kunall31meena",
                        "content": "i am new learner and learning c++ and i am unable to solve this question. anyone help me?"
                    },
                    {
                        "username": "kingbee1",
                        "content": "very soon, it will make sense to you and you will be able to attempt some. "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//most efficient solution\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int counti=0,countv=0,countx=0,countl=0,countc=0,countd=0,countm=0,civ=0,cix=0,cxl=0,cxc=0,ccd=0,ccm=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'I\\'&&s[i+1]==\\'X\\'){\\n                cix++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'&&s[i+1]==\\'V\\'){\\n                civ++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'){\\n                counti++;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                countv++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'L\\'){\\n                cxl++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'C\\'){\\n                cxc++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'){\\n                countx++;\\n            }\\n            else if(s[i]==\\'L\\'){\\n                countl++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                ccd++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'M\\'){\\n                ccm++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'){\\n                countc++; \\n            }\\n            else if(s[i]==\\'D\\'){\\n                countd++;\\n            }\\n            else{\\n                countm++;\\n            }\\n        }\\n        int ans=1*counti+5*countv+10*countx+50*countl+100*countc+500*countd+1000*countm+4*civ+9*cix+40*cxl+90*cxc+400*ccd+900*ccm;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Shriyansh_Shukla",
                        "content": "Why I am getting runtime error while submitting the code ??\\n\\nint romanToInt(char * s){\\n    int n = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n        if (s[i]==\\'M\\')\\n        {\\n            n += 1000; \\n        }\\n        else if (s[i]==\\'D\\')\\n        {\\n            n += 500;\\n        }\\n        else if (s[i]==\\'C\\')\\n        {\\n            n += 100;\\n        } \\n        else if (s[i]==\\'L\\')\\n        {\\n            n += 50;\\n        }\\n        else if (s[i]==\\'X\\')\\n        {\\n            n += 10; \\n        }\\n        else if (s[i]==\\'V\\')\\n        {\\n            n += 5;\\n        }\\n        else if (s[i]==\\'I\\')\\n        {\\n            n += 1;\\n        }  \\n        if (s[i]==\\'I\\' && s[i+1]==\\'V\\' || s[i]==\\'I\\' && s[i+1]==\\'X\\')\\n        {\\n            n -= 2;\\n        }\\n        if (s[i]==\\'X\\' && s[i+1]==\\'L\\' || s[i]==\\'X\\' && s[i+1]==\\'C\\')\\n        {\\n            n -= 20;\\n        }\\n        if (s[i]==\\'C\\' && s[i+1]==\\'D\\' || s[i]==\\'C\\' && s[i+1]==\\'M\\')\\n        {\\n            n -= 200;\\n        }\\n    }\\n    return n;\\n}"
                    },
                    {
                        "username": "hiteshcoder0",
                        "content": "code: \\n```\\nclass Solution\\n{\\npublic:\\n    int romanToInt(string s)\\n    {\\n        int ans = 0;\\n\\n        map<char, int> roman;\\n\\n        roman[\\'I\\'] = 1;\\n        roman[\\'V\\'] = 5;\\n        roman[\\'X\\'] = 10;\\n        roman[\\'L\\'] = 50;\\n        roman[\\'C\\'] = 100;\\n        roman[\\'D\\'] = 500;\\n        roman[\\'M\\'] = 1000;\\n\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n\\n            ans += roman[s[i]];\\n            if (roman[s[i]] > roman[s[i - 1]])\\n            {\\n                ans -= roman[s[i - 1]] * 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n\\n# I am getting this error\\n\\n##Runtime Error\\n```\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff2d67d6a0 overflowed to 0x7fff2d67d69f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n```"
                    },
                    {
                        "username": "user7769x",
                        "content": "int romanToInt(char * s){\\n    int ans = 0;\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++)\\n    {\\n        if (s[i] == \\'I\\')\\n            ans += 1;\\n        else if (s[i] == \\'V\\') \\n            ans += 5;\\n        else if (s[i] == \\'X\\') \\n            ans += 10;\\n        else if (s[i] == \\'L\\') \\n            ans += 50;\\n        else if (s[i] == \\'C\\') \\n            ans += 100;\\n        else if (s[i] == \\'V\\') \\n            ans += 500;\\n        else if (s[i] == \\'M\\')\\n            ans += 1000;\\n        else\\n        {\\n\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1787032,
                "content": [
                    {
                        "username": "mohitgarg85",
                        "content": "Use HashMap to store the roman Integers values.\\n\\n"
                    },
                    {
                        "username": "SuperSeb",
                        "content": "In the skeleton provided (python), I read in comment: :type s: str\\nYet this line crashes: assert isinstance(s, str)"
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "I don\\'t understand why this problem is important, there is nothing logic init. all you need to do some remember stuffs.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leave coding, there is no logic in it :)"
                    },
                    {
                        "username": "varunkumarc0508",
                        "content": "Is there any other login to find the value of \\'IV\\' instead of subtracting 2 from \\'VI\\'?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Tell me please\\nWhat algorithm can i use?"
                    },
                    {
                        "username": "kunall31meena",
                        "content": "i am new learner and learning c++ and i am unable to solve this question. anyone help me?"
                    },
                    {
                        "username": "kingbee1",
                        "content": "very soon, it will make sense to you and you will be able to attempt some. "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//most efficient solution\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int counti=0,countv=0,countx=0,countl=0,countc=0,countd=0,countm=0,civ=0,cix=0,cxl=0,cxc=0,ccd=0,ccm=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'I\\'&&s[i+1]==\\'X\\'){\\n                cix++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'&&s[i+1]==\\'V\\'){\\n                civ++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'){\\n                counti++;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                countv++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'L\\'){\\n                cxl++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'C\\'){\\n                cxc++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'){\\n                countx++;\\n            }\\n            else if(s[i]==\\'L\\'){\\n                countl++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                ccd++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'M\\'){\\n                ccm++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'){\\n                countc++; \\n            }\\n            else if(s[i]==\\'D\\'){\\n                countd++;\\n            }\\n            else{\\n                countm++;\\n            }\\n        }\\n        int ans=1*counti+5*countv+10*countx+50*countl+100*countc+500*countd+1000*countm+4*civ+9*cix+40*cxl+90*cxc+400*ccd+900*ccm;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Shriyansh_Shukla",
                        "content": "Why I am getting runtime error while submitting the code ??\\n\\nint romanToInt(char * s){\\n    int n = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n        if (s[i]==\\'M\\')\\n        {\\n            n += 1000; \\n        }\\n        else if (s[i]==\\'D\\')\\n        {\\n            n += 500;\\n        }\\n        else if (s[i]==\\'C\\')\\n        {\\n            n += 100;\\n        } \\n        else if (s[i]==\\'L\\')\\n        {\\n            n += 50;\\n        }\\n        else if (s[i]==\\'X\\')\\n        {\\n            n += 10; \\n        }\\n        else if (s[i]==\\'V\\')\\n        {\\n            n += 5;\\n        }\\n        else if (s[i]==\\'I\\')\\n        {\\n            n += 1;\\n        }  \\n        if (s[i]==\\'I\\' && s[i+1]==\\'V\\' || s[i]==\\'I\\' && s[i+1]==\\'X\\')\\n        {\\n            n -= 2;\\n        }\\n        if (s[i]==\\'X\\' && s[i+1]==\\'L\\' || s[i]==\\'X\\' && s[i+1]==\\'C\\')\\n        {\\n            n -= 20;\\n        }\\n        if (s[i]==\\'C\\' && s[i+1]==\\'D\\' || s[i]==\\'C\\' && s[i+1]==\\'M\\')\\n        {\\n            n -= 200;\\n        }\\n    }\\n    return n;\\n}"
                    },
                    {
                        "username": "hiteshcoder0",
                        "content": "code: \\n```\\nclass Solution\\n{\\npublic:\\n    int romanToInt(string s)\\n    {\\n        int ans = 0;\\n\\n        map<char, int> roman;\\n\\n        roman[\\'I\\'] = 1;\\n        roman[\\'V\\'] = 5;\\n        roman[\\'X\\'] = 10;\\n        roman[\\'L\\'] = 50;\\n        roman[\\'C\\'] = 100;\\n        roman[\\'D\\'] = 500;\\n        roman[\\'M\\'] = 1000;\\n\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n\\n            ans += roman[s[i]];\\n            if (roman[s[i]] > roman[s[i - 1]])\\n            {\\n                ans -= roman[s[i - 1]] * 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n\\n# I am getting this error\\n\\n##Runtime Error\\n```\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff2d67d6a0 overflowed to 0x7fff2d67d69f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n```"
                    },
                    {
                        "username": "user7769x",
                        "content": "int romanToInt(char * s){\\n    int ans = 0;\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++)\\n    {\\n        if (s[i] == \\'I\\')\\n            ans += 1;\\n        else if (s[i] == \\'V\\') \\n            ans += 5;\\n        else if (s[i] == \\'X\\') \\n            ans += 10;\\n        else if (s[i] == \\'L\\') \\n            ans += 50;\\n        else if (s[i] == \\'C\\') \\n            ans += 100;\\n        else if (s[i] == \\'V\\') \\n            ans += 500;\\n        else if (s[i] == \\'M\\')\\n            ans += 1000;\\n        else\\n        {\\n\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1786506,
                "content": [
                    {
                        "username": "mohitgarg85",
                        "content": "Use HashMap to store the roman Integers values.\\n\\n"
                    },
                    {
                        "username": "SuperSeb",
                        "content": "In the skeleton provided (python), I read in comment: :type s: str\\nYet this line crashes: assert isinstance(s, str)"
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "I don\\'t understand why this problem is important, there is nothing logic init. all you need to do some remember stuffs.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leave coding, there is no logic in it :)"
                    },
                    {
                        "username": "varunkumarc0508",
                        "content": "Is there any other login to find the value of \\'IV\\' instead of subtracting 2 from \\'VI\\'?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Tell me please\\nWhat algorithm can i use?"
                    },
                    {
                        "username": "kunall31meena",
                        "content": "i am new learner and learning c++ and i am unable to solve this question. anyone help me?"
                    },
                    {
                        "username": "kingbee1",
                        "content": "very soon, it will make sense to you and you will be able to attempt some. "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//most efficient solution\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int counti=0,countv=0,countx=0,countl=0,countc=0,countd=0,countm=0,civ=0,cix=0,cxl=0,cxc=0,ccd=0,ccm=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'I\\'&&s[i+1]==\\'X\\'){\\n                cix++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'&&s[i+1]==\\'V\\'){\\n                civ++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'){\\n                counti++;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                countv++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'L\\'){\\n                cxl++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'C\\'){\\n                cxc++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'){\\n                countx++;\\n            }\\n            else if(s[i]==\\'L\\'){\\n                countl++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                ccd++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'M\\'){\\n                ccm++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'){\\n                countc++; \\n            }\\n            else if(s[i]==\\'D\\'){\\n                countd++;\\n            }\\n            else{\\n                countm++;\\n            }\\n        }\\n        int ans=1*counti+5*countv+10*countx+50*countl+100*countc+500*countd+1000*countm+4*civ+9*cix+40*cxl+90*cxc+400*ccd+900*ccm;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Shriyansh_Shukla",
                        "content": "Why I am getting runtime error while submitting the code ??\\n\\nint romanToInt(char * s){\\n    int n = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n        if (s[i]==\\'M\\')\\n        {\\n            n += 1000; \\n        }\\n        else if (s[i]==\\'D\\')\\n        {\\n            n += 500;\\n        }\\n        else if (s[i]==\\'C\\')\\n        {\\n            n += 100;\\n        } \\n        else if (s[i]==\\'L\\')\\n        {\\n            n += 50;\\n        }\\n        else if (s[i]==\\'X\\')\\n        {\\n            n += 10; \\n        }\\n        else if (s[i]==\\'V\\')\\n        {\\n            n += 5;\\n        }\\n        else if (s[i]==\\'I\\')\\n        {\\n            n += 1;\\n        }  \\n        if (s[i]==\\'I\\' && s[i+1]==\\'V\\' || s[i]==\\'I\\' && s[i+1]==\\'X\\')\\n        {\\n            n -= 2;\\n        }\\n        if (s[i]==\\'X\\' && s[i+1]==\\'L\\' || s[i]==\\'X\\' && s[i+1]==\\'C\\')\\n        {\\n            n -= 20;\\n        }\\n        if (s[i]==\\'C\\' && s[i+1]==\\'D\\' || s[i]==\\'C\\' && s[i+1]==\\'M\\')\\n        {\\n            n -= 200;\\n        }\\n    }\\n    return n;\\n}"
                    },
                    {
                        "username": "hiteshcoder0",
                        "content": "code: \\n```\\nclass Solution\\n{\\npublic:\\n    int romanToInt(string s)\\n    {\\n        int ans = 0;\\n\\n        map<char, int> roman;\\n\\n        roman[\\'I\\'] = 1;\\n        roman[\\'V\\'] = 5;\\n        roman[\\'X\\'] = 10;\\n        roman[\\'L\\'] = 50;\\n        roman[\\'C\\'] = 100;\\n        roman[\\'D\\'] = 500;\\n        roman[\\'M\\'] = 1000;\\n\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n\\n            ans += roman[s[i]];\\n            if (roman[s[i]] > roman[s[i - 1]])\\n            {\\n                ans -= roman[s[i - 1]] * 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n\\n# I am getting this error\\n\\n##Runtime Error\\n```\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff2d67d6a0 overflowed to 0x7fff2d67d69f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n```"
                    },
                    {
                        "username": "user7769x",
                        "content": "int romanToInt(char * s){\\n    int ans = 0;\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++)\\n    {\\n        if (s[i] == \\'I\\')\\n            ans += 1;\\n        else if (s[i] == \\'V\\') \\n            ans += 5;\\n        else if (s[i] == \\'X\\') \\n            ans += 10;\\n        else if (s[i] == \\'L\\') \\n            ans += 50;\\n        else if (s[i] == \\'C\\') \\n            ans += 100;\\n        else if (s[i] == \\'V\\') \\n            ans += 500;\\n        else if (s[i] == \\'M\\')\\n            ans += 1000;\\n        else\\n        {\\n\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1782325,
                "content": [
                    {
                        "username": "mohitgarg85",
                        "content": "Use HashMap to store the roman Integers values.\\n\\n"
                    },
                    {
                        "username": "SuperSeb",
                        "content": "In the skeleton provided (python), I read in comment: :type s: str\\nYet this line crashes: assert isinstance(s, str)"
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "I don\\'t understand why this problem is important, there is nothing logic init. all you need to do some remember stuffs.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leave coding, there is no logic in it :)"
                    },
                    {
                        "username": "varunkumarc0508",
                        "content": "Is there any other login to find the value of \\'IV\\' instead of subtracting 2 from \\'VI\\'?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Tell me please\\nWhat algorithm can i use?"
                    },
                    {
                        "username": "kunall31meena",
                        "content": "i am new learner and learning c++ and i am unable to solve this question. anyone help me?"
                    },
                    {
                        "username": "kingbee1",
                        "content": "very soon, it will make sense to you and you will be able to attempt some. "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//most efficient solution\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int counti=0,countv=0,countx=0,countl=0,countc=0,countd=0,countm=0,civ=0,cix=0,cxl=0,cxc=0,ccd=0,ccm=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'I\\'&&s[i+1]==\\'X\\'){\\n                cix++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'&&s[i+1]==\\'V\\'){\\n                civ++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'){\\n                counti++;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                countv++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'L\\'){\\n                cxl++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'C\\'){\\n                cxc++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'){\\n                countx++;\\n            }\\n            else if(s[i]==\\'L\\'){\\n                countl++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                ccd++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'M\\'){\\n                ccm++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'){\\n                countc++; \\n            }\\n            else if(s[i]==\\'D\\'){\\n                countd++;\\n            }\\n            else{\\n                countm++;\\n            }\\n        }\\n        int ans=1*counti+5*countv+10*countx+50*countl+100*countc+500*countd+1000*countm+4*civ+9*cix+40*cxl+90*cxc+400*ccd+900*ccm;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Shriyansh_Shukla",
                        "content": "Why I am getting runtime error while submitting the code ??\\n\\nint romanToInt(char * s){\\n    int n = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n        if (s[i]==\\'M\\')\\n        {\\n            n += 1000; \\n        }\\n        else if (s[i]==\\'D\\')\\n        {\\n            n += 500;\\n        }\\n        else if (s[i]==\\'C\\')\\n        {\\n            n += 100;\\n        } \\n        else if (s[i]==\\'L\\')\\n        {\\n            n += 50;\\n        }\\n        else if (s[i]==\\'X\\')\\n        {\\n            n += 10; \\n        }\\n        else if (s[i]==\\'V\\')\\n        {\\n            n += 5;\\n        }\\n        else if (s[i]==\\'I\\')\\n        {\\n            n += 1;\\n        }  \\n        if (s[i]==\\'I\\' && s[i+1]==\\'V\\' || s[i]==\\'I\\' && s[i+1]==\\'X\\')\\n        {\\n            n -= 2;\\n        }\\n        if (s[i]==\\'X\\' && s[i+1]==\\'L\\' || s[i]==\\'X\\' && s[i+1]==\\'C\\')\\n        {\\n            n -= 20;\\n        }\\n        if (s[i]==\\'C\\' && s[i+1]==\\'D\\' || s[i]==\\'C\\' && s[i+1]==\\'M\\')\\n        {\\n            n -= 200;\\n        }\\n    }\\n    return n;\\n}"
                    },
                    {
                        "username": "hiteshcoder0",
                        "content": "code: \\n```\\nclass Solution\\n{\\npublic:\\n    int romanToInt(string s)\\n    {\\n        int ans = 0;\\n\\n        map<char, int> roman;\\n\\n        roman[\\'I\\'] = 1;\\n        roman[\\'V\\'] = 5;\\n        roman[\\'X\\'] = 10;\\n        roman[\\'L\\'] = 50;\\n        roman[\\'C\\'] = 100;\\n        roman[\\'D\\'] = 500;\\n        roman[\\'M\\'] = 1000;\\n\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n\\n            ans += roman[s[i]];\\n            if (roman[s[i]] > roman[s[i - 1]])\\n            {\\n                ans -= roman[s[i - 1]] * 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n\\n# I am getting this error\\n\\n##Runtime Error\\n```\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff2d67d6a0 overflowed to 0x7fff2d67d69f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n```"
                    },
                    {
                        "username": "user7769x",
                        "content": "int romanToInt(char * s){\\n    int ans = 0;\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++)\\n    {\\n        if (s[i] == \\'I\\')\\n            ans += 1;\\n        else if (s[i] == \\'V\\') \\n            ans += 5;\\n        else if (s[i] == \\'X\\') \\n            ans += 10;\\n        else if (s[i] == \\'L\\') \\n            ans += 50;\\n        else if (s[i] == \\'C\\') \\n            ans += 100;\\n        else if (s[i] == \\'V\\') \\n            ans += 500;\\n        else if (s[i] == \\'M\\')\\n            ans += 1000;\\n        else\\n        {\\n\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1782160,
                "content": [
                    {
                        "username": "mohitgarg85",
                        "content": "Use HashMap to store the roman Integers values.\\n\\n"
                    },
                    {
                        "username": "SuperSeb",
                        "content": "In the skeleton provided (python), I read in comment: :type s: str\\nYet this line crashes: assert isinstance(s, str)"
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "I don\\'t understand why this problem is important, there is nothing logic init. all you need to do some remember stuffs.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leave coding, there is no logic in it :)"
                    },
                    {
                        "username": "varunkumarc0508",
                        "content": "Is there any other login to find the value of \\'IV\\' instead of subtracting 2 from \\'VI\\'?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Tell me please\\nWhat algorithm can i use?"
                    },
                    {
                        "username": "kunall31meena",
                        "content": "i am new learner and learning c++ and i am unable to solve this question. anyone help me?"
                    },
                    {
                        "username": "kingbee1",
                        "content": "very soon, it will make sense to you and you will be able to attempt some. "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//most efficient solution\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int counti=0,countv=0,countx=0,countl=0,countc=0,countd=0,countm=0,civ=0,cix=0,cxl=0,cxc=0,ccd=0,ccm=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'I\\'&&s[i+1]==\\'X\\'){\\n                cix++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'&&s[i+1]==\\'V\\'){\\n                civ++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'){\\n                counti++;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                countv++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'L\\'){\\n                cxl++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'C\\'){\\n                cxc++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'){\\n                countx++;\\n            }\\n            else if(s[i]==\\'L\\'){\\n                countl++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                ccd++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'M\\'){\\n                ccm++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'){\\n                countc++; \\n            }\\n            else if(s[i]==\\'D\\'){\\n                countd++;\\n            }\\n            else{\\n                countm++;\\n            }\\n        }\\n        int ans=1*counti+5*countv+10*countx+50*countl+100*countc+500*countd+1000*countm+4*civ+9*cix+40*cxl+90*cxc+400*ccd+900*ccm;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Shriyansh_Shukla",
                        "content": "Why I am getting runtime error while submitting the code ??\\n\\nint romanToInt(char * s){\\n    int n = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n        if (s[i]==\\'M\\')\\n        {\\n            n += 1000; \\n        }\\n        else if (s[i]==\\'D\\')\\n        {\\n            n += 500;\\n        }\\n        else if (s[i]==\\'C\\')\\n        {\\n            n += 100;\\n        } \\n        else if (s[i]==\\'L\\')\\n        {\\n            n += 50;\\n        }\\n        else if (s[i]==\\'X\\')\\n        {\\n            n += 10; \\n        }\\n        else if (s[i]==\\'V\\')\\n        {\\n            n += 5;\\n        }\\n        else if (s[i]==\\'I\\')\\n        {\\n            n += 1;\\n        }  \\n        if (s[i]==\\'I\\' && s[i+1]==\\'V\\' || s[i]==\\'I\\' && s[i+1]==\\'X\\')\\n        {\\n            n -= 2;\\n        }\\n        if (s[i]==\\'X\\' && s[i+1]==\\'L\\' || s[i]==\\'X\\' && s[i+1]==\\'C\\')\\n        {\\n            n -= 20;\\n        }\\n        if (s[i]==\\'C\\' && s[i+1]==\\'D\\' || s[i]==\\'C\\' && s[i+1]==\\'M\\')\\n        {\\n            n -= 200;\\n        }\\n    }\\n    return n;\\n}"
                    },
                    {
                        "username": "hiteshcoder0",
                        "content": "code: \\n```\\nclass Solution\\n{\\npublic:\\n    int romanToInt(string s)\\n    {\\n        int ans = 0;\\n\\n        map<char, int> roman;\\n\\n        roman[\\'I\\'] = 1;\\n        roman[\\'V\\'] = 5;\\n        roman[\\'X\\'] = 10;\\n        roman[\\'L\\'] = 50;\\n        roman[\\'C\\'] = 100;\\n        roman[\\'D\\'] = 500;\\n        roman[\\'M\\'] = 1000;\\n\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n\\n            ans += roman[s[i]];\\n            if (roman[s[i]] > roman[s[i - 1]])\\n            {\\n                ans -= roman[s[i - 1]] * 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n\\n# I am getting this error\\n\\n##Runtime Error\\n```\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff2d67d6a0 overflowed to 0x7fff2d67d69f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n```"
                    },
                    {
                        "username": "user7769x",
                        "content": "int romanToInt(char * s){\\n    int ans = 0;\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++)\\n    {\\n        if (s[i] == \\'I\\')\\n            ans += 1;\\n        else if (s[i] == \\'V\\') \\n            ans += 5;\\n        else if (s[i] == \\'X\\') \\n            ans += 10;\\n        else if (s[i] == \\'L\\') \\n            ans += 50;\\n        else if (s[i] == \\'C\\') \\n            ans += 100;\\n        else if (s[i] == \\'V\\') \\n            ans += 500;\\n        else if (s[i] == \\'M\\')\\n            ans += 1000;\\n        else\\n        {\\n\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1781941,
                "content": [
                    {
                        "username": "mohitgarg85",
                        "content": "Use HashMap to store the roman Integers values.\\n\\n"
                    },
                    {
                        "username": "SuperSeb",
                        "content": "In the skeleton provided (python), I read in comment: :type s: str\\nYet this line crashes: assert isinstance(s, str)"
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "I don\\'t understand why this problem is important, there is nothing logic init. all you need to do some remember stuffs.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leave coding, there is no logic in it :)"
                    },
                    {
                        "username": "varunkumarc0508",
                        "content": "Is there any other login to find the value of \\'IV\\' instead of subtracting 2 from \\'VI\\'?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Tell me please\\nWhat algorithm can i use?"
                    },
                    {
                        "username": "kunall31meena",
                        "content": "i am new learner and learning c++ and i am unable to solve this question. anyone help me?"
                    },
                    {
                        "username": "kingbee1",
                        "content": "very soon, it will make sense to you and you will be able to attempt some. "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//most efficient solution\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int counti=0,countv=0,countx=0,countl=0,countc=0,countd=0,countm=0,civ=0,cix=0,cxl=0,cxc=0,ccd=0,ccm=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'I\\'&&s[i+1]==\\'X\\'){\\n                cix++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'&&s[i+1]==\\'V\\'){\\n                civ++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'){\\n                counti++;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                countv++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'L\\'){\\n                cxl++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'C\\'){\\n                cxc++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'){\\n                countx++;\\n            }\\n            else if(s[i]==\\'L\\'){\\n                countl++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                ccd++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'M\\'){\\n                ccm++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'){\\n                countc++; \\n            }\\n            else if(s[i]==\\'D\\'){\\n                countd++;\\n            }\\n            else{\\n                countm++;\\n            }\\n        }\\n        int ans=1*counti+5*countv+10*countx+50*countl+100*countc+500*countd+1000*countm+4*civ+9*cix+40*cxl+90*cxc+400*ccd+900*ccm;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Shriyansh_Shukla",
                        "content": "Why I am getting runtime error while submitting the code ??\\n\\nint romanToInt(char * s){\\n    int n = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n        if (s[i]==\\'M\\')\\n        {\\n            n += 1000; \\n        }\\n        else if (s[i]==\\'D\\')\\n        {\\n            n += 500;\\n        }\\n        else if (s[i]==\\'C\\')\\n        {\\n            n += 100;\\n        } \\n        else if (s[i]==\\'L\\')\\n        {\\n            n += 50;\\n        }\\n        else if (s[i]==\\'X\\')\\n        {\\n            n += 10; \\n        }\\n        else if (s[i]==\\'V\\')\\n        {\\n            n += 5;\\n        }\\n        else if (s[i]==\\'I\\')\\n        {\\n            n += 1;\\n        }  \\n        if (s[i]==\\'I\\' && s[i+1]==\\'V\\' || s[i]==\\'I\\' && s[i+1]==\\'X\\')\\n        {\\n            n -= 2;\\n        }\\n        if (s[i]==\\'X\\' && s[i+1]==\\'L\\' || s[i]==\\'X\\' && s[i+1]==\\'C\\')\\n        {\\n            n -= 20;\\n        }\\n        if (s[i]==\\'C\\' && s[i+1]==\\'D\\' || s[i]==\\'C\\' && s[i+1]==\\'M\\')\\n        {\\n            n -= 200;\\n        }\\n    }\\n    return n;\\n}"
                    },
                    {
                        "username": "hiteshcoder0",
                        "content": "code: \\n```\\nclass Solution\\n{\\npublic:\\n    int romanToInt(string s)\\n    {\\n        int ans = 0;\\n\\n        map<char, int> roman;\\n\\n        roman[\\'I\\'] = 1;\\n        roman[\\'V\\'] = 5;\\n        roman[\\'X\\'] = 10;\\n        roman[\\'L\\'] = 50;\\n        roman[\\'C\\'] = 100;\\n        roman[\\'D\\'] = 500;\\n        roman[\\'M\\'] = 1000;\\n\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n\\n            ans += roman[s[i]];\\n            if (roman[s[i]] > roman[s[i - 1]])\\n            {\\n                ans -= roman[s[i - 1]] * 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n\\n# I am getting this error\\n\\n##Runtime Error\\n```\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff2d67d6a0 overflowed to 0x7fff2d67d69f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n```"
                    },
                    {
                        "username": "user7769x",
                        "content": "int romanToInt(char * s){\\n    int ans = 0;\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++)\\n    {\\n        if (s[i] == \\'I\\')\\n            ans += 1;\\n        else if (s[i] == \\'V\\') \\n            ans += 5;\\n        else if (s[i] == \\'X\\') \\n            ans += 10;\\n        else if (s[i] == \\'L\\') \\n            ans += 50;\\n        else if (s[i] == \\'C\\') \\n            ans += 100;\\n        else if (s[i] == \\'V\\') \\n            ans += 500;\\n        else if (s[i] == \\'M\\')\\n            ans += 1000;\\n        else\\n        {\\n\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1780794,
                "content": [
                    {
                        "username": "mohitgarg85",
                        "content": "Use HashMap to store the roman Integers values.\\n\\n"
                    },
                    {
                        "username": "SuperSeb",
                        "content": "In the skeleton provided (python), I read in comment: :type s: str\\nYet this line crashes: assert isinstance(s, str)"
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "I don\\'t understand why this problem is important, there is nothing logic init. all you need to do some remember stuffs.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leave coding, there is no logic in it :)"
                    },
                    {
                        "username": "varunkumarc0508",
                        "content": "Is there any other login to find the value of \\'IV\\' instead of subtracting 2 from \\'VI\\'?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Tell me please\\nWhat algorithm can i use?"
                    },
                    {
                        "username": "kunall31meena",
                        "content": "i am new learner and learning c++ and i am unable to solve this question. anyone help me?"
                    },
                    {
                        "username": "kingbee1",
                        "content": "very soon, it will make sense to you and you will be able to attempt some. "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//most efficient solution\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int counti=0,countv=0,countx=0,countl=0,countc=0,countd=0,countm=0,civ=0,cix=0,cxl=0,cxc=0,ccd=0,ccm=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'I\\'&&s[i+1]==\\'X\\'){\\n                cix++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'&&s[i+1]==\\'V\\'){\\n                civ++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'){\\n                counti++;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                countv++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'L\\'){\\n                cxl++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'C\\'){\\n                cxc++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'){\\n                countx++;\\n            }\\n            else if(s[i]==\\'L\\'){\\n                countl++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                ccd++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'M\\'){\\n                ccm++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'){\\n                countc++; \\n            }\\n            else if(s[i]==\\'D\\'){\\n                countd++;\\n            }\\n            else{\\n                countm++;\\n            }\\n        }\\n        int ans=1*counti+5*countv+10*countx+50*countl+100*countc+500*countd+1000*countm+4*civ+9*cix+40*cxl+90*cxc+400*ccd+900*ccm;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Shriyansh_Shukla",
                        "content": "Why I am getting runtime error while submitting the code ??\\n\\nint romanToInt(char * s){\\n    int n = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n        if (s[i]==\\'M\\')\\n        {\\n            n += 1000; \\n        }\\n        else if (s[i]==\\'D\\')\\n        {\\n            n += 500;\\n        }\\n        else if (s[i]==\\'C\\')\\n        {\\n            n += 100;\\n        } \\n        else if (s[i]==\\'L\\')\\n        {\\n            n += 50;\\n        }\\n        else if (s[i]==\\'X\\')\\n        {\\n            n += 10; \\n        }\\n        else if (s[i]==\\'V\\')\\n        {\\n            n += 5;\\n        }\\n        else if (s[i]==\\'I\\')\\n        {\\n            n += 1;\\n        }  \\n        if (s[i]==\\'I\\' && s[i+1]==\\'V\\' || s[i]==\\'I\\' && s[i+1]==\\'X\\')\\n        {\\n            n -= 2;\\n        }\\n        if (s[i]==\\'X\\' && s[i+1]==\\'L\\' || s[i]==\\'X\\' && s[i+1]==\\'C\\')\\n        {\\n            n -= 20;\\n        }\\n        if (s[i]==\\'C\\' && s[i+1]==\\'D\\' || s[i]==\\'C\\' && s[i+1]==\\'M\\')\\n        {\\n            n -= 200;\\n        }\\n    }\\n    return n;\\n}"
                    },
                    {
                        "username": "hiteshcoder0",
                        "content": "code: \\n```\\nclass Solution\\n{\\npublic:\\n    int romanToInt(string s)\\n    {\\n        int ans = 0;\\n\\n        map<char, int> roman;\\n\\n        roman[\\'I\\'] = 1;\\n        roman[\\'V\\'] = 5;\\n        roman[\\'X\\'] = 10;\\n        roman[\\'L\\'] = 50;\\n        roman[\\'C\\'] = 100;\\n        roman[\\'D\\'] = 500;\\n        roman[\\'M\\'] = 1000;\\n\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n\\n            ans += roman[s[i]];\\n            if (roman[s[i]] > roman[s[i - 1]])\\n            {\\n                ans -= roman[s[i - 1]] * 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n\\n# I am getting this error\\n\\n##Runtime Error\\n```\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff2d67d6a0 overflowed to 0x7fff2d67d69f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n```"
                    },
                    {
                        "username": "user7769x",
                        "content": "int romanToInt(char * s){\\n    int ans = 0;\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++)\\n    {\\n        if (s[i] == \\'I\\')\\n            ans += 1;\\n        else if (s[i] == \\'V\\') \\n            ans += 5;\\n        else if (s[i] == \\'X\\') \\n            ans += 10;\\n        else if (s[i] == \\'L\\') \\n            ans += 50;\\n        else if (s[i] == \\'C\\') \\n            ans += 100;\\n        else if (s[i] == \\'V\\') \\n            ans += 500;\\n        else if (s[i] == \\'M\\')\\n            ans += 1000;\\n        else\\n        {\\n\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1780571,
                "content": [
                    {
                        "username": "mohitgarg85",
                        "content": "Use HashMap to store the roman Integers values.\\n\\n"
                    },
                    {
                        "username": "SuperSeb",
                        "content": "In the skeleton provided (python), I read in comment: :type s: str\\nYet this line crashes: assert isinstance(s, str)"
                    },
                    {
                        "username": "Sayon_islam_23",
                        "content": "I don\\'t understand why this problem is important, there is nothing logic init. all you need to do some remember stuffs.\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leave coding, there is no logic in it :)"
                    },
                    {
                        "username": "varunkumarc0508",
                        "content": "Is there any other login to find the value of \\'IV\\' instead of subtracting 2 from \\'VI\\'?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Tell me please\\nWhat algorithm can i use?"
                    },
                    {
                        "username": "kunall31meena",
                        "content": "i am new learner and learning c++ and i am unable to solve this question. anyone help me?"
                    },
                    {
                        "username": "kingbee1",
                        "content": "very soon, it will make sense to you and you will be able to attempt some. "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//most efficient solution\\nclass Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int counti=0,countv=0,countx=0,countl=0,countc=0,countd=0,countm=0,civ=0,cix=0,cxl=0,cxc=0,ccd=0,ccm=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'I\\'&&s[i+1]==\\'X\\'){\\n                cix++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'&&s[i+1]==\\'V\\'){\\n                civ++;\\n                i++;\\n            }\\n            else if(s[i]==\\'I\\'){\\n                counti++;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                countv++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'L\\'){\\n                cxl++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'&&s[i+1]==\\'C\\'){\\n                cxc++;\\n                i++;\\n            }\\n            else if(s[i]==\\'X\\'){\\n                countx++;\\n            }\\n            else if(s[i]==\\'L\\'){\\n                countl++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                ccd++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'&&s[i+1]==\\'M\\'){\\n                ccm++;\\n                i++;\\n            }\\n            else if(s[i]==\\'C\\'){\\n                countc++; \\n            }\\n            else if(s[i]==\\'D\\'){\\n                countd++;\\n            }\\n            else{\\n                countm++;\\n            }\\n        }\\n        int ans=1*counti+5*countv+10*countx+50*countl+100*countc+500*countd+1000*countm+4*civ+9*cix+40*cxl+90*cxc+400*ccd+900*ccm;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "Shriyansh_Shukla",
                        "content": "Why I am getting runtime error while submitting the code ??\\n\\nint romanToInt(char * s){\\n    int n = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n        if (s[i]==\\'M\\')\\n        {\\n            n += 1000; \\n        }\\n        else if (s[i]==\\'D\\')\\n        {\\n            n += 500;\\n        }\\n        else if (s[i]==\\'C\\')\\n        {\\n            n += 100;\\n        } \\n        else if (s[i]==\\'L\\')\\n        {\\n            n += 50;\\n        }\\n        else if (s[i]==\\'X\\')\\n        {\\n            n += 10; \\n        }\\n        else if (s[i]==\\'V\\')\\n        {\\n            n += 5;\\n        }\\n        else if (s[i]==\\'I\\')\\n        {\\n            n += 1;\\n        }  \\n        if (s[i]==\\'I\\' && s[i+1]==\\'V\\' || s[i]==\\'I\\' && s[i+1]==\\'X\\')\\n        {\\n            n -= 2;\\n        }\\n        if (s[i]==\\'X\\' && s[i+1]==\\'L\\' || s[i]==\\'X\\' && s[i+1]==\\'C\\')\\n        {\\n            n -= 20;\\n        }\\n        if (s[i]==\\'C\\' && s[i+1]==\\'D\\' || s[i]==\\'C\\' && s[i+1]==\\'M\\')\\n        {\\n            n -= 200;\\n        }\\n    }\\n    return n;\\n}"
                    },
                    {
                        "username": "hiteshcoder0",
                        "content": "code: \\n```\\nclass Solution\\n{\\npublic:\\n    int romanToInt(string s)\\n    {\\n        int ans = 0;\\n\\n        map<char, int> roman;\\n\\n        roman[\\'I\\'] = 1;\\n        roman[\\'V\\'] = 5;\\n        roman[\\'X\\'] = 10;\\n        roman[\\'L\\'] = 50;\\n        roman[\\'C\\'] = 100;\\n        roman[\\'D\\'] = 500;\\n        roman[\\'M\\'] = 1000;\\n\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n\\n            ans += roman[s[i]];\\n            if (roman[s[i]] > roman[s[i - 1]])\\n            {\\n                ans -= roman[s[i - 1]] * 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n\\n# I am getting this error\\n\\n##Runtime Error\\n```\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff2d67d6a0 overflowed to 0x7fff2d67d69f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\\n```"
                    },
                    {
                        "username": "user7769x",
                        "content": "int romanToInt(char * s){\\n    int ans = 0;\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++)\\n    {\\n        if (s[i] == \\'I\\')\\n            ans += 1;\\n        else if (s[i] == \\'V\\') \\n            ans += 5;\\n        else if (s[i] == \\'X\\') \\n            ans += 10;\\n        else if (s[i] == \\'L\\') \\n            ans += 50;\\n        else if (s[i] == \\'C\\') \\n            ans += 100;\\n        else if (s[i] == \\'V\\') \\n            ans += 500;\\n        else if (s[i] == \\'M\\')\\n            ans += 1000;\\n        else\\n        {\\n\\n        }\\n    }\\n    return ans;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1779570,
                "content": [
                    {
                        "username": "DSpursuer",
                        "content": "what\\'s the acceptance criteria? after running my java code is marked as \"accepted\", I haven\\'t submitted the code yet since I a) have no idea how fast this is, it creates quite a few of things in memory which I\\'d like not to create (and use streamapi for instance), and the code is over 40 lines long, which again feels kind of suboptimal. I, however, tested it on different combinations of roman numbers and it works every time"
                    },
                    {
                        "username": "rennorenno",
                        "content": "am i dumb because idek what the self input is supposed to be or mean. like doesn\\'t the function only take in a roman numeral?"
                    },
                    {
                        "username": "NASEEF_VPO",
                        "content": "if(4 * num < answer)\\n        {\\n            answer -= num;\\n        }"
                    },
                    {
                        "username": "brandon0458",
                        "content": "Python simple easy:\n\n\n`\n \nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \n        mapping = {\n            \"I\": 1,\n            \"IV\": 4,\n            \"V\": 5,\n            \"IX\": 9,\n            \"X\": 10,\n            \"XL\": 40,\n            \"L\": 50,\n            \"XC\": 90,\n            \"C\": 100,\n            \"CD\": 400,\n            \"D\": 500,\n            \"CM\": 900,\n            \"M\": 1000,\n        }\n\n        output = 0\n        index = 0\n        \n        while index < len(s):\n            if (len(s) - index + 1 > 2):\n                if (f\"{s[index]}{s[index+1]}\" in mapping):\n                    output += mapping.get(f\"{s[index]}{s[index+1]}\")\n                    index += 2\n                else: \n                    output += mapping.get(f\"{s[index]}\")\n                    index += 1\n            else:\n                output += mapping.get(f\"{s[index]}\")\n                index += 1\n        return output\n\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules simple easy.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\n1. store the symbols and cost in a hashmap\n2. `sum = s[last_index]`\n3. iterate the string in reversed order, upto `last_index-1`\n4. if `cost(s[current_index])` >= `cost(s[current_index + 1])`, then\n4.1. `sum += s[current_index]`\n5. else\n5.1. `sum -= s[current_index]`\n6. return sum\n7. stop"
                    },
                    {
                        "username": "eliasfayad",
                        "content": "if this is considered easy, then can\\'t wait to see medium and hard levels :p "
                    },
                    {
                        "username": "sachin12g",
                        "content": "How difficult or easy would it be to do this problem the other way round? i.e convert Integer to Roman."
                    },
                    {
                        "username": "samcodepractice",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int value = 0;\\n        for(int i=0; i<s.length(); ++i){\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n            case \\'I\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'V\\' || s.charAt(i + 1) == \\'X\\')) {\\n                    value -= 1;\\n                } else {\\n                    value += 1;\\n                }\\n                break;\\n            case \\'V\\':\\n                value += 5;\\n                break;\\n            case \\'X\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'L\\' || s.charAt(i + 1) == \\'C\\')) {\\n                    value -= 10;\\n                } else {\\n                    value += 10;\\n                }\\n                break;\\n            case \\'L\\':\\n                value += 50;\\n                break;\\n            case \\'C\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'D\\' || s.charAt(i + 1) == \\'M\\')) {\\n                    value -= 100;\\n                } else {\\n                    value += 100;\\n                }\\n                break;\\n            case \\'D\\':\\n                value += 500;\\n                break;\\n            case \\'M\\':\\n                value += 1000;\\n        }\\n    }\\n    return value;\\n\\n            /* It\\'s doesn\\'t pass one test case although it\\'s right */\\n            \\n        //     switch(ch){\\n        //         case \\'I\\':\\n        //            value += 1;\\n        //            break;\\n        //         case \\'V\\':\\n        //             value += 5;\\n        //             break;\\n        //         case \\'X\\':\\n        //             value += 10;\\n        //             break;\\n        //         case \\'L\\':\\n        //             value += 50;\\n        //             break;\\n        //         case \\'C\\':\\n        //             value += 100;\\n        //             break;\\n        //         case \\'D\\':\\n        //             value += 500;\\n        //             break;\\n        //         case \\'M\\':\\n        //             value += 1000;\\n                    \\n        //     }\\n        // }\\n        // return value;\\n    }\\n}\\n\\nFor each character, it uses a switch statement to determine the integer value of the character. If the character is \\'I\\', \\'X\\', \\'C\\', the method checks if the next character is \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\' or \\'M\\' respectively. If true, it subtract the value of current character from the result, otherwise it adds the value of current character to the result. If the character is \\'V\\', \\'L\\', \\'D\\' or \\'M\\', the method adds the corresponding value to the result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user7716Tf",
                        "content": "I am new in leetcode, dont know why my runtime and memory usage is different if I repeatedly submit my answer"
                    },
                    {
                        "username": "khasim19",
                        "content": "there is no line 64,  why compiler error at line64\\n"
                    }
                ]
            },
            {
                "id": 1778351,
                "content": [
                    {
                        "username": "DSpursuer",
                        "content": "what\\'s the acceptance criteria? after running my java code is marked as \"accepted\", I haven\\'t submitted the code yet since I a) have no idea how fast this is, it creates quite a few of things in memory which I\\'d like not to create (and use streamapi for instance), and the code is over 40 lines long, which again feels kind of suboptimal. I, however, tested it on different combinations of roman numbers and it works every time"
                    },
                    {
                        "username": "rennorenno",
                        "content": "am i dumb because idek what the self input is supposed to be or mean. like doesn\\'t the function only take in a roman numeral?"
                    },
                    {
                        "username": "NASEEF_VPO",
                        "content": "if(4 * num < answer)\\n        {\\n            answer -= num;\\n        }"
                    },
                    {
                        "username": "brandon0458",
                        "content": "Python simple easy:\n\n\n`\n \nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \n        mapping = {\n            \"I\": 1,\n            \"IV\": 4,\n            \"V\": 5,\n            \"IX\": 9,\n            \"X\": 10,\n            \"XL\": 40,\n            \"L\": 50,\n            \"XC\": 90,\n            \"C\": 100,\n            \"CD\": 400,\n            \"D\": 500,\n            \"CM\": 900,\n            \"M\": 1000,\n        }\n\n        output = 0\n        index = 0\n        \n        while index < len(s):\n            if (len(s) - index + 1 > 2):\n                if (f\"{s[index]}{s[index+1]}\" in mapping):\n                    output += mapping.get(f\"{s[index]}{s[index+1]}\")\n                    index += 2\n                else: \n                    output += mapping.get(f\"{s[index]}\")\n                    index += 1\n            else:\n                output += mapping.get(f\"{s[index]}\")\n                index += 1\n        return output\n\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules simple easy.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\n1. store the symbols and cost in a hashmap\n2. `sum = s[last_index]`\n3. iterate the string in reversed order, upto `last_index-1`\n4. if `cost(s[current_index])` >= `cost(s[current_index + 1])`, then\n4.1. `sum += s[current_index]`\n5. else\n5.1. `sum -= s[current_index]`\n6. return sum\n7. stop"
                    },
                    {
                        "username": "eliasfayad",
                        "content": "if this is considered easy, then can\\'t wait to see medium and hard levels :p "
                    },
                    {
                        "username": "sachin12g",
                        "content": "How difficult or easy would it be to do this problem the other way round? i.e convert Integer to Roman."
                    },
                    {
                        "username": "samcodepractice",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int value = 0;\\n        for(int i=0; i<s.length(); ++i){\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n            case \\'I\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'V\\' || s.charAt(i + 1) == \\'X\\')) {\\n                    value -= 1;\\n                } else {\\n                    value += 1;\\n                }\\n                break;\\n            case \\'V\\':\\n                value += 5;\\n                break;\\n            case \\'X\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'L\\' || s.charAt(i + 1) == \\'C\\')) {\\n                    value -= 10;\\n                } else {\\n                    value += 10;\\n                }\\n                break;\\n            case \\'L\\':\\n                value += 50;\\n                break;\\n            case \\'C\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'D\\' || s.charAt(i + 1) == \\'M\\')) {\\n                    value -= 100;\\n                } else {\\n                    value += 100;\\n                }\\n                break;\\n            case \\'D\\':\\n                value += 500;\\n                break;\\n            case \\'M\\':\\n                value += 1000;\\n        }\\n    }\\n    return value;\\n\\n            /* It\\'s doesn\\'t pass one test case although it\\'s right */\\n            \\n        //     switch(ch){\\n        //         case \\'I\\':\\n        //            value += 1;\\n        //            break;\\n        //         case \\'V\\':\\n        //             value += 5;\\n        //             break;\\n        //         case \\'X\\':\\n        //             value += 10;\\n        //             break;\\n        //         case \\'L\\':\\n        //             value += 50;\\n        //             break;\\n        //         case \\'C\\':\\n        //             value += 100;\\n        //             break;\\n        //         case \\'D\\':\\n        //             value += 500;\\n        //             break;\\n        //         case \\'M\\':\\n        //             value += 1000;\\n                    \\n        //     }\\n        // }\\n        // return value;\\n    }\\n}\\n\\nFor each character, it uses a switch statement to determine the integer value of the character. If the character is \\'I\\', \\'X\\', \\'C\\', the method checks if the next character is \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\' or \\'M\\' respectively. If true, it subtract the value of current character from the result, otherwise it adds the value of current character to the result. If the character is \\'V\\', \\'L\\', \\'D\\' or \\'M\\', the method adds the corresponding value to the result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user7716Tf",
                        "content": "I am new in leetcode, dont know why my runtime and memory usage is different if I repeatedly submit my answer"
                    },
                    {
                        "username": "khasim19",
                        "content": "there is no line 64,  why compiler error at line64\\n"
                    }
                ]
            },
            {
                "id": 1776121,
                "content": [
                    {
                        "username": "DSpursuer",
                        "content": "what\\'s the acceptance criteria? after running my java code is marked as \"accepted\", I haven\\'t submitted the code yet since I a) have no idea how fast this is, it creates quite a few of things in memory which I\\'d like not to create (and use streamapi for instance), and the code is over 40 lines long, which again feels kind of suboptimal. I, however, tested it on different combinations of roman numbers and it works every time"
                    },
                    {
                        "username": "rennorenno",
                        "content": "am i dumb because idek what the self input is supposed to be or mean. like doesn\\'t the function only take in a roman numeral?"
                    },
                    {
                        "username": "NASEEF_VPO",
                        "content": "if(4 * num < answer)\\n        {\\n            answer -= num;\\n        }"
                    },
                    {
                        "username": "brandon0458",
                        "content": "Python simple easy:\n\n\n`\n \nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \n        mapping = {\n            \"I\": 1,\n            \"IV\": 4,\n            \"V\": 5,\n            \"IX\": 9,\n            \"X\": 10,\n            \"XL\": 40,\n            \"L\": 50,\n            \"XC\": 90,\n            \"C\": 100,\n            \"CD\": 400,\n            \"D\": 500,\n            \"CM\": 900,\n            \"M\": 1000,\n        }\n\n        output = 0\n        index = 0\n        \n        while index < len(s):\n            if (len(s) - index + 1 > 2):\n                if (f\"{s[index]}{s[index+1]}\" in mapping):\n                    output += mapping.get(f\"{s[index]}{s[index+1]}\")\n                    index += 2\n                else: \n                    output += mapping.get(f\"{s[index]}\")\n                    index += 1\n            else:\n                output += mapping.get(f\"{s[index]}\")\n                index += 1\n        return output\n\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules simple easy.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\n1. store the symbols and cost in a hashmap\n2. `sum = s[last_index]`\n3. iterate the string in reversed order, upto `last_index-1`\n4. if `cost(s[current_index])` >= `cost(s[current_index + 1])`, then\n4.1. `sum += s[current_index]`\n5. else\n5.1. `sum -= s[current_index]`\n6. return sum\n7. stop"
                    },
                    {
                        "username": "eliasfayad",
                        "content": "if this is considered easy, then can\\'t wait to see medium and hard levels :p "
                    },
                    {
                        "username": "sachin12g",
                        "content": "How difficult or easy would it be to do this problem the other way round? i.e convert Integer to Roman."
                    },
                    {
                        "username": "samcodepractice",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int value = 0;\\n        for(int i=0; i<s.length(); ++i){\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n            case \\'I\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'V\\' || s.charAt(i + 1) == \\'X\\')) {\\n                    value -= 1;\\n                } else {\\n                    value += 1;\\n                }\\n                break;\\n            case \\'V\\':\\n                value += 5;\\n                break;\\n            case \\'X\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'L\\' || s.charAt(i + 1) == \\'C\\')) {\\n                    value -= 10;\\n                } else {\\n                    value += 10;\\n                }\\n                break;\\n            case \\'L\\':\\n                value += 50;\\n                break;\\n            case \\'C\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'D\\' || s.charAt(i + 1) == \\'M\\')) {\\n                    value -= 100;\\n                } else {\\n                    value += 100;\\n                }\\n                break;\\n            case \\'D\\':\\n                value += 500;\\n                break;\\n            case \\'M\\':\\n                value += 1000;\\n        }\\n    }\\n    return value;\\n\\n            /* It\\'s doesn\\'t pass one test case although it\\'s right */\\n            \\n        //     switch(ch){\\n        //         case \\'I\\':\\n        //            value += 1;\\n        //            break;\\n        //         case \\'V\\':\\n        //             value += 5;\\n        //             break;\\n        //         case \\'X\\':\\n        //             value += 10;\\n        //             break;\\n        //         case \\'L\\':\\n        //             value += 50;\\n        //             break;\\n        //         case \\'C\\':\\n        //             value += 100;\\n        //             break;\\n        //         case \\'D\\':\\n        //             value += 500;\\n        //             break;\\n        //         case \\'M\\':\\n        //             value += 1000;\\n                    \\n        //     }\\n        // }\\n        // return value;\\n    }\\n}\\n\\nFor each character, it uses a switch statement to determine the integer value of the character. If the character is \\'I\\', \\'X\\', \\'C\\', the method checks if the next character is \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\' or \\'M\\' respectively. If true, it subtract the value of current character from the result, otherwise it adds the value of current character to the result. If the character is \\'V\\', \\'L\\', \\'D\\' or \\'M\\', the method adds the corresponding value to the result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user7716Tf",
                        "content": "I am new in leetcode, dont know why my runtime and memory usage is different if I repeatedly submit my answer"
                    },
                    {
                        "username": "khasim19",
                        "content": "there is no line 64,  why compiler error at line64\\n"
                    }
                ]
            },
            {
                "id": 1774557,
                "content": [
                    {
                        "username": "DSpursuer",
                        "content": "what\\'s the acceptance criteria? after running my java code is marked as \"accepted\", I haven\\'t submitted the code yet since I a) have no idea how fast this is, it creates quite a few of things in memory which I\\'d like not to create (and use streamapi for instance), and the code is over 40 lines long, which again feels kind of suboptimal. I, however, tested it on different combinations of roman numbers and it works every time"
                    },
                    {
                        "username": "rennorenno",
                        "content": "am i dumb because idek what the self input is supposed to be or mean. like doesn\\'t the function only take in a roman numeral?"
                    },
                    {
                        "username": "NASEEF_VPO",
                        "content": "if(4 * num < answer)\\n        {\\n            answer -= num;\\n        }"
                    },
                    {
                        "username": "brandon0458",
                        "content": "Python simple easy:\n\n\n`\n \nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \n        mapping = {\n            \"I\": 1,\n            \"IV\": 4,\n            \"V\": 5,\n            \"IX\": 9,\n            \"X\": 10,\n            \"XL\": 40,\n            \"L\": 50,\n            \"XC\": 90,\n            \"C\": 100,\n            \"CD\": 400,\n            \"D\": 500,\n            \"CM\": 900,\n            \"M\": 1000,\n        }\n\n        output = 0\n        index = 0\n        \n        while index < len(s):\n            if (len(s) - index + 1 > 2):\n                if (f\"{s[index]}{s[index+1]}\" in mapping):\n                    output += mapping.get(f\"{s[index]}{s[index+1]}\")\n                    index += 2\n                else: \n                    output += mapping.get(f\"{s[index]}\")\n                    index += 1\n            else:\n                output += mapping.get(f\"{s[index]}\")\n                index += 1\n        return output\n\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules simple easy.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\n1. store the symbols and cost in a hashmap\n2. `sum = s[last_index]`\n3. iterate the string in reversed order, upto `last_index-1`\n4. if `cost(s[current_index])` >= `cost(s[current_index + 1])`, then\n4.1. `sum += s[current_index]`\n5. else\n5.1. `sum -= s[current_index]`\n6. return sum\n7. stop"
                    },
                    {
                        "username": "eliasfayad",
                        "content": "if this is considered easy, then can\\'t wait to see medium and hard levels :p "
                    },
                    {
                        "username": "sachin12g",
                        "content": "How difficult or easy would it be to do this problem the other way round? i.e convert Integer to Roman."
                    },
                    {
                        "username": "samcodepractice",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int value = 0;\\n        for(int i=0; i<s.length(); ++i){\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n            case \\'I\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'V\\' || s.charAt(i + 1) == \\'X\\')) {\\n                    value -= 1;\\n                } else {\\n                    value += 1;\\n                }\\n                break;\\n            case \\'V\\':\\n                value += 5;\\n                break;\\n            case \\'X\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'L\\' || s.charAt(i + 1) == \\'C\\')) {\\n                    value -= 10;\\n                } else {\\n                    value += 10;\\n                }\\n                break;\\n            case \\'L\\':\\n                value += 50;\\n                break;\\n            case \\'C\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'D\\' || s.charAt(i + 1) == \\'M\\')) {\\n                    value -= 100;\\n                } else {\\n                    value += 100;\\n                }\\n                break;\\n            case \\'D\\':\\n                value += 500;\\n                break;\\n            case \\'M\\':\\n                value += 1000;\\n        }\\n    }\\n    return value;\\n\\n            /* It\\'s doesn\\'t pass one test case although it\\'s right */\\n            \\n        //     switch(ch){\\n        //         case \\'I\\':\\n        //            value += 1;\\n        //            break;\\n        //         case \\'V\\':\\n        //             value += 5;\\n        //             break;\\n        //         case \\'X\\':\\n        //             value += 10;\\n        //             break;\\n        //         case \\'L\\':\\n        //             value += 50;\\n        //             break;\\n        //         case \\'C\\':\\n        //             value += 100;\\n        //             break;\\n        //         case \\'D\\':\\n        //             value += 500;\\n        //             break;\\n        //         case \\'M\\':\\n        //             value += 1000;\\n                    \\n        //     }\\n        // }\\n        // return value;\\n    }\\n}\\n\\nFor each character, it uses a switch statement to determine the integer value of the character. If the character is \\'I\\', \\'X\\', \\'C\\', the method checks if the next character is \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\' or \\'M\\' respectively. If true, it subtract the value of current character from the result, otherwise it adds the value of current character to the result. If the character is \\'V\\', \\'L\\', \\'D\\' or \\'M\\', the method adds the corresponding value to the result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user7716Tf",
                        "content": "I am new in leetcode, dont know why my runtime and memory usage is different if I repeatedly submit my answer"
                    },
                    {
                        "username": "khasim19",
                        "content": "there is no line 64,  why compiler error at line64\\n"
                    }
                ]
            },
            {
                "id": 1773651,
                "content": [
                    {
                        "username": "DSpursuer",
                        "content": "what\\'s the acceptance criteria? after running my java code is marked as \"accepted\", I haven\\'t submitted the code yet since I a) have no idea how fast this is, it creates quite a few of things in memory which I\\'d like not to create (and use streamapi for instance), and the code is over 40 lines long, which again feels kind of suboptimal. I, however, tested it on different combinations of roman numbers and it works every time"
                    },
                    {
                        "username": "rennorenno",
                        "content": "am i dumb because idek what the self input is supposed to be or mean. like doesn\\'t the function only take in a roman numeral?"
                    },
                    {
                        "username": "NASEEF_VPO",
                        "content": "if(4 * num < answer)\\n        {\\n            answer -= num;\\n        }"
                    },
                    {
                        "username": "brandon0458",
                        "content": "Python simple easy:\n\n\n`\n \nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \n        mapping = {\n            \"I\": 1,\n            \"IV\": 4,\n            \"V\": 5,\n            \"IX\": 9,\n            \"X\": 10,\n            \"XL\": 40,\n            \"L\": 50,\n            \"XC\": 90,\n            \"C\": 100,\n            \"CD\": 400,\n            \"D\": 500,\n            \"CM\": 900,\n            \"M\": 1000,\n        }\n\n        output = 0\n        index = 0\n        \n        while index < len(s):\n            if (len(s) - index + 1 > 2):\n                if (f\"{s[index]}{s[index+1]}\" in mapping):\n                    output += mapping.get(f\"{s[index]}{s[index+1]}\")\n                    index += 2\n                else: \n                    output += mapping.get(f\"{s[index]}\")\n                    index += 1\n            else:\n                output += mapping.get(f\"{s[index]}\")\n                index += 1\n        return output\n\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules simple easy.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\n1. store the symbols and cost in a hashmap\n2. `sum = s[last_index]`\n3. iterate the string in reversed order, upto `last_index-1`\n4. if `cost(s[current_index])` >= `cost(s[current_index + 1])`, then\n4.1. `sum += s[current_index]`\n5. else\n5.1. `sum -= s[current_index]`\n6. return sum\n7. stop"
                    },
                    {
                        "username": "eliasfayad",
                        "content": "if this is considered easy, then can\\'t wait to see medium and hard levels :p "
                    },
                    {
                        "username": "sachin12g",
                        "content": "How difficult or easy would it be to do this problem the other way round? i.e convert Integer to Roman."
                    },
                    {
                        "username": "samcodepractice",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int value = 0;\\n        for(int i=0; i<s.length(); ++i){\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n            case \\'I\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'V\\' || s.charAt(i + 1) == \\'X\\')) {\\n                    value -= 1;\\n                } else {\\n                    value += 1;\\n                }\\n                break;\\n            case \\'V\\':\\n                value += 5;\\n                break;\\n            case \\'X\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'L\\' || s.charAt(i + 1) == \\'C\\')) {\\n                    value -= 10;\\n                } else {\\n                    value += 10;\\n                }\\n                break;\\n            case \\'L\\':\\n                value += 50;\\n                break;\\n            case \\'C\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'D\\' || s.charAt(i + 1) == \\'M\\')) {\\n                    value -= 100;\\n                } else {\\n                    value += 100;\\n                }\\n                break;\\n            case \\'D\\':\\n                value += 500;\\n                break;\\n            case \\'M\\':\\n                value += 1000;\\n        }\\n    }\\n    return value;\\n\\n            /* It\\'s doesn\\'t pass one test case although it\\'s right */\\n            \\n        //     switch(ch){\\n        //         case \\'I\\':\\n        //            value += 1;\\n        //            break;\\n        //         case \\'V\\':\\n        //             value += 5;\\n        //             break;\\n        //         case \\'X\\':\\n        //             value += 10;\\n        //             break;\\n        //         case \\'L\\':\\n        //             value += 50;\\n        //             break;\\n        //         case \\'C\\':\\n        //             value += 100;\\n        //             break;\\n        //         case \\'D\\':\\n        //             value += 500;\\n        //             break;\\n        //         case \\'M\\':\\n        //             value += 1000;\\n                    \\n        //     }\\n        // }\\n        // return value;\\n    }\\n}\\n\\nFor each character, it uses a switch statement to determine the integer value of the character. If the character is \\'I\\', \\'X\\', \\'C\\', the method checks if the next character is \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\' or \\'M\\' respectively. If true, it subtract the value of current character from the result, otherwise it adds the value of current character to the result. If the character is \\'V\\', \\'L\\', \\'D\\' or \\'M\\', the method adds the corresponding value to the result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user7716Tf",
                        "content": "I am new in leetcode, dont know why my runtime and memory usage is different if I repeatedly submit my answer"
                    },
                    {
                        "username": "khasim19",
                        "content": "there is no line 64,  why compiler error at line64\\n"
                    }
                ]
            },
            {
                "id": 1773612,
                "content": [
                    {
                        "username": "DSpursuer",
                        "content": "what\\'s the acceptance criteria? after running my java code is marked as \"accepted\", I haven\\'t submitted the code yet since I a) have no idea how fast this is, it creates quite a few of things in memory which I\\'d like not to create (and use streamapi for instance), and the code is over 40 lines long, which again feels kind of suboptimal. I, however, tested it on different combinations of roman numbers and it works every time"
                    },
                    {
                        "username": "rennorenno",
                        "content": "am i dumb because idek what the self input is supposed to be or mean. like doesn\\'t the function only take in a roman numeral?"
                    },
                    {
                        "username": "NASEEF_VPO",
                        "content": "if(4 * num < answer)\\n        {\\n            answer -= num;\\n        }"
                    },
                    {
                        "username": "brandon0458",
                        "content": "Python simple easy:\n\n\n`\n \nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \n        mapping = {\n            \"I\": 1,\n            \"IV\": 4,\n            \"V\": 5,\n            \"IX\": 9,\n            \"X\": 10,\n            \"XL\": 40,\n            \"L\": 50,\n            \"XC\": 90,\n            \"C\": 100,\n            \"CD\": 400,\n            \"D\": 500,\n            \"CM\": 900,\n            \"M\": 1000,\n        }\n\n        output = 0\n        index = 0\n        \n        while index < len(s):\n            if (len(s) - index + 1 > 2):\n                if (f\"{s[index]}{s[index+1]}\" in mapping):\n                    output += mapping.get(f\"{s[index]}{s[index+1]}\")\n                    index += 2\n                else: \n                    output += mapping.get(f\"{s[index]}\")\n                    index += 1\n            else:\n                output += mapping.get(f\"{s[index]}\")\n                index += 1\n        return output\n\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules simple easy.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\n1. store the symbols and cost in a hashmap\n2. `sum = s[last_index]`\n3. iterate the string in reversed order, upto `last_index-1`\n4. if `cost(s[current_index])` >= `cost(s[current_index + 1])`, then\n4.1. `sum += s[current_index]`\n5. else\n5.1. `sum -= s[current_index]`\n6. return sum\n7. stop"
                    },
                    {
                        "username": "eliasfayad",
                        "content": "if this is considered easy, then can\\'t wait to see medium and hard levels :p "
                    },
                    {
                        "username": "sachin12g",
                        "content": "How difficult or easy would it be to do this problem the other way round? i.e convert Integer to Roman."
                    },
                    {
                        "username": "samcodepractice",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int value = 0;\\n        for(int i=0; i<s.length(); ++i){\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n            case \\'I\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'V\\' || s.charAt(i + 1) == \\'X\\')) {\\n                    value -= 1;\\n                } else {\\n                    value += 1;\\n                }\\n                break;\\n            case \\'V\\':\\n                value += 5;\\n                break;\\n            case \\'X\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'L\\' || s.charAt(i + 1) == \\'C\\')) {\\n                    value -= 10;\\n                } else {\\n                    value += 10;\\n                }\\n                break;\\n            case \\'L\\':\\n                value += 50;\\n                break;\\n            case \\'C\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'D\\' || s.charAt(i + 1) == \\'M\\')) {\\n                    value -= 100;\\n                } else {\\n                    value += 100;\\n                }\\n                break;\\n            case \\'D\\':\\n                value += 500;\\n                break;\\n            case \\'M\\':\\n                value += 1000;\\n        }\\n    }\\n    return value;\\n\\n            /* It\\'s doesn\\'t pass one test case although it\\'s right */\\n            \\n        //     switch(ch){\\n        //         case \\'I\\':\\n        //            value += 1;\\n        //            break;\\n        //         case \\'V\\':\\n        //             value += 5;\\n        //             break;\\n        //         case \\'X\\':\\n        //             value += 10;\\n        //             break;\\n        //         case \\'L\\':\\n        //             value += 50;\\n        //             break;\\n        //         case \\'C\\':\\n        //             value += 100;\\n        //             break;\\n        //         case \\'D\\':\\n        //             value += 500;\\n        //             break;\\n        //         case \\'M\\':\\n        //             value += 1000;\\n                    \\n        //     }\\n        // }\\n        // return value;\\n    }\\n}\\n\\nFor each character, it uses a switch statement to determine the integer value of the character. If the character is \\'I\\', \\'X\\', \\'C\\', the method checks if the next character is \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\' or \\'M\\' respectively. If true, it subtract the value of current character from the result, otherwise it adds the value of current character to the result. If the character is \\'V\\', \\'L\\', \\'D\\' or \\'M\\', the method adds the corresponding value to the result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user7716Tf",
                        "content": "I am new in leetcode, dont know why my runtime and memory usage is different if I repeatedly submit my answer"
                    },
                    {
                        "username": "khasim19",
                        "content": "there is no line 64,  why compiler error at line64\\n"
                    }
                ]
            },
            {
                "id": 1773053,
                "content": [
                    {
                        "username": "DSpursuer",
                        "content": "what\\'s the acceptance criteria? after running my java code is marked as \"accepted\", I haven\\'t submitted the code yet since I a) have no idea how fast this is, it creates quite a few of things in memory which I\\'d like not to create (and use streamapi for instance), and the code is over 40 lines long, which again feels kind of suboptimal. I, however, tested it on different combinations of roman numbers and it works every time"
                    },
                    {
                        "username": "rennorenno",
                        "content": "am i dumb because idek what the self input is supposed to be or mean. like doesn\\'t the function only take in a roman numeral?"
                    },
                    {
                        "username": "NASEEF_VPO",
                        "content": "if(4 * num < answer)\\n        {\\n            answer -= num;\\n        }"
                    },
                    {
                        "username": "brandon0458",
                        "content": "Python simple easy:\n\n\n`\n \nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \n        mapping = {\n            \"I\": 1,\n            \"IV\": 4,\n            \"V\": 5,\n            \"IX\": 9,\n            \"X\": 10,\n            \"XL\": 40,\n            \"L\": 50,\n            \"XC\": 90,\n            \"C\": 100,\n            \"CD\": 400,\n            \"D\": 500,\n            \"CM\": 900,\n            \"M\": 1000,\n        }\n\n        output = 0\n        index = 0\n        \n        while index < len(s):\n            if (len(s) - index + 1 > 2):\n                if (f\"{s[index]}{s[index+1]}\" in mapping):\n                    output += mapping.get(f\"{s[index]}{s[index+1]}\")\n                    index += 2\n                else: \n                    output += mapping.get(f\"{s[index]}\")\n                    index += 1\n            else:\n                output += mapping.get(f\"{s[index]}\")\n                index += 1\n        return output\n\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules simple easy.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\n1. store the symbols and cost in a hashmap\n2. `sum = s[last_index]`\n3. iterate the string in reversed order, upto `last_index-1`\n4. if `cost(s[current_index])` >= `cost(s[current_index + 1])`, then\n4.1. `sum += s[current_index]`\n5. else\n5.1. `sum -= s[current_index]`\n6. return sum\n7. stop"
                    },
                    {
                        "username": "eliasfayad",
                        "content": "if this is considered easy, then can\\'t wait to see medium and hard levels :p "
                    },
                    {
                        "username": "sachin12g",
                        "content": "How difficult or easy would it be to do this problem the other way round? i.e convert Integer to Roman."
                    },
                    {
                        "username": "samcodepractice",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int value = 0;\\n        for(int i=0; i<s.length(); ++i){\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n            case \\'I\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'V\\' || s.charAt(i + 1) == \\'X\\')) {\\n                    value -= 1;\\n                } else {\\n                    value += 1;\\n                }\\n                break;\\n            case \\'V\\':\\n                value += 5;\\n                break;\\n            case \\'X\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'L\\' || s.charAt(i + 1) == \\'C\\')) {\\n                    value -= 10;\\n                } else {\\n                    value += 10;\\n                }\\n                break;\\n            case \\'L\\':\\n                value += 50;\\n                break;\\n            case \\'C\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'D\\' || s.charAt(i + 1) == \\'M\\')) {\\n                    value -= 100;\\n                } else {\\n                    value += 100;\\n                }\\n                break;\\n            case \\'D\\':\\n                value += 500;\\n                break;\\n            case \\'M\\':\\n                value += 1000;\\n        }\\n    }\\n    return value;\\n\\n            /* It\\'s doesn\\'t pass one test case although it\\'s right */\\n            \\n        //     switch(ch){\\n        //         case \\'I\\':\\n        //            value += 1;\\n        //            break;\\n        //         case \\'V\\':\\n        //             value += 5;\\n        //             break;\\n        //         case \\'X\\':\\n        //             value += 10;\\n        //             break;\\n        //         case \\'L\\':\\n        //             value += 50;\\n        //             break;\\n        //         case \\'C\\':\\n        //             value += 100;\\n        //             break;\\n        //         case \\'D\\':\\n        //             value += 500;\\n        //             break;\\n        //         case \\'M\\':\\n        //             value += 1000;\\n                    \\n        //     }\\n        // }\\n        // return value;\\n    }\\n}\\n\\nFor each character, it uses a switch statement to determine the integer value of the character. If the character is \\'I\\', \\'X\\', \\'C\\', the method checks if the next character is \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\' or \\'M\\' respectively. If true, it subtract the value of current character from the result, otherwise it adds the value of current character to the result. If the character is \\'V\\', \\'L\\', \\'D\\' or \\'M\\', the method adds the corresponding value to the result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user7716Tf",
                        "content": "I am new in leetcode, dont know why my runtime and memory usage is different if I repeatedly submit my answer"
                    },
                    {
                        "username": "khasim19",
                        "content": "there is no line 64,  why compiler error at line64\\n"
                    }
                ]
            },
            {
                "id": 1772828,
                "content": [
                    {
                        "username": "DSpursuer",
                        "content": "what\\'s the acceptance criteria? after running my java code is marked as \"accepted\", I haven\\'t submitted the code yet since I a) have no idea how fast this is, it creates quite a few of things in memory which I\\'d like not to create (and use streamapi for instance), and the code is over 40 lines long, which again feels kind of suboptimal. I, however, tested it on different combinations of roman numbers and it works every time"
                    },
                    {
                        "username": "rennorenno",
                        "content": "am i dumb because idek what the self input is supposed to be or mean. like doesn\\'t the function only take in a roman numeral?"
                    },
                    {
                        "username": "NASEEF_VPO",
                        "content": "if(4 * num < answer)\\n        {\\n            answer -= num;\\n        }"
                    },
                    {
                        "username": "brandon0458",
                        "content": "Python simple easy:\n\n\n`\n \nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \n        mapping = {\n            \"I\": 1,\n            \"IV\": 4,\n            \"V\": 5,\n            \"IX\": 9,\n            \"X\": 10,\n            \"XL\": 40,\n            \"L\": 50,\n            \"XC\": 90,\n            \"C\": 100,\n            \"CD\": 400,\n            \"D\": 500,\n            \"CM\": 900,\n            \"M\": 1000,\n        }\n\n        output = 0\n        index = 0\n        \n        while index < len(s):\n            if (len(s) - index + 1 > 2):\n                if (f\"{s[index]}{s[index+1]}\" in mapping):\n                    output += mapping.get(f\"{s[index]}{s[index+1]}\")\n                    index += 2\n                else: \n                    output += mapping.get(f\"{s[index]}\")\n                    index += 1\n            else:\n                output += mapping.get(f\"{s[index]}\")\n                index += 1\n        return output\n\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules simple easy.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\n1. store the symbols and cost in a hashmap\n2. `sum = s[last_index]`\n3. iterate the string in reversed order, upto `last_index-1`\n4. if `cost(s[current_index])` >= `cost(s[current_index + 1])`, then\n4.1. `sum += s[current_index]`\n5. else\n5.1. `sum -= s[current_index]`\n6. return sum\n7. stop"
                    },
                    {
                        "username": "eliasfayad",
                        "content": "if this is considered easy, then can\\'t wait to see medium and hard levels :p "
                    },
                    {
                        "username": "sachin12g",
                        "content": "How difficult or easy would it be to do this problem the other way round? i.e convert Integer to Roman."
                    },
                    {
                        "username": "samcodepractice",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int value = 0;\\n        for(int i=0; i<s.length(); ++i){\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n            case \\'I\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'V\\' || s.charAt(i + 1) == \\'X\\')) {\\n                    value -= 1;\\n                } else {\\n                    value += 1;\\n                }\\n                break;\\n            case \\'V\\':\\n                value += 5;\\n                break;\\n            case \\'X\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'L\\' || s.charAt(i + 1) == \\'C\\')) {\\n                    value -= 10;\\n                } else {\\n                    value += 10;\\n                }\\n                break;\\n            case \\'L\\':\\n                value += 50;\\n                break;\\n            case \\'C\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'D\\' || s.charAt(i + 1) == \\'M\\')) {\\n                    value -= 100;\\n                } else {\\n                    value += 100;\\n                }\\n                break;\\n            case \\'D\\':\\n                value += 500;\\n                break;\\n            case \\'M\\':\\n                value += 1000;\\n        }\\n    }\\n    return value;\\n\\n            /* It\\'s doesn\\'t pass one test case although it\\'s right */\\n            \\n        //     switch(ch){\\n        //         case \\'I\\':\\n        //            value += 1;\\n        //            break;\\n        //         case \\'V\\':\\n        //             value += 5;\\n        //             break;\\n        //         case \\'X\\':\\n        //             value += 10;\\n        //             break;\\n        //         case \\'L\\':\\n        //             value += 50;\\n        //             break;\\n        //         case \\'C\\':\\n        //             value += 100;\\n        //             break;\\n        //         case \\'D\\':\\n        //             value += 500;\\n        //             break;\\n        //         case \\'M\\':\\n        //             value += 1000;\\n                    \\n        //     }\\n        // }\\n        // return value;\\n    }\\n}\\n\\nFor each character, it uses a switch statement to determine the integer value of the character. If the character is \\'I\\', \\'X\\', \\'C\\', the method checks if the next character is \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\' or \\'M\\' respectively. If true, it subtract the value of current character from the result, otherwise it adds the value of current character to the result. If the character is \\'V\\', \\'L\\', \\'D\\' or \\'M\\', the method adds the corresponding value to the result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user7716Tf",
                        "content": "I am new in leetcode, dont know why my runtime and memory usage is different if I repeatedly submit my answer"
                    },
                    {
                        "username": "khasim19",
                        "content": "there is no line 64,  why compiler error at line64\\n"
                    }
                ]
            },
            {
                "id": 1772198,
                "content": [
                    {
                        "username": "DSpursuer",
                        "content": "what\\'s the acceptance criteria? after running my java code is marked as \"accepted\", I haven\\'t submitted the code yet since I a) have no idea how fast this is, it creates quite a few of things in memory which I\\'d like not to create (and use streamapi for instance), and the code is over 40 lines long, which again feels kind of suboptimal. I, however, tested it on different combinations of roman numbers and it works every time"
                    },
                    {
                        "username": "rennorenno",
                        "content": "am i dumb because idek what the self input is supposed to be or mean. like doesn\\'t the function only take in a roman numeral?"
                    },
                    {
                        "username": "NASEEF_VPO",
                        "content": "if(4 * num < answer)\\n        {\\n            answer -= num;\\n        }"
                    },
                    {
                        "username": "brandon0458",
                        "content": "Python simple easy:\n\n\n`\n \nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \n        mapping = {\n            \"I\": 1,\n            \"IV\": 4,\n            \"V\": 5,\n            \"IX\": 9,\n            \"X\": 10,\n            \"XL\": 40,\n            \"L\": 50,\n            \"XC\": 90,\n            \"C\": 100,\n            \"CD\": 400,\n            \"D\": 500,\n            \"CM\": 900,\n            \"M\": 1000,\n        }\n\n        output = 0\n        index = 0\n        \n        while index < len(s):\n            if (len(s) - index + 1 > 2):\n                if (f\"{s[index]}{s[index+1]}\" in mapping):\n                    output += mapping.get(f\"{s[index]}{s[index+1]}\")\n                    index += 2\n                else: \n                    output += mapping.get(f\"{s[index]}\")\n                    index += 1\n            else:\n                output += mapping.get(f\"{s[index]}\")\n                index += 1\n        return output\n\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules simple easy.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\n1. store the symbols and cost in a hashmap\n2. `sum = s[last_index]`\n3. iterate the string in reversed order, upto `last_index-1`\n4. if `cost(s[current_index])` >= `cost(s[current_index + 1])`, then\n4.1. `sum += s[current_index]`\n5. else\n5.1. `sum -= s[current_index]`\n6. return sum\n7. stop"
                    },
                    {
                        "username": "eliasfayad",
                        "content": "if this is considered easy, then can\\'t wait to see medium and hard levels :p "
                    },
                    {
                        "username": "sachin12g",
                        "content": "How difficult or easy would it be to do this problem the other way round? i.e convert Integer to Roman."
                    },
                    {
                        "username": "samcodepractice",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int value = 0;\\n        for(int i=0; i<s.length(); ++i){\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n            case \\'I\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'V\\' || s.charAt(i + 1) == \\'X\\')) {\\n                    value -= 1;\\n                } else {\\n                    value += 1;\\n                }\\n                break;\\n            case \\'V\\':\\n                value += 5;\\n                break;\\n            case \\'X\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'L\\' || s.charAt(i + 1) == \\'C\\')) {\\n                    value -= 10;\\n                } else {\\n                    value += 10;\\n                }\\n                break;\\n            case \\'L\\':\\n                value += 50;\\n                break;\\n            case \\'C\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'D\\' || s.charAt(i + 1) == \\'M\\')) {\\n                    value -= 100;\\n                } else {\\n                    value += 100;\\n                }\\n                break;\\n            case \\'D\\':\\n                value += 500;\\n                break;\\n            case \\'M\\':\\n                value += 1000;\\n        }\\n    }\\n    return value;\\n\\n            /* It\\'s doesn\\'t pass one test case although it\\'s right */\\n            \\n        //     switch(ch){\\n        //         case \\'I\\':\\n        //            value += 1;\\n        //            break;\\n        //         case \\'V\\':\\n        //             value += 5;\\n        //             break;\\n        //         case \\'X\\':\\n        //             value += 10;\\n        //             break;\\n        //         case \\'L\\':\\n        //             value += 50;\\n        //             break;\\n        //         case \\'C\\':\\n        //             value += 100;\\n        //             break;\\n        //         case \\'D\\':\\n        //             value += 500;\\n        //             break;\\n        //         case \\'M\\':\\n        //             value += 1000;\\n                    \\n        //     }\\n        // }\\n        // return value;\\n    }\\n}\\n\\nFor each character, it uses a switch statement to determine the integer value of the character. If the character is \\'I\\', \\'X\\', \\'C\\', the method checks if the next character is \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\' or \\'M\\' respectively. If true, it subtract the value of current character from the result, otherwise it adds the value of current character to the result. If the character is \\'V\\', \\'L\\', \\'D\\' or \\'M\\', the method adds the corresponding value to the result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user7716Tf",
                        "content": "I am new in leetcode, dont know why my runtime and memory usage is different if I repeatedly submit my answer"
                    },
                    {
                        "username": "khasim19",
                        "content": "there is no line 64,  why compiler error at line64\\n"
                    }
                ]
            },
            {
                "id": 1769983,
                "content": [
                    {
                        "username": "DSpursuer",
                        "content": "what\\'s the acceptance criteria? after running my java code is marked as \"accepted\", I haven\\'t submitted the code yet since I a) have no idea how fast this is, it creates quite a few of things in memory which I\\'d like not to create (and use streamapi for instance), and the code is over 40 lines long, which again feels kind of suboptimal. I, however, tested it on different combinations of roman numbers and it works every time"
                    },
                    {
                        "username": "rennorenno",
                        "content": "am i dumb because idek what the self input is supposed to be or mean. like doesn\\'t the function only take in a roman numeral?"
                    },
                    {
                        "username": "NASEEF_VPO",
                        "content": "if(4 * num < answer)\\n        {\\n            answer -= num;\\n        }"
                    },
                    {
                        "username": "brandon0458",
                        "content": "Python simple easy:\n\n\n`\n \nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \n        mapping = {\n            \"I\": 1,\n            \"IV\": 4,\n            \"V\": 5,\n            \"IX\": 9,\n            \"X\": 10,\n            \"XL\": 40,\n            \"L\": 50,\n            \"XC\": 90,\n            \"C\": 100,\n            \"CD\": 400,\n            \"D\": 500,\n            \"CM\": 900,\n            \"M\": 1000,\n        }\n\n        output = 0\n        index = 0\n        \n        while index < len(s):\n            if (len(s) - index + 1 > 2):\n                if (f\"{s[index]}{s[index+1]}\" in mapping):\n                    output += mapping.get(f\"{s[index]}{s[index+1]}\")\n                    index += 2\n                else: \n                    output += mapping.get(f\"{s[index]}\")\n                    index += 1\n            else:\n                output += mapping.get(f\"{s[index]}\")\n                index += 1\n        return output\n\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The rules simple easy.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\n1. store the symbols and cost in a hashmap\n2. `sum = s[last_index]`\n3. iterate the string in reversed order, upto `last_index-1`\n4. if `cost(s[current_index])` >= `cost(s[current_index + 1])`, then\n4.1. `sum += s[current_index]`\n5. else\n5.1. `sum -= s[current_index]`\n6. return sum\n7. stop"
                    },
                    {
                        "username": "eliasfayad",
                        "content": "if this is considered easy, then can\\'t wait to see medium and hard levels :p "
                    },
                    {
                        "username": "sachin12g",
                        "content": "How difficult or easy would it be to do this problem the other way round? i.e convert Integer to Roman."
                    },
                    {
                        "username": "samcodepractice",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        int value = 0;\\n        for(int i=0; i<s.length(); ++i){\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n            case \\'I\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'V\\' || s.charAt(i + 1) == \\'X\\')) {\\n                    value -= 1;\\n                } else {\\n                    value += 1;\\n                }\\n                break;\\n            case \\'V\\':\\n                value += 5;\\n                break;\\n            case \\'X\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'L\\' || s.charAt(i + 1) == \\'C\\')) {\\n                    value -= 10;\\n                } else {\\n                    value += 10;\\n                }\\n                break;\\n            case \\'L\\':\\n                value += 50;\\n                break;\\n            case \\'C\\':\\n                if (i < s.length() - 1 && (s.charAt(i + 1) == \\'D\\' || s.charAt(i + 1) == \\'M\\')) {\\n                    value -= 100;\\n                } else {\\n                    value += 100;\\n                }\\n                break;\\n            case \\'D\\':\\n                value += 500;\\n                break;\\n            case \\'M\\':\\n                value += 1000;\\n        }\\n    }\\n    return value;\\n\\n            /* It\\'s doesn\\'t pass one test case although it\\'s right */\\n            \\n        //     switch(ch){\\n        //         case \\'I\\':\\n        //            value += 1;\\n        //            break;\\n        //         case \\'V\\':\\n        //             value += 5;\\n        //             break;\\n        //         case \\'X\\':\\n        //             value += 10;\\n        //             break;\\n        //         case \\'L\\':\\n        //             value += 50;\\n        //             break;\\n        //         case \\'C\\':\\n        //             value += 100;\\n        //             break;\\n        //         case \\'D\\':\\n        //             value += 500;\\n        //             break;\\n        //         case \\'M\\':\\n        //             value += 1000;\\n                    \\n        //     }\\n        // }\\n        // return value;\\n    }\\n}\\n\\nFor each character, it uses a switch statement to determine the integer value of the character. If the character is \\'I\\', \\'X\\', \\'C\\', the method checks if the next character is \\'V\\', \\'X\\', \\'L\\', \\'C\\', \\'D\\' or \\'M\\' respectively. If true, it subtract the value of current character from the result, otherwise it adds the value of current character to the result. If the character is \\'V\\', \\'L\\', \\'D\\' or \\'M\\', the method adds the corresponding value to the result."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user7716Tf",
                        "content": "I am new in leetcode, dont know why my runtime and memory usage is different if I repeatedly submit my answer"
                    },
                    {
                        "username": "khasim19",
                        "content": "there is no line 64,  why compiler error at line64\\n"
                    }
                ]
            },
            {
                "id": 1768436,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kingctan",
                        "content": "Convert the string to char array speed up the runtime \\npublic static int romanToInt(String s) {\\n        char[] chars = s.toCharArray();\\n        int sum = 0;\\n        int length = chars.length;\\n        for (int i = 0; i < chars.length; i++) {\\n            char curr = chars[i];\\n            if ((i + 1) < length && values.get(curr) < values.get(chars[i + 1])) {\\n                sum += values.get(chars[i + 1]) - values.get(curr);\\n                i++;\\n            } else\\n                sum += values.get(curr);\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "BurhanGardezi",
                        "content": "How is \"MMMCDXC\" = 2490 and not 3490?!\\n\\n[image](https://drive.google.com/file/d/1QCYmb67cWVIiWK7CU2xfTg3VX9AzU7fX/view?usp=share_link)"
                    },
                    {
                        "username": "phoducoder",
                        "content": "I am just starting out and this was marked as an easy question. Sweated in the this question only. Nervous on how this journey would be. "
                    },
                    {
                        "username": "codersudhir",
                        "content": "third tc was not corerect"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My code passes all tests but may I ask ChatGPT to improve it ?!!"
                    },
                    {
                        "username": "vinod006",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = map.get(s.charAt(s.length()-1));\\n        for(int i = s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                result -= map.get(s.charAt(i));\\n            }\\n            else{\\n                result += map.get(s.charAt(i));\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aldemyr",
                        "content": "I have a problem with the number \"DCXXI\" (621) in a IDE works fine, but in leet code doesn\\'t work, why it\\'s happend?"
                    },
                    {
                        "username": "v-losharma",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sum=0\\n        for val in s:\\n            if val == \\'I\\':\\n                sum = sum + 1\\n            elif val == \\'V\\':\\n                sum = sum +5\\n            elif val == \\'X\\':\\n                sum = sum +10\\n            elif val == \\'L\\':\\n                sum = sum + 50\\n            elif val == \\'C\\':\\n                sum = sum + 100\\n            elif val == \\'D\\':\\n                sum = sum + 500\\n            elif val == \\'M\\':\\n                sum = sum + 1000\\n        for val in [\"IV\",\"IX\",\"XL\",\"XC\",\"CD\",\"CM\"]:\\n            if val in s:\\n                if val in [\"IV\",\"IX\"]:\\n                    sum = sum -2\\n                elif val in [\"XL\",\"XC\"]:\\n                    sum = sum - 20\\n                elif val in [\"CD\",\"CM\"]:\\n                    sum = sum - 200\\n        return sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "We have `7` chars, `4` of them can be in any position in a string `s` which are:\\n`{V, L, D, M}`. The `3` rest chars are `{I, X, C}` if one of them is the last char in a string at `(i == s.length()-1`), then we will not have any difficulties, but if one of them is not the last char  at `(i != s.length()-1)`, then we will check the next char at `(i+1)` ."
                    }
                ]
            },
            {
                "id": 1768415,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kingctan",
                        "content": "Convert the string to char array speed up the runtime \\npublic static int romanToInt(String s) {\\n        char[] chars = s.toCharArray();\\n        int sum = 0;\\n        int length = chars.length;\\n        for (int i = 0; i < chars.length; i++) {\\n            char curr = chars[i];\\n            if ((i + 1) < length && values.get(curr) < values.get(chars[i + 1])) {\\n                sum += values.get(chars[i + 1]) - values.get(curr);\\n                i++;\\n            } else\\n                sum += values.get(curr);\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "BurhanGardezi",
                        "content": "How is \"MMMCDXC\" = 2490 and not 3490?!\\n\\n[image](https://drive.google.com/file/d/1QCYmb67cWVIiWK7CU2xfTg3VX9AzU7fX/view?usp=share_link)"
                    },
                    {
                        "username": "phoducoder",
                        "content": "I am just starting out and this was marked as an easy question. Sweated in the this question only. Nervous on how this journey would be. "
                    },
                    {
                        "username": "codersudhir",
                        "content": "third tc was not corerect"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My code passes all tests but may I ask ChatGPT to improve it ?!!"
                    },
                    {
                        "username": "vinod006",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = map.get(s.charAt(s.length()-1));\\n        for(int i = s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                result -= map.get(s.charAt(i));\\n            }\\n            else{\\n                result += map.get(s.charAt(i));\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aldemyr",
                        "content": "I have a problem with the number \"DCXXI\" (621) in a IDE works fine, but in leet code doesn\\'t work, why it\\'s happend?"
                    },
                    {
                        "username": "v-losharma",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sum=0\\n        for val in s:\\n            if val == \\'I\\':\\n                sum = sum + 1\\n            elif val == \\'V\\':\\n                sum = sum +5\\n            elif val == \\'X\\':\\n                sum = sum +10\\n            elif val == \\'L\\':\\n                sum = sum + 50\\n            elif val == \\'C\\':\\n                sum = sum + 100\\n            elif val == \\'D\\':\\n                sum = sum + 500\\n            elif val == \\'M\\':\\n                sum = sum + 1000\\n        for val in [\"IV\",\"IX\",\"XL\",\"XC\",\"CD\",\"CM\"]:\\n            if val in s:\\n                if val in [\"IV\",\"IX\"]:\\n                    sum = sum -2\\n                elif val in [\"XL\",\"XC\"]:\\n                    sum = sum - 20\\n                elif val in [\"CD\",\"CM\"]:\\n                    sum = sum - 200\\n        return sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "We have `7` chars, `4` of them can be in any position in a string `s` which are:\\n`{V, L, D, M}`. The `3` rest chars are `{I, X, C}` if one of them is the last char in a string at `(i == s.length()-1`), then we will not have any difficulties, but if one of them is not the last char  at `(i != s.length()-1)`, then we will check the next char at `(i+1)` ."
                    }
                ]
            },
            {
                "id": 1766976,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kingctan",
                        "content": "Convert the string to char array speed up the runtime \\npublic static int romanToInt(String s) {\\n        char[] chars = s.toCharArray();\\n        int sum = 0;\\n        int length = chars.length;\\n        for (int i = 0; i < chars.length; i++) {\\n            char curr = chars[i];\\n            if ((i + 1) < length && values.get(curr) < values.get(chars[i + 1])) {\\n                sum += values.get(chars[i + 1]) - values.get(curr);\\n                i++;\\n            } else\\n                sum += values.get(curr);\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "BurhanGardezi",
                        "content": "How is \"MMMCDXC\" = 2490 and not 3490?!\\n\\n[image](https://drive.google.com/file/d/1QCYmb67cWVIiWK7CU2xfTg3VX9AzU7fX/view?usp=share_link)"
                    },
                    {
                        "username": "phoducoder",
                        "content": "I am just starting out and this was marked as an easy question. Sweated in the this question only. Nervous on how this journey would be. "
                    },
                    {
                        "username": "codersudhir",
                        "content": "third tc was not corerect"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My code passes all tests but may I ask ChatGPT to improve it ?!!"
                    },
                    {
                        "username": "vinod006",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = map.get(s.charAt(s.length()-1));\\n        for(int i = s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                result -= map.get(s.charAt(i));\\n            }\\n            else{\\n                result += map.get(s.charAt(i));\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aldemyr",
                        "content": "I have a problem with the number \"DCXXI\" (621) in a IDE works fine, but in leet code doesn\\'t work, why it\\'s happend?"
                    },
                    {
                        "username": "v-losharma",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sum=0\\n        for val in s:\\n            if val == \\'I\\':\\n                sum = sum + 1\\n            elif val == \\'V\\':\\n                sum = sum +5\\n            elif val == \\'X\\':\\n                sum = sum +10\\n            elif val == \\'L\\':\\n                sum = sum + 50\\n            elif val == \\'C\\':\\n                sum = sum + 100\\n            elif val == \\'D\\':\\n                sum = sum + 500\\n            elif val == \\'M\\':\\n                sum = sum + 1000\\n        for val in [\"IV\",\"IX\",\"XL\",\"XC\",\"CD\",\"CM\"]:\\n            if val in s:\\n                if val in [\"IV\",\"IX\"]:\\n                    sum = sum -2\\n                elif val in [\"XL\",\"XC\"]:\\n                    sum = sum - 20\\n                elif val in [\"CD\",\"CM\"]:\\n                    sum = sum - 200\\n        return sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "We have `7` chars, `4` of them can be in any position in a string `s` which are:\\n`{V, L, D, M}`. The `3` rest chars are `{I, X, C}` if one of them is the last char in a string at `(i == s.length()-1`), then we will not have any difficulties, but if one of them is not the last char  at `(i != s.length()-1)`, then we will check the next char at `(i+1)` ."
                    }
                ]
            },
            {
                "id": 1766916,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kingctan",
                        "content": "Convert the string to char array speed up the runtime \\npublic static int romanToInt(String s) {\\n        char[] chars = s.toCharArray();\\n        int sum = 0;\\n        int length = chars.length;\\n        for (int i = 0; i < chars.length; i++) {\\n            char curr = chars[i];\\n            if ((i + 1) < length && values.get(curr) < values.get(chars[i + 1])) {\\n                sum += values.get(chars[i + 1]) - values.get(curr);\\n                i++;\\n            } else\\n                sum += values.get(curr);\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "BurhanGardezi",
                        "content": "How is \"MMMCDXC\" = 2490 and not 3490?!\\n\\n[image](https://drive.google.com/file/d/1QCYmb67cWVIiWK7CU2xfTg3VX9AzU7fX/view?usp=share_link)"
                    },
                    {
                        "username": "phoducoder",
                        "content": "I am just starting out and this was marked as an easy question. Sweated in the this question only. Nervous on how this journey would be. "
                    },
                    {
                        "username": "codersudhir",
                        "content": "third tc was not corerect"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My code passes all tests but may I ask ChatGPT to improve it ?!!"
                    },
                    {
                        "username": "vinod006",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = map.get(s.charAt(s.length()-1));\\n        for(int i = s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                result -= map.get(s.charAt(i));\\n            }\\n            else{\\n                result += map.get(s.charAt(i));\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aldemyr",
                        "content": "I have a problem with the number \"DCXXI\" (621) in a IDE works fine, but in leet code doesn\\'t work, why it\\'s happend?"
                    },
                    {
                        "username": "v-losharma",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sum=0\\n        for val in s:\\n            if val == \\'I\\':\\n                sum = sum + 1\\n            elif val == \\'V\\':\\n                sum = sum +5\\n            elif val == \\'X\\':\\n                sum = sum +10\\n            elif val == \\'L\\':\\n                sum = sum + 50\\n            elif val == \\'C\\':\\n                sum = sum + 100\\n            elif val == \\'D\\':\\n                sum = sum + 500\\n            elif val == \\'M\\':\\n                sum = sum + 1000\\n        for val in [\"IV\",\"IX\",\"XL\",\"XC\",\"CD\",\"CM\"]:\\n            if val in s:\\n                if val in [\"IV\",\"IX\"]:\\n                    sum = sum -2\\n                elif val in [\"XL\",\"XC\"]:\\n                    sum = sum - 20\\n                elif val in [\"CD\",\"CM\"]:\\n                    sum = sum - 200\\n        return sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "We have `7` chars, `4` of them can be in any position in a string `s` which are:\\n`{V, L, D, M}`. The `3` rest chars are `{I, X, C}` if one of them is the last char in a string at `(i == s.length()-1`), then we will not have any difficulties, but if one of them is not the last char  at `(i != s.length()-1)`, then we will check the next char at `(i+1)` ."
                    }
                ]
            },
            {
                "id": 1766195,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kingctan",
                        "content": "Convert the string to char array speed up the runtime \\npublic static int romanToInt(String s) {\\n        char[] chars = s.toCharArray();\\n        int sum = 0;\\n        int length = chars.length;\\n        for (int i = 0; i < chars.length; i++) {\\n            char curr = chars[i];\\n            if ((i + 1) < length && values.get(curr) < values.get(chars[i + 1])) {\\n                sum += values.get(chars[i + 1]) - values.get(curr);\\n                i++;\\n            } else\\n                sum += values.get(curr);\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "BurhanGardezi",
                        "content": "How is \"MMMCDXC\" = 2490 and not 3490?!\\n\\n[image](https://drive.google.com/file/d/1QCYmb67cWVIiWK7CU2xfTg3VX9AzU7fX/view?usp=share_link)"
                    },
                    {
                        "username": "phoducoder",
                        "content": "I am just starting out and this was marked as an easy question. Sweated in the this question only. Nervous on how this journey would be. "
                    },
                    {
                        "username": "codersudhir",
                        "content": "third tc was not corerect"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My code passes all tests but may I ask ChatGPT to improve it ?!!"
                    },
                    {
                        "username": "vinod006",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = map.get(s.charAt(s.length()-1));\\n        for(int i = s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                result -= map.get(s.charAt(i));\\n            }\\n            else{\\n                result += map.get(s.charAt(i));\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aldemyr",
                        "content": "I have a problem with the number \"DCXXI\" (621) in a IDE works fine, but in leet code doesn\\'t work, why it\\'s happend?"
                    },
                    {
                        "username": "v-losharma",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sum=0\\n        for val in s:\\n            if val == \\'I\\':\\n                sum = sum + 1\\n            elif val == \\'V\\':\\n                sum = sum +5\\n            elif val == \\'X\\':\\n                sum = sum +10\\n            elif val == \\'L\\':\\n                sum = sum + 50\\n            elif val == \\'C\\':\\n                sum = sum + 100\\n            elif val == \\'D\\':\\n                sum = sum + 500\\n            elif val == \\'M\\':\\n                sum = sum + 1000\\n        for val in [\"IV\",\"IX\",\"XL\",\"XC\",\"CD\",\"CM\"]:\\n            if val in s:\\n                if val in [\"IV\",\"IX\"]:\\n                    sum = sum -2\\n                elif val in [\"XL\",\"XC\"]:\\n                    sum = sum - 20\\n                elif val in [\"CD\",\"CM\"]:\\n                    sum = sum - 200\\n        return sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "We have `7` chars, `4` of them can be in any position in a string `s` which are:\\n`{V, L, D, M}`. The `3` rest chars are `{I, X, C}` if one of them is the last char in a string at `(i == s.length()-1`), then we will not have any difficulties, but if one of them is not the last char  at `(i != s.length()-1)`, then we will check the next char at `(i+1)` ."
                    }
                ]
            },
            {
                "id": 1763890,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kingctan",
                        "content": "Convert the string to char array speed up the runtime \\npublic static int romanToInt(String s) {\\n        char[] chars = s.toCharArray();\\n        int sum = 0;\\n        int length = chars.length;\\n        for (int i = 0; i < chars.length; i++) {\\n            char curr = chars[i];\\n            if ((i + 1) < length && values.get(curr) < values.get(chars[i + 1])) {\\n                sum += values.get(chars[i + 1]) - values.get(curr);\\n                i++;\\n            } else\\n                sum += values.get(curr);\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "BurhanGardezi",
                        "content": "How is \"MMMCDXC\" = 2490 and not 3490?!\\n\\n[image](https://drive.google.com/file/d/1QCYmb67cWVIiWK7CU2xfTg3VX9AzU7fX/view?usp=share_link)"
                    },
                    {
                        "username": "phoducoder",
                        "content": "I am just starting out and this was marked as an easy question. Sweated in the this question only. Nervous on how this journey would be. "
                    },
                    {
                        "username": "codersudhir",
                        "content": "third tc was not corerect"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My code passes all tests but may I ask ChatGPT to improve it ?!!"
                    },
                    {
                        "username": "vinod006",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = map.get(s.charAt(s.length()-1));\\n        for(int i = s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                result -= map.get(s.charAt(i));\\n            }\\n            else{\\n                result += map.get(s.charAt(i));\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aldemyr",
                        "content": "I have a problem with the number \"DCXXI\" (621) in a IDE works fine, but in leet code doesn\\'t work, why it\\'s happend?"
                    },
                    {
                        "username": "v-losharma",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sum=0\\n        for val in s:\\n            if val == \\'I\\':\\n                sum = sum + 1\\n            elif val == \\'V\\':\\n                sum = sum +5\\n            elif val == \\'X\\':\\n                sum = sum +10\\n            elif val == \\'L\\':\\n                sum = sum + 50\\n            elif val == \\'C\\':\\n                sum = sum + 100\\n            elif val == \\'D\\':\\n                sum = sum + 500\\n            elif val == \\'M\\':\\n                sum = sum + 1000\\n        for val in [\"IV\",\"IX\",\"XL\",\"XC\",\"CD\",\"CM\"]:\\n            if val in s:\\n                if val in [\"IV\",\"IX\"]:\\n                    sum = sum -2\\n                elif val in [\"XL\",\"XC\"]:\\n                    sum = sum - 20\\n                elif val in [\"CD\",\"CM\"]:\\n                    sum = sum - 200\\n        return sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "We have `7` chars, `4` of them can be in any position in a string `s` which are:\\n`{V, L, D, M}`. The `3` rest chars are `{I, X, C}` if one of them is the last char in a string at `(i == s.length()-1`), then we will not have any difficulties, but if one of them is not the last char  at `(i != s.length()-1)`, then we will check the next char at `(i+1)` ."
                    }
                ]
            },
            {
                "id": 1762220,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kingctan",
                        "content": "Convert the string to char array speed up the runtime \\npublic static int romanToInt(String s) {\\n        char[] chars = s.toCharArray();\\n        int sum = 0;\\n        int length = chars.length;\\n        for (int i = 0; i < chars.length; i++) {\\n            char curr = chars[i];\\n            if ((i + 1) < length && values.get(curr) < values.get(chars[i + 1])) {\\n                sum += values.get(chars[i + 1]) - values.get(curr);\\n                i++;\\n            } else\\n                sum += values.get(curr);\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "BurhanGardezi",
                        "content": "How is \"MMMCDXC\" = 2490 and not 3490?!\\n\\n[image](https://drive.google.com/file/d/1QCYmb67cWVIiWK7CU2xfTg3VX9AzU7fX/view?usp=share_link)"
                    },
                    {
                        "username": "phoducoder",
                        "content": "I am just starting out and this was marked as an easy question. Sweated in the this question only. Nervous on how this journey would be. "
                    },
                    {
                        "username": "codersudhir",
                        "content": "third tc was not corerect"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My code passes all tests but may I ask ChatGPT to improve it ?!!"
                    },
                    {
                        "username": "vinod006",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = map.get(s.charAt(s.length()-1));\\n        for(int i = s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                result -= map.get(s.charAt(i));\\n            }\\n            else{\\n                result += map.get(s.charAt(i));\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aldemyr",
                        "content": "I have a problem with the number \"DCXXI\" (621) in a IDE works fine, but in leet code doesn\\'t work, why it\\'s happend?"
                    },
                    {
                        "username": "v-losharma",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sum=0\\n        for val in s:\\n            if val == \\'I\\':\\n                sum = sum + 1\\n            elif val == \\'V\\':\\n                sum = sum +5\\n            elif val == \\'X\\':\\n                sum = sum +10\\n            elif val == \\'L\\':\\n                sum = sum + 50\\n            elif val == \\'C\\':\\n                sum = sum + 100\\n            elif val == \\'D\\':\\n                sum = sum + 500\\n            elif val == \\'M\\':\\n                sum = sum + 1000\\n        for val in [\"IV\",\"IX\",\"XL\",\"XC\",\"CD\",\"CM\"]:\\n            if val in s:\\n                if val in [\"IV\",\"IX\"]:\\n                    sum = sum -2\\n                elif val in [\"XL\",\"XC\"]:\\n                    sum = sum - 20\\n                elif val in [\"CD\",\"CM\"]:\\n                    sum = sum - 200\\n        return sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "We have `7` chars, `4` of them can be in any position in a string `s` which are:\\n`{V, L, D, M}`. The `3` rest chars are `{I, X, C}` if one of them is the last char in a string at `(i == s.length()-1`), then we will not have any difficulties, but if one of them is not the last char  at `(i != s.length()-1)`, then we will check the next char at `(i+1)` ."
                    }
                ]
            },
            {
                "id": 1761933,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kingctan",
                        "content": "Convert the string to char array speed up the runtime \\npublic static int romanToInt(String s) {\\n        char[] chars = s.toCharArray();\\n        int sum = 0;\\n        int length = chars.length;\\n        for (int i = 0; i < chars.length; i++) {\\n            char curr = chars[i];\\n            if ((i + 1) < length && values.get(curr) < values.get(chars[i + 1])) {\\n                sum += values.get(chars[i + 1]) - values.get(curr);\\n                i++;\\n            } else\\n                sum += values.get(curr);\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "BurhanGardezi",
                        "content": "How is \"MMMCDXC\" = 2490 and not 3490?!\\n\\n[image](https://drive.google.com/file/d/1QCYmb67cWVIiWK7CU2xfTg3VX9AzU7fX/view?usp=share_link)"
                    },
                    {
                        "username": "phoducoder",
                        "content": "I am just starting out and this was marked as an easy question. Sweated in the this question only. Nervous on how this journey would be. "
                    },
                    {
                        "username": "codersudhir",
                        "content": "third tc was not corerect"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My code passes all tests but may I ask ChatGPT to improve it ?!!"
                    },
                    {
                        "username": "vinod006",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = map.get(s.charAt(s.length()-1));\\n        for(int i = s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                result -= map.get(s.charAt(i));\\n            }\\n            else{\\n                result += map.get(s.charAt(i));\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aldemyr",
                        "content": "I have a problem with the number \"DCXXI\" (621) in a IDE works fine, but in leet code doesn\\'t work, why it\\'s happend?"
                    },
                    {
                        "username": "v-losharma",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sum=0\\n        for val in s:\\n            if val == \\'I\\':\\n                sum = sum + 1\\n            elif val == \\'V\\':\\n                sum = sum +5\\n            elif val == \\'X\\':\\n                sum = sum +10\\n            elif val == \\'L\\':\\n                sum = sum + 50\\n            elif val == \\'C\\':\\n                sum = sum + 100\\n            elif val == \\'D\\':\\n                sum = sum + 500\\n            elif val == \\'M\\':\\n                sum = sum + 1000\\n        for val in [\"IV\",\"IX\",\"XL\",\"XC\",\"CD\",\"CM\"]:\\n            if val in s:\\n                if val in [\"IV\",\"IX\"]:\\n                    sum = sum -2\\n                elif val in [\"XL\",\"XC\"]:\\n                    sum = sum - 20\\n                elif val in [\"CD\",\"CM\"]:\\n                    sum = sum - 200\\n        return sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "We have `7` chars, `4` of them can be in any position in a string `s` which are:\\n`{V, L, D, M}`. The `3` rest chars are `{I, X, C}` if one of them is the last char in a string at `(i == s.length()-1`), then we will not have any difficulties, but if one of them is not the last char  at `(i != s.length()-1)`, then we will check the next char at `(i+1)` ."
                    }
                ]
            },
            {
                "id": 1761728,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kingctan",
                        "content": "Convert the string to char array speed up the runtime \\npublic static int romanToInt(String s) {\\n        char[] chars = s.toCharArray();\\n        int sum = 0;\\n        int length = chars.length;\\n        for (int i = 0; i < chars.length; i++) {\\n            char curr = chars[i];\\n            if ((i + 1) < length && values.get(curr) < values.get(chars[i + 1])) {\\n                sum += values.get(chars[i + 1]) - values.get(curr);\\n                i++;\\n            } else\\n                sum += values.get(curr);\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "BurhanGardezi",
                        "content": "How is \"MMMCDXC\" = 2490 and not 3490?!\\n\\n[image](https://drive.google.com/file/d/1QCYmb67cWVIiWK7CU2xfTg3VX9AzU7fX/view?usp=share_link)"
                    },
                    {
                        "username": "phoducoder",
                        "content": "I am just starting out and this was marked as an easy question. Sweated in the this question only. Nervous on how this journey would be. "
                    },
                    {
                        "username": "codersudhir",
                        "content": "third tc was not corerect"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My code passes all tests but may I ask ChatGPT to improve it ?!!"
                    },
                    {
                        "username": "vinod006",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = map.get(s.charAt(s.length()-1));\\n        for(int i = s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                result -= map.get(s.charAt(i));\\n            }\\n            else{\\n                result += map.get(s.charAt(i));\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aldemyr",
                        "content": "I have a problem with the number \"DCXXI\" (621) in a IDE works fine, but in leet code doesn\\'t work, why it\\'s happend?"
                    },
                    {
                        "username": "v-losharma",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sum=0\\n        for val in s:\\n            if val == \\'I\\':\\n                sum = sum + 1\\n            elif val == \\'V\\':\\n                sum = sum +5\\n            elif val == \\'X\\':\\n                sum = sum +10\\n            elif val == \\'L\\':\\n                sum = sum + 50\\n            elif val == \\'C\\':\\n                sum = sum + 100\\n            elif val == \\'D\\':\\n                sum = sum + 500\\n            elif val == \\'M\\':\\n                sum = sum + 1000\\n        for val in [\"IV\",\"IX\",\"XL\",\"XC\",\"CD\",\"CM\"]:\\n            if val in s:\\n                if val in [\"IV\",\"IX\"]:\\n                    sum = sum -2\\n                elif val in [\"XL\",\"XC\"]:\\n                    sum = sum - 20\\n                elif val in [\"CD\",\"CM\"]:\\n                    sum = sum - 200\\n        return sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "We have `7` chars, `4` of them can be in any position in a string `s` which are:\\n`{V, L, D, M}`. The `3` rest chars are `{I, X, C}` if one of them is the last char in a string at `(i == s.length()-1`), then we will not have any difficulties, but if one of them is not the last char  at `(i != s.length()-1)`, then we will check the next char at `(i+1)` ."
                    }
                ]
            },
            {
                "id": 1758747,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kingctan",
                        "content": "Convert the string to char array speed up the runtime \\npublic static int romanToInt(String s) {\\n        char[] chars = s.toCharArray();\\n        int sum = 0;\\n        int length = chars.length;\\n        for (int i = 0; i < chars.length; i++) {\\n            char curr = chars[i];\\n            if ((i + 1) < length && values.get(curr) < values.get(chars[i + 1])) {\\n                sum += values.get(chars[i + 1]) - values.get(curr);\\n                i++;\\n            } else\\n                sum += values.get(curr);\\n        }\\n        return sum;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "BurhanGardezi",
                        "content": "How is \"MMMCDXC\" = 2490 and not 3490?!\\n\\n[image](https://drive.google.com/file/d/1QCYmb67cWVIiWK7CU2xfTg3VX9AzU7fX/view?usp=share_link)"
                    },
                    {
                        "username": "phoducoder",
                        "content": "I am just starting out and this was marked as an easy question. Sweated in the this question only. Nervous on how this journey would be. "
                    },
                    {
                        "username": "codersudhir",
                        "content": "third tc was not corerect"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My code passes all tests but may I ask ChatGPT to improve it ?!!"
                    },
                    {
                        "username": "vinod006",
                        "content": "class Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result = map.get(s.charAt(s.length()-1));\\n        for(int i = s.length()-2;i>=0;i--){\\n            if(map.get(s.charAt(i))<map.get(s.charAt(i+1))){\\n                result -= map.get(s.charAt(i));\\n            }\\n            else{\\n                result += map.get(s.charAt(i));\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aldemyr",
                        "content": "I have a problem with the number \"DCXXI\" (621) in a IDE works fine, but in leet code doesn\\'t work, why it\\'s happend?"
                    },
                    {
                        "username": "v-losharma",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        sum=0\\n        for val in s:\\n            if val == \\'I\\':\\n                sum = sum + 1\\n            elif val == \\'V\\':\\n                sum = sum +5\\n            elif val == \\'X\\':\\n                sum = sum +10\\n            elif val == \\'L\\':\\n                sum = sum + 50\\n            elif val == \\'C\\':\\n                sum = sum + 100\\n            elif val == \\'D\\':\\n                sum = sum + 500\\n            elif val == \\'M\\':\\n                sum = sum + 1000\\n        for val in [\"IV\",\"IX\",\"XL\",\"XC\",\"CD\",\"CM\"]:\\n            if val in s:\\n                if val in [\"IV\",\"IX\"]:\\n                    sum = sum -2\\n                elif val in [\"XL\",\"XC\"]:\\n                    sum = sum - 20\\n                elif val in [\"CD\",\"CM\"]:\\n                    sum = sum - 200\\n        return sum"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "muhammedkhanem",
                        "content": "We have `7` chars, `4` of them can be in any position in a string `s` which are:\\n`{V, L, D, M}`. The `3` rest chars are `{I, X, C}` if one of them is the last char in a string at `(i == s.length()-1`), then we will not have any difficulties, but if one of them is not the last char  at `(i != s.length()-1)`, then we will check the next char at `(i+1)` ."
                    }
                ]
            },
            {
                "id": 1756512,
                "content": [
                    {
                        "username": "renee_az96",
                        "content": "I ran my code a few times and it still didnt work. Tried it on my IDE and it worked just fine. Wonder if anyone else faced the same issue. Wasted my time trying to figure out where i was wrong"
                    },
                    {
                        "username": "Schokobonlean",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffb72d9cf0 at pc 0x000000347826 bp 0x7fffb72d99e0 sp 0x7fffb72d99d8\\nREAD of size 1 at 0x7fffb72d9cf0 thread T0\\n    #5 0x7f5f172270b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x7fffb72d9cf0 is located in stack of thread T0 at offset 80 in frame\\n  This frame has 2 object(s):\\n    [32, 33) \\'ref.tmp\\'\\n    [48, 80) \\'agg.tmp\\' <== Memory access at offset 80 overflows this variable\\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\\n      (longjmp and C++ exceptions *are* supported)\\nShadow bytes around the buggy address:\\n  0x100076e53340: f1 f1 f1 f1 00 f2 f2 f2 f8 f2 f2 f2 f8 f3 f3 f3\\n  0x100076e53350: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e53360: f1 f1 f1 f1 00 00 00 00 00 00 f2 f2 f2 f2 f8 f8\\n  0x100076e53370: f8 f8 f8 f8 f8 f2 f2 f2 f2 f2 f8 f2 f8 f3 f3 f3\\n  0x100076e53380: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x100076e53390: 00 00 00 00 f1 f1 f1 f1 01 f2 00 00 00 00[f3]f3\\n  0x100076e533a0: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533b0: 00 00 00 00 f1 f1 f1 f1 04 f2 00 00 00 00 00 00\\n  0x100076e533c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nI run into this error in the c++ version. Can\\'t be my code right? Shold be a bug."
                    },
                    {
                        "username": "kiranpmt",
                        "content": "how to write java code Roman into integer"
                    },
                    {
                        "username": "sajjadahmed0309",
                        "content": "Read the question carefully largest to small means if previous roman number is small then subtract it from current but dont forget to mutlply with 2 coz we already added that number to answer thats why multply best of luck\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int ans=0;\\n        int prev=0;\\n        int curr=0;\\n        int temp=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            switch(s.charAt(i))\\n            {\\n                case \\'I\\':\\n                {\\n                    curr=1;\\n                    break;\\n                }\\n                case \\'V\\':\\n                {\\n                    curr=5;\\n                    break;\\n                }\\n                case \\'X\\':\\n                {\\n                    curr=10;\\n                    break;\\n                }\\n                case \\'L\\':\\n                {\\n                    curr=50;\\n                    break;\\n                }\\n                case \\'C\\':\\n                {\\n                    curr=100;\\n                    break;\\n                }\\n                case \\'D\\':\\n                {\\n                    curr=500;\\n                    break;\\n                }\\n                case \\'M\\':\\n                {\\n                    curr=1000;\\n                    break;\\n                }\\n               \\n                \\n\\n            }\\n            temp=curr;\\n             if(prev<curr)\\n                {\\n                    curr=curr-2*prev;\\n                }\\n                ans=ans+curr;\\n                prev=temp;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "seranVishal",
                        "content": "hi, i didnt get errors , but also i didnt get the expected output... any favour plz\\n my code  given below\\n\\n\\n\\n\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        HashMap<Character, Integer> convertRomToInt = new HashMap();\\n        convertRomToInt.put(\\'I\\',1);\\n        convertRomToInt.put(\\'V\\',5);\\n        convertRomToInt.put(\\'X\\',10);\\n        convertRomToInt.put(\\'L\\',50);\\n        convertRomToInt.put(\\'C\\',100);\\n        convertRomToInt.put(\\'D\\',500);\\n        convertRomToInt.put(\\'M\\',1000);\\n        s= s.replace(\"IV\", \"IIII\");\\n        s= s.replace(\"IX\", \"VIIII\");\\n        s= s.replace(\"XL\", \"XXXX\");\\n        s= s.replace(\"XC\", \"LXXXX\");\\n        s= s.replace(\"CD\", \"CCCC\");\\n        s= s.replace(\"CM\", \"DCCCC\");\\n\\n        int number = 0;\\n        for(int i = 0; i>s.length();i++){\\n            number = number + (convertRomToInt.get(s.charAt(i)));\\n        }\\n        return number;\\n    }\\n    public static void main(String args[]){\\n        Scanner inp = new Scanner(System.in);\\n\\n        System.out.println(\"Enter RomanNumber\");\\n\\n         String roman = inp.nextLine(); \\n        romanToInt(\"roman\");\\n    }\\n}\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "iwenyadaniel12",
                        "content": "I\\u2019m new here\\u2026 let\\u2019s get it\\uD83D\\uDCAA\\uD83C\\uDFFE\\uD83D\\uDCAA\\uD83C\\uDFFE"
                    },
                    {
                        "username": "ponamarevrabota",
                        "content": " `class Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function romanToInt($s) {\\n        $symbolValue = array(\\n            \"I\" => 1,\\n            \"V\" => 5,\\n            \"X\" => 10,\\n            \"L\" => 50,\\n            \"C\" => 100,\\n            \"D\" => 500,\\n            \"M\" => 1000\\n        );\\n        $output = 0;\\n        $input = str_split($s);\\n        \\n        for($i = 0; $i <= strlen($s); $i++){\\n            if($symbolValue[$input[$i]]<$symbolValue[$input[$i+1]])\\n                $output -= $symbolValue[$input[$i]];\\n            else\\n                $output += $symbolValue[$input[$i]];\\n        }\\n        return($output);\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maulanabima785",
                        "content": "class Solution {\\nfun romanToInt(s: String): Int {\\n     val symbol = mapOf(\\'I\\' to 1, \\'V\\' to 5, \\'X\\' to 10, \\'L\\' to 50 ,\\'C\\' to 100, \\'D\\' to 500, \\'M\\' to 1000)\\n    var result = 0\\n    var x = 0\\n    while (x < s.length) {\\n        if( x != s.length-1 && symbol[s[x+1]]!! > symbol[s[x]]!!){\\n            result += (symbol[s[x+1]]!! - symbol[s[x]]!!)\\n            x++\\n        } else {\\n            result += symbol[s[x]] ?: 0\\n        }\\n        x++\\n    }\\n\\n    return result\\n}\\n}\\n\\nkotlin solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dhanrajkoshta7477292583",
                        "content": "\\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "IDK how to properly ask about this. I have written what appears to be a solution for the problem. It works fine on various test cases, in including the default ones when I run it on my system, but fails on most test cases when run on leetcode. What am I supposed to do?"
                    }
                ]
            },
            {
                "id": 1756229,
                "content": [
                    {
                        "username": "renee_az96",
                        "content": "I ran my code a few times and it still didnt work. Tried it on my IDE and it worked just fine. Wonder if anyone else faced the same issue. Wasted my time trying to figure out where i was wrong"
                    },
                    {
                        "username": "Schokobonlean",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffb72d9cf0 at pc 0x000000347826 bp 0x7fffb72d99e0 sp 0x7fffb72d99d8\\nREAD of size 1 at 0x7fffb72d9cf0 thread T0\\n    #5 0x7f5f172270b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x7fffb72d9cf0 is located in stack of thread T0 at offset 80 in frame\\n  This frame has 2 object(s):\\n    [32, 33) \\'ref.tmp\\'\\n    [48, 80) \\'agg.tmp\\' <== Memory access at offset 80 overflows this variable\\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\\n      (longjmp and C++ exceptions *are* supported)\\nShadow bytes around the buggy address:\\n  0x100076e53340: f1 f1 f1 f1 00 f2 f2 f2 f8 f2 f2 f2 f8 f3 f3 f3\\n  0x100076e53350: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e53360: f1 f1 f1 f1 00 00 00 00 00 00 f2 f2 f2 f2 f8 f8\\n  0x100076e53370: f8 f8 f8 f8 f8 f2 f2 f2 f2 f2 f8 f2 f8 f3 f3 f3\\n  0x100076e53380: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x100076e53390: 00 00 00 00 f1 f1 f1 f1 01 f2 00 00 00 00[f3]f3\\n  0x100076e533a0: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533b0: 00 00 00 00 f1 f1 f1 f1 04 f2 00 00 00 00 00 00\\n  0x100076e533c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nI run into this error in the c++ version. Can\\'t be my code right? Shold be a bug."
                    },
                    {
                        "username": "kiranpmt",
                        "content": "how to write java code Roman into integer"
                    },
                    {
                        "username": "sajjadahmed0309",
                        "content": "Read the question carefully largest to small means if previous roman number is small then subtract it from current but dont forget to mutlply with 2 coz we already added that number to answer thats why multply best of luck\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int ans=0;\\n        int prev=0;\\n        int curr=0;\\n        int temp=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            switch(s.charAt(i))\\n            {\\n                case \\'I\\':\\n                {\\n                    curr=1;\\n                    break;\\n                }\\n                case \\'V\\':\\n                {\\n                    curr=5;\\n                    break;\\n                }\\n                case \\'X\\':\\n                {\\n                    curr=10;\\n                    break;\\n                }\\n                case \\'L\\':\\n                {\\n                    curr=50;\\n                    break;\\n                }\\n                case \\'C\\':\\n                {\\n                    curr=100;\\n                    break;\\n                }\\n                case \\'D\\':\\n                {\\n                    curr=500;\\n                    break;\\n                }\\n                case \\'M\\':\\n                {\\n                    curr=1000;\\n                    break;\\n                }\\n               \\n                \\n\\n            }\\n            temp=curr;\\n             if(prev<curr)\\n                {\\n                    curr=curr-2*prev;\\n                }\\n                ans=ans+curr;\\n                prev=temp;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "seranVishal",
                        "content": "hi, i didnt get errors , but also i didnt get the expected output... any favour plz\\n my code  given below\\n\\n\\n\\n\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        HashMap<Character, Integer> convertRomToInt = new HashMap();\\n        convertRomToInt.put(\\'I\\',1);\\n        convertRomToInt.put(\\'V\\',5);\\n        convertRomToInt.put(\\'X\\',10);\\n        convertRomToInt.put(\\'L\\',50);\\n        convertRomToInt.put(\\'C\\',100);\\n        convertRomToInt.put(\\'D\\',500);\\n        convertRomToInt.put(\\'M\\',1000);\\n        s= s.replace(\"IV\", \"IIII\");\\n        s= s.replace(\"IX\", \"VIIII\");\\n        s= s.replace(\"XL\", \"XXXX\");\\n        s= s.replace(\"XC\", \"LXXXX\");\\n        s= s.replace(\"CD\", \"CCCC\");\\n        s= s.replace(\"CM\", \"DCCCC\");\\n\\n        int number = 0;\\n        for(int i = 0; i>s.length();i++){\\n            number = number + (convertRomToInt.get(s.charAt(i)));\\n        }\\n        return number;\\n    }\\n    public static void main(String args[]){\\n        Scanner inp = new Scanner(System.in);\\n\\n        System.out.println(\"Enter RomanNumber\");\\n\\n         String roman = inp.nextLine(); \\n        romanToInt(\"roman\");\\n    }\\n}\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "iwenyadaniel12",
                        "content": "I\\u2019m new here\\u2026 let\\u2019s get it\\uD83D\\uDCAA\\uD83C\\uDFFE\\uD83D\\uDCAA\\uD83C\\uDFFE"
                    },
                    {
                        "username": "ponamarevrabota",
                        "content": " `class Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function romanToInt($s) {\\n        $symbolValue = array(\\n            \"I\" => 1,\\n            \"V\" => 5,\\n            \"X\" => 10,\\n            \"L\" => 50,\\n            \"C\" => 100,\\n            \"D\" => 500,\\n            \"M\" => 1000\\n        );\\n        $output = 0;\\n        $input = str_split($s);\\n        \\n        for($i = 0; $i <= strlen($s); $i++){\\n            if($symbolValue[$input[$i]]<$symbolValue[$input[$i+1]])\\n                $output -= $symbolValue[$input[$i]];\\n            else\\n                $output += $symbolValue[$input[$i]];\\n        }\\n        return($output);\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maulanabima785",
                        "content": "class Solution {\\nfun romanToInt(s: String): Int {\\n     val symbol = mapOf(\\'I\\' to 1, \\'V\\' to 5, \\'X\\' to 10, \\'L\\' to 50 ,\\'C\\' to 100, \\'D\\' to 500, \\'M\\' to 1000)\\n    var result = 0\\n    var x = 0\\n    while (x < s.length) {\\n        if( x != s.length-1 && symbol[s[x+1]]!! > symbol[s[x]]!!){\\n            result += (symbol[s[x+1]]!! - symbol[s[x]]!!)\\n            x++\\n        } else {\\n            result += symbol[s[x]] ?: 0\\n        }\\n        x++\\n    }\\n\\n    return result\\n}\\n}\\n\\nkotlin solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dhanrajkoshta7477292583",
                        "content": "\\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "IDK how to properly ask about this. I have written what appears to be a solution for the problem. It works fine on various test cases, in including the default ones when I run it on my system, but fails on most test cases when run on leetcode. What am I supposed to do?"
                    }
                ]
            },
            {
                "id": 1755364,
                "content": [
                    {
                        "username": "renee_az96",
                        "content": "I ran my code a few times and it still didnt work. Tried it on my IDE and it worked just fine. Wonder if anyone else faced the same issue. Wasted my time trying to figure out where i was wrong"
                    },
                    {
                        "username": "Schokobonlean",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffb72d9cf0 at pc 0x000000347826 bp 0x7fffb72d99e0 sp 0x7fffb72d99d8\\nREAD of size 1 at 0x7fffb72d9cf0 thread T0\\n    #5 0x7f5f172270b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x7fffb72d9cf0 is located in stack of thread T0 at offset 80 in frame\\n  This frame has 2 object(s):\\n    [32, 33) \\'ref.tmp\\'\\n    [48, 80) \\'agg.tmp\\' <== Memory access at offset 80 overflows this variable\\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\\n      (longjmp and C++ exceptions *are* supported)\\nShadow bytes around the buggy address:\\n  0x100076e53340: f1 f1 f1 f1 00 f2 f2 f2 f8 f2 f2 f2 f8 f3 f3 f3\\n  0x100076e53350: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e53360: f1 f1 f1 f1 00 00 00 00 00 00 f2 f2 f2 f2 f8 f8\\n  0x100076e53370: f8 f8 f8 f8 f8 f2 f2 f2 f2 f2 f8 f2 f8 f3 f3 f3\\n  0x100076e53380: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x100076e53390: 00 00 00 00 f1 f1 f1 f1 01 f2 00 00 00 00[f3]f3\\n  0x100076e533a0: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533b0: 00 00 00 00 f1 f1 f1 f1 04 f2 00 00 00 00 00 00\\n  0x100076e533c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nI run into this error in the c++ version. Can\\'t be my code right? Shold be a bug."
                    },
                    {
                        "username": "kiranpmt",
                        "content": "how to write java code Roman into integer"
                    },
                    {
                        "username": "sajjadahmed0309",
                        "content": "Read the question carefully largest to small means if previous roman number is small then subtract it from current but dont forget to mutlply with 2 coz we already added that number to answer thats why multply best of luck\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int ans=0;\\n        int prev=0;\\n        int curr=0;\\n        int temp=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            switch(s.charAt(i))\\n            {\\n                case \\'I\\':\\n                {\\n                    curr=1;\\n                    break;\\n                }\\n                case \\'V\\':\\n                {\\n                    curr=5;\\n                    break;\\n                }\\n                case \\'X\\':\\n                {\\n                    curr=10;\\n                    break;\\n                }\\n                case \\'L\\':\\n                {\\n                    curr=50;\\n                    break;\\n                }\\n                case \\'C\\':\\n                {\\n                    curr=100;\\n                    break;\\n                }\\n                case \\'D\\':\\n                {\\n                    curr=500;\\n                    break;\\n                }\\n                case \\'M\\':\\n                {\\n                    curr=1000;\\n                    break;\\n                }\\n               \\n                \\n\\n            }\\n            temp=curr;\\n             if(prev<curr)\\n                {\\n                    curr=curr-2*prev;\\n                }\\n                ans=ans+curr;\\n                prev=temp;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "seranVishal",
                        "content": "hi, i didnt get errors , but also i didnt get the expected output... any favour plz\\n my code  given below\\n\\n\\n\\n\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        HashMap<Character, Integer> convertRomToInt = new HashMap();\\n        convertRomToInt.put(\\'I\\',1);\\n        convertRomToInt.put(\\'V\\',5);\\n        convertRomToInt.put(\\'X\\',10);\\n        convertRomToInt.put(\\'L\\',50);\\n        convertRomToInt.put(\\'C\\',100);\\n        convertRomToInt.put(\\'D\\',500);\\n        convertRomToInt.put(\\'M\\',1000);\\n        s= s.replace(\"IV\", \"IIII\");\\n        s= s.replace(\"IX\", \"VIIII\");\\n        s= s.replace(\"XL\", \"XXXX\");\\n        s= s.replace(\"XC\", \"LXXXX\");\\n        s= s.replace(\"CD\", \"CCCC\");\\n        s= s.replace(\"CM\", \"DCCCC\");\\n\\n        int number = 0;\\n        for(int i = 0; i>s.length();i++){\\n            number = number + (convertRomToInt.get(s.charAt(i)));\\n        }\\n        return number;\\n    }\\n    public static void main(String args[]){\\n        Scanner inp = new Scanner(System.in);\\n\\n        System.out.println(\"Enter RomanNumber\");\\n\\n         String roman = inp.nextLine(); \\n        romanToInt(\"roman\");\\n    }\\n}\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "iwenyadaniel12",
                        "content": "I\\u2019m new here\\u2026 let\\u2019s get it\\uD83D\\uDCAA\\uD83C\\uDFFE\\uD83D\\uDCAA\\uD83C\\uDFFE"
                    },
                    {
                        "username": "ponamarevrabota",
                        "content": " `class Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function romanToInt($s) {\\n        $symbolValue = array(\\n            \"I\" => 1,\\n            \"V\" => 5,\\n            \"X\" => 10,\\n            \"L\" => 50,\\n            \"C\" => 100,\\n            \"D\" => 500,\\n            \"M\" => 1000\\n        );\\n        $output = 0;\\n        $input = str_split($s);\\n        \\n        for($i = 0; $i <= strlen($s); $i++){\\n            if($symbolValue[$input[$i]]<$symbolValue[$input[$i+1]])\\n                $output -= $symbolValue[$input[$i]];\\n            else\\n                $output += $symbolValue[$input[$i]];\\n        }\\n        return($output);\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maulanabima785",
                        "content": "class Solution {\\nfun romanToInt(s: String): Int {\\n     val symbol = mapOf(\\'I\\' to 1, \\'V\\' to 5, \\'X\\' to 10, \\'L\\' to 50 ,\\'C\\' to 100, \\'D\\' to 500, \\'M\\' to 1000)\\n    var result = 0\\n    var x = 0\\n    while (x < s.length) {\\n        if( x != s.length-1 && symbol[s[x+1]]!! > symbol[s[x]]!!){\\n            result += (symbol[s[x+1]]!! - symbol[s[x]]!!)\\n            x++\\n        } else {\\n            result += symbol[s[x]] ?: 0\\n        }\\n        x++\\n    }\\n\\n    return result\\n}\\n}\\n\\nkotlin solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dhanrajkoshta7477292583",
                        "content": "\\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "IDK how to properly ask about this. I have written what appears to be a solution for the problem. It works fine on various test cases, in including the default ones when I run it on my system, but fails on most test cases when run on leetcode. What am I supposed to do?"
                    }
                ]
            },
            {
                "id": 1754942,
                "content": [
                    {
                        "username": "renee_az96",
                        "content": "I ran my code a few times and it still didnt work. Tried it on my IDE and it worked just fine. Wonder if anyone else faced the same issue. Wasted my time trying to figure out where i was wrong"
                    },
                    {
                        "username": "Schokobonlean",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffb72d9cf0 at pc 0x000000347826 bp 0x7fffb72d99e0 sp 0x7fffb72d99d8\\nREAD of size 1 at 0x7fffb72d9cf0 thread T0\\n    #5 0x7f5f172270b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x7fffb72d9cf0 is located in stack of thread T0 at offset 80 in frame\\n  This frame has 2 object(s):\\n    [32, 33) \\'ref.tmp\\'\\n    [48, 80) \\'agg.tmp\\' <== Memory access at offset 80 overflows this variable\\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\\n      (longjmp and C++ exceptions *are* supported)\\nShadow bytes around the buggy address:\\n  0x100076e53340: f1 f1 f1 f1 00 f2 f2 f2 f8 f2 f2 f2 f8 f3 f3 f3\\n  0x100076e53350: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e53360: f1 f1 f1 f1 00 00 00 00 00 00 f2 f2 f2 f2 f8 f8\\n  0x100076e53370: f8 f8 f8 f8 f8 f2 f2 f2 f2 f2 f8 f2 f8 f3 f3 f3\\n  0x100076e53380: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x100076e53390: 00 00 00 00 f1 f1 f1 f1 01 f2 00 00 00 00[f3]f3\\n  0x100076e533a0: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533b0: 00 00 00 00 f1 f1 f1 f1 04 f2 00 00 00 00 00 00\\n  0x100076e533c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nI run into this error in the c++ version. Can\\'t be my code right? Shold be a bug."
                    },
                    {
                        "username": "kiranpmt",
                        "content": "how to write java code Roman into integer"
                    },
                    {
                        "username": "sajjadahmed0309",
                        "content": "Read the question carefully largest to small means if previous roman number is small then subtract it from current but dont forget to mutlply with 2 coz we already added that number to answer thats why multply best of luck\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int ans=0;\\n        int prev=0;\\n        int curr=0;\\n        int temp=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            switch(s.charAt(i))\\n            {\\n                case \\'I\\':\\n                {\\n                    curr=1;\\n                    break;\\n                }\\n                case \\'V\\':\\n                {\\n                    curr=5;\\n                    break;\\n                }\\n                case \\'X\\':\\n                {\\n                    curr=10;\\n                    break;\\n                }\\n                case \\'L\\':\\n                {\\n                    curr=50;\\n                    break;\\n                }\\n                case \\'C\\':\\n                {\\n                    curr=100;\\n                    break;\\n                }\\n                case \\'D\\':\\n                {\\n                    curr=500;\\n                    break;\\n                }\\n                case \\'M\\':\\n                {\\n                    curr=1000;\\n                    break;\\n                }\\n               \\n                \\n\\n            }\\n            temp=curr;\\n             if(prev<curr)\\n                {\\n                    curr=curr-2*prev;\\n                }\\n                ans=ans+curr;\\n                prev=temp;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "seranVishal",
                        "content": "hi, i didnt get errors , but also i didnt get the expected output... any favour plz\\n my code  given below\\n\\n\\n\\n\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        HashMap<Character, Integer> convertRomToInt = new HashMap();\\n        convertRomToInt.put(\\'I\\',1);\\n        convertRomToInt.put(\\'V\\',5);\\n        convertRomToInt.put(\\'X\\',10);\\n        convertRomToInt.put(\\'L\\',50);\\n        convertRomToInt.put(\\'C\\',100);\\n        convertRomToInt.put(\\'D\\',500);\\n        convertRomToInt.put(\\'M\\',1000);\\n        s= s.replace(\"IV\", \"IIII\");\\n        s= s.replace(\"IX\", \"VIIII\");\\n        s= s.replace(\"XL\", \"XXXX\");\\n        s= s.replace(\"XC\", \"LXXXX\");\\n        s= s.replace(\"CD\", \"CCCC\");\\n        s= s.replace(\"CM\", \"DCCCC\");\\n\\n        int number = 0;\\n        for(int i = 0; i>s.length();i++){\\n            number = number + (convertRomToInt.get(s.charAt(i)));\\n        }\\n        return number;\\n    }\\n    public static void main(String args[]){\\n        Scanner inp = new Scanner(System.in);\\n\\n        System.out.println(\"Enter RomanNumber\");\\n\\n         String roman = inp.nextLine(); \\n        romanToInt(\"roman\");\\n    }\\n}\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "iwenyadaniel12",
                        "content": "I\\u2019m new here\\u2026 let\\u2019s get it\\uD83D\\uDCAA\\uD83C\\uDFFE\\uD83D\\uDCAA\\uD83C\\uDFFE"
                    },
                    {
                        "username": "ponamarevrabota",
                        "content": " `class Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function romanToInt($s) {\\n        $symbolValue = array(\\n            \"I\" => 1,\\n            \"V\" => 5,\\n            \"X\" => 10,\\n            \"L\" => 50,\\n            \"C\" => 100,\\n            \"D\" => 500,\\n            \"M\" => 1000\\n        );\\n        $output = 0;\\n        $input = str_split($s);\\n        \\n        for($i = 0; $i <= strlen($s); $i++){\\n            if($symbolValue[$input[$i]]<$symbolValue[$input[$i+1]])\\n                $output -= $symbolValue[$input[$i]];\\n            else\\n                $output += $symbolValue[$input[$i]];\\n        }\\n        return($output);\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maulanabima785",
                        "content": "class Solution {\\nfun romanToInt(s: String): Int {\\n     val symbol = mapOf(\\'I\\' to 1, \\'V\\' to 5, \\'X\\' to 10, \\'L\\' to 50 ,\\'C\\' to 100, \\'D\\' to 500, \\'M\\' to 1000)\\n    var result = 0\\n    var x = 0\\n    while (x < s.length) {\\n        if( x != s.length-1 && symbol[s[x+1]]!! > symbol[s[x]]!!){\\n            result += (symbol[s[x+1]]!! - symbol[s[x]]!!)\\n            x++\\n        } else {\\n            result += symbol[s[x]] ?: 0\\n        }\\n        x++\\n    }\\n\\n    return result\\n}\\n}\\n\\nkotlin solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dhanrajkoshta7477292583",
                        "content": "\\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "IDK how to properly ask about this. I have written what appears to be a solution for the problem. It works fine on various test cases, in including the default ones when I run it on my system, but fails on most test cases when run on leetcode. What am I supposed to do?"
                    }
                ]
            },
            {
                "id": 1753994,
                "content": [
                    {
                        "username": "renee_az96",
                        "content": "I ran my code a few times and it still didnt work. Tried it on my IDE and it worked just fine. Wonder if anyone else faced the same issue. Wasted my time trying to figure out where i was wrong"
                    },
                    {
                        "username": "Schokobonlean",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffb72d9cf0 at pc 0x000000347826 bp 0x7fffb72d99e0 sp 0x7fffb72d99d8\\nREAD of size 1 at 0x7fffb72d9cf0 thread T0\\n    #5 0x7f5f172270b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x7fffb72d9cf0 is located in stack of thread T0 at offset 80 in frame\\n  This frame has 2 object(s):\\n    [32, 33) \\'ref.tmp\\'\\n    [48, 80) \\'agg.tmp\\' <== Memory access at offset 80 overflows this variable\\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\\n      (longjmp and C++ exceptions *are* supported)\\nShadow bytes around the buggy address:\\n  0x100076e53340: f1 f1 f1 f1 00 f2 f2 f2 f8 f2 f2 f2 f8 f3 f3 f3\\n  0x100076e53350: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e53360: f1 f1 f1 f1 00 00 00 00 00 00 f2 f2 f2 f2 f8 f8\\n  0x100076e53370: f8 f8 f8 f8 f8 f2 f2 f2 f2 f2 f8 f2 f8 f3 f3 f3\\n  0x100076e53380: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x100076e53390: 00 00 00 00 f1 f1 f1 f1 01 f2 00 00 00 00[f3]f3\\n  0x100076e533a0: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533b0: 00 00 00 00 f1 f1 f1 f1 04 f2 00 00 00 00 00 00\\n  0x100076e533c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nI run into this error in the c++ version. Can\\'t be my code right? Shold be a bug."
                    },
                    {
                        "username": "kiranpmt",
                        "content": "how to write java code Roman into integer"
                    },
                    {
                        "username": "sajjadahmed0309",
                        "content": "Read the question carefully largest to small means if previous roman number is small then subtract it from current but dont forget to mutlply with 2 coz we already added that number to answer thats why multply best of luck\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int ans=0;\\n        int prev=0;\\n        int curr=0;\\n        int temp=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            switch(s.charAt(i))\\n            {\\n                case \\'I\\':\\n                {\\n                    curr=1;\\n                    break;\\n                }\\n                case \\'V\\':\\n                {\\n                    curr=5;\\n                    break;\\n                }\\n                case \\'X\\':\\n                {\\n                    curr=10;\\n                    break;\\n                }\\n                case \\'L\\':\\n                {\\n                    curr=50;\\n                    break;\\n                }\\n                case \\'C\\':\\n                {\\n                    curr=100;\\n                    break;\\n                }\\n                case \\'D\\':\\n                {\\n                    curr=500;\\n                    break;\\n                }\\n                case \\'M\\':\\n                {\\n                    curr=1000;\\n                    break;\\n                }\\n               \\n                \\n\\n            }\\n            temp=curr;\\n             if(prev<curr)\\n                {\\n                    curr=curr-2*prev;\\n                }\\n                ans=ans+curr;\\n                prev=temp;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "seranVishal",
                        "content": "hi, i didnt get errors , but also i didnt get the expected output... any favour plz\\n my code  given below\\n\\n\\n\\n\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        HashMap<Character, Integer> convertRomToInt = new HashMap();\\n        convertRomToInt.put(\\'I\\',1);\\n        convertRomToInt.put(\\'V\\',5);\\n        convertRomToInt.put(\\'X\\',10);\\n        convertRomToInt.put(\\'L\\',50);\\n        convertRomToInt.put(\\'C\\',100);\\n        convertRomToInt.put(\\'D\\',500);\\n        convertRomToInt.put(\\'M\\',1000);\\n        s= s.replace(\"IV\", \"IIII\");\\n        s= s.replace(\"IX\", \"VIIII\");\\n        s= s.replace(\"XL\", \"XXXX\");\\n        s= s.replace(\"XC\", \"LXXXX\");\\n        s= s.replace(\"CD\", \"CCCC\");\\n        s= s.replace(\"CM\", \"DCCCC\");\\n\\n        int number = 0;\\n        for(int i = 0; i>s.length();i++){\\n            number = number + (convertRomToInt.get(s.charAt(i)));\\n        }\\n        return number;\\n    }\\n    public static void main(String args[]){\\n        Scanner inp = new Scanner(System.in);\\n\\n        System.out.println(\"Enter RomanNumber\");\\n\\n         String roman = inp.nextLine(); \\n        romanToInt(\"roman\");\\n    }\\n}\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "iwenyadaniel12",
                        "content": "I\\u2019m new here\\u2026 let\\u2019s get it\\uD83D\\uDCAA\\uD83C\\uDFFE\\uD83D\\uDCAA\\uD83C\\uDFFE"
                    },
                    {
                        "username": "ponamarevrabota",
                        "content": " `class Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function romanToInt($s) {\\n        $symbolValue = array(\\n            \"I\" => 1,\\n            \"V\" => 5,\\n            \"X\" => 10,\\n            \"L\" => 50,\\n            \"C\" => 100,\\n            \"D\" => 500,\\n            \"M\" => 1000\\n        );\\n        $output = 0;\\n        $input = str_split($s);\\n        \\n        for($i = 0; $i <= strlen($s); $i++){\\n            if($symbolValue[$input[$i]]<$symbolValue[$input[$i+1]])\\n                $output -= $symbolValue[$input[$i]];\\n            else\\n                $output += $symbolValue[$input[$i]];\\n        }\\n        return($output);\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maulanabima785",
                        "content": "class Solution {\\nfun romanToInt(s: String): Int {\\n     val symbol = mapOf(\\'I\\' to 1, \\'V\\' to 5, \\'X\\' to 10, \\'L\\' to 50 ,\\'C\\' to 100, \\'D\\' to 500, \\'M\\' to 1000)\\n    var result = 0\\n    var x = 0\\n    while (x < s.length) {\\n        if( x != s.length-1 && symbol[s[x+1]]!! > symbol[s[x]]!!){\\n            result += (symbol[s[x+1]]!! - symbol[s[x]]!!)\\n            x++\\n        } else {\\n            result += symbol[s[x]] ?: 0\\n        }\\n        x++\\n    }\\n\\n    return result\\n}\\n}\\n\\nkotlin solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dhanrajkoshta7477292583",
                        "content": "\\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "IDK how to properly ask about this. I have written what appears to be a solution for the problem. It works fine on various test cases, in including the default ones when I run it on my system, but fails on most test cases when run on leetcode. What am I supposed to do?"
                    }
                ]
            },
            {
                "id": 1753910,
                "content": [
                    {
                        "username": "renee_az96",
                        "content": "I ran my code a few times and it still didnt work. Tried it on my IDE and it worked just fine. Wonder if anyone else faced the same issue. Wasted my time trying to figure out where i was wrong"
                    },
                    {
                        "username": "Schokobonlean",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffb72d9cf0 at pc 0x000000347826 bp 0x7fffb72d99e0 sp 0x7fffb72d99d8\\nREAD of size 1 at 0x7fffb72d9cf0 thread T0\\n    #5 0x7f5f172270b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x7fffb72d9cf0 is located in stack of thread T0 at offset 80 in frame\\n  This frame has 2 object(s):\\n    [32, 33) \\'ref.tmp\\'\\n    [48, 80) \\'agg.tmp\\' <== Memory access at offset 80 overflows this variable\\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\\n      (longjmp and C++ exceptions *are* supported)\\nShadow bytes around the buggy address:\\n  0x100076e53340: f1 f1 f1 f1 00 f2 f2 f2 f8 f2 f2 f2 f8 f3 f3 f3\\n  0x100076e53350: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e53360: f1 f1 f1 f1 00 00 00 00 00 00 f2 f2 f2 f2 f8 f8\\n  0x100076e53370: f8 f8 f8 f8 f8 f2 f2 f2 f2 f2 f8 f2 f8 f3 f3 f3\\n  0x100076e53380: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x100076e53390: 00 00 00 00 f1 f1 f1 f1 01 f2 00 00 00 00[f3]f3\\n  0x100076e533a0: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533b0: 00 00 00 00 f1 f1 f1 f1 04 f2 00 00 00 00 00 00\\n  0x100076e533c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nI run into this error in the c++ version. Can\\'t be my code right? Shold be a bug."
                    },
                    {
                        "username": "kiranpmt",
                        "content": "how to write java code Roman into integer"
                    },
                    {
                        "username": "sajjadahmed0309",
                        "content": "Read the question carefully largest to small means if previous roman number is small then subtract it from current but dont forget to mutlply with 2 coz we already added that number to answer thats why multply best of luck\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int ans=0;\\n        int prev=0;\\n        int curr=0;\\n        int temp=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            switch(s.charAt(i))\\n            {\\n                case \\'I\\':\\n                {\\n                    curr=1;\\n                    break;\\n                }\\n                case \\'V\\':\\n                {\\n                    curr=5;\\n                    break;\\n                }\\n                case \\'X\\':\\n                {\\n                    curr=10;\\n                    break;\\n                }\\n                case \\'L\\':\\n                {\\n                    curr=50;\\n                    break;\\n                }\\n                case \\'C\\':\\n                {\\n                    curr=100;\\n                    break;\\n                }\\n                case \\'D\\':\\n                {\\n                    curr=500;\\n                    break;\\n                }\\n                case \\'M\\':\\n                {\\n                    curr=1000;\\n                    break;\\n                }\\n               \\n                \\n\\n            }\\n            temp=curr;\\n             if(prev<curr)\\n                {\\n                    curr=curr-2*prev;\\n                }\\n                ans=ans+curr;\\n                prev=temp;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "seranVishal",
                        "content": "hi, i didnt get errors , but also i didnt get the expected output... any favour plz\\n my code  given below\\n\\n\\n\\n\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        HashMap<Character, Integer> convertRomToInt = new HashMap();\\n        convertRomToInt.put(\\'I\\',1);\\n        convertRomToInt.put(\\'V\\',5);\\n        convertRomToInt.put(\\'X\\',10);\\n        convertRomToInt.put(\\'L\\',50);\\n        convertRomToInt.put(\\'C\\',100);\\n        convertRomToInt.put(\\'D\\',500);\\n        convertRomToInt.put(\\'M\\',1000);\\n        s= s.replace(\"IV\", \"IIII\");\\n        s= s.replace(\"IX\", \"VIIII\");\\n        s= s.replace(\"XL\", \"XXXX\");\\n        s= s.replace(\"XC\", \"LXXXX\");\\n        s= s.replace(\"CD\", \"CCCC\");\\n        s= s.replace(\"CM\", \"DCCCC\");\\n\\n        int number = 0;\\n        for(int i = 0; i>s.length();i++){\\n            number = number + (convertRomToInt.get(s.charAt(i)));\\n        }\\n        return number;\\n    }\\n    public static void main(String args[]){\\n        Scanner inp = new Scanner(System.in);\\n\\n        System.out.println(\"Enter RomanNumber\");\\n\\n         String roman = inp.nextLine(); \\n        romanToInt(\"roman\");\\n    }\\n}\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "iwenyadaniel12",
                        "content": "I\\u2019m new here\\u2026 let\\u2019s get it\\uD83D\\uDCAA\\uD83C\\uDFFE\\uD83D\\uDCAA\\uD83C\\uDFFE"
                    },
                    {
                        "username": "ponamarevrabota",
                        "content": " `class Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function romanToInt($s) {\\n        $symbolValue = array(\\n            \"I\" => 1,\\n            \"V\" => 5,\\n            \"X\" => 10,\\n            \"L\" => 50,\\n            \"C\" => 100,\\n            \"D\" => 500,\\n            \"M\" => 1000\\n        );\\n        $output = 0;\\n        $input = str_split($s);\\n        \\n        for($i = 0; $i <= strlen($s); $i++){\\n            if($symbolValue[$input[$i]]<$symbolValue[$input[$i+1]])\\n                $output -= $symbolValue[$input[$i]];\\n            else\\n                $output += $symbolValue[$input[$i]];\\n        }\\n        return($output);\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maulanabima785",
                        "content": "class Solution {\\nfun romanToInt(s: String): Int {\\n     val symbol = mapOf(\\'I\\' to 1, \\'V\\' to 5, \\'X\\' to 10, \\'L\\' to 50 ,\\'C\\' to 100, \\'D\\' to 500, \\'M\\' to 1000)\\n    var result = 0\\n    var x = 0\\n    while (x < s.length) {\\n        if( x != s.length-1 && symbol[s[x+1]]!! > symbol[s[x]]!!){\\n            result += (symbol[s[x+1]]!! - symbol[s[x]]!!)\\n            x++\\n        } else {\\n            result += symbol[s[x]] ?: 0\\n        }\\n        x++\\n    }\\n\\n    return result\\n}\\n}\\n\\nkotlin solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dhanrajkoshta7477292583",
                        "content": "\\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "IDK how to properly ask about this. I have written what appears to be a solution for the problem. It works fine on various test cases, in including the default ones when I run it on my system, but fails on most test cases when run on leetcode. What am I supposed to do?"
                    }
                ]
            },
            {
                "id": 1751978,
                "content": [
                    {
                        "username": "renee_az96",
                        "content": "I ran my code a few times and it still didnt work. Tried it on my IDE and it worked just fine. Wonder if anyone else faced the same issue. Wasted my time trying to figure out where i was wrong"
                    },
                    {
                        "username": "Schokobonlean",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffb72d9cf0 at pc 0x000000347826 bp 0x7fffb72d99e0 sp 0x7fffb72d99d8\\nREAD of size 1 at 0x7fffb72d9cf0 thread T0\\n    #5 0x7f5f172270b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x7fffb72d9cf0 is located in stack of thread T0 at offset 80 in frame\\n  This frame has 2 object(s):\\n    [32, 33) \\'ref.tmp\\'\\n    [48, 80) \\'agg.tmp\\' <== Memory access at offset 80 overflows this variable\\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\\n      (longjmp and C++ exceptions *are* supported)\\nShadow bytes around the buggy address:\\n  0x100076e53340: f1 f1 f1 f1 00 f2 f2 f2 f8 f2 f2 f2 f8 f3 f3 f3\\n  0x100076e53350: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e53360: f1 f1 f1 f1 00 00 00 00 00 00 f2 f2 f2 f2 f8 f8\\n  0x100076e53370: f8 f8 f8 f8 f8 f2 f2 f2 f2 f2 f8 f2 f8 f3 f3 f3\\n  0x100076e53380: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x100076e53390: 00 00 00 00 f1 f1 f1 f1 01 f2 00 00 00 00[f3]f3\\n  0x100076e533a0: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533b0: 00 00 00 00 f1 f1 f1 f1 04 f2 00 00 00 00 00 00\\n  0x100076e533c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nI run into this error in the c++ version. Can\\'t be my code right? Shold be a bug."
                    },
                    {
                        "username": "kiranpmt",
                        "content": "how to write java code Roman into integer"
                    },
                    {
                        "username": "sajjadahmed0309",
                        "content": "Read the question carefully largest to small means if previous roman number is small then subtract it from current but dont forget to mutlply with 2 coz we already added that number to answer thats why multply best of luck\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int ans=0;\\n        int prev=0;\\n        int curr=0;\\n        int temp=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            switch(s.charAt(i))\\n            {\\n                case \\'I\\':\\n                {\\n                    curr=1;\\n                    break;\\n                }\\n                case \\'V\\':\\n                {\\n                    curr=5;\\n                    break;\\n                }\\n                case \\'X\\':\\n                {\\n                    curr=10;\\n                    break;\\n                }\\n                case \\'L\\':\\n                {\\n                    curr=50;\\n                    break;\\n                }\\n                case \\'C\\':\\n                {\\n                    curr=100;\\n                    break;\\n                }\\n                case \\'D\\':\\n                {\\n                    curr=500;\\n                    break;\\n                }\\n                case \\'M\\':\\n                {\\n                    curr=1000;\\n                    break;\\n                }\\n               \\n                \\n\\n            }\\n            temp=curr;\\n             if(prev<curr)\\n                {\\n                    curr=curr-2*prev;\\n                }\\n                ans=ans+curr;\\n                prev=temp;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "seranVishal",
                        "content": "hi, i didnt get errors , but also i didnt get the expected output... any favour plz\\n my code  given below\\n\\n\\n\\n\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        HashMap<Character, Integer> convertRomToInt = new HashMap();\\n        convertRomToInt.put(\\'I\\',1);\\n        convertRomToInt.put(\\'V\\',5);\\n        convertRomToInt.put(\\'X\\',10);\\n        convertRomToInt.put(\\'L\\',50);\\n        convertRomToInt.put(\\'C\\',100);\\n        convertRomToInt.put(\\'D\\',500);\\n        convertRomToInt.put(\\'M\\',1000);\\n        s= s.replace(\"IV\", \"IIII\");\\n        s= s.replace(\"IX\", \"VIIII\");\\n        s= s.replace(\"XL\", \"XXXX\");\\n        s= s.replace(\"XC\", \"LXXXX\");\\n        s= s.replace(\"CD\", \"CCCC\");\\n        s= s.replace(\"CM\", \"DCCCC\");\\n\\n        int number = 0;\\n        for(int i = 0; i>s.length();i++){\\n            number = number + (convertRomToInt.get(s.charAt(i)));\\n        }\\n        return number;\\n    }\\n    public static void main(String args[]){\\n        Scanner inp = new Scanner(System.in);\\n\\n        System.out.println(\"Enter RomanNumber\");\\n\\n         String roman = inp.nextLine(); \\n        romanToInt(\"roman\");\\n    }\\n}\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "iwenyadaniel12",
                        "content": "I\\u2019m new here\\u2026 let\\u2019s get it\\uD83D\\uDCAA\\uD83C\\uDFFE\\uD83D\\uDCAA\\uD83C\\uDFFE"
                    },
                    {
                        "username": "ponamarevrabota",
                        "content": " `class Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function romanToInt($s) {\\n        $symbolValue = array(\\n            \"I\" => 1,\\n            \"V\" => 5,\\n            \"X\" => 10,\\n            \"L\" => 50,\\n            \"C\" => 100,\\n            \"D\" => 500,\\n            \"M\" => 1000\\n        );\\n        $output = 0;\\n        $input = str_split($s);\\n        \\n        for($i = 0; $i <= strlen($s); $i++){\\n            if($symbolValue[$input[$i]]<$symbolValue[$input[$i+1]])\\n                $output -= $symbolValue[$input[$i]];\\n            else\\n                $output += $symbolValue[$input[$i]];\\n        }\\n        return($output);\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maulanabima785",
                        "content": "class Solution {\\nfun romanToInt(s: String): Int {\\n     val symbol = mapOf(\\'I\\' to 1, \\'V\\' to 5, \\'X\\' to 10, \\'L\\' to 50 ,\\'C\\' to 100, \\'D\\' to 500, \\'M\\' to 1000)\\n    var result = 0\\n    var x = 0\\n    while (x < s.length) {\\n        if( x != s.length-1 && symbol[s[x+1]]!! > symbol[s[x]]!!){\\n            result += (symbol[s[x+1]]!! - symbol[s[x]]!!)\\n            x++\\n        } else {\\n            result += symbol[s[x]] ?: 0\\n        }\\n        x++\\n    }\\n\\n    return result\\n}\\n}\\n\\nkotlin solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dhanrajkoshta7477292583",
                        "content": "\\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "IDK how to properly ask about this. I have written what appears to be a solution for the problem. It works fine on various test cases, in including the default ones when I run it on my system, but fails on most test cases when run on leetcode. What am I supposed to do?"
                    }
                ]
            },
            {
                "id": 1750677,
                "content": [
                    {
                        "username": "renee_az96",
                        "content": "I ran my code a few times and it still didnt work. Tried it on my IDE and it worked just fine. Wonder if anyone else faced the same issue. Wasted my time trying to figure out where i was wrong"
                    },
                    {
                        "username": "Schokobonlean",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffb72d9cf0 at pc 0x000000347826 bp 0x7fffb72d99e0 sp 0x7fffb72d99d8\\nREAD of size 1 at 0x7fffb72d9cf0 thread T0\\n    #5 0x7f5f172270b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x7fffb72d9cf0 is located in stack of thread T0 at offset 80 in frame\\n  This frame has 2 object(s):\\n    [32, 33) \\'ref.tmp\\'\\n    [48, 80) \\'agg.tmp\\' <== Memory access at offset 80 overflows this variable\\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\\n      (longjmp and C++ exceptions *are* supported)\\nShadow bytes around the buggy address:\\n  0x100076e53340: f1 f1 f1 f1 00 f2 f2 f2 f8 f2 f2 f2 f8 f3 f3 f3\\n  0x100076e53350: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e53360: f1 f1 f1 f1 00 00 00 00 00 00 f2 f2 f2 f2 f8 f8\\n  0x100076e53370: f8 f8 f8 f8 f8 f2 f2 f2 f2 f2 f8 f2 f8 f3 f3 f3\\n  0x100076e53380: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x100076e53390: 00 00 00 00 f1 f1 f1 f1 01 f2 00 00 00 00[f3]f3\\n  0x100076e533a0: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533b0: 00 00 00 00 f1 f1 f1 f1 04 f2 00 00 00 00 00 00\\n  0x100076e533c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nI run into this error in the c++ version. Can\\'t be my code right? Shold be a bug."
                    },
                    {
                        "username": "kiranpmt",
                        "content": "how to write java code Roman into integer"
                    },
                    {
                        "username": "sajjadahmed0309",
                        "content": "Read the question carefully largest to small means if previous roman number is small then subtract it from current but dont forget to mutlply with 2 coz we already added that number to answer thats why multply best of luck\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int ans=0;\\n        int prev=0;\\n        int curr=0;\\n        int temp=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            switch(s.charAt(i))\\n            {\\n                case \\'I\\':\\n                {\\n                    curr=1;\\n                    break;\\n                }\\n                case \\'V\\':\\n                {\\n                    curr=5;\\n                    break;\\n                }\\n                case \\'X\\':\\n                {\\n                    curr=10;\\n                    break;\\n                }\\n                case \\'L\\':\\n                {\\n                    curr=50;\\n                    break;\\n                }\\n                case \\'C\\':\\n                {\\n                    curr=100;\\n                    break;\\n                }\\n                case \\'D\\':\\n                {\\n                    curr=500;\\n                    break;\\n                }\\n                case \\'M\\':\\n                {\\n                    curr=1000;\\n                    break;\\n                }\\n               \\n                \\n\\n            }\\n            temp=curr;\\n             if(prev<curr)\\n                {\\n                    curr=curr-2*prev;\\n                }\\n                ans=ans+curr;\\n                prev=temp;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "seranVishal",
                        "content": "hi, i didnt get errors , but also i didnt get the expected output... any favour plz\\n my code  given below\\n\\n\\n\\n\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        HashMap<Character, Integer> convertRomToInt = new HashMap();\\n        convertRomToInt.put(\\'I\\',1);\\n        convertRomToInt.put(\\'V\\',5);\\n        convertRomToInt.put(\\'X\\',10);\\n        convertRomToInt.put(\\'L\\',50);\\n        convertRomToInt.put(\\'C\\',100);\\n        convertRomToInt.put(\\'D\\',500);\\n        convertRomToInt.put(\\'M\\',1000);\\n        s= s.replace(\"IV\", \"IIII\");\\n        s= s.replace(\"IX\", \"VIIII\");\\n        s= s.replace(\"XL\", \"XXXX\");\\n        s= s.replace(\"XC\", \"LXXXX\");\\n        s= s.replace(\"CD\", \"CCCC\");\\n        s= s.replace(\"CM\", \"DCCCC\");\\n\\n        int number = 0;\\n        for(int i = 0; i>s.length();i++){\\n            number = number + (convertRomToInt.get(s.charAt(i)));\\n        }\\n        return number;\\n    }\\n    public static void main(String args[]){\\n        Scanner inp = new Scanner(System.in);\\n\\n        System.out.println(\"Enter RomanNumber\");\\n\\n         String roman = inp.nextLine(); \\n        romanToInt(\"roman\");\\n    }\\n}\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "iwenyadaniel12",
                        "content": "I\\u2019m new here\\u2026 let\\u2019s get it\\uD83D\\uDCAA\\uD83C\\uDFFE\\uD83D\\uDCAA\\uD83C\\uDFFE"
                    },
                    {
                        "username": "ponamarevrabota",
                        "content": " `class Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function romanToInt($s) {\\n        $symbolValue = array(\\n            \"I\" => 1,\\n            \"V\" => 5,\\n            \"X\" => 10,\\n            \"L\" => 50,\\n            \"C\" => 100,\\n            \"D\" => 500,\\n            \"M\" => 1000\\n        );\\n        $output = 0;\\n        $input = str_split($s);\\n        \\n        for($i = 0; $i <= strlen($s); $i++){\\n            if($symbolValue[$input[$i]]<$symbolValue[$input[$i+1]])\\n                $output -= $symbolValue[$input[$i]];\\n            else\\n                $output += $symbolValue[$input[$i]];\\n        }\\n        return($output);\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maulanabima785",
                        "content": "class Solution {\\nfun romanToInt(s: String): Int {\\n     val symbol = mapOf(\\'I\\' to 1, \\'V\\' to 5, \\'X\\' to 10, \\'L\\' to 50 ,\\'C\\' to 100, \\'D\\' to 500, \\'M\\' to 1000)\\n    var result = 0\\n    var x = 0\\n    while (x < s.length) {\\n        if( x != s.length-1 && symbol[s[x+1]]!! > symbol[s[x]]!!){\\n            result += (symbol[s[x+1]]!! - symbol[s[x]]!!)\\n            x++\\n        } else {\\n            result += symbol[s[x]] ?: 0\\n        }\\n        x++\\n    }\\n\\n    return result\\n}\\n}\\n\\nkotlin solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dhanrajkoshta7477292583",
                        "content": "\\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "IDK how to properly ask about this. I have written what appears to be a solution for the problem. It works fine on various test cases, in including the default ones when I run it on my system, but fails on most test cases when run on leetcode. What am I supposed to do?"
                    }
                ]
            },
            {
                "id": 1749554,
                "content": [
                    {
                        "username": "renee_az96",
                        "content": "I ran my code a few times and it still didnt work. Tried it on my IDE and it worked just fine. Wonder if anyone else faced the same issue. Wasted my time trying to figure out where i was wrong"
                    },
                    {
                        "username": "Schokobonlean",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffb72d9cf0 at pc 0x000000347826 bp 0x7fffb72d99e0 sp 0x7fffb72d99d8\\nREAD of size 1 at 0x7fffb72d9cf0 thread T0\\n    #5 0x7f5f172270b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x7fffb72d9cf0 is located in stack of thread T0 at offset 80 in frame\\n  This frame has 2 object(s):\\n    [32, 33) \\'ref.tmp\\'\\n    [48, 80) \\'agg.tmp\\' <== Memory access at offset 80 overflows this variable\\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\\n      (longjmp and C++ exceptions *are* supported)\\nShadow bytes around the buggy address:\\n  0x100076e53340: f1 f1 f1 f1 00 f2 f2 f2 f8 f2 f2 f2 f8 f3 f3 f3\\n  0x100076e53350: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e53360: f1 f1 f1 f1 00 00 00 00 00 00 f2 f2 f2 f2 f8 f8\\n  0x100076e53370: f8 f8 f8 f8 f8 f2 f2 f2 f2 f2 f8 f2 f8 f3 f3 f3\\n  0x100076e53380: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x100076e53390: 00 00 00 00 f1 f1 f1 f1 01 f2 00 00 00 00[f3]f3\\n  0x100076e533a0: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533b0: 00 00 00 00 f1 f1 f1 f1 04 f2 00 00 00 00 00 00\\n  0x100076e533c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nI run into this error in the c++ version. Can\\'t be my code right? Shold be a bug."
                    },
                    {
                        "username": "kiranpmt",
                        "content": "how to write java code Roman into integer"
                    },
                    {
                        "username": "sajjadahmed0309",
                        "content": "Read the question carefully largest to small means if previous roman number is small then subtract it from current but dont forget to mutlply with 2 coz we already added that number to answer thats why multply best of luck\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int ans=0;\\n        int prev=0;\\n        int curr=0;\\n        int temp=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            switch(s.charAt(i))\\n            {\\n                case \\'I\\':\\n                {\\n                    curr=1;\\n                    break;\\n                }\\n                case \\'V\\':\\n                {\\n                    curr=5;\\n                    break;\\n                }\\n                case \\'X\\':\\n                {\\n                    curr=10;\\n                    break;\\n                }\\n                case \\'L\\':\\n                {\\n                    curr=50;\\n                    break;\\n                }\\n                case \\'C\\':\\n                {\\n                    curr=100;\\n                    break;\\n                }\\n                case \\'D\\':\\n                {\\n                    curr=500;\\n                    break;\\n                }\\n                case \\'M\\':\\n                {\\n                    curr=1000;\\n                    break;\\n                }\\n               \\n                \\n\\n            }\\n            temp=curr;\\n             if(prev<curr)\\n                {\\n                    curr=curr-2*prev;\\n                }\\n                ans=ans+curr;\\n                prev=temp;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "seranVishal",
                        "content": "hi, i didnt get errors , but also i didnt get the expected output... any favour plz\\n my code  given below\\n\\n\\n\\n\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        HashMap<Character, Integer> convertRomToInt = new HashMap();\\n        convertRomToInt.put(\\'I\\',1);\\n        convertRomToInt.put(\\'V\\',5);\\n        convertRomToInt.put(\\'X\\',10);\\n        convertRomToInt.put(\\'L\\',50);\\n        convertRomToInt.put(\\'C\\',100);\\n        convertRomToInt.put(\\'D\\',500);\\n        convertRomToInt.put(\\'M\\',1000);\\n        s= s.replace(\"IV\", \"IIII\");\\n        s= s.replace(\"IX\", \"VIIII\");\\n        s= s.replace(\"XL\", \"XXXX\");\\n        s= s.replace(\"XC\", \"LXXXX\");\\n        s= s.replace(\"CD\", \"CCCC\");\\n        s= s.replace(\"CM\", \"DCCCC\");\\n\\n        int number = 0;\\n        for(int i = 0; i>s.length();i++){\\n            number = number + (convertRomToInt.get(s.charAt(i)));\\n        }\\n        return number;\\n    }\\n    public static void main(String args[]){\\n        Scanner inp = new Scanner(System.in);\\n\\n        System.out.println(\"Enter RomanNumber\");\\n\\n         String roman = inp.nextLine(); \\n        romanToInt(\"roman\");\\n    }\\n}\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "iwenyadaniel12",
                        "content": "I\\u2019m new here\\u2026 let\\u2019s get it\\uD83D\\uDCAA\\uD83C\\uDFFE\\uD83D\\uDCAA\\uD83C\\uDFFE"
                    },
                    {
                        "username": "ponamarevrabota",
                        "content": " `class Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function romanToInt($s) {\\n        $symbolValue = array(\\n            \"I\" => 1,\\n            \"V\" => 5,\\n            \"X\" => 10,\\n            \"L\" => 50,\\n            \"C\" => 100,\\n            \"D\" => 500,\\n            \"M\" => 1000\\n        );\\n        $output = 0;\\n        $input = str_split($s);\\n        \\n        for($i = 0; $i <= strlen($s); $i++){\\n            if($symbolValue[$input[$i]]<$symbolValue[$input[$i+1]])\\n                $output -= $symbolValue[$input[$i]];\\n            else\\n                $output += $symbolValue[$input[$i]];\\n        }\\n        return($output);\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maulanabima785",
                        "content": "class Solution {\\nfun romanToInt(s: String): Int {\\n     val symbol = mapOf(\\'I\\' to 1, \\'V\\' to 5, \\'X\\' to 10, \\'L\\' to 50 ,\\'C\\' to 100, \\'D\\' to 500, \\'M\\' to 1000)\\n    var result = 0\\n    var x = 0\\n    while (x < s.length) {\\n        if( x != s.length-1 && symbol[s[x+1]]!! > symbol[s[x]]!!){\\n            result += (symbol[s[x+1]]!! - symbol[s[x]]!!)\\n            x++\\n        } else {\\n            result += symbol[s[x]] ?: 0\\n        }\\n        x++\\n    }\\n\\n    return result\\n}\\n}\\n\\nkotlin solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dhanrajkoshta7477292583",
                        "content": "\\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "IDK how to properly ask about this. I have written what appears to be a solution for the problem. It works fine on various test cases, in including the default ones when I run it on my system, but fails on most test cases when run on leetcode. What am I supposed to do?"
                    }
                ]
            },
            {
                "id": 1748911,
                "content": [
                    {
                        "username": "renee_az96",
                        "content": "I ran my code a few times and it still didnt work. Tried it on my IDE and it worked just fine. Wonder if anyone else faced the same issue. Wasted my time trying to figure out where i was wrong"
                    },
                    {
                        "username": "Schokobonlean",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffb72d9cf0 at pc 0x000000347826 bp 0x7fffb72d99e0 sp 0x7fffb72d99d8\\nREAD of size 1 at 0x7fffb72d9cf0 thread T0\\n    #5 0x7f5f172270b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x7fffb72d9cf0 is located in stack of thread T0 at offset 80 in frame\\n  This frame has 2 object(s):\\n    [32, 33) \\'ref.tmp\\'\\n    [48, 80) \\'agg.tmp\\' <== Memory access at offset 80 overflows this variable\\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\\n      (longjmp and C++ exceptions *are* supported)\\nShadow bytes around the buggy address:\\n  0x100076e53340: f1 f1 f1 f1 00 f2 f2 f2 f8 f2 f2 f2 f8 f3 f3 f3\\n  0x100076e53350: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e53360: f1 f1 f1 f1 00 00 00 00 00 00 f2 f2 f2 f2 f8 f8\\n  0x100076e53370: f8 f8 f8 f8 f8 f2 f2 f2 f2 f2 f8 f2 f8 f3 f3 f3\\n  0x100076e53380: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x100076e53390: 00 00 00 00 f1 f1 f1 f1 01 f2 00 00 00 00[f3]f3\\n  0x100076e533a0: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533b0: 00 00 00 00 f1 f1 f1 f1 04 f2 00 00 00 00 00 00\\n  0x100076e533c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x100076e533e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nI run into this error in the c++ version. Can\\'t be my code right? Shold be a bug."
                    },
                    {
                        "username": "kiranpmt",
                        "content": "how to write java code Roman into integer"
                    },
                    {
                        "username": "sajjadahmed0309",
                        "content": "Read the question carefully largest to small means if previous roman number is small then subtract it from current but dont forget to mutlply with 2 coz we already added that number to answer thats why multply best of luck\\nclass Solution {\\n    public int romanToInt(String s) {\\n        int ans=0;\\n        int prev=0;\\n        int curr=0;\\n        int temp=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            switch(s.charAt(i))\\n            {\\n                case \\'I\\':\\n                {\\n                    curr=1;\\n                    break;\\n                }\\n                case \\'V\\':\\n                {\\n                    curr=5;\\n                    break;\\n                }\\n                case \\'X\\':\\n                {\\n                    curr=10;\\n                    break;\\n                }\\n                case \\'L\\':\\n                {\\n                    curr=50;\\n                    break;\\n                }\\n                case \\'C\\':\\n                {\\n                    curr=100;\\n                    break;\\n                }\\n                case \\'D\\':\\n                {\\n                    curr=500;\\n                    break;\\n                }\\n                case \\'M\\':\\n                {\\n                    curr=1000;\\n                    break;\\n                }\\n               \\n                \\n\\n            }\\n            temp=curr;\\n             if(prev<curr)\\n                {\\n                    curr=curr-2*prev;\\n                }\\n                ans=ans+curr;\\n                prev=temp;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "seranVishal",
                        "content": "hi, i didnt get errors , but also i didnt get the expected output... any favour plz\\n my code  given below\\n\\n\\n\\n\\nclass Solution {\\n    public static int romanToInt(String s) {\\n        HashMap<Character, Integer> convertRomToInt = new HashMap();\\n        convertRomToInt.put(\\'I\\',1);\\n        convertRomToInt.put(\\'V\\',5);\\n        convertRomToInt.put(\\'X\\',10);\\n        convertRomToInt.put(\\'L\\',50);\\n        convertRomToInt.put(\\'C\\',100);\\n        convertRomToInt.put(\\'D\\',500);\\n        convertRomToInt.put(\\'M\\',1000);\\n        s= s.replace(\"IV\", \"IIII\");\\n        s= s.replace(\"IX\", \"VIIII\");\\n        s= s.replace(\"XL\", \"XXXX\");\\n        s= s.replace(\"XC\", \"LXXXX\");\\n        s= s.replace(\"CD\", \"CCCC\");\\n        s= s.replace(\"CM\", \"DCCCC\");\\n\\n        int number = 0;\\n        for(int i = 0; i>s.length();i++){\\n            number = number + (convertRomToInt.get(s.charAt(i)));\\n        }\\n        return number;\\n    }\\n    public static void main(String args[]){\\n        Scanner inp = new Scanner(System.in);\\n\\n        System.out.println(\"Enter RomanNumber\");\\n\\n         String roman = inp.nextLine(); \\n        romanToInt(\"roman\");\\n    }\\n}\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "iwenyadaniel12",
                        "content": "I\\u2019m new here\\u2026 let\\u2019s get it\\uD83D\\uDCAA\\uD83C\\uDFFE\\uD83D\\uDCAA\\uD83C\\uDFFE"
                    },
                    {
                        "username": "ponamarevrabota",
                        "content": " `class Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function romanToInt($s) {\\n        $symbolValue = array(\\n            \"I\" => 1,\\n            \"V\" => 5,\\n            \"X\" => 10,\\n            \"L\" => 50,\\n            \"C\" => 100,\\n            \"D\" => 500,\\n            \"M\" => 1000\\n        );\\n        $output = 0;\\n        $input = str_split($s);\\n        \\n        for($i = 0; $i <= strlen($s); $i++){\\n            if($symbolValue[$input[$i]]<$symbolValue[$input[$i+1]])\\n                $output -= $symbolValue[$input[$i]];\\n            else\\n                $output += $symbolValue[$input[$i]];\\n        }\\n        return($output);\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "maulanabima785",
                        "content": "class Solution {\\nfun romanToInt(s: String): Int {\\n     val symbol = mapOf(\\'I\\' to 1, \\'V\\' to 5, \\'X\\' to 10, \\'L\\' to 50 ,\\'C\\' to 100, \\'D\\' to 500, \\'M\\' to 1000)\\n    var result = 0\\n    var x = 0\\n    while (x < s.length) {\\n        if( x != s.length-1 && symbol[s[x+1]]!! > symbol[s[x]]!!){\\n            result += (symbol[s[x+1]]!! - symbol[s[x]]!!)\\n            x++\\n        } else {\\n            result += symbol[s[x]] ?: 0\\n        }\\n        x++\\n    }\\n\\n    return result\\n}\\n}\\n\\nkotlin solution"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dhanrajkoshta7477292583",
                        "content": "\\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "IDK how to properly ask about this. I have written what appears to be a solution for the problem. It works fine on various test cases, in including the default ones when I run it on my system, but fails on most test cases when run on leetcode. What am I supposed to do?"
                    }
                ]
            },
            {
                "id": 1748547,
                "content": [
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "i wrote a code but i am getting 2nd text case answer in 1st test case result and same with test case 2 and test case 3. no output for test case 3. same code works in another compiler ..how can i resolve this issue? "
                    },
                    {
                        "username": "MRZ16",
                        "content": "hi! this problem, it\\'s well"
                    },
                    {
                        "username": "Koura",
                        "content": "The solution is in this sentence: \\n\"Roman numerals are usually written largest to smallest from left to right\" \\uD83D\\uDE09\\n"
                    },
                    {
                        "username": "SnoopyDly",
                        "content": "Chewing about law of roman numbers, wondering if it can express very big numbers? Not sure should be processed left to right or right to left. :-)"
                    },
                    {
                        "username": "Itzprakhar",
                        "content": " my this code is giving correct answer in code editor but why it is showing incorrect answer here.. my \\n\\n`class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int sum;\\n       for(int i = 0; i<s.length(); i++ ){\\n           if(s[i] == \\'I\\'){\\n               sum = sum +1;\\n           }\\n           if(s[i] == \\'V\\'){\\n               sum = sum +5;\\n           }\\n           if(s[i] == \\'X\\'){\\n               sum = sum +10;\\n           }\\n           if(s[i] == \\'L\\'){\\n               sum = sum +50;\\n           }\\n           if(s[i] == \\'C\\'){\\n               sum = sum +100;\\n           }\\n           if(s[i] == \\'D\\'){\\n               sum = sum +500;\\n           }\\n           if(s[i] == \\'M\\'){\\n               sum = sum +1000;\\n           } \\n       }\\n       return sum;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "rocketz",
                        "content": "is it gonna give correct answer for 4 and 9?"
                    },
                    {
                        "username": "annecodess",
                        "content": "first problem is to always initialize sum to 0 if you would like to increment it."
                    },
                    {
                        "username": "parthvirana29",
                        "content": "Why is function declared as  \"def romanToInt(self, s)\" in python. What is the self?"
                    },
                    {
                        "username": "ibbu731",
                        "content": "my code is getting this error: TypeError: __init__() takes exactly 2 arguments (1 given)\\n    ret = Solution().romanToInt(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\\nwhat should I do"
                    },
                    {
                        "username": "bgc23",
                        "content": "Why is this code failing case 3?\\n\\nWhen given the string \"MCMXCIV\" the code first adds the value of M correctly, increments i, but then doesn\\'t recognize the final if condition check (C followed by M) and instead goes into the else block. \\n\\nI know the solution below isn\\'t ideal, but I want to understand why the logic isn\\'t working. \\n\\n`while(i+1 < size) {\\n                if((map[s[i]] == \\'I\\' && map[s[i+1]] == \\'V\\') || \\n                    (map[s[i]] == \\'I\\' && map[s[i+1]] == \\'X\\') ||\\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'L\\') || \\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'C\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'D\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'M\\')) {  \\n                \\n                    sum += (map[s[i+1]] - map[s[i]]);\\n                    i = i+2;\\n                }\\n                else {\\n                    sum += map[s[i]];\\n                    ++i;\\n                } \\n            }\\n            sum += map[s[i]];  `  "
                    },
                    {
                        "username": "Smorgleberry",
                        "content": "I\\'m guessing it can be assumed that these roman numerals are all valid in terms of the Roman numeral rules.  This meaning if a smaller symbol comes before a larger one you can always subtract it.  In the real system, which isn\\'t exactly defined here, a number to be subtracted must be within 2 symbols from what you are subtracting it from.  As an example the number 99 cannot be constructed like \"IC\" it must be built from \"L\" whereas the number 9 is \"IX\"."
                    },
                    {
                        "username": "manjaridhoundiyal",
                        "content": "Javascript Solution\\n\\nvar romanToInt = function(s) {\\n    let index=0;\\n    let count = 0;\\n    while(s.length > index){\\n        if(s[index] === \\'I\\' && s[index+1] === \\'V\\'){\\n            count = count + 4;\\n            index++;\\n        }\\n        else if(s[index] === \\'I\\' && s[index+1] === \\'X\\'){\\n            count = count + 9;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'L\\'){\\n            count = count + 40;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'C\\'){\\n            count = count + 90;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'D\\'){\\n            count = count + 400;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'M\\'){\\n            count = count + 900;\\n            index++;\\n        }\\n        else{\\n            count = count + symbolValue(s[index])\\n        }\\n        index++\\n    }\\n    return count\\n};\\n\\n\\nvar symbolValue = function(s) {\\n    switch(s){\\n        case \\'I\\':\\n            return 1;\\n        case \\'V\\':\\n            return 5;\\n        case \\'X\\':\\n            return 10;\\n        case \\'L\\':\\n            return 50;\\n        case \\'C\\':\\n            return 100;\\n        case \\'D\\':\\n            return 500;\\n        case \\'M\\':\\n            return 1000;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1746740,
                "content": [
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "i wrote a code but i am getting 2nd text case answer in 1st test case result and same with test case 2 and test case 3. no output for test case 3. same code works in another compiler ..how can i resolve this issue? "
                    },
                    {
                        "username": "MRZ16",
                        "content": "hi! this problem, it\\'s well"
                    },
                    {
                        "username": "Koura",
                        "content": "The solution is in this sentence: \\n\"Roman numerals are usually written largest to smallest from left to right\" \\uD83D\\uDE09\\n"
                    },
                    {
                        "username": "SnoopyDly",
                        "content": "Chewing about law of roman numbers, wondering if it can express very big numbers? Not sure should be processed left to right or right to left. :-)"
                    },
                    {
                        "username": "Itzprakhar",
                        "content": " my this code is giving correct answer in code editor but why it is showing incorrect answer here.. my \\n\\n`class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int sum;\\n       for(int i = 0; i<s.length(); i++ ){\\n           if(s[i] == \\'I\\'){\\n               sum = sum +1;\\n           }\\n           if(s[i] == \\'V\\'){\\n               sum = sum +5;\\n           }\\n           if(s[i] == \\'X\\'){\\n               sum = sum +10;\\n           }\\n           if(s[i] == \\'L\\'){\\n               sum = sum +50;\\n           }\\n           if(s[i] == \\'C\\'){\\n               sum = sum +100;\\n           }\\n           if(s[i] == \\'D\\'){\\n               sum = sum +500;\\n           }\\n           if(s[i] == \\'M\\'){\\n               sum = sum +1000;\\n           } \\n       }\\n       return sum;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "rocketz",
                        "content": "is it gonna give correct answer for 4 and 9?"
                    },
                    {
                        "username": "annecodess",
                        "content": "first problem is to always initialize sum to 0 if you would like to increment it."
                    },
                    {
                        "username": "parthvirana29",
                        "content": "Why is function declared as  \"def romanToInt(self, s)\" in python. What is the self?"
                    },
                    {
                        "username": "ibbu731",
                        "content": "my code is getting this error: TypeError: __init__() takes exactly 2 arguments (1 given)\\n    ret = Solution().romanToInt(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\\nwhat should I do"
                    },
                    {
                        "username": "bgc23",
                        "content": "Why is this code failing case 3?\\n\\nWhen given the string \"MCMXCIV\" the code first adds the value of M correctly, increments i, but then doesn\\'t recognize the final if condition check (C followed by M) and instead goes into the else block. \\n\\nI know the solution below isn\\'t ideal, but I want to understand why the logic isn\\'t working. \\n\\n`while(i+1 < size) {\\n                if((map[s[i]] == \\'I\\' && map[s[i+1]] == \\'V\\') || \\n                    (map[s[i]] == \\'I\\' && map[s[i+1]] == \\'X\\') ||\\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'L\\') || \\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'C\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'D\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'M\\')) {  \\n                \\n                    sum += (map[s[i+1]] - map[s[i]]);\\n                    i = i+2;\\n                }\\n                else {\\n                    sum += map[s[i]];\\n                    ++i;\\n                } \\n            }\\n            sum += map[s[i]];  `  "
                    },
                    {
                        "username": "Smorgleberry",
                        "content": "I\\'m guessing it can be assumed that these roman numerals are all valid in terms of the Roman numeral rules.  This meaning if a smaller symbol comes before a larger one you can always subtract it.  In the real system, which isn\\'t exactly defined here, a number to be subtracted must be within 2 symbols from what you are subtracting it from.  As an example the number 99 cannot be constructed like \"IC\" it must be built from \"L\" whereas the number 9 is \"IX\"."
                    },
                    {
                        "username": "manjaridhoundiyal",
                        "content": "Javascript Solution\\n\\nvar romanToInt = function(s) {\\n    let index=0;\\n    let count = 0;\\n    while(s.length > index){\\n        if(s[index] === \\'I\\' && s[index+1] === \\'V\\'){\\n            count = count + 4;\\n            index++;\\n        }\\n        else if(s[index] === \\'I\\' && s[index+1] === \\'X\\'){\\n            count = count + 9;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'L\\'){\\n            count = count + 40;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'C\\'){\\n            count = count + 90;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'D\\'){\\n            count = count + 400;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'M\\'){\\n            count = count + 900;\\n            index++;\\n        }\\n        else{\\n            count = count + symbolValue(s[index])\\n        }\\n        index++\\n    }\\n    return count\\n};\\n\\n\\nvar symbolValue = function(s) {\\n    switch(s){\\n        case \\'I\\':\\n            return 1;\\n        case \\'V\\':\\n            return 5;\\n        case \\'X\\':\\n            return 10;\\n        case \\'L\\':\\n            return 50;\\n        case \\'C\\':\\n            return 100;\\n        case \\'D\\':\\n            return 500;\\n        case \\'M\\':\\n            return 1000;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1746000,
                "content": [
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "i wrote a code but i am getting 2nd text case answer in 1st test case result and same with test case 2 and test case 3. no output for test case 3. same code works in another compiler ..how can i resolve this issue? "
                    },
                    {
                        "username": "MRZ16",
                        "content": "hi! this problem, it\\'s well"
                    },
                    {
                        "username": "Koura",
                        "content": "The solution is in this sentence: \\n\"Roman numerals are usually written largest to smallest from left to right\" \\uD83D\\uDE09\\n"
                    },
                    {
                        "username": "SnoopyDly",
                        "content": "Chewing about law of roman numbers, wondering if it can express very big numbers? Not sure should be processed left to right or right to left. :-)"
                    },
                    {
                        "username": "Itzprakhar",
                        "content": " my this code is giving correct answer in code editor but why it is showing incorrect answer here.. my \\n\\n`class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int sum;\\n       for(int i = 0; i<s.length(); i++ ){\\n           if(s[i] == \\'I\\'){\\n               sum = sum +1;\\n           }\\n           if(s[i] == \\'V\\'){\\n               sum = sum +5;\\n           }\\n           if(s[i] == \\'X\\'){\\n               sum = sum +10;\\n           }\\n           if(s[i] == \\'L\\'){\\n               sum = sum +50;\\n           }\\n           if(s[i] == \\'C\\'){\\n               sum = sum +100;\\n           }\\n           if(s[i] == \\'D\\'){\\n               sum = sum +500;\\n           }\\n           if(s[i] == \\'M\\'){\\n               sum = sum +1000;\\n           } \\n       }\\n       return sum;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "rocketz",
                        "content": "is it gonna give correct answer for 4 and 9?"
                    },
                    {
                        "username": "annecodess",
                        "content": "first problem is to always initialize sum to 0 if you would like to increment it."
                    },
                    {
                        "username": "parthvirana29",
                        "content": "Why is function declared as  \"def romanToInt(self, s)\" in python. What is the self?"
                    },
                    {
                        "username": "ibbu731",
                        "content": "my code is getting this error: TypeError: __init__() takes exactly 2 arguments (1 given)\\n    ret = Solution().romanToInt(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\\nwhat should I do"
                    },
                    {
                        "username": "bgc23",
                        "content": "Why is this code failing case 3?\\n\\nWhen given the string \"MCMXCIV\" the code first adds the value of M correctly, increments i, but then doesn\\'t recognize the final if condition check (C followed by M) and instead goes into the else block. \\n\\nI know the solution below isn\\'t ideal, but I want to understand why the logic isn\\'t working. \\n\\n`while(i+1 < size) {\\n                if((map[s[i]] == \\'I\\' && map[s[i+1]] == \\'V\\') || \\n                    (map[s[i]] == \\'I\\' && map[s[i+1]] == \\'X\\') ||\\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'L\\') || \\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'C\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'D\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'M\\')) {  \\n                \\n                    sum += (map[s[i+1]] - map[s[i]]);\\n                    i = i+2;\\n                }\\n                else {\\n                    sum += map[s[i]];\\n                    ++i;\\n                } \\n            }\\n            sum += map[s[i]];  `  "
                    },
                    {
                        "username": "Smorgleberry",
                        "content": "I\\'m guessing it can be assumed that these roman numerals are all valid in terms of the Roman numeral rules.  This meaning if a smaller symbol comes before a larger one you can always subtract it.  In the real system, which isn\\'t exactly defined here, a number to be subtracted must be within 2 symbols from what you are subtracting it from.  As an example the number 99 cannot be constructed like \"IC\" it must be built from \"L\" whereas the number 9 is \"IX\"."
                    },
                    {
                        "username": "manjaridhoundiyal",
                        "content": "Javascript Solution\\n\\nvar romanToInt = function(s) {\\n    let index=0;\\n    let count = 0;\\n    while(s.length > index){\\n        if(s[index] === \\'I\\' && s[index+1] === \\'V\\'){\\n            count = count + 4;\\n            index++;\\n        }\\n        else if(s[index] === \\'I\\' && s[index+1] === \\'X\\'){\\n            count = count + 9;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'L\\'){\\n            count = count + 40;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'C\\'){\\n            count = count + 90;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'D\\'){\\n            count = count + 400;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'M\\'){\\n            count = count + 900;\\n            index++;\\n        }\\n        else{\\n            count = count + symbolValue(s[index])\\n        }\\n        index++\\n    }\\n    return count\\n};\\n\\n\\nvar symbolValue = function(s) {\\n    switch(s){\\n        case \\'I\\':\\n            return 1;\\n        case \\'V\\':\\n            return 5;\\n        case \\'X\\':\\n            return 10;\\n        case \\'L\\':\\n            return 50;\\n        case \\'C\\':\\n            return 100;\\n        case \\'D\\':\\n            return 500;\\n        case \\'M\\':\\n            return 1000;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1745562,
                "content": [
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "i wrote a code but i am getting 2nd text case answer in 1st test case result and same with test case 2 and test case 3. no output for test case 3. same code works in another compiler ..how can i resolve this issue? "
                    },
                    {
                        "username": "MRZ16",
                        "content": "hi! this problem, it\\'s well"
                    },
                    {
                        "username": "Koura",
                        "content": "The solution is in this sentence: \\n\"Roman numerals are usually written largest to smallest from left to right\" \\uD83D\\uDE09\\n"
                    },
                    {
                        "username": "SnoopyDly",
                        "content": "Chewing about law of roman numbers, wondering if it can express very big numbers? Not sure should be processed left to right or right to left. :-)"
                    },
                    {
                        "username": "Itzprakhar",
                        "content": " my this code is giving correct answer in code editor but why it is showing incorrect answer here.. my \\n\\n`class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int sum;\\n       for(int i = 0; i<s.length(); i++ ){\\n           if(s[i] == \\'I\\'){\\n               sum = sum +1;\\n           }\\n           if(s[i] == \\'V\\'){\\n               sum = sum +5;\\n           }\\n           if(s[i] == \\'X\\'){\\n               sum = sum +10;\\n           }\\n           if(s[i] == \\'L\\'){\\n               sum = sum +50;\\n           }\\n           if(s[i] == \\'C\\'){\\n               sum = sum +100;\\n           }\\n           if(s[i] == \\'D\\'){\\n               sum = sum +500;\\n           }\\n           if(s[i] == \\'M\\'){\\n               sum = sum +1000;\\n           } \\n       }\\n       return sum;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "rocketz",
                        "content": "is it gonna give correct answer for 4 and 9?"
                    },
                    {
                        "username": "annecodess",
                        "content": "first problem is to always initialize sum to 0 if you would like to increment it."
                    },
                    {
                        "username": "parthvirana29",
                        "content": "Why is function declared as  \"def romanToInt(self, s)\" in python. What is the self?"
                    },
                    {
                        "username": "ibbu731",
                        "content": "my code is getting this error: TypeError: __init__() takes exactly 2 arguments (1 given)\\n    ret = Solution().romanToInt(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\\nwhat should I do"
                    },
                    {
                        "username": "bgc23",
                        "content": "Why is this code failing case 3?\\n\\nWhen given the string \"MCMXCIV\" the code first adds the value of M correctly, increments i, but then doesn\\'t recognize the final if condition check (C followed by M) and instead goes into the else block. \\n\\nI know the solution below isn\\'t ideal, but I want to understand why the logic isn\\'t working. \\n\\n`while(i+1 < size) {\\n                if((map[s[i]] == \\'I\\' && map[s[i+1]] == \\'V\\') || \\n                    (map[s[i]] == \\'I\\' && map[s[i+1]] == \\'X\\') ||\\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'L\\') || \\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'C\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'D\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'M\\')) {  \\n                \\n                    sum += (map[s[i+1]] - map[s[i]]);\\n                    i = i+2;\\n                }\\n                else {\\n                    sum += map[s[i]];\\n                    ++i;\\n                } \\n            }\\n            sum += map[s[i]];  `  "
                    },
                    {
                        "username": "Smorgleberry",
                        "content": "I\\'m guessing it can be assumed that these roman numerals are all valid in terms of the Roman numeral rules.  This meaning if a smaller symbol comes before a larger one you can always subtract it.  In the real system, which isn\\'t exactly defined here, a number to be subtracted must be within 2 symbols from what you are subtracting it from.  As an example the number 99 cannot be constructed like \"IC\" it must be built from \"L\" whereas the number 9 is \"IX\"."
                    },
                    {
                        "username": "manjaridhoundiyal",
                        "content": "Javascript Solution\\n\\nvar romanToInt = function(s) {\\n    let index=0;\\n    let count = 0;\\n    while(s.length > index){\\n        if(s[index] === \\'I\\' && s[index+1] === \\'V\\'){\\n            count = count + 4;\\n            index++;\\n        }\\n        else if(s[index] === \\'I\\' && s[index+1] === \\'X\\'){\\n            count = count + 9;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'L\\'){\\n            count = count + 40;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'C\\'){\\n            count = count + 90;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'D\\'){\\n            count = count + 400;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'M\\'){\\n            count = count + 900;\\n            index++;\\n        }\\n        else{\\n            count = count + symbolValue(s[index])\\n        }\\n        index++\\n    }\\n    return count\\n};\\n\\n\\nvar symbolValue = function(s) {\\n    switch(s){\\n        case \\'I\\':\\n            return 1;\\n        case \\'V\\':\\n            return 5;\\n        case \\'X\\':\\n            return 10;\\n        case \\'L\\':\\n            return 50;\\n        case \\'C\\':\\n            return 100;\\n        case \\'D\\':\\n            return 500;\\n        case \\'M\\':\\n            return 1000;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1743982,
                "content": [
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "i wrote a code but i am getting 2nd text case answer in 1st test case result and same with test case 2 and test case 3. no output for test case 3. same code works in another compiler ..how can i resolve this issue? "
                    },
                    {
                        "username": "MRZ16",
                        "content": "hi! this problem, it\\'s well"
                    },
                    {
                        "username": "Koura",
                        "content": "The solution is in this sentence: \\n\"Roman numerals are usually written largest to smallest from left to right\" \\uD83D\\uDE09\\n"
                    },
                    {
                        "username": "SnoopyDly",
                        "content": "Chewing about law of roman numbers, wondering if it can express very big numbers? Not sure should be processed left to right or right to left. :-)"
                    },
                    {
                        "username": "Itzprakhar",
                        "content": " my this code is giving correct answer in code editor but why it is showing incorrect answer here.. my \\n\\n`class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int sum;\\n       for(int i = 0; i<s.length(); i++ ){\\n           if(s[i] == \\'I\\'){\\n               sum = sum +1;\\n           }\\n           if(s[i] == \\'V\\'){\\n               sum = sum +5;\\n           }\\n           if(s[i] == \\'X\\'){\\n               sum = sum +10;\\n           }\\n           if(s[i] == \\'L\\'){\\n               sum = sum +50;\\n           }\\n           if(s[i] == \\'C\\'){\\n               sum = sum +100;\\n           }\\n           if(s[i] == \\'D\\'){\\n               sum = sum +500;\\n           }\\n           if(s[i] == \\'M\\'){\\n               sum = sum +1000;\\n           } \\n       }\\n       return sum;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "rocketz",
                        "content": "is it gonna give correct answer for 4 and 9?"
                    },
                    {
                        "username": "annecodess",
                        "content": "first problem is to always initialize sum to 0 if you would like to increment it."
                    },
                    {
                        "username": "parthvirana29",
                        "content": "Why is function declared as  \"def romanToInt(self, s)\" in python. What is the self?"
                    },
                    {
                        "username": "ibbu731",
                        "content": "my code is getting this error: TypeError: __init__() takes exactly 2 arguments (1 given)\\n    ret = Solution().romanToInt(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\\nwhat should I do"
                    },
                    {
                        "username": "bgc23",
                        "content": "Why is this code failing case 3?\\n\\nWhen given the string \"MCMXCIV\" the code first adds the value of M correctly, increments i, but then doesn\\'t recognize the final if condition check (C followed by M) and instead goes into the else block. \\n\\nI know the solution below isn\\'t ideal, but I want to understand why the logic isn\\'t working. \\n\\n`while(i+1 < size) {\\n                if((map[s[i]] == \\'I\\' && map[s[i+1]] == \\'V\\') || \\n                    (map[s[i]] == \\'I\\' && map[s[i+1]] == \\'X\\') ||\\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'L\\') || \\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'C\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'D\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'M\\')) {  \\n                \\n                    sum += (map[s[i+1]] - map[s[i]]);\\n                    i = i+2;\\n                }\\n                else {\\n                    sum += map[s[i]];\\n                    ++i;\\n                } \\n            }\\n            sum += map[s[i]];  `  "
                    },
                    {
                        "username": "Smorgleberry",
                        "content": "I\\'m guessing it can be assumed that these roman numerals are all valid in terms of the Roman numeral rules.  This meaning if a smaller symbol comes before a larger one you can always subtract it.  In the real system, which isn\\'t exactly defined here, a number to be subtracted must be within 2 symbols from what you are subtracting it from.  As an example the number 99 cannot be constructed like \"IC\" it must be built from \"L\" whereas the number 9 is \"IX\"."
                    },
                    {
                        "username": "manjaridhoundiyal",
                        "content": "Javascript Solution\\n\\nvar romanToInt = function(s) {\\n    let index=0;\\n    let count = 0;\\n    while(s.length > index){\\n        if(s[index] === \\'I\\' && s[index+1] === \\'V\\'){\\n            count = count + 4;\\n            index++;\\n        }\\n        else if(s[index] === \\'I\\' && s[index+1] === \\'X\\'){\\n            count = count + 9;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'L\\'){\\n            count = count + 40;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'C\\'){\\n            count = count + 90;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'D\\'){\\n            count = count + 400;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'M\\'){\\n            count = count + 900;\\n            index++;\\n        }\\n        else{\\n            count = count + symbolValue(s[index])\\n        }\\n        index++\\n    }\\n    return count\\n};\\n\\n\\nvar symbolValue = function(s) {\\n    switch(s){\\n        case \\'I\\':\\n            return 1;\\n        case \\'V\\':\\n            return 5;\\n        case \\'X\\':\\n            return 10;\\n        case \\'L\\':\\n            return 50;\\n        case \\'C\\':\\n            return 100;\\n        case \\'D\\':\\n            return 500;\\n        case \\'M\\':\\n            return 1000;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1743542,
                "content": [
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "i wrote a code but i am getting 2nd text case answer in 1st test case result and same with test case 2 and test case 3. no output for test case 3. same code works in another compiler ..how can i resolve this issue? "
                    },
                    {
                        "username": "MRZ16",
                        "content": "hi! this problem, it\\'s well"
                    },
                    {
                        "username": "Koura",
                        "content": "The solution is in this sentence: \\n\"Roman numerals are usually written largest to smallest from left to right\" \\uD83D\\uDE09\\n"
                    },
                    {
                        "username": "SnoopyDly",
                        "content": "Chewing about law of roman numbers, wondering if it can express very big numbers? Not sure should be processed left to right or right to left. :-)"
                    },
                    {
                        "username": "Itzprakhar",
                        "content": " my this code is giving correct answer in code editor but why it is showing incorrect answer here.. my \\n\\n`class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int sum;\\n       for(int i = 0; i<s.length(); i++ ){\\n           if(s[i] == \\'I\\'){\\n               sum = sum +1;\\n           }\\n           if(s[i] == \\'V\\'){\\n               sum = sum +5;\\n           }\\n           if(s[i] == \\'X\\'){\\n               sum = sum +10;\\n           }\\n           if(s[i] == \\'L\\'){\\n               sum = sum +50;\\n           }\\n           if(s[i] == \\'C\\'){\\n               sum = sum +100;\\n           }\\n           if(s[i] == \\'D\\'){\\n               sum = sum +500;\\n           }\\n           if(s[i] == \\'M\\'){\\n               sum = sum +1000;\\n           } \\n       }\\n       return sum;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "rocketz",
                        "content": "is it gonna give correct answer for 4 and 9?"
                    },
                    {
                        "username": "annecodess",
                        "content": "first problem is to always initialize sum to 0 if you would like to increment it."
                    },
                    {
                        "username": "parthvirana29",
                        "content": "Why is function declared as  \"def romanToInt(self, s)\" in python. What is the self?"
                    },
                    {
                        "username": "ibbu731",
                        "content": "my code is getting this error: TypeError: __init__() takes exactly 2 arguments (1 given)\\n    ret = Solution().romanToInt(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\\nwhat should I do"
                    },
                    {
                        "username": "bgc23",
                        "content": "Why is this code failing case 3?\\n\\nWhen given the string \"MCMXCIV\" the code first adds the value of M correctly, increments i, but then doesn\\'t recognize the final if condition check (C followed by M) and instead goes into the else block. \\n\\nI know the solution below isn\\'t ideal, but I want to understand why the logic isn\\'t working. \\n\\n`while(i+1 < size) {\\n                if((map[s[i]] == \\'I\\' && map[s[i+1]] == \\'V\\') || \\n                    (map[s[i]] == \\'I\\' && map[s[i+1]] == \\'X\\') ||\\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'L\\') || \\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'C\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'D\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'M\\')) {  \\n                \\n                    sum += (map[s[i+1]] - map[s[i]]);\\n                    i = i+2;\\n                }\\n                else {\\n                    sum += map[s[i]];\\n                    ++i;\\n                } \\n            }\\n            sum += map[s[i]];  `  "
                    },
                    {
                        "username": "Smorgleberry",
                        "content": "I\\'m guessing it can be assumed that these roman numerals are all valid in terms of the Roman numeral rules.  This meaning if a smaller symbol comes before a larger one you can always subtract it.  In the real system, which isn\\'t exactly defined here, a number to be subtracted must be within 2 symbols from what you are subtracting it from.  As an example the number 99 cannot be constructed like \"IC\" it must be built from \"L\" whereas the number 9 is \"IX\"."
                    },
                    {
                        "username": "manjaridhoundiyal",
                        "content": "Javascript Solution\\n\\nvar romanToInt = function(s) {\\n    let index=0;\\n    let count = 0;\\n    while(s.length > index){\\n        if(s[index] === \\'I\\' && s[index+1] === \\'V\\'){\\n            count = count + 4;\\n            index++;\\n        }\\n        else if(s[index] === \\'I\\' && s[index+1] === \\'X\\'){\\n            count = count + 9;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'L\\'){\\n            count = count + 40;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'C\\'){\\n            count = count + 90;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'D\\'){\\n            count = count + 400;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'M\\'){\\n            count = count + 900;\\n            index++;\\n        }\\n        else{\\n            count = count + symbolValue(s[index])\\n        }\\n        index++\\n    }\\n    return count\\n};\\n\\n\\nvar symbolValue = function(s) {\\n    switch(s){\\n        case \\'I\\':\\n            return 1;\\n        case \\'V\\':\\n            return 5;\\n        case \\'X\\':\\n            return 10;\\n        case \\'L\\':\\n            return 50;\\n        case \\'C\\':\\n            return 100;\\n        case \\'D\\':\\n            return 500;\\n        case \\'M\\':\\n            return 1000;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1743184,
                "content": [
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "i wrote a code but i am getting 2nd text case answer in 1st test case result and same with test case 2 and test case 3. no output for test case 3. same code works in another compiler ..how can i resolve this issue? "
                    },
                    {
                        "username": "MRZ16",
                        "content": "hi! this problem, it\\'s well"
                    },
                    {
                        "username": "Koura",
                        "content": "The solution is in this sentence: \\n\"Roman numerals are usually written largest to smallest from left to right\" \\uD83D\\uDE09\\n"
                    },
                    {
                        "username": "SnoopyDly",
                        "content": "Chewing about law of roman numbers, wondering if it can express very big numbers? Not sure should be processed left to right or right to left. :-)"
                    },
                    {
                        "username": "Itzprakhar",
                        "content": " my this code is giving correct answer in code editor but why it is showing incorrect answer here.. my \\n\\n`class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int sum;\\n       for(int i = 0; i<s.length(); i++ ){\\n           if(s[i] == \\'I\\'){\\n               sum = sum +1;\\n           }\\n           if(s[i] == \\'V\\'){\\n               sum = sum +5;\\n           }\\n           if(s[i] == \\'X\\'){\\n               sum = sum +10;\\n           }\\n           if(s[i] == \\'L\\'){\\n               sum = sum +50;\\n           }\\n           if(s[i] == \\'C\\'){\\n               sum = sum +100;\\n           }\\n           if(s[i] == \\'D\\'){\\n               sum = sum +500;\\n           }\\n           if(s[i] == \\'M\\'){\\n               sum = sum +1000;\\n           } \\n       }\\n       return sum;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "rocketz",
                        "content": "is it gonna give correct answer for 4 and 9?"
                    },
                    {
                        "username": "annecodess",
                        "content": "first problem is to always initialize sum to 0 if you would like to increment it."
                    },
                    {
                        "username": "parthvirana29",
                        "content": "Why is function declared as  \"def romanToInt(self, s)\" in python. What is the self?"
                    },
                    {
                        "username": "ibbu731",
                        "content": "my code is getting this error: TypeError: __init__() takes exactly 2 arguments (1 given)\\n    ret = Solution().romanToInt(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\\nwhat should I do"
                    },
                    {
                        "username": "bgc23",
                        "content": "Why is this code failing case 3?\\n\\nWhen given the string \"MCMXCIV\" the code first adds the value of M correctly, increments i, but then doesn\\'t recognize the final if condition check (C followed by M) and instead goes into the else block. \\n\\nI know the solution below isn\\'t ideal, but I want to understand why the logic isn\\'t working. \\n\\n`while(i+1 < size) {\\n                if((map[s[i]] == \\'I\\' && map[s[i+1]] == \\'V\\') || \\n                    (map[s[i]] == \\'I\\' && map[s[i+1]] == \\'X\\') ||\\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'L\\') || \\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'C\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'D\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'M\\')) {  \\n                \\n                    sum += (map[s[i+1]] - map[s[i]]);\\n                    i = i+2;\\n                }\\n                else {\\n                    sum += map[s[i]];\\n                    ++i;\\n                } \\n            }\\n            sum += map[s[i]];  `  "
                    },
                    {
                        "username": "Smorgleberry",
                        "content": "I\\'m guessing it can be assumed that these roman numerals are all valid in terms of the Roman numeral rules.  This meaning if a smaller symbol comes before a larger one you can always subtract it.  In the real system, which isn\\'t exactly defined here, a number to be subtracted must be within 2 symbols from what you are subtracting it from.  As an example the number 99 cannot be constructed like \"IC\" it must be built from \"L\" whereas the number 9 is \"IX\"."
                    },
                    {
                        "username": "manjaridhoundiyal",
                        "content": "Javascript Solution\\n\\nvar romanToInt = function(s) {\\n    let index=0;\\n    let count = 0;\\n    while(s.length > index){\\n        if(s[index] === \\'I\\' && s[index+1] === \\'V\\'){\\n            count = count + 4;\\n            index++;\\n        }\\n        else if(s[index] === \\'I\\' && s[index+1] === \\'X\\'){\\n            count = count + 9;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'L\\'){\\n            count = count + 40;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'C\\'){\\n            count = count + 90;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'D\\'){\\n            count = count + 400;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'M\\'){\\n            count = count + 900;\\n            index++;\\n        }\\n        else{\\n            count = count + symbolValue(s[index])\\n        }\\n        index++\\n    }\\n    return count\\n};\\n\\n\\nvar symbolValue = function(s) {\\n    switch(s){\\n        case \\'I\\':\\n            return 1;\\n        case \\'V\\':\\n            return 5;\\n        case \\'X\\':\\n            return 10;\\n        case \\'L\\':\\n            return 50;\\n        case \\'C\\':\\n            return 100;\\n        case \\'D\\':\\n            return 500;\\n        case \\'M\\':\\n            return 1000;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1742308,
                "content": [
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "i wrote a code but i am getting 2nd text case answer in 1st test case result and same with test case 2 and test case 3. no output for test case 3. same code works in another compiler ..how can i resolve this issue? "
                    },
                    {
                        "username": "MRZ16",
                        "content": "hi! this problem, it\\'s well"
                    },
                    {
                        "username": "Koura",
                        "content": "The solution is in this sentence: \\n\"Roman numerals are usually written largest to smallest from left to right\" \\uD83D\\uDE09\\n"
                    },
                    {
                        "username": "SnoopyDly",
                        "content": "Chewing about law of roman numbers, wondering if it can express very big numbers? Not sure should be processed left to right or right to left. :-)"
                    },
                    {
                        "username": "Itzprakhar",
                        "content": " my this code is giving correct answer in code editor but why it is showing incorrect answer here.. my \\n\\n`class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int sum;\\n       for(int i = 0; i<s.length(); i++ ){\\n           if(s[i] == \\'I\\'){\\n               sum = sum +1;\\n           }\\n           if(s[i] == \\'V\\'){\\n               sum = sum +5;\\n           }\\n           if(s[i] == \\'X\\'){\\n               sum = sum +10;\\n           }\\n           if(s[i] == \\'L\\'){\\n               sum = sum +50;\\n           }\\n           if(s[i] == \\'C\\'){\\n               sum = sum +100;\\n           }\\n           if(s[i] == \\'D\\'){\\n               sum = sum +500;\\n           }\\n           if(s[i] == \\'M\\'){\\n               sum = sum +1000;\\n           } \\n       }\\n       return sum;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "rocketz",
                        "content": "is it gonna give correct answer for 4 and 9?"
                    },
                    {
                        "username": "annecodess",
                        "content": "first problem is to always initialize sum to 0 if you would like to increment it."
                    },
                    {
                        "username": "parthvirana29",
                        "content": "Why is function declared as  \"def romanToInt(self, s)\" in python. What is the self?"
                    },
                    {
                        "username": "ibbu731",
                        "content": "my code is getting this error: TypeError: __init__() takes exactly 2 arguments (1 given)\\n    ret = Solution().romanToInt(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\\nwhat should I do"
                    },
                    {
                        "username": "bgc23",
                        "content": "Why is this code failing case 3?\\n\\nWhen given the string \"MCMXCIV\" the code first adds the value of M correctly, increments i, but then doesn\\'t recognize the final if condition check (C followed by M) and instead goes into the else block. \\n\\nI know the solution below isn\\'t ideal, but I want to understand why the logic isn\\'t working. \\n\\n`while(i+1 < size) {\\n                if((map[s[i]] == \\'I\\' && map[s[i+1]] == \\'V\\') || \\n                    (map[s[i]] == \\'I\\' && map[s[i+1]] == \\'X\\') ||\\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'L\\') || \\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'C\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'D\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'M\\')) {  \\n                \\n                    sum += (map[s[i+1]] - map[s[i]]);\\n                    i = i+2;\\n                }\\n                else {\\n                    sum += map[s[i]];\\n                    ++i;\\n                } \\n            }\\n            sum += map[s[i]];  `  "
                    },
                    {
                        "username": "Smorgleberry",
                        "content": "I\\'m guessing it can be assumed that these roman numerals are all valid in terms of the Roman numeral rules.  This meaning if a smaller symbol comes before a larger one you can always subtract it.  In the real system, which isn\\'t exactly defined here, a number to be subtracted must be within 2 symbols from what you are subtracting it from.  As an example the number 99 cannot be constructed like \"IC\" it must be built from \"L\" whereas the number 9 is \"IX\"."
                    },
                    {
                        "username": "manjaridhoundiyal",
                        "content": "Javascript Solution\\n\\nvar romanToInt = function(s) {\\n    let index=0;\\n    let count = 0;\\n    while(s.length > index){\\n        if(s[index] === \\'I\\' && s[index+1] === \\'V\\'){\\n            count = count + 4;\\n            index++;\\n        }\\n        else if(s[index] === \\'I\\' && s[index+1] === \\'X\\'){\\n            count = count + 9;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'L\\'){\\n            count = count + 40;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'C\\'){\\n            count = count + 90;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'D\\'){\\n            count = count + 400;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'M\\'){\\n            count = count + 900;\\n            index++;\\n        }\\n        else{\\n            count = count + symbolValue(s[index])\\n        }\\n        index++\\n    }\\n    return count\\n};\\n\\n\\nvar symbolValue = function(s) {\\n    switch(s){\\n        case \\'I\\':\\n            return 1;\\n        case \\'V\\':\\n            return 5;\\n        case \\'X\\':\\n            return 10;\\n        case \\'L\\':\\n            return 50;\\n        case \\'C\\':\\n            return 100;\\n        case \\'D\\':\\n            return 500;\\n        case \\'M\\':\\n            return 1000;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1742049,
                "content": [
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "i wrote a code but i am getting 2nd text case answer in 1st test case result and same with test case 2 and test case 3. no output for test case 3. same code works in another compiler ..how can i resolve this issue? "
                    },
                    {
                        "username": "MRZ16",
                        "content": "hi! this problem, it\\'s well"
                    },
                    {
                        "username": "Koura",
                        "content": "The solution is in this sentence: \\n\"Roman numerals are usually written largest to smallest from left to right\" \\uD83D\\uDE09\\n"
                    },
                    {
                        "username": "SnoopyDly",
                        "content": "Chewing about law of roman numbers, wondering if it can express very big numbers? Not sure should be processed left to right or right to left. :-)"
                    },
                    {
                        "username": "Itzprakhar",
                        "content": " my this code is giving correct answer in code editor but why it is showing incorrect answer here.. my \\n\\n`class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int sum;\\n       for(int i = 0; i<s.length(); i++ ){\\n           if(s[i] == \\'I\\'){\\n               sum = sum +1;\\n           }\\n           if(s[i] == \\'V\\'){\\n               sum = sum +5;\\n           }\\n           if(s[i] == \\'X\\'){\\n               sum = sum +10;\\n           }\\n           if(s[i] == \\'L\\'){\\n               sum = sum +50;\\n           }\\n           if(s[i] == \\'C\\'){\\n               sum = sum +100;\\n           }\\n           if(s[i] == \\'D\\'){\\n               sum = sum +500;\\n           }\\n           if(s[i] == \\'M\\'){\\n               sum = sum +1000;\\n           } \\n       }\\n       return sum;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "rocketz",
                        "content": "is it gonna give correct answer for 4 and 9?"
                    },
                    {
                        "username": "annecodess",
                        "content": "first problem is to always initialize sum to 0 if you would like to increment it."
                    },
                    {
                        "username": "parthvirana29",
                        "content": "Why is function declared as  \"def romanToInt(self, s)\" in python. What is the self?"
                    },
                    {
                        "username": "ibbu731",
                        "content": "my code is getting this error: TypeError: __init__() takes exactly 2 arguments (1 given)\\n    ret = Solution().romanToInt(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\\nwhat should I do"
                    },
                    {
                        "username": "bgc23",
                        "content": "Why is this code failing case 3?\\n\\nWhen given the string \"MCMXCIV\" the code first adds the value of M correctly, increments i, but then doesn\\'t recognize the final if condition check (C followed by M) and instead goes into the else block. \\n\\nI know the solution below isn\\'t ideal, but I want to understand why the logic isn\\'t working. \\n\\n`while(i+1 < size) {\\n                if((map[s[i]] == \\'I\\' && map[s[i+1]] == \\'V\\') || \\n                    (map[s[i]] == \\'I\\' && map[s[i+1]] == \\'X\\') ||\\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'L\\') || \\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'C\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'D\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'M\\')) {  \\n                \\n                    sum += (map[s[i+1]] - map[s[i]]);\\n                    i = i+2;\\n                }\\n                else {\\n                    sum += map[s[i]];\\n                    ++i;\\n                } \\n            }\\n            sum += map[s[i]];  `  "
                    },
                    {
                        "username": "Smorgleberry",
                        "content": "I\\'m guessing it can be assumed that these roman numerals are all valid in terms of the Roman numeral rules.  This meaning if a smaller symbol comes before a larger one you can always subtract it.  In the real system, which isn\\'t exactly defined here, a number to be subtracted must be within 2 symbols from what you are subtracting it from.  As an example the number 99 cannot be constructed like \"IC\" it must be built from \"L\" whereas the number 9 is \"IX\"."
                    },
                    {
                        "username": "manjaridhoundiyal",
                        "content": "Javascript Solution\\n\\nvar romanToInt = function(s) {\\n    let index=0;\\n    let count = 0;\\n    while(s.length > index){\\n        if(s[index] === \\'I\\' && s[index+1] === \\'V\\'){\\n            count = count + 4;\\n            index++;\\n        }\\n        else if(s[index] === \\'I\\' && s[index+1] === \\'X\\'){\\n            count = count + 9;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'L\\'){\\n            count = count + 40;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'C\\'){\\n            count = count + 90;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'D\\'){\\n            count = count + 400;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'M\\'){\\n            count = count + 900;\\n            index++;\\n        }\\n        else{\\n            count = count + symbolValue(s[index])\\n        }\\n        index++\\n    }\\n    return count\\n};\\n\\n\\nvar symbolValue = function(s) {\\n    switch(s){\\n        case \\'I\\':\\n            return 1;\\n        case \\'V\\':\\n            return 5;\\n        case \\'X\\':\\n            return 10;\\n        case \\'L\\':\\n            return 50;\\n        case \\'C\\':\\n            return 100;\\n        case \\'D\\':\\n            return 500;\\n        case \\'M\\':\\n            return 1000;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1739358,
                "content": [
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "i wrote a code but i am getting 2nd text case answer in 1st test case result and same with test case 2 and test case 3. no output for test case 3. same code works in another compiler ..how can i resolve this issue? "
                    },
                    {
                        "username": "MRZ16",
                        "content": "hi! this problem, it\\'s well"
                    },
                    {
                        "username": "Koura",
                        "content": "The solution is in this sentence: \\n\"Roman numerals are usually written largest to smallest from left to right\" \\uD83D\\uDE09\\n"
                    },
                    {
                        "username": "SnoopyDly",
                        "content": "Chewing about law of roman numbers, wondering if it can express very big numbers? Not sure should be processed left to right or right to left. :-)"
                    },
                    {
                        "username": "Itzprakhar",
                        "content": " my this code is giving correct answer in code editor but why it is showing incorrect answer here.. my \\n\\n`class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int sum;\\n       for(int i = 0; i<s.length(); i++ ){\\n           if(s[i] == \\'I\\'){\\n               sum = sum +1;\\n           }\\n           if(s[i] == \\'V\\'){\\n               sum = sum +5;\\n           }\\n           if(s[i] == \\'X\\'){\\n               sum = sum +10;\\n           }\\n           if(s[i] == \\'L\\'){\\n               sum = sum +50;\\n           }\\n           if(s[i] == \\'C\\'){\\n               sum = sum +100;\\n           }\\n           if(s[i] == \\'D\\'){\\n               sum = sum +500;\\n           }\\n           if(s[i] == \\'M\\'){\\n               sum = sum +1000;\\n           } \\n       }\\n       return sum;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "rocketz",
                        "content": "is it gonna give correct answer for 4 and 9?"
                    },
                    {
                        "username": "annecodess",
                        "content": "first problem is to always initialize sum to 0 if you would like to increment it."
                    },
                    {
                        "username": "parthvirana29",
                        "content": "Why is function declared as  \"def romanToInt(self, s)\" in python. What is the self?"
                    },
                    {
                        "username": "ibbu731",
                        "content": "my code is getting this error: TypeError: __init__() takes exactly 2 arguments (1 given)\\n    ret = Solution().romanToInt(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\\nwhat should I do"
                    },
                    {
                        "username": "bgc23",
                        "content": "Why is this code failing case 3?\\n\\nWhen given the string \"MCMXCIV\" the code first adds the value of M correctly, increments i, but then doesn\\'t recognize the final if condition check (C followed by M) and instead goes into the else block. \\n\\nI know the solution below isn\\'t ideal, but I want to understand why the logic isn\\'t working. \\n\\n`while(i+1 < size) {\\n                if((map[s[i]] == \\'I\\' && map[s[i+1]] == \\'V\\') || \\n                    (map[s[i]] == \\'I\\' && map[s[i+1]] == \\'X\\') ||\\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'L\\') || \\n                    (map[s[i]] == \\'X\\' && map[s[i+1]] == \\'C\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'D\\') ||\\n                    (map[s[i]] == \\'C\\' && map[s[i+1]] == \\'M\\')) {  \\n                \\n                    sum += (map[s[i+1]] - map[s[i]]);\\n                    i = i+2;\\n                }\\n                else {\\n                    sum += map[s[i]];\\n                    ++i;\\n                } \\n            }\\n            sum += map[s[i]];  `  "
                    },
                    {
                        "username": "Smorgleberry",
                        "content": "I\\'m guessing it can be assumed that these roman numerals are all valid in terms of the Roman numeral rules.  This meaning if a smaller symbol comes before a larger one you can always subtract it.  In the real system, which isn\\'t exactly defined here, a number to be subtracted must be within 2 symbols from what you are subtracting it from.  As an example the number 99 cannot be constructed like \"IC\" it must be built from \"L\" whereas the number 9 is \"IX\"."
                    },
                    {
                        "username": "manjaridhoundiyal",
                        "content": "Javascript Solution\\n\\nvar romanToInt = function(s) {\\n    let index=0;\\n    let count = 0;\\n    while(s.length > index){\\n        if(s[index] === \\'I\\' && s[index+1] === \\'V\\'){\\n            count = count + 4;\\n            index++;\\n        }\\n        else if(s[index] === \\'I\\' && s[index+1] === \\'X\\'){\\n            count = count + 9;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'L\\'){\\n            count = count + 40;\\n            index++;\\n        }\\n        else if(s[index] === \\'X\\' && s[index+1] === \\'C\\'){\\n            count = count + 90;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'D\\'){\\n            count = count + 400;\\n            index++;\\n        }\\n        else if(s[index] === \\'C\\' && s[index+1] === \\'M\\'){\\n            count = count + 900;\\n            index++;\\n        }\\n        else{\\n            count = count + symbolValue(s[index])\\n        }\\n        index++\\n    }\\n    return count\\n};\\n\\n\\nvar symbolValue = function(s) {\\n    switch(s){\\n        case \\'I\\':\\n            return 1;\\n        case \\'V\\':\\n            return 5;\\n        case \\'X\\':\\n            return 10;\\n        case \\'L\\':\\n            return 50;\\n        case \\'C\\':\\n            return 100;\\n        case \\'D\\':\\n            return 500;\\n        case \\'M\\':\\n            return 1000;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1738449,
                "content": [
                    {
                        "username": "Suraj_Kumar_Singh_5007",
                        "content": "my code is working in other compiler but in leet code it is showing error in line 82 or 75 but my code has only 74 lines ???"
                    },
                    {
                        "username": "BarryJohnson",
                        "content": "golang code\\n\\nfunc romanToInt(s string) int {\\n    ret := 0\\n\\ti := 0\\n\\tlength := len(s)\\n\\tfor ; i < length-1; i++ {\\n\\t\\t//fmt.Println(s[i : i+2])\\n\\t\\tswitch s[i : i+2] {\\n\\t\\tcase \"IV\":\\n\\t\\t\\tret += 4\\n\\t\\t\\ti += 1\\n\\t\\tcase \"IX\":\\n\\t\\t\\tret += 9\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XL\":\\n\\t\\t\\tret += 40\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XC\":\\n\\t\\t\\tret += 90\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CD\":\\n\\t\\t\\tret += 400\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CM\":\\n\\t\\t\\tret += 900\\n\\t\\t\\ti += 1\\n\\t\\tdefault:\\n\\t\\t\\tswitch s[i] {\\n\\t\\t\\tcase \\'I\\':\\n\\t\\t\\t\\tret += 1\\n\\t\\t\\tcase \\'V\\':\\n\\t\\t\\t\\tret += 5\\n\\t\\t\\tcase \\'X\\':\\n\\t\\t\\t\\tret += 10\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tret += 50\\n\\t\\t\\tcase \\'C\\':\\n\\t\\t\\t\\tret += 100\\n\\t\\t\\tcase \\'D\\':\\n\\t\\t\\t\\tret += 500\\n\\t\\t\\tcase \\'M\\':\\n\\t\\t\\t\\tret += 1000\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif i == length-1 {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'I\\':\\n\\t\\t\\tret += 1\\n\\t\\tcase \\'V\\':\\n\\t\\t\\tret += 5\\n\\t\\tcase \\'X\\':\\n\\t\\t\\tret += 10\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tret += 50\\n\\t\\tcase \\'C\\':\\n\\t\\t\\tret += 100\\n\\t\\tcase \\'D\\':\\n\\t\\t\\tret += 500\\n\\t\\tcase \\'M\\':\\n\\t\\t\\tret += 1000\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "laxminagln",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        res = 0\\n        t = {\\n            \\'I\\':1,\\n            \\'V\\':5,\\n            \\'X\\':10,\\n            \\'L\\':50,\\n            \\'C\\':100,\\n            \\'D\\':500,\\n            \\'M\\':1000\\n        }\\n        s = s.replace(\\'IV\\',\\'IIII\\')\\n        s = s.replace(\\'IX\\',\\'VIIII\\')\\n        s = s.replace(\\'XL\\',\\'XXXX\\')\\n        s = s.replace(\\'XC\\',\\'LXXXX\\')\\n        s = s.replace(\\'CD\\',\\'CCCC\\')\\n        s = s.replace(\\'CM\\',\\'DCCCC\\')\\n        for i in s:\\n            res += t[i]\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     int value(char roman){\\n\\n        switch(roman)\\n        {\\n            case \\'I\\':return 1;\\n            case \\'V\\':return 5;\\n            case \\'X\\':return 10;\\n            case \\'L\\':return 50;\\n            case \\'C\\':return 100;\\n            case \\'D\\':return 500;\\n            case \\'M\\':return 1000;\\n        }\\n        return 0;\\n    }\\n\\n    int romanToInt(string s) {\\n        int i, n, ans=0, p=0;\\n        n = s.length()-1;\\n\\n        for( i=n; i>=0; i--)\\n        {\\n        if( value(s[i]) >= p){\\n            ans = ans + value(s[i]);\\n        }\\n        else{\\n            ans = ans - value(s[i]);\\n        }\\n        p = value(s[i]);\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": "The Efficient Solution is here.  Please let it Update by adding comment reply if you do any other change and efficient solution in this code.  \\n\\nTime Complexity :- `O(n)`"
                    },
                    {
                        "username": "Djeekay",
                        "content": "Your kotlin compiler has problems with cast. Mb you use old version of it idk\nLine 17: Char 40: error: smart cast to 'Char' is impossible, because 'key' is a local variable that is captured by a changing closure\n                val inKey = dictionary[key]!!"
                    },
                    {
                        "username": "Longboiii",
                        "content": "I made my solution with many \"else if\" and the result is different EVEN WHEN I START THE SAME SOLUTION ONE MORE TIME. I just registred and this is happening, already love you, leetcode.  The compiler is just kidding, cause when I add  cout<<size(s)<<' '; to the cycle, it begins to work, but not quite good as I said."
                    },
                    {
                        "username": "Tusharkr43",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int  x=0;\\n        int size=s.length();\\n        for(int i=0;i<size;i++){\\n            if(s[i]==\\'I\\'){\\n               \\n               x=x+1;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                x=x+5;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-5+4;\\n                }\\n                \\n                \\n            }\\n            else if(s[i]==\\'X\\'){\\n                x=x+10;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-10+9;\\n                }\\n            }\\n            else if(s[i]==\\'L\\'){\\n                x=x+50;\\n                if(s[i-1]==\\'X\\'){\\n                    x=x-10-50+40;\\n                }\\n            }\\n            else if(s[i]==\\'C\\'){\\n                x=x+100;\\n                  if(s[i-1]==\\'X\\'){\\n                    x=x-10+90-100;\\n                    }\\n            }\\n            else if(s[i]==\\'D\\'){\\n                x=x+500;\\n                  if(s[i-1]==\\'C\\'){\\n                    x=x-100-500+400;\\n                }\\n            }\\n            else if(s[i]==\\'M\\'){\\n                x=x+1000;\\n                   if(s[i-1]==\\'C\\'){\\n                    x=x-100+900-1000;\\n                }\\n            }\\n            \\n        }\\n @\\n        return x;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pogozh",
                        "content": "My code works at home, but it doesn\\'t work on the site. Is this normal?)"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "I had the same trouble. If you\\'ve just started on LeetCode, check some other problems(you\\'d get a better understanding of how stuff works here) and then get back to this after a few days. I did that, and implemented a different logic, and was able to submit the solution just a few hours ago."
                    },
                    {
                        "username": "aditya7mail77",
                        "content": "Line 47: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "public int romanToInt(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int sum = 0;\\n        char ch = 0;\\n        char pre = 0;\\n        for(int i = 0, len = s.length(); i < len; i ++) {\\n            pre = ch;\\n            ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'I\\':\\n                    sum ++;\\n                    break;\\n                case \\'V\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 3;\\n                    }\\n                    else {\\n                        sum += 5;\\n                    }\\n                    break;\\n                case \\'X\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 8;\\n                    }\\n                    else {\\n                        sum += 10;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 48;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 40;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 30;\\n                    }\\n                    else {\\n                        sum += 50;\\n                    }\\n                    break;\\n                case \\'C\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 98;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 90;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 80;\\n                    }\\n                    else {\\n                        sum += 100;\\n                    }\\n                    break;\\n                case \\'D\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 498;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 490;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 480;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 300;\\n                    }\\n                    else {\\n                        sum += 500;\\n                    }\\n                    break;\\n                case \\'M\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 998;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 990;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 980;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 800;\\n                    }\\n                    else {\\n                        sum += 1000;\\n                    }\\n                    break;\\n            }\\n        }\\n        return sum;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "eryzml",
                        "content": "Have you tried to optimize your solution since your submission?"
                    }
                ]
            },
            {
                "id": 1735033,
                "content": [
                    {
                        "username": "Suraj_Kumar_Singh_5007",
                        "content": "my code is working in other compiler but in leet code it is showing error in line 82 or 75 but my code has only 74 lines ???"
                    },
                    {
                        "username": "BarryJohnson",
                        "content": "golang code\\n\\nfunc romanToInt(s string) int {\\n    ret := 0\\n\\ti := 0\\n\\tlength := len(s)\\n\\tfor ; i < length-1; i++ {\\n\\t\\t//fmt.Println(s[i : i+2])\\n\\t\\tswitch s[i : i+2] {\\n\\t\\tcase \"IV\":\\n\\t\\t\\tret += 4\\n\\t\\t\\ti += 1\\n\\t\\tcase \"IX\":\\n\\t\\t\\tret += 9\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XL\":\\n\\t\\t\\tret += 40\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XC\":\\n\\t\\t\\tret += 90\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CD\":\\n\\t\\t\\tret += 400\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CM\":\\n\\t\\t\\tret += 900\\n\\t\\t\\ti += 1\\n\\t\\tdefault:\\n\\t\\t\\tswitch s[i] {\\n\\t\\t\\tcase \\'I\\':\\n\\t\\t\\t\\tret += 1\\n\\t\\t\\tcase \\'V\\':\\n\\t\\t\\t\\tret += 5\\n\\t\\t\\tcase \\'X\\':\\n\\t\\t\\t\\tret += 10\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tret += 50\\n\\t\\t\\tcase \\'C\\':\\n\\t\\t\\t\\tret += 100\\n\\t\\t\\tcase \\'D\\':\\n\\t\\t\\t\\tret += 500\\n\\t\\t\\tcase \\'M\\':\\n\\t\\t\\t\\tret += 1000\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif i == length-1 {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'I\\':\\n\\t\\t\\tret += 1\\n\\t\\tcase \\'V\\':\\n\\t\\t\\tret += 5\\n\\t\\tcase \\'X\\':\\n\\t\\t\\tret += 10\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tret += 50\\n\\t\\tcase \\'C\\':\\n\\t\\t\\tret += 100\\n\\t\\tcase \\'D\\':\\n\\t\\t\\tret += 500\\n\\t\\tcase \\'M\\':\\n\\t\\t\\tret += 1000\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "laxminagln",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        res = 0\\n        t = {\\n            \\'I\\':1,\\n            \\'V\\':5,\\n            \\'X\\':10,\\n            \\'L\\':50,\\n            \\'C\\':100,\\n            \\'D\\':500,\\n            \\'M\\':1000\\n        }\\n        s = s.replace(\\'IV\\',\\'IIII\\')\\n        s = s.replace(\\'IX\\',\\'VIIII\\')\\n        s = s.replace(\\'XL\\',\\'XXXX\\')\\n        s = s.replace(\\'XC\\',\\'LXXXX\\')\\n        s = s.replace(\\'CD\\',\\'CCCC\\')\\n        s = s.replace(\\'CM\\',\\'DCCCC\\')\\n        for i in s:\\n            res += t[i]\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     int value(char roman){\\n\\n        switch(roman)\\n        {\\n            case \\'I\\':return 1;\\n            case \\'V\\':return 5;\\n            case \\'X\\':return 10;\\n            case \\'L\\':return 50;\\n            case \\'C\\':return 100;\\n            case \\'D\\':return 500;\\n            case \\'M\\':return 1000;\\n        }\\n        return 0;\\n    }\\n\\n    int romanToInt(string s) {\\n        int i, n, ans=0, p=0;\\n        n = s.length()-1;\\n\\n        for( i=n; i>=0; i--)\\n        {\\n        if( value(s[i]) >= p){\\n            ans = ans + value(s[i]);\\n        }\\n        else{\\n            ans = ans - value(s[i]);\\n        }\\n        p = value(s[i]);\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": "The Efficient Solution is here.  Please let it Update by adding comment reply if you do any other change and efficient solution in this code.  \\n\\nTime Complexity :- `O(n)`"
                    },
                    {
                        "username": "Djeekay",
                        "content": "Your kotlin compiler has problems with cast. Mb you use old version of it idk\nLine 17: Char 40: error: smart cast to 'Char' is impossible, because 'key' is a local variable that is captured by a changing closure\n                val inKey = dictionary[key]!!"
                    },
                    {
                        "username": "Longboiii",
                        "content": "I made my solution with many \"else if\" and the result is different EVEN WHEN I START THE SAME SOLUTION ONE MORE TIME. I just registred and this is happening, already love you, leetcode.  The compiler is just kidding, cause when I add  cout<<size(s)<<' '; to the cycle, it begins to work, but not quite good as I said."
                    },
                    {
                        "username": "Tusharkr43",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int  x=0;\\n        int size=s.length();\\n        for(int i=0;i<size;i++){\\n            if(s[i]==\\'I\\'){\\n               \\n               x=x+1;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                x=x+5;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-5+4;\\n                }\\n                \\n                \\n            }\\n            else if(s[i]==\\'X\\'){\\n                x=x+10;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-10+9;\\n                }\\n            }\\n            else if(s[i]==\\'L\\'){\\n                x=x+50;\\n                if(s[i-1]==\\'X\\'){\\n                    x=x-10-50+40;\\n                }\\n            }\\n            else if(s[i]==\\'C\\'){\\n                x=x+100;\\n                  if(s[i-1]==\\'X\\'){\\n                    x=x-10+90-100;\\n                    }\\n            }\\n            else if(s[i]==\\'D\\'){\\n                x=x+500;\\n                  if(s[i-1]==\\'C\\'){\\n                    x=x-100-500+400;\\n                }\\n            }\\n            else if(s[i]==\\'M\\'){\\n                x=x+1000;\\n                   if(s[i-1]==\\'C\\'){\\n                    x=x-100+900-1000;\\n                }\\n            }\\n            \\n        }\\n @\\n        return x;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pogozh",
                        "content": "My code works at home, but it doesn\\'t work on the site. Is this normal?)"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "I had the same trouble. If you\\'ve just started on LeetCode, check some other problems(you\\'d get a better understanding of how stuff works here) and then get back to this after a few days. I did that, and implemented a different logic, and was able to submit the solution just a few hours ago."
                    },
                    {
                        "username": "aditya7mail77",
                        "content": "Line 47: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "public int romanToInt(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int sum = 0;\\n        char ch = 0;\\n        char pre = 0;\\n        for(int i = 0, len = s.length(); i < len; i ++) {\\n            pre = ch;\\n            ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'I\\':\\n                    sum ++;\\n                    break;\\n                case \\'V\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 3;\\n                    }\\n                    else {\\n                        sum += 5;\\n                    }\\n                    break;\\n                case \\'X\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 8;\\n                    }\\n                    else {\\n                        sum += 10;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 48;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 40;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 30;\\n                    }\\n                    else {\\n                        sum += 50;\\n                    }\\n                    break;\\n                case \\'C\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 98;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 90;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 80;\\n                    }\\n                    else {\\n                        sum += 100;\\n                    }\\n                    break;\\n                case \\'D\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 498;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 490;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 480;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 300;\\n                    }\\n                    else {\\n                        sum += 500;\\n                    }\\n                    break;\\n                case \\'M\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 998;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 990;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 980;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 800;\\n                    }\\n                    else {\\n                        sum += 1000;\\n                    }\\n                    break;\\n            }\\n        }\\n        return sum;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "eryzml",
                        "content": "Have you tried to optimize your solution since your submission?"
                    }
                ]
            },
            {
                "id": 1734519,
                "content": [
                    {
                        "username": "Suraj_Kumar_Singh_5007",
                        "content": "my code is working in other compiler but in leet code it is showing error in line 82 or 75 but my code has only 74 lines ???"
                    },
                    {
                        "username": "BarryJohnson",
                        "content": "golang code\\n\\nfunc romanToInt(s string) int {\\n    ret := 0\\n\\ti := 0\\n\\tlength := len(s)\\n\\tfor ; i < length-1; i++ {\\n\\t\\t//fmt.Println(s[i : i+2])\\n\\t\\tswitch s[i : i+2] {\\n\\t\\tcase \"IV\":\\n\\t\\t\\tret += 4\\n\\t\\t\\ti += 1\\n\\t\\tcase \"IX\":\\n\\t\\t\\tret += 9\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XL\":\\n\\t\\t\\tret += 40\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XC\":\\n\\t\\t\\tret += 90\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CD\":\\n\\t\\t\\tret += 400\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CM\":\\n\\t\\t\\tret += 900\\n\\t\\t\\ti += 1\\n\\t\\tdefault:\\n\\t\\t\\tswitch s[i] {\\n\\t\\t\\tcase \\'I\\':\\n\\t\\t\\t\\tret += 1\\n\\t\\t\\tcase \\'V\\':\\n\\t\\t\\t\\tret += 5\\n\\t\\t\\tcase \\'X\\':\\n\\t\\t\\t\\tret += 10\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tret += 50\\n\\t\\t\\tcase \\'C\\':\\n\\t\\t\\t\\tret += 100\\n\\t\\t\\tcase \\'D\\':\\n\\t\\t\\t\\tret += 500\\n\\t\\t\\tcase \\'M\\':\\n\\t\\t\\t\\tret += 1000\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif i == length-1 {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'I\\':\\n\\t\\t\\tret += 1\\n\\t\\tcase \\'V\\':\\n\\t\\t\\tret += 5\\n\\t\\tcase \\'X\\':\\n\\t\\t\\tret += 10\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tret += 50\\n\\t\\tcase \\'C\\':\\n\\t\\t\\tret += 100\\n\\t\\tcase \\'D\\':\\n\\t\\t\\tret += 500\\n\\t\\tcase \\'M\\':\\n\\t\\t\\tret += 1000\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "laxminagln",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        res = 0\\n        t = {\\n            \\'I\\':1,\\n            \\'V\\':5,\\n            \\'X\\':10,\\n            \\'L\\':50,\\n            \\'C\\':100,\\n            \\'D\\':500,\\n            \\'M\\':1000\\n        }\\n        s = s.replace(\\'IV\\',\\'IIII\\')\\n        s = s.replace(\\'IX\\',\\'VIIII\\')\\n        s = s.replace(\\'XL\\',\\'XXXX\\')\\n        s = s.replace(\\'XC\\',\\'LXXXX\\')\\n        s = s.replace(\\'CD\\',\\'CCCC\\')\\n        s = s.replace(\\'CM\\',\\'DCCCC\\')\\n        for i in s:\\n            res += t[i]\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     int value(char roman){\\n\\n        switch(roman)\\n        {\\n            case \\'I\\':return 1;\\n            case \\'V\\':return 5;\\n            case \\'X\\':return 10;\\n            case \\'L\\':return 50;\\n            case \\'C\\':return 100;\\n            case \\'D\\':return 500;\\n            case \\'M\\':return 1000;\\n        }\\n        return 0;\\n    }\\n\\n    int romanToInt(string s) {\\n        int i, n, ans=0, p=0;\\n        n = s.length()-1;\\n\\n        for( i=n; i>=0; i--)\\n        {\\n        if( value(s[i]) >= p){\\n            ans = ans + value(s[i]);\\n        }\\n        else{\\n            ans = ans - value(s[i]);\\n        }\\n        p = value(s[i]);\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": "The Efficient Solution is here.  Please let it Update by adding comment reply if you do any other change and efficient solution in this code.  \\n\\nTime Complexity :- `O(n)`"
                    },
                    {
                        "username": "Djeekay",
                        "content": "Your kotlin compiler has problems with cast. Mb you use old version of it idk\nLine 17: Char 40: error: smart cast to 'Char' is impossible, because 'key' is a local variable that is captured by a changing closure\n                val inKey = dictionary[key]!!"
                    },
                    {
                        "username": "Longboiii",
                        "content": "I made my solution with many \"else if\" and the result is different EVEN WHEN I START THE SAME SOLUTION ONE MORE TIME. I just registred and this is happening, already love you, leetcode.  The compiler is just kidding, cause when I add  cout<<size(s)<<' '; to the cycle, it begins to work, but not quite good as I said."
                    },
                    {
                        "username": "Tusharkr43",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int  x=0;\\n        int size=s.length();\\n        for(int i=0;i<size;i++){\\n            if(s[i]==\\'I\\'){\\n               \\n               x=x+1;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                x=x+5;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-5+4;\\n                }\\n                \\n                \\n            }\\n            else if(s[i]==\\'X\\'){\\n                x=x+10;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-10+9;\\n                }\\n            }\\n            else if(s[i]==\\'L\\'){\\n                x=x+50;\\n                if(s[i-1]==\\'X\\'){\\n                    x=x-10-50+40;\\n                }\\n            }\\n            else if(s[i]==\\'C\\'){\\n                x=x+100;\\n                  if(s[i-1]==\\'X\\'){\\n                    x=x-10+90-100;\\n                    }\\n            }\\n            else if(s[i]==\\'D\\'){\\n                x=x+500;\\n                  if(s[i-1]==\\'C\\'){\\n                    x=x-100-500+400;\\n                }\\n            }\\n            else if(s[i]==\\'M\\'){\\n                x=x+1000;\\n                   if(s[i-1]==\\'C\\'){\\n                    x=x-100+900-1000;\\n                }\\n            }\\n            \\n        }\\n @\\n        return x;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pogozh",
                        "content": "My code works at home, but it doesn\\'t work on the site. Is this normal?)"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "I had the same trouble. If you\\'ve just started on LeetCode, check some other problems(you\\'d get a better understanding of how stuff works here) and then get back to this after a few days. I did that, and implemented a different logic, and was able to submit the solution just a few hours ago."
                    },
                    {
                        "username": "aditya7mail77",
                        "content": "Line 47: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "public int romanToInt(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int sum = 0;\\n        char ch = 0;\\n        char pre = 0;\\n        for(int i = 0, len = s.length(); i < len; i ++) {\\n            pre = ch;\\n            ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'I\\':\\n                    sum ++;\\n                    break;\\n                case \\'V\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 3;\\n                    }\\n                    else {\\n                        sum += 5;\\n                    }\\n                    break;\\n                case \\'X\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 8;\\n                    }\\n                    else {\\n                        sum += 10;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 48;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 40;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 30;\\n                    }\\n                    else {\\n                        sum += 50;\\n                    }\\n                    break;\\n                case \\'C\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 98;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 90;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 80;\\n                    }\\n                    else {\\n                        sum += 100;\\n                    }\\n                    break;\\n                case \\'D\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 498;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 490;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 480;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 300;\\n                    }\\n                    else {\\n                        sum += 500;\\n                    }\\n                    break;\\n                case \\'M\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 998;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 990;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 980;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 800;\\n                    }\\n                    else {\\n                        sum += 1000;\\n                    }\\n                    break;\\n            }\\n        }\\n        return sum;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "eryzml",
                        "content": "Have you tried to optimize your solution since your submission?"
                    }
                ]
            },
            {
                "id": 1732918,
                "content": [
                    {
                        "username": "Suraj_Kumar_Singh_5007",
                        "content": "my code is working in other compiler but in leet code it is showing error in line 82 or 75 but my code has only 74 lines ???"
                    },
                    {
                        "username": "BarryJohnson",
                        "content": "golang code\\n\\nfunc romanToInt(s string) int {\\n    ret := 0\\n\\ti := 0\\n\\tlength := len(s)\\n\\tfor ; i < length-1; i++ {\\n\\t\\t//fmt.Println(s[i : i+2])\\n\\t\\tswitch s[i : i+2] {\\n\\t\\tcase \"IV\":\\n\\t\\t\\tret += 4\\n\\t\\t\\ti += 1\\n\\t\\tcase \"IX\":\\n\\t\\t\\tret += 9\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XL\":\\n\\t\\t\\tret += 40\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XC\":\\n\\t\\t\\tret += 90\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CD\":\\n\\t\\t\\tret += 400\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CM\":\\n\\t\\t\\tret += 900\\n\\t\\t\\ti += 1\\n\\t\\tdefault:\\n\\t\\t\\tswitch s[i] {\\n\\t\\t\\tcase \\'I\\':\\n\\t\\t\\t\\tret += 1\\n\\t\\t\\tcase \\'V\\':\\n\\t\\t\\t\\tret += 5\\n\\t\\t\\tcase \\'X\\':\\n\\t\\t\\t\\tret += 10\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tret += 50\\n\\t\\t\\tcase \\'C\\':\\n\\t\\t\\t\\tret += 100\\n\\t\\t\\tcase \\'D\\':\\n\\t\\t\\t\\tret += 500\\n\\t\\t\\tcase \\'M\\':\\n\\t\\t\\t\\tret += 1000\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif i == length-1 {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'I\\':\\n\\t\\t\\tret += 1\\n\\t\\tcase \\'V\\':\\n\\t\\t\\tret += 5\\n\\t\\tcase \\'X\\':\\n\\t\\t\\tret += 10\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tret += 50\\n\\t\\tcase \\'C\\':\\n\\t\\t\\tret += 100\\n\\t\\tcase \\'D\\':\\n\\t\\t\\tret += 500\\n\\t\\tcase \\'M\\':\\n\\t\\t\\tret += 1000\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "laxminagln",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        res = 0\\n        t = {\\n            \\'I\\':1,\\n            \\'V\\':5,\\n            \\'X\\':10,\\n            \\'L\\':50,\\n            \\'C\\':100,\\n            \\'D\\':500,\\n            \\'M\\':1000\\n        }\\n        s = s.replace(\\'IV\\',\\'IIII\\')\\n        s = s.replace(\\'IX\\',\\'VIIII\\')\\n        s = s.replace(\\'XL\\',\\'XXXX\\')\\n        s = s.replace(\\'XC\\',\\'LXXXX\\')\\n        s = s.replace(\\'CD\\',\\'CCCC\\')\\n        s = s.replace(\\'CM\\',\\'DCCCC\\')\\n        for i in s:\\n            res += t[i]\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     int value(char roman){\\n\\n        switch(roman)\\n        {\\n            case \\'I\\':return 1;\\n            case \\'V\\':return 5;\\n            case \\'X\\':return 10;\\n            case \\'L\\':return 50;\\n            case \\'C\\':return 100;\\n            case \\'D\\':return 500;\\n            case \\'M\\':return 1000;\\n        }\\n        return 0;\\n    }\\n\\n    int romanToInt(string s) {\\n        int i, n, ans=0, p=0;\\n        n = s.length()-1;\\n\\n        for( i=n; i>=0; i--)\\n        {\\n        if( value(s[i]) >= p){\\n            ans = ans + value(s[i]);\\n        }\\n        else{\\n            ans = ans - value(s[i]);\\n        }\\n        p = value(s[i]);\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": "The Efficient Solution is here.  Please let it Update by adding comment reply if you do any other change and efficient solution in this code.  \\n\\nTime Complexity :- `O(n)`"
                    },
                    {
                        "username": "Djeekay",
                        "content": "Your kotlin compiler has problems with cast. Mb you use old version of it idk\nLine 17: Char 40: error: smart cast to 'Char' is impossible, because 'key' is a local variable that is captured by a changing closure\n                val inKey = dictionary[key]!!"
                    },
                    {
                        "username": "Longboiii",
                        "content": "I made my solution with many \"else if\" and the result is different EVEN WHEN I START THE SAME SOLUTION ONE MORE TIME. I just registred and this is happening, already love you, leetcode.  The compiler is just kidding, cause when I add  cout<<size(s)<<' '; to the cycle, it begins to work, but not quite good as I said."
                    },
                    {
                        "username": "Tusharkr43",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int  x=0;\\n        int size=s.length();\\n        for(int i=0;i<size;i++){\\n            if(s[i]==\\'I\\'){\\n               \\n               x=x+1;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                x=x+5;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-5+4;\\n                }\\n                \\n                \\n            }\\n            else if(s[i]==\\'X\\'){\\n                x=x+10;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-10+9;\\n                }\\n            }\\n            else if(s[i]==\\'L\\'){\\n                x=x+50;\\n                if(s[i-1]==\\'X\\'){\\n                    x=x-10-50+40;\\n                }\\n            }\\n            else if(s[i]==\\'C\\'){\\n                x=x+100;\\n                  if(s[i-1]==\\'X\\'){\\n                    x=x-10+90-100;\\n                    }\\n            }\\n            else if(s[i]==\\'D\\'){\\n                x=x+500;\\n                  if(s[i-1]==\\'C\\'){\\n                    x=x-100-500+400;\\n                }\\n            }\\n            else if(s[i]==\\'M\\'){\\n                x=x+1000;\\n                   if(s[i-1]==\\'C\\'){\\n                    x=x-100+900-1000;\\n                }\\n            }\\n            \\n        }\\n @\\n        return x;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pogozh",
                        "content": "My code works at home, but it doesn\\'t work on the site. Is this normal?)"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "I had the same trouble. If you\\'ve just started on LeetCode, check some other problems(you\\'d get a better understanding of how stuff works here) and then get back to this after a few days. I did that, and implemented a different logic, and was able to submit the solution just a few hours ago."
                    },
                    {
                        "username": "aditya7mail77",
                        "content": "Line 47: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "public int romanToInt(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int sum = 0;\\n        char ch = 0;\\n        char pre = 0;\\n        for(int i = 0, len = s.length(); i < len; i ++) {\\n            pre = ch;\\n            ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'I\\':\\n                    sum ++;\\n                    break;\\n                case \\'V\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 3;\\n                    }\\n                    else {\\n                        sum += 5;\\n                    }\\n                    break;\\n                case \\'X\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 8;\\n                    }\\n                    else {\\n                        sum += 10;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 48;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 40;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 30;\\n                    }\\n                    else {\\n                        sum += 50;\\n                    }\\n                    break;\\n                case \\'C\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 98;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 90;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 80;\\n                    }\\n                    else {\\n                        sum += 100;\\n                    }\\n                    break;\\n                case \\'D\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 498;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 490;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 480;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 300;\\n                    }\\n                    else {\\n                        sum += 500;\\n                    }\\n                    break;\\n                case \\'M\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 998;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 990;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 980;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 800;\\n                    }\\n                    else {\\n                        sum += 1000;\\n                    }\\n                    break;\\n            }\\n        }\\n        return sum;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "eryzml",
                        "content": "Have you tried to optimize your solution since your submission?"
                    }
                ]
            },
            {
                "id": 1732669,
                "content": [
                    {
                        "username": "Suraj_Kumar_Singh_5007",
                        "content": "my code is working in other compiler but in leet code it is showing error in line 82 or 75 but my code has only 74 lines ???"
                    },
                    {
                        "username": "BarryJohnson",
                        "content": "golang code\\n\\nfunc romanToInt(s string) int {\\n    ret := 0\\n\\ti := 0\\n\\tlength := len(s)\\n\\tfor ; i < length-1; i++ {\\n\\t\\t//fmt.Println(s[i : i+2])\\n\\t\\tswitch s[i : i+2] {\\n\\t\\tcase \"IV\":\\n\\t\\t\\tret += 4\\n\\t\\t\\ti += 1\\n\\t\\tcase \"IX\":\\n\\t\\t\\tret += 9\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XL\":\\n\\t\\t\\tret += 40\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XC\":\\n\\t\\t\\tret += 90\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CD\":\\n\\t\\t\\tret += 400\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CM\":\\n\\t\\t\\tret += 900\\n\\t\\t\\ti += 1\\n\\t\\tdefault:\\n\\t\\t\\tswitch s[i] {\\n\\t\\t\\tcase \\'I\\':\\n\\t\\t\\t\\tret += 1\\n\\t\\t\\tcase \\'V\\':\\n\\t\\t\\t\\tret += 5\\n\\t\\t\\tcase \\'X\\':\\n\\t\\t\\t\\tret += 10\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tret += 50\\n\\t\\t\\tcase \\'C\\':\\n\\t\\t\\t\\tret += 100\\n\\t\\t\\tcase \\'D\\':\\n\\t\\t\\t\\tret += 500\\n\\t\\t\\tcase \\'M\\':\\n\\t\\t\\t\\tret += 1000\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif i == length-1 {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'I\\':\\n\\t\\t\\tret += 1\\n\\t\\tcase \\'V\\':\\n\\t\\t\\tret += 5\\n\\t\\tcase \\'X\\':\\n\\t\\t\\tret += 10\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tret += 50\\n\\t\\tcase \\'C\\':\\n\\t\\t\\tret += 100\\n\\t\\tcase \\'D\\':\\n\\t\\t\\tret += 500\\n\\t\\tcase \\'M\\':\\n\\t\\t\\tret += 1000\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "laxminagln",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        res = 0\\n        t = {\\n            \\'I\\':1,\\n            \\'V\\':5,\\n            \\'X\\':10,\\n            \\'L\\':50,\\n            \\'C\\':100,\\n            \\'D\\':500,\\n            \\'M\\':1000\\n        }\\n        s = s.replace(\\'IV\\',\\'IIII\\')\\n        s = s.replace(\\'IX\\',\\'VIIII\\')\\n        s = s.replace(\\'XL\\',\\'XXXX\\')\\n        s = s.replace(\\'XC\\',\\'LXXXX\\')\\n        s = s.replace(\\'CD\\',\\'CCCC\\')\\n        s = s.replace(\\'CM\\',\\'DCCCC\\')\\n        for i in s:\\n            res += t[i]\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     int value(char roman){\\n\\n        switch(roman)\\n        {\\n            case \\'I\\':return 1;\\n            case \\'V\\':return 5;\\n            case \\'X\\':return 10;\\n            case \\'L\\':return 50;\\n            case \\'C\\':return 100;\\n            case \\'D\\':return 500;\\n            case \\'M\\':return 1000;\\n        }\\n        return 0;\\n    }\\n\\n    int romanToInt(string s) {\\n        int i, n, ans=0, p=0;\\n        n = s.length()-1;\\n\\n        for( i=n; i>=0; i--)\\n        {\\n        if( value(s[i]) >= p){\\n            ans = ans + value(s[i]);\\n        }\\n        else{\\n            ans = ans - value(s[i]);\\n        }\\n        p = value(s[i]);\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": "The Efficient Solution is here.  Please let it Update by adding comment reply if you do any other change and efficient solution in this code.  \\n\\nTime Complexity :- `O(n)`"
                    },
                    {
                        "username": "Djeekay",
                        "content": "Your kotlin compiler has problems with cast. Mb you use old version of it idk\nLine 17: Char 40: error: smart cast to 'Char' is impossible, because 'key' is a local variable that is captured by a changing closure\n                val inKey = dictionary[key]!!"
                    },
                    {
                        "username": "Longboiii",
                        "content": "I made my solution with many \"else if\" and the result is different EVEN WHEN I START THE SAME SOLUTION ONE MORE TIME. I just registred and this is happening, already love you, leetcode.  The compiler is just kidding, cause when I add  cout<<size(s)<<' '; to the cycle, it begins to work, but not quite good as I said."
                    },
                    {
                        "username": "Tusharkr43",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int  x=0;\\n        int size=s.length();\\n        for(int i=0;i<size;i++){\\n            if(s[i]==\\'I\\'){\\n               \\n               x=x+1;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                x=x+5;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-5+4;\\n                }\\n                \\n                \\n            }\\n            else if(s[i]==\\'X\\'){\\n                x=x+10;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-10+9;\\n                }\\n            }\\n            else if(s[i]==\\'L\\'){\\n                x=x+50;\\n                if(s[i-1]==\\'X\\'){\\n                    x=x-10-50+40;\\n                }\\n            }\\n            else if(s[i]==\\'C\\'){\\n                x=x+100;\\n                  if(s[i-1]==\\'X\\'){\\n                    x=x-10+90-100;\\n                    }\\n            }\\n            else if(s[i]==\\'D\\'){\\n                x=x+500;\\n                  if(s[i-1]==\\'C\\'){\\n                    x=x-100-500+400;\\n                }\\n            }\\n            else if(s[i]==\\'M\\'){\\n                x=x+1000;\\n                   if(s[i-1]==\\'C\\'){\\n                    x=x-100+900-1000;\\n                }\\n            }\\n            \\n        }\\n @\\n        return x;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pogozh",
                        "content": "My code works at home, but it doesn\\'t work on the site. Is this normal?)"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "I had the same trouble. If you\\'ve just started on LeetCode, check some other problems(you\\'d get a better understanding of how stuff works here) and then get back to this after a few days. I did that, and implemented a different logic, and was able to submit the solution just a few hours ago."
                    },
                    {
                        "username": "aditya7mail77",
                        "content": "Line 47: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "public int romanToInt(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int sum = 0;\\n        char ch = 0;\\n        char pre = 0;\\n        for(int i = 0, len = s.length(); i < len; i ++) {\\n            pre = ch;\\n            ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'I\\':\\n                    sum ++;\\n                    break;\\n                case \\'V\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 3;\\n                    }\\n                    else {\\n                        sum += 5;\\n                    }\\n                    break;\\n                case \\'X\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 8;\\n                    }\\n                    else {\\n                        sum += 10;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 48;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 40;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 30;\\n                    }\\n                    else {\\n                        sum += 50;\\n                    }\\n                    break;\\n                case \\'C\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 98;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 90;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 80;\\n                    }\\n                    else {\\n                        sum += 100;\\n                    }\\n                    break;\\n                case \\'D\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 498;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 490;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 480;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 300;\\n                    }\\n                    else {\\n                        sum += 500;\\n                    }\\n                    break;\\n                case \\'M\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 998;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 990;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 980;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 800;\\n                    }\\n                    else {\\n                        sum += 1000;\\n                    }\\n                    break;\\n            }\\n        }\\n        return sum;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "eryzml",
                        "content": "Have you tried to optimize your solution since your submission?"
                    }
                ]
            },
            {
                "id": 1731590,
                "content": [
                    {
                        "username": "Suraj_Kumar_Singh_5007",
                        "content": "my code is working in other compiler but in leet code it is showing error in line 82 or 75 but my code has only 74 lines ???"
                    },
                    {
                        "username": "BarryJohnson",
                        "content": "golang code\\n\\nfunc romanToInt(s string) int {\\n    ret := 0\\n\\ti := 0\\n\\tlength := len(s)\\n\\tfor ; i < length-1; i++ {\\n\\t\\t//fmt.Println(s[i : i+2])\\n\\t\\tswitch s[i : i+2] {\\n\\t\\tcase \"IV\":\\n\\t\\t\\tret += 4\\n\\t\\t\\ti += 1\\n\\t\\tcase \"IX\":\\n\\t\\t\\tret += 9\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XL\":\\n\\t\\t\\tret += 40\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XC\":\\n\\t\\t\\tret += 90\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CD\":\\n\\t\\t\\tret += 400\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CM\":\\n\\t\\t\\tret += 900\\n\\t\\t\\ti += 1\\n\\t\\tdefault:\\n\\t\\t\\tswitch s[i] {\\n\\t\\t\\tcase \\'I\\':\\n\\t\\t\\t\\tret += 1\\n\\t\\t\\tcase \\'V\\':\\n\\t\\t\\t\\tret += 5\\n\\t\\t\\tcase \\'X\\':\\n\\t\\t\\t\\tret += 10\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tret += 50\\n\\t\\t\\tcase \\'C\\':\\n\\t\\t\\t\\tret += 100\\n\\t\\t\\tcase \\'D\\':\\n\\t\\t\\t\\tret += 500\\n\\t\\t\\tcase \\'M\\':\\n\\t\\t\\t\\tret += 1000\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif i == length-1 {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'I\\':\\n\\t\\t\\tret += 1\\n\\t\\tcase \\'V\\':\\n\\t\\t\\tret += 5\\n\\t\\tcase \\'X\\':\\n\\t\\t\\tret += 10\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tret += 50\\n\\t\\tcase \\'C\\':\\n\\t\\t\\tret += 100\\n\\t\\tcase \\'D\\':\\n\\t\\t\\tret += 500\\n\\t\\tcase \\'M\\':\\n\\t\\t\\tret += 1000\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "laxminagln",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        res = 0\\n        t = {\\n            \\'I\\':1,\\n            \\'V\\':5,\\n            \\'X\\':10,\\n            \\'L\\':50,\\n            \\'C\\':100,\\n            \\'D\\':500,\\n            \\'M\\':1000\\n        }\\n        s = s.replace(\\'IV\\',\\'IIII\\')\\n        s = s.replace(\\'IX\\',\\'VIIII\\')\\n        s = s.replace(\\'XL\\',\\'XXXX\\')\\n        s = s.replace(\\'XC\\',\\'LXXXX\\')\\n        s = s.replace(\\'CD\\',\\'CCCC\\')\\n        s = s.replace(\\'CM\\',\\'DCCCC\\')\\n        for i in s:\\n            res += t[i]\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     int value(char roman){\\n\\n        switch(roman)\\n        {\\n            case \\'I\\':return 1;\\n            case \\'V\\':return 5;\\n            case \\'X\\':return 10;\\n            case \\'L\\':return 50;\\n            case \\'C\\':return 100;\\n            case \\'D\\':return 500;\\n            case \\'M\\':return 1000;\\n        }\\n        return 0;\\n    }\\n\\n    int romanToInt(string s) {\\n        int i, n, ans=0, p=0;\\n        n = s.length()-1;\\n\\n        for( i=n; i>=0; i--)\\n        {\\n        if( value(s[i]) >= p){\\n            ans = ans + value(s[i]);\\n        }\\n        else{\\n            ans = ans - value(s[i]);\\n        }\\n        p = value(s[i]);\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": "The Efficient Solution is here.  Please let it Update by adding comment reply if you do any other change and efficient solution in this code.  \\n\\nTime Complexity :- `O(n)`"
                    },
                    {
                        "username": "Djeekay",
                        "content": "Your kotlin compiler has problems with cast. Mb you use old version of it idk\nLine 17: Char 40: error: smart cast to 'Char' is impossible, because 'key' is a local variable that is captured by a changing closure\n                val inKey = dictionary[key]!!"
                    },
                    {
                        "username": "Longboiii",
                        "content": "I made my solution with many \"else if\" and the result is different EVEN WHEN I START THE SAME SOLUTION ONE MORE TIME. I just registred and this is happening, already love you, leetcode.  The compiler is just kidding, cause when I add  cout<<size(s)<<' '; to the cycle, it begins to work, but not quite good as I said."
                    },
                    {
                        "username": "Tusharkr43",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int  x=0;\\n        int size=s.length();\\n        for(int i=0;i<size;i++){\\n            if(s[i]==\\'I\\'){\\n               \\n               x=x+1;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                x=x+5;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-5+4;\\n                }\\n                \\n                \\n            }\\n            else if(s[i]==\\'X\\'){\\n                x=x+10;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-10+9;\\n                }\\n            }\\n            else if(s[i]==\\'L\\'){\\n                x=x+50;\\n                if(s[i-1]==\\'X\\'){\\n                    x=x-10-50+40;\\n                }\\n            }\\n            else if(s[i]==\\'C\\'){\\n                x=x+100;\\n                  if(s[i-1]==\\'X\\'){\\n                    x=x-10+90-100;\\n                    }\\n            }\\n            else if(s[i]==\\'D\\'){\\n                x=x+500;\\n                  if(s[i-1]==\\'C\\'){\\n                    x=x-100-500+400;\\n                }\\n            }\\n            else if(s[i]==\\'M\\'){\\n                x=x+1000;\\n                   if(s[i-1]==\\'C\\'){\\n                    x=x-100+900-1000;\\n                }\\n            }\\n            \\n        }\\n @\\n        return x;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pogozh",
                        "content": "My code works at home, but it doesn\\'t work on the site. Is this normal?)"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "I had the same trouble. If you\\'ve just started on LeetCode, check some other problems(you\\'d get a better understanding of how stuff works here) and then get back to this after a few days. I did that, and implemented a different logic, and was able to submit the solution just a few hours ago."
                    },
                    {
                        "username": "aditya7mail77",
                        "content": "Line 47: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "public int romanToInt(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int sum = 0;\\n        char ch = 0;\\n        char pre = 0;\\n        for(int i = 0, len = s.length(); i < len; i ++) {\\n            pre = ch;\\n            ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'I\\':\\n                    sum ++;\\n                    break;\\n                case \\'V\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 3;\\n                    }\\n                    else {\\n                        sum += 5;\\n                    }\\n                    break;\\n                case \\'X\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 8;\\n                    }\\n                    else {\\n                        sum += 10;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 48;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 40;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 30;\\n                    }\\n                    else {\\n                        sum += 50;\\n                    }\\n                    break;\\n                case \\'C\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 98;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 90;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 80;\\n                    }\\n                    else {\\n                        sum += 100;\\n                    }\\n                    break;\\n                case \\'D\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 498;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 490;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 480;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 300;\\n                    }\\n                    else {\\n                        sum += 500;\\n                    }\\n                    break;\\n                case \\'M\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 998;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 990;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 980;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 800;\\n                    }\\n                    else {\\n                        sum += 1000;\\n                    }\\n                    break;\\n            }\\n        }\\n        return sum;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "eryzml",
                        "content": "Have you tried to optimize your solution since your submission?"
                    }
                ]
            },
            {
                "id": 1731522,
                "content": [
                    {
                        "username": "Suraj_Kumar_Singh_5007",
                        "content": "my code is working in other compiler but in leet code it is showing error in line 82 or 75 but my code has only 74 lines ???"
                    },
                    {
                        "username": "BarryJohnson",
                        "content": "golang code\\n\\nfunc romanToInt(s string) int {\\n    ret := 0\\n\\ti := 0\\n\\tlength := len(s)\\n\\tfor ; i < length-1; i++ {\\n\\t\\t//fmt.Println(s[i : i+2])\\n\\t\\tswitch s[i : i+2] {\\n\\t\\tcase \"IV\":\\n\\t\\t\\tret += 4\\n\\t\\t\\ti += 1\\n\\t\\tcase \"IX\":\\n\\t\\t\\tret += 9\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XL\":\\n\\t\\t\\tret += 40\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XC\":\\n\\t\\t\\tret += 90\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CD\":\\n\\t\\t\\tret += 400\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CM\":\\n\\t\\t\\tret += 900\\n\\t\\t\\ti += 1\\n\\t\\tdefault:\\n\\t\\t\\tswitch s[i] {\\n\\t\\t\\tcase \\'I\\':\\n\\t\\t\\t\\tret += 1\\n\\t\\t\\tcase \\'V\\':\\n\\t\\t\\t\\tret += 5\\n\\t\\t\\tcase \\'X\\':\\n\\t\\t\\t\\tret += 10\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tret += 50\\n\\t\\t\\tcase \\'C\\':\\n\\t\\t\\t\\tret += 100\\n\\t\\t\\tcase \\'D\\':\\n\\t\\t\\t\\tret += 500\\n\\t\\t\\tcase \\'M\\':\\n\\t\\t\\t\\tret += 1000\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif i == length-1 {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'I\\':\\n\\t\\t\\tret += 1\\n\\t\\tcase \\'V\\':\\n\\t\\t\\tret += 5\\n\\t\\tcase \\'X\\':\\n\\t\\t\\tret += 10\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tret += 50\\n\\t\\tcase \\'C\\':\\n\\t\\t\\tret += 100\\n\\t\\tcase \\'D\\':\\n\\t\\t\\tret += 500\\n\\t\\tcase \\'M\\':\\n\\t\\t\\tret += 1000\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "laxminagln",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        res = 0\\n        t = {\\n            \\'I\\':1,\\n            \\'V\\':5,\\n            \\'X\\':10,\\n            \\'L\\':50,\\n            \\'C\\':100,\\n            \\'D\\':500,\\n            \\'M\\':1000\\n        }\\n        s = s.replace(\\'IV\\',\\'IIII\\')\\n        s = s.replace(\\'IX\\',\\'VIIII\\')\\n        s = s.replace(\\'XL\\',\\'XXXX\\')\\n        s = s.replace(\\'XC\\',\\'LXXXX\\')\\n        s = s.replace(\\'CD\\',\\'CCCC\\')\\n        s = s.replace(\\'CM\\',\\'DCCCC\\')\\n        for i in s:\\n            res += t[i]\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     int value(char roman){\\n\\n        switch(roman)\\n        {\\n            case \\'I\\':return 1;\\n            case \\'V\\':return 5;\\n            case \\'X\\':return 10;\\n            case \\'L\\':return 50;\\n            case \\'C\\':return 100;\\n            case \\'D\\':return 500;\\n            case \\'M\\':return 1000;\\n        }\\n        return 0;\\n    }\\n\\n    int romanToInt(string s) {\\n        int i, n, ans=0, p=0;\\n        n = s.length()-1;\\n\\n        for( i=n; i>=0; i--)\\n        {\\n        if( value(s[i]) >= p){\\n            ans = ans + value(s[i]);\\n        }\\n        else{\\n            ans = ans - value(s[i]);\\n        }\\n        p = value(s[i]);\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": "The Efficient Solution is here.  Please let it Update by adding comment reply if you do any other change and efficient solution in this code.  \\n\\nTime Complexity :- `O(n)`"
                    },
                    {
                        "username": "Djeekay",
                        "content": "Your kotlin compiler has problems with cast. Mb you use old version of it idk\nLine 17: Char 40: error: smart cast to 'Char' is impossible, because 'key' is a local variable that is captured by a changing closure\n                val inKey = dictionary[key]!!"
                    },
                    {
                        "username": "Longboiii",
                        "content": "I made my solution with many \"else if\" and the result is different EVEN WHEN I START THE SAME SOLUTION ONE MORE TIME. I just registred and this is happening, already love you, leetcode.  The compiler is just kidding, cause when I add  cout<<size(s)<<' '; to the cycle, it begins to work, but not quite good as I said."
                    },
                    {
                        "username": "Tusharkr43",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int  x=0;\\n        int size=s.length();\\n        for(int i=0;i<size;i++){\\n            if(s[i]==\\'I\\'){\\n               \\n               x=x+1;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                x=x+5;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-5+4;\\n                }\\n                \\n                \\n            }\\n            else if(s[i]==\\'X\\'){\\n                x=x+10;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-10+9;\\n                }\\n            }\\n            else if(s[i]==\\'L\\'){\\n                x=x+50;\\n                if(s[i-1]==\\'X\\'){\\n                    x=x-10-50+40;\\n                }\\n            }\\n            else if(s[i]==\\'C\\'){\\n                x=x+100;\\n                  if(s[i-1]==\\'X\\'){\\n                    x=x-10+90-100;\\n                    }\\n            }\\n            else if(s[i]==\\'D\\'){\\n                x=x+500;\\n                  if(s[i-1]==\\'C\\'){\\n                    x=x-100-500+400;\\n                }\\n            }\\n            else if(s[i]==\\'M\\'){\\n                x=x+1000;\\n                   if(s[i-1]==\\'C\\'){\\n                    x=x-100+900-1000;\\n                }\\n            }\\n            \\n        }\\n @\\n        return x;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pogozh",
                        "content": "My code works at home, but it doesn\\'t work on the site. Is this normal?)"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "I had the same trouble. If you\\'ve just started on LeetCode, check some other problems(you\\'d get a better understanding of how stuff works here) and then get back to this after a few days. I did that, and implemented a different logic, and was able to submit the solution just a few hours ago."
                    },
                    {
                        "username": "aditya7mail77",
                        "content": "Line 47: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "public int romanToInt(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int sum = 0;\\n        char ch = 0;\\n        char pre = 0;\\n        for(int i = 0, len = s.length(); i < len; i ++) {\\n            pre = ch;\\n            ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'I\\':\\n                    sum ++;\\n                    break;\\n                case \\'V\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 3;\\n                    }\\n                    else {\\n                        sum += 5;\\n                    }\\n                    break;\\n                case \\'X\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 8;\\n                    }\\n                    else {\\n                        sum += 10;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 48;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 40;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 30;\\n                    }\\n                    else {\\n                        sum += 50;\\n                    }\\n                    break;\\n                case \\'C\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 98;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 90;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 80;\\n                    }\\n                    else {\\n                        sum += 100;\\n                    }\\n                    break;\\n                case \\'D\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 498;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 490;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 480;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 300;\\n                    }\\n                    else {\\n                        sum += 500;\\n                    }\\n                    break;\\n                case \\'M\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 998;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 990;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 980;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 800;\\n                    }\\n                    else {\\n                        sum += 1000;\\n                    }\\n                    break;\\n            }\\n        }\\n        return sum;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "eryzml",
                        "content": "Have you tried to optimize your solution since your submission?"
                    }
                ]
            },
            {
                "id": 1728947,
                "content": [
                    {
                        "username": "Suraj_Kumar_Singh_5007",
                        "content": "my code is working in other compiler but in leet code it is showing error in line 82 or 75 but my code has only 74 lines ???"
                    },
                    {
                        "username": "BarryJohnson",
                        "content": "golang code\\n\\nfunc romanToInt(s string) int {\\n    ret := 0\\n\\ti := 0\\n\\tlength := len(s)\\n\\tfor ; i < length-1; i++ {\\n\\t\\t//fmt.Println(s[i : i+2])\\n\\t\\tswitch s[i : i+2] {\\n\\t\\tcase \"IV\":\\n\\t\\t\\tret += 4\\n\\t\\t\\ti += 1\\n\\t\\tcase \"IX\":\\n\\t\\t\\tret += 9\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XL\":\\n\\t\\t\\tret += 40\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XC\":\\n\\t\\t\\tret += 90\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CD\":\\n\\t\\t\\tret += 400\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CM\":\\n\\t\\t\\tret += 900\\n\\t\\t\\ti += 1\\n\\t\\tdefault:\\n\\t\\t\\tswitch s[i] {\\n\\t\\t\\tcase \\'I\\':\\n\\t\\t\\t\\tret += 1\\n\\t\\t\\tcase \\'V\\':\\n\\t\\t\\t\\tret += 5\\n\\t\\t\\tcase \\'X\\':\\n\\t\\t\\t\\tret += 10\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tret += 50\\n\\t\\t\\tcase \\'C\\':\\n\\t\\t\\t\\tret += 100\\n\\t\\t\\tcase \\'D\\':\\n\\t\\t\\t\\tret += 500\\n\\t\\t\\tcase \\'M\\':\\n\\t\\t\\t\\tret += 1000\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif i == length-1 {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'I\\':\\n\\t\\t\\tret += 1\\n\\t\\tcase \\'V\\':\\n\\t\\t\\tret += 5\\n\\t\\tcase \\'X\\':\\n\\t\\t\\tret += 10\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tret += 50\\n\\t\\tcase \\'C\\':\\n\\t\\t\\tret += 100\\n\\t\\tcase \\'D\\':\\n\\t\\t\\tret += 500\\n\\t\\tcase \\'M\\':\\n\\t\\t\\tret += 1000\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "laxminagln",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        res = 0\\n        t = {\\n            \\'I\\':1,\\n            \\'V\\':5,\\n            \\'X\\':10,\\n            \\'L\\':50,\\n            \\'C\\':100,\\n            \\'D\\':500,\\n            \\'M\\':1000\\n        }\\n        s = s.replace(\\'IV\\',\\'IIII\\')\\n        s = s.replace(\\'IX\\',\\'VIIII\\')\\n        s = s.replace(\\'XL\\',\\'XXXX\\')\\n        s = s.replace(\\'XC\\',\\'LXXXX\\')\\n        s = s.replace(\\'CD\\',\\'CCCC\\')\\n        s = s.replace(\\'CM\\',\\'DCCCC\\')\\n        for i in s:\\n            res += t[i]\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     int value(char roman){\\n\\n        switch(roman)\\n        {\\n            case \\'I\\':return 1;\\n            case \\'V\\':return 5;\\n            case \\'X\\':return 10;\\n            case \\'L\\':return 50;\\n            case \\'C\\':return 100;\\n            case \\'D\\':return 500;\\n            case \\'M\\':return 1000;\\n        }\\n        return 0;\\n    }\\n\\n    int romanToInt(string s) {\\n        int i, n, ans=0, p=0;\\n        n = s.length()-1;\\n\\n        for( i=n; i>=0; i--)\\n        {\\n        if( value(s[i]) >= p){\\n            ans = ans + value(s[i]);\\n        }\\n        else{\\n            ans = ans - value(s[i]);\\n        }\\n        p = value(s[i]);\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": "The Efficient Solution is here.  Please let it Update by adding comment reply if you do any other change and efficient solution in this code.  \\n\\nTime Complexity :- `O(n)`"
                    },
                    {
                        "username": "Djeekay",
                        "content": "Your kotlin compiler has problems with cast. Mb you use old version of it idk\nLine 17: Char 40: error: smart cast to 'Char' is impossible, because 'key' is a local variable that is captured by a changing closure\n                val inKey = dictionary[key]!!"
                    },
                    {
                        "username": "Longboiii",
                        "content": "I made my solution with many \"else if\" and the result is different EVEN WHEN I START THE SAME SOLUTION ONE MORE TIME. I just registred and this is happening, already love you, leetcode.  The compiler is just kidding, cause when I add  cout<<size(s)<<' '; to the cycle, it begins to work, but not quite good as I said."
                    },
                    {
                        "username": "Tusharkr43",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int  x=0;\\n        int size=s.length();\\n        for(int i=0;i<size;i++){\\n            if(s[i]==\\'I\\'){\\n               \\n               x=x+1;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                x=x+5;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-5+4;\\n                }\\n                \\n                \\n            }\\n            else if(s[i]==\\'X\\'){\\n                x=x+10;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-10+9;\\n                }\\n            }\\n            else if(s[i]==\\'L\\'){\\n                x=x+50;\\n                if(s[i-1]==\\'X\\'){\\n                    x=x-10-50+40;\\n                }\\n            }\\n            else if(s[i]==\\'C\\'){\\n                x=x+100;\\n                  if(s[i-1]==\\'X\\'){\\n                    x=x-10+90-100;\\n                    }\\n            }\\n            else if(s[i]==\\'D\\'){\\n                x=x+500;\\n                  if(s[i-1]==\\'C\\'){\\n                    x=x-100-500+400;\\n                }\\n            }\\n            else if(s[i]==\\'M\\'){\\n                x=x+1000;\\n                   if(s[i-1]==\\'C\\'){\\n                    x=x-100+900-1000;\\n                }\\n            }\\n            \\n        }\\n @\\n        return x;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pogozh",
                        "content": "My code works at home, but it doesn\\'t work on the site. Is this normal?)"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "I had the same trouble. If you\\'ve just started on LeetCode, check some other problems(you\\'d get a better understanding of how stuff works here) and then get back to this after a few days. I did that, and implemented a different logic, and was able to submit the solution just a few hours ago."
                    },
                    {
                        "username": "aditya7mail77",
                        "content": "Line 47: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "public int romanToInt(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int sum = 0;\\n        char ch = 0;\\n        char pre = 0;\\n        for(int i = 0, len = s.length(); i < len; i ++) {\\n            pre = ch;\\n            ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'I\\':\\n                    sum ++;\\n                    break;\\n                case \\'V\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 3;\\n                    }\\n                    else {\\n                        sum += 5;\\n                    }\\n                    break;\\n                case \\'X\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 8;\\n                    }\\n                    else {\\n                        sum += 10;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 48;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 40;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 30;\\n                    }\\n                    else {\\n                        sum += 50;\\n                    }\\n                    break;\\n                case \\'C\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 98;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 90;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 80;\\n                    }\\n                    else {\\n                        sum += 100;\\n                    }\\n                    break;\\n                case \\'D\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 498;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 490;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 480;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 300;\\n                    }\\n                    else {\\n                        sum += 500;\\n                    }\\n                    break;\\n                case \\'M\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 998;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 990;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 980;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 800;\\n                    }\\n                    else {\\n                        sum += 1000;\\n                    }\\n                    break;\\n            }\\n        }\\n        return sum;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "eryzml",
                        "content": "Have you tried to optimize your solution since your submission?"
                    }
                ]
            },
            {
                "id": 1728252,
                "content": [
                    {
                        "username": "Suraj_Kumar_Singh_5007",
                        "content": "my code is working in other compiler but in leet code it is showing error in line 82 or 75 but my code has only 74 lines ???"
                    },
                    {
                        "username": "BarryJohnson",
                        "content": "golang code\\n\\nfunc romanToInt(s string) int {\\n    ret := 0\\n\\ti := 0\\n\\tlength := len(s)\\n\\tfor ; i < length-1; i++ {\\n\\t\\t//fmt.Println(s[i : i+2])\\n\\t\\tswitch s[i : i+2] {\\n\\t\\tcase \"IV\":\\n\\t\\t\\tret += 4\\n\\t\\t\\ti += 1\\n\\t\\tcase \"IX\":\\n\\t\\t\\tret += 9\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XL\":\\n\\t\\t\\tret += 40\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XC\":\\n\\t\\t\\tret += 90\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CD\":\\n\\t\\t\\tret += 400\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CM\":\\n\\t\\t\\tret += 900\\n\\t\\t\\ti += 1\\n\\t\\tdefault:\\n\\t\\t\\tswitch s[i] {\\n\\t\\t\\tcase \\'I\\':\\n\\t\\t\\t\\tret += 1\\n\\t\\t\\tcase \\'V\\':\\n\\t\\t\\t\\tret += 5\\n\\t\\t\\tcase \\'X\\':\\n\\t\\t\\t\\tret += 10\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tret += 50\\n\\t\\t\\tcase \\'C\\':\\n\\t\\t\\t\\tret += 100\\n\\t\\t\\tcase \\'D\\':\\n\\t\\t\\t\\tret += 500\\n\\t\\t\\tcase \\'M\\':\\n\\t\\t\\t\\tret += 1000\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif i == length-1 {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'I\\':\\n\\t\\t\\tret += 1\\n\\t\\tcase \\'V\\':\\n\\t\\t\\tret += 5\\n\\t\\tcase \\'X\\':\\n\\t\\t\\tret += 10\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tret += 50\\n\\t\\tcase \\'C\\':\\n\\t\\t\\tret += 100\\n\\t\\tcase \\'D\\':\\n\\t\\t\\tret += 500\\n\\t\\tcase \\'M\\':\\n\\t\\t\\tret += 1000\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "laxminagln",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        res = 0\\n        t = {\\n            \\'I\\':1,\\n            \\'V\\':5,\\n            \\'X\\':10,\\n            \\'L\\':50,\\n            \\'C\\':100,\\n            \\'D\\':500,\\n            \\'M\\':1000\\n        }\\n        s = s.replace(\\'IV\\',\\'IIII\\')\\n        s = s.replace(\\'IX\\',\\'VIIII\\')\\n        s = s.replace(\\'XL\\',\\'XXXX\\')\\n        s = s.replace(\\'XC\\',\\'LXXXX\\')\\n        s = s.replace(\\'CD\\',\\'CCCC\\')\\n        s = s.replace(\\'CM\\',\\'DCCCC\\')\\n        for i in s:\\n            res += t[i]\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     int value(char roman){\\n\\n        switch(roman)\\n        {\\n            case \\'I\\':return 1;\\n            case \\'V\\':return 5;\\n            case \\'X\\':return 10;\\n            case \\'L\\':return 50;\\n            case \\'C\\':return 100;\\n            case \\'D\\':return 500;\\n            case \\'M\\':return 1000;\\n        }\\n        return 0;\\n    }\\n\\n    int romanToInt(string s) {\\n        int i, n, ans=0, p=0;\\n        n = s.length()-1;\\n\\n        for( i=n; i>=0; i--)\\n        {\\n        if( value(s[i]) >= p){\\n            ans = ans + value(s[i]);\\n        }\\n        else{\\n            ans = ans - value(s[i]);\\n        }\\n        p = value(s[i]);\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": "The Efficient Solution is here.  Please let it Update by adding comment reply if you do any other change and efficient solution in this code.  \\n\\nTime Complexity :- `O(n)`"
                    },
                    {
                        "username": "Djeekay",
                        "content": "Your kotlin compiler has problems with cast. Mb you use old version of it idk\nLine 17: Char 40: error: smart cast to 'Char' is impossible, because 'key' is a local variable that is captured by a changing closure\n                val inKey = dictionary[key]!!"
                    },
                    {
                        "username": "Longboiii",
                        "content": "I made my solution with many \"else if\" and the result is different EVEN WHEN I START THE SAME SOLUTION ONE MORE TIME. I just registred and this is happening, already love you, leetcode.  The compiler is just kidding, cause when I add  cout<<size(s)<<' '; to the cycle, it begins to work, but not quite good as I said."
                    },
                    {
                        "username": "Tusharkr43",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int  x=0;\\n        int size=s.length();\\n        for(int i=0;i<size;i++){\\n            if(s[i]==\\'I\\'){\\n               \\n               x=x+1;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                x=x+5;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-5+4;\\n                }\\n                \\n                \\n            }\\n            else if(s[i]==\\'X\\'){\\n                x=x+10;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-10+9;\\n                }\\n            }\\n            else if(s[i]==\\'L\\'){\\n                x=x+50;\\n                if(s[i-1]==\\'X\\'){\\n                    x=x-10-50+40;\\n                }\\n            }\\n            else if(s[i]==\\'C\\'){\\n                x=x+100;\\n                  if(s[i-1]==\\'X\\'){\\n                    x=x-10+90-100;\\n                    }\\n            }\\n            else if(s[i]==\\'D\\'){\\n                x=x+500;\\n                  if(s[i-1]==\\'C\\'){\\n                    x=x-100-500+400;\\n                }\\n            }\\n            else if(s[i]==\\'M\\'){\\n                x=x+1000;\\n                   if(s[i-1]==\\'C\\'){\\n                    x=x-100+900-1000;\\n                }\\n            }\\n            \\n        }\\n @\\n        return x;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pogozh",
                        "content": "My code works at home, but it doesn\\'t work on the site. Is this normal?)"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "I had the same trouble. If you\\'ve just started on LeetCode, check some other problems(you\\'d get a better understanding of how stuff works here) and then get back to this after a few days. I did that, and implemented a different logic, and was able to submit the solution just a few hours ago."
                    },
                    {
                        "username": "aditya7mail77",
                        "content": "Line 47: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "public int romanToInt(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int sum = 0;\\n        char ch = 0;\\n        char pre = 0;\\n        for(int i = 0, len = s.length(); i < len; i ++) {\\n            pre = ch;\\n            ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'I\\':\\n                    sum ++;\\n                    break;\\n                case \\'V\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 3;\\n                    }\\n                    else {\\n                        sum += 5;\\n                    }\\n                    break;\\n                case \\'X\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 8;\\n                    }\\n                    else {\\n                        sum += 10;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 48;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 40;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 30;\\n                    }\\n                    else {\\n                        sum += 50;\\n                    }\\n                    break;\\n                case \\'C\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 98;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 90;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 80;\\n                    }\\n                    else {\\n                        sum += 100;\\n                    }\\n                    break;\\n                case \\'D\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 498;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 490;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 480;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 300;\\n                    }\\n                    else {\\n                        sum += 500;\\n                    }\\n                    break;\\n                case \\'M\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 998;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 990;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 980;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 800;\\n                    }\\n                    else {\\n                        sum += 1000;\\n                    }\\n                    break;\\n            }\\n        }\\n        return sum;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "eryzml",
                        "content": "Have you tried to optimize your solution since your submission?"
                    }
                ]
            },
            {
                "id": 1724693,
                "content": [
                    {
                        "username": "Suraj_Kumar_Singh_5007",
                        "content": "my code is working in other compiler but in leet code it is showing error in line 82 or 75 but my code has only 74 lines ???"
                    },
                    {
                        "username": "BarryJohnson",
                        "content": "golang code\\n\\nfunc romanToInt(s string) int {\\n    ret := 0\\n\\ti := 0\\n\\tlength := len(s)\\n\\tfor ; i < length-1; i++ {\\n\\t\\t//fmt.Println(s[i : i+2])\\n\\t\\tswitch s[i : i+2] {\\n\\t\\tcase \"IV\":\\n\\t\\t\\tret += 4\\n\\t\\t\\ti += 1\\n\\t\\tcase \"IX\":\\n\\t\\t\\tret += 9\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XL\":\\n\\t\\t\\tret += 40\\n\\t\\t\\ti += 1\\n\\t\\tcase \"XC\":\\n\\t\\t\\tret += 90\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CD\":\\n\\t\\t\\tret += 400\\n\\t\\t\\ti += 1\\n\\t\\tcase \"CM\":\\n\\t\\t\\tret += 900\\n\\t\\t\\ti += 1\\n\\t\\tdefault:\\n\\t\\t\\tswitch s[i] {\\n\\t\\t\\tcase \\'I\\':\\n\\t\\t\\t\\tret += 1\\n\\t\\t\\tcase \\'V\\':\\n\\t\\t\\t\\tret += 5\\n\\t\\t\\tcase \\'X\\':\\n\\t\\t\\t\\tret += 10\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tret += 50\\n\\t\\t\\tcase \\'C\\':\\n\\t\\t\\t\\tret += 100\\n\\t\\t\\tcase \\'D\\':\\n\\t\\t\\t\\tret += 500\\n\\t\\t\\tcase \\'M\\':\\n\\t\\t\\t\\tret += 1000\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif i == length-1 {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'I\\':\\n\\t\\t\\tret += 1\\n\\t\\tcase \\'V\\':\\n\\t\\t\\tret += 5\\n\\t\\tcase \\'X\\':\\n\\t\\t\\tret += 10\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tret += 50\\n\\t\\tcase \\'C\\':\\n\\t\\t\\tret += 100\\n\\t\\tcase \\'D\\':\\n\\t\\t\\tret += 500\\n\\t\\tcase \\'M\\':\\n\\t\\t\\tret += 1000\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "laxminagln",
                        "content": "class Solution:\\n    def romanToInt(self, s: str) -> int:\\n        res = 0\\n        t = {\\n            \\'I\\':1,\\n            \\'V\\':5,\\n            \\'X\\':10,\\n            \\'L\\':50,\\n            \\'C\\':100,\\n            \\'D\\':500,\\n            \\'M\\':1000\\n        }\\n        s = s.replace(\\'IV\\',\\'IIII\\')\\n        s = s.replace(\\'IX\\',\\'VIIII\\')\\n        s = s.replace(\\'XL\\',\\'XXXX\\')\\n        s = s.replace(\\'XC\\',\\'LXXXX\\')\\n        s = s.replace(\\'CD\\',\\'CCCC\\')\\n        s = s.replace(\\'CM\\',\\'DCCCC\\')\\n        for i in s:\\n            res += t[i]\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     int value(char roman){\\n\\n        switch(roman)\\n        {\\n            case \\'I\\':return 1;\\n            case \\'V\\':return 5;\\n            case \\'X\\':return 10;\\n            case \\'L\\':return 50;\\n            case \\'C\\':return 100;\\n            case \\'D\\':return 500;\\n            case \\'M\\':return 1000;\\n        }\\n        return 0;\\n    }\\n\\n    int romanToInt(string s) {\\n        int i, n, ans=0, p=0;\\n        n = s.length()-1;\\n\\n        for( i=n; i>=0; i--)\\n        {\\n        if( value(s[i]) >= p){\\n            ans = ans + value(s[i]);\\n        }\\n        else{\\n            ans = ans - value(s[i]);\\n        }\\n        p = value(s[i]);\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ec1912",
                        "content": "The Efficient Solution is here.  Please let it Update by adding comment reply if you do any other change and efficient solution in this code.  \\n\\nTime Complexity :- `O(n)`"
                    },
                    {
                        "username": "Djeekay",
                        "content": "Your kotlin compiler has problems with cast. Mb you use old version of it idk\nLine 17: Char 40: error: smart cast to 'Char' is impossible, because 'key' is a local variable that is captured by a changing closure\n                val inKey = dictionary[key]!!"
                    },
                    {
                        "username": "Longboiii",
                        "content": "I made my solution with many \"else if\" and the result is different EVEN WHEN I START THE SAME SOLUTION ONE MORE TIME. I just registred and this is happening, already love you, leetcode.  The compiler is just kidding, cause when I add  cout<<size(s)<<' '; to the cycle, it begins to work, but not quite good as I said."
                    },
                    {
                        "username": "Tusharkr43",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n       int  x=0;\\n        int size=s.length();\\n        for(int i=0;i<size;i++){\\n            if(s[i]==\\'I\\'){\\n               \\n               x=x+1;\\n            }\\n            else if(s[i]==\\'V\\'){\\n                x=x+5;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-5+4;\\n                }\\n                \\n                \\n            }\\n            else if(s[i]==\\'X\\'){\\n                x=x+10;\\n                if(s[i-1]==\\'I\\'){\\n                    x=x-1-10+9;\\n                }\\n            }\\n            else if(s[i]==\\'L\\'){\\n                x=x+50;\\n                if(s[i-1]==\\'X\\'){\\n                    x=x-10-50+40;\\n                }\\n            }\\n            else if(s[i]==\\'C\\'){\\n                x=x+100;\\n                  if(s[i-1]==\\'X\\'){\\n                    x=x-10+90-100;\\n                    }\\n            }\\n            else if(s[i]==\\'D\\'){\\n                x=x+500;\\n                  if(s[i-1]==\\'C\\'){\\n                    x=x-100-500+400;\\n                }\\n            }\\n            else if(s[i]==\\'M\\'){\\n                x=x+1000;\\n                   if(s[i-1]==\\'C\\'){\\n                    x=x-100+900-1000;\\n                }\\n            }\\n            \\n        }\\n @\\n        return x;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pogozh",
                        "content": "My code works at home, but it doesn\\'t work on the site. Is this normal?)"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "I had the same trouble. If you\\'ve just started on LeetCode, check some other problems(you\\'d get a better understanding of how stuff works here) and then get back to this after a few days. I did that, and implemented a different logic, and was able to submit the solution just a few hours ago."
                    },
                    {
                        "username": "aditya7mail77",
                        "content": "Line 47: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~"
                    },
                    {
                        "username": "subodhkushwaha79",
                        "content": "public int romanToInt(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int sum = 0;\\n        char ch = 0;\\n        char pre = 0;\\n        for(int i = 0, len = s.length(); i < len; i ++) {\\n            pre = ch;\\n            ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'I\\':\\n                    sum ++;\\n                    break;\\n                case \\'V\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 3;\\n                    }\\n                    else {\\n                        sum += 5;\\n                    }\\n                    break;\\n                case \\'X\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 8;\\n                    }\\n                    else {\\n                        sum += 10;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 48;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 40;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 30;\\n                    }\\n                    else {\\n                        sum += 50;\\n                    }\\n                    break;\\n                case \\'C\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 98;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 90;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 80;\\n                    }\\n                    else {\\n                        sum += 100;\\n                    }\\n                    break;\\n                case \\'D\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 498;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 490;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 480;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 300;\\n                    }\\n                    else {\\n                        sum += 500;\\n                    }\\n                    break;\\n                case \\'M\\':\\n                    if (pre == \\'I\\') {\\n                        sum += 998;\\n                    }\\n                    else if (pre == \\'V\\') {\\n                        sum += 990;\\n                    }\\n                    else if (pre == \\'X\\') {\\n                        sum += 980;\\n                    }\\n                    else if (pre == \\'C\\') {\\n                        sum += 800;\\n                    }\\n                    else {\\n                        sum += 1000;\\n                    }\\n                    break;\\n            }\\n        }\\n        return sum;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "eryzml",
                        "content": "Have you tried to optimize your solution since your submission?"
                    }
                ]
            },
            {
                "id": 1724665,
                "content": [
                    {
                        "username": "Aadhitya22",
                        "content": "< Lang used - JavaScript>\\nSo, I tried solving this in my VS code, and I pass the value for Roman numeral to test each time. I get the right solution.... but I\\'m not able to get the same results here in LeetCode.\\nDoes anyone know how the value of the roman numeral is passed in LeetCode\\'s compiler?"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "[@eryzml](/eryzml) This was the first problem that I tried in leetcode, and didn\\'t really understand a few stuff here. Thanks for the reply... brought my attention back to this problem. Implemented a simpler approach now and my solution got accepted\\uD83D\\uDE05"
                    },
                    {
                        "username": "eryzml",
                        "content": "I don\\'t think it\\'s doing anything different to pass the arguments in. Did you tried conlog the string in leetcode and compare with what you pass in on VS code?"
                    },
                    {
                        "username": "stfn_ko",
                        "content": "Doesn\\'t the description explicitly say there\\'s a length constraint: 1 <= s.length() <= 15. \"MMMDCCCLXXXVIII\" is 15 characters long; hence, the result should be false(0), whereas expected result is 3888"
                    },
                    {
                        "username": "eryzml",
                        "content": "`<=` would be _less than or equal to_ so equal to 15 is within the length constraint, if it was just `<` than only lengths less than 15 would be accepted, hope that clears it up."
                    },
                    {
                        "username": "jogipraveen123",
                        "content": "What is the use of Roman and integers"
                    },
                    {
                        "username": "eryzml",
                        "content": "It was a number counting system used by the [ancient romans](https://www.britannica.com/topic/Roman-numeral)."
                    },
                    {
                        "username": "siri_d",
                        "content": "u need a dictionary or dataset to convert the string to an int"
                    },
                    {
                        "username": "Infinitesquirrel_5601",
                        "content": "Hi,\\n\\nCan anyone point me in the right direction please? Im new to python and not sure where to go .. apart from a massive for if  loop \\n\\n`#define variables \\nI = 1\\nIV = 4 \\nV = 5\\nIX = 9\\nX = 10 \\nXL = 40 \\nL = 50 \\nXC = 90 \\nC = 100 \\nCD = 400\\nD = 500\\nCM = 90 \\nM = 1000\\n\\n#input \\n\\n\\ns = input(\\'s = \\')\\ninitial = 0   \\nfor numeral in s:\\n  if s == \\'I\\' or \\'II\\' or \\'III\\':  \\n    initial = initial + I\\n  elif s == \\'IV\\':\\n    print(IV)\\n    break\\n  elif s == \\'VI\\' or \\'VII\\' or \\'VIII\\':\\n    initial = V + I \\n    initial = initial + I\\nprint(initial) "
                    },
                    {
                        "username": "eryzml",
                        "content": "One way to think about the problem is, whenever the task is to process a string of characters or an array of elements, and it has to do with calculations, try to look for some pattern in the elements that can help you generalize the problem, instead of having to use conditionals for ever possible element. I'll give a more specific hint if you like but only read if the first part isnt clear: \n\nFor this problem in particular, it is essentially an addition problem, when you read the roman numeral string you are either adding or subtracting the values to get the final value. For example, III is the same as 1 + 1 + 1, and XIV is the same as 10 - 1 + 5. So i would approach it in a way where I try to figure out how can I determine when to add and when to subtract the next value? Hope that points you in the right direction!"
                    },
                    {
                        "username": "siri_d",
                        "content": "beats 93% Javascript https://leetcode.com/problems/roman-to-integer/submissions/863400559/\\n` /**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n    let result = 0;\\n    let romanMap = []\\n    for(let i = 0;i<s.length;i++){\\n        switch(s[i]){\\n            case \\'I\\':\\n                romanMap[i] = 1;\\n                break;\\n            case \\'V\\':\\n                romanMap[i] = 5;\\n                break;\\n            case \\'X\\':\\n                romanMap[i] = 10;\\n                break;\\n            case \\'L\\':\\n                romanMap[i] = 50;\\n                break;\\n            case \\'C\\':\\n                romanMap[i] = 100;\\n                break;\\n            case \\'D\\':\\n                romanMap[i] = 500;\\n                break;\\n            case \\'M\\':\\n                romanMap[i] = 1000;\\n                break;\\n            default:null;\\n        }\\n    }\\nlet i =0;\\nlet j=1;\\n while(i<s.length){\\n     if(j<s.length && romanMap[i]<romanMap[j]){\\n         result-=romanMap[i];\\n     } else result+=romanMap[i];\\n     i++;\\n     j++;\\n }\\n return result;\\n};`\\n"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "1. create dict with 4, 9, 40, 90, 400, 900 numbers\\n2. create dict with 5, 10, 50, 100, 500, 1000 numbers\\n3. using for loop to check dict 1\\n4. if there is any number - remove it from s string\\n5. check dict 2"
                    },
                    {
                        "username": "therealadvait",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        if(s.empty()) return 0;  // if string \\'s\\' is empty this will return 0\\n        unordered_map<char,int>m = {    //making unordered_map with <key, value> pair  where key is \\'char\\' and value is \\'int\\'.\\n           {\\'I\\', 1},\\n          {\\'V\\',5},\\n         {\\'X\\',10},\\n         {\\'L\\', 50},\\n        {\\'C\\',100},\\n        {\\'D\\',500},\\n       {\\'M\\',1000}\\n        };\\n        int sum = 0;          // making variable to store sum,\\n        for(int i=0; i< s.length()-1; ++i){     // i is a pointer which will go from 0 to s.length()-1  on our string s.\\n            if(m[s[i]]< m[s[i+1]]){          // if value of pointer  at i is less then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'V\\' \\n                                                               which is before \\'X\\' then  sum = 0-5 which is 5.  \\n                sum-=m[s[i]];\\n            }else{\\n                sum+=m[s[i]];  // if value of pointer  at i is more then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'X\\' \\n                                                               which is before \\'I\\' then  sum = 0+10 which is 10.  \\n            }\\n        }\\n        sum+=m[s.back()];    // this will take the value from above and push it into end of string and repeat the process till we find our sum.\\n        return sum;\\n           \\n    }\\n\\n};"
                    },
                    {
                        "username": "12manisha",
                        "content": "Line 70: Char 17: error: use of undeclared identifier \\'Solution\\'\\n      int ret = Solution().romanToInt(param_1); return ret;\\n                ^\\n\\nI didn\\'t use line 70 , it is showing this problem and tried my code in different coding site and it is working perfectly. Why?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": " `class Solution {\npublic:\n    int romanToInt(string s) {\n        int summa=0;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='I') summa+=1;\n            else if(s[i]=='V') summa+=5;\n            else if(s[i]=='X') summa+=10;\n            else if(s[i]=='L') summa+=50;\n            else if(s[i]=='C') summa+=100;\n            else if(s[i]=='D') summa+=500;\n            else if(s[i]=='M') summa+=1000;\n        }\n        return summa;\n    }\n};`\nHere is my code.\nAnd it is giving 1994 in the 3rd case on leetcode instead of 2216. But it is working fine on my IDE. Does anyone know where is the error?"
                    },
                    {
                        "username": "jeeteshshaw",
                        "content": "Why the execution time of my code giving different, every time I submit?"
                    }
                ]
            },
            {
                "id": 1724452,
                "content": [
                    {
                        "username": "Aadhitya22",
                        "content": "< Lang used - JavaScript>\\nSo, I tried solving this in my VS code, and I pass the value for Roman numeral to test each time. I get the right solution.... but I\\'m not able to get the same results here in LeetCode.\\nDoes anyone know how the value of the roman numeral is passed in LeetCode\\'s compiler?"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "[@eryzml](/eryzml) This was the first problem that I tried in leetcode, and didn\\'t really understand a few stuff here. Thanks for the reply... brought my attention back to this problem. Implemented a simpler approach now and my solution got accepted\\uD83D\\uDE05"
                    },
                    {
                        "username": "eryzml",
                        "content": "I don\\'t think it\\'s doing anything different to pass the arguments in. Did you tried conlog the string in leetcode and compare with what you pass in on VS code?"
                    },
                    {
                        "username": "stfn_ko",
                        "content": "Doesn\\'t the description explicitly say there\\'s a length constraint: 1 <= s.length() <= 15. \"MMMDCCCLXXXVIII\" is 15 characters long; hence, the result should be false(0), whereas expected result is 3888"
                    },
                    {
                        "username": "eryzml",
                        "content": "`<=` would be _less than or equal to_ so equal to 15 is within the length constraint, if it was just `<` than only lengths less than 15 would be accepted, hope that clears it up."
                    },
                    {
                        "username": "jogipraveen123",
                        "content": "What is the use of Roman and integers"
                    },
                    {
                        "username": "eryzml",
                        "content": "It was a number counting system used by the [ancient romans](https://www.britannica.com/topic/Roman-numeral)."
                    },
                    {
                        "username": "siri_d",
                        "content": "u need a dictionary or dataset to convert the string to an int"
                    },
                    {
                        "username": "Infinitesquirrel_5601",
                        "content": "Hi,\\n\\nCan anyone point me in the right direction please? Im new to python and not sure where to go .. apart from a massive for if  loop \\n\\n`#define variables \\nI = 1\\nIV = 4 \\nV = 5\\nIX = 9\\nX = 10 \\nXL = 40 \\nL = 50 \\nXC = 90 \\nC = 100 \\nCD = 400\\nD = 500\\nCM = 90 \\nM = 1000\\n\\n#input \\n\\n\\ns = input(\\'s = \\')\\ninitial = 0   \\nfor numeral in s:\\n  if s == \\'I\\' or \\'II\\' or \\'III\\':  \\n    initial = initial + I\\n  elif s == \\'IV\\':\\n    print(IV)\\n    break\\n  elif s == \\'VI\\' or \\'VII\\' or \\'VIII\\':\\n    initial = V + I \\n    initial = initial + I\\nprint(initial) "
                    },
                    {
                        "username": "eryzml",
                        "content": "One way to think about the problem is, whenever the task is to process a string of characters or an array of elements, and it has to do with calculations, try to look for some pattern in the elements that can help you generalize the problem, instead of having to use conditionals for ever possible element. I'll give a more specific hint if you like but only read if the first part isnt clear: \n\nFor this problem in particular, it is essentially an addition problem, when you read the roman numeral string you are either adding or subtracting the values to get the final value. For example, III is the same as 1 + 1 + 1, and XIV is the same as 10 - 1 + 5. So i would approach it in a way where I try to figure out how can I determine when to add and when to subtract the next value? Hope that points you in the right direction!"
                    },
                    {
                        "username": "siri_d",
                        "content": "beats 93% Javascript https://leetcode.com/problems/roman-to-integer/submissions/863400559/\\n` /**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n    let result = 0;\\n    let romanMap = []\\n    for(let i = 0;i<s.length;i++){\\n        switch(s[i]){\\n            case \\'I\\':\\n                romanMap[i] = 1;\\n                break;\\n            case \\'V\\':\\n                romanMap[i] = 5;\\n                break;\\n            case \\'X\\':\\n                romanMap[i] = 10;\\n                break;\\n            case \\'L\\':\\n                romanMap[i] = 50;\\n                break;\\n            case \\'C\\':\\n                romanMap[i] = 100;\\n                break;\\n            case \\'D\\':\\n                romanMap[i] = 500;\\n                break;\\n            case \\'M\\':\\n                romanMap[i] = 1000;\\n                break;\\n            default:null;\\n        }\\n    }\\nlet i =0;\\nlet j=1;\\n while(i<s.length){\\n     if(j<s.length && romanMap[i]<romanMap[j]){\\n         result-=romanMap[i];\\n     } else result+=romanMap[i];\\n     i++;\\n     j++;\\n }\\n return result;\\n};`\\n"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "1. create dict with 4, 9, 40, 90, 400, 900 numbers\\n2. create dict with 5, 10, 50, 100, 500, 1000 numbers\\n3. using for loop to check dict 1\\n4. if there is any number - remove it from s string\\n5. check dict 2"
                    },
                    {
                        "username": "therealadvait",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        if(s.empty()) return 0;  // if string \\'s\\' is empty this will return 0\\n        unordered_map<char,int>m = {    //making unordered_map with <key, value> pair  where key is \\'char\\' and value is \\'int\\'.\\n           {\\'I\\', 1},\\n          {\\'V\\',5},\\n         {\\'X\\',10},\\n         {\\'L\\', 50},\\n        {\\'C\\',100},\\n        {\\'D\\',500},\\n       {\\'M\\',1000}\\n        };\\n        int sum = 0;          // making variable to store sum,\\n        for(int i=0; i< s.length()-1; ++i){     // i is a pointer which will go from 0 to s.length()-1  on our string s.\\n            if(m[s[i]]< m[s[i+1]]){          // if value of pointer  at i is less then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'V\\' \\n                                                               which is before \\'X\\' then  sum = 0-5 which is 5.  \\n                sum-=m[s[i]];\\n            }else{\\n                sum+=m[s[i]];  // if value of pointer  at i is more then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'X\\' \\n                                                               which is before \\'I\\' then  sum = 0+10 which is 10.  \\n            }\\n        }\\n        sum+=m[s.back()];    // this will take the value from above and push it into end of string and repeat the process till we find our sum.\\n        return sum;\\n           \\n    }\\n\\n};"
                    },
                    {
                        "username": "12manisha",
                        "content": "Line 70: Char 17: error: use of undeclared identifier \\'Solution\\'\\n      int ret = Solution().romanToInt(param_1); return ret;\\n                ^\\n\\nI didn\\'t use line 70 , it is showing this problem and tried my code in different coding site and it is working perfectly. Why?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": " `class Solution {\npublic:\n    int romanToInt(string s) {\n        int summa=0;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='I') summa+=1;\n            else if(s[i]=='V') summa+=5;\n            else if(s[i]=='X') summa+=10;\n            else if(s[i]=='L') summa+=50;\n            else if(s[i]=='C') summa+=100;\n            else if(s[i]=='D') summa+=500;\n            else if(s[i]=='M') summa+=1000;\n        }\n        return summa;\n    }\n};`\nHere is my code.\nAnd it is giving 1994 in the 3rd case on leetcode instead of 2216. But it is working fine on my IDE. Does anyone know where is the error?"
                    },
                    {
                        "username": "jeeteshshaw",
                        "content": "Why the execution time of my code giving different, every time I submit?"
                    }
                ]
            },
            {
                "id": 1724154,
                "content": [
                    {
                        "username": "Aadhitya22",
                        "content": "< Lang used - JavaScript>\\nSo, I tried solving this in my VS code, and I pass the value for Roman numeral to test each time. I get the right solution.... but I\\'m not able to get the same results here in LeetCode.\\nDoes anyone know how the value of the roman numeral is passed in LeetCode\\'s compiler?"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "[@eryzml](/eryzml) This was the first problem that I tried in leetcode, and didn\\'t really understand a few stuff here. Thanks for the reply... brought my attention back to this problem. Implemented a simpler approach now and my solution got accepted\\uD83D\\uDE05"
                    },
                    {
                        "username": "eryzml",
                        "content": "I don\\'t think it\\'s doing anything different to pass the arguments in. Did you tried conlog the string in leetcode and compare with what you pass in on VS code?"
                    },
                    {
                        "username": "stfn_ko",
                        "content": "Doesn\\'t the description explicitly say there\\'s a length constraint: 1 <= s.length() <= 15. \"MMMDCCCLXXXVIII\" is 15 characters long; hence, the result should be false(0), whereas expected result is 3888"
                    },
                    {
                        "username": "eryzml",
                        "content": "`<=` would be _less than or equal to_ so equal to 15 is within the length constraint, if it was just `<` than only lengths less than 15 would be accepted, hope that clears it up."
                    },
                    {
                        "username": "jogipraveen123",
                        "content": "What is the use of Roman and integers"
                    },
                    {
                        "username": "eryzml",
                        "content": "It was a number counting system used by the [ancient romans](https://www.britannica.com/topic/Roman-numeral)."
                    },
                    {
                        "username": "siri_d",
                        "content": "u need a dictionary or dataset to convert the string to an int"
                    },
                    {
                        "username": "Infinitesquirrel_5601",
                        "content": "Hi,\\n\\nCan anyone point me in the right direction please? Im new to python and not sure where to go .. apart from a massive for if  loop \\n\\n`#define variables \\nI = 1\\nIV = 4 \\nV = 5\\nIX = 9\\nX = 10 \\nXL = 40 \\nL = 50 \\nXC = 90 \\nC = 100 \\nCD = 400\\nD = 500\\nCM = 90 \\nM = 1000\\n\\n#input \\n\\n\\ns = input(\\'s = \\')\\ninitial = 0   \\nfor numeral in s:\\n  if s == \\'I\\' or \\'II\\' or \\'III\\':  \\n    initial = initial + I\\n  elif s == \\'IV\\':\\n    print(IV)\\n    break\\n  elif s == \\'VI\\' or \\'VII\\' or \\'VIII\\':\\n    initial = V + I \\n    initial = initial + I\\nprint(initial) "
                    },
                    {
                        "username": "eryzml",
                        "content": "One way to think about the problem is, whenever the task is to process a string of characters or an array of elements, and it has to do with calculations, try to look for some pattern in the elements that can help you generalize the problem, instead of having to use conditionals for ever possible element. I'll give a more specific hint if you like but only read if the first part isnt clear: \n\nFor this problem in particular, it is essentially an addition problem, when you read the roman numeral string you are either adding or subtracting the values to get the final value. For example, III is the same as 1 + 1 + 1, and XIV is the same as 10 - 1 + 5. So i would approach it in a way where I try to figure out how can I determine when to add and when to subtract the next value? Hope that points you in the right direction!"
                    },
                    {
                        "username": "siri_d",
                        "content": "beats 93% Javascript https://leetcode.com/problems/roman-to-integer/submissions/863400559/\\n` /**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n    let result = 0;\\n    let romanMap = []\\n    for(let i = 0;i<s.length;i++){\\n        switch(s[i]){\\n            case \\'I\\':\\n                romanMap[i] = 1;\\n                break;\\n            case \\'V\\':\\n                romanMap[i] = 5;\\n                break;\\n            case \\'X\\':\\n                romanMap[i] = 10;\\n                break;\\n            case \\'L\\':\\n                romanMap[i] = 50;\\n                break;\\n            case \\'C\\':\\n                romanMap[i] = 100;\\n                break;\\n            case \\'D\\':\\n                romanMap[i] = 500;\\n                break;\\n            case \\'M\\':\\n                romanMap[i] = 1000;\\n                break;\\n            default:null;\\n        }\\n    }\\nlet i =0;\\nlet j=1;\\n while(i<s.length){\\n     if(j<s.length && romanMap[i]<romanMap[j]){\\n         result-=romanMap[i];\\n     } else result+=romanMap[i];\\n     i++;\\n     j++;\\n }\\n return result;\\n};`\\n"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "1. create dict with 4, 9, 40, 90, 400, 900 numbers\\n2. create dict with 5, 10, 50, 100, 500, 1000 numbers\\n3. using for loop to check dict 1\\n4. if there is any number - remove it from s string\\n5. check dict 2"
                    },
                    {
                        "username": "therealadvait",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        if(s.empty()) return 0;  // if string \\'s\\' is empty this will return 0\\n        unordered_map<char,int>m = {    //making unordered_map with <key, value> pair  where key is \\'char\\' and value is \\'int\\'.\\n           {\\'I\\', 1},\\n          {\\'V\\',5},\\n         {\\'X\\',10},\\n         {\\'L\\', 50},\\n        {\\'C\\',100},\\n        {\\'D\\',500},\\n       {\\'M\\',1000}\\n        };\\n        int sum = 0;          // making variable to store sum,\\n        for(int i=0; i< s.length()-1; ++i){     // i is a pointer which will go from 0 to s.length()-1  on our string s.\\n            if(m[s[i]]< m[s[i+1]]){          // if value of pointer  at i is less then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'V\\' \\n                                                               which is before \\'X\\' then  sum = 0-5 which is 5.  \\n                sum-=m[s[i]];\\n            }else{\\n                sum+=m[s[i]];  // if value of pointer  at i is more then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'X\\' \\n                                                               which is before \\'I\\' then  sum = 0+10 which is 10.  \\n            }\\n        }\\n        sum+=m[s.back()];    // this will take the value from above and push it into end of string and repeat the process till we find our sum.\\n        return sum;\\n           \\n    }\\n\\n};"
                    },
                    {
                        "username": "12manisha",
                        "content": "Line 70: Char 17: error: use of undeclared identifier \\'Solution\\'\\n      int ret = Solution().romanToInt(param_1); return ret;\\n                ^\\n\\nI didn\\'t use line 70 , it is showing this problem and tried my code in different coding site and it is working perfectly. Why?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": " `class Solution {\npublic:\n    int romanToInt(string s) {\n        int summa=0;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='I') summa+=1;\n            else if(s[i]=='V') summa+=5;\n            else if(s[i]=='X') summa+=10;\n            else if(s[i]=='L') summa+=50;\n            else if(s[i]=='C') summa+=100;\n            else if(s[i]=='D') summa+=500;\n            else if(s[i]=='M') summa+=1000;\n        }\n        return summa;\n    }\n};`\nHere is my code.\nAnd it is giving 1994 in the 3rd case on leetcode instead of 2216. But it is working fine on my IDE. Does anyone know where is the error?"
                    },
                    {
                        "username": "jeeteshshaw",
                        "content": "Why the execution time of my code giving different, every time I submit?"
                    }
                ]
            },
            {
                "id": 1723997,
                "content": [
                    {
                        "username": "Aadhitya22",
                        "content": "< Lang used - JavaScript>\\nSo, I tried solving this in my VS code, and I pass the value for Roman numeral to test each time. I get the right solution.... but I\\'m not able to get the same results here in LeetCode.\\nDoes anyone know how the value of the roman numeral is passed in LeetCode\\'s compiler?"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "[@eryzml](/eryzml) This was the first problem that I tried in leetcode, and didn\\'t really understand a few stuff here. Thanks for the reply... brought my attention back to this problem. Implemented a simpler approach now and my solution got accepted\\uD83D\\uDE05"
                    },
                    {
                        "username": "eryzml",
                        "content": "I don\\'t think it\\'s doing anything different to pass the arguments in. Did you tried conlog the string in leetcode and compare with what you pass in on VS code?"
                    },
                    {
                        "username": "stfn_ko",
                        "content": "Doesn\\'t the description explicitly say there\\'s a length constraint: 1 <= s.length() <= 15. \"MMMDCCCLXXXVIII\" is 15 characters long; hence, the result should be false(0), whereas expected result is 3888"
                    },
                    {
                        "username": "eryzml",
                        "content": "`<=` would be _less than or equal to_ so equal to 15 is within the length constraint, if it was just `<` than only lengths less than 15 would be accepted, hope that clears it up."
                    },
                    {
                        "username": "jogipraveen123",
                        "content": "What is the use of Roman and integers"
                    },
                    {
                        "username": "eryzml",
                        "content": "It was a number counting system used by the [ancient romans](https://www.britannica.com/topic/Roman-numeral)."
                    },
                    {
                        "username": "siri_d",
                        "content": "u need a dictionary or dataset to convert the string to an int"
                    },
                    {
                        "username": "Infinitesquirrel_5601",
                        "content": "Hi,\\n\\nCan anyone point me in the right direction please? Im new to python and not sure where to go .. apart from a massive for if  loop \\n\\n`#define variables \\nI = 1\\nIV = 4 \\nV = 5\\nIX = 9\\nX = 10 \\nXL = 40 \\nL = 50 \\nXC = 90 \\nC = 100 \\nCD = 400\\nD = 500\\nCM = 90 \\nM = 1000\\n\\n#input \\n\\n\\ns = input(\\'s = \\')\\ninitial = 0   \\nfor numeral in s:\\n  if s == \\'I\\' or \\'II\\' or \\'III\\':  \\n    initial = initial + I\\n  elif s == \\'IV\\':\\n    print(IV)\\n    break\\n  elif s == \\'VI\\' or \\'VII\\' or \\'VIII\\':\\n    initial = V + I \\n    initial = initial + I\\nprint(initial) "
                    },
                    {
                        "username": "eryzml",
                        "content": "One way to think about the problem is, whenever the task is to process a string of characters or an array of elements, and it has to do with calculations, try to look for some pattern in the elements that can help you generalize the problem, instead of having to use conditionals for ever possible element. I'll give a more specific hint if you like but only read if the first part isnt clear: \n\nFor this problem in particular, it is essentially an addition problem, when you read the roman numeral string you are either adding or subtracting the values to get the final value. For example, III is the same as 1 + 1 + 1, and XIV is the same as 10 - 1 + 5. So i would approach it in a way where I try to figure out how can I determine when to add and when to subtract the next value? Hope that points you in the right direction!"
                    },
                    {
                        "username": "siri_d",
                        "content": "beats 93% Javascript https://leetcode.com/problems/roman-to-integer/submissions/863400559/\\n` /**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n    let result = 0;\\n    let romanMap = []\\n    for(let i = 0;i<s.length;i++){\\n        switch(s[i]){\\n            case \\'I\\':\\n                romanMap[i] = 1;\\n                break;\\n            case \\'V\\':\\n                romanMap[i] = 5;\\n                break;\\n            case \\'X\\':\\n                romanMap[i] = 10;\\n                break;\\n            case \\'L\\':\\n                romanMap[i] = 50;\\n                break;\\n            case \\'C\\':\\n                romanMap[i] = 100;\\n                break;\\n            case \\'D\\':\\n                romanMap[i] = 500;\\n                break;\\n            case \\'M\\':\\n                romanMap[i] = 1000;\\n                break;\\n            default:null;\\n        }\\n    }\\nlet i =0;\\nlet j=1;\\n while(i<s.length){\\n     if(j<s.length && romanMap[i]<romanMap[j]){\\n         result-=romanMap[i];\\n     } else result+=romanMap[i];\\n     i++;\\n     j++;\\n }\\n return result;\\n};`\\n"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "1. create dict with 4, 9, 40, 90, 400, 900 numbers\\n2. create dict with 5, 10, 50, 100, 500, 1000 numbers\\n3. using for loop to check dict 1\\n4. if there is any number - remove it from s string\\n5. check dict 2"
                    },
                    {
                        "username": "therealadvait",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        if(s.empty()) return 0;  // if string \\'s\\' is empty this will return 0\\n        unordered_map<char,int>m = {    //making unordered_map with <key, value> pair  where key is \\'char\\' and value is \\'int\\'.\\n           {\\'I\\', 1},\\n          {\\'V\\',5},\\n         {\\'X\\',10},\\n         {\\'L\\', 50},\\n        {\\'C\\',100},\\n        {\\'D\\',500},\\n       {\\'M\\',1000}\\n        };\\n        int sum = 0;          // making variable to store sum,\\n        for(int i=0; i< s.length()-1; ++i){     // i is a pointer which will go from 0 to s.length()-1  on our string s.\\n            if(m[s[i]]< m[s[i+1]]){          // if value of pointer  at i is less then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'V\\' \\n                                                               which is before \\'X\\' then  sum = 0-5 which is 5.  \\n                sum-=m[s[i]];\\n            }else{\\n                sum+=m[s[i]];  // if value of pointer  at i is more then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'X\\' \\n                                                               which is before \\'I\\' then  sum = 0+10 which is 10.  \\n            }\\n        }\\n        sum+=m[s.back()];    // this will take the value from above and push it into end of string and repeat the process till we find our sum.\\n        return sum;\\n           \\n    }\\n\\n};"
                    },
                    {
                        "username": "12manisha",
                        "content": "Line 70: Char 17: error: use of undeclared identifier \\'Solution\\'\\n      int ret = Solution().romanToInt(param_1); return ret;\\n                ^\\n\\nI didn\\'t use line 70 , it is showing this problem and tried my code in different coding site and it is working perfectly. Why?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": " `class Solution {\npublic:\n    int romanToInt(string s) {\n        int summa=0;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='I') summa+=1;\n            else if(s[i]=='V') summa+=5;\n            else if(s[i]=='X') summa+=10;\n            else if(s[i]=='L') summa+=50;\n            else if(s[i]=='C') summa+=100;\n            else if(s[i]=='D') summa+=500;\n            else if(s[i]=='M') summa+=1000;\n        }\n        return summa;\n    }\n};`\nHere is my code.\nAnd it is giving 1994 in the 3rd case on leetcode instead of 2216. But it is working fine on my IDE. Does anyone know where is the error?"
                    },
                    {
                        "username": "jeeteshshaw",
                        "content": "Why the execution time of my code giving different, every time I submit?"
                    }
                ]
            },
            {
                "id": 1723858,
                "content": [
                    {
                        "username": "Aadhitya22",
                        "content": "< Lang used - JavaScript>\\nSo, I tried solving this in my VS code, and I pass the value for Roman numeral to test each time. I get the right solution.... but I\\'m not able to get the same results here in LeetCode.\\nDoes anyone know how the value of the roman numeral is passed in LeetCode\\'s compiler?"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "[@eryzml](/eryzml) This was the first problem that I tried in leetcode, and didn\\'t really understand a few stuff here. Thanks for the reply... brought my attention back to this problem. Implemented a simpler approach now and my solution got accepted\\uD83D\\uDE05"
                    },
                    {
                        "username": "eryzml",
                        "content": "I don\\'t think it\\'s doing anything different to pass the arguments in. Did you tried conlog the string in leetcode and compare with what you pass in on VS code?"
                    },
                    {
                        "username": "stfn_ko",
                        "content": "Doesn\\'t the description explicitly say there\\'s a length constraint: 1 <= s.length() <= 15. \"MMMDCCCLXXXVIII\" is 15 characters long; hence, the result should be false(0), whereas expected result is 3888"
                    },
                    {
                        "username": "eryzml",
                        "content": "`<=` would be _less than or equal to_ so equal to 15 is within the length constraint, if it was just `<` than only lengths less than 15 would be accepted, hope that clears it up."
                    },
                    {
                        "username": "jogipraveen123",
                        "content": "What is the use of Roman and integers"
                    },
                    {
                        "username": "eryzml",
                        "content": "It was a number counting system used by the [ancient romans](https://www.britannica.com/topic/Roman-numeral)."
                    },
                    {
                        "username": "siri_d",
                        "content": "u need a dictionary or dataset to convert the string to an int"
                    },
                    {
                        "username": "Infinitesquirrel_5601",
                        "content": "Hi,\\n\\nCan anyone point me in the right direction please? Im new to python and not sure where to go .. apart from a massive for if  loop \\n\\n`#define variables \\nI = 1\\nIV = 4 \\nV = 5\\nIX = 9\\nX = 10 \\nXL = 40 \\nL = 50 \\nXC = 90 \\nC = 100 \\nCD = 400\\nD = 500\\nCM = 90 \\nM = 1000\\n\\n#input \\n\\n\\ns = input(\\'s = \\')\\ninitial = 0   \\nfor numeral in s:\\n  if s == \\'I\\' or \\'II\\' or \\'III\\':  \\n    initial = initial + I\\n  elif s == \\'IV\\':\\n    print(IV)\\n    break\\n  elif s == \\'VI\\' or \\'VII\\' or \\'VIII\\':\\n    initial = V + I \\n    initial = initial + I\\nprint(initial) "
                    },
                    {
                        "username": "eryzml",
                        "content": "One way to think about the problem is, whenever the task is to process a string of characters or an array of elements, and it has to do with calculations, try to look for some pattern in the elements that can help you generalize the problem, instead of having to use conditionals for ever possible element. I'll give a more specific hint if you like but only read if the first part isnt clear: \n\nFor this problem in particular, it is essentially an addition problem, when you read the roman numeral string you are either adding or subtracting the values to get the final value. For example, III is the same as 1 + 1 + 1, and XIV is the same as 10 - 1 + 5. So i would approach it in a way where I try to figure out how can I determine when to add and when to subtract the next value? Hope that points you in the right direction!"
                    },
                    {
                        "username": "siri_d",
                        "content": "beats 93% Javascript https://leetcode.com/problems/roman-to-integer/submissions/863400559/\\n` /**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n    let result = 0;\\n    let romanMap = []\\n    for(let i = 0;i<s.length;i++){\\n        switch(s[i]){\\n            case \\'I\\':\\n                romanMap[i] = 1;\\n                break;\\n            case \\'V\\':\\n                romanMap[i] = 5;\\n                break;\\n            case \\'X\\':\\n                romanMap[i] = 10;\\n                break;\\n            case \\'L\\':\\n                romanMap[i] = 50;\\n                break;\\n            case \\'C\\':\\n                romanMap[i] = 100;\\n                break;\\n            case \\'D\\':\\n                romanMap[i] = 500;\\n                break;\\n            case \\'M\\':\\n                romanMap[i] = 1000;\\n                break;\\n            default:null;\\n        }\\n    }\\nlet i =0;\\nlet j=1;\\n while(i<s.length){\\n     if(j<s.length && romanMap[i]<romanMap[j]){\\n         result-=romanMap[i];\\n     } else result+=romanMap[i];\\n     i++;\\n     j++;\\n }\\n return result;\\n};`\\n"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "1. create dict with 4, 9, 40, 90, 400, 900 numbers\\n2. create dict with 5, 10, 50, 100, 500, 1000 numbers\\n3. using for loop to check dict 1\\n4. if there is any number - remove it from s string\\n5. check dict 2"
                    },
                    {
                        "username": "therealadvait",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        if(s.empty()) return 0;  // if string \\'s\\' is empty this will return 0\\n        unordered_map<char,int>m = {    //making unordered_map with <key, value> pair  where key is \\'char\\' and value is \\'int\\'.\\n           {\\'I\\', 1},\\n          {\\'V\\',5},\\n         {\\'X\\',10},\\n         {\\'L\\', 50},\\n        {\\'C\\',100},\\n        {\\'D\\',500},\\n       {\\'M\\',1000}\\n        };\\n        int sum = 0;          // making variable to store sum,\\n        for(int i=0; i< s.length()-1; ++i){     // i is a pointer which will go from 0 to s.length()-1  on our string s.\\n            if(m[s[i]]< m[s[i+1]]){          // if value of pointer  at i is less then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'V\\' \\n                                                               which is before \\'X\\' then  sum = 0-5 which is 5.  \\n                sum-=m[s[i]];\\n            }else{\\n                sum+=m[s[i]];  // if value of pointer  at i is more then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'X\\' \\n                                                               which is before \\'I\\' then  sum = 0+10 which is 10.  \\n            }\\n        }\\n        sum+=m[s.back()];    // this will take the value from above and push it into end of string and repeat the process till we find our sum.\\n        return sum;\\n           \\n    }\\n\\n};"
                    },
                    {
                        "username": "12manisha",
                        "content": "Line 70: Char 17: error: use of undeclared identifier \\'Solution\\'\\n      int ret = Solution().romanToInt(param_1); return ret;\\n                ^\\n\\nI didn\\'t use line 70 , it is showing this problem and tried my code in different coding site and it is working perfectly. Why?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": " `class Solution {\npublic:\n    int romanToInt(string s) {\n        int summa=0;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='I') summa+=1;\n            else if(s[i]=='V') summa+=5;\n            else if(s[i]=='X') summa+=10;\n            else if(s[i]=='L') summa+=50;\n            else if(s[i]=='C') summa+=100;\n            else if(s[i]=='D') summa+=500;\n            else if(s[i]=='M') summa+=1000;\n        }\n        return summa;\n    }\n};`\nHere is my code.\nAnd it is giving 1994 in the 3rd case on leetcode instead of 2216. But it is working fine on my IDE. Does anyone know where is the error?"
                    },
                    {
                        "username": "jeeteshshaw",
                        "content": "Why the execution time of my code giving different, every time I submit?"
                    }
                ]
            },
            {
                "id": 1722728,
                "content": [
                    {
                        "username": "Aadhitya22",
                        "content": "< Lang used - JavaScript>\\nSo, I tried solving this in my VS code, and I pass the value for Roman numeral to test each time. I get the right solution.... but I\\'m not able to get the same results here in LeetCode.\\nDoes anyone know how the value of the roman numeral is passed in LeetCode\\'s compiler?"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "[@eryzml](/eryzml) This was the first problem that I tried in leetcode, and didn\\'t really understand a few stuff here. Thanks for the reply... brought my attention back to this problem. Implemented a simpler approach now and my solution got accepted\\uD83D\\uDE05"
                    },
                    {
                        "username": "eryzml",
                        "content": "I don\\'t think it\\'s doing anything different to pass the arguments in. Did you tried conlog the string in leetcode and compare with what you pass in on VS code?"
                    },
                    {
                        "username": "stfn_ko",
                        "content": "Doesn\\'t the description explicitly say there\\'s a length constraint: 1 <= s.length() <= 15. \"MMMDCCCLXXXVIII\" is 15 characters long; hence, the result should be false(0), whereas expected result is 3888"
                    },
                    {
                        "username": "eryzml",
                        "content": "`<=` would be _less than or equal to_ so equal to 15 is within the length constraint, if it was just `<` than only lengths less than 15 would be accepted, hope that clears it up."
                    },
                    {
                        "username": "jogipraveen123",
                        "content": "What is the use of Roman and integers"
                    },
                    {
                        "username": "eryzml",
                        "content": "It was a number counting system used by the [ancient romans](https://www.britannica.com/topic/Roman-numeral)."
                    },
                    {
                        "username": "siri_d",
                        "content": "u need a dictionary or dataset to convert the string to an int"
                    },
                    {
                        "username": "Infinitesquirrel_5601",
                        "content": "Hi,\\n\\nCan anyone point me in the right direction please? Im new to python and not sure where to go .. apart from a massive for if  loop \\n\\n`#define variables \\nI = 1\\nIV = 4 \\nV = 5\\nIX = 9\\nX = 10 \\nXL = 40 \\nL = 50 \\nXC = 90 \\nC = 100 \\nCD = 400\\nD = 500\\nCM = 90 \\nM = 1000\\n\\n#input \\n\\n\\ns = input(\\'s = \\')\\ninitial = 0   \\nfor numeral in s:\\n  if s == \\'I\\' or \\'II\\' or \\'III\\':  \\n    initial = initial + I\\n  elif s == \\'IV\\':\\n    print(IV)\\n    break\\n  elif s == \\'VI\\' or \\'VII\\' or \\'VIII\\':\\n    initial = V + I \\n    initial = initial + I\\nprint(initial) "
                    },
                    {
                        "username": "eryzml",
                        "content": "One way to think about the problem is, whenever the task is to process a string of characters or an array of elements, and it has to do with calculations, try to look for some pattern in the elements that can help you generalize the problem, instead of having to use conditionals for ever possible element. I'll give a more specific hint if you like but only read if the first part isnt clear: \n\nFor this problem in particular, it is essentially an addition problem, when you read the roman numeral string you are either adding or subtracting the values to get the final value. For example, III is the same as 1 + 1 + 1, and XIV is the same as 10 - 1 + 5. So i would approach it in a way where I try to figure out how can I determine when to add and when to subtract the next value? Hope that points you in the right direction!"
                    },
                    {
                        "username": "siri_d",
                        "content": "beats 93% Javascript https://leetcode.com/problems/roman-to-integer/submissions/863400559/\\n` /**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n    let result = 0;\\n    let romanMap = []\\n    for(let i = 0;i<s.length;i++){\\n        switch(s[i]){\\n            case \\'I\\':\\n                romanMap[i] = 1;\\n                break;\\n            case \\'V\\':\\n                romanMap[i] = 5;\\n                break;\\n            case \\'X\\':\\n                romanMap[i] = 10;\\n                break;\\n            case \\'L\\':\\n                romanMap[i] = 50;\\n                break;\\n            case \\'C\\':\\n                romanMap[i] = 100;\\n                break;\\n            case \\'D\\':\\n                romanMap[i] = 500;\\n                break;\\n            case \\'M\\':\\n                romanMap[i] = 1000;\\n                break;\\n            default:null;\\n        }\\n    }\\nlet i =0;\\nlet j=1;\\n while(i<s.length){\\n     if(j<s.length && romanMap[i]<romanMap[j]){\\n         result-=romanMap[i];\\n     } else result+=romanMap[i];\\n     i++;\\n     j++;\\n }\\n return result;\\n};`\\n"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "1. create dict with 4, 9, 40, 90, 400, 900 numbers\\n2. create dict with 5, 10, 50, 100, 500, 1000 numbers\\n3. using for loop to check dict 1\\n4. if there is any number - remove it from s string\\n5. check dict 2"
                    },
                    {
                        "username": "therealadvait",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        if(s.empty()) return 0;  // if string \\'s\\' is empty this will return 0\\n        unordered_map<char,int>m = {    //making unordered_map with <key, value> pair  where key is \\'char\\' and value is \\'int\\'.\\n           {\\'I\\', 1},\\n          {\\'V\\',5},\\n         {\\'X\\',10},\\n         {\\'L\\', 50},\\n        {\\'C\\',100},\\n        {\\'D\\',500},\\n       {\\'M\\',1000}\\n        };\\n        int sum = 0;          // making variable to store sum,\\n        for(int i=0; i< s.length()-1; ++i){     // i is a pointer which will go from 0 to s.length()-1  on our string s.\\n            if(m[s[i]]< m[s[i+1]]){          // if value of pointer  at i is less then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'V\\' \\n                                                               which is before \\'X\\' then  sum = 0-5 which is 5.  \\n                sum-=m[s[i]];\\n            }else{\\n                sum+=m[s[i]];  // if value of pointer  at i is more then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'X\\' \\n                                                               which is before \\'I\\' then  sum = 0+10 which is 10.  \\n            }\\n        }\\n        sum+=m[s.back()];    // this will take the value from above and push it into end of string and repeat the process till we find our sum.\\n        return sum;\\n           \\n    }\\n\\n};"
                    },
                    {
                        "username": "12manisha",
                        "content": "Line 70: Char 17: error: use of undeclared identifier \\'Solution\\'\\n      int ret = Solution().romanToInt(param_1); return ret;\\n                ^\\n\\nI didn\\'t use line 70 , it is showing this problem and tried my code in different coding site and it is working perfectly. Why?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": " `class Solution {\npublic:\n    int romanToInt(string s) {\n        int summa=0;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='I') summa+=1;\n            else if(s[i]=='V') summa+=5;\n            else if(s[i]=='X') summa+=10;\n            else if(s[i]=='L') summa+=50;\n            else if(s[i]=='C') summa+=100;\n            else if(s[i]=='D') summa+=500;\n            else if(s[i]=='M') summa+=1000;\n        }\n        return summa;\n    }\n};`\nHere is my code.\nAnd it is giving 1994 in the 3rd case on leetcode instead of 2216. But it is working fine on my IDE. Does anyone know where is the error?"
                    },
                    {
                        "username": "jeeteshshaw",
                        "content": "Why the execution time of my code giving different, every time I submit?"
                    }
                ]
            },
            {
                "id": 1720950,
                "content": [
                    {
                        "username": "Aadhitya22",
                        "content": "< Lang used - JavaScript>\\nSo, I tried solving this in my VS code, and I pass the value for Roman numeral to test each time. I get the right solution.... but I\\'m not able to get the same results here in LeetCode.\\nDoes anyone know how the value of the roman numeral is passed in LeetCode\\'s compiler?"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "[@eryzml](/eryzml) This was the first problem that I tried in leetcode, and didn\\'t really understand a few stuff here. Thanks for the reply... brought my attention back to this problem. Implemented a simpler approach now and my solution got accepted\\uD83D\\uDE05"
                    },
                    {
                        "username": "eryzml",
                        "content": "I don\\'t think it\\'s doing anything different to pass the arguments in. Did you tried conlog the string in leetcode and compare with what you pass in on VS code?"
                    },
                    {
                        "username": "stfn_ko",
                        "content": "Doesn\\'t the description explicitly say there\\'s a length constraint: 1 <= s.length() <= 15. \"MMMDCCCLXXXVIII\" is 15 characters long; hence, the result should be false(0), whereas expected result is 3888"
                    },
                    {
                        "username": "eryzml",
                        "content": "`<=` would be _less than or equal to_ so equal to 15 is within the length constraint, if it was just `<` than only lengths less than 15 would be accepted, hope that clears it up."
                    },
                    {
                        "username": "jogipraveen123",
                        "content": "What is the use of Roman and integers"
                    },
                    {
                        "username": "eryzml",
                        "content": "It was a number counting system used by the [ancient romans](https://www.britannica.com/topic/Roman-numeral)."
                    },
                    {
                        "username": "siri_d",
                        "content": "u need a dictionary or dataset to convert the string to an int"
                    },
                    {
                        "username": "Infinitesquirrel_5601",
                        "content": "Hi,\\n\\nCan anyone point me in the right direction please? Im new to python and not sure where to go .. apart from a massive for if  loop \\n\\n`#define variables \\nI = 1\\nIV = 4 \\nV = 5\\nIX = 9\\nX = 10 \\nXL = 40 \\nL = 50 \\nXC = 90 \\nC = 100 \\nCD = 400\\nD = 500\\nCM = 90 \\nM = 1000\\n\\n#input \\n\\n\\ns = input(\\'s = \\')\\ninitial = 0   \\nfor numeral in s:\\n  if s == \\'I\\' or \\'II\\' or \\'III\\':  \\n    initial = initial + I\\n  elif s == \\'IV\\':\\n    print(IV)\\n    break\\n  elif s == \\'VI\\' or \\'VII\\' or \\'VIII\\':\\n    initial = V + I \\n    initial = initial + I\\nprint(initial) "
                    },
                    {
                        "username": "eryzml",
                        "content": "One way to think about the problem is, whenever the task is to process a string of characters or an array of elements, and it has to do with calculations, try to look for some pattern in the elements that can help you generalize the problem, instead of having to use conditionals for ever possible element. I'll give a more specific hint if you like but only read if the first part isnt clear: \n\nFor this problem in particular, it is essentially an addition problem, when you read the roman numeral string you are either adding or subtracting the values to get the final value. For example, III is the same as 1 + 1 + 1, and XIV is the same as 10 - 1 + 5. So i would approach it in a way where I try to figure out how can I determine when to add and when to subtract the next value? Hope that points you in the right direction!"
                    },
                    {
                        "username": "siri_d",
                        "content": "beats 93% Javascript https://leetcode.com/problems/roman-to-integer/submissions/863400559/\\n` /**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n    let result = 0;\\n    let romanMap = []\\n    for(let i = 0;i<s.length;i++){\\n        switch(s[i]){\\n            case \\'I\\':\\n                romanMap[i] = 1;\\n                break;\\n            case \\'V\\':\\n                romanMap[i] = 5;\\n                break;\\n            case \\'X\\':\\n                romanMap[i] = 10;\\n                break;\\n            case \\'L\\':\\n                romanMap[i] = 50;\\n                break;\\n            case \\'C\\':\\n                romanMap[i] = 100;\\n                break;\\n            case \\'D\\':\\n                romanMap[i] = 500;\\n                break;\\n            case \\'M\\':\\n                romanMap[i] = 1000;\\n                break;\\n            default:null;\\n        }\\n    }\\nlet i =0;\\nlet j=1;\\n while(i<s.length){\\n     if(j<s.length && romanMap[i]<romanMap[j]){\\n         result-=romanMap[i];\\n     } else result+=romanMap[i];\\n     i++;\\n     j++;\\n }\\n return result;\\n};`\\n"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "1. create dict with 4, 9, 40, 90, 400, 900 numbers\\n2. create dict with 5, 10, 50, 100, 500, 1000 numbers\\n3. using for loop to check dict 1\\n4. if there is any number - remove it from s string\\n5. check dict 2"
                    },
                    {
                        "username": "therealadvait",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        if(s.empty()) return 0;  // if string \\'s\\' is empty this will return 0\\n        unordered_map<char,int>m = {    //making unordered_map with <key, value> pair  where key is \\'char\\' and value is \\'int\\'.\\n           {\\'I\\', 1},\\n          {\\'V\\',5},\\n         {\\'X\\',10},\\n         {\\'L\\', 50},\\n        {\\'C\\',100},\\n        {\\'D\\',500},\\n       {\\'M\\',1000}\\n        };\\n        int sum = 0;          // making variable to store sum,\\n        for(int i=0; i< s.length()-1; ++i){     // i is a pointer which will go from 0 to s.length()-1  on our string s.\\n            if(m[s[i]]< m[s[i+1]]){          // if value of pointer  at i is less then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'V\\' \\n                                                               which is before \\'X\\' then  sum = 0-5 which is 5.  \\n                sum-=m[s[i]];\\n            }else{\\n                sum+=m[s[i]];  // if value of pointer  at i is more then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'X\\' \\n                                                               which is before \\'I\\' then  sum = 0+10 which is 10.  \\n            }\\n        }\\n        sum+=m[s.back()];    // this will take the value from above and push it into end of string and repeat the process till we find our sum.\\n        return sum;\\n           \\n    }\\n\\n};"
                    },
                    {
                        "username": "12manisha",
                        "content": "Line 70: Char 17: error: use of undeclared identifier \\'Solution\\'\\n      int ret = Solution().romanToInt(param_1); return ret;\\n                ^\\n\\nI didn\\'t use line 70 , it is showing this problem and tried my code in different coding site and it is working perfectly. Why?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": " `class Solution {\npublic:\n    int romanToInt(string s) {\n        int summa=0;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='I') summa+=1;\n            else if(s[i]=='V') summa+=5;\n            else if(s[i]=='X') summa+=10;\n            else if(s[i]=='L') summa+=50;\n            else if(s[i]=='C') summa+=100;\n            else if(s[i]=='D') summa+=500;\n            else if(s[i]=='M') summa+=1000;\n        }\n        return summa;\n    }\n};`\nHere is my code.\nAnd it is giving 1994 in the 3rd case on leetcode instead of 2216. But it is working fine on my IDE. Does anyone know where is the error?"
                    },
                    {
                        "username": "jeeteshshaw",
                        "content": "Why the execution time of my code giving different, every time I submit?"
                    }
                ]
            },
            {
                "id": 1720736,
                "content": [
                    {
                        "username": "Aadhitya22",
                        "content": "< Lang used - JavaScript>\\nSo, I tried solving this in my VS code, and I pass the value for Roman numeral to test each time. I get the right solution.... but I\\'m not able to get the same results here in LeetCode.\\nDoes anyone know how the value of the roman numeral is passed in LeetCode\\'s compiler?"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "[@eryzml](/eryzml) This was the first problem that I tried in leetcode, and didn\\'t really understand a few stuff here. Thanks for the reply... brought my attention back to this problem. Implemented a simpler approach now and my solution got accepted\\uD83D\\uDE05"
                    },
                    {
                        "username": "eryzml",
                        "content": "I don\\'t think it\\'s doing anything different to pass the arguments in. Did you tried conlog the string in leetcode and compare with what you pass in on VS code?"
                    },
                    {
                        "username": "stfn_ko",
                        "content": "Doesn\\'t the description explicitly say there\\'s a length constraint: 1 <= s.length() <= 15. \"MMMDCCCLXXXVIII\" is 15 characters long; hence, the result should be false(0), whereas expected result is 3888"
                    },
                    {
                        "username": "eryzml",
                        "content": "`<=` would be _less than or equal to_ so equal to 15 is within the length constraint, if it was just `<` than only lengths less than 15 would be accepted, hope that clears it up."
                    },
                    {
                        "username": "jogipraveen123",
                        "content": "What is the use of Roman and integers"
                    },
                    {
                        "username": "eryzml",
                        "content": "It was a number counting system used by the [ancient romans](https://www.britannica.com/topic/Roman-numeral)."
                    },
                    {
                        "username": "siri_d",
                        "content": "u need a dictionary or dataset to convert the string to an int"
                    },
                    {
                        "username": "Infinitesquirrel_5601",
                        "content": "Hi,\\n\\nCan anyone point me in the right direction please? Im new to python and not sure where to go .. apart from a massive for if  loop \\n\\n`#define variables \\nI = 1\\nIV = 4 \\nV = 5\\nIX = 9\\nX = 10 \\nXL = 40 \\nL = 50 \\nXC = 90 \\nC = 100 \\nCD = 400\\nD = 500\\nCM = 90 \\nM = 1000\\n\\n#input \\n\\n\\ns = input(\\'s = \\')\\ninitial = 0   \\nfor numeral in s:\\n  if s == \\'I\\' or \\'II\\' or \\'III\\':  \\n    initial = initial + I\\n  elif s == \\'IV\\':\\n    print(IV)\\n    break\\n  elif s == \\'VI\\' or \\'VII\\' or \\'VIII\\':\\n    initial = V + I \\n    initial = initial + I\\nprint(initial) "
                    },
                    {
                        "username": "eryzml",
                        "content": "One way to think about the problem is, whenever the task is to process a string of characters or an array of elements, and it has to do with calculations, try to look for some pattern in the elements that can help you generalize the problem, instead of having to use conditionals for ever possible element. I'll give a more specific hint if you like but only read if the first part isnt clear: \n\nFor this problem in particular, it is essentially an addition problem, when you read the roman numeral string you are either adding or subtracting the values to get the final value. For example, III is the same as 1 + 1 + 1, and XIV is the same as 10 - 1 + 5. So i would approach it in a way where I try to figure out how can I determine when to add and when to subtract the next value? Hope that points you in the right direction!"
                    },
                    {
                        "username": "siri_d",
                        "content": "beats 93% Javascript https://leetcode.com/problems/roman-to-integer/submissions/863400559/\\n` /**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n    let result = 0;\\n    let romanMap = []\\n    for(let i = 0;i<s.length;i++){\\n        switch(s[i]){\\n            case \\'I\\':\\n                romanMap[i] = 1;\\n                break;\\n            case \\'V\\':\\n                romanMap[i] = 5;\\n                break;\\n            case \\'X\\':\\n                romanMap[i] = 10;\\n                break;\\n            case \\'L\\':\\n                romanMap[i] = 50;\\n                break;\\n            case \\'C\\':\\n                romanMap[i] = 100;\\n                break;\\n            case \\'D\\':\\n                romanMap[i] = 500;\\n                break;\\n            case \\'M\\':\\n                romanMap[i] = 1000;\\n                break;\\n            default:null;\\n        }\\n    }\\nlet i =0;\\nlet j=1;\\n while(i<s.length){\\n     if(j<s.length && romanMap[i]<romanMap[j]){\\n         result-=romanMap[i];\\n     } else result+=romanMap[i];\\n     i++;\\n     j++;\\n }\\n return result;\\n};`\\n"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "1. create dict with 4, 9, 40, 90, 400, 900 numbers\\n2. create dict with 5, 10, 50, 100, 500, 1000 numbers\\n3. using for loop to check dict 1\\n4. if there is any number - remove it from s string\\n5. check dict 2"
                    },
                    {
                        "username": "therealadvait",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        if(s.empty()) return 0;  // if string \\'s\\' is empty this will return 0\\n        unordered_map<char,int>m = {    //making unordered_map with <key, value> pair  where key is \\'char\\' and value is \\'int\\'.\\n           {\\'I\\', 1},\\n          {\\'V\\',5},\\n         {\\'X\\',10},\\n         {\\'L\\', 50},\\n        {\\'C\\',100},\\n        {\\'D\\',500},\\n       {\\'M\\',1000}\\n        };\\n        int sum = 0;          // making variable to store sum,\\n        for(int i=0; i< s.length()-1; ++i){     // i is a pointer which will go from 0 to s.length()-1  on our string s.\\n            if(m[s[i]]< m[s[i+1]]){          // if value of pointer  at i is less then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'V\\' \\n                                                               which is before \\'X\\' then  sum = 0-5 which is 5.  \\n                sum-=m[s[i]];\\n            }else{\\n                sum+=m[s[i]];  // if value of pointer  at i is more then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'X\\' \\n                                                               which is before \\'I\\' then  sum = 0+10 which is 10.  \\n            }\\n        }\\n        sum+=m[s.back()];    // this will take the value from above and push it into end of string and repeat the process till we find our sum.\\n        return sum;\\n           \\n    }\\n\\n};"
                    },
                    {
                        "username": "12manisha",
                        "content": "Line 70: Char 17: error: use of undeclared identifier \\'Solution\\'\\n      int ret = Solution().romanToInt(param_1); return ret;\\n                ^\\n\\nI didn\\'t use line 70 , it is showing this problem and tried my code in different coding site and it is working perfectly. Why?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": " `class Solution {\npublic:\n    int romanToInt(string s) {\n        int summa=0;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='I') summa+=1;\n            else if(s[i]=='V') summa+=5;\n            else if(s[i]=='X') summa+=10;\n            else if(s[i]=='L') summa+=50;\n            else if(s[i]=='C') summa+=100;\n            else if(s[i]=='D') summa+=500;\n            else if(s[i]=='M') summa+=1000;\n        }\n        return summa;\n    }\n};`\nHere is my code.\nAnd it is giving 1994 in the 3rd case on leetcode instead of 2216. But it is working fine on my IDE. Does anyone know where is the error?"
                    },
                    {
                        "username": "jeeteshshaw",
                        "content": "Why the execution time of my code giving different, every time I submit?"
                    }
                ]
            },
            {
                "id": 1720637,
                "content": [
                    {
                        "username": "Aadhitya22",
                        "content": "< Lang used - JavaScript>\\nSo, I tried solving this in my VS code, and I pass the value for Roman numeral to test each time. I get the right solution.... but I\\'m not able to get the same results here in LeetCode.\\nDoes anyone know how the value of the roman numeral is passed in LeetCode\\'s compiler?"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "[@eryzml](/eryzml) This was the first problem that I tried in leetcode, and didn\\'t really understand a few stuff here. Thanks for the reply... brought my attention back to this problem. Implemented a simpler approach now and my solution got accepted\\uD83D\\uDE05"
                    },
                    {
                        "username": "eryzml",
                        "content": "I don\\'t think it\\'s doing anything different to pass the arguments in. Did you tried conlog the string in leetcode and compare with what you pass in on VS code?"
                    },
                    {
                        "username": "stfn_ko",
                        "content": "Doesn\\'t the description explicitly say there\\'s a length constraint: 1 <= s.length() <= 15. \"MMMDCCCLXXXVIII\" is 15 characters long; hence, the result should be false(0), whereas expected result is 3888"
                    },
                    {
                        "username": "eryzml",
                        "content": "`<=` would be _less than or equal to_ so equal to 15 is within the length constraint, if it was just `<` than only lengths less than 15 would be accepted, hope that clears it up."
                    },
                    {
                        "username": "jogipraveen123",
                        "content": "What is the use of Roman and integers"
                    },
                    {
                        "username": "eryzml",
                        "content": "It was a number counting system used by the [ancient romans](https://www.britannica.com/topic/Roman-numeral)."
                    },
                    {
                        "username": "siri_d",
                        "content": "u need a dictionary or dataset to convert the string to an int"
                    },
                    {
                        "username": "Infinitesquirrel_5601",
                        "content": "Hi,\\n\\nCan anyone point me in the right direction please? Im new to python and not sure where to go .. apart from a massive for if  loop \\n\\n`#define variables \\nI = 1\\nIV = 4 \\nV = 5\\nIX = 9\\nX = 10 \\nXL = 40 \\nL = 50 \\nXC = 90 \\nC = 100 \\nCD = 400\\nD = 500\\nCM = 90 \\nM = 1000\\n\\n#input \\n\\n\\ns = input(\\'s = \\')\\ninitial = 0   \\nfor numeral in s:\\n  if s == \\'I\\' or \\'II\\' or \\'III\\':  \\n    initial = initial + I\\n  elif s == \\'IV\\':\\n    print(IV)\\n    break\\n  elif s == \\'VI\\' or \\'VII\\' or \\'VIII\\':\\n    initial = V + I \\n    initial = initial + I\\nprint(initial) "
                    },
                    {
                        "username": "eryzml",
                        "content": "One way to think about the problem is, whenever the task is to process a string of characters or an array of elements, and it has to do with calculations, try to look for some pattern in the elements that can help you generalize the problem, instead of having to use conditionals for ever possible element. I'll give a more specific hint if you like but only read if the first part isnt clear: \n\nFor this problem in particular, it is essentially an addition problem, when you read the roman numeral string you are either adding or subtracting the values to get the final value. For example, III is the same as 1 + 1 + 1, and XIV is the same as 10 - 1 + 5. So i would approach it in a way where I try to figure out how can I determine when to add and when to subtract the next value? Hope that points you in the right direction!"
                    },
                    {
                        "username": "siri_d",
                        "content": "beats 93% Javascript https://leetcode.com/problems/roman-to-integer/submissions/863400559/\\n` /**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n    let result = 0;\\n    let romanMap = []\\n    for(let i = 0;i<s.length;i++){\\n        switch(s[i]){\\n            case \\'I\\':\\n                romanMap[i] = 1;\\n                break;\\n            case \\'V\\':\\n                romanMap[i] = 5;\\n                break;\\n            case \\'X\\':\\n                romanMap[i] = 10;\\n                break;\\n            case \\'L\\':\\n                romanMap[i] = 50;\\n                break;\\n            case \\'C\\':\\n                romanMap[i] = 100;\\n                break;\\n            case \\'D\\':\\n                romanMap[i] = 500;\\n                break;\\n            case \\'M\\':\\n                romanMap[i] = 1000;\\n                break;\\n            default:null;\\n        }\\n    }\\nlet i =0;\\nlet j=1;\\n while(i<s.length){\\n     if(j<s.length && romanMap[i]<romanMap[j]){\\n         result-=romanMap[i];\\n     } else result+=romanMap[i];\\n     i++;\\n     j++;\\n }\\n return result;\\n};`\\n"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "1. create dict with 4, 9, 40, 90, 400, 900 numbers\\n2. create dict with 5, 10, 50, 100, 500, 1000 numbers\\n3. using for loop to check dict 1\\n4. if there is any number - remove it from s string\\n5. check dict 2"
                    },
                    {
                        "username": "therealadvait",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        if(s.empty()) return 0;  // if string \\'s\\' is empty this will return 0\\n        unordered_map<char,int>m = {    //making unordered_map with <key, value> pair  where key is \\'char\\' and value is \\'int\\'.\\n           {\\'I\\', 1},\\n          {\\'V\\',5},\\n         {\\'X\\',10},\\n         {\\'L\\', 50},\\n        {\\'C\\',100},\\n        {\\'D\\',500},\\n       {\\'M\\',1000}\\n        };\\n        int sum = 0;          // making variable to store sum,\\n        for(int i=0; i< s.length()-1; ++i){     // i is a pointer which will go from 0 to s.length()-1  on our string s.\\n            if(m[s[i]]< m[s[i+1]]){          // if value of pointer  at i is less then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'V\\' \\n                                                               which is before \\'X\\' then  sum = 0-5 which is 5.  \\n                sum-=m[s[i]];\\n            }else{\\n                sum+=m[s[i]];  // if value of pointer  at i is more then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'X\\' \\n                                                               which is before \\'I\\' then  sum = 0+10 which is 10.  \\n            }\\n        }\\n        sum+=m[s.back()];    // this will take the value from above and push it into end of string and repeat the process till we find our sum.\\n        return sum;\\n           \\n    }\\n\\n};"
                    },
                    {
                        "username": "12manisha",
                        "content": "Line 70: Char 17: error: use of undeclared identifier \\'Solution\\'\\n      int ret = Solution().romanToInt(param_1); return ret;\\n                ^\\n\\nI didn\\'t use line 70 , it is showing this problem and tried my code in different coding site and it is working perfectly. Why?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": " `class Solution {\npublic:\n    int romanToInt(string s) {\n        int summa=0;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='I') summa+=1;\n            else if(s[i]=='V') summa+=5;\n            else if(s[i]=='X') summa+=10;\n            else if(s[i]=='L') summa+=50;\n            else if(s[i]=='C') summa+=100;\n            else if(s[i]=='D') summa+=500;\n            else if(s[i]=='M') summa+=1000;\n        }\n        return summa;\n    }\n};`\nHere is my code.\nAnd it is giving 1994 in the 3rd case on leetcode instead of 2216. But it is working fine on my IDE. Does anyone know where is the error?"
                    },
                    {
                        "username": "jeeteshshaw",
                        "content": "Why the execution time of my code giving different, every time I submit?"
                    }
                ]
            },
            {
                "id": 1720231,
                "content": [
                    {
                        "username": "Aadhitya22",
                        "content": "< Lang used - JavaScript>\\nSo, I tried solving this in my VS code, and I pass the value for Roman numeral to test each time. I get the right solution.... but I\\'m not able to get the same results here in LeetCode.\\nDoes anyone know how the value of the roman numeral is passed in LeetCode\\'s compiler?"
                    },
                    {
                        "username": "Aadhitya22",
                        "content": "[@eryzml](/eryzml) This was the first problem that I tried in leetcode, and didn\\'t really understand a few stuff here. Thanks for the reply... brought my attention back to this problem. Implemented a simpler approach now and my solution got accepted\\uD83D\\uDE05"
                    },
                    {
                        "username": "eryzml",
                        "content": "I don\\'t think it\\'s doing anything different to pass the arguments in. Did you tried conlog the string in leetcode and compare with what you pass in on VS code?"
                    },
                    {
                        "username": "stfn_ko",
                        "content": "Doesn\\'t the description explicitly say there\\'s a length constraint: 1 <= s.length() <= 15. \"MMMDCCCLXXXVIII\" is 15 characters long; hence, the result should be false(0), whereas expected result is 3888"
                    },
                    {
                        "username": "eryzml",
                        "content": "`<=` would be _less than or equal to_ so equal to 15 is within the length constraint, if it was just `<` than only lengths less than 15 would be accepted, hope that clears it up."
                    },
                    {
                        "username": "jogipraveen123",
                        "content": "What is the use of Roman and integers"
                    },
                    {
                        "username": "eryzml",
                        "content": "It was a number counting system used by the [ancient romans](https://www.britannica.com/topic/Roman-numeral)."
                    },
                    {
                        "username": "siri_d",
                        "content": "u need a dictionary or dataset to convert the string to an int"
                    },
                    {
                        "username": "Infinitesquirrel_5601",
                        "content": "Hi,\\n\\nCan anyone point me in the right direction please? Im new to python and not sure where to go .. apart from a massive for if  loop \\n\\n`#define variables \\nI = 1\\nIV = 4 \\nV = 5\\nIX = 9\\nX = 10 \\nXL = 40 \\nL = 50 \\nXC = 90 \\nC = 100 \\nCD = 400\\nD = 500\\nCM = 90 \\nM = 1000\\n\\n#input \\n\\n\\ns = input(\\'s = \\')\\ninitial = 0   \\nfor numeral in s:\\n  if s == \\'I\\' or \\'II\\' or \\'III\\':  \\n    initial = initial + I\\n  elif s == \\'IV\\':\\n    print(IV)\\n    break\\n  elif s == \\'VI\\' or \\'VII\\' or \\'VIII\\':\\n    initial = V + I \\n    initial = initial + I\\nprint(initial) "
                    },
                    {
                        "username": "eryzml",
                        "content": "One way to think about the problem is, whenever the task is to process a string of characters or an array of elements, and it has to do with calculations, try to look for some pattern in the elements that can help you generalize the problem, instead of having to use conditionals for ever possible element. I'll give a more specific hint if you like but only read if the first part isnt clear: \n\nFor this problem in particular, it is essentially an addition problem, when you read the roman numeral string you are either adding or subtracting the values to get the final value. For example, III is the same as 1 + 1 + 1, and XIV is the same as 10 - 1 + 5. So i would approach it in a way where I try to figure out how can I determine when to add and when to subtract the next value? Hope that points you in the right direction!"
                    },
                    {
                        "username": "siri_d",
                        "content": "beats 93% Javascript https://leetcode.com/problems/roman-to-integer/submissions/863400559/\\n` /**\\n * @param {string} s\\n * @return {number}\\n */\\nvar romanToInt = function(s) {\\n    let result = 0;\\n    let romanMap = []\\n    for(let i = 0;i<s.length;i++){\\n        switch(s[i]){\\n            case \\'I\\':\\n                romanMap[i] = 1;\\n                break;\\n            case \\'V\\':\\n                romanMap[i] = 5;\\n                break;\\n            case \\'X\\':\\n                romanMap[i] = 10;\\n                break;\\n            case \\'L\\':\\n                romanMap[i] = 50;\\n                break;\\n            case \\'C\\':\\n                romanMap[i] = 100;\\n                break;\\n            case \\'D\\':\\n                romanMap[i] = 500;\\n                break;\\n            case \\'M\\':\\n                romanMap[i] = 1000;\\n                break;\\n            default:null;\\n        }\\n    }\\nlet i =0;\\nlet j=1;\\n while(i<s.length){\\n     if(j<s.length && romanMap[i]<romanMap[j]){\\n         result-=romanMap[i];\\n     } else result+=romanMap[i];\\n     i++;\\n     j++;\\n }\\n return result;\\n};`\\n"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "1. create dict with 4, 9, 40, 90, 400, 900 numbers\\n2. create dict with 5, 10, 50, 100, 500, 1000 numbers\\n3. using for loop to check dict 1\\n4. if there is any number - remove it from s string\\n5. check dict 2"
                    },
                    {
                        "username": "therealadvait",
                        "content": "class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        if(s.empty()) return 0;  // if string \\'s\\' is empty this will return 0\\n        unordered_map<char,int>m = {    //making unordered_map with <key, value> pair  where key is \\'char\\' and value is \\'int\\'.\\n           {\\'I\\', 1},\\n          {\\'V\\',5},\\n         {\\'X\\',10},\\n         {\\'L\\', 50},\\n        {\\'C\\',100},\\n        {\\'D\\',500},\\n       {\\'M\\',1000}\\n        };\\n        int sum = 0;          // making variable to store sum,\\n        for(int i=0; i< s.length()-1; ++i){     // i is a pointer which will go from 0 to s.length()-1  on our string s.\\n            if(m[s[i]]< m[s[i+1]]){          // if value of pointer  at i is less then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'V\\' \\n                                                               which is before \\'X\\' then  sum = 0-5 which is 5.  \\n                sum-=m[s[i]];\\n            }else{\\n                sum+=m[s[i]];  // if value of pointer  at i is more then value at i+1 (eg: if we consider string \\'IVXIX\\' and consider i is a \\'X\\' \\n                                                               which is before \\'I\\' then  sum = 0+10 which is 10.  \\n            }\\n        }\\n        sum+=m[s.back()];    // this will take the value from above and push it into end of string and repeat the process till we find our sum.\\n        return sum;\\n           \\n    }\\n\\n};"
                    },
                    {
                        "username": "12manisha",
                        "content": "Line 70: Char 17: error: use of undeclared identifier \\'Solution\\'\\n      int ret = Solution().romanToInt(param_1); return ret;\\n                ^\\n\\nI didn\\'t use line 70 , it is showing this problem and tried my code in different coding site and it is working perfectly. Why?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": " `class Solution {\npublic:\n    int romanToInt(string s) {\n        int summa=0;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='I') summa+=1;\n            else if(s[i]=='V') summa+=5;\n            else if(s[i]=='X') summa+=10;\n            else if(s[i]=='L') summa+=50;\n            else if(s[i]=='C') summa+=100;\n            else if(s[i]=='D') summa+=500;\n            else if(s[i]=='M') summa+=1000;\n        }\n        return summa;\n    }\n};`\nHere is my code.\nAnd it is giving 1994 in the 3rd case on leetcode instead of 2216. But it is working fine on my IDE. Does anyone know where is the error?"
                    },
                    {
                        "username": "jeeteshshaw",
                        "content": "Why the execution time of my code giving different, every time I submit?"
                    }
                ]
            },
            {
                "id": 1718371,
                "content": [
                    {
                        "username": "LotfiLammari",
                        "content": "Wrote my code on VS code and tested with the 3 cases and they worked. Copied the code to leetCode and the outputs were different ..."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/13_roman_to_integer.cpp\\nleave a STAR if you find it HELPFUL"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Hello, i can\\'t convert when the next  value is bigger and i have to decrease. Is there somebady here who could help with this?\\nCoding in JavaScript\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n  let acc = 0;\\n\\nvar romanToInt = function(s) {\\n    acc = 0;\\n    let arrayObj = [\\n        {value: 1, roman: \\'I\\'},\\n        {value: 5, roman: \\'V\\'},\\n        {value: 10, roman: \\'X\\'},\\n        {value: 50, roman: \\'L\\'},\\n        {value: 100, roman: \\'C\\'},\\n        {value: 500, roman: \\'D\\'},\\n        {value: 1000, roman: \\'M\\'},\\n ];\\n    let letra = Array.from(s)\\n    let verification = []\\n    letra.forEach(item =>{\\n        arrayObj.map(({value,roman}) =>{\\n            if(item === roman){\\n                acc += value;\\n                verification.push(value)\\n            }\\n            \\n        })\\n    })\\n    \\n    let tesste = 0\\n  console.log(verification)\\n\\n    return acc\\n};"
                    },
                    {
                        "username": "Adi20sh",
                        "content": " `int romanToInt(char * s){\\nint len = -1;\\nint val = 0;\\n\\nwhile (s[len + 1] != \\'\\\\0\\') len++;\\nwhile(len >= 0)\\n{\\n    switch(s[len])\\n    {\\n        case \\'I\\'    : val += 1; break;\\n        case \\'V\\'    : if(s[len-1] == \\'I\\') { val += 4; len--; break; } else { val += 5; break; }\\n        case \\'X\\'    : if(s[len-1] == \\'I\\') { val += 9; len--; break; } else { val += 10; break; }\\n        case \\'L\\'    : if(s[len-1] == \\'X\\') { val += 40; len--; break; } else { val += 50; break; }\\n        case \\'C\\'    : if(s[len-1] == \\'X\\') { val += 90; len--; break; } else { val += 100; break; }\\n        case \\'D\\'    : if(s[len-1] == \\'C\\') { val += 400; len--; break; } else { val += 500; break; }\\n        case \\'M\\'    : if(s[len-1] == \\'C\\') { val += 900; len--; break; } else { val += 1000; break; }\\n        default     : return -1;\\n    }\\n    len--;\\n}\\nreturn val;\\n}`\\n\\nthis works with other compilers but not in leetcode.\\n\\nIt shows Runtime Error. Any idea why ?"
                    },
                    {
                        "username": "lafllamme",
                        "content": "I wasted so long for debug but my actual issue where that I assigned a wrong value into my start object"
                    },
                    {
                        "username": "sajalkumarr030",
                        "content": "error: use of undeclared identifier \\'Character\\'\\nhow to remove this error\\n"
                    },
                    {
                        "username": "bhawanisingh15101999",
                        "content": "my java 5 ms code very simple"
                    },
                    {
                        "username": "cartercanedy42",
                        "content": "I swear to god this site is going to give me an aneurism, [see picture](https://github.com/carter-canedy/leet/blob/main/image.png)"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Maybe is not type number"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "BEST SOLUTION IN JAVA \\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map= new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result=map.get(s.charAt(s.length()-1));\\n        for(int i=s.length()-2;i>=0;i--)\\n        if(map.get(s.charAt(i))<map.get(s.charAt(i+1)))\\n        {\\n        result-=map.get(s.charAt(i));\\n        }\\n        else\\n        {\\n        result+=map.get(s.charAt(i));\\n        }\\nreturn result;\\n}\\n}"
                    },
                    {
                        "username": "hamdymubarak1980",
                        "content": "I am trying the test cases on my IDE and the program works fine. Here I get this error:\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffcd5e9ad80 overflowed to 0x7ffcd5e9ad7f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    }
                ]
            },
            {
                "id": 1717966,
                "content": [
                    {
                        "username": "LotfiLammari",
                        "content": "Wrote my code on VS code and tested with the 3 cases and they worked. Copied the code to leetCode and the outputs were different ..."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/13_roman_to_integer.cpp\\nleave a STAR if you find it HELPFUL"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Hello, i can\\'t convert when the next  value is bigger and i have to decrease. Is there somebady here who could help with this?\\nCoding in JavaScript\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n  let acc = 0;\\n\\nvar romanToInt = function(s) {\\n    acc = 0;\\n    let arrayObj = [\\n        {value: 1, roman: \\'I\\'},\\n        {value: 5, roman: \\'V\\'},\\n        {value: 10, roman: \\'X\\'},\\n        {value: 50, roman: \\'L\\'},\\n        {value: 100, roman: \\'C\\'},\\n        {value: 500, roman: \\'D\\'},\\n        {value: 1000, roman: \\'M\\'},\\n ];\\n    let letra = Array.from(s)\\n    let verification = []\\n    letra.forEach(item =>{\\n        arrayObj.map(({value,roman}) =>{\\n            if(item === roman){\\n                acc += value;\\n                verification.push(value)\\n            }\\n            \\n        })\\n    })\\n    \\n    let tesste = 0\\n  console.log(verification)\\n\\n    return acc\\n};"
                    },
                    {
                        "username": "Adi20sh",
                        "content": " `int romanToInt(char * s){\\nint len = -1;\\nint val = 0;\\n\\nwhile (s[len + 1] != \\'\\\\0\\') len++;\\nwhile(len >= 0)\\n{\\n    switch(s[len])\\n    {\\n        case \\'I\\'    : val += 1; break;\\n        case \\'V\\'    : if(s[len-1] == \\'I\\') { val += 4; len--; break; } else { val += 5; break; }\\n        case \\'X\\'    : if(s[len-1] == \\'I\\') { val += 9; len--; break; } else { val += 10; break; }\\n        case \\'L\\'    : if(s[len-1] == \\'X\\') { val += 40; len--; break; } else { val += 50; break; }\\n        case \\'C\\'    : if(s[len-1] == \\'X\\') { val += 90; len--; break; } else { val += 100; break; }\\n        case \\'D\\'    : if(s[len-1] == \\'C\\') { val += 400; len--; break; } else { val += 500; break; }\\n        case \\'M\\'    : if(s[len-1] == \\'C\\') { val += 900; len--; break; } else { val += 1000; break; }\\n        default     : return -1;\\n    }\\n    len--;\\n}\\nreturn val;\\n}`\\n\\nthis works with other compilers but not in leetcode.\\n\\nIt shows Runtime Error. Any idea why ?"
                    },
                    {
                        "username": "lafllamme",
                        "content": "I wasted so long for debug but my actual issue where that I assigned a wrong value into my start object"
                    },
                    {
                        "username": "sajalkumarr030",
                        "content": "error: use of undeclared identifier \\'Character\\'\\nhow to remove this error\\n"
                    },
                    {
                        "username": "bhawanisingh15101999",
                        "content": "my java 5 ms code very simple"
                    },
                    {
                        "username": "cartercanedy42",
                        "content": "I swear to god this site is going to give me an aneurism, [see picture](https://github.com/carter-canedy/leet/blob/main/image.png)"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Maybe is not type number"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "BEST SOLUTION IN JAVA \\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map= new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result=map.get(s.charAt(s.length()-1));\\n        for(int i=s.length()-2;i>=0;i--)\\n        if(map.get(s.charAt(i))<map.get(s.charAt(i+1)))\\n        {\\n        result-=map.get(s.charAt(i));\\n        }\\n        else\\n        {\\n        result+=map.get(s.charAt(i));\\n        }\\nreturn result;\\n}\\n}"
                    },
                    {
                        "username": "hamdymubarak1980",
                        "content": "I am trying the test cases on my IDE and the program works fine. Here I get this error:\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffcd5e9ad80 overflowed to 0x7ffcd5e9ad7f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    }
                ]
            },
            {
                "id": 1717646,
                "content": [
                    {
                        "username": "LotfiLammari",
                        "content": "Wrote my code on VS code and tested with the 3 cases and they worked. Copied the code to leetCode and the outputs were different ..."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/13_roman_to_integer.cpp\\nleave a STAR if you find it HELPFUL"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Hello, i can\\'t convert when the next  value is bigger and i have to decrease. Is there somebady here who could help with this?\\nCoding in JavaScript\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n  let acc = 0;\\n\\nvar romanToInt = function(s) {\\n    acc = 0;\\n    let arrayObj = [\\n        {value: 1, roman: \\'I\\'},\\n        {value: 5, roman: \\'V\\'},\\n        {value: 10, roman: \\'X\\'},\\n        {value: 50, roman: \\'L\\'},\\n        {value: 100, roman: \\'C\\'},\\n        {value: 500, roman: \\'D\\'},\\n        {value: 1000, roman: \\'M\\'},\\n ];\\n    let letra = Array.from(s)\\n    let verification = []\\n    letra.forEach(item =>{\\n        arrayObj.map(({value,roman}) =>{\\n            if(item === roman){\\n                acc += value;\\n                verification.push(value)\\n            }\\n            \\n        })\\n    })\\n    \\n    let tesste = 0\\n  console.log(verification)\\n\\n    return acc\\n};"
                    },
                    {
                        "username": "Adi20sh",
                        "content": " `int romanToInt(char * s){\\nint len = -1;\\nint val = 0;\\n\\nwhile (s[len + 1] != \\'\\\\0\\') len++;\\nwhile(len >= 0)\\n{\\n    switch(s[len])\\n    {\\n        case \\'I\\'    : val += 1; break;\\n        case \\'V\\'    : if(s[len-1] == \\'I\\') { val += 4; len--; break; } else { val += 5; break; }\\n        case \\'X\\'    : if(s[len-1] == \\'I\\') { val += 9; len--; break; } else { val += 10; break; }\\n        case \\'L\\'    : if(s[len-1] == \\'X\\') { val += 40; len--; break; } else { val += 50; break; }\\n        case \\'C\\'    : if(s[len-1] == \\'X\\') { val += 90; len--; break; } else { val += 100; break; }\\n        case \\'D\\'    : if(s[len-1] == \\'C\\') { val += 400; len--; break; } else { val += 500; break; }\\n        case \\'M\\'    : if(s[len-1] == \\'C\\') { val += 900; len--; break; } else { val += 1000; break; }\\n        default     : return -1;\\n    }\\n    len--;\\n}\\nreturn val;\\n}`\\n\\nthis works with other compilers but not in leetcode.\\n\\nIt shows Runtime Error. Any idea why ?"
                    },
                    {
                        "username": "lafllamme",
                        "content": "I wasted so long for debug but my actual issue where that I assigned a wrong value into my start object"
                    },
                    {
                        "username": "sajalkumarr030",
                        "content": "error: use of undeclared identifier \\'Character\\'\\nhow to remove this error\\n"
                    },
                    {
                        "username": "bhawanisingh15101999",
                        "content": "my java 5 ms code very simple"
                    },
                    {
                        "username": "cartercanedy42",
                        "content": "I swear to god this site is going to give me an aneurism, [see picture](https://github.com/carter-canedy/leet/blob/main/image.png)"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Maybe is not type number"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "BEST SOLUTION IN JAVA \\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map= new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result=map.get(s.charAt(s.length()-1));\\n        for(int i=s.length()-2;i>=0;i--)\\n        if(map.get(s.charAt(i))<map.get(s.charAt(i+1)))\\n        {\\n        result-=map.get(s.charAt(i));\\n        }\\n        else\\n        {\\n        result+=map.get(s.charAt(i));\\n        }\\nreturn result;\\n}\\n}"
                    },
                    {
                        "username": "hamdymubarak1980",
                        "content": "I am trying the test cases on my IDE and the program works fine. Here I get this error:\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffcd5e9ad80 overflowed to 0x7ffcd5e9ad7f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    }
                ]
            },
            {
                "id": 1717483,
                "content": [
                    {
                        "username": "LotfiLammari",
                        "content": "Wrote my code on VS code and tested with the 3 cases and they worked. Copied the code to leetCode and the outputs were different ..."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/13_roman_to_integer.cpp\\nleave a STAR if you find it HELPFUL"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Hello, i can\\'t convert when the next  value is bigger and i have to decrease. Is there somebady here who could help with this?\\nCoding in JavaScript\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n  let acc = 0;\\n\\nvar romanToInt = function(s) {\\n    acc = 0;\\n    let arrayObj = [\\n        {value: 1, roman: \\'I\\'},\\n        {value: 5, roman: \\'V\\'},\\n        {value: 10, roman: \\'X\\'},\\n        {value: 50, roman: \\'L\\'},\\n        {value: 100, roman: \\'C\\'},\\n        {value: 500, roman: \\'D\\'},\\n        {value: 1000, roman: \\'M\\'},\\n ];\\n    let letra = Array.from(s)\\n    let verification = []\\n    letra.forEach(item =>{\\n        arrayObj.map(({value,roman}) =>{\\n            if(item === roman){\\n                acc += value;\\n                verification.push(value)\\n            }\\n            \\n        })\\n    })\\n    \\n    let tesste = 0\\n  console.log(verification)\\n\\n    return acc\\n};"
                    },
                    {
                        "username": "Adi20sh",
                        "content": " `int romanToInt(char * s){\\nint len = -1;\\nint val = 0;\\n\\nwhile (s[len + 1] != \\'\\\\0\\') len++;\\nwhile(len >= 0)\\n{\\n    switch(s[len])\\n    {\\n        case \\'I\\'    : val += 1; break;\\n        case \\'V\\'    : if(s[len-1] == \\'I\\') { val += 4; len--; break; } else { val += 5; break; }\\n        case \\'X\\'    : if(s[len-1] == \\'I\\') { val += 9; len--; break; } else { val += 10; break; }\\n        case \\'L\\'    : if(s[len-1] == \\'X\\') { val += 40; len--; break; } else { val += 50; break; }\\n        case \\'C\\'    : if(s[len-1] == \\'X\\') { val += 90; len--; break; } else { val += 100; break; }\\n        case \\'D\\'    : if(s[len-1] == \\'C\\') { val += 400; len--; break; } else { val += 500; break; }\\n        case \\'M\\'    : if(s[len-1] == \\'C\\') { val += 900; len--; break; } else { val += 1000; break; }\\n        default     : return -1;\\n    }\\n    len--;\\n}\\nreturn val;\\n}`\\n\\nthis works with other compilers but not in leetcode.\\n\\nIt shows Runtime Error. Any idea why ?"
                    },
                    {
                        "username": "lafllamme",
                        "content": "I wasted so long for debug but my actual issue where that I assigned a wrong value into my start object"
                    },
                    {
                        "username": "sajalkumarr030",
                        "content": "error: use of undeclared identifier \\'Character\\'\\nhow to remove this error\\n"
                    },
                    {
                        "username": "bhawanisingh15101999",
                        "content": "my java 5 ms code very simple"
                    },
                    {
                        "username": "cartercanedy42",
                        "content": "I swear to god this site is going to give me an aneurism, [see picture](https://github.com/carter-canedy/leet/blob/main/image.png)"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Maybe is not type number"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "BEST SOLUTION IN JAVA \\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map= new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result=map.get(s.charAt(s.length()-1));\\n        for(int i=s.length()-2;i>=0;i--)\\n        if(map.get(s.charAt(i))<map.get(s.charAt(i+1)))\\n        {\\n        result-=map.get(s.charAt(i));\\n        }\\n        else\\n        {\\n        result+=map.get(s.charAt(i));\\n        }\\nreturn result;\\n}\\n}"
                    },
                    {
                        "username": "hamdymubarak1980",
                        "content": "I am trying the test cases on my IDE and the program works fine. Here I get this error:\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffcd5e9ad80 overflowed to 0x7ffcd5e9ad7f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    }
                ]
            },
            {
                "id": 1717470,
                "content": [
                    {
                        "username": "LotfiLammari",
                        "content": "Wrote my code on VS code and tested with the 3 cases and they worked. Copied the code to leetCode and the outputs were different ..."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/13_roman_to_integer.cpp\\nleave a STAR if you find it HELPFUL"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Hello, i can\\'t convert when the next  value is bigger and i have to decrease. Is there somebady here who could help with this?\\nCoding in JavaScript\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n  let acc = 0;\\n\\nvar romanToInt = function(s) {\\n    acc = 0;\\n    let arrayObj = [\\n        {value: 1, roman: \\'I\\'},\\n        {value: 5, roman: \\'V\\'},\\n        {value: 10, roman: \\'X\\'},\\n        {value: 50, roman: \\'L\\'},\\n        {value: 100, roman: \\'C\\'},\\n        {value: 500, roman: \\'D\\'},\\n        {value: 1000, roman: \\'M\\'},\\n ];\\n    let letra = Array.from(s)\\n    let verification = []\\n    letra.forEach(item =>{\\n        arrayObj.map(({value,roman}) =>{\\n            if(item === roman){\\n                acc += value;\\n                verification.push(value)\\n            }\\n            \\n        })\\n    })\\n    \\n    let tesste = 0\\n  console.log(verification)\\n\\n    return acc\\n};"
                    },
                    {
                        "username": "Adi20sh",
                        "content": " `int romanToInt(char * s){\\nint len = -1;\\nint val = 0;\\n\\nwhile (s[len + 1] != \\'\\\\0\\') len++;\\nwhile(len >= 0)\\n{\\n    switch(s[len])\\n    {\\n        case \\'I\\'    : val += 1; break;\\n        case \\'V\\'    : if(s[len-1] == \\'I\\') { val += 4; len--; break; } else { val += 5; break; }\\n        case \\'X\\'    : if(s[len-1] == \\'I\\') { val += 9; len--; break; } else { val += 10; break; }\\n        case \\'L\\'    : if(s[len-1] == \\'X\\') { val += 40; len--; break; } else { val += 50; break; }\\n        case \\'C\\'    : if(s[len-1] == \\'X\\') { val += 90; len--; break; } else { val += 100; break; }\\n        case \\'D\\'    : if(s[len-1] == \\'C\\') { val += 400; len--; break; } else { val += 500; break; }\\n        case \\'M\\'    : if(s[len-1] == \\'C\\') { val += 900; len--; break; } else { val += 1000; break; }\\n        default     : return -1;\\n    }\\n    len--;\\n}\\nreturn val;\\n}`\\n\\nthis works with other compilers but not in leetcode.\\n\\nIt shows Runtime Error. Any idea why ?"
                    },
                    {
                        "username": "lafllamme",
                        "content": "I wasted so long for debug but my actual issue where that I assigned a wrong value into my start object"
                    },
                    {
                        "username": "sajalkumarr030",
                        "content": "error: use of undeclared identifier \\'Character\\'\\nhow to remove this error\\n"
                    },
                    {
                        "username": "bhawanisingh15101999",
                        "content": "my java 5 ms code very simple"
                    },
                    {
                        "username": "cartercanedy42",
                        "content": "I swear to god this site is going to give me an aneurism, [see picture](https://github.com/carter-canedy/leet/blob/main/image.png)"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Maybe is not type number"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "BEST SOLUTION IN JAVA \\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map= new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result=map.get(s.charAt(s.length()-1));\\n        for(int i=s.length()-2;i>=0;i--)\\n        if(map.get(s.charAt(i))<map.get(s.charAt(i+1)))\\n        {\\n        result-=map.get(s.charAt(i));\\n        }\\n        else\\n        {\\n        result+=map.get(s.charAt(i));\\n        }\\nreturn result;\\n}\\n}"
                    },
                    {
                        "username": "hamdymubarak1980",
                        "content": "I am trying the test cases on my IDE and the program works fine. Here I get this error:\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffcd5e9ad80 overflowed to 0x7ffcd5e9ad7f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    }
                ]
            },
            {
                "id": 1717396,
                "content": [
                    {
                        "username": "LotfiLammari",
                        "content": "Wrote my code on VS code and tested with the 3 cases and they worked. Copied the code to leetCode and the outputs were different ..."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/13_roman_to_integer.cpp\\nleave a STAR if you find it HELPFUL"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Hello, i can\\'t convert when the next  value is bigger and i have to decrease. Is there somebady here who could help with this?\\nCoding in JavaScript\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n  let acc = 0;\\n\\nvar romanToInt = function(s) {\\n    acc = 0;\\n    let arrayObj = [\\n        {value: 1, roman: \\'I\\'},\\n        {value: 5, roman: \\'V\\'},\\n        {value: 10, roman: \\'X\\'},\\n        {value: 50, roman: \\'L\\'},\\n        {value: 100, roman: \\'C\\'},\\n        {value: 500, roman: \\'D\\'},\\n        {value: 1000, roman: \\'M\\'},\\n ];\\n    let letra = Array.from(s)\\n    let verification = []\\n    letra.forEach(item =>{\\n        arrayObj.map(({value,roman}) =>{\\n            if(item === roman){\\n                acc += value;\\n                verification.push(value)\\n            }\\n            \\n        })\\n    })\\n    \\n    let tesste = 0\\n  console.log(verification)\\n\\n    return acc\\n};"
                    },
                    {
                        "username": "Adi20sh",
                        "content": " `int romanToInt(char * s){\\nint len = -1;\\nint val = 0;\\n\\nwhile (s[len + 1] != \\'\\\\0\\') len++;\\nwhile(len >= 0)\\n{\\n    switch(s[len])\\n    {\\n        case \\'I\\'    : val += 1; break;\\n        case \\'V\\'    : if(s[len-1] == \\'I\\') { val += 4; len--; break; } else { val += 5; break; }\\n        case \\'X\\'    : if(s[len-1] == \\'I\\') { val += 9; len--; break; } else { val += 10; break; }\\n        case \\'L\\'    : if(s[len-1] == \\'X\\') { val += 40; len--; break; } else { val += 50; break; }\\n        case \\'C\\'    : if(s[len-1] == \\'X\\') { val += 90; len--; break; } else { val += 100; break; }\\n        case \\'D\\'    : if(s[len-1] == \\'C\\') { val += 400; len--; break; } else { val += 500; break; }\\n        case \\'M\\'    : if(s[len-1] == \\'C\\') { val += 900; len--; break; } else { val += 1000; break; }\\n        default     : return -1;\\n    }\\n    len--;\\n}\\nreturn val;\\n}`\\n\\nthis works with other compilers but not in leetcode.\\n\\nIt shows Runtime Error. Any idea why ?"
                    },
                    {
                        "username": "lafllamme",
                        "content": "I wasted so long for debug but my actual issue where that I assigned a wrong value into my start object"
                    },
                    {
                        "username": "sajalkumarr030",
                        "content": "error: use of undeclared identifier \\'Character\\'\\nhow to remove this error\\n"
                    },
                    {
                        "username": "bhawanisingh15101999",
                        "content": "my java 5 ms code very simple"
                    },
                    {
                        "username": "cartercanedy42",
                        "content": "I swear to god this site is going to give me an aneurism, [see picture](https://github.com/carter-canedy/leet/blob/main/image.png)"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Maybe is not type number"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "BEST SOLUTION IN JAVA \\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map= new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result=map.get(s.charAt(s.length()-1));\\n        for(int i=s.length()-2;i>=0;i--)\\n        if(map.get(s.charAt(i))<map.get(s.charAt(i+1)))\\n        {\\n        result-=map.get(s.charAt(i));\\n        }\\n        else\\n        {\\n        result+=map.get(s.charAt(i));\\n        }\\nreturn result;\\n}\\n}"
                    },
                    {
                        "username": "hamdymubarak1980",
                        "content": "I am trying the test cases on my IDE and the program works fine. Here I get this error:\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffcd5e9ad80 overflowed to 0x7ffcd5e9ad7f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    }
                ]
            },
            {
                "id": 1717239,
                "content": [
                    {
                        "username": "LotfiLammari",
                        "content": "Wrote my code on VS code and tested with the 3 cases and they worked. Copied the code to leetCode and the outputs were different ..."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/13_roman_to_integer.cpp\\nleave a STAR if you find it HELPFUL"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Hello, i can\\'t convert when the next  value is bigger and i have to decrease. Is there somebady here who could help with this?\\nCoding in JavaScript\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n  let acc = 0;\\n\\nvar romanToInt = function(s) {\\n    acc = 0;\\n    let arrayObj = [\\n        {value: 1, roman: \\'I\\'},\\n        {value: 5, roman: \\'V\\'},\\n        {value: 10, roman: \\'X\\'},\\n        {value: 50, roman: \\'L\\'},\\n        {value: 100, roman: \\'C\\'},\\n        {value: 500, roman: \\'D\\'},\\n        {value: 1000, roman: \\'M\\'},\\n ];\\n    let letra = Array.from(s)\\n    let verification = []\\n    letra.forEach(item =>{\\n        arrayObj.map(({value,roman}) =>{\\n            if(item === roman){\\n                acc += value;\\n                verification.push(value)\\n            }\\n            \\n        })\\n    })\\n    \\n    let tesste = 0\\n  console.log(verification)\\n\\n    return acc\\n};"
                    },
                    {
                        "username": "Adi20sh",
                        "content": " `int romanToInt(char * s){\\nint len = -1;\\nint val = 0;\\n\\nwhile (s[len + 1] != \\'\\\\0\\') len++;\\nwhile(len >= 0)\\n{\\n    switch(s[len])\\n    {\\n        case \\'I\\'    : val += 1; break;\\n        case \\'V\\'    : if(s[len-1] == \\'I\\') { val += 4; len--; break; } else { val += 5; break; }\\n        case \\'X\\'    : if(s[len-1] == \\'I\\') { val += 9; len--; break; } else { val += 10; break; }\\n        case \\'L\\'    : if(s[len-1] == \\'X\\') { val += 40; len--; break; } else { val += 50; break; }\\n        case \\'C\\'    : if(s[len-1] == \\'X\\') { val += 90; len--; break; } else { val += 100; break; }\\n        case \\'D\\'    : if(s[len-1] == \\'C\\') { val += 400; len--; break; } else { val += 500; break; }\\n        case \\'M\\'    : if(s[len-1] == \\'C\\') { val += 900; len--; break; } else { val += 1000; break; }\\n        default     : return -1;\\n    }\\n    len--;\\n}\\nreturn val;\\n}`\\n\\nthis works with other compilers but not in leetcode.\\n\\nIt shows Runtime Error. Any idea why ?"
                    },
                    {
                        "username": "lafllamme",
                        "content": "I wasted so long for debug but my actual issue where that I assigned a wrong value into my start object"
                    },
                    {
                        "username": "sajalkumarr030",
                        "content": "error: use of undeclared identifier \\'Character\\'\\nhow to remove this error\\n"
                    },
                    {
                        "username": "bhawanisingh15101999",
                        "content": "my java 5 ms code very simple"
                    },
                    {
                        "username": "cartercanedy42",
                        "content": "I swear to god this site is going to give me an aneurism, [see picture](https://github.com/carter-canedy/leet/blob/main/image.png)"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Maybe is not type number"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "BEST SOLUTION IN JAVA \\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map= new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result=map.get(s.charAt(s.length()-1));\\n        for(int i=s.length()-2;i>=0;i--)\\n        if(map.get(s.charAt(i))<map.get(s.charAt(i+1)))\\n        {\\n        result-=map.get(s.charAt(i));\\n        }\\n        else\\n        {\\n        result+=map.get(s.charAt(i));\\n        }\\nreturn result;\\n}\\n}"
                    },
                    {
                        "username": "hamdymubarak1980",
                        "content": "I am trying the test cases on my IDE and the program works fine. Here I get this error:\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffcd5e9ad80 overflowed to 0x7ffcd5e9ad7f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    }
                ]
            },
            {
                "id": 1716508,
                "content": [
                    {
                        "username": "LotfiLammari",
                        "content": "Wrote my code on VS code and tested with the 3 cases and they worked. Copied the code to leetCode and the outputs were different ..."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/13_roman_to_integer.cpp\\nleave a STAR if you find it HELPFUL"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Hello, i can\\'t convert when the next  value is bigger and i have to decrease. Is there somebady here who could help with this?\\nCoding in JavaScript\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n  let acc = 0;\\n\\nvar romanToInt = function(s) {\\n    acc = 0;\\n    let arrayObj = [\\n        {value: 1, roman: \\'I\\'},\\n        {value: 5, roman: \\'V\\'},\\n        {value: 10, roman: \\'X\\'},\\n        {value: 50, roman: \\'L\\'},\\n        {value: 100, roman: \\'C\\'},\\n        {value: 500, roman: \\'D\\'},\\n        {value: 1000, roman: \\'M\\'},\\n ];\\n    let letra = Array.from(s)\\n    let verification = []\\n    letra.forEach(item =>{\\n        arrayObj.map(({value,roman}) =>{\\n            if(item === roman){\\n                acc += value;\\n                verification.push(value)\\n            }\\n            \\n        })\\n    })\\n    \\n    let tesste = 0\\n  console.log(verification)\\n\\n    return acc\\n};"
                    },
                    {
                        "username": "Adi20sh",
                        "content": " `int romanToInt(char * s){\\nint len = -1;\\nint val = 0;\\n\\nwhile (s[len + 1] != \\'\\\\0\\') len++;\\nwhile(len >= 0)\\n{\\n    switch(s[len])\\n    {\\n        case \\'I\\'    : val += 1; break;\\n        case \\'V\\'    : if(s[len-1] == \\'I\\') { val += 4; len--; break; } else { val += 5; break; }\\n        case \\'X\\'    : if(s[len-1] == \\'I\\') { val += 9; len--; break; } else { val += 10; break; }\\n        case \\'L\\'    : if(s[len-1] == \\'X\\') { val += 40; len--; break; } else { val += 50; break; }\\n        case \\'C\\'    : if(s[len-1] == \\'X\\') { val += 90; len--; break; } else { val += 100; break; }\\n        case \\'D\\'    : if(s[len-1] == \\'C\\') { val += 400; len--; break; } else { val += 500; break; }\\n        case \\'M\\'    : if(s[len-1] == \\'C\\') { val += 900; len--; break; } else { val += 1000; break; }\\n        default     : return -1;\\n    }\\n    len--;\\n}\\nreturn val;\\n}`\\n\\nthis works with other compilers but not in leetcode.\\n\\nIt shows Runtime Error. Any idea why ?"
                    },
                    {
                        "username": "lafllamme",
                        "content": "I wasted so long for debug but my actual issue where that I assigned a wrong value into my start object"
                    },
                    {
                        "username": "sajalkumarr030",
                        "content": "error: use of undeclared identifier \\'Character\\'\\nhow to remove this error\\n"
                    },
                    {
                        "username": "bhawanisingh15101999",
                        "content": "my java 5 ms code very simple"
                    },
                    {
                        "username": "cartercanedy42",
                        "content": "I swear to god this site is going to give me an aneurism, [see picture](https://github.com/carter-canedy/leet/blob/main/image.png)"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Maybe is not type number"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "BEST SOLUTION IN JAVA \\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map= new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result=map.get(s.charAt(s.length()-1));\\n        for(int i=s.length()-2;i>=0;i--)\\n        if(map.get(s.charAt(i))<map.get(s.charAt(i+1)))\\n        {\\n        result-=map.get(s.charAt(i));\\n        }\\n        else\\n        {\\n        result+=map.get(s.charAt(i));\\n        }\\nreturn result;\\n}\\n}"
                    },
                    {
                        "username": "hamdymubarak1980",
                        "content": "I am trying the test cases on my IDE and the program works fine. Here I get this error:\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffcd5e9ad80 overflowed to 0x7ffcd5e9ad7f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    }
                ]
            },
            {
                "id": 1716305,
                "content": [
                    {
                        "username": "LotfiLammari",
                        "content": "Wrote my code on VS code and tested with the 3 cases and they worked. Copied the code to leetCode and the outputs were different ..."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/13_roman_to_integer.cpp\\nleave a STAR if you find it HELPFUL"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Hello, i can\\'t convert when the next  value is bigger and i have to decrease. Is there somebady here who could help with this?\\nCoding in JavaScript\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n  let acc = 0;\\n\\nvar romanToInt = function(s) {\\n    acc = 0;\\n    let arrayObj = [\\n        {value: 1, roman: \\'I\\'},\\n        {value: 5, roman: \\'V\\'},\\n        {value: 10, roman: \\'X\\'},\\n        {value: 50, roman: \\'L\\'},\\n        {value: 100, roman: \\'C\\'},\\n        {value: 500, roman: \\'D\\'},\\n        {value: 1000, roman: \\'M\\'},\\n ];\\n    let letra = Array.from(s)\\n    let verification = []\\n    letra.forEach(item =>{\\n        arrayObj.map(({value,roman}) =>{\\n            if(item === roman){\\n                acc += value;\\n                verification.push(value)\\n            }\\n            \\n        })\\n    })\\n    \\n    let tesste = 0\\n  console.log(verification)\\n\\n    return acc\\n};"
                    },
                    {
                        "username": "Adi20sh",
                        "content": " `int romanToInt(char * s){\\nint len = -1;\\nint val = 0;\\n\\nwhile (s[len + 1] != \\'\\\\0\\') len++;\\nwhile(len >= 0)\\n{\\n    switch(s[len])\\n    {\\n        case \\'I\\'    : val += 1; break;\\n        case \\'V\\'    : if(s[len-1] == \\'I\\') { val += 4; len--; break; } else { val += 5; break; }\\n        case \\'X\\'    : if(s[len-1] == \\'I\\') { val += 9; len--; break; } else { val += 10; break; }\\n        case \\'L\\'    : if(s[len-1] == \\'X\\') { val += 40; len--; break; } else { val += 50; break; }\\n        case \\'C\\'    : if(s[len-1] == \\'X\\') { val += 90; len--; break; } else { val += 100; break; }\\n        case \\'D\\'    : if(s[len-1] == \\'C\\') { val += 400; len--; break; } else { val += 500; break; }\\n        case \\'M\\'    : if(s[len-1] == \\'C\\') { val += 900; len--; break; } else { val += 1000; break; }\\n        default     : return -1;\\n    }\\n    len--;\\n}\\nreturn val;\\n}`\\n\\nthis works with other compilers but not in leetcode.\\n\\nIt shows Runtime Error. Any idea why ?"
                    },
                    {
                        "username": "lafllamme",
                        "content": "I wasted so long for debug but my actual issue where that I assigned a wrong value into my start object"
                    },
                    {
                        "username": "sajalkumarr030",
                        "content": "error: use of undeclared identifier \\'Character\\'\\nhow to remove this error\\n"
                    },
                    {
                        "username": "bhawanisingh15101999",
                        "content": "my java 5 ms code very simple"
                    },
                    {
                        "username": "cartercanedy42",
                        "content": "I swear to god this site is going to give me an aneurism, [see picture](https://github.com/carter-canedy/leet/blob/main/image.png)"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Maybe is not type number"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "BEST SOLUTION IN JAVA \\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map= new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result=map.get(s.charAt(s.length()-1));\\n        for(int i=s.length()-2;i>=0;i--)\\n        if(map.get(s.charAt(i))<map.get(s.charAt(i+1)))\\n        {\\n        result-=map.get(s.charAt(i));\\n        }\\n        else\\n        {\\n        result+=map.get(s.charAt(i));\\n        }\\nreturn result;\\n}\\n}"
                    },
                    {
                        "username": "hamdymubarak1980",
                        "content": "I am trying the test cases on my IDE and the program works fine. Here I get this error:\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffcd5e9ad80 overflowed to 0x7ffcd5e9ad7f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    }
                ]
            },
            {
                "id": 1715710,
                "content": [
                    {
                        "username": "LotfiLammari",
                        "content": "Wrote my code on VS code and tested with the 3 cases and they worked. Copied the code to leetCode and the outputs were different ..."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/13_roman_to_integer.cpp\\nleave a STAR if you find it HELPFUL"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Hello, i can\\'t convert when the next  value is bigger and i have to decrease. Is there somebady here who could help with this?\\nCoding in JavaScript\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n  let acc = 0;\\n\\nvar romanToInt = function(s) {\\n    acc = 0;\\n    let arrayObj = [\\n        {value: 1, roman: \\'I\\'},\\n        {value: 5, roman: \\'V\\'},\\n        {value: 10, roman: \\'X\\'},\\n        {value: 50, roman: \\'L\\'},\\n        {value: 100, roman: \\'C\\'},\\n        {value: 500, roman: \\'D\\'},\\n        {value: 1000, roman: \\'M\\'},\\n ];\\n    let letra = Array.from(s)\\n    let verification = []\\n    letra.forEach(item =>{\\n        arrayObj.map(({value,roman}) =>{\\n            if(item === roman){\\n                acc += value;\\n                verification.push(value)\\n            }\\n            \\n        })\\n    })\\n    \\n    let tesste = 0\\n  console.log(verification)\\n\\n    return acc\\n};"
                    },
                    {
                        "username": "Adi20sh",
                        "content": " `int romanToInt(char * s){\\nint len = -1;\\nint val = 0;\\n\\nwhile (s[len + 1] != \\'\\\\0\\') len++;\\nwhile(len >= 0)\\n{\\n    switch(s[len])\\n    {\\n        case \\'I\\'    : val += 1; break;\\n        case \\'V\\'    : if(s[len-1] == \\'I\\') { val += 4; len--; break; } else { val += 5; break; }\\n        case \\'X\\'    : if(s[len-1] == \\'I\\') { val += 9; len--; break; } else { val += 10; break; }\\n        case \\'L\\'    : if(s[len-1] == \\'X\\') { val += 40; len--; break; } else { val += 50; break; }\\n        case \\'C\\'    : if(s[len-1] == \\'X\\') { val += 90; len--; break; } else { val += 100; break; }\\n        case \\'D\\'    : if(s[len-1] == \\'C\\') { val += 400; len--; break; } else { val += 500; break; }\\n        case \\'M\\'    : if(s[len-1] == \\'C\\') { val += 900; len--; break; } else { val += 1000; break; }\\n        default     : return -1;\\n    }\\n    len--;\\n}\\nreturn val;\\n}`\\n\\nthis works with other compilers but not in leetcode.\\n\\nIt shows Runtime Error. Any idea why ?"
                    },
                    {
                        "username": "lafllamme",
                        "content": "I wasted so long for debug but my actual issue where that I assigned a wrong value into my start object"
                    },
                    {
                        "username": "sajalkumarr030",
                        "content": "error: use of undeclared identifier \\'Character\\'\\nhow to remove this error\\n"
                    },
                    {
                        "username": "bhawanisingh15101999",
                        "content": "my java 5 ms code very simple"
                    },
                    {
                        "username": "cartercanedy42",
                        "content": "I swear to god this site is going to give me an aneurism, [see picture](https://github.com/carter-canedy/leet/blob/main/image.png)"
                    },
                    {
                        "username": "andrewborgescampos",
                        "content": "Maybe is not type number"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "BEST SOLUTION IN JAVA \\nclass Solution {\\n    public int romanToInt(String s) {\\n        Map<Character, Integer> map= new HashMap<>();\\n        map.put(\\'I\\',1);\\n        map.put(\\'V\\',5);\\n        map.put(\\'X\\',10);\\n        map.put(\\'L\\',50);\\n        map.put(\\'C\\',100);\\n        map.put(\\'D\\',500);\\n        map.put(\\'M\\',1000);\\n        int result=map.get(s.charAt(s.length()-1));\\n        for(int i=s.length()-2;i>=0;i--)\\n        if(map.get(s.charAt(i))<map.get(s.charAt(i+1)))\\n        {\\n        result-=map.get(s.charAt(i));\\n        }\\n        else\\n        {\\n        result+=map.get(s.charAt(i));\\n        }\\nreturn result;\\n}\\n}"
                    },
                    {
                        "username": "hamdymubarak1980",
                        "content": "I am trying the test cases on my IDE and the program works fine. Here I get this error:\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7ffcd5e9ad80 overflowed to 0x7ffcd5e9ad7f (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    }
                ]
            },
            {
                "id": 1715356,
                "content": [
                    {
                        "username": "Sooraj1710",
                        "content": "hello guys, im new here, and i dont know how to use leetcode.\\njust if someone can tell me what to do with the roman int question"
                    },
                    {
                        "username": "quosuka",
                        "content": "what im missing? \\n/**\\n* @param {string} s\\n* @return {number}\\n*/\\nvar romanToInt = function (s) { \\nvar dict = {\\n\\'I\\':1,\\n\\'V\\':5,\\n\\'X\\':10, \\n\\'L\\':50,\\n\\'C\\':100,\\n\\'D\\':500,\\n\\'M\\':1000\\n};\\n\\nvar result = 0;\\nvar intVal = 0; \\nvar nextIntVal = 0;\\nfor (var I = 0; I < s.length; I++) {\\nintVal = dict [s[I]];\\n\\nif(I!=s.length-1)\\n{\\nnextIntVal = dict[s[I+1]];\\nif(nextIntVal>intVal){\\n    intVal = nextIntVal-intVal;\\n I+I+1;\\n}\\n}\\nresult = result + intVal;\\n}\\nreturn result;\\n};"
                    },
                    {
                        "username": "okdssdf",
                        "content": "i need to help:\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n"
                    },
                    {
                        "username": "mathavaroopan",
                        "content": "Java - Beats 95%\\n\\nCode:\\n\\nclass Solution {\\n    public int romanToInt(String s) {\\n        char[] ch = s.toCharArray();\\n        int result = 0;\\n        int i = 0;\\n        while(i<ch.length){\\n                if(ch[i]==\\'I\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'V\\'){\\n                            result = result + 4;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'X\\'){\\n                            result+=9;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n                    result+=1;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'X\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'L\\' && i<ch.length-1){\\n                            result+=40;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'C\\' && i<ch.length-1){\\n                            result+=90;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=10;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'C\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'M\\'){\\n                            result+=900;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'D\\'){\\n                            result+=400;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=100;\\n                    i+=1;\\n                    continue;\\n                }\\n            switch (ch[i]){\\n                case \\'V\\':\\n                    result+=5;\\n                    i+=1;\\n                    continue;\\n                case \\'L\\':\\n                    result+=50;\\n                    i+=1;\\n                    continue;\\n                case \\'D\\':\\n                    result+=500;\\n                    i+=1;\\n                    continue;\\n                case \\'M\\':\\n                    result+=1000;\\n                    i+=1;\\n                    continue;\\n\\n            }\\n            i+=1;\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "shubhamdesoria",
                        "content": "My code runs great on the js online compiler but suprisingly it\\'s not working on leet code\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "MHZ48",
                        "content": "omk 87be"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "#include<bits/stdc++.h>\\nclass Solution{\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char,int> uMap ={{\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},\\n        {\\'M\\',1000}};\\n        int num =0;\\n        int pValue= 1000;\\n        for(int i =0;i<s.length();i++){\\n            int value = uMap[s[i]];\\n            if(value>pValue){\\n                num-= 2*pValue;                \\n            }\\n            num+=value;\\n            pValue= value;\\n        }\\n        return num;   \\n    }\\n};"
                    },
                    {
                        "username": "James5779",
                        "content": "This is not clear, what is the actual question they are asking? Write a program that dose what? "
                    },
                    {
                        "username": "marsinearth",
                        "content": "I think there are mere subtraction of lesser values compare to greater values are all accepted here, which it should not!\\nfor example, 999 for roman number should be CMXCIX, not IM but many answers are accepting those IM cases....\\n\\nThis is WRONG\\n\\n"
                    }
                ]
            },
            {
                "id": 1715263,
                "content": [
                    {
                        "username": "Sooraj1710",
                        "content": "hello guys, im new here, and i dont know how to use leetcode.\\njust if someone can tell me what to do with the roman int question"
                    },
                    {
                        "username": "quosuka",
                        "content": "what im missing? \\n/**\\n* @param {string} s\\n* @return {number}\\n*/\\nvar romanToInt = function (s) { \\nvar dict = {\\n\\'I\\':1,\\n\\'V\\':5,\\n\\'X\\':10, \\n\\'L\\':50,\\n\\'C\\':100,\\n\\'D\\':500,\\n\\'M\\':1000\\n};\\n\\nvar result = 0;\\nvar intVal = 0; \\nvar nextIntVal = 0;\\nfor (var I = 0; I < s.length; I++) {\\nintVal = dict [s[I]];\\n\\nif(I!=s.length-1)\\n{\\nnextIntVal = dict[s[I+1]];\\nif(nextIntVal>intVal){\\n    intVal = nextIntVal-intVal;\\n I+I+1;\\n}\\n}\\nresult = result + intVal;\\n}\\nreturn result;\\n};"
                    },
                    {
                        "username": "okdssdf",
                        "content": "i need to help:\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n"
                    },
                    {
                        "username": "mathavaroopan",
                        "content": "Java - Beats 95%\\n\\nCode:\\n\\nclass Solution {\\n    public int romanToInt(String s) {\\n        char[] ch = s.toCharArray();\\n        int result = 0;\\n        int i = 0;\\n        while(i<ch.length){\\n                if(ch[i]==\\'I\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'V\\'){\\n                            result = result + 4;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'X\\'){\\n                            result+=9;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n                    result+=1;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'X\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'L\\' && i<ch.length-1){\\n                            result+=40;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'C\\' && i<ch.length-1){\\n                            result+=90;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=10;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'C\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'M\\'){\\n                            result+=900;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'D\\'){\\n                            result+=400;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=100;\\n                    i+=1;\\n                    continue;\\n                }\\n            switch (ch[i]){\\n                case \\'V\\':\\n                    result+=5;\\n                    i+=1;\\n                    continue;\\n                case \\'L\\':\\n                    result+=50;\\n                    i+=1;\\n                    continue;\\n                case \\'D\\':\\n                    result+=500;\\n                    i+=1;\\n                    continue;\\n                case \\'M\\':\\n                    result+=1000;\\n                    i+=1;\\n                    continue;\\n\\n            }\\n            i+=1;\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "shubhamdesoria",
                        "content": "My code runs great on the js online compiler but suprisingly it\\'s not working on leet code\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "MHZ48",
                        "content": "omk 87be"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "#include<bits/stdc++.h>\\nclass Solution{\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char,int> uMap ={{\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},\\n        {\\'M\\',1000}};\\n        int num =0;\\n        int pValue= 1000;\\n        for(int i =0;i<s.length();i++){\\n            int value = uMap[s[i]];\\n            if(value>pValue){\\n                num-= 2*pValue;                \\n            }\\n            num+=value;\\n            pValue= value;\\n        }\\n        return num;   \\n    }\\n};"
                    },
                    {
                        "username": "James5779",
                        "content": "This is not clear, what is the actual question they are asking? Write a program that dose what? "
                    },
                    {
                        "username": "marsinearth",
                        "content": "I think there are mere subtraction of lesser values compare to greater values are all accepted here, which it should not!\\nfor example, 999 for roman number should be CMXCIX, not IM but many answers are accepting those IM cases....\\n\\nThis is WRONG\\n\\n"
                    }
                ]
            },
            {
                "id": 1714338,
                "content": [
                    {
                        "username": "Sooraj1710",
                        "content": "hello guys, im new here, and i dont know how to use leetcode.\\njust if someone can tell me what to do with the roman int question"
                    },
                    {
                        "username": "quosuka",
                        "content": "what im missing? \\n/**\\n* @param {string} s\\n* @return {number}\\n*/\\nvar romanToInt = function (s) { \\nvar dict = {\\n\\'I\\':1,\\n\\'V\\':5,\\n\\'X\\':10, \\n\\'L\\':50,\\n\\'C\\':100,\\n\\'D\\':500,\\n\\'M\\':1000\\n};\\n\\nvar result = 0;\\nvar intVal = 0; \\nvar nextIntVal = 0;\\nfor (var I = 0; I < s.length; I++) {\\nintVal = dict [s[I]];\\n\\nif(I!=s.length-1)\\n{\\nnextIntVal = dict[s[I+1]];\\nif(nextIntVal>intVal){\\n    intVal = nextIntVal-intVal;\\n I+I+1;\\n}\\n}\\nresult = result + intVal;\\n}\\nreturn result;\\n};"
                    },
                    {
                        "username": "okdssdf",
                        "content": "i need to help:\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n"
                    },
                    {
                        "username": "mathavaroopan",
                        "content": "Java - Beats 95%\\n\\nCode:\\n\\nclass Solution {\\n    public int romanToInt(String s) {\\n        char[] ch = s.toCharArray();\\n        int result = 0;\\n        int i = 0;\\n        while(i<ch.length){\\n                if(ch[i]==\\'I\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'V\\'){\\n                            result = result + 4;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'X\\'){\\n                            result+=9;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n                    result+=1;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'X\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'L\\' && i<ch.length-1){\\n                            result+=40;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'C\\' && i<ch.length-1){\\n                            result+=90;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=10;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'C\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'M\\'){\\n                            result+=900;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'D\\'){\\n                            result+=400;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=100;\\n                    i+=1;\\n                    continue;\\n                }\\n            switch (ch[i]){\\n                case \\'V\\':\\n                    result+=5;\\n                    i+=1;\\n                    continue;\\n                case \\'L\\':\\n                    result+=50;\\n                    i+=1;\\n                    continue;\\n                case \\'D\\':\\n                    result+=500;\\n                    i+=1;\\n                    continue;\\n                case \\'M\\':\\n                    result+=1000;\\n                    i+=1;\\n                    continue;\\n\\n            }\\n            i+=1;\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "shubhamdesoria",
                        "content": "My code runs great on the js online compiler but suprisingly it\\'s not working on leet code\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "MHZ48",
                        "content": "omk 87be"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "#include<bits/stdc++.h>\\nclass Solution{\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char,int> uMap ={{\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},\\n        {\\'M\\',1000}};\\n        int num =0;\\n        int pValue= 1000;\\n        for(int i =0;i<s.length();i++){\\n            int value = uMap[s[i]];\\n            if(value>pValue){\\n                num-= 2*pValue;                \\n            }\\n            num+=value;\\n            pValue= value;\\n        }\\n        return num;   \\n    }\\n};"
                    },
                    {
                        "username": "James5779",
                        "content": "This is not clear, what is the actual question they are asking? Write a program that dose what? "
                    },
                    {
                        "username": "marsinearth",
                        "content": "I think there are mere subtraction of lesser values compare to greater values are all accepted here, which it should not!\\nfor example, 999 for roman number should be CMXCIX, not IM but many answers are accepting those IM cases....\\n\\nThis is WRONG\\n\\n"
                    }
                ]
            },
            {
                "id": 1709991,
                "content": [
                    {
                        "username": "Sooraj1710",
                        "content": "hello guys, im new here, and i dont know how to use leetcode.\\njust if someone can tell me what to do with the roman int question"
                    },
                    {
                        "username": "quosuka",
                        "content": "what im missing? \\n/**\\n* @param {string} s\\n* @return {number}\\n*/\\nvar romanToInt = function (s) { \\nvar dict = {\\n\\'I\\':1,\\n\\'V\\':5,\\n\\'X\\':10, \\n\\'L\\':50,\\n\\'C\\':100,\\n\\'D\\':500,\\n\\'M\\':1000\\n};\\n\\nvar result = 0;\\nvar intVal = 0; \\nvar nextIntVal = 0;\\nfor (var I = 0; I < s.length; I++) {\\nintVal = dict [s[I]];\\n\\nif(I!=s.length-1)\\n{\\nnextIntVal = dict[s[I+1]];\\nif(nextIntVal>intVal){\\n    intVal = nextIntVal-intVal;\\n I+I+1;\\n}\\n}\\nresult = result + intVal;\\n}\\nreturn result;\\n};"
                    },
                    {
                        "username": "okdssdf",
                        "content": "i need to help:\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n"
                    },
                    {
                        "username": "mathavaroopan",
                        "content": "Java - Beats 95%\\n\\nCode:\\n\\nclass Solution {\\n    public int romanToInt(String s) {\\n        char[] ch = s.toCharArray();\\n        int result = 0;\\n        int i = 0;\\n        while(i<ch.length){\\n                if(ch[i]==\\'I\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'V\\'){\\n                            result = result + 4;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'X\\'){\\n                            result+=9;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n                    result+=1;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'X\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'L\\' && i<ch.length-1){\\n                            result+=40;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'C\\' && i<ch.length-1){\\n                            result+=90;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=10;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'C\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'M\\'){\\n                            result+=900;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'D\\'){\\n                            result+=400;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=100;\\n                    i+=1;\\n                    continue;\\n                }\\n            switch (ch[i]){\\n                case \\'V\\':\\n                    result+=5;\\n                    i+=1;\\n                    continue;\\n                case \\'L\\':\\n                    result+=50;\\n                    i+=1;\\n                    continue;\\n                case \\'D\\':\\n                    result+=500;\\n                    i+=1;\\n                    continue;\\n                case \\'M\\':\\n                    result+=1000;\\n                    i+=1;\\n                    continue;\\n\\n            }\\n            i+=1;\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "shubhamdesoria",
                        "content": "My code runs great on the js online compiler but suprisingly it\\'s not working on leet code\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "MHZ48",
                        "content": "omk 87be"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "#include<bits/stdc++.h>\\nclass Solution{\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char,int> uMap ={{\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},\\n        {\\'M\\',1000}};\\n        int num =0;\\n        int pValue= 1000;\\n        for(int i =0;i<s.length();i++){\\n            int value = uMap[s[i]];\\n            if(value>pValue){\\n                num-= 2*pValue;                \\n            }\\n            num+=value;\\n            pValue= value;\\n        }\\n        return num;   \\n    }\\n};"
                    },
                    {
                        "username": "James5779",
                        "content": "This is not clear, what is the actual question they are asking? Write a program that dose what? "
                    },
                    {
                        "username": "marsinearth",
                        "content": "I think there are mere subtraction of lesser values compare to greater values are all accepted here, which it should not!\\nfor example, 999 for roman number should be CMXCIX, not IM but many answers are accepting those IM cases....\\n\\nThis is WRONG\\n\\n"
                    }
                ]
            },
            {
                "id": 1709943,
                "content": [
                    {
                        "username": "Sooraj1710",
                        "content": "hello guys, im new here, and i dont know how to use leetcode.\\njust if someone can tell me what to do with the roman int question"
                    },
                    {
                        "username": "quosuka",
                        "content": "what im missing? \\n/**\\n* @param {string} s\\n* @return {number}\\n*/\\nvar romanToInt = function (s) { \\nvar dict = {\\n\\'I\\':1,\\n\\'V\\':5,\\n\\'X\\':10, \\n\\'L\\':50,\\n\\'C\\':100,\\n\\'D\\':500,\\n\\'M\\':1000\\n};\\n\\nvar result = 0;\\nvar intVal = 0; \\nvar nextIntVal = 0;\\nfor (var I = 0; I < s.length; I++) {\\nintVal = dict [s[I]];\\n\\nif(I!=s.length-1)\\n{\\nnextIntVal = dict[s[I+1]];\\nif(nextIntVal>intVal){\\n    intVal = nextIntVal-intVal;\\n I+I+1;\\n}\\n}\\nresult = result + intVal;\\n}\\nreturn result;\\n};"
                    },
                    {
                        "username": "okdssdf",
                        "content": "i need to help:\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n"
                    },
                    {
                        "username": "mathavaroopan",
                        "content": "Java - Beats 95%\\n\\nCode:\\n\\nclass Solution {\\n    public int romanToInt(String s) {\\n        char[] ch = s.toCharArray();\\n        int result = 0;\\n        int i = 0;\\n        while(i<ch.length){\\n                if(ch[i]==\\'I\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'V\\'){\\n                            result = result + 4;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'X\\'){\\n                            result+=9;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n                    result+=1;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'X\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'L\\' && i<ch.length-1){\\n                            result+=40;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'C\\' && i<ch.length-1){\\n                            result+=90;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=10;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'C\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'M\\'){\\n                            result+=900;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'D\\'){\\n                            result+=400;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=100;\\n                    i+=1;\\n                    continue;\\n                }\\n            switch (ch[i]){\\n                case \\'V\\':\\n                    result+=5;\\n                    i+=1;\\n                    continue;\\n                case \\'L\\':\\n                    result+=50;\\n                    i+=1;\\n                    continue;\\n                case \\'D\\':\\n                    result+=500;\\n                    i+=1;\\n                    continue;\\n                case \\'M\\':\\n                    result+=1000;\\n                    i+=1;\\n                    continue;\\n\\n            }\\n            i+=1;\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "shubhamdesoria",
                        "content": "My code runs great on the js online compiler but suprisingly it\\'s not working on leet code\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "MHZ48",
                        "content": "omk 87be"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "#include<bits/stdc++.h>\\nclass Solution{\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char,int> uMap ={{\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},\\n        {\\'M\\',1000}};\\n        int num =0;\\n        int pValue= 1000;\\n        for(int i =0;i<s.length();i++){\\n            int value = uMap[s[i]];\\n            if(value>pValue){\\n                num-= 2*pValue;                \\n            }\\n            num+=value;\\n            pValue= value;\\n        }\\n        return num;   \\n    }\\n};"
                    },
                    {
                        "username": "James5779",
                        "content": "This is not clear, what is the actual question they are asking? Write a program that dose what? "
                    },
                    {
                        "username": "marsinearth",
                        "content": "I think there are mere subtraction of lesser values compare to greater values are all accepted here, which it should not!\\nfor example, 999 for roman number should be CMXCIX, not IM but many answers are accepting those IM cases....\\n\\nThis is WRONG\\n\\n"
                    }
                ]
            },
            {
                "id": 1702952,
                "content": [
                    {
                        "username": "Sooraj1710",
                        "content": "hello guys, im new here, and i dont know how to use leetcode.\\njust if someone can tell me what to do with the roman int question"
                    },
                    {
                        "username": "quosuka",
                        "content": "what im missing? \\n/**\\n* @param {string} s\\n* @return {number}\\n*/\\nvar romanToInt = function (s) { \\nvar dict = {\\n\\'I\\':1,\\n\\'V\\':5,\\n\\'X\\':10, \\n\\'L\\':50,\\n\\'C\\':100,\\n\\'D\\':500,\\n\\'M\\':1000\\n};\\n\\nvar result = 0;\\nvar intVal = 0; \\nvar nextIntVal = 0;\\nfor (var I = 0; I < s.length; I++) {\\nintVal = dict [s[I]];\\n\\nif(I!=s.length-1)\\n{\\nnextIntVal = dict[s[I+1]];\\nif(nextIntVal>intVal){\\n    intVal = nextIntVal-intVal;\\n I+I+1;\\n}\\n}\\nresult = result + intVal;\\n}\\nreturn result;\\n};"
                    },
                    {
                        "username": "okdssdf",
                        "content": "i need to help:\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n"
                    },
                    {
                        "username": "mathavaroopan",
                        "content": "Java - Beats 95%\\n\\nCode:\\n\\nclass Solution {\\n    public int romanToInt(String s) {\\n        char[] ch = s.toCharArray();\\n        int result = 0;\\n        int i = 0;\\n        while(i<ch.length){\\n                if(ch[i]==\\'I\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'V\\'){\\n                            result = result + 4;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'X\\'){\\n                            result+=9;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n                    result+=1;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'X\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'L\\' && i<ch.length-1){\\n                            result+=40;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'C\\' && i<ch.length-1){\\n                            result+=90;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=10;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'C\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'M\\'){\\n                            result+=900;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'D\\'){\\n                            result+=400;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=100;\\n                    i+=1;\\n                    continue;\\n                }\\n            switch (ch[i]){\\n                case \\'V\\':\\n                    result+=5;\\n                    i+=1;\\n                    continue;\\n                case \\'L\\':\\n                    result+=50;\\n                    i+=1;\\n                    continue;\\n                case \\'D\\':\\n                    result+=500;\\n                    i+=1;\\n                    continue;\\n                case \\'M\\':\\n                    result+=1000;\\n                    i+=1;\\n                    continue;\\n\\n            }\\n            i+=1;\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "shubhamdesoria",
                        "content": "My code runs great on the js online compiler but suprisingly it\\'s not working on leet code\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "MHZ48",
                        "content": "omk 87be"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "#include<bits/stdc++.h>\\nclass Solution{\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char,int> uMap ={{\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},\\n        {\\'M\\',1000}};\\n        int num =0;\\n        int pValue= 1000;\\n        for(int i =0;i<s.length();i++){\\n            int value = uMap[s[i]];\\n            if(value>pValue){\\n                num-= 2*pValue;                \\n            }\\n            num+=value;\\n            pValue= value;\\n        }\\n        return num;   \\n    }\\n};"
                    },
                    {
                        "username": "James5779",
                        "content": "This is not clear, what is the actual question they are asking? Write a program that dose what? "
                    },
                    {
                        "username": "marsinearth",
                        "content": "I think there are mere subtraction of lesser values compare to greater values are all accepted here, which it should not!\\nfor example, 999 for roman number should be CMXCIX, not IM but many answers are accepting those IM cases....\\n\\nThis is WRONG\\n\\n"
                    }
                ]
            },
            {
                "id": 1694437,
                "content": [
                    {
                        "username": "Sooraj1710",
                        "content": "hello guys, im new here, and i dont know how to use leetcode.\\njust if someone can tell me what to do with the roman int question"
                    },
                    {
                        "username": "quosuka",
                        "content": "what im missing? \\n/**\\n* @param {string} s\\n* @return {number}\\n*/\\nvar romanToInt = function (s) { \\nvar dict = {\\n\\'I\\':1,\\n\\'V\\':5,\\n\\'X\\':10, \\n\\'L\\':50,\\n\\'C\\':100,\\n\\'D\\':500,\\n\\'M\\':1000\\n};\\n\\nvar result = 0;\\nvar intVal = 0; \\nvar nextIntVal = 0;\\nfor (var I = 0; I < s.length; I++) {\\nintVal = dict [s[I]];\\n\\nif(I!=s.length-1)\\n{\\nnextIntVal = dict[s[I+1]];\\nif(nextIntVal>intVal){\\n    intVal = nextIntVal-intVal;\\n I+I+1;\\n}\\n}\\nresult = result + intVal;\\n}\\nreturn result;\\n};"
                    },
                    {
                        "username": "okdssdf",
                        "content": "i need to help:\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n"
                    },
                    {
                        "username": "mathavaroopan",
                        "content": "Java - Beats 95%\\n\\nCode:\\n\\nclass Solution {\\n    public int romanToInt(String s) {\\n        char[] ch = s.toCharArray();\\n        int result = 0;\\n        int i = 0;\\n        while(i<ch.length){\\n                if(ch[i]==\\'I\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'V\\'){\\n                            result = result + 4;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'X\\'){\\n                            result+=9;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n                    result+=1;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'X\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'L\\' && i<ch.length-1){\\n                            result+=40;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'C\\' && i<ch.length-1){\\n                            result+=90;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=10;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'C\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'M\\'){\\n                            result+=900;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'D\\'){\\n                            result+=400;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=100;\\n                    i+=1;\\n                    continue;\\n                }\\n            switch (ch[i]){\\n                case \\'V\\':\\n                    result+=5;\\n                    i+=1;\\n                    continue;\\n                case \\'L\\':\\n                    result+=50;\\n                    i+=1;\\n                    continue;\\n                case \\'D\\':\\n                    result+=500;\\n                    i+=1;\\n                    continue;\\n                case \\'M\\':\\n                    result+=1000;\\n                    i+=1;\\n                    continue;\\n\\n            }\\n            i+=1;\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "shubhamdesoria",
                        "content": "My code runs great on the js online compiler but suprisingly it\\'s not working on leet code\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "MHZ48",
                        "content": "omk 87be"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "#include<bits/stdc++.h>\\nclass Solution{\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char,int> uMap ={{\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},\\n        {\\'M\\',1000}};\\n        int num =0;\\n        int pValue= 1000;\\n        for(int i =0;i<s.length();i++){\\n            int value = uMap[s[i]];\\n            if(value>pValue){\\n                num-= 2*pValue;                \\n            }\\n            num+=value;\\n            pValue= value;\\n        }\\n        return num;   \\n    }\\n};"
                    },
                    {
                        "username": "James5779",
                        "content": "This is not clear, what is the actual question they are asking? Write a program that dose what? "
                    },
                    {
                        "username": "marsinearth",
                        "content": "I think there are mere subtraction of lesser values compare to greater values are all accepted here, which it should not!\\nfor example, 999 for roman number should be CMXCIX, not IM but many answers are accepting those IM cases....\\n\\nThis is WRONG\\n\\n"
                    }
                ]
            },
            {
                "id": 1688662,
                "content": [
                    {
                        "username": "Sooraj1710",
                        "content": "hello guys, im new here, and i dont know how to use leetcode.\\njust if someone can tell me what to do with the roman int question"
                    },
                    {
                        "username": "quosuka",
                        "content": "what im missing? \\n/**\\n* @param {string} s\\n* @return {number}\\n*/\\nvar romanToInt = function (s) { \\nvar dict = {\\n\\'I\\':1,\\n\\'V\\':5,\\n\\'X\\':10, \\n\\'L\\':50,\\n\\'C\\':100,\\n\\'D\\':500,\\n\\'M\\':1000\\n};\\n\\nvar result = 0;\\nvar intVal = 0; \\nvar nextIntVal = 0;\\nfor (var I = 0; I < s.length; I++) {\\nintVal = dict [s[I]];\\n\\nif(I!=s.length-1)\\n{\\nnextIntVal = dict[s[I+1]];\\nif(nextIntVal>intVal){\\n    intVal = nextIntVal-intVal;\\n I+I+1;\\n}\\n}\\nresult = result + intVal;\\n}\\nreturn result;\\n};"
                    },
                    {
                        "username": "okdssdf",
                        "content": "i need to help:\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n"
                    },
                    {
                        "username": "mathavaroopan",
                        "content": "Java - Beats 95%\\n\\nCode:\\n\\nclass Solution {\\n    public int romanToInt(String s) {\\n        char[] ch = s.toCharArray();\\n        int result = 0;\\n        int i = 0;\\n        while(i<ch.length){\\n                if(ch[i]==\\'I\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'V\\'){\\n                            result = result + 4;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'X\\'){\\n                            result+=9;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n                    result+=1;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'X\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'L\\' && i<ch.length-1){\\n                            result+=40;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'C\\' && i<ch.length-1){\\n                            result+=90;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=10;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'C\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'M\\'){\\n                            result+=900;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'D\\'){\\n                            result+=400;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=100;\\n                    i+=1;\\n                    continue;\\n                }\\n            switch (ch[i]){\\n                case \\'V\\':\\n                    result+=5;\\n                    i+=1;\\n                    continue;\\n                case \\'L\\':\\n                    result+=50;\\n                    i+=1;\\n                    continue;\\n                case \\'D\\':\\n                    result+=500;\\n                    i+=1;\\n                    continue;\\n                case \\'M\\':\\n                    result+=1000;\\n                    i+=1;\\n                    continue;\\n\\n            }\\n            i+=1;\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "shubhamdesoria",
                        "content": "My code runs great on the js online compiler but suprisingly it\\'s not working on leet code\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "MHZ48",
                        "content": "omk 87be"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "#include<bits/stdc++.h>\\nclass Solution{\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char,int> uMap ={{\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},\\n        {\\'M\\',1000}};\\n        int num =0;\\n        int pValue= 1000;\\n        for(int i =0;i<s.length();i++){\\n            int value = uMap[s[i]];\\n            if(value>pValue){\\n                num-= 2*pValue;                \\n            }\\n            num+=value;\\n            pValue= value;\\n        }\\n        return num;   \\n    }\\n};"
                    },
                    {
                        "username": "James5779",
                        "content": "This is not clear, what is the actual question they are asking? Write a program that dose what? "
                    },
                    {
                        "username": "marsinearth",
                        "content": "I think there are mere subtraction of lesser values compare to greater values are all accepted here, which it should not!\\nfor example, 999 for roman number should be CMXCIX, not IM but many answers are accepting those IM cases....\\n\\nThis is WRONG\\n\\n"
                    }
                ]
            },
            {
                "id": 1686164,
                "content": [
                    {
                        "username": "Sooraj1710",
                        "content": "hello guys, im new here, and i dont know how to use leetcode.\\njust if someone can tell me what to do with the roman int question"
                    },
                    {
                        "username": "quosuka",
                        "content": "what im missing? \\n/**\\n* @param {string} s\\n* @return {number}\\n*/\\nvar romanToInt = function (s) { \\nvar dict = {\\n\\'I\\':1,\\n\\'V\\':5,\\n\\'X\\':10, \\n\\'L\\':50,\\n\\'C\\':100,\\n\\'D\\':500,\\n\\'M\\':1000\\n};\\n\\nvar result = 0;\\nvar intVal = 0; \\nvar nextIntVal = 0;\\nfor (var I = 0; I < s.length; I++) {\\nintVal = dict [s[I]];\\n\\nif(I!=s.length-1)\\n{\\nnextIntVal = dict[s[I+1]];\\nif(nextIntVal>intVal){\\n    intVal = nextIntVal-intVal;\\n I+I+1;\\n}\\n}\\nresult = result + intVal;\\n}\\nreturn result;\\n};"
                    },
                    {
                        "username": "okdssdf",
                        "content": "i need to help:\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n"
                    },
                    {
                        "username": "mathavaroopan",
                        "content": "Java - Beats 95%\\n\\nCode:\\n\\nclass Solution {\\n    public int romanToInt(String s) {\\n        char[] ch = s.toCharArray();\\n        int result = 0;\\n        int i = 0;\\n        while(i<ch.length){\\n                if(ch[i]==\\'I\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'V\\'){\\n                            result = result + 4;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'X\\'){\\n                            result+=9;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n                    result+=1;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'X\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'L\\' && i<ch.length-1){\\n                            result+=40;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'C\\' && i<ch.length-1){\\n                            result+=90;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=10;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'C\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'M\\'){\\n                            result+=900;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'D\\'){\\n                            result+=400;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=100;\\n                    i+=1;\\n                    continue;\\n                }\\n            switch (ch[i]){\\n                case \\'V\\':\\n                    result+=5;\\n                    i+=1;\\n                    continue;\\n                case \\'L\\':\\n                    result+=50;\\n                    i+=1;\\n                    continue;\\n                case \\'D\\':\\n                    result+=500;\\n                    i+=1;\\n                    continue;\\n                case \\'M\\':\\n                    result+=1000;\\n                    i+=1;\\n                    continue;\\n\\n            }\\n            i+=1;\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "shubhamdesoria",
                        "content": "My code runs great on the js online compiler but suprisingly it\\'s not working on leet code\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "MHZ48",
                        "content": "omk 87be"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "#include<bits/stdc++.h>\\nclass Solution{\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char,int> uMap ={{\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},\\n        {\\'M\\',1000}};\\n        int num =0;\\n        int pValue= 1000;\\n        for(int i =0;i<s.length();i++){\\n            int value = uMap[s[i]];\\n            if(value>pValue){\\n                num-= 2*pValue;                \\n            }\\n            num+=value;\\n            pValue= value;\\n        }\\n        return num;   \\n    }\\n};"
                    },
                    {
                        "username": "James5779",
                        "content": "This is not clear, what is the actual question they are asking? Write a program that dose what? "
                    },
                    {
                        "username": "marsinearth",
                        "content": "I think there are mere subtraction of lesser values compare to greater values are all accepted here, which it should not!\\nfor example, 999 for roman number should be CMXCIX, not IM but many answers are accepting those IM cases....\\n\\nThis is WRONG\\n\\n"
                    }
                ]
            },
            {
                "id": 1683844,
                "content": [
                    {
                        "username": "Sooraj1710",
                        "content": "hello guys, im new here, and i dont know how to use leetcode.\\njust if someone can tell me what to do with the roman int question"
                    },
                    {
                        "username": "quosuka",
                        "content": "what im missing? \\n/**\\n* @param {string} s\\n* @return {number}\\n*/\\nvar romanToInt = function (s) { \\nvar dict = {\\n\\'I\\':1,\\n\\'V\\':5,\\n\\'X\\':10, \\n\\'L\\':50,\\n\\'C\\':100,\\n\\'D\\':500,\\n\\'M\\':1000\\n};\\n\\nvar result = 0;\\nvar intVal = 0; \\nvar nextIntVal = 0;\\nfor (var I = 0; I < s.length; I++) {\\nintVal = dict [s[I]];\\n\\nif(I!=s.length-1)\\n{\\nnextIntVal = dict[s[I+1]];\\nif(nextIntVal>intVal){\\n    intVal = nextIntVal-intVal;\\n I+I+1;\\n}\\n}\\nresult = result + intVal;\\n}\\nreturn result;\\n};"
                    },
                    {
                        "username": "okdssdf",
                        "content": "i need to help:\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n"
                    },
                    {
                        "username": "mathavaroopan",
                        "content": "Java - Beats 95%\\n\\nCode:\\n\\nclass Solution {\\n    public int romanToInt(String s) {\\n        char[] ch = s.toCharArray();\\n        int result = 0;\\n        int i = 0;\\n        while(i<ch.length){\\n                if(ch[i]==\\'I\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'V\\'){\\n                            result = result + 4;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'X\\'){\\n                            result+=9;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n                    result+=1;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'X\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'L\\' && i<ch.length-1){\\n                            result+=40;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'C\\' && i<ch.length-1){\\n                            result+=90;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=10;\\n                    i+=1;\\n                    continue;\\n                }else if(ch[i]==\\'C\\'){\\n                    if(i<ch.length-1){\\n                        if(ch[i+1]==\\'M\\'){\\n                            result+=900;\\n                            i+=2;\\n                            continue;\\n                        }else if(ch[i+1]==\\'D\\'){\\n                            result+=400;\\n                            i+=2;\\n                            continue;\\n                        }\\n                    }\\n\\n                    result+=100;\\n                    i+=1;\\n                    continue;\\n                }\\n            switch (ch[i]){\\n                case \\'V\\':\\n                    result+=5;\\n                    i+=1;\\n                    continue;\\n                case \\'L\\':\\n                    result+=50;\\n                    i+=1;\\n                    continue;\\n                case \\'D\\':\\n                    result+=500;\\n                    i+=1;\\n                    continue;\\n                case \\'M\\':\\n                    result+=1000;\\n                    i+=1;\\n                    continue;\\n\\n            }\\n            i+=1;\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "shubhamdesoria",
                        "content": "My code runs great on the js online compiler but suprisingly it\\'s not working on leet code\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/roman-to-integer/solutions/2869607/easiest-faang-method-ever/"
                    },
                    {
                        "username": "MHZ48",
                        "content": "omk 87be"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "#include<bits/stdc++.h>\\nclass Solution{\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char,int> uMap ={{\\'I\\',1},{\\'V\\',5},{\\'X\\',10},{\\'L\\',50},{\\'C\\',100},{\\'D\\',500},\\n        {\\'M\\',1000}};\\n        int num =0;\\n        int pValue= 1000;\\n        for(int i =0;i<s.length();i++){\\n            int value = uMap[s[i]];\\n            if(value>pValue){\\n                num-= 2*pValue;                \\n            }\\n            num+=value;\\n            pValue= value;\\n        }\\n        return num;   \\n    }\\n};"
                    },
                    {
                        "username": "James5779",
                        "content": "This is not clear, what is the actual question they are asking? Write a program that dose what? "
                    },
                    {
                        "username": "marsinearth",
                        "content": "I think there are mere subtraction of lesser values compare to greater values are all accepted here, which it should not!\\nfor example, 999 for roman number should be CMXCIX, not IM but many answers are accepting those IM cases....\\n\\nThis is WRONG\\n\\n"
                    }
                ]
            },
            {
                "id": 1681279,
                "content": [
                    {
                        "username": "sankalp1_807",
                        "content": "what logic must i use here\\n"
                    },
                    {
                        "username": "mokasha11",
                        "content": "I don\\'t think this problem should be classified as easy because it involves some tricky string manipulation when it comes to the subtraction for the odd cases. How long did it take you to solve this problem?"
                    },
                    {
                        "username": "P3DR0_SULISTA",
                        "content": "No roblox Studio, os blocos ficam soltos uns dos outros algu\\xE9m coloca o script para eu arrumar isso?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html)"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "Please tell me why this does not give 3 as output when input is \"III\" in javascript.\\n \\nvar romanToInt = function(s) {\\n   var num = 0;\\n   for(let i=0;i<s.length;i++){\\n       let flag=0;\\n       switch(s[i]){\\n           case \\'I\\':\\n           if(s[i++]==\\'V\\'){\\n               num+=4;\\n               flag=1;\\n           }\\n           else if(s[i++]===\\'X\\'){\\n               num+=9;\\n               flag=1;\\n           }\\n              \\n           else{\\n               num+=1;\\n           }  \\n           break;\\n           \\n           case \\'V\\':\\n           num+=5;\\n           break;\\n           \\n           case \\'X\\':\\n           if(s[i++]==\\'L\\'){\\n               num+=40;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'C\\'){\\n               num+=90;\\n               flag=1;\\n           }     \\n           else{\\n               num+=10;\\n           }  \\n           break;\\n\\n           case \\'L\\':\\n           num+=50;\\n           break;\\n\\n           case \\'C\\':\\n           if(s[i++]==\\'D\\'){\\n               num+=400;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'M\\'){\\n               num+=900;\\n               flag=1;\\n           }     \\n           else{\\n               num+=100;\\n           }  \\n           break;\\n\\n           case \\'D\\':\\n           num+=500;\\n           break;\\n\\n           case \\'M\\':\\n           num+=1000;\\n           break;\\n        }\\n        if(flag==1){\\n            continue;\\n        }\\n         \\n   }\\n  \\n   return num;\\n};"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "[@elzazo](/elzazo) Thanks brother all my test cases passed. Also I had to replace \"continue\" with i=i+2"
                    },
                    {
                        "username": "elzazo",
                        "content": "Your code returns 1, doesn\\'t it? ^_^ The explaination is simple: every time you evaluate against i++ i gets incremented. Replace it with i+1 and retest. If you had tested it with II it should have gone out of bounds immediately, which it would have given you the possibility to understand it by yourself. ;-)"
                    },
                    {
                        "username": "Bharath_sharadanand",
                        "content": "Information about constraints "
                    },
                    {
                        "username": "skp_82603",
                        "content": "I have executed this code in DevC++ compiler and also online GDB compiler, and it is giving me the solution correctly, but for some reason I\\'m not getting the correct output in leetcode. Any suggestions?"
                    },
                    {
                        "username": "elzazo",
                        "content": "is the function signature the exact same? is the class name exactly the same? "
                    },
                    {
                        "username": "Y0ucef",
                        "content": "I made it so you can read the roman_Num \\nby using a for loop that goes through my code and calls another function that checks the letter and returns a number \\n\\nbut then I couldn\\'t get it to work on numbers like (IV,IX,IL .... ect)\\n\\nI tried to put and if statment inside of the my for loop to know if the agacent number is bigger or smaller but i always had and \"index out of range error\"\\nany advice to correct it \\n\\n "
                    },
                    {
                        "username": "victor_Bliss",
                        "content": "Place given value behind known ones to get answer i think"
                    },
                    {
                        "username": "anchal712",
                        "content": "class Solution{\\n    \\n public int romanToInt(String  s)  {\\n  int i,sum=0;\\n  String p;\\n  int z = s.length();\\n  for(i=0;i<z;i++){\\n      p = Character.toString(s.charAt(i));\\n      \\n      String result = p;\\n      switch(result){\\n          case \"I\" : sum = sum+ 1;\\n                   break;\\n          case \"V\" : sum = sum+ 5;\\n                   break;\\n          case \"X\": sum = sum+ 10;\\n                   break;\\n          case \"L\" : sum = sum+ 50;\\n                   break; \\n          case \"C\" : sum = sum+ 100;\\n                   break;\\n          case \"D\" : sum = sum+ 500;\\n                   break; \\n          case \"M\" : sum = sum+ 1000;\\n                   break;\\n          default : System.out.println(\"number doesnt exist\");\\n                                  \\n      }\\n      \\n      \\n  }\\n  return sum;\\n }\\n\\n}"
                    },
                    {
                        "username": "elzazo",
                        "content": "Sorry but this solution is wrong. With IV it gives 6 (1+5) instead of 4 (5-1)."
                    }
                ]
            },
            {
                "id": 1672420,
                "content": [
                    {
                        "username": "sankalp1_807",
                        "content": "what logic must i use here\\n"
                    },
                    {
                        "username": "mokasha11",
                        "content": "I don\\'t think this problem should be classified as easy because it involves some tricky string manipulation when it comes to the subtraction for the odd cases. How long did it take you to solve this problem?"
                    },
                    {
                        "username": "P3DR0_SULISTA",
                        "content": "No roblox Studio, os blocos ficam soltos uns dos outros algu\\xE9m coloca o script para eu arrumar isso?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html)"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "Please tell me why this does not give 3 as output when input is \"III\" in javascript.\\n \\nvar romanToInt = function(s) {\\n   var num = 0;\\n   for(let i=0;i<s.length;i++){\\n       let flag=0;\\n       switch(s[i]){\\n           case \\'I\\':\\n           if(s[i++]==\\'V\\'){\\n               num+=4;\\n               flag=1;\\n           }\\n           else if(s[i++]===\\'X\\'){\\n               num+=9;\\n               flag=1;\\n           }\\n              \\n           else{\\n               num+=1;\\n           }  \\n           break;\\n           \\n           case \\'V\\':\\n           num+=5;\\n           break;\\n           \\n           case \\'X\\':\\n           if(s[i++]==\\'L\\'){\\n               num+=40;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'C\\'){\\n               num+=90;\\n               flag=1;\\n           }     \\n           else{\\n               num+=10;\\n           }  \\n           break;\\n\\n           case \\'L\\':\\n           num+=50;\\n           break;\\n\\n           case \\'C\\':\\n           if(s[i++]==\\'D\\'){\\n               num+=400;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'M\\'){\\n               num+=900;\\n               flag=1;\\n           }     \\n           else{\\n               num+=100;\\n           }  \\n           break;\\n\\n           case \\'D\\':\\n           num+=500;\\n           break;\\n\\n           case \\'M\\':\\n           num+=1000;\\n           break;\\n        }\\n        if(flag==1){\\n            continue;\\n        }\\n         \\n   }\\n  \\n   return num;\\n};"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "[@elzazo](/elzazo) Thanks brother all my test cases passed. Also I had to replace \"continue\" with i=i+2"
                    },
                    {
                        "username": "elzazo",
                        "content": "Your code returns 1, doesn\\'t it? ^_^ The explaination is simple: every time you evaluate against i++ i gets incremented. Replace it with i+1 and retest. If you had tested it with II it should have gone out of bounds immediately, which it would have given you the possibility to understand it by yourself. ;-)"
                    },
                    {
                        "username": "Bharath_sharadanand",
                        "content": "Information about constraints "
                    },
                    {
                        "username": "skp_82603",
                        "content": "I have executed this code in DevC++ compiler and also online GDB compiler, and it is giving me the solution correctly, but for some reason I\\'m not getting the correct output in leetcode. Any suggestions?"
                    },
                    {
                        "username": "elzazo",
                        "content": "is the function signature the exact same? is the class name exactly the same? "
                    },
                    {
                        "username": "Y0ucef",
                        "content": "I made it so you can read the roman_Num \\nby using a for loop that goes through my code and calls another function that checks the letter and returns a number \\n\\nbut then I couldn\\'t get it to work on numbers like (IV,IX,IL .... ect)\\n\\nI tried to put and if statment inside of the my for loop to know if the agacent number is bigger or smaller but i always had and \"index out of range error\"\\nany advice to correct it \\n\\n "
                    },
                    {
                        "username": "victor_Bliss",
                        "content": "Place given value behind known ones to get answer i think"
                    },
                    {
                        "username": "anchal712",
                        "content": "class Solution{\\n    \\n public int romanToInt(String  s)  {\\n  int i,sum=0;\\n  String p;\\n  int z = s.length();\\n  for(i=0;i<z;i++){\\n      p = Character.toString(s.charAt(i));\\n      \\n      String result = p;\\n      switch(result){\\n          case \"I\" : sum = sum+ 1;\\n                   break;\\n          case \"V\" : sum = sum+ 5;\\n                   break;\\n          case \"X\": sum = sum+ 10;\\n                   break;\\n          case \"L\" : sum = sum+ 50;\\n                   break; \\n          case \"C\" : sum = sum+ 100;\\n                   break;\\n          case \"D\" : sum = sum+ 500;\\n                   break; \\n          case \"M\" : sum = sum+ 1000;\\n                   break;\\n          default : System.out.println(\"number doesnt exist\");\\n                                  \\n      }\\n      \\n      \\n  }\\n  return sum;\\n }\\n\\n}"
                    },
                    {
                        "username": "elzazo",
                        "content": "Sorry but this solution is wrong. With IV it gives 6 (1+5) instead of 4 (5-1)."
                    }
                ]
            },
            {
                "id": 1671519,
                "content": [
                    {
                        "username": "sankalp1_807",
                        "content": "what logic must i use here\\n"
                    },
                    {
                        "username": "mokasha11",
                        "content": "I don\\'t think this problem should be classified as easy because it involves some tricky string manipulation when it comes to the subtraction for the odd cases. How long did it take you to solve this problem?"
                    },
                    {
                        "username": "P3DR0_SULISTA",
                        "content": "No roblox Studio, os blocos ficam soltos uns dos outros algu\\xE9m coloca o script para eu arrumar isso?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html)"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "Please tell me why this does not give 3 as output when input is \"III\" in javascript.\\n \\nvar romanToInt = function(s) {\\n   var num = 0;\\n   for(let i=0;i<s.length;i++){\\n       let flag=0;\\n       switch(s[i]){\\n           case \\'I\\':\\n           if(s[i++]==\\'V\\'){\\n               num+=4;\\n               flag=1;\\n           }\\n           else if(s[i++]===\\'X\\'){\\n               num+=9;\\n               flag=1;\\n           }\\n              \\n           else{\\n               num+=1;\\n           }  \\n           break;\\n           \\n           case \\'V\\':\\n           num+=5;\\n           break;\\n           \\n           case \\'X\\':\\n           if(s[i++]==\\'L\\'){\\n               num+=40;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'C\\'){\\n               num+=90;\\n               flag=1;\\n           }     \\n           else{\\n               num+=10;\\n           }  \\n           break;\\n\\n           case \\'L\\':\\n           num+=50;\\n           break;\\n\\n           case \\'C\\':\\n           if(s[i++]==\\'D\\'){\\n               num+=400;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'M\\'){\\n               num+=900;\\n               flag=1;\\n           }     \\n           else{\\n               num+=100;\\n           }  \\n           break;\\n\\n           case \\'D\\':\\n           num+=500;\\n           break;\\n\\n           case \\'M\\':\\n           num+=1000;\\n           break;\\n        }\\n        if(flag==1){\\n            continue;\\n        }\\n         \\n   }\\n  \\n   return num;\\n};"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "[@elzazo](/elzazo) Thanks brother all my test cases passed. Also I had to replace \"continue\" with i=i+2"
                    },
                    {
                        "username": "elzazo",
                        "content": "Your code returns 1, doesn\\'t it? ^_^ The explaination is simple: every time you evaluate against i++ i gets incremented. Replace it with i+1 and retest. If you had tested it with II it should have gone out of bounds immediately, which it would have given you the possibility to understand it by yourself. ;-)"
                    },
                    {
                        "username": "Bharath_sharadanand",
                        "content": "Information about constraints "
                    },
                    {
                        "username": "skp_82603",
                        "content": "I have executed this code in DevC++ compiler and also online GDB compiler, and it is giving me the solution correctly, but for some reason I\\'m not getting the correct output in leetcode. Any suggestions?"
                    },
                    {
                        "username": "elzazo",
                        "content": "is the function signature the exact same? is the class name exactly the same? "
                    },
                    {
                        "username": "Y0ucef",
                        "content": "I made it so you can read the roman_Num \\nby using a for loop that goes through my code and calls another function that checks the letter and returns a number \\n\\nbut then I couldn\\'t get it to work on numbers like (IV,IX,IL .... ect)\\n\\nI tried to put and if statment inside of the my for loop to know if the agacent number is bigger or smaller but i always had and \"index out of range error\"\\nany advice to correct it \\n\\n "
                    },
                    {
                        "username": "victor_Bliss",
                        "content": "Place given value behind known ones to get answer i think"
                    },
                    {
                        "username": "anchal712",
                        "content": "class Solution{\\n    \\n public int romanToInt(String  s)  {\\n  int i,sum=0;\\n  String p;\\n  int z = s.length();\\n  for(i=0;i<z;i++){\\n      p = Character.toString(s.charAt(i));\\n      \\n      String result = p;\\n      switch(result){\\n          case \"I\" : sum = sum+ 1;\\n                   break;\\n          case \"V\" : sum = sum+ 5;\\n                   break;\\n          case \"X\": sum = sum+ 10;\\n                   break;\\n          case \"L\" : sum = sum+ 50;\\n                   break; \\n          case \"C\" : sum = sum+ 100;\\n                   break;\\n          case \"D\" : sum = sum+ 500;\\n                   break; \\n          case \"M\" : sum = sum+ 1000;\\n                   break;\\n          default : System.out.println(\"number doesnt exist\");\\n                                  \\n      }\\n      \\n      \\n  }\\n  return sum;\\n }\\n\\n}"
                    },
                    {
                        "username": "elzazo",
                        "content": "Sorry but this solution is wrong. With IV it gives 6 (1+5) instead of 4 (5-1)."
                    }
                ]
            },
            {
                "id": 1671251,
                "content": [
                    {
                        "username": "sankalp1_807",
                        "content": "what logic must i use here\\n"
                    },
                    {
                        "username": "mokasha11",
                        "content": "I don\\'t think this problem should be classified as easy because it involves some tricky string manipulation when it comes to the subtraction for the odd cases. How long did it take you to solve this problem?"
                    },
                    {
                        "username": "P3DR0_SULISTA",
                        "content": "No roblox Studio, os blocos ficam soltos uns dos outros algu\\xE9m coloca o script para eu arrumar isso?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html)"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "Please tell me why this does not give 3 as output when input is \"III\" in javascript.\\n \\nvar romanToInt = function(s) {\\n   var num = 0;\\n   for(let i=0;i<s.length;i++){\\n       let flag=0;\\n       switch(s[i]){\\n           case \\'I\\':\\n           if(s[i++]==\\'V\\'){\\n               num+=4;\\n               flag=1;\\n           }\\n           else if(s[i++]===\\'X\\'){\\n               num+=9;\\n               flag=1;\\n           }\\n              \\n           else{\\n               num+=1;\\n           }  \\n           break;\\n           \\n           case \\'V\\':\\n           num+=5;\\n           break;\\n           \\n           case \\'X\\':\\n           if(s[i++]==\\'L\\'){\\n               num+=40;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'C\\'){\\n               num+=90;\\n               flag=1;\\n           }     \\n           else{\\n               num+=10;\\n           }  \\n           break;\\n\\n           case \\'L\\':\\n           num+=50;\\n           break;\\n\\n           case \\'C\\':\\n           if(s[i++]==\\'D\\'){\\n               num+=400;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'M\\'){\\n               num+=900;\\n               flag=1;\\n           }     \\n           else{\\n               num+=100;\\n           }  \\n           break;\\n\\n           case \\'D\\':\\n           num+=500;\\n           break;\\n\\n           case \\'M\\':\\n           num+=1000;\\n           break;\\n        }\\n        if(flag==1){\\n            continue;\\n        }\\n         \\n   }\\n  \\n   return num;\\n};"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "[@elzazo](/elzazo) Thanks brother all my test cases passed. Also I had to replace \"continue\" with i=i+2"
                    },
                    {
                        "username": "elzazo",
                        "content": "Your code returns 1, doesn\\'t it? ^_^ The explaination is simple: every time you evaluate against i++ i gets incremented. Replace it with i+1 and retest. If you had tested it with II it should have gone out of bounds immediately, which it would have given you the possibility to understand it by yourself. ;-)"
                    },
                    {
                        "username": "Bharath_sharadanand",
                        "content": "Information about constraints "
                    },
                    {
                        "username": "skp_82603",
                        "content": "I have executed this code in DevC++ compiler and also online GDB compiler, and it is giving me the solution correctly, but for some reason I\\'m not getting the correct output in leetcode. Any suggestions?"
                    },
                    {
                        "username": "elzazo",
                        "content": "is the function signature the exact same? is the class name exactly the same? "
                    },
                    {
                        "username": "Y0ucef",
                        "content": "I made it so you can read the roman_Num \\nby using a for loop that goes through my code and calls another function that checks the letter and returns a number \\n\\nbut then I couldn\\'t get it to work on numbers like (IV,IX,IL .... ect)\\n\\nI tried to put and if statment inside of the my for loop to know if the agacent number is bigger or smaller but i always had and \"index out of range error\"\\nany advice to correct it \\n\\n "
                    },
                    {
                        "username": "victor_Bliss",
                        "content": "Place given value behind known ones to get answer i think"
                    },
                    {
                        "username": "anchal712",
                        "content": "class Solution{\\n    \\n public int romanToInt(String  s)  {\\n  int i,sum=0;\\n  String p;\\n  int z = s.length();\\n  for(i=0;i<z;i++){\\n      p = Character.toString(s.charAt(i));\\n      \\n      String result = p;\\n      switch(result){\\n          case \"I\" : sum = sum+ 1;\\n                   break;\\n          case \"V\" : sum = sum+ 5;\\n                   break;\\n          case \"X\": sum = sum+ 10;\\n                   break;\\n          case \"L\" : sum = sum+ 50;\\n                   break; \\n          case \"C\" : sum = sum+ 100;\\n                   break;\\n          case \"D\" : sum = sum+ 500;\\n                   break; \\n          case \"M\" : sum = sum+ 1000;\\n                   break;\\n          default : System.out.println(\"number doesnt exist\");\\n                                  \\n      }\\n      \\n      \\n  }\\n  return sum;\\n }\\n\\n}"
                    },
                    {
                        "username": "elzazo",
                        "content": "Sorry but this solution is wrong. With IV it gives 6 (1+5) instead of 4 (5-1)."
                    }
                ]
            },
            {
                "id": 1663022,
                "content": [
                    {
                        "username": "sankalp1_807",
                        "content": "what logic must i use here\\n"
                    },
                    {
                        "username": "mokasha11",
                        "content": "I don\\'t think this problem should be classified as easy because it involves some tricky string manipulation when it comes to the subtraction for the odd cases. How long did it take you to solve this problem?"
                    },
                    {
                        "username": "P3DR0_SULISTA",
                        "content": "No roblox Studio, os blocos ficam soltos uns dos outros algu\\xE9m coloca o script para eu arrumar isso?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html)"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "Please tell me why this does not give 3 as output when input is \"III\" in javascript.\\n \\nvar romanToInt = function(s) {\\n   var num = 0;\\n   for(let i=0;i<s.length;i++){\\n       let flag=0;\\n       switch(s[i]){\\n           case \\'I\\':\\n           if(s[i++]==\\'V\\'){\\n               num+=4;\\n               flag=1;\\n           }\\n           else if(s[i++]===\\'X\\'){\\n               num+=9;\\n               flag=1;\\n           }\\n              \\n           else{\\n               num+=1;\\n           }  \\n           break;\\n           \\n           case \\'V\\':\\n           num+=5;\\n           break;\\n           \\n           case \\'X\\':\\n           if(s[i++]==\\'L\\'){\\n               num+=40;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'C\\'){\\n               num+=90;\\n               flag=1;\\n           }     \\n           else{\\n               num+=10;\\n           }  \\n           break;\\n\\n           case \\'L\\':\\n           num+=50;\\n           break;\\n\\n           case \\'C\\':\\n           if(s[i++]==\\'D\\'){\\n               num+=400;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'M\\'){\\n               num+=900;\\n               flag=1;\\n           }     \\n           else{\\n               num+=100;\\n           }  \\n           break;\\n\\n           case \\'D\\':\\n           num+=500;\\n           break;\\n\\n           case \\'M\\':\\n           num+=1000;\\n           break;\\n        }\\n        if(flag==1){\\n            continue;\\n        }\\n         \\n   }\\n  \\n   return num;\\n};"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "[@elzazo](/elzazo) Thanks brother all my test cases passed. Also I had to replace \"continue\" with i=i+2"
                    },
                    {
                        "username": "elzazo",
                        "content": "Your code returns 1, doesn\\'t it? ^_^ The explaination is simple: every time you evaluate against i++ i gets incremented. Replace it with i+1 and retest. If you had tested it with II it should have gone out of bounds immediately, which it would have given you the possibility to understand it by yourself. ;-)"
                    },
                    {
                        "username": "Bharath_sharadanand",
                        "content": "Information about constraints "
                    },
                    {
                        "username": "skp_82603",
                        "content": "I have executed this code in DevC++ compiler and also online GDB compiler, and it is giving me the solution correctly, but for some reason I\\'m not getting the correct output in leetcode. Any suggestions?"
                    },
                    {
                        "username": "elzazo",
                        "content": "is the function signature the exact same? is the class name exactly the same? "
                    },
                    {
                        "username": "Y0ucef",
                        "content": "I made it so you can read the roman_Num \\nby using a for loop that goes through my code and calls another function that checks the letter and returns a number \\n\\nbut then I couldn\\'t get it to work on numbers like (IV,IX,IL .... ect)\\n\\nI tried to put and if statment inside of the my for loop to know if the agacent number is bigger or smaller but i always had and \"index out of range error\"\\nany advice to correct it \\n\\n "
                    },
                    {
                        "username": "victor_Bliss",
                        "content": "Place given value behind known ones to get answer i think"
                    },
                    {
                        "username": "anchal712",
                        "content": "class Solution{\\n    \\n public int romanToInt(String  s)  {\\n  int i,sum=0;\\n  String p;\\n  int z = s.length();\\n  for(i=0;i<z;i++){\\n      p = Character.toString(s.charAt(i));\\n      \\n      String result = p;\\n      switch(result){\\n          case \"I\" : sum = sum+ 1;\\n                   break;\\n          case \"V\" : sum = sum+ 5;\\n                   break;\\n          case \"X\": sum = sum+ 10;\\n                   break;\\n          case \"L\" : sum = sum+ 50;\\n                   break; \\n          case \"C\" : sum = sum+ 100;\\n                   break;\\n          case \"D\" : sum = sum+ 500;\\n                   break; \\n          case \"M\" : sum = sum+ 1000;\\n                   break;\\n          default : System.out.println(\"number doesnt exist\");\\n                                  \\n      }\\n      \\n      \\n  }\\n  return sum;\\n }\\n\\n}"
                    },
                    {
                        "username": "elzazo",
                        "content": "Sorry but this solution is wrong. With IV it gives 6 (1+5) instead of 4 (5-1)."
                    }
                ]
            },
            {
                "id": 1662640,
                "content": [
                    {
                        "username": "sankalp1_807",
                        "content": "what logic must i use here\\n"
                    },
                    {
                        "username": "mokasha11",
                        "content": "I don\\'t think this problem should be classified as easy because it involves some tricky string manipulation when it comes to the subtraction for the odd cases. How long did it take you to solve this problem?"
                    },
                    {
                        "username": "P3DR0_SULISTA",
                        "content": "No roblox Studio, os blocos ficam soltos uns dos outros algu\\xE9m coloca o script para eu arrumar isso?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html)"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "Please tell me why this does not give 3 as output when input is \"III\" in javascript.\\n \\nvar romanToInt = function(s) {\\n   var num = 0;\\n   for(let i=0;i<s.length;i++){\\n       let flag=0;\\n       switch(s[i]){\\n           case \\'I\\':\\n           if(s[i++]==\\'V\\'){\\n               num+=4;\\n               flag=1;\\n           }\\n           else if(s[i++]===\\'X\\'){\\n               num+=9;\\n               flag=1;\\n           }\\n              \\n           else{\\n               num+=1;\\n           }  \\n           break;\\n           \\n           case \\'V\\':\\n           num+=5;\\n           break;\\n           \\n           case \\'X\\':\\n           if(s[i++]==\\'L\\'){\\n               num+=40;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'C\\'){\\n               num+=90;\\n               flag=1;\\n           }     \\n           else{\\n               num+=10;\\n           }  \\n           break;\\n\\n           case \\'L\\':\\n           num+=50;\\n           break;\\n\\n           case \\'C\\':\\n           if(s[i++]==\\'D\\'){\\n               num+=400;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'M\\'){\\n               num+=900;\\n               flag=1;\\n           }     \\n           else{\\n               num+=100;\\n           }  \\n           break;\\n\\n           case \\'D\\':\\n           num+=500;\\n           break;\\n\\n           case \\'M\\':\\n           num+=1000;\\n           break;\\n        }\\n        if(flag==1){\\n            continue;\\n        }\\n         \\n   }\\n  \\n   return num;\\n};"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "[@elzazo](/elzazo) Thanks brother all my test cases passed. Also I had to replace \"continue\" with i=i+2"
                    },
                    {
                        "username": "elzazo",
                        "content": "Your code returns 1, doesn\\'t it? ^_^ The explaination is simple: every time you evaluate against i++ i gets incremented. Replace it with i+1 and retest. If you had tested it with II it should have gone out of bounds immediately, which it would have given you the possibility to understand it by yourself. ;-)"
                    },
                    {
                        "username": "Bharath_sharadanand",
                        "content": "Information about constraints "
                    },
                    {
                        "username": "skp_82603",
                        "content": "I have executed this code in DevC++ compiler and also online GDB compiler, and it is giving me the solution correctly, but for some reason I\\'m not getting the correct output in leetcode. Any suggestions?"
                    },
                    {
                        "username": "elzazo",
                        "content": "is the function signature the exact same? is the class name exactly the same? "
                    },
                    {
                        "username": "Y0ucef",
                        "content": "I made it so you can read the roman_Num \\nby using a for loop that goes through my code and calls another function that checks the letter and returns a number \\n\\nbut then I couldn\\'t get it to work on numbers like (IV,IX,IL .... ect)\\n\\nI tried to put and if statment inside of the my for loop to know if the agacent number is bigger or smaller but i always had and \"index out of range error\"\\nany advice to correct it \\n\\n "
                    },
                    {
                        "username": "victor_Bliss",
                        "content": "Place given value behind known ones to get answer i think"
                    },
                    {
                        "username": "anchal712",
                        "content": "class Solution{\\n    \\n public int romanToInt(String  s)  {\\n  int i,sum=0;\\n  String p;\\n  int z = s.length();\\n  for(i=0;i<z;i++){\\n      p = Character.toString(s.charAt(i));\\n      \\n      String result = p;\\n      switch(result){\\n          case \"I\" : sum = sum+ 1;\\n                   break;\\n          case \"V\" : sum = sum+ 5;\\n                   break;\\n          case \"X\": sum = sum+ 10;\\n                   break;\\n          case \"L\" : sum = sum+ 50;\\n                   break; \\n          case \"C\" : sum = sum+ 100;\\n                   break;\\n          case \"D\" : sum = sum+ 500;\\n                   break; \\n          case \"M\" : sum = sum+ 1000;\\n                   break;\\n          default : System.out.println(\"number doesnt exist\");\\n                                  \\n      }\\n      \\n      \\n  }\\n  return sum;\\n }\\n\\n}"
                    },
                    {
                        "username": "elzazo",
                        "content": "Sorry but this solution is wrong. With IV it gives 6 (1+5) instead of 4 (5-1)."
                    }
                ]
            },
            {
                "id": 1658616,
                "content": [
                    {
                        "username": "sankalp1_807",
                        "content": "what logic must i use here\\n"
                    },
                    {
                        "username": "mokasha11",
                        "content": "I don\\'t think this problem should be classified as easy because it involves some tricky string manipulation when it comes to the subtraction for the odd cases. How long did it take you to solve this problem?"
                    },
                    {
                        "username": "P3DR0_SULISTA",
                        "content": "No roblox Studio, os blocos ficam soltos uns dos outros algu\\xE9m coloca o script para eu arrumar isso?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html)"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "Please tell me why this does not give 3 as output when input is \"III\" in javascript.\\n \\nvar romanToInt = function(s) {\\n   var num = 0;\\n   for(let i=0;i<s.length;i++){\\n       let flag=0;\\n       switch(s[i]){\\n           case \\'I\\':\\n           if(s[i++]==\\'V\\'){\\n               num+=4;\\n               flag=1;\\n           }\\n           else if(s[i++]===\\'X\\'){\\n               num+=9;\\n               flag=1;\\n           }\\n              \\n           else{\\n               num+=1;\\n           }  \\n           break;\\n           \\n           case \\'V\\':\\n           num+=5;\\n           break;\\n           \\n           case \\'X\\':\\n           if(s[i++]==\\'L\\'){\\n               num+=40;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'C\\'){\\n               num+=90;\\n               flag=1;\\n           }     \\n           else{\\n               num+=10;\\n           }  \\n           break;\\n\\n           case \\'L\\':\\n           num+=50;\\n           break;\\n\\n           case \\'C\\':\\n           if(s[i++]==\\'D\\'){\\n               num+=400;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'M\\'){\\n               num+=900;\\n               flag=1;\\n           }     \\n           else{\\n               num+=100;\\n           }  \\n           break;\\n\\n           case \\'D\\':\\n           num+=500;\\n           break;\\n\\n           case \\'M\\':\\n           num+=1000;\\n           break;\\n        }\\n        if(flag==1){\\n            continue;\\n        }\\n         \\n   }\\n  \\n   return num;\\n};"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "[@elzazo](/elzazo) Thanks brother all my test cases passed. Also I had to replace \"continue\" with i=i+2"
                    },
                    {
                        "username": "elzazo",
                        "content": "Your code returns 1, doesn\\'t it? ^_^ The explaination is simple: every time you evaluate against i++ i gets incremented. Replace it with i+1 and retest. If you had tested it with II it should have gone out of bounds immediately, which it would have given you the possibility to understand it by yourself. ;-)"
                    },
                    {
                        "username": "Bharath_sharadanand",
                        "content": "Information about constraints "
                    },
                    {
                        "username": "skp_82603",
                        "content": "I have executed this code in DevC++ compiler and also online GDB compiler, and it is giving me the solution correctly, but for some reason I\\'m not getting the correct output in leetcode. Any suggestions?"
                    },
                    {
                        "username": "elzazo",
                        "content": "is the function signature the exact same? is the class name exactly the same? "
                    },
                    {
                        "username": "Y0ucef",
                        "content": "I made it so you can read the roman_Num \\nby using a for loop that goes through my code and calls another function that checks the letter and returns a number \\n\\nbut then I couldn\\'t get it to work on numbers like (IV,IX,IL .... ect)\\n\\nI tried to put and if statment inside of the my for loop to know if the agacent number is bigger or smaller but i always had and \"index out of range error\"\\nany advice to correct it \\n\\n "
                    },
                    {
                        "username": "victor_Bliss",
                        "content": "Place given value behind known ones to get answer i think"
                    },
                    {
                        "username": "anchal712",
                        "content": "class Solution{\\n    \\n public int romanToInt(String  s)  {\\n  int i,sum=0;\\n  String p;\\n  int z = s.length();\\n  for(i=0;i<z;i++){\\n      p = Character.toString(s.charAt(i));\\n      \\n      String result = p;\\n      switch(result){\\n          case \"I\" : sum = sum+ 1;\\n                   break;\\n          case \"V\" : sum = sum+ 5;\\n                   break;\\n          case \"X\": sum = sum+ 10;\\n                   break;\\n          case \"L\" : sum = sum+ 50;\\n                   break; \\n          case \"C\" : sum = sum+ 100;\\n                   break;\\n          case \"D\" : sum = sum+ 500;\\n                   break; \\n          case \"M\" : sum = sum+ 1000;\\n                   break;\\n          default : System.out.println(\"number doesnt exist\");\\n                                  \\n      }\\n      \\n      \\n  }\\n  return sum;\\n }\\n\\n}"
                    },
                    {
                        "username": "elzazo",
                        "content": "Sorry but this solution is wrong. With IV it gives 6 (1+5) instead of 4 (5-1)."
                    }
                ]
            },
            {
                "id": 1654672,
                "content": [
                    {
                        "username": "sankalp1_807",
                        "content": "what logic must i use here\\n"
                    },
                    {
                        "username": "mokasha11",
                        "content": "I don\\'t think this problem should be classified as easy because it involves some tricky string manipulation when it comes to the subtraction for the odd cases. How long did it take you to solve this problem?"
                    },
                    {
                        "username": "P3DR0_SULISTA",
                        "content": "No roblox Studio, os blocos ficam soltos uns dos outros algu\\xE9m coloca o script para eu arrumar isso?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html)"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "Please tell me why this does not give 3 as output when input is \"III\" in javascript.\\n \\nvar romanToInt = function(s) {\\n   var num = 0;\\n   for(let i=0;i<s.length;i++){\\n       let flag=0;\\n       switch(s[i]){\\n           case \\'I\\':\\n           if(s[i++]==\\'V\\'){\\n               num+=4;\\n               flag=1;\\n           }\\n           else if(s[i++]===\\'X\\'){\\n               num+=9;\\n               flag=1;\\n           }\\n              \\n           else{\\n               num+=1;\\n           }  \\n           break;\\n           \\n           case \\'V\\':\\n           num+=5;\\n           break;\\n           \\n           case \\'X\\':\\n           if(s[i++]==\\'L\\'){\\n               num+=40;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'C\\'){\\n               num+=90;\\n               flag=1;\\n           }     \\n           else{\\n               num+=10;\\n           }  \\n           break;\\n\\n           case \\'L\\':\\n           num+=50;\\n           break;\\n\\n           case \\'C\\':\\n           if(s[i++]==\\'D\\'){\\n               num+=400;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'M\\'){\\n               num+=900;\\n               flag=1;\\n           }     \\n           else{\\n               num+=100;\\n           }  \\n           break;\\n\\n           case \\'D\\':\\n           num+=500;\\n           break;\\n\\n           case \\'M\\':\\n           num+=1000;\\n           break;\\n        }\\n        if(flag==1){\\n            continue;\\n        }\\n         \\n   }\\n  \\n   return num;\\n};"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "[@elzazo](/elzazo) Thanks brother all my test cases passed. Also I had to replace \"continue\" with i=i+2"
                    },
                    {
                        "username": "elzazo",
                        "content": "Your code returns 1, doesn\\'t it? ^_^ The explaination is simple: every time you evaluate against i++ i gets incremented. Replace it with i+1 and retest. If you had tested it with II it should have gone out of bounds immediately, which it would have given you the possibility to understand it by yourself. ;-)"
                    },
                    {
                        "username": "Bharath_sharadanand",
                        "content": "Information about constraints "
                    },
                    {
                        "username": "skp_82603",
                        "content": "I have executed this code in DevC++ compiler and also online GDB compiler, and it is giving me the solution correctly, but for some reason I\\'m not getting the correct output in leetcode. Any suggestions?"
                    },
                    {
                        "username": "elzazo",
                        "content": "is the function signature the exact same? is the class name exactly the same? "
                    },
                    {
                        "username": "Y0ucef",
                        "content": "I made it so you can read the roman_Num \\nby using a for loop that goes through my code and calls another function that checks the letter and returns a number \\n\\nbut then I couldn\\'t get it to work on numbers like (IV,IX,IL .... ect)\\n\\nI tried to put and if statment inside of the my for loop to know if the agacent number is bigger or smaller but i always had and \"index out of range error\"\\nany advice to correct it \\n\\n "
                    },
                    {
                        "username": "victor_Bliss",
                        "content": "Place given value behind known ones to get answer i think"
                    },
                    {
                        "username": "anchal712",
                        "content": "class Solution{\\n    \\n public int romanToInt(String  s)  {\\n  int i,sum=0;\\n  String p;\\n  int z = s.length();\\n  for(i=0;i<z;i++){\\n      p = Character.toString(s.charAt(i));\\n      \\n      String result = p;\\n      switch(result){\\n          case \"I\" : sum = sum+ 1;\\n                   break;\\n          case \"V\" : sum = sum+ 5;\\n                   break;\\n          case \"X\": sum = sum+ 10;\\n                   break;\\n          case \"L\" : sum = sum+ 50;\\n                   break; \\n          case \"C\" : sum = sum+ 100;\\n                   break;\\n          case \"D\" : sum = sum+ 500;\\n                   break; \\n          case \"M\" : sum = sum+ 1000;\\n                   break;\\n          default : System.out.println(\"number doesnt exist\");\\n                                  \\n      }\\n      \\n      \\n  }\\n  return sum;\\n }\\n\\n}"
                    },
                    {
                        "username": "elzazo",
                        "content": "Sorry but this solution is wrong. With IV it gives 6 (1+5) instead of 4 (5-1)."
                    }
                ]
            },
            {
                "id": 1654127,
                "content": [
                    {
                        "username": "sankalp1_807",
                        "content": "what logic must i use here\\n"
                    },
                    {
                        "username": "mokasha11",
                        "content": "I don\\'t think this problem should be classified as easy because it involves some tricky string manipulation when it comes to the subtraction for the odd cases. How long did it take you to solve this problem?"
                    },
                    {
                        "username": "P3DR0_SULISTA",
                        "content": "No roblox Studio, os blocos ficam soltos uns dos outros algu\\xE9m coloca o script para eu arrumar isso?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html)"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "Please tell me why this does not give 3 as output when input is \"III\" in javascript.\\n \\nvar romanToInt = function(s) {\\n   var num = 0;\\n   for(let i=0;i<s.length;i++){\\n       let flag=0;\\n       switch(s[i]){\\n           case \\'I\\':\\n           if(s[i++]==\\'V\\'){\\n               num+=4;\\n               flag=1;\\n           }\\n           else if(s[i++]===\\'X\\'){\\n               num+=9;\\n               flag=1;\\n           }\\n              \\n           else{\\n               num+=1;\\n           }  \\n           break;\\n           \\n           case \\'V\\':\\n           num+=5;\\n           break;\\n           \\n           case \\'X\\':\\n           if(s[i++]==\\'L\\'){\\n               num+=40;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'C\\'){\\n               num+=90;\\n               flag=1;\\n           }     \\n           else{\\n               num+=10;\\n           }  \\n           break;\\n\\n           case \\'L\\':\\n           num+=50;\\n           break;\\n\\n           case \\'C\\':\\n           if(s[i++]==\\'D\\'){\\n               num+=400;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'M\\'){\\n               num+=900;\\n               flag=1;\\n           }     \\n           else{\\n               num+=100;\\n           }  \\n           break;\\n\\n           case \\'D\\':\\n           num+=500;\\n           break;\\n\\n           case \\'M\\':\\n           num+=1000;\\n           break;\\n        }\\n        if(flag==1){\\n            continue;\\n        }\\n         \\n   }\\n  \\n   return num;\\n};"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "[@elzazo](/elzazo) Thanks brother all my test cases passed. Also I had to replace \"continue\" with i=i+2"
                    },
                    {
                        "username": "elzazo",
                        "content": "Your code returns 1, doesn\\'t it? ^_^ The explaination is simple: every time you evaluate against i++ i gets incremented. Replace it with i+1 and retest. If you had tested it with II it should have gone out of bounds immediately, which it would have given you the possibility to understand it by yourself. ;-)"
                    },
                    {
                        "username": "Bharath_sharadanand",
                        "content": "Information about constraints "
                    },
                    {
                        "username": "skp_82603",
                        "content": "I have executed this code in DevC++ compiler and also online GDB compiler, and it is giving me the solution correctly, but for some reason I\\'m not getting the correct output in leetcode. Any suggestions?"
                    },
                    {
                        "username": "elzazo",
                        "content": "is the function signature the exact same? is the class name exactly the same? "
                    },
                    {
                        "username": "Y0ucef",
                        "content": "I made it so you can read the roman_Num \\nby using a for loop that goes through my code and calls another function that checks the letter and returns a number \\n\\nbut then I couldn\\'t get it to work on numbers like (IV,IX,IL .... ect)\\n\\nI tried to put and if statment inside of the my for loop to know if the agacent number is bigger or smaller but i always had and \"index out of range error\"\\nany advice to correct it \\n\\n "
                    },
                    {
                        "username": "victor_Bliss",
                        "content": "Place given value behind known ones to get answer i think"
                    },
                    {
                        "username": "anchal712",
                        "content": "class Solution{\\n    \\n public int romanToInt(String  s)  {\\n  int i,sum=0;\\n  String p;\\n  int z = s.length();\\n  for(i=0;i<z;i++){\\n      p = Character.toString(s.charAt(i));\\n      \\n      String result = p;\\n      switch(result){\\n          case \"I\" : sum = sum+ 1;\\n                   break;\\n          case \"V\" : sum = sum+ 5;\\n                   break;\\n          case \"X\": sum = sum+ 10;\\n                   break;\\n          case \"L\" : sum = sum+ 50;\\n                   break; \\n          case \"C\" : sum = sum+ 100;\\n                   break;\\n          case \"D\" : sum = sum+ 500;\\n                   break; \\n          case \"M\" : sum = sum+ 1000;\\n                   break;\\n          default : System.out.println(\"number doesnt exist\");\\n                                  \\n      }\\n      \\n      \\n  }\\n  return sum;\\n }\\n\\n}"
                    },
                    {
                        "username": "elzazo",
                        "content": "Sorry but this solution is wrong. With IV it gives 6 (1+5) instead of 4 (5-1)."
                    }
                ]
            },
            {
                "id": 1644787,
                "content": [
                    {
                        "username": "sankalp1_807",
                        "content": "what logic must i use here\\n"
                    },
                    {
                        "username": "mokasha11",
                        "content": "I don\\'t think this problem should be classified as easy because it involves some tricky string manipulation when it comes to the subtraction for the odd cases. How long did it take you to solve this problem?"
                    },
                    {
                        "username": "P3DR0_SULISTA",
                        "content": "No roblox Studio, os blocos ficam soltos uns dos outros algu\\xE9m coloca o script para eu arrumar isso?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-roman-to-integer-problem-solution.html)"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "Please tell me why this does not give 3 as output when input is \"III\" in javascript.\\n \\nvar romanToInt = function(s) {\\n   var num = 0;\\n   for(let i=0;i<s.length;i++){\\n       let flag=0;\\n       switch(s[i]){\\n           case \\'I\\':\\n           if(s[i++]==\\'V\\'){\\n               num+=4;\\n               flag=1;\\n           }\\n           else if(s[i++]===\\'X\\'){\\n               num+=9;\\n               flag=1;\\n           }\\n              \\n           else{\\n               num+=1;\\n           }  \\n           break;\\n           \\n           case \\'V\\':\\n           num+=5;\\n           break;\\n           \\n           case \\'X\\':\\n           if(s[i++]==\\'L\\'){\\n               num+=40;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'C\\'){\\n               num+=90;\\n               flag=1;\\n           }     \\n           else{\\n               num+=10;\\n           }  \\n           break;\\n\\n           case \\'L\\':\\n           num+=50;\\n           break;\\n\\n           case \\'C\\':\\n           if(s[i++]==\\'D\\'){\\n               num+=400;\\n               flag=1;\\n           }\\n           else if(s[i++]==\\'M\\'){\\n               num+=900;\\n               flag=1;\\n           }     \\n           else{\\n               num+=100;\\n           }  \\n           break;\\n\\n           case \\'D\\':\\n           num+=500;\\n           break;\\n\\n           case \\'M\\':\\n           num+=1000;\\n           break;\\n        }\\n        if(flag==1){\\n            continue;\\n        }\\n         \\n   }\\n  \\n   return num;\\n};"
                    },
                    {
                        "username": "aleemabbas31",
                        "content": "[@elzazo](/elzazo) Thanks brother all my test cases passed. Also I had to replace \"continue\" with i=i+2"
                    },
                    {
                        "username": "elzazo",
                        "content": "Your code returns 1, doesn\\'t it? ^_^ The explaination is simple: every time you evaluate against i++ i gets incremented. Replace it with i+1 and retest. If you had tested it with II it should have gone out of bounds immediately, which it would have given you the possibility to understand it by yourself. ;-)"
                    },
                    {
                        "username": "Bharath_sharadanand",
                        "content": "Information about constraints "
                    },
                    {
                        "username": "skp_82603",
                        "content": "I have executed this code in DevC++ compiler and also online GDB compiler, and it is giving me the solution correctly, but for some reason I\\'m not getting the correct output in leetcode. Any suggestions?"
                    },
                    {
                        "username": "elzazo",
                        "content": "is the function signature the exact same? is the class name exactly the same? "
                    },
                    {
                        "username": "Y0ucef",
                        "content": "I made it so you can read the roman_Num \\nby using a for loop that goes through my code and calls another function that checks the letter and returns a number \\n\\nbut then I couldn\\'t get it to work on numbers like (IV,IX,IL .... ect)\\n\\nI tried to put and if statment inside of the my for loop to know if the agacent number is bigger or smaller but i always had and \"index out of range error\"\\nany advice to correct it \\n\\n "
                    },
                    {
                        "username": "victor_Bliss",
                        "content": "Place given value behind known ones to get answer i think"
                    },
                    {
                        "username": "anchal712",
                        "content": "class Solution{\\n    \\n public int romanToInt(String  s)  {\\n  int i,sum=0;\\n  String p;\\n  int z = s.length();\\n  for(i=0;i<z;i++){\\n      p = Character.toString(s.charAt(i));\\n      \\n      String result = p;\\n      switch(result){\\n          case \"I\" : sum = sum+ 1;\\n                   break;\\n          case \"V\" : sum = sum+ 5;\\n                   break;\\n          case \"X\": sum = sum+ 10;\\n                   break;\\n          case \"L\" : sum = sum+ 50;\\n                   break; \\n          case \"C\" : sum = sum+ 100;\\n                   break;\\n          case \"D\" : sum = sum+ 500;\\n                   break; \\n          case \"M\" : sum = sum+ 1000;\\n                   break;\\n          default : System.out.println(\"number doesnt exist\");\\n                                  \\n      }\\n      \\n      \\n  }\\n  return sum;\\n }\\n\\n}"
                    },
                    {
                        "username": "elzazo",
                        "content": "Sorry but this solution is wrong. With IV it gives 6 (1+5) instead of 4 (5-1)."
                    }
                ]
            }
        ]
    },
    {
        "title": "Path Sum II",
        "question_content": "<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals </em><code>targetSum</code><em>. Each path should be returned as a list of the node <strong>values</strong>, not node references</em>.</p>\n\n<p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg\" style=\"width: 500px; height: 356px;\" />\n<pre>\n<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n<strong>Output:</strong> [[5,4,11,2],[5,8,4,5]]\n<strong>Explanation:</strong> There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" style=\"width: 212px; height: 181px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3], targetSum = 5\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,2], targetSum = 0\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 36829,
                "title": "python-solutions-recursively-bfs-queue-dfs-stack",
                "content": "```\\n    def pathSum(self, root, sum):\\n        res = []\\n        self.dfs(root, sum, [], res)\\n        return res\\n        \\n    def dfs(self, root, sum, ls, res):\\n        if root:\\n\\t\\t\\tif not root.left and not root.right and sum == root.val:\\n\\t\\t\\t\\tls.append(root.val)\\n\\t\\t\\t\\tres.append(ls)\\n            self.dfs(root.left, sum-root.val, ls+[root.val], res)\\n            self.dfs(root.right, sum-root.val, ls+[root.val], res)\\n            \\n    def pathSum2(self, root, sum):\\n        if not root:\\n            return []\\n        if not root.left and not root.right and sum == root.val:\\n            return [[root.val]]\\n        tmp = self.pathSum(root.left, sum-root.val) + self.pathSum(root.right, sum-root.val)\\n        return [[root.val]+i for i in tmp]\\n    \\n    # BFS + queue    \\n    def pathSum3(self, root, sum): \\n        if not root:\\n            return []\\n        res = []\\n        queue = [(root, root.val, [root.val])]\\n        while queue:\\n            curr, val, ls = queue.pop(0)\\n            if not curr.left and not curr.right and val == sum:\\n                res.append(ls)\\n            if curr.left:\\n                queue.append((curr.left, val+curr.left.val, ls+[curr.left.val]))\\n            if curr.right:\\n                queue.append((curr.right, val+curr.right.val, ls+[curr.right.val]))\\n        return res\\n        \\n    # DFS + stack I  \\n    def pathSum4(self, root, sum): \\n        if not root:\\n            return []\\n        res = []\\n        stack = [(root, sum-root.val, [root.val])]\\n        while stack:\\n            curr, val, ls = stack.pop()\\n            if not curr.left and not curr.right and val == 0:\\n                res.append(ls)\\n            if curr.right:\\n                stack.append((curr.right, val-curr.right.val, ls+[curr.right.val]))\\n            if curr.left:\\n                stack.append((curr.left, val-curr.left.val, ls+[curr.left.val]))\\n        return res \\n    \\n    # DFS + stack II   \\n    def pathSum5(self, root, s): \\n        if not root:\\n            return []\\n        res = []\\n        stack = [(root, [root.val])]\\n        while stack:\\n            curr, ls = stack.pop()\\n            if not curr.left and not curr.right and sum(ls) == s:\\n                res.append(ls)\\n            if curr.right:\\n                stack.append((curr.right, ls+[curr.right.val]))\\n            if curr.left:\\n                stack.append((curr.left, ls+[curr.left.val]))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n    def pathSum(self, root, sum):\\n        res = []\\n        self.dfs(root, sum, [], res)\\n        return res\\n        \\n    def dfs(self, root, sum, ls, res):\\n        if root:\\n\\t\\t\\tif not root.left and not root.right and sum == root.val:\\n\\t\\t\\t\\tls.append(root.val)\\n\\t\\t\\t\\tres.append(ls)\\n            self.dfs(root.left, sum-root.val, ls+[root.val], res)\\n            self.dfs(root.right, sum-root.val, ls+[root.val], res)\\n            \\n    def pathSum2(self, root, sum):\\n        if not root:\\n            return []\\n        if not root.left and not root.right and sum == root.val:\\n            return [[root.val]]\\n        tmp = self.pathSum(root.left, sum-root.val) + self.pathSum(root.right, sum-root.val)\\n        return [[root.val]+i for i in tmp]\\n    \\n    # BFS + queue    \\n    def pathSum3(self, root, sum): \\n        if not root:\\n            return []\\n        res = []\\n        queue = [(root, root.val, [root.val])]\\n        while queue:\\n            curr, val, ls = queue.pop(0)\\n            if not curr.left and not curr.right and val == sum:\\n                res.append(ls)\\n            if curr.left:\\n                queue.append((curr.left, val+curr.left.val, ls+[curr.left.val]))\\n            if curr.right:\\n                queue.append((curr.right, val+curr.right.val, ls+[curr.right.val]))\\n        return res\\n        \\n    # DFS + stack I  \\n    def pathSum4(self, root, sum): \\n        if not root:\\n            return []\\n        res = []\\n        stack = [(root, sum-root.val, [root.val])]\\n        while stack:\\n            curr, val, ls = stack.pop()\\n            if not curr.left and not curr.right and val == 0:\\n                res.append(ls)\\n            if curr.right:\\n                stack.append((curr.right, val-curr.right.val, ls+[curr.right.val]))\\n            if curr.left:\\n                stack.append((curr.left, val-curr.left.val, ls+[curr.left.val]))\\n        return res \\n    \\n    # DFS + stack II   \\n    def pathSum5(self, root, s): \\n        if not root:\\n            return []\\n        res = []\\n        stack = [(root, [root.val])]\\n        while stack:\\n            curr, ls = stack.pop()\\n            if not curr.left and not curr.right and sum(ls) == s:\\n                res.append(ls)\\n            if curr.right:\\n                stack.append((curr.right, ls+[curr.right.val]))\\n            if curr.left:\\n                stack.append((curr.left, ls+[curr.left.val]))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 36685,
                "title": "12ms-11-lines-c-solution",
                "content": "Well, a typical backtracking problem. The code is as follows. You may walk through it using the example in the problem statement to see how it works.\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n            vector<vector<int> > paths;\\n            vector<int> path;\\n            findPaths(root, sum, path, paths);\\n            return paths;  \\n        }\\n    private:\\n        void findPaths(TreeNode* node, int sum, vector<int>& path, vector<vector<int> >& paths) {\\n            if (!node) return;\\n            path.push_back(node -> val);\\n            if (!(node -> left) && !(node -> right) && sum == node -> val)\\n                paths.push_back(path);\\n            findPaths(node -> left, sum - node -> val, path, paths);\\n            findPaths(node -> right, sum - node -> val, path, paths);\\n            path.pop_back();\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n            vector<vector<int> > paths;\\n            vector<int> path;\\n            findPaths(root, sum, path, paths);\\n            return paths;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1382332,
                "title": "c-python-dfs-clean-concise-time-complexity-explained",
                "content": "**Idea**\\n- DFS from the root down to it\\'s descendants:\\n\\t- We need to keep current `path` (which stores elements in the path) so far.\\n\\t- We need to keep the remain `targetSum` so far (after minus value of elements in the path).\\n\\t- If we already reach into leaf node\\n\\t\\t- Check if `targetSum == 0` then we found a valid path from `root` to `leaf` node which sum equal to `targetSum`, so add current `path` to the answer.\\n\\t- Else dfs on left node and on the right node.\\n\\t\\n<iframe src=\"https://leetcode.com/playground/6xapiKpk/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 5000` is the number of elements in the binary tree. \\n\\t- First, we think the time complexity is `O(N)` because we only visit each node once.\\n\\t- But we forgot to calculate the cost to copy the current `path` when we found a valid path, which in the worst case can cost `O(N^2)`, let see the following example for more clear.\\n\\t![image](https://assets.leetcode.com/users/images/07ce7b13-c6b8-4fdf-80d7-b4e8cfb17b7b_1628074950.3171947.png)\\n\\n- Extra Space (without counting output as space): `O(H)`, where `H` is height of the binary tree. This is the space for stack recursion or keeping path so far.\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**Idea**\\n- DFS from the root down to it\\'s descendants:\\n\\t- We need to keep current `path` (which stores elements in the path) so far.\\n\\t- We need to keep the remain `targetSum` so far (after minus value of elements in the path).\\n\\t- If we already reach into leaf node\\n\\t\\t- Check if `targetSum == 0` then we found a valid path from `root` to `leaf` node which sum equal to `targetSum`, so add current `path` to the answer.\\n\\t- Else dfs on left node and on the right node.\\n\\t\\n<iframe src=\"https://leetcode.com/playground/6xapiKpk/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 5000` is the number of elements in the binary tree. \\n\\t- First, we think the time complexity is `O(N)` because we only visit each node once.\\n\\t- But we forgot to calculate the cost to copy the current `path` when we found a valid path, which in the worst case can cost `O(N^2)`, let see the following example for more clear.\\n\\t![image](https://assets.leetcode.com/users/images/07ce7b13-c6b8-4fdf-80d7-b4e8cfb17b7b_1628074950.3171947.png)\\n\\n- Extra Space (without counting output as space): `O(H)`, where `H` is height of the binary tree. This is the space for stack recursion or keeping path so far.\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 36683,
                "title": "dfs-with-one-linkedlist-accepted-java-solution",
                "content": "\\tpublic List<List<Integer>> pathSum(TreeNode root, int sum){\\n\\t\\tList<List<Integer>> result  = new LinkedList<List<Integer>>();\\n\\t\\tList<Integer> currentResult  = new LinkedList<Integer>();\\n\\t\\tpathSum(root,sum,currentResult,result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic void pathSum(TreeNode root, int sum, List<Integer> currentResult,\\n\\t\\t\\tList<List<Integer>> result) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn;\\n\\t\\tcurrentResult.add(new Integer(root.val));\\n\\t\\tif (root.left == null && root.right == null && sum == root.val) {\\n\\t\\t\\tresult.add(new LinkedList(currentResult));\\n\\t\\t\\tcurrentResult.remove(currentResult.size() - 1);//don't forget to remove the last integer\\n\\t\\t\\treturn;\\n\\t\\t} else {\\n\\t\\t\\tpathSum(root.left, sum - root.val, currentResult, result);\\n\\t\\t\\tpathSum(root.right, sum - root.val, currentResult, result);\\n\\t\\t}\\n\\t\\tcurrentResult.remove(currentResult.size() - 1);\\n\\t}",
                "solutionTags": [],
                "code": "\\tpublic List<List<Integer>> pathSum(TreeNode root, int sum){\\n\\t\\tList<List<Integer>> result  = new LinkedList<List<Integer>>();\\n\\t\\tList<Integer> currentResult  = new LinkedList<Integer>();\\n\\t\\tpathSum(root,sum,currentResult,result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic void pathSum(TreeNode root, int sum, List<Integer> currentResult,\\n\\t\\t\\tList<List<Integer>> result) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn;\\n\\t\\tcurrentResult.add(new Integer(root.val));\\n\\t\\tif (root.left == null && root.right == null && sum == root.val) {\\n\\t\\t\\tresult.add(new LinkedList(currentResult));\\n\\t\\t\\tcurrentResult.remove(currentResult.size() - 1);//don't forget to remove the last integer\\n\\t\\t\\treturn;\\n\\t\\t} else {\\n\\t\\t\\tpathSum(root.left, sum - root.val, currentResult, result);\\n\\t\\t\\tpathSum(root.right, sum - root.val, currentResult, result);\\n\\t\\t}\\n\\t\\tcurrentResult.remove(currentResult.size() - 1);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 36698,
                "title": "another-accepted-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            pathSum(root, sum, new ArrayList<Integer>(), res);\\n            return res;\\n        }\\n        \\n        void pathSum(TreeNode root, int sum, List<Integer> sol, List<List<Integer>> res) {\\n            if (root == null) {\\n                return;\\n            }\\n            \\n            sol.add(root.val);\\n            \\n            if (root.left == null && root.right == null && sum == root.val) {\\n                res.add(new ArrayList<Integer>(sol));\\n            } else {\\n                pathSum(root.left, sum - root.val, sol, res);\\n                pathSum(root.right, sum - root.val, sol, res);\\n            }\\n            \\n            sol.remove(sol.size() - 1);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            pathSum(root, sum, new ArrayList<Integer>(), res);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36695,
                "title": "java-solution-iterative-and-recursive",
                "content": "    //1. iterative: Using a stack to implement DFS\\n    //2. Recursive: \\n\\n    public class Solution {\\n        public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> path = new ArrayList<>();\\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            int SUM = 0;\\n            TreeNode cur = root;\\n            TreeNode pre = null;\\n            while(cur!=null || !stack.isEmpty()){\\n                while(cur!=null){\\n                    stack.push(cur);\\n                    path.add(cur.val);\\n                    SUM+=cur.val;\\n                    cur=cur.left;\\n                }\\n                cur = stack.peek();\\n                if(cur.right!=null && cur.right!=pre){\\n                    cur = cur.right;\\n                    continue;\\n                } \\n                if(cur.left==null && cur.right==null && SUM==sum) \\n                    res.add(new ArrayList<Integer>(path));\\n      \\n                pre = cur;\\n                stack.pop();\\n                path.remove(path.size()-1);\\n                SUM-=cur.val;\\n                cur = null;\\n            \\n            }\\n            return res;\\n        }\\n    }\\n\\n   \\n    \\n        public class Solution {\\n            public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n                List<List<Integer>> res = new ArrayList<>();\\n                List<Integer> path = new ArrayList<>();\\n                dfs(root, sum, res, path);\\n                return res;\\n            }\\n            \\n            public void dfs(TreeNode root, int sum, List<List<Integer>> res, List<Integer> path){\\n                if(root==null) return;\\n                path.add(root.val);\\n                \\n                if(root.left==null && root.right==null ){\\n                    if(root.val==sum)\\n                        res.add(new ArrayList<Integer>(path));\\n                    return;\\n                }\\n                if(root.left!=null) {\\n                    dfs(root.left,sum-root.val,res,path);\\n                    path.remove(path.size()-1);\\n                }\\n                if(root.right!=null) {\\n                    dfs(root.right,sum-root.val,res,path);\\n                    path.remove(path.size()-1);\\n                }\\n                \\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> path = new ArrayList<>();\\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            int SUM = 0;\\n            TreeNode cur = root;\\n            TreeNode pre = null;\\n            while(cur!=null || !stack.isEmpty()){\\n                while(cur!=null){\\n                    stack.push(cur);\\n                    path.add(cur.val);\\n                    SUM+=cur.val;\\n                    cur=cur.left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2615948,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    // the idea is to use dfs to traverse the tree from all root to leaf paths\\n    // `path` is used to store the current route \\n    // `remainingSum` is used to store thre remaining sum that we need with the initial value `targetSum`.\\n    //  we substract it from the node value when we traverse down the tree\\n    // if we arrive the leaf and the the remaining sum is eqaul to leaf node value\\n    // then we can add `path` to ans\\n    // e.g. path = [5,4,11,2] and remainingSum = targetSum = 22\\n    // traverse node 5, remainingSum = 22 - 5 = 17\\n    // traverse node 4, remainingSum = 17 - 4 = 13\\n    // traverse node 11, remainingSum = 13 - 11 = 2\\n    // traverse node 2, remainingSum = 2 - 2 = 0\\n    // remainingSum is 0 which means the sum of current path is eqaul to targetSum\\n    // so how to find another path?\\n    // we can backtrack here\\n    // we can pop back a node and try another\\n    // e.g. path = [5, 4, 11, 7]\\n    // pop 7 out = [5, 4, 11]\\n    // push 2 = [5, 4, 11, 2]\\n    // ... etc\\n    void dfs(TreeNode* node, vector<int>& path, int remainingSum) {\\n        // if it is nullptr, then return\\n        if (!node) return;\\n        // add the current node val to path\\n        path.push_back(node-> val);\\n        // !node->left && !node->right : check if it is a leaf node\\n        // remainingSum == node->val: check if the remaining sum - node->val == 0\\n        // if both condition is true, then we find one of the paths\\n        if (!node->left && !node->right && remainingSum == node->val) ans.push_back(path);\\n        // traverse left sub tree with updated remaining sum\\n        // we don\\'t need to check if left sub tree is nullptr or not\\n        // as we handle it in the first line of this function\\n        dfs(node-> left, path, remainingSum - node-> val);\\n        // traverse right sub tree with updated remaining sum\\n        // we don\\'t need to check if right sub tree is nullptr or not\\n        // as we handle it in the first line of this function\\n        dfs(node-> right, path, remainingSum - node-> val);\\n        // backtrack \\n        path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        // used to store current route\\n        vector<int> path;\\n        // dfs from the root\\n        dfs(root, path, targetSum);\\n        return ans;  \\n    }\\n};\\n```\\n\\n**Python**\\n\\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    # the idea is to use dfs to traverse the tree from all root to leaf paths\\n    # `path` is used to store the current route \\n    # `remainingSum` is used to store thre remaining sum that we need with the initial value `targetSum`.\\n    #  we substract it from the node value when we traverse down the tree\\n    # if we arrive the leaf and the the remaining sum is eqaul to leaf node value\\n    # then we can add `path` to ans\\n    # e.g. path = [5,4,11,2] and remainingSum = targetSum = 22\\n    # traverse node 5, remainingSum = 22 - 5 = 17\\n    # traverse node 4, remainingSum = 17 - 4 = 13\\n    # traverse node 11, remainingSum = 13 - 11 = 2\\n    # traverse node 2, remainingSum = 2 - 2 = 0\\n    # remainingSum is 0 which means the sum of current path is eqaul to targetSum\\n    # so how to find another path?\\n    # we can backtrack here\\n    # we can pop back a node and try another\\n    # e.g. path = [5, 4, 11, 7]\\n    # pop 7 out = [5, 4, 11]\\n    # push 2 = [5, 4, 11, 2]\\n    # ... etc\\n    def dfs(self, root, path, ans, remainingSum):\\n        # if it is None, then return\\n        if not root:\\n            return\\n        # add the current node val to path\\n        path.append(root.val)\\n        # !node.left && !node.right : check if it is a leaf node\\n        # remainingSum == node.val: check if the remaining sum - node.val == 0\\n        # if both condition is true, then we find one of the paths\\n        if not root.left and not root.right and remainingSum == root.val:\\n            ans.append(list(path))\\n        # traverse left sub tree with updated remaining sum\\n        # we don\\'t need to check if left sub tree is nullptr or not\\n        # as we handle it in the first line of this function\\n        self.dfs(root.left, path, ans, remainingSum - root.val)\\n        # traverse right sub tree with updated remaining sum\\n        # we don\\'t need to check if right sub tree is nullptr or not\\n        # as we handle it in the first line of this function\\n        self.dfs(root.right, path, ans, remainingSum - root.val)\\n        # backtrack \\n        path.pop()\\n    \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        ans = []\\n        self.dfs(root, [], ans, targetSum)\\n        return ans\\n            \\n```\\n\\n**Java**\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n    // the idea is to use dfs to traverse the tree from all root to leaf paths\\n    // `path` is used to store the current route \\n    // `remainingSum` is used to store thre remaining sum that we need with the initial value `targetSum`.\\n    //  we substract it from the node value when we traverse down the tree\\n    // if we arrive the leaf and the the remaining sum is eqaul to leaf node value\\n    // then we can add `path` to ans\\n    // e.g. path = [5,4,11,2] and remainingSum = targetSum = 22\\n    // traverse node 5, remainingSum = 22 - 5 = 17\\n    // traverse node 4, remainingSum = 17 - 4 = 13\\n    // traverse node 11, remainingSum = 13 - 11 = 2\\n    // traverse node 2, remainingSum = 2 - 2 = 0\\n    // remainingSum is 0 which means the sum of current path is eqaul to targetSum\\n    // so how to find another path?\\n    // we can backtrack here\\n    // we can pop back a node and try another\\n    // e.g. path = [5, 4, 11, 7]\\n    // pop 7 out = [5, 4, 11]\\n    // push 2 = [5, 4, 11, 2]\\n    // ... etc\\n    private void dfs(TreeNode node, List<Integer> path, int remainingSum) {\\n        // if it is null, then return\\n        if (node == null) return;\\n        // add the current node val to path\\n        path.add(node.val);\\n        // !node.left && !node.right : check if it is a leaf node\\n        // remainingSum == node.val: check if the remaining sum - node.val == 0\\n        // if both condition is true, then we find one of the paths\\n        if (node.left == null && node.right == null && remainingSum == node.val) ans.add(new ArrayList<>(path));\\n        // traverse left sub tree with updated remaining sum\\n        // we don\\'t need to check if left sub tree is nullptr or not\\n        // as we handle it in the first line of this function\\n        this.dfs(node.left, path, remainingSum - node.val);\\n        // traverse right sub tree with updated remaining sum\\n        // we don\\'t need to check if right sub tree is nullptr or not\\n        // as we handle it in the first line of this function\\n        this.dfs(node.right, path, remainingSum - node.val);\\n        // backtrack \\n        path.remove(path.size() - 1);\\n    }\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<Integer> path = new ArrayList<Integer>();\\n        dfs(root, path, targetSum);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    // the idea is to use dfs to traverse the tree from all root to leaf paths\\n    // `path` is used to store the current route \\n    // `remainingSum` is used to store thre remaining sum that we need with the initial value `targetSum`.\\n    //  we substract it from the node value when we traverse down the tree\\n    // if we arrive the leaf and the the remaining sum is eqaul to leaf node value\\n    // then we can add `path` to ans\\n    // e.g. path = [5,4,11,2] and remainingSum = targetSum = 22\\n    // traverse node 5, remainingSum = 22 - 5 = 17\\n    // traverse node 4, remainingSum = 17 - 4 = 13\\n    // traverse node 11, remainingSum = 13 - 11 = 2\\n    // traverse node 2, remainingSum = 2 - 2 = 0\\n    // remainingSum is 0 which means the sum of current path is eqaul to targetSum\\n    // so how to find another path?\\n    // we can backtrack here\\n    // we can pop back a node and try another\\n    // e.g. path = [5, 4, 11, 7]\\n    // pop 7 out = [5, 4, 11]\\n    // push 2 = [5, 4, 11, 2]\\n    // ... etc\\n    void dfs(TreeNode* node, vector<int>& path, int remainingSum) {\\n        // if it is nullptr, then return\\n        if (!node) return;\\n        // add the current node val to path\\n        path.push_back(node-> val);\\n        // !node->left && !node->right : check if it is a leaf node\\n        // remainingSum == node->val: check if the remaining sum - node->val == 0\\n        // if both condition is true, then we find one of the paths\\n        if (!node->left && !node->right && remainingSum == node->val) ans.push_back(path);\\n        // traverse left sub tree with updated remaining sum\\n        // we don\\'t need to check if left sub tree is nullptr or not\\n        // as we handle it in the first line of this function\\n        dfs(node-> left, path, remainingSum - node-> val);\\n        // traverse right sub tree with updated remaining sum\\n        // we don\\'t need to check if right sub tree is nullptr or not\\n        // as we handle it in the first line of this function\\n        dfs(node-> right, path, remainingSum - node-> val);\\n        // backtrack \\n        path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        // used to store current route\\n        vector<int> path;\\n        // dfs from the root\\n        dfs(root, path, targetSum);\\n        return ans;  \\n    }\\n};\\n```\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    # the idea is to use dfs to traverse the tree from all root to leaf paths\\n    # `path` is used to store the current route \\n    # `remainingSum` is used to store thre remaining sum that we need with the initial value `targetSum`.\\n    #  we substract it from the node value when we traverse down the tree\\n    # if we arrive the leaf and the the remaining sum is eqaul to leaf node value\\n    # then we can add `path` to ans\\n    # e.g. path = [5,4,11,2] and remainingSum = targetSum = 22\\n    # traverse node 5, remainingSum = 22 - 5 = 17\\n    # traverse node 4, remainingSum = 17 - 4 = 13\\n    # traverse node 11, remainingSum = 13 - 11 = 2\\n    # traverse node 2, remainingSum = 2 - 2 = 0\\n    # remainingSum is 0 which means the sum of current path is eqaul to targetSum\\n    # so how to find another path?\\n    # we can backtrack here\\n    # we can pop back a node and try another\\n    # e.g. path = [5, 4, 11, 7]\\n    # pop 7 out = [5, 4, 11]\\n    # push 2 = [5, 4, 11, 2]\\n    # ... etc\\n    def dfs(self, root, path, ans, remainingSum):\\n        # if it is None, then return\\n        if not root:\\n            return\\n        # add the current node val to path\\n        path.append(root.val)\\n        # !node.left && !node.right : check if it is a leaf node\\n        # remainingSum == node.val: check if the remaining sum - node.val == 0\\n        # if both condition is true, then we find one of the paths\\n        if not root.left and not root.right and remainingSum == root.val:\\n            ans.append(list(path))\\n        # traverse left sub tree with updated remaining sum\\n        # we don\\'t need to check if left sub tree is nullptr or not\\n        # as we handle it in the first line of this function\\n        self.dfs(root.left, path, ans, remainingSum - root.val)\\n        # traverse right sub tree with updated remaining sum\\n        # we don\\'t need to check if right sub tree is nullptr or not\\n        # as we handle it in the first line of this function\\n        self.dfs(root.right, path, ans, remainingSum - root.val)\\n        # backtrack \\n        path.pop()\\n    \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        ans = []\\n        self.dfs(root, [], ans, targetSum)\\n        return ans\\n            \\n```\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n    // the idea is to use dfs to traverse the tree from all root to leaf paths\\n    // `path` is used to store the current route \\n    // `remainingSum` is used to store thre remaining sum that we need with the initial value `targetSum`.\\n    //  we substract it from the node value when we traverse down the tree\\n    // if we arrive the leaf and the the remaining sum is eqaul to leaf node value\\n    // then we can add `path` to ans\\n    // e.g. path = [5,4,11,2] and remainingSum = targetSum = 22\\n    // traverse node 5, remainingSum = 22 - 5 = 17\\n    // traverse node 4, remainingSum = 17 - 4 = 13\\n    // traverse node 11, remainingSum = 13 - 11 = 2\\n    // traverse node 2, remainingSum = 2 - 2 = 0\\n    // remainingSum is 0 which means the sum of current path is eqaul to targetSum\\n    // so how to find another path?\\n    // we can backtrack here\\n    // we can pop back a node and try another\\n    // e.g. path = [5, 4, 11, 7]\\n    // pop 7 out = [5, 4, 11]\\n    // push 2 = [5, 4, 11, 2]\\n    // ... etc\\n    private void dfs(TreeNode node, List<Integer> path, int remainingSum) {\\n        // if it is null, then return\\n        if (node == null) return;\\n        // add the current node val to path\\n        path.add(node.val);\\n        // !node.left && !node.right : check if it is a leaf node\\n        // remainingSum == node.val: check if the remaining sum - node.val == 0\\n        // if both condition is true, then we find one of the paths\\n        if (node.left == null && node.right == null && remainingSum == node.val) ans.add(new ArrayList<>(path));\\n        // traverse left sub tree with updated remaining sum\\n        // we don\\'t need to check if left sub tree is nullptr or not\\n        // as we handle it in the first line of this function\\n        this.dfs(node.left, path, remainingSum - node.val);\\n        // traverse right sub tree with updated remaining sum\\n        // we don\\'t need to check if right sub tree is nullptr or not\\n        // as we handle it in the first line of this function\\n        this.dfs(node.right, path, remainingSum - node.val);\\n        // backtrack \\n        path.remove(path.size() - 1);\\n    }\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<Integer> path = new ArrayList<Integer>();\\n        dfs(root, path, targetSum);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36673,
                "title": "simple-dfs-java-solution",
                "content": "Save intermediate result into stack and save the stack into result array once its sum == required sum.\\n\\n    public class Solution {\\n        private List<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n        \\n        public void pathSumInner(TreeNode root, int sum, Stack<Integer>path) {\\n            path.push(root.val);\\n            if(root.left == null && root.right == null)\\n                if(sum == root.val) resultList.add(new ArrayList<Integer>(path));\\n            if(root.left!=null) pathSumInner(root.left, sum-root.val, path);\\n            if(root.right!=null)pathSumInner(root.right, sum-root.val, path);\\n            path.pop();\\n        }\\n        \\n        public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n            if(root==null) return resultList;\\n            Stack<Integer> path = new Stack<Integer>();\\n            pathSumInner(root, sum, path);\\n            return resultList;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        private List<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n        \\n        public void pathSumInner(TreeNode root, int sum, Stack<Integer>path) {\\n            path.push(root.val);\\n            if(root.left == null && root.right == null)\\n                if(sum == root.val) resultList.add(new ArrayList<Integer>(path));\\n            if(root.left!=null) pathSumInner(root.left, sum-root.val, path);\\n            if(root.right!=null)pathSumInner(root.right, sum-root.val, path);\\n            path.pop();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1382603,
                "title": "path-sum-ii-dfs-bfs-w-explanation-2-approaches",
                "content": "***Solution 1(Preorder Traversal):***\\n```\\n# Observation:\\nRoot To Leaf Path is required in the question:\\nthat is a good point to observe, we can think in terms of Preorder Traversal,\\nbecause in Preorder the flow will be from Root To Leaf.\\n\\n#Algorithm:\\n1) Keep storing the values of nodes while doing the preorder traversal,\\n2) If we are at particular node ,lets say \"x\" then we must have the sum of all the nodes in root to x path,\\n3) We will keep track of current sum also,\\n4) Whenever we reach \"LEAF\" Node , we will check whether the current Sum == targetSum,\\n- if yes then we can push one Path to the answer.\\n\\n#Note:\\nStoring a sum variable to keep track of the path sum,\\nor decrementing the targetSum whenever we leave the treeNode is same,\\nbecause\\nit is biderectional,\\neither we can move from 0 to targetSum\\nor from targetSum to 0,\\nboth are same.\\n```\\n***\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    void getAllPaths(TreeNode *root,int targetSum,vector<int> temp,vector<vector<int>> &ans)\\n    {\\n        if(!root)\\n            return;\\n        if(!root->left and !root->right and targetSum == root->val)\\n        {\\n            temp.push_back(root->val);\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(root->val);\\n        getAllPaths(root->left,targetSum-root->val,temp,ans);\\n        getAllPaths(root->right,targetSum-root->val,temp,ans);\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) \\n    {\\n        vector<vector<int>> ans;\\n        getAllPaths(root,targetSum,{},ans);\\n        return ans;\\n    }\\n};\\n```\\n***\\n***Solution 2:(BFS):***\\n```\\nIn BFS we traverse level by level,\\nso, for a particular node at any level,\\nwe must have to store,\\n1) Sum (From Root to current node)\\n2) Path (We have to store the Path which will contain all the nodes from Root to current node).\\n\\nAt each step whenever we are popping out the nodes from queue,\\nwe need to compare the currentSum with the TargetSum,\\nif CurrentSum == TargetSum,\\nthen we can store the currentPath to our answer.\\n```\\n***\\n**C++:**\\n```\\nclass Solution {\\nbool isLeaf(TreeNode *root)\\n{\\n    return !root->left and !root->right;\\n}\\n\\nvector<vector<int>> getAllPaths(TreeNode *root,int targetSum)\\n{\\n// Queue stores {TreeNode , Sum From Root To TreeNode, Path containing Nodes From Root To Current Node}\\n    queue<pair<TreeNode*,pair<int,vector<int> > > > q;\\n    vector<vector<int>> res;\\n    if(!root)\\n        return res;\\n// Start with Root Node with currentSum == root->val and Path = {root->val}\\n    q.push({root,{root->val,{root->val}}});\\n    while(!q.empty())\\n    {\\n        auto front = q.front();\\n        q.pop();\\n        TreeNode *treeNode = front.first;\\n        int currentSum = front.second.first;\\n        vector<int> currentPath = front.second.second;\\n//         Check if we reach the leaf node with currentSum equals to TargetSum\\n        if(isLeaf(treeNode) and currentSum == targetSum)\\n        {\\n//          Push one Path into the final Answer\\n            res.push_back(currentPath);\\n        }\\n        if(treeNode->left)\\n        {\\n            vector<int> leftPath = currentPath;\\n            leftPath.push_back(treeNode->left->val);\\n//          Store the left child with new sum and path,\\n            q.push({treeNode->left,{currentSum + treeNode->left->val,leftPath}});\\n        }\\n        if(treeNode->right)\\n        {\\n            vector<int> rightPath = currentPath;\\n            rightPath.push_back(treeNode->right->val);\\n//          Store the right child with new sum and path,\\n            q.push({treeNode->right,{currentSum + treeNode->right->val,rightPath}});\\n        }\\n    }\\n    return res;\\n}\\n\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        return getAllPaths(root,targetSum);\\n    }\\n};\\n```\\n***\\n**If you found the post useful, do consider it for upvotes, :)**\\n***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n# Observation:\\nRoot To Leaf Path is required in the question:\\nthat is a good point to observe, we can think in terms of Preorder Traversal,\\nbecause in Preorder the flow will be from Root To Leaf.\\n\\n#Algorithm:\\n1) Keep storing the values of nodes while doing the preorder traversal,\\n2) If we are at particular node ,lets say \"x\" then we must have the sum of all the nodes in root to x path,\\n3) We will keep track of current sum also,\\n4) Whenever we reach \"LEAF\" Node , we will check whether the current Sum == targetSum,\\n- if yes then we can push one Path to the answer.\\n\\n#Note:\\nStoring a sum variable to keep track of the path sum,\\nor decrementing the targetSum whenever we leave the treeNode is same,\\nbecause\\nit is biderectional,\\neither we can move from 0 to targetSum\\nor from targetSum to 0,\\nboth are same.\\n```\n```\\nclass Solution {\\npublic:\\n    void getAllPaths(TreeNode *root,int targetSum,vector<int> temp,vector<vector<int>> &ans)\\n    {\\n        if(!root)\\n            return;\\n        if(!root->left and !root->right and targetSum == root->val)\\n        {\\n            temp.push_back(root->val);\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(root->val);\\n        getAllPaths(root->left,targetSum-root->val,temp,ans);\\n        getAllPaths(root->right,targetSum-root->val,temp,ans);\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) \\n    {\\n        vector<vector<int>> ans;\\n        getAllPaths(root,targetSum,{},ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nIn BFS we traverse level by level,\\nso, for a particular node at any level,\\nwe must have to store,\\n1) Sum (From Root to current node)\\n2) Path (We have to store the Path which will contain all the nodes from Root to current node).\\n\\nAt each step whenever we are popping out the nodes from queue,\\nwe need to compare the currentSum with the TargetSum,\\nif CurrentSum == TargetSum,\\nthen we can store the currentPath to our answer.\\n```\n```\\nclass Solution {\\nbool isLeaf(TreeNode *root)\\n{\\n    return !root->left and !root->right;\\n}\\n\\nvector<vector<int>> getAllPaths(TreeNode *root,int targetSum)\\n{\\n// Queue stores {TreeNode , Sum From Root To TreeNode, Path containing Nodes From Root To Current Node}\\n    queue<pair<TreeNode*,pair<int,vector<int> > > > q;\\n    vector<vector<int>> res;\\n    if(!root)\\n        return res;\\n// Start with Root Node with currentSum == root->val and Path = {root->val}\\n    q.push({root,{root->val,{root->val}}});\\n    while(!q.empty())\\n    {\\n        auto front = q.front();\\n        q.pop();\\n        TreeNode *treeNode = front.first;\\n        int currentSum = front.second.first;\\n        vector<int> currentPath = front.second.second;\\n//         Check if we reach the leaf node with currentSum equals to TargetSum\\n        if(isLeaf(treeNode) and currentSum == targetSum)\\n        {\\n//          Push one Path into the final Answer\\n            res.push_back(currentPath);\\n        }\\n        if(treeNode->left)\\n        {\\n            vector<int> leftPath = currentPath;\\n            leftPath.push_back(treeNode->left->val);\\n//          Store the left child with new sum and path,\\n            q.push({treeNode->left,{currentSum + treeNode->left->val,leftPath}});\\n        }\\n        if(treeNode->right)\\n        {\\n            vector<int> rightPath = currentPath;\\n            rightPath.push_back(treeNode->right->val);\\n//          Store the right child with new sum and path,\\n            q.push({treeNode->right,{currentSum + treeNode->right->val,rightPath}});\\n        }\\n    }\\n    return res;\\n}\\n\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        return getAllPaths(root,targetSum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616083,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=2Feu7nK3ysM\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\nclass Solution {\\n\\npublic:\\n    vector<vector<int>> answer;\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        dfs(root, targetSum, path);// using dfs to traverse on each node\\n        return answer;\\n    }\\n    void dfs(TreeNode* root, int newtarget, vector<int>& path) {\\n        if (!root) return; // if current root is null return\\n        path.push_back(root->val);\\n        newtarget -= root->val; // new target will be the privious target- the value of that node\\n        if (!root->left && !root->right) { // check whether it is a leaf node or not\\n            if (newtarget == 0) // if we get valid path, pushback in our answer\\n                answer.push_back(path);\\n        } else {\\n            dfs(root->left, newtarget, path);\\n            dfs(root->right, newtarget, path);\\n        }\\n        path.pop_back(); // for the backtracking\\n    }\\n};\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    vector<vector<int>> answer;\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        dfs(root, targetSum, path);// using dfs to traverse on each node\\n        return answer;\\n    }\\n    void dfs(TreeNode* root, int newtarget, vector<int>& path) {\\n        if (!root) return; // if current root is null return\\n        path.push_back(root->val);\\n        newtarget -= root->val; // new target will be the privious target- the value of that node\\n        if (!root->left && !root->right) { // check whether it is a leaf node or not\\n            if (newtarget == 0) // if we get valid path, pushback in our answer\\n                answer.push_back(path);\\n        } else {\\n            dfs(root->left, newtarget, path);\\n            dfs(root->right, newtarget, path);\\n        }\\n        path.pop_back(); // for the backtracking\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616699,
                "title": "java-detailed-explanation-100-faster-code-easy-solution",
                "content": "\\t\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<Integer> currentPath = new ArrayList();\\n        List<List<Integer>> allPaths = new ArrayList();\\n        findPathsRecursive(root,targetSum,currentPath,allPaths);\\n        return allPaths;\\n    }\\n    private static void findPathsRecursive(TreeNode currentNode, int sum, List<Integer> currentPath,List<List<Integer>> allPaths){\\n         if(currentNode==null)return;\\n         // add the current node to the path\\n         currentPath.add(currentNode.val);\\n         // if the current node is a leaf and its value is equal to sum, save the current path\\n         if(currentNode.val==sum && currentNode.left==null && currentNode.right==null)\\n             allPaths.add(new ArrayList<Integer>(currentPath));\\n         else{\\n             // traverse the left sub-tree\\n             findPathsRecursive(currentNode.left,sum-currentNode.val,currentPath,allPaths);\\n             // traverse the right sub-tree\\n             findPathsRecursive(currentNode.right,sum-currentNode.val,currentPath,allPaths);\\n         }\\n         // remove the current node from the path to backtrack, \\n         // we need to remove the current node while we are going up the recursive call stack.\\n         currentPath.remove(currentPath.size()-1);\\n      }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<Integer> currentPath = new ArrayList();\\n        List<List<Integer>> allPaths = new ArrayList();\\n        findPathsRecursive(root,targetSum,currentPath,allPaths);\\n        return allPaths;\\n    }\\n    private static void findPathsRecursive(TreeNode currentNode, int sum, List<Integer> currentPath,List<List<Integer>> allPaths){\\n         if(currentNode==null)return;\\n         // add the current node to the path\\n         currentPath.add(currentNode.val);\\n         // if the current node is a leaf and its value is equal to sum, save the current path\\n         if(currentNode.val==sum && currentNode.left==null && currentNode.right==null)\\n             allPaths.add(new ArrayList<Integer>(currentPath));\\n         else{\\n             // traverse the left sub-tree\\n             findPathsRecursive(currentNode.left,sum-currentNode.val,currentPath,allPaths);\\n             // traverse the right sub-tree\\n             findPathsRecursive(currentNode.right,sum-currentNode.val,currentPath,allPaths);\\n         }\\n         // remove the current node from the path to backtrack, \\n         // we need to remove the current node while we are going up the recursive call stack.\\n         currentPath.remove(currentPath.size()-1);\\n      }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382469,
                "title": "python-dfs-solution-with-complexity-explained",
                "content": "This is classical dfs problem: let use `dfs(node, sm)` function, which have parameters:\\n\\n1. `node` is current node we are in now.\\n2. `sm` is value we need to get.\\n3. output are all possible paths we can get, here I keep them inverted, because it is faster to add to the end of list.\\n\\nWhen we traverse our tree, we need to do the following:\\n\\n1. Check if we go outside tree, in this case we return `[]`.\\n2. Check if we reached leaf, and value in this leaf is equal to `node.val`, in this case return `[[node.val]]`.\\n3. Run function recursively for left and right children. Not that some of them can be empty, in thic case answer for this child will be `[]`.\\n4. Finally, return list of lists for both left and right children.\\n\\n#### Complexity\\nComplexity of pure dfs part is just `O(n)`, what is more interesting is complexity of this dfs where we need to keep lists. If we consider balanced tree, than we can have `O(n)` solutions, which of which have `O(log n)` length, so time and space complexity will be `O(n log n)`. However it can go upto `O(n^2)`, see the following example:\\n\\nLet us have tree with `n` nodes, such that first it is single line with length `n/2`:   `a1 -> a2 -> ... a_(n//2) -> (full tree on n/2 nodes)`. All values in all nodes equal to `1`. Then there will be `n//4` leafs and path to each leaf has `n//2+log(n//2) = O(n)` length, so all paths will take `n//4*(n//2 + log(n//2)) = O(n^2)` time and space complexity. See image for more details.\\n\\n![image](https://assets.leetcode.com/users/images/c6654cf6-03c5-42c3-b338-380dff016891_1628075309.8059347.png)\\n\\n\\n#### Code\\n```python\\nclass Solution:\\n    def pathSum(self, root, sm):\\n        def dfs(node, sm):\\n            if not node: return []\\n            if not node.left and not node.right and sm == node.val:\\n                return [[node.val]]\\n           \\n            lft = dfs(node.left, sm - node.val)\\n            rgh = dfs(node.right, sm - node.val)\\n            return [cand + [node.val] for cand in lft + rgh]\\n            \\n        return [s[::-1] for s in dfs(root, sm)]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def pathSum(self, root, sm):\\n        def dfs(node, sm):\\n            if not node: return []\\n            if not node.left and not node.right and sm == node.val:\\n                return [[node.val]]\\n           \\n            lft = dfs(node.left, sm - node.val)\\n            rgh = dfs(node.right, sm - node.val)\\n            return [cand + [node.val] for cand in lft + rgh]\\n            \\n        return [s[::-1] for s in dfs(root, sm)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616034,
                "title": "c-dfs-related-problems",
                "content": "![image](https://assets.leetcode.com/users/images/22476ea5-e00a-4b04-a5dd-9fa680854fd7_1663987851.0947344.png)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> ans;\\n    vector<int> path;\\n    \\n    void dfs(TreeNode* root, int current, int target) {\\n        if(!root) {\\n            return;\\n        }\\n        \\n        current += root->val;\\n        path.push_back(root->val);\\n        \\n\\t\\t// When we reach at leaf node, we have to check if current sum is equal to target\\n        if(current == target && !root->left && !root->right) {\\n            ans.push_back(path);\\n        }    \\n        \\n        dfs(root->left, current, target);\\n        dfs(root->right, current, target);\\n        \\n        path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        dfs(root, 0, targetSum);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Edit 1**\\n**Alternative way**\\n<details>\\n<summary>View Code</summary>\\n\\n```cpp\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> ans;\\n    vector<int> path;\\n    \\n    void dfs(TreeNode* root, int target) {\\n        if(!root) {\\n            return;\\n        }\\n        \\n        target -= root->val;\\n        path.push_back(root->val);\\n        \\n        if(target == 0 && !root->left && !root->right) {\\n            ans.push_back(path);\\n        }    \\n        \\n        dfs(root->left, target);\\n        dfs(root->right, target);\\n        \\n        path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        dfs(root, targetSum);\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>\\n\\n**Edit 2**\\n**Passing path vector in function with reference**\\n\\n<details>\\n<summary>View Code</summary>\\n\\n```cpp\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> ans;\\n    \\n    void dfs(TreeNode* root, int current, vector<int>& path, int target) {\\n        if(!root) {\\n            return;\\n        }\\n        \\n        current += root->val;\\n        path.push_back(root->val);\\n        \\n        if(current == target && !root->left && !root->right) {\\n            ans.push_back(path);\\n        }    \\n        \\n        dfs(root->left, current, path, target);\\n        dfs(root->right, current, path, target);\\n        \\n        path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        dfs(root, 0, path, targetSum);\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>\\n\\n**Edit 3**\\nCan we do it without pop_back()? - Yes, we can.\\nDisclaimer : **Higher Time and Space complexity** Credit to @heder for pointing it out.\\n<details>\\n<summary>View Code</summary>\\n\\n```cpp\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> ans;\\n    \\n    void dfs(TreeNode* root, int current, vector<int> path, int target) {\\n        if(!root) {\\n            return;\\n        }\\n        \\n        current += root->val;\\n        path.push_back(root->val);\\n        \\n        if(current == target && !root->left && !root->right) {\\n            ans.push_back(path);\\n        }    \\n        \\n        dfs(root->left, current, path, target);\\n        dfs(root->right, current, path, target);\\n        \\n        // path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        dfs(root, 0, path, targetSum);\\n        return ans;\\n    }\\n};\\n```\\n</detials>\\n\\n**Related Problems**\\n[1. Sum Root to Leaf Numbers ](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\n[2. Smallest String Starting From Leaf ](https://leetcode.com/problems/smallest-string-starting-from-leaf/)\\n[3. Sum of Left Leaves ](https://leetcode.com/problems/sum-of-left-leaves/)",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> ans;\\n    vector<int> path;\\n    \\n    void dfs(TreeNode* root, int current, int target) {\\n        if(!root) {\\n            return;\\n        }\\n        \\n        current += root->val;\\n        path.push_back(root->val);\\n        \\n\\t\\t// When we reach at leaf node, we have to check if current sum is equal to target\\n        if(current == target && !root->left && !root->right) {\\n            ans.push_back(path);\\n        }    \\n        \\n        dfs(root->left, current, target);\\n        dfs(root->right, current, target);\\n        \\n        path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        dfs(root, 0, targetSum);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> ans;\\n    vector<int> path;\\n    \\n    void dfs(TreeNode* root, int target) {\\n        if(!root) {\\n            return;\\n        }\\n        \\n        target -= root->val;\\n        path.push_back(root->val);\\n        \\n        if(target == 0 && !root->left && !root->right) {\\n            ans.push_back(path);\\n        }    \\n        \\n        dfs(root->left, target);\\n        dfs(root->right, target);\\n        \\n        path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        dfs(root, targetSum);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> ans;\\n    \\n    void dfs(TreeNode* root, int current, vector<int>& path, int target) {\\n        if(!root) {\\n            return;\\n        }\\n        \\n        current += root->val;\\n        path.push_back(root->val);\\n        \\n        if(current == target && !root->left && !root->right) {\\n            ans.push_back(path);\\n        }    \\n        \\n        dfs(root->left, current, path, target);\\n        dfs(root->right, current, path, target);\\n        \\n        path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        dfs(root, 0, path, targetSum);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> ans;\\n    \\n    void dfs(TreeNode* root, int current, vector<int> path, int target) {\\n        if(!root) {\\n            return;\\n        }\\n        \\n        current += root->val;\\n        path.push_back(root->val);\\n        \\n        if(current == target && !root->left && !root->right) {\\n            ans.push_back(path);\\n        }    \\n        \\n        dfs(root->left, current, path, target);\\n        dfs(root->right, current, path, target);\\n        \\n        // path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        dfs(root, 0, path, targetSum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36681,
                "title": "another-javascript-solution",
                "content": "The idea is to perform a preorder traversal from the root node, once we found a leaf node and that leaf node's value is equal to the current sum value, then we found a solution, put it into the final result array.\\n\\nThe tricky part is to backtrack, think of it this way, let's say the sum is 8, and we are at node 4, see the tree below:\\n```\\n       1\\n      / \\\\\\n     2   3\\n    / \\\\\\n   4   5\\n```\\nthe current solution array is [1, 2, 4], as 4 is the leaf node, we are done with this path, since it's preorder, the next node we need to scan is 5, and the solution list should look like [1, 2, 5] which represents the correct path, that's why we need to remove 4 from the solution array, otherwise, the solution array will be [1, 2, 4, 5].\\n\\nBelow is the JavaScript solution:\\n```\\n/**\\n * @param {TreeNode} root\\n * @param {number} sum\\n * @return {number[][]}\\n */\\nvar pathSum = function(root, sum) {\\n    return helper(root, sum, [], []);\\n};\\n\\n/**\\n * A helper function that does the search\\n * @param {TreeNode} root\\n * @param {number} sum\\n * @param {number[]} solution - one path from root to a leaf\\n * @param {number[]} result - the final result\\n * @return {number[]} result\\n */\\nfunction helper(root, sum, solution, result) {\\n    if (!root) { // sanity check\\n        return result;\\n    }\\n\\n    solution.push(root.val); // add current node's value to the solution\\n\\n    if (!root.left && !root.right && root.val === sum) {\\n        result.push(solution.slice()); // found a solution\\n    }\\n\\n    helper(root.left, sum - root.val, solution, result); // try left subtree\\n    helper(root.right, sum - root.val, solution, result); // try right subtree\\n\\n    solution.pop(); // backtracking\\n\\n    return result;\\n}\\n```\\n\\nTime complexity: `O(n)`",
                "solutionTags": [],
                "code": "```\\n       1\\n      / \\\\\\n     2   3\\n    / \\\\\\n   4   5\\n```\n```\\n/**\\n * @param {TreeNode} root\\n * @param {number} sum\\n * @return {number[][]}\\n */\\nvar pathSum = function(root, sum) {\\n    return helper(root, sum, [], []);\\n};\\n\\n/**\\n * A helper function that does the search\\n * @param {TreeNode} root\\n * @param {number} sum\\n * @param {number[]} solution - one path from root to a leaf\\n * @param {number[]} result - the final result\\n * @return {number[]} result\\n */\\nfunction helper(root, sum, solution, result) {\\n    if (!root) { // sanity check\\n        return result;\\n    }\\n\\n    solution.push(root.val); // add current node's value to the solution\\n\\n    if (!root.left && !root.right && root.val === sum) {\\n        result.push(solution.slice()); // found a solution\\n    }\\n\\n    helper(root.left, sum - root.val, solution, result); // try left subtree\\n    helper(root.right, sum - root.val, solution, result); // try right subtree\\n\\n    solution.pop(); // backtracking\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36802,
                "title": "short-python-solution",
                "content": "    class Solution:\\n \\n    def pathSum(self, root, sum):\\n        if not root: return []\\n        if root.left == None and root.right == None:\\n            if sum == root.val: \\n                return [[root.val]]\\n            else: \\n                return []\\n        a = self.pathSum(root.left, sum - root.val) + \\\\\\n            self.pathSum(root.right, sum - root.val)\\n        return [[root.val] + i for i in a]",
                "solutionTags": [],
                "code": "    class Solution:\\n \\n    def pathSum(self, root, sum):\\n        if not root: return []\\n        if root.left == None and root.right == None:\\n            if sum == root.val: \\n                return [[root.val]]\\n            else: \\n                return []\\n        a = self.pathSum(root.left, sum - root.val) + \\\\\\n            self.pathSum(root.right, sum - root.val)\\n        return [[root.val] + i for i in a]",
                "codeTag": "Java"
            },
            {
                "id": 2616589,
                "title": "python-template-for-binary-tree-path-problems-easiest-solution",
                "content": "Things I learnt which might benefit everyone:\\n* In questions like these where we have to find the paths from Root-to-Leaf, we can use a template and just change a line inside our if-block in order to accomodate for the conditions asked in the question ie. `sum(path)==targetSum`\\n\\n`DFS (recursive)`\\n\\n\\n```python\\ndef binaryTreePaths(self, root):\\n        result = []\\n        def dfs(root, path):\\n            nonlocal result\\n            if not root:\\n                return []\\n            path += [root.val]           \\n            if not root.left and not root.right:\\n                result.append(path.copy())\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()\\n            return result    \\n        return dfs(root, [])\\n ```\\n\\n \\n\\n`DFS (iterative)`\\n\\n```python\\ndef binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        result, stack = [], [[root, \"\"]]\\n        while stack:\\n            node, string = stack.pop()\\n            if not node.left and not node.right:\\n                result.append([string+ str(node.val)].copy())\\n            if node.right:\\n                stack.append([node.right, string+str(node.val) + \"->\"])\\n            if node.left:\\n                stack.append([node.left, string+str(node.val) + \"->\"])\\n        return result\\n ```\\n\\n`BFS`\\n\\n```python\\ndef binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        result, queue = [], deque([[root, []]])\\n        while queue:\\n            node, string = queue.popleft()\\n            if not node.left and not node.right:\\n                result.append([string+ [node.val]])\\n            if node.left:\\n                queue.append([node.left, string+ [node.val]])\\n            if node.right:\\n                queue.append([node.right, string+ [node.val]])\\n        return result\\n```\\n\\n---\\n\\nNow in our question we are required to find the path ie. equal to the targetSum provided, just be adding a line we can get our result:)\\n\\n```python\\nclass Solution:\\n    def pathSum(self, root, targetSum):\\n        result = []\\n        def dfs(root, path):\\n            nonlocal result\\n            if not root:\\n                return []\\n            path += [root.val]           \\n            if not root.left and not root.right:\\n\\t\\t\\t    # Adding the condition needed in the question\\n                if sum(path)==targetSum:\\n                    result.append(path.copy())\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()\\n            return result    \\n        return dfs(root, [])\\n```\\n\\nYou can also find some similar list of questions:\\n* https://leetcode.com/problems/binary-tree-paths/\\n* https://leetcode.com/problems/path-sum/\\n\\nI will update the list above with more questions along the way..!",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```python\\ndef binaryTreePaths(self, root):\\n        result = []\\n        def dfs(root, path):\\n            nonlocal result\\n            if not root:\\n                return []\\n            path += [root.val]           \\n            if not root.left and not root.right:\\n                result.append(path.copy())\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()\\n            return result    \\n        return dfs(root, [])\\n ```\n```python\\ndef binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        result, stack = [], [[root, \"\"]]\\n        while stack:\\n            node, string = stack.pop()\\n            if not node.left and not node.right:\\n                result.append([string+ str(node.val)].copy())\\n            if node.right:\\n                stack.append([node.right, string+str(node.val) + \"->\"])\\n            if node.left:\\n                stack.append([node.left, string+str(node.val) + \"->\"])\\n        return result\\n ```\n```python\\ndef binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        result, queue = [], deque([[root, []]])\\n        while queue:\\n            node, string = queue.popleft()\\n            if not node.left and not node.right:\\n                result.append([string+ [node.val]])\\n            if node.left:\\n                queue.append([node.left, string+ [node.val]])\\n            if node.right:\\n                queue.append([node.right, string+ [node.val]])\\n        return result\\n```\n```python\\nclass Solution:\\n    def pathSum(self, root, targetSum):\\n        result = []\\n        def dfs(root, path):\\n            nonlocal result\\n            if not root:\\n                return []\\n            path += [root.val]           \\n            if not root.left and not root.right:\\n\\t\\t\\t    # Adding the condition needed in the question\\n                if sum(path)==targetSum:\\n                    result.append(path.copy())\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()\\n            return result    \\n        return dfs(root, [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084920,
                "title": "tried-my-best-to-explain-it-in-a-humourous-manner-c-dfs-preorder",
                "content": "**Approach:\\n**\\n1.  preorder traversal + mainting a currSum var for each call + pushed node->val in temp vector(for each call) travelled so far, irrespective of it\\'s contribution towards TargetSum.\\n2.  if at any moment currSum reaches targetSum then check it\\'s leaf or not, if leaf then only push current vector in final ans\\n3.  if node is leaf and currSum != targetSum just return\\n4.  check for existence of left as well as right node and make calls accordingly. \\n  \\n```\\nclass Solution {\\nprivate:\\n    void pathSum_helper(TreeNode* root, int target, int curr_Sum, vector<int> temp, vector< vector<int> >& ans){\\n\\t\\t//andha dhun value dalo  bhai har recursion calls par\\n        temp.push_back(root->val);\\n\\t\\t// ye kami bhi poori krdi taaki tumhari mehnat ka fal khatta na reh jaye\\n        curr_Sum += root->val;\\n\\t\\t\\n\\t\\t//abh tak toh smjh hi gye hoge saaara khel target ka hi toh hai\\n\\t\\t// samay(leaf node) se pehle na kisi ko faaal(targetSUm) mila hai aur mil bhi gya to koi kam ka nhi hai \\n        if(curr_Sum == target && (!root->left && !root->right)){\\n\\t\\t // final answer mein temp ko push crow frands \\n            ans.push_back(temp);\\n\\t\\t\\t//tata bye bye \\n\\t\\t\\t//nahi nahi goodbye abhi nahi\\n            return;\\n        }\\n        if(!root->left && !root->right){\\n\\t\\t\\t\\n\\t\\t\\t// TargetSum na ho toh rahenge hum nahi hum nahi na chahiye kuch targetSum se zyada,,, na kam nahi\\n            return;\\n        }\\n\\t\\t// current node ka left right NULL toh nahi hai\\n        if(root->left) pathSum_helper(root->left, target, curr_Sum, temp, ans);\\n        if(root->right) pathSum_helper(root->right, target, curr_Sum, temp, ans);\\n\\t\\t\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        vector<int> temp;\\n        pathSum_helper(root, targetSum, 0, temp, ans);\\n        return ans;\\n    }\\n};\\n```\\n!!!!Hope it helps",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void pathSum_helper(TreeNode* root, int target, int curr_Sum, vector<int> temp, vector< vector<int> >& ans){\\n\\t\\t//andha dhun value dalo  bhai har recursion calls par\\n        temp.push_back(root->val);\\n\\t\\t// ye kami bhi poori krdi taaki tumhari mehnat ka fal khatta na reh jaye\\n        curr_Sum += root->val;\\n\\t\\t\\n\\t\\t//abh tak toh smjh hi gye hoge saaara khel target ka hi toh hai\\n\\t\\t// samay(leaf node) se pehle na kisi ko faaal(targetSUm) mila hai aur mil bhi gya to koi kam ka nhi hai \\n        if(curr_Sum == target && (!root->left && !root->right)){\\n\\t\\t // final answer mein temp ko push crow frands \\n            ans.push_back(temp);\\n\\t\\t\\t//tata bye bye \\n\\t\\t\\t//nahi nahi goodbye abhi nahi\\n            return;\\n        }\\n        if(!root->left && !root->right){\\n\\t\\t\\t\\n\\t\\t\\t// TargetSum na ho toh rahenge hum nahi hum nahi na chahiye kuch targetSum se zyada,,, na kam nahi\\n            return;\\n        }\\n\\t\\t// current node ka left right NULL toh nahi hai\\n        if(root->left) pathSum_helper(root->left, target, curr_Sum, temp, ans);\\n        if(root->right) pathSum_helper(root->right, target, curr_Sum, temp, ans);\\n\\t\\t\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        vector<int> temp;\\n        pathSum_helper(root, targetSum, 0, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36827,
                "title": "python-solution-dfs",
                "content": "    class Solution:\\n    # @param {TreeNode} root\\n    # @param {integer} sum\\n    # @return {integer[][]}\\n    def pathSum(self, root, sum):\\n        ans = []\\n        self.dfs(root, sum, [],ans)\\n        return ans\\n    \\n    def dfs(self, root, sum, tmp, ans):\\n        if not root:\\n            return\\n        \\n        if root.left == None and root.right == None and sum == root.val:\\n            ans.append(tmp+[root.val])\\n            return\\n        \\n        self.dfs(root.left, sum-root.val, tmp+[root.val], ans)\\n        self.dfs(root.right, sum-root.val, tmp+[root.val], ans)",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 36899,
                "title": "18-ms-c-recursive-solution",
                "content": "    vector<vector<int> > pathSum(TreeNode *root, int sum) {\\n            vector<vector<int> > result;\\n            vector<int> cur_path(0);\\n            pathSumRec(root, sum, result, cur_path);\\n            return result;\\n        }\\n        \\n        // pass the current path as a reference and remember to pop out the last added element\\n        // this improves the performance by 5 times\\n        void pathSumRec(TreeNode* root, int sum, vector<vector<int> >& result, vector<int>& cur_path) {\\n            if (root == NULL) {\\n                return;\\n            }\\n            \\n            if (root->val == sum && root->left == NULL && root->right == NULL) {\\n                cur_path.push_back(root->val);\\n                result.push_back(cur_path);\\n                cur_path.pop_back();\\n                return;\\n            }\\n            \\n            int sum_left = sum - root->val;\\n            cur_path.push_back(root->val);\\n            pathSumRec(root->left, sum_left, result, cur_path);\\n            //cur_path.pop_back();\\n            pathSumRec(root->right, sum_left, result, cur_path);\\n            cur_path.pop_back();\\n        }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "    vector<vector<int> > pathSum(TreeNode *root, int sum) {\\n            vector<vector<int> > result;\\n            vector<int> cur_path(0);\\n            pathSumRec(root, sum, result, cur_path);\\n            return result;\\n        }\\n        \\n        // pass the current path as a reference and remember to pop out the last added element\\n        // this improves the performance by 5 times\\n        void pathSumRec(TreeNode* root, int sum, vector<vector<int> >& result, vector<int>& cur_path) {\\n            if (root == NULL) {\\n                return;\\n            }\\n            \\n            if (root->val == sum && root->left == NULL && root->right == NULL) {\\n                cur_path.push_back(root->val);\\n                result.push_back(cur_path);\\n                cur_path.pop_back();\\n                return;\\n            }\\n            \\n            int sum_left = sum - root->val;\\n            cur_path.push_back(root->val);\\n            pathSumRec(root->left, sum_left, result, cur_path);\\n            //cur_path.pop_back();\\n            pathSumRec(root->right, sum_left, result, cur_path);\\n            cur_path.pop_back();\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 456959,
                "title": "javascript",
                "content": "```js\\nvar pathSum = function(root, sum, res = [], path = []){\\n    if(root){\\n        path.push(root.val);\\n        if(!root.left && !root.right && sum - root.val === 0) res.push([...path]);\\n        pathSum(root.left, sum - root.val, res, path);\\n        pathSum(root.right, sum - root.val, res, path);\\n        path.pop();\\n    }\\n    return res;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar pathSum = function(root, sum, res = [], path = []){\\n    if(root){\\n        path.push(root.val);\\n        if(!root.left && !root.right && sum - root.val === 0) res.push([...path]);\\n        pathSum(root.left, sum - root.val, res, path);\\n        pathSum(root.right, sum - root.val, res, path);\\n        path.pop();\\n    }\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 36824,
                "title": "my-simple-java-solution",
                "content": "    private List<List<Integer>> result = new ArrayList<List<Integer>>();\\n    \\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        helper(new ArrayList<Integer>(), root, sum);\\n        return result;\\n    }\\n    \\n    private void helper(List<Integer> list, TreeNode root, int sum) {\\n        if (root == null) return;\\n        list.add(root.val);\\n        sum -= root.val;\\n        if (root.left == null && root.right == null) {\\n            if (sum == 0) result.add(list);\\n            return;\\n        }\\n        helper(new ArrayList<Integer>(list), root.left, sum);\\n        helper(new ArrayList<Integer>(list), root.right, sum);\\n    }",
                "solutionTags": [],
                "code": "    private List<List<Integer>> result = new ArrayList<List<Integer>>();\\n    \\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        helper(new ArrayList<Integer>(), root, sum);\\n        return result;\\n    }\\n    \\n    private void helper(List<Integer> list, TreeNode root, int sum) {\\n        if (root == null) return;\\n        list.add(root.val);\\n        sum -= root.val;\\n        if (root.left == null && root.right == null) {\\n            if (sum == 0) result.add(list);\\n            return;\\n        }\\n        helper(new ArrayList<Integer>(list), root.left, sum);\\n        helper(new ArrayList<Integer>(list), root.right, sum);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1383515,
                "title": "hindi-and-english-well-commented-backtracking-solution",
                "content": "So this is my well commented code for Path Sum 2. **Comments in hindi and english both.**\\n\\nUpvote the answer if you like!\\n\\nHappy Coding!\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        \\n        List<Integer> currPath = new ArrayList<>();\\n        \\n        List<List<Integer>> allPaths = new ArrayList<>();\\n        pathSum(root, targetSum, currPath, allPaths);\\n        return allPaths;\\n    }\\n    \\n    public void pathSum(TreeNode root, int targetSum, List<Integer> currPath, List<List<Integer>> allPaths) {\\n        \\n        if(root == null) {\\n            return;\\n        }\\n        /*\\n          1. Agar node leaf node, koi child nahin hai, or targetsum bann gaya to allPath list mein \\n             currentPath list ko add krdia.\\n          2. If statement mein topi utarna(backtrack krna) na bhulna, path add krne ke baad.\\n\\n          1. If node is a leaf node i.e no left and right child and target sum is achieved \\n             add the currentPath into all path\\n          2. Do not forget to backtrack in if statement i.e remove after adding path.\\n        */\\n        if(root.left == null && root.right == null && targetSum - root.val == 0) {\\n            currPath.add(root.val);\\n            allPaths.add(new ArrayList<>(currPath));\\n            currPath.remove(currPath.size() - 1);\\n            return;\\n        }\\n        \\n        //Add the current node in the potential currentPath list.\\n        //jis node pr hain usko consider krenge to usko currentPath list mein add krdia\\n        currPath.add(root.val); //Topi pehnana(Wearing The Cap)\\n        \\n        //Two choices(Left, Right) -> decrement target sum by root\\'s(current node) value.\\n        //Do choices hain left jao and right jao -> targetSum mein se current node ki value minus krdo\\n        pathSum(root.left, targetSum - root.val, currPath, allPaths);\\n        pathSum(root.right, targetSum - root.val, currPath, allPaths);\\n        //Backtracking(Topi Utarna(Pehle jaisi list krna)/Taking of the cup(undo))\\n        currPath.remove(currPath.size() - 1); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        \\n        List<Integer> currPath = new ArrayList<>();\\n        \\n        List<List<Integer>> allPaths = new ArrayList<>();\\n        pathSum(root, targetSum, currPath, allPaths);\\n        return allPaths;\\n    }\\n    \\n    public void pathSum(TreeNode root, int targetSum, List<Integer> currPath, List<List<Integer>> allPaths) {\\n        \\n        if(root == null) {\\n            return;\\n        }\\n        /*\\n          1. Agar node leaf node, koi child nahin hai, or targetsum bann gaya to allPath list mein \\n             currentPath list ko add krdia.\\n          2. If statement mein topi utarna(backtrack krna) na bhulna, path add krne ke baad.\\n\\n          1. If node is a leaf node i.e no left and right child and target sum is achieved \\n             add the currentPath into all path\\n          2. Do not forget to backtrack in if statement i.e remove after adding path.\\n        */\\n        if(root.left == null && root.right == null && targetSum - root.val == 0) {\\n            currPath.add(root.val);\\n            allPaths.add(new ArrayList<>(currPath));\\n            currPath.remove(currPath.size() - 1);\\n            return;\\n        }\\n        \\n        //Add the current node in the potential currentPath list.\\n        //jis node pr hain usko consider krenge to usko currentPath list mein add krdia\\n        currPath.add(root.val); //Topi pehnana(Wearing The Cap)\\n        \\n        //Two choices(Left, Right) -> decrement target sum by root\\'s(current node) value.\\n        //Do choices hain left jao and right jao -> targetSum mein se current node ki value minus krdo\\n        pathSum(root.left, targetSum - root.val, currPath, allPaths);\\n        pathSum(root.right, targetSum - root.val, currPath, allPaths);\\n        //Backtracking(Topi Utarna(Pehle jaisi list krna)/Taking of the cup(undo))\\n        currPath.remove(currPath.size() - 1); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36843,
                "title": "c-dfs-17ms-non-recursive-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n            vector<vector<int> > result;\\n            vector<TreeNode*> st;\\n            TreeNode *pre = NULL, *cur = root;\\n            int value = 0;\\n            while (cur || !st.empty()) {\\n                while (cur) {\\n                    st.push_back(cur);\\n                    value += cur->val;\\n                    cur = cur->left;\\n                }\\n                cur = st.back();\\n                if (!cur->left && !cur->right && value == sum) {\\n                    vector<int> t;\\n                    for (auto i : st) {\\n                        t.push_back(i->val);\\n                    }\\n                    result.push_back(t);\\n                }\\n                if (cur->right && cur->right != pre) {\\n                    cur = cur->right;\\n                } else {\\n                    pre = cur;\\n                    value -= cur->val;\\n                    st.pop_back();\\n                    cur = NULL;\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n            vector<vector<int> > result;\\n            vector<TreeNode*> st;\\n            TreeNode *pre = NULL, *cur = root;\\n            int value = 0;\\n            while (cur || !st.empty()) {\\n                while (cur) {\\n                    st.push_back(cur);\\n                    value += cur->val;\\n                    cur = cur->left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1383773,
                "title": "c-simple-recursive-solution-96-time-and-93-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // vector to maintenance the nodes in the current path\\n    vector<int> path;\\n    // vector to save all paths that have sum equals to target\\n    vector< vector<int> > ans;\\n    \\n    void dfs(TreeNode* curr, int sum,int target)\\n    {\\n        if(!curr)\\n            return;\\n        \\n        sum += curr->val;\\n        path.push_back(curr->val);\\n        \\n        // if curr Node is a leaf\\n        if(!curr->left && !curr->right)\\n        {\\n            if(sum == target)            \\n                ans.push_back(path);            \\n        }\\n        else\\n        {\\n            dfs(curr->left,sum,target);\\n            dfs(curr->right,sum,target);\\n        }\\n        \\n        path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) \\n    {\\n        ans.clear();\\n        dfs(root,0,targetSum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // vector to maintenance the nodes in the current path\\n    vector<int> path;\\n    // vector to save all paths that have sum equals to target\\n    vector< vector<int> > ans;\\n    \\n    void dfs(TreeNode* curr, int sum,int target)\\n    {\\n        if(!curr)\\n            return;\\n        \\n        sum += curr->val;\\n        path.push_back(curr->val);\\n        \\n        // if curr Node is a leaf\\n        if(!curr->left && !curr->right)\\n        {\\n            if(sum == target)            \\n                ans.push_back(path);            \\n        }\\n        else\\n        {\\n            dfs(curr->left,sum,target);\\n            dfs(curr->right,sum,target);\\n        }\\n        \\n        path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) \\n    {\\n        ans.clear();\\n        dfs(root,0,targetSum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616000,
                "title": "c-easy-solution-with-image-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/be5fd050-0d54-492f-958b-1d452c4a005a_1663985386.2214854.jpeg)\\n\\n```\\n void solve(TreeNode *root,int targetSum,vector<int> ds,vector<vector<int>> &ans)\\n    {\\n        if(root==NULL) return;\\n        ds.push_back(root->val);\\n        targetSum=targetSum-root->val;\\n        if(targetSum==0 && root->left==NULL && root->right==NULL)\\n        {\\n            ans.push_back(ds);\\n            return;\\n        }\\n        solve(root->left,targetSum,ds,ans);\\n        solve(root->right,targetSum,ds,ans);\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(root,targetSum,ds,ans);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n void solve(TreeNode *root,int targetSum,vector<int> ds,vector<vector<int>> &ans)\\n    {\\n        if(root==NULL) return;\\n        ds.push_back(root->val);\\n        targetSum=targetSum-root->val;\\n        if(targetSum==0 && root->left==NULL && root->right==NULL)\\n        {\\n            ans.push_back(ds);\\n            return;\\n        }\\n        solve(root->left,targetSum,ds,ans);\\n        solve(root->right,targetSum,ds,ans);\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(root,targetSum,ds,ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 484120,
                "title": "python-3-beats-100-nine-lines-dfs",
                "content": "```\\nclass Solution:\\n    def pathSum(self, R: TreeNode, S: int) -> List[List[int]]:\\n        A, P = [], []\\n        def dfs(N):\\n            if N == None: return\\n            P.append(N.val)\\n            if (N.left,N.right) == (None,None) and sum(P) == S: A.append(list(P))\\n            else: dfs(N.left), dfs(N.right)\\n            P.pop()\\n        dfs(R)\\n        return A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, R: TreeNode, S: int) -> List[List[int]]:\\n        A, P = [], []\\n        def dfs(N):\\n            if N == None: return\\n            P.append(N.val)\\n            if (N.left,N.right) == (None,None) and sum(P) == S: A.append(list(P))\\n            else: dfs(N.left), dfs(N.right)\\n            P.pop()\\n        dfs(R)\\n        return A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 1932074,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func pathSum(_ root: TreeNode?, _ targetSum: Int) -> [[Int]] {\\n        var res: [[Int]] = []\\n        \\n        \\n        func backtrack(_ path: [Int], _ root: TreeNode?, _ target: Int) {\\n            guard let root = root else { return }\\n            \\n            if root.val == target && root.left == nil && root.right == nil {\\n                res.append(path + [root.val])\\n                return\\n            }\\n            \\n            var path = path\\n            for i in 0..<2 {\\n                if let node = (i == 0 ? root.left : root.right) {\\n                    path.append(root.val)\\n                    backtrack(path, node, target - root.val)\\n                    path.removeLast()\\n                }\\n            }    \\n        }\\n        \\n        backtrack([], root, targetSum)\\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func pathSum(_ root: TreeNode?, _ targetSum: Int) -> [[Int]] {\\n        var res: [[Int]] = []\\n        \\n        \\n        func backtrack(_ path: [Int], _ root: TreeNode?, _ target: Int) {\\n            guard let root = root else { return }\\n            \\n            if root.val == target && root.left == nil && root.right == nil {\\n                res.append(path + [root.val])\\n                return\\n            }\\n            \\n            var path = path\\n            for i in 0..<2 {\\n                if let node = (i == 0 ? root.left : root.right) {\\n                    path.append(root.val)\\n                    backtrack(path, node, target - root.val)\\n                    path.removeLast()\\n                }\\n            }    \\n        }\\n        \\n        backtrack([], root, targetSum)\\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382620,
                "title": "c-python-simple-and-clean-dfs-solution",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int target, int prev_sum, vector<int> curr) {\\n        if (!root) return;\\n        prev_sum += root->val;\\n        curr.push_back(root->val);\\n        \\n        if (prev_sum == target && !root->left && !root->right) res.push_back(curr);\\n        \\n        dfs(root->left, target, prev_sum, curr);\\n        dfs(root->right, target, prev_sum, curr);\\n        curr.pop_back();\\n    }\\n\\t\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        dfs(root, targetSum, 0, {});\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<vector<int>> res;\\n};\\n```\\n****\\n**Python:**\\n```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:\\n        self.res = []\\n        self.dfs(root, targetSum, 0, [])\\n        return self.res\\n            \\n    def dfs(self, root:TreeNode, target:int, prev_sum:int, my_list:list):\\n        if not root:\\n            return\\n        prev_sum += root.val\\n        my_list.append(root.val)\\n       \\n        if prev_sum == target and root.left == None and root.right == None:\\n            self.res.append(my_list[:])\\n        \\n        self.dfs(root.left, target, prev_sum, my_list)\\n        self.dfs(root.right, target, prev_sum, my_list)\\n        my_list.pop()\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int target, int prev_sum, vector<int> curr) {\\n        if (!root) return;\\n        prev_sum += root->val;\\n        curr.push_back(root->val);\\n        \\n        if (prev_sum == target && !root->left && !root->right) res.push_back(curr);\\n        \\n        dfs(root->left, target, prev_sum, curr);\\n        dfs(root->right, target, prev_sum, curr);\\n        curr.pop_back();\\n    }\\n\\t\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        dfs(root, targetSum, 0, {});\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<vector<int>> res;\\n};\\n```\n```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:\\n        self.res = []\\n        self.dfs(root, targetSum, 0, [])\\n        return self.res\\n            \\n    def dfs(self, root:TreeNode, target:int, prev_sum:int, my_list:list):\\n        if not root:\\n            return\\n        prev_sum += root.val\\n        my_list.append(root.val)\\n       \\n        if prev_sum == target and root.left == None and root.right == None:\\n            self.res.append(my_list[:])\\n        \\n        self.dfs(root.left, target, prev_sum, my_list)\\n        self.dfs(root.right, target, prev_sum, my_list)\\n        my_list.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382904,
                "title": "c-clean-easy-solution-backtracking",
                "content": "**Solution:**\\n```\\nclass Solution {\\npublic:\\n    void pathStore(TreeNode* root, vector<int>& path, int targetSum, vector<vector<int>>& res){\\n        if(root == NULL)\\n            return;\\t\\n        path.push_back(root->val);\\n        if(root->right == NULL and root->left == NULL and targetSum == root->val){\\n            res.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        pathStore(root->left, path, targetSum - root->val, res);\\n        pathStore(root->right, path, targetSum - root->val, res); \\n        path.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        vector<vector<int>> res;\\n        pathStore(root, path, targetSum, res);\\n        return res;\\n    }\\n};\\n```\\n\\n**Feel free to share ideas or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void pathStore(TreeNode* root, vector<int>& path, int targetSum, vector<vector<int>>& res){\\n        if(root == NULL)\\n            return;\\t\\n        path.push_back(root->val);\\n        if(root->right == NULL and root->left == NULL and targetSum == root->val){\\n            res.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        pathStore(root->left, path, targetSum - root->val, res);\\n        pathStore(root->right, path, targetSum - root->val, res); \\n        path.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        vector<vector<int>> res;\\n        pathStore(root, path, targetSum, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151494,
                "title": "python-js-go-c-o-n-by-dfs-w-comment",
                "content": "O(n) by DFS\\n\\n---\\n\\n**Implementation** by DFS in Python\\n\\n```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:\\n        \\n        def dfs( node, cur_path, cur_target ):\\n            \\n            # base case\\n            if not node:\\n                # empty node or empty tree\\n                return\\n        \\n            # general case\\n            \\n            # update current path\\n            cur_path.append( node.val )\\n            \\n            # update current target\\n            cur_target -= node.val\\n            \\n            if not node.left and not node.right and cur_target == 0:\\n                \\n                # current path is valid with wanted targetSum\\n\\t\\t\\t\\t# list is pass-by-reference in Python, so here we have to make a copy of list\\n                answer.append( cur_path[::] )\\n                \\n                # undo selection and go back to previous level\\n                cur_path.pop()\\n                return\\n            \\n            # solve subproblem in DFS\\n            dfs(node.left, cur_path, cur_target)\\n            dfs(node.right, cur_path, cur_target)\\n            \\n            # undo selection and go back to previous level\\n            cur_path.pop()\\n            return\\n        \\n        #------------------------------------------\\n        answer = []\\n        \\n        dfs(root, [], targetSum)\\n        \\n        return answer\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar pathSum = function(root, targetSum) {\\n    \\n    function dfs(node, curPath, curTarget){\\n        \\n        // base case\\n        if( node == null ){\\n            // empty node or empty tree\\n            return;\\n        }\\n        \\n        // general case\\n        \\n        // update current path\\n        curPath.push( node.val );\\n        \\n        // update current target\\n        curTarget -= node.val;\\n        \\n        if( node.left == null && node.right == null && curTarget == 0 ){\\n            \\n            // current path is valid with wanted targetSum\\n            // array is pass-by-reference in Javascript, so here we have to make a copy of array\\n            answer.push( curPath.slice() );\\n            \\n            // undo selection and go back to previous level\\n            curPath.pop();\\n            return;\\n        }\\n        \\n        // solve subproblem in DFS\\n        dfs( node.left, curPath, curTarget );\\n        dfs( node.right, curPath, curTarget );\\n\\n        // undo selection and go back to previous level\\n        curPath.pop();\\n        return;\\n    }\\n    \\n    // --------------------------\\n    \\n    answer = [];\\n    dfs(root, [], targetSum);\\n    return answer;\\n    \\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc pathSum(root *TreeNode, targetSum int) [][]int {\\n    \\n    \\n    answer := [][]int{}\\n    curPath := []int{}\\n    \\n    \\n    var dfs func( *TreeNode, []int, int)\\n    \\n    dfs = func(node *TreeNode, curPath []int, curTarget int){\\n        \\n        // base case\\n        if node == nil{\\n            \\n            // empty node or empty tree\\n            return\\n        }\\n        \\n        // general case\\n        \\n        // update current path\\n        curPath = append(curPath, node.Val)\\n\\n        // update current target\\n        curTarget -= node.Val\\n        \\n        if node.Left == nil && node.Right == nil && curTarget == 0{\\n            \\n            curSolution := append([]int{}, curPath...)\\n            answer = append(answer, curSolution )\\n            \\n            // undeo selection and go back to previous level\\n            curPath = curPath[:len(curPath)-1]\\n            return\\n        }\\n        \\n        dfs( node.Left, curPath, curTarget )\\n        dfs( node.Right, curPath, curTarget )\\n        \\n        // undeo selection and go back to previous level\\n        curPath = curPath[:len(curPath)-1]\\n        return\\n        \\n        \\n    }\\n    \\n\\n    dfs( root, curPath, targetSum)\\n    \\n    return answer\\n    \\n}\\n```\\n\\n---\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> curPath = {};\\n        \\n        dfs(root, curPath, targetSum);\\n        return answer;\\n    }\\n    \\nprivate:\\n    vector<vector<int>> answer;\\n    void dfs(TreeNode* node, vector<int>& curPath, int curTarget){\\n        \\n        // base case\\n        if( node == nullptr ){\\n            // empty node or empty tree\\n            return;\\n        }\\n        \\n        // general case\\n        \\n        // update current path\\n        curPath.push_back( node->val );\\n\\n        // update current target\\n        curTarget -= node->val;\\n            \\n        if( node->left == nullptr && node->right == nullptr and curTarget == 0 ){\\n            \\n            // current path is valid with wanted targetSum\\n            answer.push_back( curPath );\\n            \\n            // undo selection and go back to previous level\\n            curPath.pop_back();\\n            return;\\n        }\\n        \\n        // solve subproblem in DFS\\n        dfs( node->left, curPath, curTarget);\\n        dfs( node->right, curPath, curTarget);\\n        \\n        // undo selection and go back to previous level\\n        curPath.pop_back();\\n        return;\\n    }\\n};\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #112 Path Sum](https://leetcode.com/problems/path-sum/)\\n\\n[Leetcode #437 Path Sum III](https://leetcode.com/problems/path-sum-iii/)\\n\\n[Leetcode #666 Path Sum IV (Locked)(Premium Access)](https://leetcode.com/problems/path-sum-iv)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:\\n        \\n        def dfs( node, cur_path, cur_target ):\\n            \\n            # base case\\n            if not node:\\n                # empty node or empty tree\\n                return\\n        \\n            # general case\\n            \\n            # update current path\\n            cur_path.append( node.val )\\n            \\n            # update current target\\n            cur_target -= node.val\\n            \\n            if not node.left and not node.right and cur_target == 0:\\n                \\n                # current path is valid with wanted targetSum\\n\\t\\t\\t\\t# list is pass-by-reference in Python, so here we have to make a copy of list\\n                answer.append( cur_path[::] )\\n                \\n                # undo selection and go back to previous level\\n                cur_path.pop()\\n                return\\n            \\n            # solve subproblem in DFS\\n            dfs(node.left, cur_path, cur_target)\\n            dfs(node.right, cur_path, cur_target)\\n            \\n            # undo selection and go back to previous level\\n            cur_path.pop()\\n            return\\n        \\n        #------------------------------------------\\n        answer = []\\n        \\n        dfs(root, [], targetSum)\\n        \\n        return answer\\n```\n```\\nvar pathSum = function(root, targetSum) {\\n    \\n    function dfs(node, curPath, curTarget){\\n        \\n        // base case\\n        if( node == null ){\\n            // empty node or empty tree\\n            return;\\n        }\\n        \\n        // general case\\n        \\n        // update current path\\n        curPath.push( node.val );\\n        \\n        // update current target\\n        curTarget -= node.val;\\n        \\n        if( node.left == null && node.right == null && curTarget == 0 ){\\n            \\n            // current path is valid with wanted targetSum\\n            // array is pass-by-reference in Javascript, so here we have to make a copy of array\\n            answer.push( curPath.slice() );\\n            \\n            // undo selection and go back to previous level\\n            curPath.pop();\\n            return;\\n        }\\n        \\n        // solve subproblem in DFS\\n        dfs( node.left, curPath, curTarget );\\n        dfs( node.right, curPath, curTarget );\\n\\n        // undo selection and go back to previous level\\n        curPath.pop();\\n        return;\\n    }\\n    \\n    // --------------------------\\n    \\n    answer = [];\\n    dfs(root, [], targetSum);\\n    return answer;\\n    \\n};\\n```\n```\\nfunc pathSum(root *TreeNode, targetSum int) [][]int {\\n    \\n    \\n    answer := [][]int{}\\n    curPath := []int{}\\n    \\n    \\n    var dfs func( *TreeNode, []int, int)\\n    \\n    dfs = func(node *TreeNode, curPath []int, curTarget int){\\n        \\n        // base case\\n        if node == nil{\\n            \\n            // empty node or empty tree\\n            return\\n        }\\n        \\n        // general case\\n        \\n        // update current path\\n        curPath = append(curPath, node.Val)\\n\\n        // update current target\\n        curTarget -= node.Val\\n        \\n        if node.Left == nil && node.Right == nil && curTarget == 0{\\n            \\n            curSolution := append([]int{}, curPath...)\\n            answer = append(answer, curSolution )\\n            \\n            // undeo selection and go back to previous level\\n            curPath = curPath[:len(curPath)-1]\\n            return\\n        }\\n        \\n        dfs( node.Left, curPath, curTarget )\\n        dfs( node.Right, curPath, curTarget )\\n        \\n        // undeo selection and go back to previous level\\n        curPath = curPath[:len(curPath)-1]\\n        return\\n        \\n        \\n    }\\n    \\n\\n    dfs( root, curPath, targetSum)\\n    \\n    return answer\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> curPath = {};\\n        \\n        dfs(root, curPath, targetSum);\\n        return answer;\\n    }\\n    \\nprivate:\\n    vector<vector<int>> answer;\\n    void dfs(TreeNode* node, vector<int>& curPath, int curTarget){\\n        \\n        // base case\\n        if( node == nullptr ){\\n            // empty node or empty tree\\n            return;\\n        }\\n        \\n        // general case\\n        \\n        // update current path\\n        curPath.push_back( node->val );\\n\\n        // update current target\\n        curTarget -= node->val;\\n            \\n        if( node->left == nullptr && node->right == nullptr and curTarget == 0 ){\\n            \\n            // current path is valid with wanted targetSum\\n            answer.push_back( curPath );\\n            \\n            // undo selection and go back to previous level\\n            curPath.pop_back();\\n            return;\\n        }\\n        \\n        // solve subproblem in DFS\\n        dfs( node->left, curPath, curTarget);\\n        dfs( node->right, curPath, curTarget);\\n        \\n        // undo selection and go back to previous level\\n        curPath.pop_back();\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320640,
                "title": "c-99-9-beat-recursive-solution-smart-data-structures-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n        vector<vector<int>> aResult;\\n        vector<int> aList;\\n        pathSum(aResult, root, sum, aList);     \\n        return aResult;\\n    }\\n    \\n    void pathSum(vector<vector<int>> &pResult, TreeNode *root, int sum, vector<int> &pList) {\\n        \\n        if (root == NULL) { return; }\\n        \\n        sum -= root->val;    \\n        \\n        pList.push_back(root->val);\\n        \\n        if (root->left == NULL && root->right == NULL && sum == 0) { pResult.push_back(pList); }\\n        if (root->left)  { pathSum(pResult, root->left,  sum, pList); }\\n        if (root->right) { pathSum(pResult, root->right, sum, pList); }\\n        \\n        pList.pop_back();\\n    }\\n    \\n};\\n```\\n\\nEasier than flying through space on a blue cow\\'s cowchips.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n        vector<vector<int>> aResult;\\n        vector<int> aList;\\n        pathSum(aResult, root, sum, aList);     \\n        return aResult;\\n    }\\n    \\n    void pathSum(vector<vector<int>> &pResult, TreeNode *root, int sum, vector<int> &pList) {\\n        \\n        if (root == NULL) { return; }\\n        \\n        sum -= root->val;    \\n        \\n        pList.push_back(root->val);\\n        \\n        if (root->left == NULL && root->right == NULL && sum == 0) { pResult.push_back(pList); }\\n        if (root->left)  { pathSum(pResult, root->left,  sum, pList); }\\n        if (root->right) { pathSum(pResult, root->right, sum, pList); }\\n        \\n        pList.pop_back();\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617729,
                "title": "c-2-different-solutions-recursive-and-iterative-dfs",
                "content": "### Solution 1: recursive DFS\\n\\nThis is straight forward.\\n\\n```cpp\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        if (!root) return {};\\n\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        dfs(root, targetSum, path, ans);\\n        return ans;\\n    }\\n\\n    void dfs(TreeNode* node, int targetSum, vector<int>& path,\\n             vector<vector<int>>& ans) {\\n        path.push_back(node->val);\\n        targetSum -= node->val;\\n        if (!node->left && !node->right && !targetSum) ans.push_back(path);\\n        if (node->left) dfs(node->left, targetSum, path, ans);\\n        if (node->right) dfs(node->right, targetSum, path, ans);\\n        path.pop_back();\\n    }\\n```\\n\\n### Solution 2: iterative DFS\\n\\nIf we use a ```nullptr``` on the ```stack<TreeNode*>``` to track when we are done with a node, we can also write an iterative version.\\n\\n\\n```cpp\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        if (!root) return {};\\n\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        stack<TreeNode*> st;\\n        st.push(nullptr);\\n        st.push(root);\\n\\n        while (!empty(st)) {\\n            TreeNode* node = st.top(); st.pop();\\n            if (!node) {\\n                targetSum += path.back();\\n                path.pop_back();\\n            } else {\\n                path.push_back(node->val);\\n                targetSum -= node->val;\\n                if (!node->left && !node->right && !targetSum) {\\n                    ans.push_back(path);\\n                }\\n                if (node->left) {\\n                    st.push(nullptr);\\n                    st.push(node->left);\\n                }\\n                if (node->right) {\\n                    st.push(nullptr);\\n                    st.push(node->right);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\nThe complexity of both solutions is the same.\\n  * Time complexity: In a perfect binary tree we would have $$n / 2$$ leaf nodes, where $$n$$ is the number of nodes in the tree. For each of the leaf nodes we potentially need to copy a path of length $$\\\\log n$$. Hence to total time complexity is $$O(n \\\\log n)$$. I am unsure if we could construct a degraded case that would lead to higher complexity. If we would just have a linked list we would have a path of length $$n$$ but there would be only one such path, leading to a $$O(n)$$. Please leave a comment if you have some thoughts on the complexity analysis.\\n  * Space Complexity: $$O(n \\\\log n)$$ with basically the same argument as for time complexity.\\n\\n_As always: Feedback, questions, and comments are welcome. Please upvote if you like this post._\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        if (!root) return {};\\n\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        dfs(root, targetSum, path, ans);\\n        return ans;\\n    }\\n\\n    void dfs(TreeNode* node, int targetSum, vector<int>& path,\\n             vector<vector<int>>& ans) {\\n        path.push_back(node->val);\\n        targetSum -= node->val;\\n        if (!node->left && !node->right && !targetSum) ans.push_back(path);\\n        if (node->left) dfs(node->left, targetSum, path, ans);\\n        if (node->right) dfs(node->right, targetSum, path, ans);\\n        path.pop_back();\\n    }\\n```\n```nullptr```\n```stack<TreeNode*>```\n```cpp\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        if (!root) return {};\\n\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        stack<TreeNode*> st;\\n        st.push(nullptr);\\n        st.push(root);\\n\\n        while (!empty(st)) {\\n            TreeNode* node = st.top(); st.pop();\\n            if (!node) {\\n                targetSum += path.back();\\n                path.pop_back();\\n            } else {\\n                path.push_back(node->val);\\n                targetSum -= node->val;\\n                if (!node->left && !node->right && !targetSum) {\\n                    ans.push_back(path);\\n                }\\n                if (node->left) {\\n                    st.push(nullptr);\\n                    st.push(node->left);\\n                }\\n                if (node->right) {\\n                    st.push(nullptr);\\n                    st.push(node->right);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2615979,
                "title": "java-solution-1ms-runtime-easy-to-understand-simple-solution",
                "content": "## Please upvote the solution if you liked it\\n```\\nclass Solution {\\n    List<List<Integer>> list;\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        list  = new ArrayList<>();\\n        sum(root,targetSum,new ArrayList<>());\\n        return list;\\n    }\\n     void sum(TreeNode root,int sum,List<Integer> curr){\\n         if(root==null) return ;\\n        if(isLeaf(root)){\\n            if(sum==root.val){\\n                curr.add(root.val);\\n                list.add(new ArrayList<>(curr));\\n                curr.remove(curr.size()-1);\\n            }\\n            return;\\n        }\\n        curr.add(root.val);\\n        sum(root.left,sum-root.val,curr);\\n        sum(root.right,sum-root.val,curr);\\n        curr.remove(curr.size()-1);\\n    }\\n    static boolean isLeaf(TreeNode root){\\n        return root.left==root.right;\\n    }\\n}\\n```\\n\\n\\n### If you reached till here and this helped you out please hit the upvote button \\uD83D\\uDC4D it do not cost anything",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> list;\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        list  = new ArrayList<>();\\n        sum(root,targetSum,new ArrayList<>());\\n        return list;\\n    }\\n     void sum(TreeNode root,int sum,List<Integer> curr){\\n         if(root==null) return ;\\n        if(isLeaf(root)){\\n            if(sum==root.val){\\n                curr.add(root.val);\\n                list.add(new ArrayList<>(curr));\\n                curr.remove(curr.size()-1);\\n            }\\n            return;\\n        }\\n        curr.add(root.val);\\n        sum(root.left,sum-root.val,curr);\\n        sum(root.right,sum-root.val,curr);\\n        curr.remove(curr.size()-1);\\n    }\\n    static boolean isLeaf(TreeNode root){\\n        return root.left==root.right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615820,
                "title": "clean-fast-python3-bfs",
                "content": "Please upvote if it helps!\\n```\\nclass Solution:        \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        if root is None:\\n            return []\\n        q, paths = deque([(root, targetSum, [])]), []\\n        \\n        while q:\\n            cur, target, path = q.pop()  \\n            if not (cur.left or cur.right) and cur.val == target:\\n                paths.append(path + [cur.val])\\n            else:\\n                if cur.left:\\n                    q.appendleft((cur.left, target - cur.val, path + [cur.val]))\\n                if cur.right:\\n                    q.appendleft((cur.right, target - cur.val, path + [cur.val]))\\n                                 \\n        return paths",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "Please upvote if it helps!\\n```\\nclass Solution:        \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        if root is None:\\n            return []\\n        q, paths = deque([(root, targetSum, [])]), []\\n        \\n        while q:\\n            cur, target, path = q.pop()  \\n            if not (cur.left or cur.right) and cur.val == target:\\n                paths.append(path + [cur.val])\\n            else:\\n                if cur.left:\\n                    q.appendleft((cur.left, target - cur.val, path + [cur.val]))\\n                if cur.right:\\n                    q.appendleft((cur.right, target - cur.val, path + [cur.val]))\\n                                 \\n        return paths",
                "codeTag": "Java"
            },
            {
                "id": 2799044,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        dfs(root, targetSum, path);\\n        return ans;\\n    }\\n    void dfs(TreeNode* root, int targetSum, vector<int>& path) {\\n        if (root == nullptr) return;\\n        path.push_back(root->val);\\n        targetSum -= root->val;\\n        if (root->left == nullptr && root->right == nullptr) { // Is leaf node\\n            if (targetSum == 0) // Found valid path\\n                ans.push_back(path);\\n        } else {\\n            dfs(root->left, targetSum, path);\\n            dfs(root->right, targetSum, path);\\n        }\\n        path.pop_back(); // backtrack\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        dfs(root, targetSum, path);\\n        return ans;\\n    }\\n    void dfs(TreeNode* root, int targetSum, vector<int>& path) {\\n        if (root == nullptr) return;\\n        path.push_back(root->val);\\n        targetSum -= root->val;\\n        if (root->left == nullptr && root->right == nullptr) { // Is leaf node\\n            if (targetSum == 0) // Found valid path\\n                ans.push_back(path);\\n        } else {\\n            dfs(root->left, targetSum, path);\\n            dfs(root->right, targetSum, path);\\n        }\\n        path.pop_back(); // backtrack\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616110,
                "title": "c-dfs-direct-approach",
                "content": "**If you like it, please give a star, to my [Github](https://github.com/champmaniac/LeetCode) Repository and upvote this post.**\\n\\n**Intuition:**\\nWe can use **DFS** to traverse the tree and keep track of the path we took to get to the current node.\\n\\n**Approach:**\\n* Using **DFS** if we reach a `leaf` node and the `sum` of the path is `equal` to the `target` sum, we add the path to the `answer`.\\n* If we reach a `leaf` node and the `sum` of the path is `not` `equal` to the `target` sum, we `backtrack` and try `another` path.\\n\\n**Visualization:**\\n![image](https://assets.leetcode.com/users/images/f7659503-241d-4541-9317-e1a8ae2d64f3_1663989255.371252.png)\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int targetSum, vector<int>& path, vector<vector<int>>& ans) {\\n        if (!root) return;\\n        path.push_back(root->val);\\n        if (!root->left && !root->right && targetSum == root->val) {\\n            ans.push_back(path);\\n        }\\n        dfs(root->left, targetSum - root->val, path, ans);\\n        dfs(root->right, targetSum - root->val, path, ans);\\n        path.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        dfs(root, targetSum, path, ans);\\n        return ans;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(n)**, where `n` is the number of nodes in the tree\\n**Space Complexity:** **O(n)**\\n****\\n\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int targetSum, vector<int>& path, vector<vector<int>>& ans) {\\n        if (!root) return;\\n        path.push_back(root->val);\\n        if (!root->left && !root->right && targetSum == root->val) {\\n            ans.push_back(path);\\n        }\\n        dfs(root->left, targetSum - root->val, path, ans);\\n        dfs(root->right, targetSum - root->val, path, ans);\\n        path.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        dfs(root, targetSum, path, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235001,
                "title": "swift-path-sum-ii-test-cases",
                "content": "##### Solution\\n```swift\\nclass Solution {\\n    func pathSum(_ root: TreeNode?, _ targetSum: Int) -> [[Int]] {\\n        return findPath(root, targetSum, [Int](), [[Int]]())\\n    }\\n    \\n    private func findPath(_ root: TreeNode?, _ sum: Int, _ path: [Int], _ paths: [[Int]]) -> [[Int]] {\\n        guard let root = root else { return paths }\\n        var cpath = path\\n        cpath.append(root.val)\\n        if root.left == nil && root.right == nil && root.val == sum {\\n            var cPaths = paths\\n            cPaths.append(cpath)\\n            return cPaths\\n        }\\n        let val = sum - root.val\\n        let left = findPath(root.left, val, cpath, paths)\\n        let right = findPath(root.right, val, cpath, paths)\\n        return left + right\\n    }\\n}\\n```\\n\\n##### Test Cases\\n```swift\\nimport XCTest\\n\\n//      Executed 3 tests, with 0 failures (0 unexpected) in 0.339 (0.341) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        XCTAssertEqual(s.pathSum(.init([5,4,8,11,nil,13,4,7,2,nil,nil,5,1]), 22), [[5,4,11,2],[5,8,4,5]])\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.pathSum(.init([1,2,3]), 5), [])\\n    }\\n    func test3() {\\n        XCTAssertEqual(s.pathSum(.init([1,2]), 0), [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n##### TreeNode\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    // Making an additional initializer from an array of integers\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func pathSum(_ root: TreeNode?, _ targetSum: Int) -> [[Int]] {\\n        return findPath(root, targetSum, [Int](), [[Int]]())\\n    }\\n    \\n    private func findPath(_ root: TreeNode?, _ sum: Int, _ path: [Int], _ paths: [[Int]]) -> [[Int]] {\\n        guard let root = root else { return paths }\\n        var cpath = path\\n        cpath.append(root.val)\\n        if root.left == nil && root.right == nil && root.val == sum {\\n            var cPaths = paths\\n            cPaths.append(cpath)\\n            return cPaths\\n        }\\n        let val = sum - root.val\\n        let left = findPath(root.left, val, cpath, paths)\\n        let right = findPath(root.right, val, cpath, paths)\\n        return left + right\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n//      Executed 3 tests, with 0 failures (0 unexpected) in 0.339 (0.341) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        XCTAssertEqual(s.pathSum(.init([5,4,8,11,nil,13,4,7,2,nil,nil,5,1]), 22), [[5,4,11,2],[5,8,4,5]])\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.pathSum(.init([1,2,3]), 5), [])\\n    }\\n    func test3() {\\n        XCTAssertEqual(s.pathSum(.init([1,2]), 0), [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    // Making an additional initializer from an array of integers\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459992,
                "title": "javascript-solution",
                "content": "```\\nfunction pathSum(root, sum) {\\n  return findPaths(sum, root, []);\\n};\\n\\nfunction findPaths(sum, node, path) {\\n  if (!node) return [];\\n  if (!node.right && !node.left)\\n    return sum - node.val === 0 ? [path.concat(node.val)] : [];\\n  \\n  return [\\n    ...findPaths(sum - node.val, node.left, path.concat(node.val)),\\n    ...findPaths(sum - node.val, node.right, path.concat(node.val))\\n  ];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction pathSum(root, sum) {\\n  return findPaths(sum, root, []);\\n};\\n\\nfunction findPaths(sum, node, path) {\\n  if (!node) return [];\\n  if (!node.right && !node.left)\\n    return sum - node.val === 0 ? [path.concat(node.val)] : [];\\n  \\n  return [\\n    ...findPaths(sum - node.val, node.left, path.concat(node.val)),\\n    ...findPaths(sum - node.val, node.right, path.concat(node.val))\\n  ];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355450,
                "title": "go-4ms-recursion",
                "content": "```\\nfunc pathSum(root *TreeNode, sum int) [][]int {\\n    var res [][]int\\n    if root == nil {\\n        return res\\n    }\\n    if root.Left == nil && root.Right == nil {\\n        if sum == root.Val {\\n            return append(res, []int{ root.Val })\\n        }\\n        return res\\n    }\\n    \\n    for _, path := range pathSum(root.Left, sum - root.Val) {\\n        res = append(res, append([]int{ root.Val}, path... ))\\n    }\\n    for _, path := range pathSum(root.Right, sum - root.Val) {\\n        res = append(res, append([]int{ root.Val}, path... ))\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pathSum(root *TreeNode, sum int) [][]int {\\n    var res [][]int\\n    if root == nil {\\n        return res\\n    }\\n    if root.Left == nil && root.Right == nil {\\n        if sum == root.Val {\\n            return append(res, []int{ root.Val })\\n        }\\n        return res\\n    }\\n    \\n    for _, path := range pathSum(root.Left, sum - root.Val) {\\n        res = append(res, append([]int{ root.Val}, path... ))\\n    }\\n    for _, path := range pathSum(root.Right, sum - root.Val) {\\n        res = append(res, append([]int{ root.Val}, path... ))\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36838,
                "title": "java-3ms-solution-explained",
                "content": "    public class Solution {\\n    \\n    public List<List<Integer>> pathSum(TreeNode root, int target) {\\n        List<List<Integer>> results = new ArrayList<>();\\n        // Store path as we decend\\n        List<Integer> path = new ArrayList<>();\\n        dfs(root, 0, target, path, results);\\n        return results;\\n    }\\n    \\n    /**\\n     * Node - the current being looked at\\n     * sum  - the sum for the current path\\n     * target - the targetted total\\n     * path - the nodes seen in the current path\\n     * results - the list of paths that led to the targetted total\\n     */\\n    public void dfs(TreeNode node, int sum, int target, List<Integer> path, List<List<Integer>> results) {\\n        if (node == null) return;\\n        // Add the value of the current node to the sum\\n        sum += node.val;\\n        // Add the current node the path\\n        path.add(node.val);\\n        \\n        // If it's a leaf node and the sum matches what we're targetting\\n        // add the path to the list of paths that lead to the targetted total\\n        if(node.left == null && node.right == null && sum == target) {\\n            results.add(new ArrayList(path));\\n            return;\\n        }\\n        \\n        // Visit recursivelly the left branch, but only if it exists :)\\n        if (node.left != null) {\\n            dfs(node.left, sum, target, path, results);\\n            // Remove the last node from the path since we're going to explore other paths when \\n            // we return the function\\n            path.remove(path.size()-1);\\n        }\\n        \\n        // Same as above, but now for the rigth branch\\n        if(node.right != null) {\\n            dfs(node.right, sum, target, path, results);\\n            path.remove(path.size()-1);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public List<List<Integer>> pathSum(TreeNode root, int target) {\\n        List<List<Integer>> results = new ArrayList<>();\\n        // Store path as we decend\\n        List<Integer> path = new ArrayList<>();\\n        dfs(root, 0, target, path, results);\\n        return results;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36948,
                "title": "why-does-this-code-give-time-limit-exceeded-java",
                "content": "    /**\\n     * Definition for binary tree\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public LinkedList<LinkedList<Integer>> pathSum(TreeNode root, int sum) {\\n            LinkedList<Integer> list = new LinkedList<Integer>();\\n            LinkedList<LinkedList<Integer>> bigList = new LinkedList<LinkedList<Integer>>();\\n            get(root,sum,0,list,bigList);\\n            return bigList;\\n        }\\n        public void get(TreeNode node, int target, int sum, LinkedList<Integer> list, LinkedList<LinkedList<Integer>> bigList){\\n            if (node == null) return;\\n            int number = sum + node.val;\\n            if (number == target && node.left == null && node.right == null){// leaf & target check\\n                list.add(node.val);//add it to list\\n                bigList.add(list);//add list to big list\\n                return;\\n            }\\n            else {\\n                list.add(node.val);\\n                //recurse\\n                if (node.left != null) get(node.left, target, number, list, bigList);\\n                if (node.right != null) get(node.right, target, number, list, bigList);\\n            }\\n        }\\n        \\n    }\\n\\nFor the test case: \\n[1,1,#,1,#...,1,#,1] 1000\"",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public LinkedList<LinkedList<Integer>> pathSum(TreeNode root, int sum) {\\n            LinkedList<Integer> list = new LinkedList<Integer>();\\n            LinkedList<LinkedList<Integer>> bigList = new LinkedList<LinkedList<Integer>>();\\n            get(root,sum,0,list,bigList);\\n            return bigList;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3377751,
                "title": "easy-clear-solution-python3-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        res=[]\\n        def dfs(path,r):\\n            if r:\\n                if not r.left and not r.right:\\n                    path.append(r.val)\\n                    if sum(path)==targetSum:\\n                        res.append(path)\\n                dfs(path+[r.val],r.left)\\n                dfs(path+[r.val],r.right)\\n        dfs([],root)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        res=[]\\n        def dfs(path,r):\\n            if r:\\n                if not r.left and not r.right:\\n                    path.append(r.val)\\n                    if sum(path)==targetSum:\\n                        res.append(path)\\n                dfs(path+[r.val],r.left)\\n                dfs(path+[r.val],r.right)\\n        dfs([],root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077566,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(TreeNode* root, int t,vector<int> v)\\n    {\\n        if(!root)\\n            return;\\n        v.push_back(root->val);\\n        if(root->val==t && !root->left && !root->right)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        dfs(root->left, t-root->val,v);\\n        dfs(root->right, t-root->val,v);\\n        v.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> v;\\n        dfs(root, targetSum, v);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(TreeNode* root, int t,vector<int> v)\\n    {\\n        if(!root)\\n            return;\\n        v.push_back(root->val);\\n        if(root->val==t && !root->left && !root->right)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        dfs(root->left, t-root->val,v);\\n        dfs(root->right, t-root->val,v);\\n        v.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> v;\\n        dfs(root, targetSum, v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690275,
                "title": "python-simple-recursive-solution",
                "content": "```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\\n        ## RC ##\\n        ## APPROACH : DFS ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        def dfs(node, path, total):\\n            if not node:   return\\n            if(total + node.val == sum and not node.left and not node.right):       # watchout for conditions\\n                result.append(path + [node.val])\\n                return\\n            if(node.left):  dfs(node.left, path + [node.val], total + node.val)\\n            if(node.right): dfs(node.right, path + [node.val], total + node.val)\\n        result = []\\n        dfs(root, [], 0)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\\n        ## RC ##\\n        ## APPROACH : DFS ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        def dfs(node, path, total):\\n            if not node:   return\\n            if(total + node.val == sum and not node.left and not node.right):       # watchout for conditions\\n                result.append(path + [node.val])\\n                return\\n            if(node.left):  dfs(node.left, path + [node.val], total + node.val)\\n            if(node.right): dfs(node.right, path + [node.val], total + node.val)\\n        result = []\\n        dfs(root, [], 0)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36831,
                "title": "java-recursive-and-iterative-dfs-solutions",
                "content": "        \\n    // dfs recursively \\n    public List<List<Integer>> pathSum1(TreeNode root, int sum) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        List<Integer> path = new ArrayList<>();\\n        dfs(root, sum, path, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode root, int sum, List<Integer> path, List<List<Integer>> ret) {\\n        if (root != null) {\\n            path.add(root.val);\\n            if (root.left == null && root.right == null && root.val == sum) {\\n                ret.add(path);\\n            }\\n            dfs(root.left, sum-root.val, new ArrayList(path), ret);\\n            dfs(root.right, sum-root.val, new ArrayList(path), ret);\\n        }\\n    }\\n    \\n    class Tripple {\\n        TreeNode node;\\n        List<Integer> path;\\n        int value;\\n        Tripple(TreeNode node, List<Integer> path, int value) {\\n            this.node = node;\\n            this.path = path;\\n            this.value = value;\\n        }\\n    }\\n    \\n    // dfs iteratively\\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        Stack<Tripple> stack = new Stack<>();\\n        stack.push(new Tripple(root, new ArrayList<>(), sum));\\n        while (!stack.isEmpty()) {\\n            Tripple tripple = stack.pop();\\n            TreeNode node = tripple.node;\\n            List<Integer> path = tripple.path;\\n            int v = tripple.value;\\n            if (node != null) {\\n                path.add(node.val);\\n                if (node.left == null && node.right == null && node.val == v) {\\n                    ret.add(path);\\n                }\\n                stack.push(new Tripple(node.right, new ArrayList(path), v-node.val));\\n                stack.push(new Tripple(node.left, new ArrayList(path), v-node.val));\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // dfs recursively \\n    public List<List<Integer>> pathSum1(TreeNode root, int sum) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        List<Integer> path = new ArrayList<>();\\n        dfs(root, sum, path, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode root, int sum, List<Integer> path, List<List<Integer>> ret) {\\n        if (root != null) {\\n            path.add(root.val);\\n            if (root.left == null && root.right == null && root.val == sum) {\\n                ret.add(path);\\n            }\\n            dfs(root.left, sum-root.val, new ArrayList(path), ret);\\n            dfs(root.right, sum-root.val, new ArrayList(path), ret);\\n        }\\n    }\\n    \\n    class Tripple {\\n        TreeNode node;\\n        List<Integer> path;\\n        int value;\\n        Tripple(TreeNode node, List<Integer> path, int value) {\\n            this.node = node;\\n            this.path = path;\\n            this.value = value;\\n        }\\n    }\\n    \\n    // dfs iteratively\\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        Stack<Tripple> stack = new Stack<>();\\n        stack.push(new Tripple(root, new ArrayList<>(), sum));\\n        while (!stack.isEmpty()) {\\n            Tripple tripple = stack.pop();\\n            TreeNode node = tripple.node;\\n            List<Integer> path = tripple.path;\\n            int v = tripple.value;\\n            if (node != null) {\\n                path.add(node.val);\\n                if (node.left == null && node.right == null && node.val == v) {\\n                    ret.add(path);\\n                }\\n                stack.push(new Tripple(node.right, new ArrayList(path), v-node.val));\\n                stack.push(new Tripple(node.left, new ArrayList(path), v-node.val));\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36932,
                "title": "short-c-recursive-solution",
                "content": "Obviously this problem is suited for recursive method. However, the main problem is that one needs to find all possible paths. My solution is to recursively descend to all leafs. At the same time, pass by value a vector<int> to store the current path, while pass by reference a vector<vector<int> > to store all paths that meet the criteria.\\n\\n        class Solution {\\n    public:\\n        vector<vector<int> > pathSum(TreeNode *root, int sum) {\\n            vector<vector<int> > finishedSearch;\\n            vector<int> currentSearch;\\n            pathDesend(root, sum, currentSearch, finishedSearch);\\n            return finishedSearch;\\n        }\\n            \\n        void pathDesend(TreeNode* current_root, int sum, vector<int> currentSearch, vector<vector<int> > & finishedSearch){\\n            if(current_root==NULL) return;\\n            currentSearch.push_back(current_root->val);\\n            if(sum == current_root->val && current_root->left==NULL && current_root->right==NULL){\\n                  finishedSearch.push_back(currentSearch);\\n                  return;\\n            }\\n            pathDesend(current_root->left, sum-current_root->val,currentSearch,finishedSearch);\\n            pathDesend(current_root->right,sum-current_root->val,currentSearch,finishedSearch);\\n        }\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > pathSum(TreeNode *root, int sum) {\\n            vector<vector<int> > finishedSearch;\\n            vector<int> currentSearch;\\n            pathDesend(root, sum, currentSearch, finishedSearch);\\n            return finishedSearch;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36969,
                "title": "a-recursive-solution-accepted",
                "content": "This is a recursive solution, we can change it to iterative easily:\\n\\nclass Solution {\\npublic:\\n    vector<vector<int> > pathSum(TreeNode *root, int sum) {\\n        vector<vector<int>> res;\\n        vector<int> path;\\n        \\n        findAllPath (root, sum, path, res);\\n        return res;\\n    }\\n    \\nprivate:\\n    void findAllPath (TreeNode *root, int sum, vector<int> &path, vector<vector<int>> &res)\\n    {\\n        if (!root) return;\\n        \\n        path.push_back (root->val);\\n        if (!root->left && !root->right && root->val == sum)\\n            res.push_back (path);\\n        if (root->left)\\n            findAllPath (root->left, sum - root->val, path, res);\\n        if (root->right)\\n            findAllPath (root->right, sum - root->val, path, res);\\n        path.pop_back ();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int> > pathSum(TreeNode *root, int sum) {\\n        vector<vector<int>> res;\\n        vector<int> path;\\n        \\n        findAllPath (root, sum, path, res);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3523513,
                "title": "java-easy-solution-using-dfs-approach-beats-100-fully-explanation",
                "content": "\\n# Approach\\n- The main idea is to traverse the tree in a depth-first manner, keeping track of the current path and the remaining sum required to reach the targetSum. Here\\'s a step-by-step explanation of the approach:\\n\\n- The pathSum method initializes an empty list called ans to store the final result and creates an empty list called li to represent the current path being traversed.\\n\\n- It calls the path method, passing the root of the tree, the targetSum, the ans list, and the li list.\\n\\n- The path method is a recursive helper function that performs the actual traversal of the binary tree. It takes the following parameters:\\n\\n- root: The current node being processed in the tree.\\nsum: The remaining sum required to reach the targetSum.\\nans: The list of lists to store the result.\\nli: The current path being traversed.\\nInside the path method, the following steps are performed:\\n\\n- If the root is null, it means we have reached the end of a branch, so we return.\\n- We add the value of the current node (root.val) to the li list, representing the current path being traversed.\\n- If the current node is a leaf node (both left and right children are null), we subtract the value of the leaf node from the remaining sum. If the sum becomes zero, it means we have found a path that sums up to the targetSum. In this case, we add the li list (representing the path) to the ans list.\\n- We recursively call the path method for the left and right children of the current node. We subtract the value of the current node from the remaining sum in each recursive call. This step allows us to explore all possible paths in the binary tree.\\n- After the recursive calls are complete, we remove the last element from the li list to backtrack and explore other paths. This step ensures that the li list reflects the correct path at each point in the traversal.\\n\\nFinally, in the pathSum method, after the path method returns, we return the ans list, which contains all the paths that sum up to the targetSum.\\n\\nBy traversing the binary tree using the recursive DFS approach and keeping track of the current path and remaining sum, the code is able to find all root-to-leaf paths that sum up to the given targetSum.\\n\\n# Complexity\\n- Time complexity:\\n O(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> ans=new ArrayList();\\n       List<Integer> li=new ArrayList();\\n       path(root,targetSum,ans,li);\\n       return ans;\\n    }\\n    static void path(TreeNode root,int sum,List<List<Integer>> ans,List<Integer> li){\\n   \\n        if(root==null){\\n            return;\\n        }\\n      li.add(root.val);\\n\\n      if(root.left==null && root.right==null){\\n           sum-=root.val;\\n            if(sum==0){\\n            ans.add(new ArrayList<>(li));\\n            }\\n      }\\n     \\n     \\n      path(root.left,sum-root.val,ans,li);\\n      path(root.right,sum-root.val,ans,li);\\n      li.remove(li.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> ans=new ArrayList();\\n       List<Integer> li=new ArrayList();\\n       path(root,targetSum,ans,li);\\n       return ans;\\n    }\\n    static void path(TreeNode root,int sum,List<List<Integer>> ans,List<Integer> li){\\n   \\n        if(root==null){\\n            return;\\n        }\\n      li.add(root.val);\\n\\n      if(root.left==null && root.right==null){\\n           sum-=root.val;\\n            if(sum==0){\\n            ans.add(new ArrayList<>(li));\\n            }\\n      }\\n     \\n     \\n      path(root.left,sum-root.val,ans,li);\\n      path(root.right,sum-root.val,ans,li);\\n      li.remove(li.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616212,
                "title": "100-faster-easy-explanation-backtracking-dfs",
                "content": "**Java**\\n```\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        dfs(root, targetSum, res, list);\\n        return res;\\n    }\\n    \\n    private void dfs(TreeNode root, int ts, List<List<Integer>> res, List<Integer> list){\\n        if(root == null) return;\\n        \\n        list.add(root.val);\\n        \\n        // Found a leaf node, if targetSum becomes zero after adding leaf node value then a path is found, add the path to the result list\\n        if(root.left == null && root.right == null){\\n            if((ts-root.val)==0) res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        // Traverse left part(reduce targetSum by node value), and backtrack (by deleting node from list) after completing the left subtree\\n        if(root.left != null){\\n            dfs(root.left, ts-root.val, res, list);\\n            list.remove(list.size()-1);   \\n        }\\n        \\n        \\n        // Traverse right part and backtrack\\n        if(root.right != null){\\n            dfs(root.right, ts-root.val, res, list);\\n            list.remove(list.size()-1);    \\n        }\\n        \\n    }\\n}\\n```\\n\\n**Kotlin**\\n```\\nclass Solution {\\n    fun pathSum(root: TreeNode?, targetSum: Int): List<List<Int>> {\\n        val res = mutableListOf<List<Int>>()\\n        val list = mutableListOf<Int>()\\n        dfs(root,targetSum,list,res)\\n        return res\\n    }\\n    \\n    private fun dfs(root : TreeNode?, ts : Int, list : MutableList<Int>, res : MutableList<List<Int>>){\\n        root?.let{\\n            list.add(root.`val`)\\n            \\n            if(root.left==null && root.right==null){\\n                if((ts-root.`val`)==0) res.add(list.toMutableList())\\n                return\\n            }\\n            \\n            root.left?.let{\\n                dfs(root.left, ts-root.`val`, list, res)\\n                list.removeAt(list.size-1)\\n            }\\n            root.right?.let{\\n                dfs(root.right, ts-root.`val`, list, res)\\n                list.removeAt(list.size-1)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        dfs(root, targetSum, res, list);\\n        return res;\\n    }\\n    \\n    private void dfs(TreeNode root, int ts, List<List<Integer>> res, List<Integer> list){\\n        if(root == null) return;\\n        \\n        list.add(root.val);\\n        \\n        // Found a leaf node, if targetSum becomes zero after adding leaf node value then a path is found, add the path to the result list\\n        if(root.left == null && root.right == null){\\n            if((ts-root.val)==0) res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        // Traverse left part(reduce targetSum by node value), and backtrack (by deleting node from list) after completing the left subtree\\n        if(root.left != null){\\n            dfs(root.left, ts-root.val, res, list);\\n            list.remove(list.size()-1);   \\n        }\\n        \\n        \\n        // Traverse right part and backtrack\\n        if(root.right != null){\\n            dfs(root.right, ts-root.val, res, list);\\n            list.remove(list.size()-1);    \\n        }\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun pathSum(root: TreeNode?, targetSum: Int): List<List<Int>> {\\n        val res = mutableListOf<List<Int>>()\\n        val list = mutableListOf<Int>()\\n        dfs(root,targetSum,list,res)\\n        return res\\n    }\\n    \\n    private fun dfs(root : TreeNode?, ts : Int, list : MutableList<Int>, res : MutableList<List<Int>>){\\n        root?.let{\\n            list.add(root.`val`)\\n            \\n            if(root.left==null && root.right==null){\\n                if((ts-root.`val`)==0) res.add(list.toMutableList())\\n                return\\n            }\\n            \\n            root.left?.let{\\n                dfs(root.left, ts-root.`val`, list, res)\\n                list.removeAt(list.size-1)\\n            }\\n            root.right?.let{\\n                dfs(root.right, ts-root.`val`, list, res)\\n                list.removeAt(list.size-1)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615816,
                "title": "daily-leetcoding-challenge-september-day-24",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/path-sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Depth First Traversal | Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/path-sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1594424,
                "title": "c-code-very-easy-slight-modification-from-path1-question",
                "content": "**Not a ClickBait guys**\\nJust added one line from path question (i.e v.push_back(root->val) from this question\\'s            solution[https://leetcode.com/problems/path-sum/](http://)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; \\n    void path(TreeNode* root, int sum,vector<int> v){\\n        if(!root) return;\\n        sum-=root->val; //minus the value of current node\\n        v.push_back(root->val); // push the current to track the path\\n        //when targetSum becomes zero,then push the path in ans\\n        if(!root->left && !root->right && sum == 0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        //left call\\n        path(root->left,sum,v);\\n        //right call\\n        path(root->right,sum,v);\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        if(!root) return {};\\n        vector<int> v;\\n        path(root,targetSum,v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; \\n    void path(TreeNode* root, int sum,vector<int> v){\\n        if(!root) return;\\n        sum-=root->val; //minus the value of current node\\n        v.push_back(root->val); // push the current to track the path\\n        //when targetSum becomes zero,then push the path in ans\\n        if(!root->left && !root->right && sum == 0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        //left call\\n        path(root->left,sum,v);\\n        //right call\\n        path(root->right,sum,v);\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        if(!root) return {};\\n        vector<int> v;\\n        path(root,targetSum,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552207,
                "title": "java-backtrack-solution",
                "content": "The keyword is \"root-to-leaf\".\\n```\\n\\tpublic List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        List<List<Integer>> res = new LinkedList<>();\\n        backtrack(root, sum, new LinkedList<>(), res);\\n        return res;\\n    }\\n    \\n    public void backtrack(TreeNode root, int sum, LinkedList<Integer> cur, List<List<Integer>> res) {\\n        if(root == null)\\n            return;\\n        cur.add(root.val);\\n        if(sum == root.val && root.left == null && root.right == null) {\\n            res.add(new LinkedList<>(cur));\\n            cur.removeLast();\\n            return;\\n        }\\n        backtrack(root.left, sum - root.val, cur, res);\\n        backtrack(root.right, sum - root.val, cur, res);\\n        cur.removeLast();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        List<List<Integer>> res = new LinkedList<>();\\n        backtrack(root, sum, new LinkedList<>(), res);\\n        return res;\\n    }\\n    \\n    public void backtrack(TreeNode root, int sum, LinkedList<Integer> cur, List<List<Integer>> res) {\\n        if(root == null)\\n            return;\\n        cur.add(root.val);\\n        if(sum == root.val && root.left == null && root.right == null) {\\n            res.add(new LinkedList<>(cur));\\n            cur.removeLast();\\n            return;\\n        }\\n        backtrack(root.left, sum - root.val, cur, res);\\n        backtrack(root.right, sum - root.val, cur, res);\\n        cur.removeLast();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36926,
                "title": "python-recursive-solution",
                "content": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @param sum, an integer\\n        # @return a list of lists of integers\\n        # 2:32\\n        def pathSum(self, root, sum):\\n            output = []\\n            self.findPathSum(root, sum, [], output)\\n    \\n            return output\\n    \\n        def findPathSum(self, root, sum, temp, output):\\n            if not root:\\n                return\\n    \\n            if not root.left and not root.right and sum == root.val:\\n                temp.append(root.val)\\n                output.append(temp[:])\\n                return\\n    \\n            sum -= root.val\\n            temp.append(root.val)\\n            self.findPathSum(root.left, sum, temp[:], output)\\n            self.findPathSum(root.right, sum, temp[:], output)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @param sum, an integer\\n        # @return a list of lists of integers\\n        # 2:32\\n        def pathSum(self, root, sum):\\n            output = []\\n            self.findPathSum(root, sum, [], output)\\n    \\n            return output\\n    \\n        def findPathSum(self, root, sum, temp, output):\\n            if not root:\\n                return\\n    \\n            if not root.left and not root.right and sum == root.val:\\n                temp.append(root.val)\\n                output.append(temp[:])\\n                return\\n    \\n            sum -= root.val\\n            temp.append(root.val)\\n            self.findPathSum(root.left, sum, temp[:], output)\\n            self.findPathSum(root.right, sum, temp[:], output)",
                "codeTag": "Java"
            },
            {
                "id": 3622881,
                "title": "path-sum-ii-in-java",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Define a helper method called `allPathSum` that takes four parameters: the current node, the remaining sum, the current path, and the list of all paths.\\n- If the current node is null, return from the method.\\n- Add the current node\\'s value to the path.\\n- If the current node is a leaf (has no left or right child) and its value equals the remaining sum, add a copy of the path to the list of all paths.\\n- Recursively call `allPathSum` on the left and right child of the current node, passing the updated remaining sum and path.\\n- Remove the last element from the path to backtrack to the previous node.\\n- Define another method called `pathSum` that takes two parameters: the root node and the target sum. This is the main method that will return the list of all paths.\\n- Create an empty list to store all paths.\\n- Call `allPathSum` with the root node, target sum, an empty path, and the list of all paths.\\n- Return the list of all paths.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void allPathSum(TreeNode root,int targetSum,List<Integer> path,List<List<Integer>> list){\\n        if(root == null){\\n            return ;\\n        }\\n        path.add(root.val);\\n        if(root.left == null && root.right == null && root.val == targetSum){\\n            list.add(new ArrayList<Integer>(path));\\n        }\\n        allPathSum(root.left,(targetSum - root.val),path,list);\\n        allPathSum(root.right,(targetSum - root.val),path,list);\\n        path.remove(path.size()-1);\\n    }\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        allPathSum(root,targetSum, new ArrayList<Integer>(),list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void allPathSum(TreeNode root,int targetSum,List<Integer> path,List<List<Integer>> list){\\n        if(root == null){\\n            return ;\\n        }\\n        path.add(root.val);\\n        if(root.left == null && root.right == null && root.val == targetSum){\\n            list.add(new ArrayList<Integer>(path));\\n        }\\n        allPathSum(root.left,(targetSum - root.val),path,list);\\n        allPathSum(root.right,(targetSum - root.val),path,list);\\n        path.remove(path.size()-1);\\n    }\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        allPathSum(root,targetSum, new ArrayList<Integer>(),list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214578,
                "title": "10ms-c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,vector<vector<int>> &ans,vector<int> &tmp,int x,int& mx){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(root->left==NULL&&root->right==NULL){\\n            \\n            if(x+root->val==mx){\\n                tmp.push_back(root->val);\\n                ans.push_back(tmp);\\n                tmp.pop_back();\\n            }\\n            return;\\n        }\\n        tmp.push_back(root->val);\\n        solve(root->left,ans,tmp,x+root->val,mx);\\n        solve(root->right,ans,tmp,x+root->val,mx);\\n        tmp.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int tgt) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        // int mx = INT_MIN;\\n        solve(root,ans,tmp,0,tgt);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,vector<vector<int>> &ans,vector<int> &tmp,int x,int& mx){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(root->left==NULL&&root->right==NULL){\\n            \\n            if(x+root->val==mx){\\n                tmp.push_back(root->val);\\n                ans.push_back(tmp);\\n                tmp.pop_back();\\n            }\\n            return;\\n        }\\n        tmp.push_back(root->val);\\n        solve(root->left,ans,tmp,x+root->val,mx);\\n        solve(root->right,ans,tmp,x+root->val,mx);\\n        tmp.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int tgt) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        // int mx = INT_MIN;\\n        solve(root,ans,tmp,0,tgt);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127811,
                "title": "python3-113-path-sum-ii",
                "content": "```\\nclass Solution: \\n    def pathSum(self, root: TreeNode, targetSum: int) -> list[list[int]]:\\n\\n        def Count(node:TreeNode)->list[list[int]]:\\n            if not node:\\n\\t\\t\\t   return []\\n            if not node.left and not node.right:\\n\\t\\t\\t   return [[node.val]]\\n\\t\\t\\t   \\n            return [[node.val]+x for x in Count(node.left) + Count(node.right)]\\n        \\n        return [x for x in Count(root) if sum(x) == targetSum]\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def pathSum(self, root: TreeNode, targetSum: int) -> list[list[int]]:\\n\\n        def Count(node:TreeNode)->list[list[int]]:\\n            if not node:\\n\\t\\t\\t   return []\\n            if not node.left and not node.right:\\n\\t\\t\\t   return [[node.val]]\\n\\t\\t\\t   \\n            return [[node.val]+x for x in Count(node.left) + Count(node.right)]\\n        \\n        return [x for x in Count(root) if sum(x) == targetSum]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994227,
                "title": "c-simple-recursive-solution-d",
                "content": "# Approach\\nThe approach is pretty simple. When we visit a non empty node, we add its value to the sum of the root-to-leaf path and push_back it into a vector, where we will store the this path. Is the root is leaf (a root is leaf if and only if both its children are nullptr) than we chech whether the path sum is equal to the target sum.\\n\\n# Complexity\\n- Time complexity: \\u041E(n), n = number of nodes in the tree. We visit each node of the tree\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode* root){\\n        return root->left == nullptr && root->right == nullptr;\\n    }\\n    void targetPath(TreeNode* root, int targetSum, int sum, vector<int>& path, vector<vector<int>>& ans){\\n        if(root == nullptr)\\n            return;\\n\\n        path.push_back(root->val);\\n        sum = sum + root->val;\\n\\n        if(isLeaf(root) && sum == targetSum)\\n            ans.push_back(path);\\n\\n        targetPath(root->left, targetSum, sum, path, ans);\\n        targetPath(root->right, targetSum, sum, path, ans);\\n        path.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        vector<vector<int> > ans;\\n        targetPath(root, targetSum, 0, path, ans);\\n        return ans;\\n    }\\n};\\n\\n```\\n\\nPlease UpVote if you like my solution. It motivates me to keep posting ;)\\nHere is my LinkedIn, if you\\'d like to connect: https://www.linkedin.com/in/elitza-yotkova-4a0a17244/",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode* root){\\n        return root->left == nullptr && root->right == nullptr;\\n    }\\n    void targetPath(TreeNode* root, int targetSum, int sum, vector<int>& path, vector<vector<int>>& ans){\\n        if(root == nullptr)\\n            return;\\n\\n        path.push_back(root->val);\\n        sum = sum + root->val;\\n\\n        if(isLeaf(root) && sum == targetSum)\\n            ans.push_back(path);\\n\\n        targetPath(root->left, targetSum, sum, path, ans);\\n        targetPath(root->right, targetSum, sum, path, ans);\\n        path.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        vector<vector<int> > ans;\\n        targetPath(root, targetSum, 0, path, ans);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649036,
                "title": "java-1-ms-beat-99-93-submission-easy-solution",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> l=new ArrayList<>();\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<Integer> list=new ArrayList<>();\\n        helper(root,targetSum,0,list);\\n        return l;\\n    }\\n        public void helper(TreeNode root,int k,int sum,List<Integer> list)\\n        {\\n            if(root==null)\\n            {\\n                return;\\n            }\\n            list.add(root.val);\\n            sum+=root.val;\\n            if(root.left==null && root.right==null)\\n            {\\n                if(sum==k)\\n                {\\n                    l.add(new ArrayList<>(list));\\n                }\\n            }\\n                helper(root.left,k,sum,list);\\n                helper(root.right,k,sum,list);\\n                list.remove(list.size()-1);\\n            }\\n     }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> l=new ArrayList<>();\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<Integer> list=new ArrayList<>();\\n        helper(root,targetSum,0,list);\\n        return l;\\n    }\\n        public void helper(TreeNode root,int k,int sum,List<Integer> list)\\n        {\\n            if(root==null)\\n            {\\n                return;\\n            }\\n            list.add(root.val);\\n            sum+=root.val;\\n            if(root.left==null && root.right==null)\\n            {\\n                if(sum==k)\\n                {\\n                    l.add(new ArrayList<>(list));\\n                }\\n            }\\n                helper(root.left,k,sum,list);\\n                helper(root.right,k,sum,list);\\n                list.remove(list.size()-1);\\n            }\\n     }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582507,
                "title": "clean-code-faster-than-99-97-solutions",
                "content": "**Please upvote , it helps a lot**\\n```\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> inner = new ArrayList<>();\\n        findans(root,targetSum,list,inner);\\n        return list;\\n    }\\n    \\n    private void findans(TreeNode root,int targetSum,List<List<Integer>> outer,\\n                 List<Integer> inner){\\n        \\n        if(root == null) return;  //base case\\n        inner.add(root.val);\\n        \\n        if(root.left == null && root.right == null && root.val == targetSum){ //base case\\n                outer.add(new ArrayList<>(inner));\\n        }else{\\n            findans(root.left,targetSum - root.val,outer,inner);\\n            findans(root.right,targetSum - root.val,outer,inner);\\n        }\\n        \\n         inner.remove(inner.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> inner = new ArrayList<>();\\n        findans(root,targetSum,list,inner);\\n        return list;\\n    }\\n    \\n    private void findans(TreeNode root,int targetSum,List<List<Integer>> outer,\\n                 List<Integer> inner){\\n        \\n        if(root == null) return;  //base case\\n        inner.add(root.val);\\n        \\n        if(root.left == null && root.right == null && root.val == targetSum){ //base case\\n                outer.add(new ArrayList<>(inner));\\n        }else{\\n            findans(root.left,targetSum - root.val,outer,inner);\\n            findans(root.right,targetSum - root.val,outer,inner);\\n        }\\n        \\n         inner.remove(inner.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382661,
                "title": "easiest-java-codes-one-using-dfs-and-other-using-bfs",
                "content": "DFS :\\n```\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> ans = new ArrayList();\\n        pathSumHelper(root,targetSum,ans,new ArrayList<Integer>());\\n        return ans;\\n    }\\n    private void pathSumHelper(TreeNode node , int sum , List<List<Integer>> ans , List<Integer> path){\\n        if(node==null) return;\\n        path.add(node.val);\\n        if(node.left==null&&node.right==null&&sum-node.val==0){\\n            List<Integer> list = new ArrayList(path);\\n            ans.add(list);\\n        }\\n        pathSumHelper(node.left,sum-node.val,ans,path);\\n        pathSumHelper(node.right,sum-node.val,ans,path);\\n        path.remove(path.size()-1);\\n    }\\n}\\n```\\n\\nBFS:\\n```\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        if(root==null) return new ArrayList();\\n        Queue<Helper> queue = new ArrayDeque();\\n        List<List<Integer>> ans = new ArrayList();\\n        queue.add(new Helper(root,targetSum,new ArrayList<Integer>()));\\n        \\n        while(queue.size()>0){\\n            Helper helper = queue.remove();\\n            List<Integer> list = helper.list;\\n            list.add(helper.node.val);\\n            if(helper.node.left==null&&helper.node.right==null&&helper.sum-helper.node.val==0){\\n                ans.add(list);\\n            }\\n            if(helper.node.left!=null){\\n                Helper left = new Helper(helper.node.left,helper.sum-helper.node.val,new ArrayList(list));\\n                queue.add(left);\\n            }\\n            if(helper.node.right!=null){\\n                Helper right = new Helper(helper.node.right,helper.sum-helper.node.val,new ArrayList(list));\\n                queue.add(right);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\nclass Helper{\\n    TreeNode node;\\n    int sum;\\n    ArrayList<Integer> list;\\n    \\n    public Helper(TreeNode node , int sum , ArrayList<Integer> list){\\n        this.node = node;\\n        this.sum = sum;\\n        this.list = list;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> ans = new ArrayList();\\n        pathSumHelper(root,targetSum,ans,new ArrayList<Integer>());\\n        return ans;\\n    }\\n    private void pathSumHelper(TreeNode node , int sum , List<List<Integer>> ans , List<Integer> path){\\n        if(node==null) return;\\n        path.add(node.val);\\n        if(node.left==null&&node.right==null&&sum-node.val==0){\\n            List<Integer> list = new ArrayList(path);\\n            ans.add(list);\\n        }\\n        pathSumHelper(node.left,sum-node.val,ans,path);\\n        pathSumHelper(node.right,sum-node.val,ans,path);\\n        path.remove(path.size()-1);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        if(root==null) return new ArrayList();\\n        Queue<Helper> queue = new ArrayDeque();\\n        List<List<Integer>> ans = new ArrayList();\\n        queue.add(new Helper(root,targetSum,new ArrayList<Integer>()));\\n        \\n        while(queue.size()>0){\\n            Helper helper = queue.remove();\\n            List<Integer> list = helper.list;\\n            list.add(helper.node.val);\\n            if(helper.node.left==null&&helper.node.right==null&&helper.sum-helper.node.val==0){\\n                ans.add(list);\\n            }\\n            if(helper.node.left!=null){\\n                Helper left = new Helper(helper.node.left,helper.sum-helper.node.val,new ArrayList(list));\\n                queue.add(left);\\n            }\\n            if(helper.node.right!=null){\\n                Helper right = new Helper(helper.node.right,helper.sum-helper.node.val,new ArrayList(list));\\n                queue.add(right);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\nclass Helper{\\n    TreeNode node;\\n    int sum;\\n    ArrayList<Integer> list;\\n    \\n    public Helper(TreeNode node , int sum , ArrayList<Integer> list){\\n        this.node = node;\\n        this.sum = sum;\\n        this.list = list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222078,
                "title": "c-dfs-4ms-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(TreeNode *root,int targetSum,int sum,vector<int> &vec)\\n    {\\n        if(!root)\\n            return;\\n        sum+=root->val;\\n        if(!root->left && !root->right)\\n        {\\n            if(sum==targetSum)\\n            {\\n                vec.push_back(root->val);\\n                \\n                res.push_back(vec);\\n                vec.pop_back() ;\\n            }\\n            return;\\n        }\\n        vec.push_back(root->val);\\n        solve(root->left,targetSum,sum,vec);\\n        solve(root->right,targetSum,sum,vec);\\n        vec.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        int sum=0;\\n        vector<int> vec ;\\n        solve(root,targetSum,sum,vec);\\n        return res;\\n    }\\n};\\n```\\n**IF YOU LIKE IT , DO UPVOTE**\\n**HAPPY CODING;**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(TreeNode *root,int targetSum,int sum,vector<int> &vec)\\n    {\\n        if(!root)\\n            return;\\n        sum+=root->val;\\n        if(!root->left && !root->right)\\n        {\\n            if(sum==targetSum)\\n            {\\n                vec.push_back(root->val);\\n                \\n                res.push_back(vec);\\n                vec.pop_back() ;\\n            }\\n            return;\\n        }\\n        vec.push_back(root->val);\\n        solve(root->left,targetSum,sum,vec);\\n        solve(root->right,targetSum,sum,vec);\\n        vec.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        int sum=0;\\n        vector<int> vec ;\\n        solve(root,targetSum,sum,vec);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909838,
                "title": "javascript-solution-faster-than-97-js-submissions-using-preorder-dfs",
                "content": "```\\nvar pathSum = function (root, sum) {\\n    if (!root) return [];\\n    const result = [];\\n    const visited = [];\\n    function traverse(node) {\\n        visited.push(node.val);\\n        if (!node.left && !node.right) {\\n            const leafSum = [...visited].reduce((a, b) => a+b);\\n            if (leafSum === sum) result.push([...visited]);\\n        }\\n        if (node.left) {\\n            traverse(node.left);\\n        }\\n        if (node.right) {\\n            traverse(node.right);\\n        }\\n        visited.pop();\\n    }\\n    traverse(root);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pathSum = function (root, sum) {\\n    if (!root) return [];\\n    const result = [];\\n    const visited = [];\\n    function traverse(node) {\\n        visited.push(node.val);\\n        if (!node.left && !node.right) {\\n            const leafSum = [...visited].reduce((a, b) => a+b);\\n            if (leafSum === sum) result.push([...visited]);\\n        }\\n        if (node.left) {\\n            traverse(node.left);\\n        }\\n        if (node.right) {\\n            traverse(node.right);\\n        }\\n        visited.pop();\\n    }\\n    traverse(root);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 860760,
                "title": "c-dfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n        vector<vector<int>> res;\\n        vector<int> pathVals;\\n        accumulateTreeSum(root, sum, res, pathVals);\\n        return res;\\n    }\\n    \\n    void accumulateTreeSum(TreeNode *currentNode, int sumByFar, vector<vector<int>> &res, vector<int> &pathVals) {\\n        if (!currentNode) {\\n            return;\\n        }\\n        sumByFar -= currentNode->val;\\n        pathVals.push_back(currentNode->val);\\n        // If we are at the leaf node\\n        if (!currentNode->right && !currentNode->left && sumByFar == 0) {\\n            res.push_back(pathVals);\\n        }\\n        accumulateTreeSum(currentNode->left, sumByFar, res, pathVals);\\n        accumulateTreeSum(currentNode->right, sumByFar, res, pathVals);\\n        pathVals.pop_back(); // Backtracking\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n        vector<vector<int>> res;\\n        vector<int> pathVals;\\n        accumulateTreeSum(root, sum, res, pathVals);\\n        return res;\\n    }\\n    \\n    void accumulateTreeSum(TreeNode *currentNode, int sumByFar, vector<vector<int>> &res, vector<int> &pathVals) {\\n        if (!currentNode) {\\n            return;\\n        }\\n        sumByFar -= currentNode->val;\\n        pathVals.push_back(currentNode->val);\\n        // If we are at the leaf node\\n        if (!currentNode->right && !currentNode->left && sumByFar == 0) {\\n            res.push_back(pathVals);\\n        }\\n        accumulateTreeSum(currentNode->left, sumByFar, res, pathVals);\\n        accumulateTreeSum(currentNode->right, sumByFar, res, pathVals);\\n        pathVals.pop_back(); // Backtracking\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286486,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> PathSum(TreeNode root, int sum) {\\n        var result = new List<IList<int>>();\\n        DFS(root, sum, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(TreeNode root, int sum, IList<int> oneResult, IList<IList<int>> result) {\\n        if (root == null) return;\\n        oneResult.Add(root.val);\\n        if (root.left == null && root.right == null) {\\n            if (sum == root.val) {\\n                result.Add(new List<int>(oneResult));\\n            }\\n        } else {\\n            DFS(root.left, sum - root.val, oneResult, result);\\n            DFS(root.right, sum - root.val, oneResult, result);\\n        }\\n        oneResult.RemoveAt(oneResult.Count - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> PathSum(TreeNode root, int sum) {\\n        var result = new List<IList<int>>();\\n        DFS(root, sum, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(TreeNode root, int sum, IList<int> oneResult, IList<IList<int>> result) {\\n        if (root == null) return;\\n        oneResult.Add(root.val);\\n        if (root.left == null && root.right == null) {\\n            if (sum == root.val) {\\n                result.Add(new List<int>(oneResult));\\n            }\\n        } else {\\n            DFS(root.left, sum - root.val, oneResult, result);\\n            DFS(root.right, sum - root.val, oneResult, result);\\n        }\\n        oneResult.RemoveAt(oneResult.Count - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36906,
                "title": "my-accepted-java-solution",
                "content": "The basic idea is to find every correct path and create a list for them. After searching the left child and right child of the root, merge two lists.\\n\\n\\n    /**\\n     * Definition for binary tree\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n            List<List<Integer>> pathList = new ArrayList<List<Integer>>();\\n    \\t\\tif(root==null){\\n    \\t\\t\\treturn pathList;\\n    \\t\\t}\\n            if(root.left==null&&root.right==null){//if find a path, create a new list and add to the pathList.\\n            \\tif(root.val==sum){\\n    \\t        \\tList<Integer> list = new ArrayList<Integer>();\\n    \\t        \\tlist.add(root.val);\\n    \\t        \\tpathList.add(list);\\n            \\t}\\n            \\treturn pathList;\\n            }\\n            //find path left and right child and merge two list together.\\n            pathList = pathSum(root.left, sum-root.val);\\n            List<List<Integer>> pathList_right = pathSum(root.right, sum-root.val);\\n            for(List<Integer> l:pathList_right){\\n            \\tpathList.add(l);\\n            }\\n            //add current root to every list in path list.\\n            for(List<Integer> l:pathList){\\n            \\tl.add(0, root.val);\\n            }\\n            return pathList;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n            List<List<Integer>> pathList = new ArrayList<List<Integer>>();\\n    \\t\\tif(root==null){\\n    \\t\\t\\treturn pathList;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 36953,
                "title": "should-python-be-given-more-time",
                "content": "I use the same algorithms, but accepted in Java and TLE in Python.\\n\\nSince OJ is to practice the algorithms, they should be accepted or denied at the same time.\\nRight?\\n\\nHere is my algorithms in both languages:\\n\\nJava:\\n\\n    public class Solution {\\n        public ArrayList<Integer> stack;\\n        public ArrayList<ArrayList<Integer>> res;\\n        public void search(TreeNode root, int sum) {\\n            if (root == null) return;\\n            stack.add(root.val);\\n            if ((root.left == null) && (root.right == null)) {\\n                if (root.val == sum) {\\n                    ArrayList<Integer> ans = new ArrayList<Integer>();\\n                    for (Integer item: stack) ans.add(item);\\n                    res.add(ans);\\n                }\\n            } else {\\n                search(root.left, sum - root.val);\\n                search(root.right, sum - root.val);\\n            }\\n            stack.remove(stack.size() - 1);\\n        }\\n        public ArrayList<ArrayList<Integer>> pathSum(TreeNode root, int sum) {\\n            stack = new ArrayList<Integer>();\\n            res = new ArrayList<ArrayList<Integer>>();\\n            search(root, sum);\\n            return res;\\n        }\\n    }\\n\\nAnd Python:\\n\\n    class Solution:\\n    # @param root, a tree node\\n    # @param sum, an integer\\n    # @return a list of lists of integers\\n    def pathSum(self, root, sum):\\n        stack = []\\n        res = []\\n        def search(root, sum):\\n            if (root == None) or (root.val > sum): return\\n            stack.append(root.val)\\n            if (root.left == None) and (root.right == None):\\n                if root.val == sum:\\n                    res.append(list(stack)) # copy stack to res\\n            else:\\n                search(root.left, sum - root.val)\\n                search(root.right, sum - root.val)\\n            stack.pop()\\n        search(root, sum)\\n        return res",
                "solutionTags": [],
                "code": "class Solution {\\n        public ArrayList<Integer> stack;\\n        public ArrayList<ArrayList<Integer>> res;\\n        public void search(TreeNode root, int sum) {\\n            if (root == null) return;\\n            stack.add(root.val);\\n            if ((root.left == null) && (root.right == null)) {\\n                if (root.val == sum) {\\n                    ArrayList<Integer> ans = new ArrayList<Integer>();\\n                    for (Integer item: stack) ans.add(item);\\n                    res.add(ans);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4087962,
                "title": "best-o-n-solution",
                "content": "# Approach\\nDFS Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int targetSum, int curSum, \\n    vector<int>& curPath, vector<vector<int>>& paths) {\\n        if (!root)\\n            return;\\n        curPath.push_back(root->val);    \\n        if (!root->left && !root->right) {\\n            if (targetSum == (curSum + root->val)) \\n                paths.push_back(curPath);\\n        }\\n        traversal(root->left, targetSum, curSum + root->val, curPath, paths);\\n        traversal(root->right, targetSum, curSum + root->val, curPath, paths);\\n        curPath.pop_back();\\n    }\\n\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> paths;\\n        vector<int> curPath;\\n        int curSum = 0;\\n        traversal(root, targetSum, curSum, curPath, paths);\\n\\n        return paths;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void traversal(TreeNode* root, int targetSum, int curSum, \\n    vector<int>& curPath, vector<vector<int>>& paths) {\\n        if (!root)\\n            return;\\n        curPath.push_back(root->val);    \\n        if (!root->left && !root->right) {\\n            if (targetSum == (curSum + root->val)) \\n                paths.push_back(curPath);\\n        }\\n        traversal(root->left, targetSum, curSum + root->val, curPath, paths);\\n        traversal(root->right, targetSum, curSum + root->val, curPath, paths);\\n        curPath.pop_back();\\n    }\\n\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> paths;\\n        vector<int> curPath;\\n        int curSum = 0;\\n        traversal(root, targetSum, curSum, curPath, paths);\\n\\n        return paths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631601,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root, int targetSum ,  vector<int> path , vector<vector<int>> &ans){\\n        if(root == NULL)\\n            return ;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right==NULL){\\n            long int sum = 0;\\n            int size = path.size();\\n            for(int i = size-1 ; i >=0 ; i--){\\n                sum += path[i];\\n            }\\n            if(sum == targetSum)\\n                ans.push_back(path);\\n        }\\n        solve(root->left , targetSum , path , ans);\\n        solve(root->right , targetSum , path , ans);\\n        \\n        path.pop_back();\\n    }\\n\\n    public:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        solve(root , targetSum , path , ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root, int targetSum ,  vector<int> path , vector<vector<int>> &ans){\\n        if(root == NULL)\\n            return ;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right==NULL){\\n            long int sum = 0;\\n            int size = path.size();\\n            for(int i = size-1 ; i >=0 ; i--){\\n                sum += path[i];\\n            }\\n            if(sum == targetSum)\\n                ans.push_back(path);\\n        }\\n        solve(root->left , targetSum , path , ans);\\n        solve(root->right , targetSum , path , ans);\\n        \\n        path.pop_back();\\n    }\\n\\n    public:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        solve(root , targetSum , path , ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631588,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root, int targetSum ,  vector<int> path , vector<vector<int>> &ans){\\n        if(root == NULL)\\n            return ;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right==NULL){\\n            long int sum = 0;\\n            int size = path.size();\\n            for(int i = size-1 ; i >=0 ; i--){\\n                sum += path[i];\\n            }\\n            if(sum == targetSum)\\n                ans.push_back(path);\\n        }\\n        solve(root->left , targetSum , path , ans);\\n        solve(root->right , targetSum , path , ans);\\n        \\n        path.pop_back();\\n    }\\n\\n    public:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        solve(root , targetSum , path , ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root, int targetSum ,  vector<int> path , vector<vector<int>> &ans){\\n        if(root == NULL)\\n            return ;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right==NULL){\\n            long int sum = 0;\\n            int size = path.size();\\n            for(int i = size-1 ; i >=0 ; i--){\\n                sum += path[i];\\n            }\\n            if(sum == targetSum)\\n                ans.push_back(path);\\n        }\\n        solve(root->left , targetSum , path , ans);\\n        solve(root->right , targetSum , path , ans);\\n        \\n        path.pop_back();\\n    }\\n\\n    public:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        solve(root , targetSum , path , ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194344,
                "title": "with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe solution uses a depth-first search (DFS) approach to traverse the binary tree and check for root-to-leaf paths that sum up to the given target sum.\\n\\nThe pathSum function initializes an empty list result to store the valid paths and an empty list path to track the current path being traversed. It then calls the dfs helper function, passing in the root node, target sum, path, and result.\\n\\nThe dfs function first checks if the current node is None. If it is, then it returns. Otherwise, it appends the current node value to the path.\\n\\nIf the current node is a leaf node (i.e., it has no left or right child nodes) and its value is equal to the target sum, then the current path is added to the result list.\\n\\nOtherwise, the dfs function calls itself recursively on the left and right child nodes, subtracting the current node value from the target sum. When the recursive calls have completed, the current node is popped from the path.\\n\\nThe final result list is returned to the calling function after all nodes have been traversed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        result = []\\n        path = []\\n        self.dfs(root, targetSum, path, result)\\n        return result\\n\\n    def dfs(self, node, target, path, result):\\n        if not node:\\n            return\\n        path.append(node.val)\\n        if not node.left and not node.right and node.val == target:\\n            result.append(path[:])\\n        self.dfs(node.left, target - node.val, path, result)\\n        self.dfs(node.right, target - node.val, path, result)\\n        path.pop()\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        result = []\\n        path = []\\n        self.dfs(root, targetSum, path, result)\\n        return result\\n\\n    def dfs(self, node, target, path, result):\\n        if not node:\\n            return\\n        path.append(node.val)\\n        if not node.left and not node.right and node.val == target:\\n            result.append(path[:])\\n        self.dfs(node.left, target - node.val, path, result)\\n        self.dfs(node.right, target - node.val, path, result)\\n        path.pop()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080122,
                "title": "1ms-100-faster-java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>>res =new ArrayList<>();\\n        List<Integer>ar=new ArrayList<>();\\n\\n        solve(root,targetSum,res,ar);\\n        return res;\\n        \\n    }\\n\\n    public void solve(TreeNode root,int targetSum,List<List<Integer>>res,List<Integer>ar){\\n        if(root==null){\\n            return;\\n        }\\n        \\n        if(root.left==null && root.right==null){\\n            if(targetSum==root.val){\\n                ArrayList<Integer>base=new ArrayList<>(ar);\\n                base.add(root.val);\\n                res.add(base);\\n            }\\n            return; \\n        }\\n\\n        ar.add(root.val);\\n        solve(root.left,targetSum-root.val,res,ar);\\n        solve(root.right,targetSum-root.val,res,ar);\\n        ar.remove(ar.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>>res =new ArrayList<>();\\n        List<Integer>ar=new ArrayList<>();\\n\\n        solve(root,targetSum,res,ar);\\n        return res;\\n        \\n    }\\n\\n    public void solve(TreeNode root,int targetSum,List<List<Integer>>res,List<Integer>ar){\\n        if(root==null){\\n            return;\\n        }\\n        \\n        if(root.left==null && root.right==null){\\n            if(targetSum==root.val){\\n                ArrayList<Integer>base=new ArrayList<>(ar);\\n                base.add(root.val);\\n                res.add(base);\\n            }\\n            return; \\n        }\\n\\n        ar.add(root.val);\\n        solve(root.left,targetSum-root.val,res,ar);\\n        solve(root.right,targetSum-root.val,res,ar);\\n        ar.remove(ar.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617153,
                "title": "c-simplest-way",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tvector<vector<int>> ans;\\n    \\n    void solve(TreeNode* root, int t, vector<int>v){\\n        \\n        if(!root) return;\\n        \\n        v.push_back(root->val);                      //push root->val in vector\\n        t=t-root->val;                               //update target\\n        if(!root->left && !root->right && t==0){     //if reached leaf node and target = 0\\n            ans.push_back(v);                        //push in ans\\n        } \\n        \\n        solve(root->left,t,v);\\n        solve(root->right,t,v);\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        if(!root) return ans;\\n        vector<int> v;\\n        solve(root,targetSum,v);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tvector<vector<int>> ans;\\n    \\n    void solve(TreeNode* root, int t, vector<int>v){\\n        \\n        if(!root) return;\\n        \\n        v.push_back(root->val);                      //push root->val in vector\\n        t=t-root->val;                               //update target\\n        if(!root->left && !root->right && t==0){     //if reached leaf node and target = 0\\n            ans.push_back(v);                        //push in ans\\n        } \\n        \\n        solve(root->left,t,v);\\n        solve(root->right,t,v);\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        if(!root) return ans;\\n        vector<int> v;\\n        solve(root,targetSum,v);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2617071,
                "title": "a-efficient-javascript-solution-recursion-easy-to-understand",
                "content": "```\\nvar pathSum = function(root, targetSum) {\\n    const ans = [];\\n  \\n  const fun = (node, path, sum) => {\\n    \\n    if (!node) return;\\n      \\n    if (!node.left && !node.right) {\\n      if (sum === node.val) {\\n        ans.push([...path, node.val]);\\n      }\\n      return;\\n    }\\n    \\n    fun(node.left, [...path, node.val], sum - node.val);\\n    fun(node.right, [...path, node.val], sum - node.val);\\n  };\\n  \\n  fun(root, [], targetSum);\\n  \\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar pathSum = function(root, targetSum) {\\n    const ans = [];\\n  \\n  const fun = (node, path, sum) => {\\n    \\n    if (!node) return;\\n      \\n    if (!node.left && !node.right) {\\n      if (sum === node.val) {\\n        ans.push([...path, node.val]);\\n      }\\n      return;\\n    }\\n    \\n    fun(node.left, [...path, node.val], sum - node.val);\\n    fun(node.right, [...path, node.val], sum - node.val);\\n  };\\n  \\n  fun(root, [], targetSum);\\n  \\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2518790,
                "title": "c-dfs-easy-understanding-solution-highly-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> ans;\\n    \\n    void f(TreeNode *root, int target, vector<int> &v){\\n        \\n\\t\\t//return if root is null\\n        if(!root) return;\\n        \\n\\t\\t//if it is a leaf node we insert it\\'s value in our vector \\'v\\' push the answer to vector \\'ans\\' and pop back \\'v\\' again to backtrack\\n        if(root->left==NULL && root->right==NULL && target-root->val==0){\\n            v.push_back(root->val);\\n            ans.push_back(v);\\n            v.pop_back();\\n            return;\\n        }\\n        \\n\\t\\t//we have two choices \\n\\t\\t//either to take left node path or to take right node path\\n        //In case we take the left node path we insert it into the vector \\'v\\' in case it may come out to be the answer\\n\\t\\tv.push_back(root->val);\\n\\t\\t\\n\\t\\t//traverse left in the tree\\n        f(root->left, target-root->val, v);\\n\\t\\t\\n\\t\\t//this is the backtracking part. If the path existed then it would have been taken care of by our custom base case\\n\\t\\t//we are passing vector \\'v\\' as a reference thats\\'s why we are taking care of it while we are backtracking. It also reduces the space complexity and time complexity.\\n        v.pop_back();\\n\\t\\t\\n\\t\\t//same again we repeat fot the right part\\n\\t\\t//push right part value to vector\\n        v.push_back(root->val);\\n\\t\\t\\n\\t\\t//traverse into the right part\\n        f(root->right, target-root->val, v);\\n\\t\\t\\n\\t\\t//backtrack\\n        v.pop_back();\\n        \\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        \\n        vector<int> v;\\n        f(root, targetSum, v);        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> ans;\\n    \\n    void f(TreeNode *root, int target, vector<int> &v){\\n        \\n\\t\\t//return if root is null\\n        if(!root) return;\\n        \\n\\t\\t//if it is a leaf node we insert it\\'s value in our vector \\'v\\' push the answer to vector \\'ans\\' and pop back \\'v\\' again to backtrack\\n        if(root->left==NULL && root->right==NULL && target-root->val==0){\\n            v.push_back(root->val);\\n            ans.push_back(v);\\n            v.pop_back();\\n            return;\\n        }\\n        \\n\\t\\t//we have two choices \\n\\t\\t//either to take left node path or to take right node path\\n        //In case we take the left node path we insert it into the vector \\'v\\' in case it may come out to be the answer\\n\\t\\tv.push_back(root->val);\\n\\t\\t\\n\\t\\t//traverse left in the tree\\n        f(root->left, target-root->val, v);\\n\\t\\t\\n\\t\\t//this is the backtracking part. If the path existed then it would have been taken care of by our custom base case\\n\\t\\t//we are passing vector \\'v\\' as a reference thats\\'s why we are taking care of it while we are backtracking. It also reduces the space complexity and time complexity.\\n        v.pop_back();\\n\\t\\t\\n\\t\\t//same again we repeat fot the right part\\n\\t\\t//push right part value to vector\\n        v.push_back(root->val);\\n\\t\\t\\n\\t\\t//traverse into the right part\\n        f(root->right, target-root->val, v);\\n\\t\\t\\n\\t\\t//backtrack\\n        v.pop_back();\\n        \\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        \\n        vector<int> v;\\n        f(root, targetSum, v);        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435513,
                "title": "trust-recursion-my-friends",
                "content": "**Solution -->**\\n```\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode* root){\\n        if(root->left==NULL && root->right==NULL) return true;\\n        return false;\\n    }\\n    void DFS_preorder(TreeNode* root, int targetSum,vector<vector<int>>& ans,int sum,vector<int> temp){\\n        if(root==NULL) return;\\n        \\n        sum+=root->val;\\n        temp.push_back(root->val);\\n        \\n        if(isLeaf(root)) {\\n            if(sum==targetSum){\\n                ans.push_back(temp);\\n            }\\n        }\\n        DFS_preorder(root->left,targetSum,ans,sum,temp);\\n        DFS_preorder(root->right,targetSum,ans,sum,temp);\\n        \\n        return;\\n\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        DFS_preorder(root, targetSum,ans,0,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode* root){\\n        if(root->left==NULL && root->right==NULL) return true;\\n        return false;\\n    }\\n    void DFS_preorder(TreeNode* root, int targetSum,vector<vector<int>>& ans,int sum,vector<int> temp){\\n        if(root==NULL) return;\\n        \\n        sum+=root->val;\\n        temp.push_back(root->val);\\n        \\n        if(isLeaf(root)) {\\n            if(sum==targetSum){\\n                ans.push_back(temp);\\n            }\\n        }\\n        DFS_preorder(root->left,targetSum,ans,sum,temp);\\n        DFS_preorder(root->right,targetSum,ans,sum,temp);\\n        \\n        return;\\n\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        DFS_preorder(root, targetSum,ans,0,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018546,
                "title": "c-recursive-approach",
                "content": "**Recursive approach in binary trees:**\\n\\n- Intuition\\n\\n\\t- Initialize an array of size 5000 as we have maximum 5000 nodes\\n\\t- Create a function **recursionTraverse** with arguments of answer vector, path array, initial path length (always 0), root node and the target sum, this function will:\\n\\n\\t\\t- return if node is NULL\\n\\t\\t- else we have to increment the pathLen after assigning the path[pathLen] as value of current node which indicates the node at a particular level in the tree\\n\\t\\t- if we encounter the leaf node then we have to calculate the sum of all nodes in the path by checking whether it is equal to _targetSum_ and store the path in the vector that we passed as an argument\\n\\t\\t- if we don\\'t have a leaf node then we have to traverse through the left and right subtrees associated with current node which can be done by calling the same function on left and right subtrees respectively\\n\\n\\t- Further we have to just call the function by initialzing the answer array and simply return our answer.\\n\\n\\n\\n\\n\\n\\t\\t\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\tvoid recursionTraverse(TreeNode *root, int path[], int pathLen, vector<vector<int>> &ans, int targetSum){\\n\\t\\t\\t\\t\\t//if root is null then return\\n\\t\\t\\t\\t\\tif(root==NULL){\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// else we have to initialize the current node\\'s data to the index represented by pathLen which is same as the level of the node in a binary tree\\n\\t\\t\\t\\tpath[pathLen] = root->val;\\n\\t\\t\\t\\tpathLen++;\\n\\n\\t\\t\\t\\t//if we find a leaf node then we have to stop and check whether the sum of nodes in this path is satisfying the condition and accordingly append the answer\\n\\t\\t\\t\\tif(root->left==NULL && root->right==NULL){\\n\\t\\t\\t\\t\\tvector<int> v;\\n\\t\\t\\t\\t\\tint s=0;\\n\\t\\t\\t\\t\\tfor(int i=0;i<pathLen;i++){\\n\\t\\t\\t\\t\\t\\ts+=path[i];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(s==targetSum){\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<pathLen;i++){\\n\\t\\t\\t\\t\\t\\tv.push_back(path[i]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tans.push_back(v);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//else we have to move to right and left sub trees\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\trecursionTraverse(root->left, path, pathLen, ans, targetSum);\\n\\t\\t\\t\\t\\trecursionTraverse(root->right, path, pathLen, ans, targetSum);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n\\t\\t\\t\\tvector<vector<int>> ans;\\n\\t\\t\\t\\t//initialize an array with size 5000 as we have maximum 5000 nodes\\n\\t\\t\\t\\tint path[5000];\\n\\t\\t\\t\\trecursionTraverse(root, path, 0, ans, targetSum);\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\tvoid recursionTraverse(TreeNode *root, int path[], int pathLen, vector<vector<int>> &ans, int targetSum){\\n\\t\\t\\t\\t\\t//if root is null then return\\n\\t\\t\\t\\t\\tif(root==NULL){\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1203026,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def path(self, node, res, target, path):\\n        if(node.left is None and node.right is None and node.val==target):\\n            res.append(path+[node.val])\\n        if(node.left):\\n            self.path(node.left, res, target-node.val, path+[node.val])\\n        if(node.right):\\n            self.path(node.right, res, target-node.val, path+[node.val])\\n        return res\\n    \\n    def pathSum(self, root, targetSum):\\n        if(root is None):\\n            return []\\n        return self.path(root, [], targetSum, [])\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def path(self, node, res, target, path):\\n        if(node.left is None and node.right is None and node.val==target):\\n            res.append(path+[node.val])\\n        if(node.left):\\n            self.path(node.left, res, target-node.val, path+[node.val])\\n        if(node.right):\\n            self.path(node.right, res, target-node.val, path+[node.val])\\n        return res\\n    \\n    def pathSum(self, root, targetSum):\\n        if(root is None):\\n            return []\\n        return self.path(root, [], targetSum, [])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058857,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> paths;\\n    void findPaths(TreeNode* node, int target, int curr, vector<int> &path) {\\n        if (node == NULL)\\n            return;\\n        curr += node->val;\\n        path.push_back(node->val);\\n        if (curr == target && node->left == node->right)\\n            paths.push_back(path);\\n        findPaths(node->left, target, curr, path);\\n        findPaths(node->right, target, curr, path);\\n        path.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        findPaths(root, targetSum, 0, path);\\n        return paths;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> paths;\\n    void findPaths(TreeNode* node, int target, int curr, vector<int> &path) {\\n        if (node == NULL)\\n            return;\\n        curr += node->val;\\n        path.push_back(node->val);\\n        if (curr == target && node->left == node->right)\\n            paths.push_back(path);\\n        findPaths(node->left, target, curr, path);\\n        findPaths(node->right, target, curr, path);\\n        path.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        findPaths(root, targetSum, 0, path);\\n        return paths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782572,
                "title": "python-dfs-simple-and-clean-solution",
                "content": "```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\\n        self.res = []\\n        self.dfs(root, sum, 0, [])\\n        return self.res\\n            \\n    def dfs(self, root:TreeNode, target:int, prev_sum:int, my_list:list):\\n        if not root:\\n            return\\n        prev_sum += root.val\\n        my_list.append(root.val)\\n       \\n        if prev_sum == target and root.left == None and root.right == None:\\n            self.res.append(my_list[:])\\n        \\n        self.dfs(root.left, target, prev_sum, my_list)\\n        self.dfs(root.right, target, prev_sum, my_list)\\n        my_list.pop()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\\n        self.res = []\\n        self.dfs(root, sum, 0, [])\\n        return self.res\\n            \\n    def dfs(self, root:TreeNode, target:int, prev_sum:int, my_list:list):\\n        if not root:\\n            return\\n        prev_sum += root.val\\n        my_list.append(root.val)\\n       \\n        if prev_sum == target and root.left == None and root.right == None:\\n            self.res.append(my_list[:])\\n        \\n        self.dfs(root.left, target, prev_sum, my_list)\\n        self.dfs(root.right, target, prev_sum, my_list)\\n        my_list.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683031,
                "title": "javascript-easy-with-explanation",
                "content": "```\\nvar pathSum = function(root, sum) {\\n    const res = [];\\n\\t// helper recursive function\\n    const helper = (node, total, arr) => {\\n        if(!node) return;\\n        if(node.val === total && !node.left && !node.right) {\\n            arr.push(node.val);\\n            res.push(arr.slice());\\n            arr.pop();\\n            return;\\n        }\\n\\t\\t// add current element into the array\\n        arr.push(node.val);\\n\\t\\t// visit left branch\\n        helper(node.left, total - node.val, arr)\\n\\t\\t// visit right branch\\n        helper(node.right, total - node.val, arr);\\n\\t\\t// backtrack \\n        arr.pop()\\n    }\\n  // invoke helper function and return result array\\n    helper(root, sum, []);  \\n    return res;\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar pathSum = function(root, sum) {\\n    const res = [];\\n\\t// helper recursive function\\n    const helper = (node, total, arr) => {\\n        if(!node) return;\\n        if(node.val === total && !node.left && !node.right) {\\n            arr.push(node.val);\\n            res.push(arr.slice());\\n            arr.pop();\\n            return;\\n        }\\n\\t\\t// add current element into the array\\n        arr.push(node.val);\\n\\t\\t// visit left branch\\n        helper(node.left, total - node.val, arr)\\n\\t\\t// visit right branch\\n        helper(node.right, total - node.val, arr);\\n\\t\\t// backtrack \\n        arr.pop()\\n    }\\n  // invoke helper function and return result array\\n    helper(root, sum, []);  \\n    return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328125,
                "title": "simple-python-solution-top-down-dfs",
                "content": "Please see and vote for my solutions for these similar problems.\\n\\n[257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/discuss/309004/Different-DFS-Python-solutions)\\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\\n\\n[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/328123/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/discuss/328033/Top-down-Python-DFS-Solution)\\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[988. Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/328119/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\\n\\n[112. Path Sum](https://leetcode.com/problems/path-sum/discuss/328124/Simple-Python-Solution%3A-top-down-DFS)\\n\\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\\n\\n[113. Path Sum II](https://leetcode.com/problems/path-sum-ii/discuss/328125/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\\n\\n[437. Path Sum III](https://leetcode.com/problems/path-sum-iii/discuss/328128/Simple-Python-Solution%3A-top-down-DFS-%2B-DP) (Similar problem: 560. Subarray Sum Equals K)\\n\\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 327177,
                "title": "113-python-iterative-and-recursive",
                "content": "Python iterative solution (DFS) with run time O(T), space O(T)\\n\\n```\\n    # iterative\\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\\n        ans = []\\n        if not root:\\n            return ans\\n        stack = [(root, root.val, [root.val])] # stack stored with (root, sum, path)\\n        while stack:\\n            cur, Sum, path = stack.pop()\\n            if not cur.left and not cur.right:\\n                if Sum == sum:\\n                    ans.append(path)\\n            else:\\n                if cur.right:\\n                    stack.append((cur.right, Sum+cur.right.val, path+[cur.right.val]))                \\n                if cur.left:\\n                    stack.append((cur.left, Sum+cur.left.val, path+[cur.left.val]))\\n        return ans\\n```\\n\\nPython revursive solution (you can also call this as backtrack) with run time O(T), space O(T)\\n\\n```\\n    # recursive\\n    def __init__(self):\\n        self.ans = []\\n\\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\\n        self.sum = sum\\n        if not root:\\n            return self.ans\\n        self.helper([root.val], root, root.val)\\n        return self.ans\\n    def helper(self, path, root, Sum):\\n        # print(path, root.val, Sum)\\n        if not root.left and not root.right:\\n            if Sum == self.sum:\\n                self.ans.append(path)\\n        else:\\n            if root.left:\\n                self.helper(path+[root.left.val], root.left, Sum+root.left.val)\\n            if root.right:\\n                self.helper(path+[root.right.val], root.right, Sum+root.right.val)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    # iterative\\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\\n        ans = []\\n        if not root:\\n            return ans\\n        stack = [(root, root.val, [root.val])] # stack stored with (root, sum, path)\\n        while stack:\\n            cur, Sum, path = stack.pop()\\n            if not cur.left and not cur.right:\\n                if Sum == sum:\\n                    ans.append(path)\\n            else:\\n                if cur.right:\\n                    stack.append((cur.right, Sum+cur.right.val, path+[cur.right.val]))                \\n                if cur.left:\\n                    stack.append((cur.left, Sum+cur.left.val, path+[cur.left.val]))\\n        return ans\\n```\n```\\n    # recursive\\n    def __init__(self):\\n        self.ans = []\\n\\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\\n        self.sum = sum\\n        if not root:\\n            return self.ans\\n        self.helper([root.val], root, root.val)\\n        return self.ans\\n    def helper(self, path, root, Sum):\\n        # print(path, root.val, Sum)\\n        if not root.left and not root.right:\\n            if Sum == self.sum:\\n                self.ans.append(path)\\n        else:\\n            if root.left:\\n                self.helper(path+[root.left.val], root.left, Sum+root.left.val)\\n            if root.right:\\n                self.helper(path+[root.right.val], root.right, Sum+root.right.val)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 180804,
                "title": "simple-bfs-solution-in-c",
                "content": "Just provide an alternative using BFS in C++.\\n```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> pathSum(TreeNode* root, int sum) {\\n\\t\\tif (!root) return vector<vector<int>>{};\\n\\t\\tvector<vector<int>> rc;\\n\\t\\tqueue<tuple<TreeNode*, vector<int>, int> > q;\\n\\t\\tq.push({ root, vector<int>{}, sum });\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tauto cur = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\tTreeNode *&curNode = get<0>(cur);\\n\\t\\t\\tget<1>(cur).push_back(curNode->val);\\n\\t\\t\\tif (curNode->val == get<2>(cur) && !curNode->left && !curNode->right) \\n\\t\\t\\t\\trc.push_back(get<1>(cur));\\n\\t\\t\\tif (curNode->left) q.push({ curNode->left, get<1>(cur), get<2>(cur) - curNode->val });\\n\\t\\t\\tif (curNode->right) q.push({ curNode->right, get<1>(cur), get<2>(cur) - curNode->val });\\n\\t\\t}\\n\\t\\treturn rc;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> pathSum(TreeNode* root, int sum) {\\n\\t\\tif (!root) return vector<vector<int>>{};\\n\\t\\tvector<vector<int>> rc;\\n\\t\\tqueue<tuple<TreeNode*, vector<int>, int> > q;\\n\\t\\tq.push({ root, vector<int>{}, sum });\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tauto cur = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\tTreeNode *&curNode = get<0>(cur);\\n\\t\\t\\tget<1>(cur).push_back(curNode->val);\\n\\t\\t\\tif (curNode->val == get<2>(cur) && !curNode->left && !curNode->right) \\n\\t\\t\\t\\trc.push_back(get<1>(cur));\\n\\t\\t\\tif (curNode->left) q.push({ curNode->left, get<1>(cur), get<2>(cur) - curNode->val });\\n\\t\\t\\tif (curNode->right) q.push({ curNode->right, get<1>(cur), get<2>(cur) - curNode->val });\\n\\t\\t}\\n\\t\\treturn rc;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164255,
                "title": "python-solution",
                "content": "recursion: \\n```\\nclass Solution(object):\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root:\\n            return []\\n        elif not root.left and not root.right:\\n            if root.val == sum:\\n                return [[root.val]]\\n            else:\\n                return []\\n        l = self.pathSum(root.left, sum - root.val)\\n        r = self.pathSum(root.right, sum - root.val)\\n        resL = [[root.val]+x for x in l]\\n        resR = [[root.val]+x for x in r]\\n        return resL + resR\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root:\\n            return []\\n        elif not root.left and not root.right:\\n            if root.val == sum:\\n                return [[root.val]]\\n            else:\\n                return []\\n        l = self.pathSum(root.left, sum - root.val)\\n        r = self.pathSum(root.right, sum - root.val)\\n        resL = [[root.val]+x for x in l]\\n        resR = [[root.val]+x for x in r]\\n        return resL + resR\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162823,
                "title": "logical-thinking-with-code-beats-100",
                "content": "**Logical Thinking**\\nThe current TreeNode and the current target sum can identify a state uniquely.\\n```\\n\\t\\t           state(node, targetSum)\\n\\t\\t\\t\\t/          \\\\\\nstate(node.left, targetSum - node.val)  state(node.right, targetSum - node.val)\\n```\\nWe keep track of the `path` on the fly.\\nOur final state is `state(leaf, x)`. If `x` turned out to be `0`, we add `path` to `result`. Else, we simply backtrack.\\n**Clear Code**\\n```\\n    List<List<Integer>> result;\\n\\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        result = new ArrayList<>();\\n        if (root == null)\\n            return result;\\n        hasPathSumFrom(root, sum, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void hasPathSumFrom(TreeNode root, int sum, List<Integer> path) {\\n        \\n        path.add(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            if (sum == root.val) {\\n                result.add(new ArrayList<>(path));\\n            }\\n            return;\\n        }\\n        \\n        if (root.left != null) {\\n            hasPathSumFrom(root.left, sum - root.val, path);\\n            path.remove(path.size() - 1);\\n        }\\n        \\n        if (root.right != null) {\\n            hasPathSumFrom(root.right, sum - root.val, path);\\n            path.remove(path.size() - 1);\\n        }\\n\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n\\t\\t           state(node, targetSum)\\n\\t\\t\\t\\t/          \\\\\\nstate(node.left, targetSum - node.val)  state(node.right, targetSum - node.val)\\n```\n```\\n    List<List<Integer>> result;\\n\\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        result = new ArrayList<>();\\n        if (root == null)\\n            return result;\\n        hasPathSumFrom(root, sum, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void hasPathSumFrom(TreeNode root, int sum, List<Integer> path) {\\n        \\n        path.add(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            if (sum == root.val) {\\n                result.add(new ArrayList<>(path));\\n            }\\n            return;\\n        }\\n        \\n        if (root.left != null) {\\n            hasPathSumFrom(root.left, sum - root.val, path);\\n            path.remove(path.size() - 1);\\n        }\\n        \\n        if (root.right != null) {\\n            hasPathSumFrom(root.right, sum - root.val, path);\\n            path.remove(path.size() - 1);\\n        }\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 111110,
                "title": "javascript-clean-solution",
                "content": "```\\nvar pathSum = function(root, sum) {\\n    let res = [];\\n    function helper(node, cur, arr){\\n        if(!node) return;\\n        arr.push(node.val);\\n        cur += node.val;\\n        if(!node.left && !node.right){\\n            if(cur === sum) res.push(arr);\\n            return;\\n        }\\n        helper(node.left, cur, arr.slice());\\n        helper(node.right, cur, arr.slice());\\n    }\\n    helper(root, 0, []);\\n    return res;\\n};",
                "solutionTags": [],
                "code": "```\\nvar pathSum = function(root, sum) {\\n    let res = [];\\n    function helper(node, cur, arr){\\n        if(!node) return;\\n        arr.push(node.val);\\n        cur += node.val;\\n        if(!node.left && !node.right){\\n            if(cur === sum) res.push(arr);\\n            return;\\n        }\\n        helper(node.left, cur, arr.slice());\\n        helper(node.right, cur, arr.slice());\\n    }\\n    helper(root, 0, []);\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 36693,
                "title": "13-lines-c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n        vector<vector<int>>res;\\n        if(!root) return res;\\n        DFS(root, res, vector<int>(), 0, sum);\\n        return res;\\n    }\\n    \\n    void DFS(TreeNode* root, vector<vector<int>>& res, vector<int>path, int sum, int target){\\n        if(!root) return;\\n        path.push_back(root->val);\\n        sum += root->val;\\n        if(!root->left && !root->right){\\n            if(sum == target) res.push_back(path);\\n            return;\\n        }\\n        DFS(root->left, res, path, sum, target);\\n        DFS(root->right, res, path, sum, target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n        vector<vector<int>>res;\\n        if(!root) return res;\\n        DFS(root, res, vector<int>(), 0, sum);\\n        return res;\\n    }\\n    \\n    void DFS(TreeNode* root, vector<vector<int>>& res, vector<int>path, int sum, int target){\\n        if(!root) return;\\n        path.push_back(root->val);\\n        sum += root->val;\\n        if(!root->left && !root->right){\\n            if(sum == target) res.push_back(path);\\n            return;\\n        }\\n        DFS(root->left, res, path, sum, target);\\n        DFS(root->right, res, path, sum, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36812,
                "title": "java-bit-94-02",
                "content": "\\n\\n    public class Solution {\\n        private int maxPathLen = 2000;\\n        private int[] path = new int[maxPathLen];\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n\\n        /**\\n         * <br/>\\n         * <strong>result of test:</strong><br/>\\n         * 114 / 114 test cases passed<br/>\\n         * Status: Accepted<br/>\\n         * Runtime: 3 ms, bit 38.48%<br/>\\n         * <p>\\n         * here the size of maxPathLen is very influence program run speed\\n         * if maxPathLen = 9999, Runtime: 3 ms, bit 38.48%\\n         * if maxPathLen = 2000, Runtime: 2 ms, bit 94.02%\\n         *\\n         * @param root\\n         * @param sum\\n         * @return\\n         */\\n        public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n            findAllPath(0, root, sum);\\n            return result;\\n        }\\n\\n        private void findAllPath(int index, TreeNode root, int sum) {\\n            if (root == null) {\\n                return;\\n            }\\n            path[index] = root.val;\\n            if (root.left == null && root.right == null && root.val == sum) {\\n                List<Integer> list = new ArrayList<Integer>();\\n                for (int i = 0; i <= index; i++) {\\n                    list.add(path[i]);\\n                }\\n                result.add(list);\\n                return;\\n            }\\n            findAllPath(index + 1, root.left, sum - root.val);\\n            findAllPath(index + 1, root.right, sum - root.val);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        private int maxPathLen = 2000;\\n        private int[] path = new int[maxPathLen];\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n\\n        /**\\n         * <br/>\\n         * <strong>result of test:</strong><br/>\\n         * 114 / 114 test cases passed<br/>\\n         * Status: Accepted<br/>\\n         * Runtime: 3 ms, bit 38.48%<br/>\\n         * <p>\\n         * here the size of maxPathLen is very influence program run speed\\n         * if maxPathLen = 9999, Runtime: 3 ms, bit 38.48%\\n         * if maxPathLen = 2000, Runtime: 2 ms, bit 94.02%\\n         *\\n         * @param root\\n         * @param sum\\n         * @return\\n         */\\n        public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n            findAllPath(0, root, sum);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36876,
                "title": "c-solution-with-one-more-function",
                "content": "      class Solution {\\n       public:\\n        vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n        vector< vector<int> > ret;\\n    vector<int> row;\\n    FindSum(root,sum,row,ret);\\n    return ret;\\n    \\n    \\n    }\\n    void FindSum(TreeNode *root, int sum, vector<int> row, vector< vector<int> > &ret)\\n    {\\n        if(root==NULL)\\n            return;\\n        else if(root->val==sum&&root->left==NULL && root->right==NULL)\\n            {\\n            row.push_back(root->val);\\n            ret.push_back(row);\\n            return;\\n            }\\n\\n        row.push_back(root->val);\\n        FindSum(root->left, sum-root->val,row,ret);\\n        FindSum(root->right, sum-root->val,row,ret);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n       public:\\n        vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n        vector< vector<int> > ret;\\n    vector<int> row;\\n    FindSum(root,sum,row,ret);\\n    return ret;\\n    \\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 36880,
                "title": "simple-clean-java-recursive",
                "content": "    public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> path = new ArrayList<>();\\n        pathSum(ans, path, root, sum);\\n        return ans;\\n    }\\n\\n\\tprivate void pathSum(List<List<Integer>> ans, List<Integer> path,\\n\\t\\t\\tTreeNode root, int sum) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn;\\n\\t\\tList<Integer> newPath = new ArrayList<>(path);\\n\\t\\tnewPath.add(root.val);\\n\\t\\tif (root.left == null && root.right == null && root.val == sum) {\\n\\t\\t\\tans.add(newPath);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpathSum(ans, newPath, root.left, sum - root.val);\\n\\t\\tpathSum(ans, newPath, root.right, sum - root.val);\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> path = new ArrayList<>();\\n        pathSum(ans, path, root, sum);\\n        return ans;\\n    }\\n\\n\\tprivate void pathSum(List<List<Integer>> ans, List<Integer> path,\\n\\t\\t\\tTreeNode root, int sum) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn;\\n\\t\\tList<Integer> newPath = new ArrayList<>(path);\\n\\t\\tnewPath.add(root.val);\\n\\t\\tif (root.left == null && root.right == null && root.val == sum) {\\n\\t\\t\\tans.add(newPath);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpathSum(ans, newPath, root.left, sum - root.val);\\n\\t\\tpathSum(ans, newPath, root.right, sum - root.val);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 36893,
                "title": "accepted-cpp-dfs-solution-only-one-function",
                "content": "this idea derived from the previous problem.quite simple~ \\n\\n    vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n    \\tvector<vector<int>> res;\\n    \\tif(!root)\\n    \\t\\treturn res;\\n    \\n    \\tif(!root->left && !root->right){\\n    \\t\\tif(sum == root->val)\\n    \\t\\t\\tres.push_back(vector<int>(1,sum));\\n    \\t\\treturn res;\\n    \\t}\\n    \\n    \\tsum-=root->val;\\n    \\tauto left_res=pathSum(root->left,sum);\\n    \\tfor(auto r: left_res){\\n    \\t\\tr.insert(r.begin(),root->val);\\n    \\t\\tres.push_back(r);\\n    \\t}\\n    \\n    \\tauto right_res=pathSum(root->right,sum);\\n    \\tfor(auto r: right_res){\\n    \\t\\tr.insert(r.begin(),root->val);\\n    \\t\\tres.push_back(r);\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "this idea derived from the previous problem.quite simple~ \\n\\n    vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n    \\tvector<vector<int>> res;\\n    \\tif(!root)\\n    \\t\\treturn res;\\n    \\n    \\tif(!root->left && !root->right){\\n    \\t\\tif(sum == root->val)\\n    \\t\\t\\tres.push_back(vector<int>(1,sum));\\n    \\t\\treturn res;\\n    \\t}\\n    \\n    \\tsum-=root->val;\\n    \\tauto left_res=pathSum(root->left,sum);\\n    \\tfor(auto r: left_res){\\n    \\t\\tr.insert(r.begin(),root->val);\\n    \\t\\tres.push_back(r);\\n    \\t}\\n    \\n    \\tauto right_res=pathSum(root->right,sum);\\n    \\tfor(auto r: right_res){\\n    \\t\\tr.insert(r.begin(),root->val);\\n    \\t\\tres.push_back(r);\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3917692,
                "title": "python-easy-solution-100-beats-98-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nimport copy\\nclass Solution:\\n    def __init__(self):\\n        self.res=[]\\n\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        arr=[]\\n        if not root:\\n            return []\\n        self.checkSm(0,targetSum, root, arr)\\n        return self.res\\n    \\n    def checkSm(self, sm, targetSum, node, arr):\\n        smValue=sm+node.val\\n        if not node.left and not node.right:\\n            if smValue==targetSum:\\n                arr.append(node.val)\\n                newarr=copy.deepcopy(arr)\\n                self.res.append(newarr)\\n                arr.pop()\\n                return\\n        else:\\n            arr.append(node.val)\\n            if node.left:\\n                self.checkSm(smValue,targetSum,  node.left, arr)\\n            if node.right:\\n                self.checkSm(smValue,targetSum, node.right, arr)\\n            arr.pop()\\n        return\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nimport copy\\nclass Solution:\\n    def __init__(self):\\n        self.res=[]\\n\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        arr=[]\\n        if not root:\\n            return []\\n        self.checkSm(0,targetSum, root, arr)\\n        return self.res\\n    \\n    def checkSm(self, sm, targetSum, node, arr):\\n        smValue=sm+node.val\\n        if not node.left and not node.right:\\n            if smValue==targetSum:\\n                arr.append(node.val)\\n                newarr=copy.deepcopy(arr)\\n                self.res.append(newarr)\\n                arr.pop()\\n                return\\n        else:\\n            arr.append(node.val)\\n            if node.left:\\n                self.checkSm(smValue,targetSum,  node.left, arr)\\n            if node.right:\\n                self.checkSm(smValue,targetSum, node.right, arr)\\n            arr.pop()\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296513,
                "title": "java-preordertraversal-recursion",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n     List<List<Integer>> al = new ArrayList<>();\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n       \\n        helper( new ArrayList<>(), root, targetSum);\\n        return al;\\n    }\\n    void helper(List<Integer> li, TreeNode root, int targetSum)\\n    {\\n        if(root == null)\\n        return;\\n        li.add(root.val);\\n        if(root.left == null && root.right == null)\\n        {\\n            int sum = 0;\\n            for(int i: li)\\n            sum+= i;\\n            if(sum == targetSum)\\n            al.add(li);\\n        }\\n        helper(new ArrayList<>(li), root.left, targetSum);\\n        helper(new ArrayList<>(li), root.right, targetSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n     List<List<Integer>> al = new ArrayList<>();\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n       \\n        helper( new ArrayList<>(), root, targetSum);\\n        return al;\\n    }\\n    void helper(List<Integer> li, TreeNode root, int targetSum)\\n    {\\n        if(root == null)\\n        return;\\n        li.add(root.val);\\n        if(root.left == null && root.right == null)\\n        {\\n            int sum = 0;\\n            for(int i: li)\\n            sum+= i;\\n            if(sum == targetSum)\\n            al.add(li);\\n        }\\n        helper(new ArrayList<>(li), root.left, targetSum);\\n        helper(new ArrayList<>(li), root.right, targetSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208616,
                "title": "java-o-n-dfs-100-faster-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> listResult = new ArrayList<>();\\n        goDFS(root, 0, targetSum, new ArrayList<>(), listResult);\\n        return listResult;\\n    }\\n\\n    private void goDFS(TreeNode node, int currSum, int targetSum, ArrayList<Integer> list, List<List<Integer>> listResult) {\\n        if (node == null) return;\\n        \\n        currSum += node.val;\\n        list.add(node.val);\\n\\n        if (node.left == null && node.right == null && currSum == targetSum) {\\n            listResult.add(new ArrayList<>(list));\\n        }\\n    \\n        goDFS(node.left, currSum, targetSum, list, listResult);\\n        goDFS(node.right, currSum, targetSum, list, listResult);\\n        list.remove(list.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> listResult = new ArrayList<>();\\n        goDFS(root, 0, targetSum, new ArrayList<>(), listResult);\\n        return listResult;\\n    }\\n\\n    private void goDFS(TreeNode node, int currSum, int targetSum, ArrayList<Integer> list, List<List<Integer>> listResult) {\\n        if (node == null) return;\\n        \\n        currSum += node.val;\\n        list.add(node.val);\\n\\n        if (node.left == null && node.right == null && currSum == targetSum) {\\n            listResult.add(new ArrayList<>(list));\\n        }\\n    \\n        goDFS(node.left, currSum, targetSum, list, listResult);\\n        goDFS(node.right, currSum, targetSum, list, listResult);\\n        list.remove(list.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657050,
                "title": "c-solution-path-sum-ii",
                "content": "```\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root, int targetSum ,  vector<int> path , vector<vector<int>> &ans){\\n        if(root == NULL)\\n            return ;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right==NULL){\\n            long int sum = 0;\\n            int size = path.size();\\n            for(int i = size-1 ; i >=0 ; i--){\\n                sum += path[i];\\n            }\\n            if(sum == targetSum)\\n                ans.push_back(path);\\n        }\\n        solve(root->left , targetSum , path , ans);\\n        solve(root->right , targetSum , path , ans);\\n        \\n        path.pop_back();\\n    }\\n\\n    public:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        solve(root , targetSum , path , ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root, int targetSum ,  vector<int> path , vector<vector<int>> &ans){\\n        if(root == NULL)\\n            return ;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right==NULL){\\n            long int sum = 0;\\n            int size = path.size();\\n            for(int i = size-1 ; i >=0 ; i--){\\n                sum += path[i];\\n            }\\n            if(sum == targetSum)\\n                ans.push_back(path);\\n        }\\n        solve(root->left , targetSum , path , ans);\\n        solve(root->right , targetSum , path , ans);\\n        \\n        path.pop_back();\\n    }\\n\\n    public:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        solve(root , targetSum , path , ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618246,
                "title": "c-easy-to-understand-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void compute(TreeNode* root,int targetSum,vector<int>res){\\n        if(!root) return;\\n        if(root->val-targetSum==0 and root->left==NULL and root->right==NULL){\\n            res.push_back(root->val);\\n            ans.push_back(res);\\n        }\\n        res.push_back(root->val);\\n        compute(root->left,targetSum-root->val,res);\\n        compute(root->right,targetSum-root->val,res);\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int>res;\\n        compute(root,targetSum,res);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void compute(TreeNode* root,int targetSum,vector<int>res){\\n        if(!root) return;\\n        if(root->val-targetSum==0 and root->left==NULL and root->right==NULL){\\n            res.push_back(root->val);\\n            ans.push_back(res);\\n        }\\n        res.push_back(root->val);\\n        compute(root->left,targetSum-root->val,res);\\n        compute(root->right,targetSum-root->val,res);\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int>res;\\n        compute(root,targetSum,res);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617663,
                "title": "c-preorder-backtracking-easy",
                "content": "```\\nvoid inorder(TreeNode* root,vector<int>&res,vector<vector<int>>&v,int s,int t){\\n        if(!root)\\n            return;\\n        s+=root->val;\\n        res.push_back(root->val);\\n        if((!root->left && !root->right) && s==t )\\n            v.push_back(res);\\n        inorder(root->left,res,v,s,t);\\n        inorder(root->right,res,v,s,t);\\n        res.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>>v;\\n        vector<int>res;\\n        inorder(root,res,v,0,targetSum);\\n        return v;\\n    }\\n```\\t",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvoid inorder(TreeNode* root,vector<int>&res,vector<vector<int>>&v,int s,int t){\\n        if(!root)\\n            return;\\n        s+=root->val;\\n        res.push_back(root->val);\\n        if((!root->left && !root->right) && s==t )\\n            v.push_back(res);\\n        inorder(root->left,res,v,s,t);\\n        inorder(root->right,res,v,s,t);\\n        res.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>>v;\\n        vector<int>res;\\n        inorder(root,res,v,0,targetSum);\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2617052,
                "title": "c-short-n-precise-diagram-explanation-intuitive-beginner-friendly-image-explanation",
                "content": "**INTUITION :**\\n* Since, every path from root to the leaf is a unique path.\\n* So, go through every path from root to leaf and check the condition  => if matched, then add to result.\\n\\n**APPROACH :**\\n* Start with the root :\\n* if left child present => decrease the TargetValue with current Root->val  and call a recursive call for Left Child.\\n* if right child present => decrease the TargetValue with current Root->val  and call a recursive call for Right Child.\\n* When reached at the Leaf (means left and right both children are absent)\\n   => then check if our target Becomes ==0 , if so add to result and then return from recursive call.\\n\\n![image](https://assets.leetcode.com/users/images/9ebce6e3-8c34-4f26-873b-680652418cc8_1664004462.2564657.png)\\n\\n# Code  | C++  :\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void solve(TreeNode* root, int targetSum, vector<int>temp){\\n        if(!root)   return;\\n        if(!root->left && !root->right){\\n            temp.push_back(root->val);\\n            targetSum-= root->val;\\n            if(targetSum == 0)  result.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(root->val);\\n        if(root->left)  solve(root->left, targetSum-root->val, temp);\\n        if(root->right) solve(root->right, targetSum-root->val, temp);\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        solve(root, targetSum, {});\\n        return result;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY : ** \\nO(H^2) , where H is the Height of the  Tree.\\n=> It  is almost equal to O(N) as we visit every node only once, (where N is the number of nodes). \\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void solve(TreeNode* root, int targetSum, vector<int>temp){\\n        if(!root)   return;\\n        if(!root->left && !root->right){\\n            temp.push_back(root->val);\\n            targetSum-= root->val;\\n            if(targetSum == 0)  result.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(root->val);\\n        if(root->left)  solve(root->left, targetSum-root->val, temp);\\n        if(root->right) solve(root->right, targetSum-root->val, temp);\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        solve(root, targetSum, {});\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616437,
                "title": "javascript-solution",
                "content": "```\\nvar pathSum = function(root, sum) {\\n  if (root === null) return [];\\n  const res = [];\\n  backtrack(root, sum, res, []);\\n  return res;\\n};\\n\\nfunction backtrack(root, sum, res, temp) {\\n  if (root === null) return;\\n  if (root.left === null && root.right === null && sum === root.val) {\\n    return res.push([...temp, root.val]);  \\n  }\\n  temp.push(root.val);\\n  backtrack(root.left, sum - root.val, res, temp);\\n\\n  backtrack(root.right, sum - root.val, res, temp);\\n  temp.pop();\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pathSum = function(root, sum) {\\n  if (root === null) return [];\\n  const res = [];\\n  backtrack(root, sum, res, []);\\n  return res;\\n};\\n\\nfunction backtrack(root, sum, res, temp) {\\n  if (root === null) return;\\n  if (root.left === null && root.right === null && sum === root.val) {\\n    return res.push([...temp, root.val]);  \\n  }\\n  temp.push(root.val);\\n  backtrack(root.left, sum - root.val, res, temp);\\n\\n  backtrack(root.right, sum - root.val, res, temp);\\n  temp.pop();\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2616401,
                "title": "path-sum-2-c-simple-dfs-and-backtracting-easy-and-clean-code",
                "content": "class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&ans, TreeNode *root, int target,int &val,vector<int> &ds){\\n        if(root==NULL ) return;\\n        val+=root->val;\\n        ds.push_back(root->val);\\n        if(val==target and (root->left==NULL and root->right==NULL)) {\\n            ans.push_back(ds);\\n        }\\n         \\n        // for(auto&i:ds) cout<<i<<\" \";\\n        //  cout<<endl;\\n       \\n        //cout<<val<<endl;\\n        dfs(ans,root->left,target,val,ds);        \\n        dfs(ans,root->right,target,val,ds);\\n        ds.pop_back();\\n        val-=root->val;\\n        \\n    }\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        int val = 0;\\n        dfs(ans,root,target,val,ds);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\nprivate:\\n    void dfs(vector<vector<int>>&ans, TreeNode *root, int target,int &val,vector<int> &ds){\\n        if(root==NULL ) return;\\n        val+=root->val;\\n        ds.push_back(root->val);\\n        if(val==target and (root->left==NULL and root->right==NULL)) {\\n            ans.push_back(ds);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2616197,
                "title": "easy-understandable-approach-python3-bfs",
                "content": "Approach:\\nCreate one ans list. for each node add it to curr_sum and curr_path.\\nIf node has not any child then compare curr_sum with target sum if both are equals then add curr_path in ans.\\n\\nMake recursive call for left and right child\\n\\nPlease Upvote if it helps.\\n\\n```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        \\n        ans = []\\n        \\n        def tree_traversal(root, curr_sum, curr_path):\\n            \\n            curr_sum += root.val\\n            curr_path.append(root.val)\\n            if root.left == None  and root.right == None:\\n                if curr_sum == targetSum:\\n                    ans.append(curr_path)\\n                return\\n            \\n            if root.left:\\n                tree_traversal(root.left, curr_sum, list(curr_path))\\n            \\n            if root.right:\\n                tree_traversal(root.right, curr_sum, list(curr_path))\\n        if root:\\n            tree_traversal(root, 0, [])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        \\n        ans = []\\n        \\n        def tree_traversal(root, curr_sum, curr_path):\\n            \\n            curr_sum += root.val\\n            curr_path.append(root.val)\\n            if root.left == None  and root.right == None:\\n                if curr_sum == targetSum:\\n                    ans.append(curr_path)\\n                return\\n            \\n            if root.left:\\n                tree_traversal(root.left, curr_sum, list(curr_path))\\n            \\n            if root.right:\\n                tree_traversal(root.right, curr_sum, list(curr_path))\\n        if root:\\n            tree_traversal(root, 0, [])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616097,
                "title": "c-dfs-related-simple",
                "content": "Firstly, for path **PUSH, PUSH, PUSH...** \\uD83D\\uDE05 then at leaf node, **POP**. \\nSecondly, for sum of that path, **+, +, +..** and then at leaf node, **-** path.back().\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    int sum = 0;\\n    vector<int> path;\\n    void dfs(TreeNode* node, int targetSum){\\n        if(!node)\\n            return;\\n        \\n        sum += node->val;\\n        path.push_back(node->val);\\n        \\n        if((sum == targetSum) && (node->left == node->right))\\n            ans.push_back(path); \\n        \\n        dfs(node->left, targetSum);                    \\n        dfs(node->right, targetSum);\\n        \\n        sum -= path.back();\\n        path.pop_back();\\n        \\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        dfs(root, targetSum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    int sum = 0;\\n    vector<int> path;\\n    void dfs(TreeNode* node, int targetSum){\\n        if(!node)\\n            return;\\n        \\n        sum += node->val;\\n        path.push_back(node->val);\\n        \\n        if((sum == targetSum) && (node->left == node->right))\\n            ans.push_back(path); \\n        \\n        dfs(node->left, targetSum);                    \\n        dfs(node->right, targetSum);\\n        \\n        sum -= path.back();\\n        path.pop_back();\\n        \\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        dfs(root, targetSum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615994,
                "title": "python3-very-easy-explained-tree",
                "content": "```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        self.targetSum, self.ans = targetSum, []            # variable initialization\\n        self.get_path_sum(root, 0, [])                      # calling function get path sum\\n        return self.ans                                     # return answer\\n        \\n    def get_path_sum(self, root, psum, path):\\n        if not root: return None                            # if not root return None\\n        if not root.left and not root.right:                # if curr node is leaf\\n            if root.val + psum == self.targetSum:           # if path sum from root to leaf = target sum\\n                path.append(root.val)                       # append node value to path\\n                self.ans.append([e for e in path])          # add path to ans list\\n                path.pop(-1)                                # remove node value from path\\n                return;                                     # return\\n        path.append(root.val)                               # append node value to path\\n        self.get_path_sum(root.left, psum + root.val, path) # left traversal\\n        self.get_path_sum(root.right, psum + root.val, path)# right traversal\\n        path.pop(-1)                                        # remove node value from path\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        self.targetSum, self.ans = targetSum, []            # variable initialization\\n        self.get_path_sum(root, 0, [])                      # calling function get path sum\\n        return self.ans                                     # return answer\\n        \\n    def get_path_sum(self, root, psum, path):\\n        if not root: return None                            # if not root return None\\n        if not root.left and not root.right:                # if curr node is leaf\\n            if root.val + psum == self.targetSum:           # if path sum from root to leaf = target sum\\n                path.append(root.val)                       # append node value to path\\n                self.ans.append([e for e in path])          # add path to ans list\\n                path.pop(-1)                                # remove node value from path\\n                return;                                     # return\\n        path.append(root.val)                               # append node value to path\\n        self.get_path_sum(root.left, psum + root.val, path) # left traversal\\n        self.get_path_sum(root.right, psum + root.val, path)# right traversal\\n        path.pop(-1)                                        # remove node value from path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615901,
                "title": "daily-leetcode-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root,int currSum,int targetSum,vector<vector<int>> &ans,vector<int> temp)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(root->right==NULL&&root->left==NULL)\\n        {\\n            currSum+=root->val;\\n            temp.push_back(root->val);\\n            if(targetSum==currSum)\\n            {\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        temp.push_back(root->val);\\n        dfs(root->left,currSum+root->val,targetSum,ans,temp);\\n        dfs(root->right,currSum+root->val,targetSum,ans,temp);\\n        temp.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        int sum=0;\\n        dfs(root,sum,targetSum,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root,int currSum,int targetSum,vector<vector<int>> &ans,vector<int> temp)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(root->right==NULL&&root->left==NULL)\\n        {\\n            currSum+=root->val;\\n            temp.push_back(root->val);\\n            if(targetSum==currSum)\\n            {\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        temp.push_back(root->val);\\n        dfs(root->left,currSum+root->val,targetSum,ans,temp);\\n        dfs(root->right,currSum+root->val,targetSum,ans,temp);\\n        temp.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        int sum=0;\\n        dfs(root,sum,targetSum,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570280,
                "title": "python-easy-solution-with-explanation",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        if not root:\\n            return []\\n        # dfs function to find path from root to leaf\\n        def dfs(root,path):\\n            # to check if node is leaf\\n            if not root.left and not root.right:\\n                # if leaf then check if path sum matches target sum\\n                if targetSum==sum(path+[root.val]):\\n                    # if yes then add path to result array\\n                    return res.append(path+[root.val])\\n            # recursively cal for left and right nodes till leaf node\\n            if root.left:\\n                dfs(root.left,path+[root.val])\\n            if root.right:\\n                dfs(root.right,path+[root.val])\\n        # create a result array\\n        res=[]\\n        # call the function for root\\n        dfs(root,[])\\n        return res\\n```\\n# upvote if u found it useful",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        if not root:\\n            return []\\n        # dfs function to find path from root to leaf\\n        def dfs(root,path):\\n            # to check if node is leaf\\n            if not root.left and not root.right:\\n                # if leaf then check if path sum matches target sum\\n                if targetSum==sum(path+[root.val]):\\n                    # if yes then add path to result array\\n                    return res.append(path+[root.val])\\n            # recursively cal for left and right nodes till leaf node\\n            if root.left:\\n                dfs(root.left,path+[root.val])\\n            if root.right:\\n                dfs(root.right,path+[root.val])\\n        # create a result array\\n        res=[]\\n        # call the function for root\\n        dfs(root,[])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364681,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        res = []\\n        def dfs(v, path, pathsum):\\n            if not v:\\n                return\\n            path.append(v.val)\\n            pathsum += v.val\\n            if not v.left and not v.right and pathsum == targetSum:\\n                res.append(path[:])\\n            dfs(v.left, path, pathsum)\\n            dfs(v.right, path, pathsum)\\n            path.pop()\\n        dfs(root, [], 0)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        res = []\\n        def dfs(v, path, pathsum):\\n            if not v:\\n                return\\n            path.append(v.val)\\n            pathsum += v.val\\n            if not v.left and not v.right and pathsum == targetSum:\\n                res.append(path[:])\\n            dfs(v.left, path, pathsum)\\n            dfs(v.right, path, pathsum)\\n            path.pop()\\n        dfs(root, [], 0)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2320926,
                "title": "python3-standard-dfs-solution",
                "content": "```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], target: int) -> List[List[int]]:\\n        result = []\\n        \\n        def dfs(root, target, path):   \\n            if not root:\\n                return\\n            if not root.left and not root.right and target - root.val == 0:\\n                result.append(path + [root.val])\\n                return\\n            \\n            dfs(root.left, target - root.val, path + [root.val])\\n            dfs(root.right, target - root.val, path + [root.val])\\n        \\n        dfs(root, target, [])\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], target: int) -> List[List[int]]:\\n        result = []\\n        \\n        def dfs(root, target, path):   \\n            if not root:\\n                return\\n            if not root.left and not root.right and target - root.val == 0:\\n                result.append(path + [root.val])\\n                return\\n            \\n            dfs(root.left, target - root.val, path + [root.val])\\n            dfs(root.right, target - root.val, path + [root.val])\\n        \\n        dfs(root, target, [])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037828,
                "title": "c-backtracking-easy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    void sumArray(TreeNode* root,int t,vector<int> &v,vector<vector<int>>&ans){\\n        if(root == NULL)\\n            return;\\n        v.push_back(root->val);\\n        if(!root->left && !root->right && t - root->val == 0){\\n            ans.push_back(v);\\n        }\\n        sumArray(root->left,t-root->val,v,ans);\\n        sumArray(root->right,t-root->val,v,ans);\\n        v.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sumArray(root,targetSum,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    void sumArray(TreeNode* root,int t,vector<int> &v,vector<vector<int>>&ans){\\n        if(root == NULL)\\n            return;\\n        v.push_back(root->val);\\n        if(!root->left && !root->right && t - root->val == 0){\\n            ans.push_back(v);\\n        }\\n        sumArray(root->left,t-root->val,v,ans);\\n        sumArray(root->right,t-root->val,v,ans);\\n        v.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sumArray(root,targetSum,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961733,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    \\n    List<List<Integer>> paths = new ArrayList<>();\\n    \\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        \\n        if(root == null)\\n            return paths;\\n        \\n        dfs(root, targetSum, new ArrayList<>());\\n        \\n        return paths;\\n    }\\n    \\n    void dfs(TreeNode node, int targetSum, ArrayList<Integer> path) {\\n        \\n        // 1- Check specific case\\n        if(node == null)\\n            return;\\n        \\n        // 2- Prosses a cell\\n            path.add(node.val);\\n            targetSum -= node.val;\\n        \\n        if(targetSum == 0 && node.left == null && node.right == null)\\n            paths.add(path);\\n        \\n        \\n        // 3- Call dfs as many times as nedded\\n        dfs(node.left, targetSum, new ArrayList<>(path));\\n        dfs(node.right, targetSum, new ArrayList<>(path));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<List<Integer>> paths = new ArrayList<>();\\n    \\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        \\n        if(root == null)\\n            return paths;\\n        \\n        dfs(root, targetSum, new ArrayList<>());\\n        \\n        return paths;\\n    }\\n    \\n    void dfs(TreeNode node, int targetSum, ArrayList<Integer> path) {\\n        \\n        // 1- Check specific case\\n        if(node == null)\\n            return;\\n        \\n        // 2- Prosses a cell\\n            path.add(node.val);\\n            targetSum -= node.val;\\n        \\n        if(targetSum == 0 && node.left == null && node.right == null)\\n            paths.add(path);\\n        \\n        \\n        // 3- Call dfs as many times as nedded\\n        dfs(node.left, targetSum, new ArrayList<>(path));\\n        dfs(node.right, targetSum, new ArrayList<>(path));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692090,
                "title": "c-solution-stack-postorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n\\t\\tvector<vector<int>> res;\\n\\t\\tif (root == nullptr) return res;\\n        stack<pair<TreeNode* , bool>> st;\\n\\t\\tTreeNode *node = root;\\n\\t\\tint sum = 0;\\n\\t\\tvector<int> temp;\\n\\t\\tbool flag = true;\\n\\t\\twhile (flag)\\n\\t\\t{\\n\\t\\t\\tif (node)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum += node->val;\\n\\t\\t\\t\\ttemp.push_back(node->val);\\n\\t\\t\\t\\tif (sum == targetSum && !(node->left) && !(node->right))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tres.push_back(temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.push({node, false});\\n\\t\\t\\t\\tnode = node->left;\\n\\t\\t\\t}\\n\\t\\t\\telse if (!st.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile (!st.empty() && st.top().second)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsum -= st.top().first->val;\\n\\t\\t\\t\\t\\ttemp.pop_back();\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!st.empty())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnode = st.top().first->right;\\n\\t\\t\\t\\t\\tst.top().second = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse flag = false;\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n\\t\\tvector<vector<int>> res;\\n\\t\\tif (root == nullptr) return res;\\n        stack<pair<TreeNode* , bool>> st;\\n\\t\\tTreeNode *node = root;\\n\\t\\tint sum = 0;\\n\\t\\tvector<int> temp;\\n\\t\\tbool flag = true;\\n\\t\\twhile (flag)\\n\\t\\t{\\n\\t\\t\\tif (node)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum += node->val;\\n\\t\\t\\t\\ttemp.push_back(node->val);\\n\\t\\t\\t\\tif (sum == targetSum && !(node->left) && !(node->right))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tres.push_back(temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.push({node, false});\\n\\t\\t\\t\\tnode = node->left;\\n\\t\\t\\t}\\n\\t\\t\\telse if (!st.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile (!st.empty() && st.top().second)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsum -= st.top().first->val;\\n\\t\\t\\t\\t\\ttemp.pop_back();\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!st.empty())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnode = st.top().first->right;\\n\\t\\t\\t\\t\\tst.top().second = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse flag = false;\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384207,
                "title": "c-dfs",
                "content": "\\nResource for modern c++: https://www.modernescpp.com/index.php/initialization\\n\\nI refered above for {}-initialisation\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    #define vvi vector<vector<int>>\\n    #define vi vector<int>\\n    \\n    int target=0;\\n    vvi ans;\\n    \\n    void dfs(TreeNode* root, int sum, vi path){\\n        \\n        if(root==NULL)return ;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL and root->right == NULL){\\n            \\n            if( sum + root->val == target){\\n                \\n                ans.push_back(path);\\n                return;\\n            }\\n        }\\n        \\n        dfs(root->left, sum + root->val, path);\\n        \\n        dfs(root->right, sum + root->val, path);\\n        \\n        \\n        \\n        \\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        \\n        this->target = targetSum;\\n        \\n        dfs(root,0,{}); // see this new way of passing empty-vector which is {}-initialisation\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    #define vvi vector<vector<int>>\\n    #define vi vector<int>\\n    \\n    int target=0;\\n    vvi ans;\\n    \\n    void dfs(TreeNode* root, int sum, vi path){\\n        \\n        if(root==NULL)return ;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL and root->right == NULL){\\n            \\n            if( sum + root->val == target){\\n                \\n                ans.push_back(path);\\n                return;\\n            }\\n        }\\n        \\n        dfs(root->left, sum + root->val, path);\\n        \\n        dfs(root->right, sum + root->val, path);\\n        \\n        \\n        \\n        \\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        \\n        this->target = targetSum;\\n        \\n        dfs(root,0,{}); // see this new way of passing empty-vector which is {}-initialisation\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383193,
                "title": "path-sum-ii-dfs-java-beats-99-9",
                "content": "Apporach : \\n1. Do DFS for each node and pass a LinkedList that stores the current node value.\\n2. Pass diff between targetSum and sum so far in DFS.\\n3. Terminate dfs when diff is 0 and leaf node.\\n\\n\\n```\\n public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> out=new ArrayList();\\n        if(root==null){\\n            return out;\\n        }\\n        LinkedList<Integer> loc=new LinkedList();\\n        loc.add(root.val);\\n        dfs(root,targetSum-root.val,loc,out);\\n        return out;\\n    }\\n    private void dfs(TreeNode node, int sum, LinkedList<Integer> loc, List<List<Integer>> out){\\n      \\n        if(sum==0 && node.left==null && node.right==null){\\n            out.add(new ArrayList(loc));\\n            return;\\n        }\\n        if(node.left!=null){\\n             loc.add(node.left.val);\\n             dfs(node.left,sum-node.left.val,loc,out);\\n             loc.pollLast();\\n        }\\n       \\n        if(node.right!=null){\\n             loc.add(node.right.val);\\n             dfs(node.right,sum-node.right.val,loc,out);\\n             loc.pollLast();\\n        }\\n        \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        List<List<Integer>> out=new ArrayList();\\n        if(root==null){\\n            return out;\\n        }\\n        LinkedList<Integer> loc=new LinkedList();\\n        loc.add(root.val);\\n        dfs(root,targetSum-root.val,loc,out);\\n        return out;\\n    }\\n    private void dfs(TreeNode node, int sum, LinkedList<Integer> loc, List<List<Integer>> out){\\n      \\n        if(sum==0 && node.left==null && node.right==null){\\n            out.add(new ArrayList(loc));\\n            return;\\n        }\\n        if(node.left!=null){\\n             loc.add(node.left.val);\\n             dfs(node.left,sum-node.left.val,loc,out);\\n             loc.pollLast();\\n        }\\n       \\n        if(node.right!=null){\\n             loc.add(node.right.val);\\n             dfs(node.right,sum-node.right.val,loc,out);\\n             loc.pollLast();\\n        }\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1383037,
                "title": "easy-c-recursive-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> vc;\\n    \\n    void helper(TreeNode* root, int& targetSum, vector<int> curr){\\n        if(root==NULL)return;\\n        curr.push_back(root->val);\\n        int ss = accumulate(curr.begin(),curr.end(),0);\\n        if(root->left == NULL && root->right==NULL){\\n            if(ss == targetSum){\\n                vc.push_back(curr);\\n                return;\\n            }\\n        }\\n        helper(root->left,targetSum,curr);\\n        helper(root->right,targetSum,curr);\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> curr;\\n        helper(root,targetSum,curr);\\n        return vc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> vc;\\n    \\n    void helper(TreeNode* root, int& targetSum, vector<int> curr){\\n        if(root==NULL)return;\\n        curr.push_back(root->val);\\n        int ss = accumulate(curr.begin(),curr.end(),0);\\n        if(root->left == NULL && root->right==NULL){\\n            if(ss == targetSum){\\n                vc.push_back(curr);\\n                return;\\n            }\\n        }\\n        helper(root->left,targetSum,curr);\\n        helper(root->right,targetSum,curr);\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> curr;\\n        helper(root,targetSum,curr);\\n        return vc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382544,
                "title": "c-simple-backtracking-dfs-vs-bfs-solution-explained-100-time-55-space",
                "content": "Handbook case for a nice backtracking application here!\\n\\nIn order to solve ths problem, we will declare a few class variable to share data between our main function and the `dfs` helper one:\\n* `res` is going to be our usual accumulator variable, where we will store all the paths that qualify;\\n* `tmp` is the temporary path we will weave and unweave as we go in our DFS exploration of the tree and subsequently backtrack it;\\n* `target` will store a copy of the original input of the same name, not to have to pass it at each recursive call;\\n* `tmpVal` will store our current sum of values, initially set to `0`.\\n\\nIn our main function, we will first of all rule out the edge case of an empty tree, assign the value to the class version of `target` and then call `dfs` passing `root` as its sole parameter.\\n\\nThis helper function will:\\n* assign `root->val` to `val`;\\n* make use of it, pushing it into `tmp` and summing it to `tmpVal`;\\n* check ifwe are on a leaf and if the newly updated value of `tmpVal` equals `target`, in which case we know we can add `tmp` to `res`;\\n* call recursively `dfs` on the `left` and `right` branch, provided they exist;\\n* backtrack what we did in the second step, resetting `tmp` (with a pop) and `tmpVal` (with a simple subtraction) to their original values.\\n\\nOnce done, we can just `return` `res` and be done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\n    vector<vector<int>> res;\\n    vector<int> tmp;\\n    int target, tmpVal = 0;\\n    void dfs(TreeNode *root) {\\n        // support variables\\n        int val = root->val;\\n        // adding the current value to tmp\\n        tmp.push_back(val), tmpVal += val;\\n        // checking if it meets the condition\\n        if (!root->left && !root->right && tmpVal == target) res.push_back(tmp);\\n        // recursive calls\\n        if (root->left) dfs(root->left);\\n        if (root->right) dfs(root->right);\\n        // backtracking\\n        tmp.pop_back(), tmpVal -= val;\\n    }\\npublic:\\n    vector<vector<int>> pathSum(TreeNode *root, int target) {\\n        // edge case: empty tree\\n        if (!root) return {};\\n        this->target = target;\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\\n\\nCuriously, this version of `dfs` which does not store `val` seems to not just consume a bit less memory as expected, but also to run a bit faster on average:\\n\\n```cpp\\n    void dfs(TreeNode *root) {\\n        // adding the current value to tmp\\n        tmp.push_back(root->val), tmpVal += root->val;\\n        // checking if it meets the condition\\n        if (!root->left && !root->right && tmpVal == target) res.push_back(tmp);\\n        // recursive calls\\n        if (root->left) dfs(root->left);\\n        if (root->right) dfs(root->right);\\n        // backtracking\\n        tmp.pop_back(), tmpVal -= root->val;\\n    }\\n```\\n\\nAnd just for the lolZ, created also a BFS version.\\n\\nI tried to optimise as much as possible, queuing a data structure that stores the last node used and a pair of previous values seen and their total, but it was of course much slower and draining about double the memory of the other approach; still fun to fiddle with it a bit:\\n\\n```cpp\\nusing path = pair<TreeNode*, pair<vector<int>, int>>;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> pathSum(TreeNode *root, int target) {\\n        // edge case: empty tree\\n        if (!root) return {};\\n        // support variables\\n        vector<vector<int>> res;\\n        vector<int> tmp;\\n        queue<path> q;\\n        int qLen = 1;\\n        q.push({root, {{root->val}, root->val}});\\n        // BFS\\n        while (qLen) {\\n            while (qLen--) {\\n                // extracting the front\\n                path curr = q.front();\\n                q.pop();\\n                // checking for matching leafs\\n                if (!curr.first->left && !curr.first->right && curr.second.second == target)\\n                    res.push_back(curr.second.first);\\n                if (curr.first->left) {\\n                    tmp = curr.first->right ?  vector<int>(begin(curr.second.first), end(curr.second.first)) : curr.second.first;\\n                    tmp.push_back(curr.first->left->val);\\n                    q.push({curr.first->left, {tmp, curr.second.second + curr.first->left->val}});\\n                }\\n                if (curr.first->right) {\\n                    curr.second.first.push_back(curr.first->right->val);\\n                    q.push({curr.first->right, {curr.second.first, curr.second.second + curr.first->right->val}});\\n                }\\n            }\\n            // preparing for the next loop\\n            qLen = q.size();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\n    vector<vector<int>> res;\\n    vector<int> tmp;\\n    int target, tmpVal = 0;\\n    void dfs(TreeNode *root) {\\n        // support variables\\n        int val = root->val;\\n        // adding the current value to tmp\\n        tmp.push_back(val), tmpVal += val;\\n        // checking if it meets the condition\\n        if (!root->left && !root->right && tmpVal == target) res.push_back(tmp);\\n        // recursive calls\\n        if (root->left) dfs(root->left);\\n        if (root->right) dfs(root->right);\\n        // backtracking\\n        tmp.pop_back(), tmpVal -= val;\\n    }\\npublic:\\n    vector<vector<int>> pathSum(TreeNode *root, int target) {\\n        // edge case: empty tree\\n        if (!root) return {};\\n        this->target = target;\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\n```cpp\\n    void dfs(TreeNode *root) {\\n        // adding the current value to tmp\\n        tmp.push_back(root->val), tmpVal += root->val;\\n        // checking if it meets the condition\\n        if (!root->left && !root->right && tmpVal == target) res.push_back(tmp);\\n        // recursive calls\\n        if (root->left) dfs(root->left);\\n        if (root->right) dfs(root->right);\\n        // backtracking\\n        tmp.pop_back(), tmpVal -= root->val;\\n    }\\n```\n```cpp\\nusing path = pair<TreeNode*, pair<vector<int>, int>>;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> pathSum(TreeNode *root, int target) {\\n        // edge case: empty tree\\n        if (!root) return {};\\n        // support variables\\n        vector<vector<int>> res;\\n        vector<int> tmp;\\n        queue<path> q;\\n        int qLen = 1;\\n        q.push({root, {{root->val}, root->val}});\\n        // BFS\\n        while (qLen) {\\n            while (qLen--) {\\n                // extracting the front\\n                path curr = q.front();\\n                q.pop();\\n                // checking for matching leafs\\n                if (!curr.first->left && !curr.first->right && curr.second.second == target)\\n                    res.push_back(curr.second.first);\\n                if (curr.first->left) {\\n                    tmp = curr.first->right ?  vector<int>(begin(curr.second.first), end(curr.second.first)) : curr.second.first;\\n                    tmp.push_back(curr.first->left->val);\\n                    q.push({curr.first->left, {tmp, curr.second.second + curr.first->left->val}});\\n                }\\n                if (curr.first->right) {\\n                    curr.second.first.push_back(curr.first->right->val);\\n                    q.push({curr.first->right, {curr.second.first, curr.second.second + curr.first->right->val}});\\n                }\\n            }\\n            // preparing for the next loop\\n            qLen = q.size();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203606,
                "title": "python-dfs-faster-than-99-33-w-explaination",
                "content": "First of, we check for a empty tree. ```if not root``` is the same as ```if root == None```. We put this line here in this main function and not the helper function because we already check for empty nodes in the helper function (```if root.left:```/```if root.right:```), so you don\\'t want to check for empty nodes twice. If you feel that having the  ```if not root``` line in the helper function is faster than checking ```if root.left:```/```if root.right:```, please do comment!\\n\\nNext, we do a dfs on the tree, checking each node 1 by 1 and adding the value of the node to the current path we\\'re looking at. If the current node\\'s value equals the sum we want and it doesn\\'t have a left/right child (left/right of node is None), then we found a \"valid\" path, so add that to our list of paths.\\n\\nIf that is not the case, then we check if we have reached a leaf or not by checking it\\'s left and right nodes, and we subtract the value of the node we just visited from the total sum and make a copy of the current path we\\'re on so that we don\\'t mutate the same list when calling it recursively on the children.\\n\\n```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:\\n        if not root:\\n            return []\\n        paths = []\\n        self.dfs(root, targetSum, [], paths)\\n        return paths\\n    \\n    def dfs(self, root, sum, curr_path, paths):\\n        curr_path.append(root.val)\\n        if root.val == sum and not (root.left or root.right):\\n            paths.append(curr_path)\\n        else:\\n            if root.left:\\n                self.dfs(root.left, sum-root.val, curr_path[:], paths)\\n            if root.right:\\n                self.dfs(root.right, sum-root.val, curr_path[:], paths)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```if not root```\n```if root == None```\n```if root.left:```\n```if root.right:```\n```if not root```\n```if root.left:```\n```if root.right:```\n```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:\\n        if not root:\\n            return []\\n        paths = []\\n        self.dfs(root, targetSum, [], paths)\\n        return paths\\n    \\n    def dfs(self, root, sum, curr_path, paths):\\n        curr_path.append(root.val)\\n        if root.val == sum and not (root.left or root.right):\\n            paths.append(curr_path)\\n        else:\\n            if root.left:\\n                self.dfs(root.left, sum-root.val, curr_path[:], paths)\\n            if root.right:\\n                self.dfs(root.right, sum-root.val, curr_path[:], paths)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148476,
                "title": "cpp-dfs-solution-easy-to-understand-short-code",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void helper(TreeNode* root, int targetSum, vector<int> asf){\\n        if(!root){\\n            return;\\n        }\\n        asf.push_back(root->val);\\n        \\n        if(!root->left and !root->right and targetSum == root->val){\\n            ans.push_back(asf);\\n            return;\\n        }\\n        \\n        helper(root->left, targetSum - root->val,asf );\\n        \\n        helper(root->right, targetSum - root->val,asf );\\n        asf.pop_back();\\n        \\n    }\\n    \\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> asf;\\n        helper(root,targetSum,asf );\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void helper(TreeNode* root, int targetSum, vector<int> asf){\\n        if(!root){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1059888,
                "title": "c-simple-boring-recursive-solution",
                "content": "Nothing much to say. It is in very boring stuff.\\nJust make sure return value and current path doesn\\'t get copied too much.\\n```\\n  vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n    vector<vector<int>> ret;\\n    vector<int> path;\\n    pathSum(root, targetSum, path, ret);\\n    return ret;\\n  }\\n\\n\\n  void pathSum(TreeNode* root, int targetSum, vector<int> & path, vector<vector<int>> & ret) {\\n    if (!root)\\n      return;\\n    path.push_back(root->val);\\n    pathSum(root->left, targetSum-root->val, path, ret);\\n    pathSum(root->right, targetSum-root->val, path, ret);\\n    if (!root->left && !root->right && targetSum == root->val)\\n      ret.push_back(path);\\n    path.pop_back();\\n  }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n  vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n    vector<vector<int>> ret;\\n    vector<int> path;\\n    pathSum(root, targetSum, path, ret);\\n    return ret;\\n  }\\n\\n\\n  void pathSum(TreeNode* root, int targetSum, vector<int> & path, vector<vector<int>> & ret) {\\n    if (!root)\\n      return;\\n    path.push_back(root->val);\\n    pathSum(root->left, targetSum-root->val, path, ret);\\n    pathSum(root->right, targetSum-root->val, path, ret);\\n    if (!root->left && !root->right && targetSum == root->val)\\n      ret.push_back(path);\\n    path.pop_back();\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1026712,
                "title": "python-3-solution-beat-76",
                "content": "```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:\\n        self.target=targetSum\\n        self.res=[]\\n        def path(root,li):\\n            if root:\\n                li.append(root.val)\\n                path(root.left,li)\\n                path(root.right,li)\\n                if root.left==None and root.right==None and sum(li)==self.target:\\n                    self.res.append(li.copy())\\n                li.pop()\\n        path(root,[])\\n        return self.res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:\\n        self.target=targetSum\\n        self.res=[]\\n        def path(root,li):\\n            if root:\\n                li.append(root.val)\\n                path(root.left,li)\\n                path(root.right,li)\\n                if root.left==None and root.right==None and sum(li)==self.target:\\n                    self.res.append(li.copy())\\n                li.pop()\\n        path(root,[])\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757261,
                "title": "path-sum-ii-easy-to-understand-go-solution-with-comments",
                "content": "```\\nfunc pathSum(root *TreeNode, sum int) [][]int {\\n\\tres, path := [][]int{}, []int{}\\n\\tvar helper func(*TreeNode, int)\\n\\n\\thelper = func(node *TreeNode, sum int) {\\n\\t\\tif node != nil {\\n\\t\\t\\t// Add the current node value to the path\\n\\t\\t\\tpath = append(path, node.Val)\\n\\t\\t\\tif node.Left == nil && node.Right == nil && node.Val == sum {\\n\\t\\t\\t\\t// Create a copy so changes to path variable will not affect res\\n\\t\\t\\t\\ttmp := make([]int, len(path))\\n\\t\\t\\t\\tcopy(tmp, path)\\n\\t\\t\\t\\tres = append(res, tmp)\\n\\t\\t\\t}\\n\\t\\t\\thelper(node.Left, sum-node.Val)\\n\\t\\t\\thelper(node.Right, sum-node.Val)\\n\\t\\t\\t// Remove the node from path after processing it\\n\\t\\t\\tpath = path[0 : len(path)-1]\\n\\t\\t}\\n\\t}\\n\\n\\thelper(root, sum)\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nfunc pathSum(root *TreeNode, sum int) [][]int {\\n\\tres, path := [][]int{}, []int{}\\n\\tvar helper func(*TreeNode, int)\\n\\n\\thelper = func(node *TreeNode, sum int) {\\n\\t\\tif node != nil {\\n\\t\\t\\t// Add the current node value to the path\\n\\t\\t\\tpath = append(path, node.Val)\\n\\t\\t\\tif node.Left == nil && node.Right == nil && node.Val == sum {\\n\\t\\t\\t\\t// Create a copy so changes to path variable will not affect res\\n\\t\\t\\t\\ttmp := make([]int, len(path))\\n\\t\\t\\t\\tcopy(tmp, path)\\n\\t\\t\\t\\tres = append(res, tmp)\\n\\t\\t\\t}\\n\\t\\t\\thelper(node.Left, sum-node.Val)\\n\\t\\t\\thelper(node.Right, sum-node.Val)\\n\\t\\t\\t// Remove the node from path after processing it\\n\\t\\t\\tpath = path[0 : len(path)-1]\\n\\t\\t}\\n\\t}\\n\\n\\thelper(root, sum)\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745360,
                "title": "please-help-find-error-in-golang-solution",
                "content": "i have solved this  question. \\nif i do  **set = append(set, root.Val)** instead of ***append(append([]int{},set...)***  i get a wrong answer. Could you help mer explain why do i get a wrong answer instead of an error.\\nfor this input\\n[5,4,8,11,null,13,4,7,2,null,null,5,1]\\n22\\ni am getting\\n**[[5,4,11,2],[5,8,4,1]]**\\ninstead of\\n**[[5,4,11,2],[5,8,4,5]]**\\nclearly we can see that the second set is incorrect by one value.\\nYour help is apprecited.\\n```\\nfunc pathSum(root *TreeNode, sum int) [][]int {\\n    if root == nil {\\n        return [][]int{} \\n    }\\n    var res [][]int\\n    sumPath(root, sum, []int{}, &res)\\n    return res\\n}\\n\\nfunc sumPath(root *TreeNode, sum int, set []int, res *[][]int) {\\n    set = append(set, root.Val)\\n    if root.Right == nil && root.Left == nil {\\n        if sum == root.Val {\\n            *res = append(*res, set)    \\n        }\\n        return\\n    }\\n    if root.Left != nil {\\n        sumPath(root.Left, sum-root.Val, set, res)\\n    }\\n    if root.Right != nil {\\n        sumPath(root.Right, sum-root.Val, set, res)\\n    }\\n    return \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pathSum(root *TreeNode, sum int) [][]int {\\n    if root == nil {\\n        return [][]int{} \\n    }\\n    var res [][]int\\n    sumPath(root, sum, []int{}, &res)\\n    return res\\n}\\n\\nfunc sumPath(root *TreeNode, sum int, set []int, res *[][]int) {\\n    set = append(set, root.Val)\\n    if root.Right == nil && root.Left == nil {\\n        if sum == root.Val {\\n            *res = append(*res, set)    \\n        }\\n        return\\n    }\\n    if root.Left != nil {\\n        sumPath(root.Left, sum-root.Val, set, res)\\n    }\\n    if root.Right != nil {\\n        sumPath(root.Right, sum-root.Val, set, res)\\n    }\\n    return \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 667588,
                "title": "javascript-dfs",
                "content": "\\tvar pathSum = function(root, sum) {\\n\\t\\tif(!root) return []\\n\\n\\t\\tlet paths = []\\n\\n\\t\\tvar dfs = function(node, currentSum, path) {\\n\\t\\t\\tif (!node) return \\n\\t\\t\\tcurrentSum = currentSum + node.val\\n\\t\\t\\tif (currentSum === sum && !node.left&&!node.right) {\\n\\t\\t\\t\\tpath.push(node.val)\\n\\t\\t\\t\\tpaths.push(path)\\n\\t\\t\\t\\tpath = []\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tpath.push(node.val)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(!node.left&&!node.right){\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (node.left) {\\n\\t\\t\\t\\tdfs(node.left, currentSum, path.slice())\\n\\t\\t\\t}\\n\\t\\t\\tif (node.right) {\\n\\t\\t\\t\\tdfs(node.right, currentSum, path.slice())\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdfs(root, 0, [])\\n\\t\\treturn paths\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "\\tvar pathSum = function(root, sum) {\\n\\t\\tif(!root) return []\\n\\n\\t\\tlet paths = []\\n\\n\\t\\tvar dfs = function(node, currentSum, path) {\\n\\t\\t\\tif (!node) return \\n\\t\\t\\tcurrentSum = currentSum + node.val\\n\\t\\t\\tif (currentSum === sum && !node.left&&!node.right) {\\n\\t\\t\\t\\tpath.push(node.val)\\n\\t\\t\\t\\tpaths.push(path)\\n\\t\\t\\t\\tpath = []\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tpath.push(node.val)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(!node.left&&!node.right){\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (node.left) {\\n\\t\\t\\t\\tdfs(node.left, currentSum, path.slice())\\n\\t\\t\\t}\\n\\t\\t\\tif (node.right) {\\n\\t\\t\\t\\tdfs(node.right, currentSum, path.slice())\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdfs(root, 0, [])\\n\\t\\treturn paths\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 519382,
                "title": "go-4ms",
                "content": "```\\nfunc pathSum(root *TreeNode, sum int) [][]int {\\n    if root == nil {\\n        return nil\\n    }\\n    result := [][]int{}\\n    helper(root, []int{}, sum, &result)\\n    return result\\n}\\n\\nfunc helper(root *TreeNode, path []int, sum int, result *[][]int) {\\n    if root.Left == nil && root.Right == nil {\\n        if root.Val == sum {\\n            *result = append(*result, append(path, root.Val))\\n        }\\n        return\\n    }    \\n    if root.Left != nil  {\\n        helper(root.Left, append(append([]int{}, path...), root.Val), sum-root.Val, result)\\n    }\\n    if root.Right != nil {\\n        helper(root.Right, append(append([]int{}, path...), root.Val), sum-root.Val, result)\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc pathSum(root *TreeNode, sum int) [][]int {\\n    if root == nil {\\n        return nil\\n    }\\n    result := [][]int{}\\n    helper(root, []int{}, sum, &result)\\n    return result\\n}\\n\\nfunc helper(root *TreeNode, path []int, sum int, result *[][]int) {\\n    if root.Left == nil && root.Right == nil {\\n        if root.Val == sum {\\n            *result = append(*result, append(path, root.Val))\\n        }\\n        return\\n    }    \\n    if root.Left != nil  {\\n        helper(root.Left, append(append([]int{}, path...), root.Val), sum-root.Val, result)\\n    }\\n    if root.Right != nil {\\n        helper(root.Right, append(append([]int{}, path...), root.Val), sum-root.Val, result)\\n    }    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 415716,
                "title": "c-beats-92-simple-with-explanation",
                "content": "```\\nclass Solution {\\n    \\nprivate:\\n    vector<vector<int>> resultVec;\\n    \\n    void hasPathSum(TreeNode* root, int currentSum, int sum, vector<int>& vec) {\\n        \\n        vec.push_back(root->val);  // Push value into vec\\n        \\n        if (currentSum + root->val == sum && !root->left && !root->right) { // root to leaf condition\\n            resultVec.push_back(vec);\\n            vec.pop_back(); // Make sure this is here, if we enter this, we circumvent\\n            return; // the pop back below, as we return immediately.\\n        }\\n\\n        if (root->left) hasPathSum(root->left, currentSum + root->val, sum, vec); // If it has a left root, recurse into it\\n        if (root->right) hasPathSum(root->right, currentSum + root->val, sum, vec); // Same for right\\n        vec.pop_back(); // If there was no successful path, remove the value you\\'ve added as you unwind\\n        return;\\n    }\\n    \\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n        if (!root) return resultVec;\\n        vector<int> singleIteration;\\n        hasPathSum(root, 0, sum, singleIteration);\\n        return resultVec;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    \\nprivate:\\n    vector<vector<int>> resultVec;\\n    \\n    void hasPathSum(TreeNode* root, int currentSum, int sum, vector<int>& vec) {\\n        \\n        vec.push_back(root->val);  // Push value into vec\\n        \\n        if (currentSum + root->val == sum && !root->left && !root->right) { // root to leaf condition\\n            resultVec.push_back(vec);\\n            vec.pop_back(); // Make sure this is here, if we enter this, we circumvent\\n            return; // the pop back below, as we return immediately.\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 264358,
                "title": "ruby-beats-100",
                "content": "```\\ndef path_sum(root, sum, path = [])\\n  return [] if root.nil?\\n  sum -= root.val\\n  if root.left.nil? && root.right.nil? && sum == 0\\n    return [path + [root.val]]\\n  end\\n  path_sum(root.left, sum, path + [root.val]) + path_sum(root.right, sum, path + [root.val])\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef path_sum(root, sum, path = [])\\n  return [] if root.nil?\\n  sum -= root.val\\n  if root.left.nil? && root.right.nil? && sum == 0\\n    return [path + [root.val]]\\n  end\\n  path_sum(root.left, sum, path + [root.val]) + path_sum(root.right, sum, path + [root.val])\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 212512,
                "title": "scala-solution",
                "content": "```\\nobject Solution {\\n    def pathSum(root: TreeNode, sum: Int): List[List[Int]] = {\\n        rec(root, sum, List.empty[List[Int]], List.empty[Int])\\n    }\\n    \\n    def rec(node: TreeNode, sum: Int, result: List[List[Int]], current: List[Int]): List[List[Int]] = {\\n        if (node == null) result        \\n        else if (node.left == null && node.right == null) if (node.value == sum) (node.value :: current).reverse :: result else result\\n        else {\\n            val newSum = sum - node.value\\n            val newCurrent = node.value :: current\\n            val newResult = rec(node.left, newSum, result, newCurrent)\\n            rec(node.right, newSum, newResult, newCurrent)\\n        }     \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def pathSum(root: TreeNode, sum: Int): List[List[Int]] = {\\n        rec(root, sum, List.empty[List[Int]], List.empty[Int])\\n    }\\n    \\n    def rec(node: TreeNode, sum: Int, result: List[List[Int]], current: List[Int]): List[List[Int]] = {\\n        if (node == null) result        \\n        else if (node.left == null && node.right == null) if (node.value == sum) (node.value :: current).reverse :: result else result\\n        else {\\n            val newSum = sum - node.value\\n            val newCurrent = node.value :: current\\n            val newResult = rec(node.left, newSum, result, newCurrent)\\n            rec(node.right, newSum, newResult, newCurrent)\\n        }     \\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 36750,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Path Sum II** https://leetcode.com/problems/path-sum-ii/\\n* When do we have a valid path? When root is a leaf and root,val == sum.\\n* Refer to https://leetcode.com/problems/path-sum/ to understand path sum constraints. Detailed solution is available at: https://discuss.leetcode.com/topic/72240/python-solution-with-detailed-explanation\\n* Refer to https://leetcode.com/problems/binary-tree-paths/ to understand the template to capture all paths. Detailed solution is available at: https://discuss.leetcode.com/topic/72244/python-solution-with-detailed-explanation\\n* Time complexity: O(N^2) - Use the same explanation provided in https://discuss.leetcode.com/topic/72244/python-solution-with-detailed-explanation\\n\\n```\\nclass Solution(object):\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result = []\\n        if root:\\n            self.helper(root, [], result, sum)\\n        return result\\n    \\n    def helper(self, root, so_far, result, sum):\\n        if root.left is None and root.right is None and root.val == sum:\\n            so_far.append(root.val)\\n            result.append([x for x in so_far])\\n            so_far.pop()\\n        else:\\n            so_far.append(root.val)\\n            if root.left:\\n                self.helper(root.left, so_far, result, sum-root.val)\\n            if root.right:\\n                self.helper(root.right, so_far, result, sum-root.val)\\n            so_far.pop()\\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result = []\\n        if root:\\n            self.helper(root, [], result, sum)\\n        return result\\n    \\n    def helper(self, root, so_far, result, sum):\\n        if root.left is None and root.right is None and root.val == sum:\\n            so_far.append(root.val)\\n            result.append([x for x in so_far])\\n            so_far.pop()\\n        else:\\n            so_far.append(root.val)\\n            if root.left:\\n                self.helper(root.left, so_far, result, sum-root.val)\\n            if root.right:\\n                self.helper(root.right, so_far, result, sum-root.val)\\n            so_far.pop()\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 36772,
                "title": "c-solution-in-6ms",
                "content": "as a c coder, I hate this type of question, it need to use ugly `realloc` to dynamically allocated the returned array...\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid traverse(struct TreeNode *root, int accu, int sum, int *tmp, int count, int ***arr, int **columnSize, int *returnSize)\\n{\\n    if (!root) return;\\n        \\n    if (!root->left && !root->right) {\\n        if (accu + root->val == sum) {\\n            ++*returnSize;\\n            (*columnSize) = realloc(*columnSize, *returnSize * sizeof **columnSize);\\n            (*arr) = realloc(*arr, *returnSize * sizeof **arr);\\n            \\n            (*columnSize)[*returnSize - 1] = count + 1;\\n            (*arr)[*returnSize - 1] = malloc((*columnSize)[*returnSize - 1] * sizeof ***arr);\\n            memcpy((*arr)[*returnSize - 1], tmp, count * sizeof tmp[0]);\\n            (*arr)[*returnSize - 1][count] = root->val;\\n        }\\n    } else {\\n        int t[count + 1];\\n        memcpy(t, tmp, count * sizeof tmp[0]);\\n        t[count] = root->val;\\n        traverse(root->left, accu + root->val, sum, t, count + 1, arr, columnSize, returnSize);\\n        traverse(root->right, accu + root->val, sum, t, count + 1, arr, columnSize, returnSize);\\n    }\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** pathSum(struct TreeNode* root, int sum, int** columnSizes, int* returnSize) {\\n    int **arr;\\n    int tmp[0];\\n    \\n    *returnSize = 0;\\n    *columnSizes = NULL;\\n    arr = NULL;\\n    traverse(root, 0, sum, tmp, 0, &arr, columnSizes, returnSize);\\n    \\n    return arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid traverse(struct TreeNode *root, int accu, int sum, int *tmp, int count, int ***arr, int **columnSize, int *returnSize)\\n{\\n    if (!root) return;\\n        \\n    if (!root->left && !root->right) {\\n        if (accu + root->val == sum) {\\n            ++*returnSize;\\n            (*columnSize) = realloc(*columnSize, *returnSize * sizeof **columnSize);\\n            (*arr) = realloc(*arr, *returnSize * sizeof **arr);\\n            \\n            (*columnSize)[*returnSize - 1] = count + 1;\\n            (*arr)[*returnSize - 1] = malloc((*columnSize)[*returnSize - 1] * sizeof ***arr);\\n            memcpy((*arr)[*returnSize - 1], tmp, count * sizeof tmp[0]);\\n            (*arr)[*returnSize - 1][count] = root->val;\\n        }\\n    } else {\\n        int t[count + 1];\\n        memcpy(t, tmp, count * sizeof tmp[0]);\\n        t[count] = root->val;\\n        traverse(root->left, accu + root->val, sum, t, count + 1, arr, columnSize, returnSize);\\n        traverse(root->right, accu + root->val, sum, t, count + 1, arr, columnSize, returnSize);\\n    }\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** pathSum(struct TreeNode* root, int sum, int** columnSizes, int* returnSize) {\\n    int **arr;\\n    int tmp[0];\\n    \\n    *returnSize = 0;\\n    *columnSizes = NULL;\\n    arr = NULL;\\n    traverse(root, 0, sum, tmp, 0, &arr, columnSizes, returnSize);\\n    \\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36817,
                "title": "simple-recursive-yet-efficient-enough-in-cpp",
                "content": "    class Solution {\\n    private:\\n        void traverse(const TreeNode* root, vector<vector<int>>& paths, vector<int> path, int sum)\\n        {\\n            int val = root->val;\\n            sum -= val;\\n            path.push_back(val);\\n            if(!root->left && !root->right && sum==0) paths.push_back(path);\\n            if(root->left) traverse(root->left, paths, path, sum);\\n            if(root->right) traverse(root->right, paths, path, sum);\\n        }\\n    public:\\n        vector<vector<int>> pathSum(TreeNode* root, int sum) {\\n            vector<vector<int>> paths;\\n            if(!root) return paths;\\n            vector<int> path;\\n            traverse(root, paths, path, sum);\\n            return paths;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    private:\\n        void traverse(const TreeNode* root, vector<vector<int>>& paths, vector<int> path, int sum)\\n        {\\n            int val = root->val;\\n            sum -= val;\\n            path.push_back(val);\\n            if(!root->left && !root->right && sum==0) paths.push_back(path);\\n            if(root->left) traverse(root->left, paths, path, sum);\\n            if(root->right) traverse(root->right, paths, path, sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36834,
                "title": "my-java-solution-with-dfs-backtracking",
                "content": "    public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        List<List<Integer>> res = new ArrayList();\\n        helper(res, new ArrayList<Integer>(), root, 0, sum);\\n        return res;\\n    }\\n    private void helper(List<List<Integer>> res, ArrayList<Integer> sub, TreeNode root, int cur, int sum) {\\n        if (root == null) return;\\n        sub.add(root.val);\\n        helper(res, sub, root.left, cur + root.val, sum);\\n        if (root.left == null && root.right == null && cur + root.val == sum) {\\n            res.add(new ArrayList<Integer>(sub));\\n        }\\n        helper(res, sub, root.right, cur + root.val, sum);\\n        sub.remove(sub.size() - 1);\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "    public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        List<List<Integer>> res = new ArrayList();\\n        helper(res, new ArrayList<Integer>(), root, 0, sum);\\n        return res;\\n    }\\n    private void helper(List<List<Integer>> res, ArrayList<Integer> sub, TreeNode root, int cur, int sum) {\\n        if (root == null) return;\\n        sub.add(root.val);\\n        helper(res, sub, root.left, cur + root.val, sum);\\n        if (root.left == null && root.right == null && cur + root.val == sum) {\\n            res.add(new ArrayList<Integer>(sub));\\n        }\\n        helper(res, sub, root.right, cur + root.val, sum);\\n        sub.remove(sub.size() - 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36885,
                "title": "8ms-c-solution-with-dfs",
                "content": "    typedef struct TreeNode tn;\\n    \\n    int maxDepth(tn* root)\\n    {\\n      if(root==NULL)        return 0;\\n      int lDep = maxDepth(root->left);\\n      int rDep = maxDepth(root->right);\\n      return (lDep> rDep)?lDep+1:rDep+1;\\n    }\\n    \\n    void helper(tn* node, int sum,\\n                int* cur, int curS,\\n                int** colS, int* retS, int** ret)\\n    {\\n      /* term */\\n      if(node->val == sum &&\\n         !node->left && !node->right)\\n      {\\n        /* got a match */\\n        ret[*retS] = (int*)malloc(sizeof(int)* (curS+1));\\n        memcpy(ret[*retS], cur, sizeof(int) * curS);\\n        ret[*retS][curS] = node->val;\\n        (*colS)[*retS] = curS +1;\\n        (*retS)++;\\n        return;\\n      }\\n    \\n      cur[curS] = node->val;\\n      /* dfs */\\n      if(node->left)\\n        helper(node->left, sum-cur[curS], cur, curS+1, colS, retS, ret);\\n    \\n      if(node->right)\\n        helper(node->right, sum-cur[curS], cur, curS+1, colS, retS, ret);    \\n    }\\n    \\n    int** pathSum(tn* root, int sum, int** colS, int* retS)\\n    {\\n      *retS = 0;\\n      if(root == NULL) return NULL;\\n    \\n      *colS = (int*)malloc(sizeof(int)*500);\\n      int** ret = (int**)malloc(sizeof(int*)*500);\\n      \\n      int cur[maxDepth(root)];\\n      helper(root, sum, cur, 0, colS, retS, ret);\\n    \\n      return ret;\\n    }",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "    typedef struct TreeNode tn;\\n    \\n    int maxDepth(tn* root)\\n    {\\n      if(root==NULL)        return 0;\\n      int lDep = maxDepth(root->left);\\n      int rDep = maxDepth(root->right);\\n      return (lDep> rDep)?lDep+1:rDep+1;\\n    }\\n    \\n    void helper(tn* node, int sum,\\n                int* cur, int curS,\\n                int** colS, int* retS, int** ret)\\n    {\\n      /* term */\\n      if(node->val == sum &&\\n         !node->left && !node->right)\\n      {\\n        /* got a match */\\n        ret[*retS] = (int*)malloc(sizeof(int)* (curS+1));\\n        memcpy(ret[*retS], cur, sizeof(int) * curS);\\n        ret[*retS][curS] = node->val;\\n        (*colS)[*retS] = curS +1;\\n        (*retS)++;\\n        return;\\n      }\\n    \\n      cur[curS] = node->val;\\n      /* dfs */\\n      if(node->left)\\n        helper(node->left, sum-cur[curS], cur, curS+1, colS, retS, ret);\\n    \\n      if(node->right)\\n        helper(node->right, sum-cur[curS], cur, curS+1, colS, retS, ret);    \\n    }\\n    \\n    int** pathSum(tn* root, int sum, int** colS, int* retS)\\n    {\\n      *retS = 0;\\n      if(root == NULL) return NULL;\\n    \\n      *colS = (int*)malloc(sizeof(int)*500);\\n      int** ret = (int**)malloc(sizeof(int*)*500);\\n      \\n      int cur[maxDepth(root)];\\n      helper(root, sum, cur, 0, colS, retS, ret);\\n    \\n      return ret;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 36923,
                "title": "c-17-ms-recursion",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > pathSum(TreeNode *root, int sum) {\\n            vector<vector<int> > result;\\n            vector<int> path_num;\\n            helper(root, sum, path_num, result);\\n            return result;\\n        }\\n        void helper(TreeNode *root, int sum, vector<int> &path_num, vector<vector<int> > &result) {\\n            if(root == NULL)\\n                return;\\n            path_num.push_back(root->val);\\n            if(root->left == NULL && root->right == NULL && sum == root->val) {\\n                result.push_back(path_num);\\n                path_num.pop_back();\\n                return;\\n            }\\n            helper(root->left, sum - root->val, path_num, result);\\n            helper(root->right, sum - root->val, path_num, result);\\n            path_num.pop_back();\\n        }\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > pathSum(TreeNode *root, int sum) {\\n            vector<vector<int> > result;\\n            vector<int> path_num;\\n            helper(root, sum, path_num, result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36954,
                "title": "share-my-non-recursive-solution",
                "content": " post order \\n\\n\\n    vector<vector<int> > pathSum(TreeNode *root, int sum) {\\n        vector<vector<int>> result;\\n        if(root == NULL)\\n        {\\n            return result;\\n        }\\n        \\n        stack<TreeNode*> nodeStack;\\n        TreeNode *current = root;\\n        TreeNode *last = NULL;\\n        vector<int> set;\\n        int pathSum = 0;\\n        \\n        while(!nodeStack.empty() || current != NULL)\\n        {\\n            if(current == NULL)\\n            {\\n                TreeNode *node = nodeStack.top();\\n                \\n                if(node->right != NULL && last != node->right)\\n                {\\n                    current = node->right;   \\n                }\\n                else\\n                {\\n                    last = node;\\n                    nodeStack.pop();\\n                    set.pop_back();\\n                    pathSum -= node->val;\\n                }\\n            }\\n            else\\n            {\\n                nodeStack.push(current);\\n                set.push_back(current->val);\\n                pathSum += current->val;\\n                \\n                if(current->left == NULL && current->right == NULL && pathSum == sum)\\n                {\\n                    vector<int> row;\\n                        \\n                    for(int i =0;i<set.size();i++)\\n                    {\\n                        row.push_back(set[i]);\\n                    }\\n                    \\n                    result.push_back(row);\\n                }\\n                \\n                current = current->left;\\n            }\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": " post order \\n\\n\\n    vector<vector<int> > pathSum(TreeNode *root, int sum) {\\n        vector<vector<int>> result;\\n        if(root == NULL)\\n        {\\n            return result;\\n        }\\n        \\n        stack<TreeNode*> nodeStack;\\n        TreeNode *current = root;\\n        TreeNode *last = NULL;\\n        vector<int> set;\\n        int pathSum = 0;\\n        \\n        while(!nodeStack.empty() || current != NULL)\\n        {\\n            if(current == NULL)\\n            {\\n                TreeNode *node = nodeStack.top();\\n                \\n                if(node->right != NULL && last != node->right)\\n                {\\n                    current = node->right;   \\n                }\\n                else\\n                {\\n                    last = node;\\n                    nodeStack.pop();\\n                    set.pop_back();\\n                    pathSum -= node->val;\\n                }\\n            }\\n            else\\n            {\\n                nodeStack.push(current);\\n                set.push_back(current->val);\\n                pathSum += current->val;\\n                \\n                if(current->left == NULL && current->right == NULL && pathSum == sum)\\n                {\\n                    vector<int> row;\\n                        \\n                    for(int i =0;i<set.size();i++)\\n                    {\\n                        row.push_back(set[i]);\\n                    }\\n                    \\n                    result.push_back(row);\\n                }\\n                \\n                current = current->left;\\n            }\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3690392,
                "title": "tc-o-n-beats-faster-cpp-c-code-easy-code-use-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\nvector<vector<int>>ans;\\nvoid solve(TreeNode *root, int k,int sum,vector<int>v){\\n    if(root==NULL){\\n        return;\\n    }\\n    sum+=root->val;\\n    v.push_back(root->val);\\n    if(sum==k && root->left==NULL && root->right==NULL){\\n        ans.push_back(v);\\n    }\\n    solve(root->left,k,sum,v);\\n    solve(root->right,k,sum,v);\\n    v.pop_back();\\n}\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int k) {\\n        if(root==NULL){\\n           return ans;\\n        }\\n       vector<int>v;\\n       int sum=0;\\n       solve(root,k,sum,v);\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\nvector<vector<int>>ans;\\nvoid solve(TreeNode *root, int k,int sum,vector<int>v){\\n    if(root==NULL){\\n        return;\\n    }\\n    sum+=root->val;\\n    v.push_back(root->val);\\n    if(sum==k && root->left==NULL && root->right==NULL){\\n        ans.push_back(v);\\n    }\\n    solve(root->left,k,sum,v);\\n    solve(root->right,k,sum,v);\\n    v.pop_back();\\n}\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int k) {\\n        if(root==NULL){\\n           return ans;\\n        }\\n       vector<int>v;\\n       int sum=0;\\n       solve(root,k,sum,v);\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686031,
                "title": "easy-c-solution-beat-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int targetSum,int sum ,vector<vector<int>> &ans,vector<int> &path){\\n        if(root==NULL)\\n            return ;\\n        if(root->left==NULL&&root->right==NULL){\\n            path.push_back(root->val);\\n            sum+=root->val;\\n            if(sum==targetSum){\\n                ans.push_back(path);\\n            }\\n            sum-=root->val;\\n            path.pop_back();\\n        }\\n        path.push_back(root->val);\\n        sum+=root->val;\\n        solve(root->left,targetSum,sum,ans,path);\\n        solve(root->right,targetSum,sum,ans,path);\\n        path.pop_back();\\n        sum-=root->val;\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        int sum=0;\\n        solve(root,targetSum,sum,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int targetSum,int sum ,vector<vector<int>> &ans,vector<int> &path){\\n        if(root==NULL)\\n            return ;\\n        if(root->left==NULL&&root->right==NULL){\\n            path.push_back(root->val);\\n            sum+=root->val;\\n            if(sum==targetSum){\\n                ans.push_back(path);\\n            }\\n            sum-=root->val;\\n            path.pop_back();\\n        }\\n        path.push_back(root->val);\\n        sum+=root->val;\\n        solve(root->left,targetSum,sum,ans,path);\\n        solve(root->right,targetSum,sum,ans,path);\\n        path.pop_back();\\n        sum-=root->val;\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        int sum=0;\\n        solve(root,targetSum,sum,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660606,
                "title": "beats-100-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int targetSum, vector<int>& path, vector<vector<int>>& ans) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        \\n        path.push_back(root->val);\\n        \\n        if (root->val == targetSum && root->left == nullptr && root->right == nullptr) {\\n            ans.push_back(path);\\n        }\\n        \\n        solve(root->left, targetSum - root->val, path, ans);\\n        solve(root->right, targetSum - root->val, path, ans);\\n        \\n        path.pop_back();\\n    }\\n\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        vector<vector<int>> ans;\\n        \\n        solve(root, targetSum, path, ans);\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int targetSum, vector<int>& path, vector<vector<int>>& ans) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        \\n        path.push_back(root->val);\\n        \\n        if (root->val == targetSum && root->left == nullptr && root->right == nullptr) {\\n            ans.push_back(path);\\n        }\\n        \\n        solve(root->left, targetSum - root->val, path, ans);\\n        solve(root->right, targetSum - root->val, path, ans);\\n        \\n        path.pop_back();\\n    }\\n\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        vector<vector<int>> ans;\\n        \\n        solve(root, targetSum, path, ans);\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643566,
                "title": "c-efficient",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define PB push_back\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        dfs(root, targetSum, path);\\n        return ans;\\n    }\\n    void dfs(TreeNode* root, int target, vector<int> &path){\\n        if(!root)\\n            return;\\n        target -= root->val;\\n        path.PB(root->val);\\n        if(!root->left && !root->right){\\n            if(target == 0)\\n                ans.PB(path);\\n        }\\n        else{\\n            dfs(root->left,target,path);\\n            dfs(root->right,target,path);\\n        }\\n        path.pop_back();\\n    }\\n};\\n```\\n\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define PB push_back\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        dfs(root, targetSum, path);\\n        return ans;\\n    }\\n    void dfs(TreeNode* root, int target, vector<int> &path){\\n        if(!root)\\n            return;\\n        target -= root->val;\\n        path.PB(root->val);\\n        if(!root->left && !root->right){\\n            if(target == 0)\\n                ans.PB(path);\\n        }\\n        else{\\n            dfs(root->left,target,path);\\n            dfs(root->right,target,path);\\n        }\\n        path.pop_back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613477,
                "title": "c-simple-dfs-backtracking-beats-90-runtime-98-memory",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> result; \\n        vector<int> path;\\n        dfs(root, targetSum, result, path);\\n        return result;\\n    }\\n\\nprivate:\\n    void dfs(TreeNode* root, int targetSum, vector<vector<int>>& result, vector<int>& path) {\\n        if (!root) return; \\n        path.emplace_back(root->val);\\n        // Has to be a leaf node \\n        if (targetSum == root->val && !root->left && !root->right)\\n            result.emplace_back(path);\\n        if (root->left)\\n            dfs(root->left, targetSum - root->val, result, path);\\n        if (root->right)\\n            dfs(root->right, targetSum - root->val, result, path);\\n        path.pop_back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> result; \\n        vector<int> path;\\n        dfs(root, targetSum, result, path);\\n        return result;\\n    }\\n\\nprivate:\\n    void dfs(TreeNode* root, int targetSum, vector<vector<int>>& result, vector<int>& path) {\\n        if (!root) return; \\n        path.emplace_back(root->val);\\n        // Has to be a leaf node \\n        if (targetSum == root->val && !root->left && !root->right)\\n            result.emplace_back(path);\\n        if (root->left)\\n            dfs(root->left, targetSum - root->val, result, path);\\n        if (root->right)\\n            dfs(root->right, targetSum - root->val, result, path);\\n        path.pop_back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582158,
                "title": "very-fast-and-optimised-faster-than-90-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// we had to pop/backtreck path if we\\'ve sent it by reference\\n    // void solve(TreeNode* &root, int &targetSum,int currSum,vector<int>path,vector<vector<int>> &ans){\\n    //     //base case 1\\n    //     if(root == NULL)    return;\\n    //     //2 leaf node\\n    //     if(root->left == NULL && root->right ==NULL){\\n    //         path.push_back(root->val);\\n    //         currSum += root->val;\\n    //         if(currSum == targetSum){\\n    //             ans.push_back(path);\\n    //         }\\n    //         return;\\n    //     }\\n    //     // one case - include current node;\\n    //     path.push_back(root->val);\\n    //     currSum += root->val;\\n\\n    //     solve(root->left,targetSum,currSum,path,ans);\\n    //     solve(root->right,targetSum,currSum,path,ans);\\n    // }\\n    // with popback\\n    void solve1(TreeNode* &root, int &targetSum,int currSum,vector<int>&path,vector<vector<int>> &ans){\\n        //base case 1\\n        if(root == NULL)    return;\\n        //2 leaf node\\n        if(root->left == NULL && root->right ==NULL){\\n            path.push_back(root->val);\\n            currSum += root->val;\\n            if(currSum == targetSum){\\n                ans.push_back(path);\\n            }\\n            path.pop_back();\\n            currSum -= root->val;\\n            return;\\n        }\\n        // one case - include current node;\\n        path.push_back(root->val);\\n        currSum += root->val;\\n\\n        solve1(root->left,targetSum,currSum,path,ans);\\n        solve1(root->right,targetSum,currSum,path,ans);\\n\\n        path.pop_back();\\n        currSum -= root->val;\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int>path;\\n        int currSum = 0;\\n        solve1(root,targetSum,currSum,path,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// we had to pop/backtreck path if we\\'ve sent it by reference\\n    // void solve(TreeNode* &root, int &targetSum,int currSum,vector<int>path,vector<vector<int>> &ans){\\n    //     //base case 1\\n    //     if(root == NULL)    return;\\n    //     //2 leaf node\\n    //     if(root->left == NULL && root->right ==NULL){\\n    //         path.push_back(root->val);\\n    //         currSum += root->val;\\n    //         if(currSum == targetSum){\\n    //             ans.push_back(path);\\n    //         }\\n    //         return;\\n    //     }\\n    //     // one case - include current node;\\n    //     path.push_back(root->val);\\n    //     currSum += root->val;\\n\\n    //     solve(root->left,targetSum,currSum,path,ans);\\n    //     solve(root->right,targetSum,currSum,path,ans);\\n    // }\\n    // with popback\\n    void solve1(TreeNode* &root, int &targetSum,int currSum,vector<int>&path,vector<vector<int>> &ans){\\n        //base case 1\\n        if(root == NULL)    return;\\n        //2 leaf node\\n        if(root->left == NULL && root->right ==NULL){\\n            path.push_back(root->val);\\n            currSum += root->val;\\n            if(currSum == targetSum){\\n                ans.push_back(path);\\n            }\\n            path.pop_back();\\n            currSum -= root->val;\\n            return;\\n        }\\n        // one case - include current node;\\n        path.push_back(root->val);\\n        currSum += root->val;\\n\\n        solve1(root->left,targetSum,currSum,path,ans);\\n        solve1(root->right,targetSum,currSum,path,ans);\\n\\n        path.pop_back();\\n        currSum -= root->val;\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int>path;\\n        int currSum = 0;\\n        solve1(root,targetSum,currSum,path,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582146,
                "title": "love-babbar-method-beginner-friendly-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// we had to pop/backtreck path if we\\'ve sent it by reference\\n    void solve(TreeNode* &root, int &targetSum,int currSum,vector<int>path,vector<vector<int>> &ans){\\n        //base case 1\\n        if(root == NULL)    return;\\n        //2 leaf node\\n        if(root->left == NULL && root->right ==NULL){\\n            path.push_back(root->val);\\n            currSum += root->val;\\n            if(currSum == targetSum){\\n                ans.push_back(path);\\n            }\\n            return;\\n        }\\n        // one case - include current node;\\n        path.push_back(root->val);\\n        currSum += root->val;\\n\\n        solve(root->left,targetSum,currSum,path,ans);\\n        solve(root->right,targetSum,currSum,path,ans);\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int>path;\\n        int currSum = 0;\\n        solve(root,targetSum,currSum,path,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// we had to pop/backtreck path if we\\'ve sent it by reference\\n    void solve(TreeNode* &root, int &targetSum,int currSum,vector<int>path,vector<vector<int>> &ans){\\n        //base case 1\\n        if(root == NULL)    return;\\n        //2 leaf node\\n        if(root->left == NULL && root->right ==NULL){\\n            path.push_back(root->val);\\n            currSum += root->val;\\n            if(currSum == targetSum){\\n                ans.push_back(path);\\n            }\\n            return;\\n        }\\n        // one case - include current node;\\n        path.push_back(root->val);\\n        currSum += root->val;\\n\\n        solve(root->left,targetSum,currSum,path,ans);\\n        solve(root->right,targetSum,currSum,path,ans);\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int>path;\\n        int currSum = 0;\\n        solve(root,targetSum,currSum,path,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579517,
                "title": "easy-cpp-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int target, int sum, vector<int> res, vector<vector<int>>& ans)\\n    {\\n        if(root==NULL) return;\\n\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            //cout<<\"inside\"<<endl;\\n            sum+=root->val;\\n            if(sum==target){\\n            res.push_back(root->val);\\n            ans.push_back(res);\\n            // cout<<\"inside inside\"<<endl;\\n            }\\n          return;\\n        }\\n        res.push_back(root->val);\\n        solve(root->left,target,sum+root->val,res,ans);\\n        solve(root->right,target,sum+root->val,res,ans);\\n        return;\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> res;\\n        vector<vector<int>> ans;\\n        int sum = 0;\\n        solve(root,targetSum,sum,res,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int target, int sum, vector<int> res, vector<vector<int>>& ans)\\n    {\\n        if(root==NULL) return;\\n\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            //cout<<\"inside\"<<endl;\\n            sum+=root->val;\\n            if(sum==target){\\n            res.push_back(root->val);\\n            ans.push_back(res);\\n            // cout<<\"inside inside\"<<endl;\\n            }\\n          return;\\n        }\\n        res.push_back(root->val);\\n        solve(root->left,target,sum+root->val,res,ans);\\n        solve(root->right,target,sum+root->val,res,ans);\\n        return;\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> res;\\n        vector<vector<int>> ans;\\n        int sum = 0;\\n        solve(root,targetSum,sum,res,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3565992,
                "title": "1ms-java-solution-dfs-recursion-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private ArrayList<List<Integer>> res;\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        res = new ArrayList<List<Integer>>();\\n        if (root != null) {\\n            path (root, targetSum, new ArrayList<>());\\n        }\\n        return res;\\n    }\\n\\n    private void path(TreeNode node, int targetSum, List<Integer> currList) {\\n        if (node == null) {\\n            return;\\n        }\\n        targetSum -= node.val;\\n\\n        currList.add(node.val);\\n        \\n        if (node.left == null && node.right == null) {\\n            if (targetSum == 0) {\\n                res.add(new ArrayList<>(currList));\\n            }\\n            currList.remove(currList.size() - 1);\\n            return;\\n        }\\n        path(node.left, targetSum, currList);\\n        path(node.right, targetSum, currList);\\n        currList.remove(currList.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private ArrayList<List<Integer>> res;\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        res = new ArrayList<List<Integer>>();\\n        if (root != null) {\\n            path (root, targetSum, new ArrayList<>());\\n        }\\n        return res;\\n    }\\n\\n    private void path(TreeNode node, int targetSum, List<Integer> currList) {\\n        if (node == null) {\\n            return;\\n        }\\n        targetSum -= node.val;\\n\\n        currList.add(node.val);\\n        \\n        if (node.left == null && node.right == null) {\\n            if (targetSum == 0) {\\n                res.add(new ArrayList<>(currList));\\n            }\\n            currList.remove(currList.size() - 1);\\n            return;\\n        }\\n        path(node.left, targetSum, currList);\\n        path(node.right, targetSum, currList);\\n        currList.remove(currList.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947108,
                "title": "c-6ms-easy-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int targetSum,int &total, vector<vector<int>> &vect, vector<int> &vv)\\n    {\\n        int c=0;\\n        if(root ==NULL)\\n        {\\n            return;\\n        }\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            total = total + root->val;\\n            if(targetSum == total)\\n            {\\n                c=1;\\n                vv.push_back(root->val);\\n                vect.push_back(vv);\\n                total = total - root->val;\\n                vv.pop_back();\\n            }\\n            else\\n            {\\n                c=0;\\n                total = total - root->val;\\n            }\\n            return;\\n        }                                           \\n        vv.push_back(root->val);\\n        total = total + root->val;\\n        solve(root->left ,targetSum,total,vect ,vv);\\n        solve(root->right ,targetSum, total, vect,vv);\\n        total = total - root->val;\\n        if(!vv.empty())\\n        {\\n            vv.pop_back();\\n        }\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        int total = 0;\\n        int count = 0;\\n        vector<int> vv;\\n        vector<vector<int>> vect;\\n        solve(root,targetSum, total,vect,vv);\\n        return vect;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int targetSum,int &total, vector<vector<int>> &vect, vector<int> &vv)\\n    {\\n        int c=0;\\n        if(root ==NULL)\\n        {\\n            return;\\n        }\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            total = total + root->val;\\n            if(targetSum == total)\\n            {\\n                c=1;\\n                vv.push_back(root->val);\\n                vect.push_back(vv);\\n                total = total - root->val;\\n                vv.pop_back();\\n            }\\n            else\\n            {\\n                c=0;\\n                total = total - root->val;\\n            }\\n            return;\\n        }                                           \\n        vv.push_back(root->val);\\n        total = total + root->val;\\n        solve(root->left ,targetSum,total,vect ,vv);\\n        solve(root->right ,targetSum, total, vect,vv);\\n        total = total - root->val;\\n        if(!vv.empty())\\n        {\\n            vv.pop_back();\\n        }\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        int total = 0;\\n        int count = 0;\\n        vector<int> vv;\\n        vector<vector<int>> vect;\\n        solve(root,targetSum, total,vect,vv);\\n        return vect;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678072,
                "title": "java-dfs-solution-recursive",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> res = new ArrayList<>();\\n    List<Integer> list = new ArrayList<>();\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        if(root == null) return res;\\n        dfs(root, targetSum);\\n        return res;\\n    }\\n    \\n    void dfs(TreeNode root, int targetSum){\\n        if(root == null) return;\\n        targetSum -= root.val;\\n        list.add(root.val);\\n        if(root.left == null && root.right == null && targetSum == 0){\\n            res.add(new ArrayList<>(list));\\n        } \\n        pathSum(root.left, targetSum);\\n        pathSum(root.right, targetSum); \\n        targetSum += root.val;\\n        list.remove(list.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> res = new ArrayList<>();\\n    List<Integer> list = new ArrayList<>();\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        if(root == null) return res;\\n        dfs(root, targetSum);\\n        return res;\\n    }\\n    \\n    void dfs(TreeNode root, int targetSum){\\n        if(root == null) return;\\n        targetSum -= root.val;\\n        list.add(root.val);\\n        if(root.left == null && root.right == null && targetSum == 0){\\n            res.add(new ArrayList<>(list));\\n        } \\n        pathSum(root.left, targetSum);\\n        pathSum(root.right, targetSum); \\n        targetSum += root.val;\\n        list.remove(list.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657933,
                "title": "java-1ms-100-faster",
                "content": "\\nclass Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        \\n        List<List<Integer>>res = new ArrayList<>();\\n        List<Integer>ans = new ArrayList<>();\\n        \\n         helper(root,targetSum,res,ans);\\n        \\n        return res;\\n        \\n    }\\n    \\n    \\n    public void helper(TreeNode root , int targetSum , List<List<Integer>>res , List<Integer>ans){\\n        \\n        if(root == null){\\n            return;\\n        }\\n        \\n        if(root.left ==null && root.right == null){\\n            if(targetSum == root.val){\\n                List<Integer>newList = new ArrayList<>(ans);\\n                newList.add(root.val);\\n                res.add(newList);\\n                return;\\n            }\\n        }\\n        \\n        ans.add(root.val);\\n        helper(root.left , targetSum-root.val , res , ans);\\n        helper(root.right,targetSum-root.val , res,ans);\\n        ans.remove(ans.size()-1);\\n        return;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        \\n        List<List<Integer>>res = new ArrayList<>();\\n        List<Integer>ans = new ArrayList<>();\\n        \\n         helper(root,targetSum,res,ans);\\n        \\n        return res;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2621908,
                "title": "c-simple-solution-7ms",
                "content": "The solution is quite simple if you understand dfs. All you have to do is modify the path according to your leaf and push it into the answer vector if the sum equals target.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> paths;\\n    vector<int> path; bool p=false;\\n    \\n    void pathtrace(TreeNode* root, int sum)\\n    {\\n        if(!root)\\n            return;\\n        \\n        path.push_back(root->val);\\n        if(!root->left && !root->right && sum==root->val)\\n            paths.push_back(path);\\n\\n        pathtrace(root->left, sum-root->val);\\n        pathtrace(root->right, sum-root->val);\\n        path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) \\n    {\\n        if(!root)\\n            return {};\\n        \\n        pathtrace(root, targetSum);\\n        return paths;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> paths;\\n    vector<int> path; bool p=false;\\n    \\n    void pathtrace(TreeNode* root, int sum)\\n    {\\n        if(!root)\\n            return;\\n        \\n        path.push_back(root->val);\\n        if(!root->left && !root->right && sum==root->val)\\n            paths.push_back(path);\\n\\n        pathtrace(root->left, sum-root->val);\\n        pathtrace(root->right, sum-root->val);\\n        path.pop_back();\\n    }\\n    \\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) \\n    {\\n        if(!root)\\n            return {};\\n        \\n        pathtrace(root, targetSum);\\n        return paths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619326,
                "title": "dfs-easy-c-solution-beginner",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void dfs(TreeNode* root, int targetSum,vector<int> path, int curr){\\n        if(!root) return;\\n        curr+=root->val;\\n        path.push_back(root->val);\\n        if(curr==targetSum && !root->left && !root->right) result.push_back(path);\\n        dfs(root->left,targetSum,path,curr);\\n        dfs(root->right,targetSum,path,curr);\\n        path.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        dfs(root,targetSum,path,0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void dfs(TreeNode* root, int targetSum,vector<int> path, int curr){\\n        if(!root) return;\\n        curr+=root->val;\\n        path.push_back(root->val);\\n        if(curr==targetSum && !root->left && !root->right) result.push_back(path);\\n        dfs(root->left,targetSum,path,curr);\\n        dfs(root->right,targetSum,path,curr);\\n        path.pop_back();\\n    }\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<int> path;\\n        dfs(root,targetSum,path,0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619054,
                "title": "java-solution-dfs-recursion",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList<>();\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        if(root != null) dfs(root, targetSum, 0, new ArrayList<>());\\n        return result;\\n    }\\n    \\n    private void dfs(TreeNode node, int target, int currentSum, List<Integer> currentList) {\\n        currentSum += node.val;\\n        currentList.add(node.val);\\n        if(node.left == null && node.right == null && currentSum == target) result.add(currentList);\\n        if(node.left != null) dfs(node.left, target, currentSum, new ArrayList<>(currentList));\\n        if(node.right != null) dfs(node.right, target, currentSum, new ArrayList<>(currentList));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList<>();\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n        if(root != null) dfs(root, targetSum, 0, new ArrayList<>());\\n        return result;\\n    }\\n    \\n    private void dfs(TreeNode node, int target, int currentSum, List<Integer> currentList) {\\n        currentSum += node.val;\\n        currentList.add(node.val);\\n        if(node.left == null && node.right == null && currentSum == target) result.add(currentList);\\n        if(node.left != null) dfs(node.left, target, currentSum, new ArrayList<>(currentList));\\n        if(node.right != null) dfs(node.right, target, currentSum, new ArrayList<>(currentList));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619033,
                "title": "python-98-faster-simple-python-code-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/3efdd4e4-761f-4dcb-b717-a72a49b9a93f_1664037856.0979905.png)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        if not root: return None\\n\\t\\t#Final Result list\\n        res = []\\n\\t\\t# Creating Stack for faster Insertion and Deletion\\n        path = collections.deque() \\n        \\n\\t\\t#dfs is define inside the pathSum method so we don\\'t have to pass the path and res list\\n        def dfs(node, s):\\n\\t\\t\\t#Adding value of node to stack as well as to sum (s)\\n            path.append(node.val)\\n            s += node.val\\n\\t\\t\\t#Checking Whether it is a leaf node and also whether sum value is equal to targetSum\\n            if  not node.left and not node.right and s == targetSum:\\n                res.append(list(path))\\n            # If not then we will continue with our dfs by recursively going to left node and right node if exist.\\n\\t\\t\\tif node.left:\\n                dfs(node.left, s)\\n            if  node.right:\\n                dfs(node.right, s)\\n\\t\\t\\t# Lastly, remove the node value from path and sum before exiting from the dfs\\n            s -= node.val\\n            path.pop()\\n        #Calling our dfs method and passing root as main node and sum(s) as 0\\n\\t\\tdfs(root, 0)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\\n        if not root: return None\\n\\t\\t#Final Result list\\n        res = []\\n\\t\\t# Creating Stack for faster Insertion and Deletion\\n        path = collections.deque() \\n        \\n\\t\\t#dfs is define inside the pathSum method so we don\\'t have to pass the path and res list\\n        def dfs(node, s):\\n\\t\\t\\t#Adding value of node to stack as well as to sum (s)\\n            path.append(node.val)\\n            s += node.val\\n\\t\\t\\t#Checking Whether it is a leaf node and also whether sum value is equal to targetSum\\n            if  not node.left and not node.right and s == targetSum:\\n                res.append(list(path))\\n            # If not then we will continue with our dfs by recursively going to left node and right node if exist.\\n\\t\\t\\tif node.left:\\n                dfs(node.left, s)\\n            if  node.right:\\n                dfs(node.right, s)\\n\\t\\t\\t# Lastly, remove the node value from path and sum before exiting from the dfs\\n            s -= node.val\\n            path.pop()\\n        #Calling our dfs method and passing root as main node and sum(s) as 0\\n\\t\\tdfs(root, 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618514,
                "title": "no-helpers-single-return-statement",
                "content": "```\\nvar pathSum = function(node, targetSum, paths = [], rootToLeaf = []) {\\n    if(node) {\\n        const remaining = targetSum - node.val;\\n        \\n        rootToLeaf.push(node.val); \\n        \\n        if(!node.left && !node.right && remaining === 0) paths.push([...rootToLeaf]);\\n        \\n        pathSum(node.left, remaining, paths, rootToLeaf);\\n        pathSum(node.right,remaining, paths, rootToLeaf);\\n        \\n        rootToLeaf.pop();\\n    }\\n\\n    return paths;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar pathSum = function(node, targetSum, paths = [], rootToLeaf = []) {\\n    if(node) {\\n        const remaining = targetSum - node.val;\\n        \\n        rootToLeaf.push(node.val); \\n        \\n        if(!node.left && !node.right && remaining === 0) paths.push([...rootToLeaf]);\\n        \\n        pathSum(node.left, remaining, paths, rootToLeaf);\\n        pathSum(node.right,remaining, paths, rootToLeaf);\\n        \\n        rootToLeaf.pop();\\n    }\\n\\n    return paths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2618236,
                "title": "could-someone-tell-me-why-this-solution-is-not-working-for-more-testcases",
                "content": "\\tclass Solution:\\n\\n\\t\\tdef pathSum(self, root: Optional[TreeNode], targetSum: int,res = [],path = []) -> List[List[int]]:\\n\\n\\t\\t\\tif not root: return res \\n\\n\\t\\t\\tif root.val == targetSum and root.left == root.right == None: \\n\\t\\t\\t\\tres.append(path+[root.val]) \\n\\t\\t\\t\\treturn res \\n\\t\\t\\tself.pathSum(root.left,targetSum-root.val,res,path + [root.val]) \\n\\t\\t\\tself.pathSum(root.right,targetSum-root.val,res,path + [root.val]) \\n\\n\\t\\t\\treturn res \\n\\t\\t\\t\\n\\t\\t\\t# Not working for more than one testcases at a time \\n\\t\\t\\t# Working for all testcases if one testcase is running at a time on terminal.",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\n\\t\\tdef pathSum(self, root: Optional[TreeNode], targetSum: int,res = [],path = []) -> List[List[int]]:\\n\\n\\t\\t\\tif not root: return res \\n\\n\\t\\t\\tif root.val == targetSum and root.left == root.right == None: \\n\\t\\t\\t\\tres.append(path+[root.val]) \\n\\t\\t\\t\\treturn res \\n\\t\\t\\tself.pathSum(root.left,targetSum-root.val,res,path + [root.val]) \\n\\t\\t\\tself.pathSum(root.right,targetSum-root.val,res,path + [root.val]) \\n\\n\\t\\t\\treturn res \\n\\t\\t\\t\\n\\t\\t\\t# Not working for more than one testcases at a time \\n\\t\\t\\t# Working for all testcases if one testcase is running at a time on terminal.",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1785083,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1572076,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1940072,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1574731,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1571235,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1857338,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1571236,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1975003,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 2024697,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1999000,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1785083,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1572076,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1940072,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1574731,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1571235,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1857338,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1571236,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1975003,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 2024697,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            },
            {
                "id": 1999000,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Excellent question to mix backtracking with trees. Impressive!"
                    },
                    {
                        "username": "mahaswec",
                        "content": "Shouldn\\'t the [1,2]  sum 1 test case result be [1]?The official answer is [[]] and I am confused.\\nInfact I find several of them contrary to what I expected. The expected results are empty whereas there clearly is a path."
                    },
                    {
                        "username": "kozmic_jazz",
                        "content": "the only paths we care about are from root to leaf, so, as the other person who responded pointed out, no"
                    },
                    {
                        "username": "kostyafarber",
                        "content": "No because the tree looks like so:\n\n       1\n      /  \n     2\n\nWe can't count the root because it's not a leaf node (i.e it has a left child)."
                    },
                    {
                        "username": "dash_dash",
                        "content": "lovely question , wasted my 2hrs tho "
                    },
                    {
                        "username": "psnehas",
                        "content": "![image](https://assets.leetcode.com/users/images/bbd1e020-13ba-4f6f-b741-066e8c2daef4_1608944959.5371606.png)\\nIn the solution given, the pathNodes list is again converted to list before appending to the pathsList result (line 22 highlighted). I am curious to know the reason behind this step as pathNodes is already a list. When I tried without conversion, the result contained empty lists."
                    },
                    {
                        "username": "andyguo1023",
                        "content": "in this case pathNodes is passed in as a reference to the list, so if we append a reference, we are not appending the list itself. "
                    },
                    {
                        "username": "redfriday",
                        "content": "Input: {1}, 0 \\nOutput: [ [ ] ] \\nExpected: [ ]"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "These trees questions have been deadly recently"
                    },
                    {
                        "username": "hhk1989",
                        "content": "Is it fair to assume that node values are all positive integers ? In that case I believe I can avoid searching below nodes whose path values from root already equal or is greater than sum."
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "this should be easy \\nbut if you see this hard you should do more DFS and backtracking it not that hard"
                    },
                    {
                        "username": "eus102025",
                        "content": "Hmm for this testcase: [1,-2,-3,1,3,-2,null,-1] I'm getting marked as wrong as it says it returned [[-2,1,3]] but when I ran it in VS 2019 I'm actually getting the expected: [[1,-2,3]]. What gives?"
                    },
                    {
                        "username": "itmevic",
                        "content": "UR code is prob wrong then. There is no way u returned -2 first in [[-2,1,3]] ,since its not the root"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "How does this Test case <[1,2,null,3,null,4,null,5] , 6> results in [[1,2,3]] ? Can anyone please explain ?\n\nSame case for this : <[1,2,null,3], 3>, [[1,2]].\n\nThis implies that The root node we can choose to be any node with less than 3 links/children from anywhere in the tree.\n\nDoes the question expects us to consider this ? Otherwise this test case does not make sense. "
                    },
                    {
                        "username": "itmevic",
                        "content": "[1,2,3] is not a valid answer for a target of 6. Its from root to leaf only. Please read the directions. "
                    }
                ]
            }
        ]
    }
]