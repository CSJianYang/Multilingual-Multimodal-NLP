[
    {
        "title": "Promise Time Limit",
        "question_content": "Given an&nbsp;asynchronous function&nbsp;fn&nbsp;and a time t&nbsp;in milliseconds, return&nbsp;a new&nbsp;time limited&nbsp;version of the input function. fn takes arguments provided to the&nbsp;time limited&nbsp;function.\nThe time limited function should follow these rules:\n\n\tIf the fn completes within the time limit of t milliseconds, the time limited function should&nbsp;resolve with the result.\n\tIf the execution of the fn exceeds the time limit, the time limited function should reject with the string \"Time Limit Exceeded\".\n\n&nbsp;\nExample 1:\n\nInput: \nfn = async (n) => { \n&nbsp; await new Promise(res => setTimeout(res, 100)); \n&nbsp; return n * n; \n}\ninputs = [5]\nt = 50\nOutput: {\"rejected\":\"Time Limit Exceeded\",\"time\":50}\nExplanation:\nconst limited = timeLimit(fn, t)\nconst start = performance.now()\nlet result;\ntry {\n&nbsp; &nbsp;const res = await limited(...inputs)\n&nbsp; &nbsp;result = {\"resolved\": res, \"time\": Math.floor(performance.now() - start)};\n} catch (err) {\n&nbsp;  result = {\"rejected\": err, \"time\": Math.floor(performance.now() - start)};\n}\nconsole.log(result) // Output\nThe provided function is set to resolve after 100ms. However, the time limit is set to 50ms. It rejects at t=50ms because the time limit was reached.\n\nExample 2:\n\nInput: \nfn = async (n) => { \n&nbsp; await new Promise(res => setTimeout(res, 100)); \n&nbsp; return n * n; \n}\ninputs = [5]\nt = 150\nOutput: {\"resolved\":25,\"time\":100}\nExplanation:\nThe function resolved 5 * 5 = 25 at t=100ms. The time limit is never reached.\n\nExample 3:\n\nInput: \nfn = async (a, b) => { \n&nbsp; await new Promise(res => setTimeout(res, 120)); \n&nbsp; return a + b; \n}\ninputs = [5,10]\nt = 150\nOutput: {\"resolved\":15,\"time\":120}\nExplanation:\n​​​​The function resolved 5 + 10 = 15 at t=120ms. The time limit is never reached.\n\nExample 4:\n\nInput: \nfn = async () => { \n&nbsp; throw \"Error\";\n}\ninputs = []\nt = 1000\nOutput: {\"rejected\":\"Error\",\"time\":0}\nExplanation:\nThe function immediately throws an error.\n&nbsp;\nConstraints:\n\n\t0 <= inputs.length <= 10\n\t0 <= t <= 1000\n\tfn returns a promise",
        "solutions": [
            {
                "id": 3406548,
                "title": "easy-promise-race-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3413842,
                "title": "settimeout-within-promise-body",
                "content": "# Approach\\nUse promise and call setTimeout for given time t.\\nThis is async call, next line will be executed just after this  call, if callback is returned before next line completes execution then it will return promise rejection, otherwise promise will resolve regurarly.\\n\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject);\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject);\\n        });\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529233,
                "title": "promise-real-life-example-dry-run-usecase-o-1-js-ts-beginner-friendly-day12",
                "content": "#Note it will better if you read ***[this post](https://leetcode.com/problems/sleep/discuss/3525419/Promise-oror-Examples-oror-Dry-Run-oror-Usecase-oror-O(1)-oror-JS-and-TS-oror-Beginner-Friendly-oror-Day11)*** before reading this post as its a continuation type of post  \\n***\\n## Problem Summary:\\n* Given an `asynchronous` function fn and a time limit `t` in milliseconds, we need to create a new time-limited version of the input function. \\n* The time-limited function should behave identically to the original function, except that if it takes longer than `t` milliseconds to fulfill, it should reject with the string` \"Time Limit Exceeded\"`.\\n***\\n## Intuition:\\nWe can use a combination of `Promise`, `setTimeout`, and `async/await` to implement the time-limited function. By setting a timeout using `setTimeout`, we can enforce the time limit and reject the promise if it exceeds the specified duration.\\n***\\n## Approach:\\n* Create a wrapper function that takes the original function `fn` and the time limit `t` as parameters.\\n* Within the wrapper function, return an `async` function that accepts any number of arguments using the spread operator `...args`.\\n* Inside the `async` function, create a new `Promise` to handle the `asynchronous` execution.\\n* Use `setTimeout` to set a timer with the time limit `t`. If the timer expires before the promise is resolved, reject the `promise` with the string `\"Time Limit Exceeded\"`.\\n* Call the original function `fn` with the provided arguments `...args` and `await` its completion.\\n* If the function completes before the time limit, resolve the promise with the result.\\n* Return the promise from the `async` function.\\n***\\n## Concepts : \\n### you can refer ***[this post](https://leetcode.com/problems/sleep/discuss/3525419/Promise-oror-Examples-oror-Dry-Run-oror-Usecase-oror-O(1)-oror-JS-and-TS-oror-Beginner-Friendly-oror-Day11)*** it has detailed explanation of these concepts\\n* Asynchronous functions\\n* Promises\\n* setTimeout\\n* async/await\\n***\\n## Solutions: \\n**Javascript Solution:**\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((delayresolve, reject) => {\\n      const timeoutId = setTimeout(() => {\\n        clearTimeout(timeoutId);\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeoutId);\\n          delayresolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeoutId);\\n          reject(error);\\n        });\\n    });\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n**Typescript Solution:**\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function (...args: any[]) {\\n    return new Promise((delayresolve, reject) => {\\n      const timeoutId = setTimeout(() => {\\n        clearTimeout(timeoutId);\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeoutId);\\n          delayresolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeoutId);\\n          reject(error);\\n        });\\n    });\\n  };\\n}\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n***\\n**Time Complexity: O(fn)\\nSpace Complexity: O(1)**\\n***\\n## Real life Example:\\n```\\nasync function fetchData() {\\n  return new Promise((delayresolve) => {\\n    setTimeout(() => {\\n      delayresolve(\"Data fetched successfully!\");\\n    }, 2000);\\n  });\\n}\\n\\nconst timeLimitedFetchData = timeLimit(fetchData, 1500);\\n\\ntimeLimitedFetchData().then((result) => {\\n  console.log(result);\\n}).catch((error) => {\\n  console.error(error);\\n});\\n```\\n**Now Letsss discuss the flow of the code:** **Less go**\\n* We have an `asynchronous` function `fetchData` that simulates fetching data by returning a `promise` that `resolves` after a delay of `2000` milliseconds.\\n* We create a time-limited version of `fetchData` using `timeLimit` and provide the function and a time limit of `1500` milliseconds.\\n* We call the time-limited function `timeLimitedFetchData` without any arguments.\\n* Inside the time-limited function, a new `promise` is created to handle the `asynchronous` execution.\\n* A timer is set using `setTimeout` for `1500` milliseconds.\\n* The original `fetchData` function is called with no arguments and awaited for its completion.\\n* Since the original function takes `2000` milliseconds to complete, it exceeds the time limit of `1500` milliseconds.\\n* The timer expires, and the `promise` is rejected with the string `\"Time Limit Exceeded\"`.\\n* The rejection is caught in the catch block, and an error message is logged to the console. \\nThat\\'s it you got it!!\\n***\\n*We all have silly questions, so don\\'t be afraid to ask them. I will gladly answer them!!*",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((delayresolve, reject) => {\\n      const timeoutId = setTimeout(() => {\\n        clearTimeout(timeoutId);\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeoutId);\\n          delayresolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeoutId);\\n          reject(error);\\n        });\\n    });\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function (...args: any[]) {\\n    return new Promise((delayresolve, reject) => {\\n      const timeoutId = setTimeout(() => {\\n        clearTimeout(timeoutId);\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeoutId);\\n          delayresolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeoutId);\\n          reject(error);\\n        });\\n    });\\n  };\\n}\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```\\nasync function fetchData() {\\n  return new Promise((delayresolve) => {\\n    setTimeout(() => {\\n      delayresolve(\"Data fetched successfully!\");\\n    }, 2000);\\n  });\\n}\\n\\nconst timeLimitedFetchData = timeLimit(fetchData, 1500);\\n\\ntimeLimitedFetchData().then((result) => {\\n  console.log(result);\\n}).catch((error) => {\\n  console.error(error);\\n});\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529228,
                "title": "detailed-explanation-of-solution-using-promise-in-javascript-promise-race-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n 1.Acc to Problem statement we have function fn returning Promise and  time T.if this function takes larger time than T to resolve then we have to return new Promise which reject after Time T with \"Time Limit Exceeded\" message otherwise we have to return fn.\\n2. That means we have to return that Promise which settles earlier and for this `Promise.race([p1,p2])` is used, where p1 and p2 are promised.\\n3.This method takes list of promises and returns that promise which settles earliar.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - We will first create original Promise that is return by fn and rejectedPromise that reject after T ms.\\n - Once we have these promises, we will return a promise betweeen these two which settles earliar.\\n# Complexity\\n- Time complexity: O(min(Time taken to settles among all Promises))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n           const originalPromise=fn(...args);\\n           const rejectPromise=new Promise((resolve,reject)=>{setTimeout(()=>{\\n               reject(\"Time Limit Exceeded\")\\n           },t);\\n           });\\n          return Promise.race([originalPromise,rejectPromise]);  \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n           const originalPromise=fn(...args);\\n           const rejectPromise=new Promise((resolve,reject)=>{setTimeout(()=>{\\n               reject(\"Time Limit Exceeded\")\\n           },t);\\n           });\\n          return Promise.race([originalPromise,rejectPromise]);  \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3411232,
                "title": "easy-to-understand-javascript-typescript-begineer-friendly",
                "content": "# Explaination\\nThe Promise.race() method is one of the promise concurrency methods. It\\'s useful when you want the first async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\\n\\nIf the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to the first of these values found in the iterable.\\n\\n***The Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.***\\n\\n### Note\\n***If the iterable contains one or more non-promise value and/or an already settled promise, then Promise.race will settle to the first of these values found in the array:***\\n\\n\\n\\n# Code\\n```TypeScript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n```JavaScript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```TypeScript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```JavaScript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004290,
                "title": "javascript-promises-api-functionality",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAccording to the given problem statement.,\\n->  *if function `fn() executed before the given time period t`, then it\\'s considered that execution is \"**successful**\"*\\n->  *if function `fn() executed after the given time period t`, then it\\'s considered that execution is \"**failed**\"*\\n\\nWe need to implement a normal function execution within the time limit & a rejected function with \"Time limit exceeded\" using Promise constructor.\\n\\n*Why Promise constructor when we can achieve the same using any asynchronous function by throwing an error of \\'time limit exceeded\\'?*\\n\\nTo impose Promise API functionality on the obtained results.\\n\\n> **`Promise.race()`**, which waits only for the first settled promise and gets its result (or error)\\n\\nLet\\'s get it on!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe timeLimit function takes two arguments an asynchronous function **`fn()`** and a time **`t`** in milliseconds\\n\\nreturn an *`async function`* with arbitrary number of arguments which are passed to **`fn()`**\\n\\n**`fn()`** performs a certain execution operation and to be executed before the **`time limit t`**\\n-   ***cond1*** - a successful function exec., ***funcExec = fn(...args)***\\n-   ***cond2*** - when the time limit is exceeded before the execution of above function, a failed function exec., ***funcRej = new promise((_, reject) => {})***\\n\\nimplement a new Promise constructor\\n```\\nlet funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n```\\nthe constructor returns a rejected promise depending on `t`\\n\\nNow impose a Promise API functionality with **Promise.race()** which takes an array of resolved / rejected promises as parameters\\n**`Promise.race([ ])`**\\n\\nreturn the result \\n```\\nPromise.race([funcExec, funcRej])\\n```\\n\\n`funcExec` *is executed with a result before t milliseconds*\\n`funcRej` *is executed with an error after t milliseconds*\\n# Complexity\\n- **Time complexity :**   $$O(min(funcExecTime, funcRejTime))$$ ~ $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- **Space complexity :**  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let funcExec = fn(...args);\\n        let funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n        return Promise.race([funcExec, funcRej])\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n```\n```\\nPromise.race([funcExec, funcRej])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3465010,
                "title": "double-arrow-function-simple-4-line-of-code",
                "content": "# Code\\n```js\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = (fn, t) => (...args) => new Promise((resolve, reject) => {\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    fn(...args).then(resolve).catch(reject);\\n});\\n```\\n\\n# Explanation\\n\\nAn arrow function `var timeLimit = (fn, t) =>` returns another arrow function `(...args) =>` that returns a `Promise`.\\n\\nOn the promise handler, I created *timeout* and on the callback we reject the promise with the message. `setTimeout(() => reject(\"Time Limit Exceeded\"), t);`\\nIf the function doesn\\'t complete within the `t` time, then the callback of *setTimeout* will be called.\\n\\nOn the next line, I called `fn` function with the `...args`. I used spread sytanx. \\nIf the function get done successfully then the `resolve` function will be called. On error `reject` function will be called.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = (fn, t) => (...args) => new Promise((resolve, reject) => {\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    fn(...args).then(resolve).catch(reject);\\n});\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3411903,
                "title": "accepted-javascript",
                "content": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return await Promise.race([\\n            new Promise(resolve => resolve(fn(...args))),\\n            new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))\\n        ]);\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return await Promise.race([\\n            new Promise(resolve => resolve(fn(...args))),\\n            new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))\\n        ]);\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529118,
                "title": "java-script-solution-for-promise-time-limit-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this code is to enforce a time limit on a given function. It wraps the function in a new function that returns a promise. If the wrapped function exceeds the specified time limit, it rejects the promise with a \"Time Limit Exceeded\" error.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The timeLimit function takes two parameters: fn, which is the function to be time-limited, and t, which is the time limit in milliseconds.\\n2. It returns an async function that accepts any number of arguments (...args) and returns a promise.\\n3. Within the returned async function, a new promise is created to handle the time limit.\\n4. A timeout is set using setTimeout, which will reject the promise after t milliseconds if it hasn\\'t been resolved or rejected before that.\\n5. The wrapped function (fn) is invoked with the provided arguments using await.\\n6. If the wrapped function resolves successfully, the result is passed to resolve of the promise created in step 3.\\n7. If an error occurs during the execution of the wrapped function, it is caught, and the promise is rejected with the error.\\n8. Regardless of whether the wrapped function resolves or rejects, the timeout is cleared using clearTimeout to prevent it from triggering after the function has completed.\\n9. The time-limited function returns the promise.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is dependent on the time complexity of the wrapped function (fn). The time limit is enforced by setting a timeout, which doesn\\'t affect the time complexity of the wrapped function itself. Therefore, the time complexity of the code can be considered the same as the time complexity of the wrapped function.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is determined by the memory required to store the wrapped function and the promise. Since the wrapped function and promise are created within the returned function and not stored outside, the space complexity is minimal and mainly depends on the wrapped function and its internal operations.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531308,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is designed to make sure a function doesn\\'t take too long to execute by setting a time limit on it. It does this by wrapping the function in a new function that returns a promise. If the wrapped function takes too long to execute, the promise is rejected with an error message that says \"Time Limit Exceeded\".\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The timeLimit function takes two arguments: \"fn\", which is the function to be time-limited, and \"t\", which is the time limit in milliseconds.\\n- It returns a new asynchronous function that can take any number of arguments using the spread syntax (...args) and returns a promise.\\n- Inside the returned async function, a new promise is created to handle the time limit.\\n- A timeout is set using the setTimeout function, which will reject the promise after t milliseconds if it hasn\\'t been resolved or rejected before that.\\n- The wrapped function (fn) is then called with the provided arguments using the \"await\" keyword.\\n- If the wrapped function resolves successfully, its result is passed to the \"resolve\" function of the promise created in step 3.\\n- If an error occurs during the execution of the wrapped function, it is caught, and the promise is rejected with the error.\\n- Regardless of whether the wrapped function resolves or rejects, the timeout is cleared using clearTimeout to prevent it from triggering after the function has completed.\\n- Finally, the time-limited function returns the promise created in step 3.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n        const tt = setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        try {\\n            const result = await fn(...args);\\n            resolve(result);\\n        } catch(err) {\\n            reject(err);\\n        }\\n        clearTimeout(tt);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n        const tt = setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        try {\\n            const result = await fn(...args);\\n            resolve(result);\\n        } catch(err) {\\n            reject(err);\\n        }\\n        clearTimeout(tt);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438827,
                "title": "promise-and-settimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I saw that the return was an asynchronous function, my first thought was to return a promise from this function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first thing is, by using the setTimeout function we reject the promise when the given time (``` t ```) has expired, we store the timeout\\'s id for the purpose of clearing the memory. If the promise isn\\'t rejected with the timeout, it\\'s because the time it took to complete the promise of the given function was less than ```t```. Therefore, we simply handle it. Finally, we delete the id of the timeout to clear the memory.\\n\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n    return new Promise((res, rej) => {\\n      const timeoutID = setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n\\n      fn(...args).then(res).catch(rej).finally(() => {clearTimeout(timeoutID)});\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "``` t ```\n```t```\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n    return new Promise((res, rej) => {\\n      const timeoutID = setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n\\n      fn(...args).then(res).catch(rej).finally(() => {clearTimeout(timeoutID)});\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3414762,
                "title": "easy-simple-javascript-solution",
                "content": "\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns=fn(...args);\\n        const p=new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\\'Time Limit Exceeded\\')\\n            },t);\\n\\n        })\\n\\n        return Promise.race([fns,p]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns=fn(...args);\\n        const p=new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\\'Time Limit Exceeded\\')\\n            },t);\\n\\n        })\\n\\n        return Promise.race([fns,p]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027403,
                "title": "promise-race-easy-js-solution",
                "content": "# Intuition\\nWe want to create a version of an asynchronous function that has a time limit. If the function completes within the time limit, it should return the result; otherwise, it should reject with a specific message.\\n\\n# Approach\\n1. We define a timeLimit function that takes two parameters: the asynchronous function fn and the time limit t.\\n\\n2. Inside the timeLimit function, we return an asynchronous function that can accept any number of arguments using the ...args syntax.\\n\\n3. We create a promise called myPromise that will resolve with the string \"success\" after a timeout of t milliseconds.\\n\\n4. We use Promise.race() to race two promises: myPromise and the execution of fn(...args).\\n\\n5. If myPromise wins the race (timeout is reached before fn completes), we return a new promise that rejects with the message \"Time Limit Exceeded.\"\\n\\n6. If fn wins the race (completes within the time limit), we return a new promise that resolves with the result obtained from fn.\\n\\n7. This code effectively provides a time-limited version of the input function fn.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const myPromise=new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                resolve(\"success\");\\n            },t)\\n        })\\n        const ans=await Promise.race([myPromise,fn(...args)]);\\n        if(ans==\"success\"){\\n            return new Promise((resolve,reject)=>{\\n                reject(\"Time Limit Exceeded\")\\n            })\\n        }\\n        return new Promise((resolve,reject)=>{\\n            resolve(ans)\\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const myPromise=new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                resolve(\"success\");\\n            },t)\\n        })\\n        const ans=await Promise.race([myPromise,fn(...args)]);\\n        if(ans==\"success\"){\\n            return new Promise((resolve,reject)=>{\\n                reject(\"Time Limit Exceeded\")\\n            })\\n        }\\n        return new Promise((resolve,reject)=>{\\n            resolve(ans)\\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879331,
                "title": "beats-98-20-simple-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\n# Approach\\n\\n**1.** First, we create a **new promise, timeoutPromise,** with setTimeout(). If this promise doesn\\'t resolve within the given time limit t, it will reject with the message \"Time Limit Exceeded\".\\n**2.** Call the function **fn(...args)**, which returns a promise.\\n**3.** Use **Promise.race()** to wait for either the result of the asynchronous function or the timeoutPromise to settle. Whichever promise settles first will determine the outcome of the timeLimit function.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((resolve,reject) => \\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        );\\n        return Promise.race([fn(...args), timeoutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((resolve,reject) => \\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        );\\n        return Promise.race([fn(...args), timeoutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683659,
                "title": "using-promise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing Promise.race, whichever promise (execution or timeout) resolves or rejects first will determine the outcome of the returned promise\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnside the returned asynchronous function, Promise.race is used to race between two promises:\\n\\nThe first promise is the execution of fn(...args). This represents the actual execution of the provided function with the given arguments.\\nThe second promise is created using setTimeout and will reject with the message \"Time Limit Exceeded\" after t milliseconds.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the timeLimit function itself is O(1) since it doesn\\'t involve any loops or recursion.\\nThe time complexity of the returned asynchronous function is determined by the time it takes to execute the provided function fn and the timeout duration t. It depends on the implementation of fn and may vary.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the timeLimit function is O(1) since it doesn\\'t create any additional data structures that grow with the input size.\\nThe space complexity of the returned asynchronous function depends on the space complexity of fn and the arguments args passed to it.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async (...args) => {\\n    return Promise.race([\\n        fn(...args),\\n        new Promise((_, rejected) => setTimeout(rejected, t, \"Time Limit Exceeded\"))\\n    ])\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async (...args) => {\\n    return Promise.race([\\n        fn(...args),\\n        new Promise((_, rejected) => setTimeout(rejected, t, \"Time Limit Exceeded\"))\\n    ])\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638379,
                "title": "using-promise-race-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUnderstanding problem\\n- call **fn** with (...args)\\n- if **fn** takes more time than the given time(t)\\n    - reject with \"Time limit Exceeded\"  // code -1\\n- else\\n    - return promise response of fn(...args) // code -2\\n    - if **fn** rejects, reject the promise\\n    - if **fn** resolves, resolve the promise\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst approach\\n - how to measure the **fn** running time?\\n - make countdown timer from **t** to **0** ?\\n\\n## buggy code (to understand, can skip)\\n```\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    const startTime = performance.now();\\n\\n    const result = await fn(...args);\\n\\n    const endTime = performance.now();\\n    const timeTaken = endTime - startTime;\\n\\n    return new Promise((resolve, reject) => {\\n      if (timeTaken > t) {\\n        reject(\"Time Limit Exceeded\",t);\\n      }\\n\\n      resolve(result);\\n    });\\n  };\\n};\\n```\\nHere we can measure the time of fn but it will await whatever time it takes. If given t=2s but fn takes 10s to execute then we can return result only after 10s. So by this we can understand we need fastest response whichever code( code-1 or code-2) completes first. Therefore make use of Promise.race.\\n\\nSecond approach\\n - use Promise.race\\n - [Promise.race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race) takes array of promises and returns a single promise whichever settles first. \\n\\n# Complexity\\n- Time complexity: Time complexity of fn\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Space complexity of fn\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n## using async await\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async (...args) => {\\n    let timeoutId;\\n\\n    const timeoutPromise = new Promise((resolve, reject) => {\\n      timeoutId = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    try {\\n      const result = await Promise.race([fn(...args), timeoutPromise]);\\n      clearTimeout(timeoutId);\\n      return result;\\n    } catch (error) {\\n      clearTimeout(timeoutId);\\n      throw error;\\n    }\\n  };\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n## Explaination\\nInside this function, we create a timeoutId variable to hold the timer ID.\\n\\nWe create a timeoutPromise using a setTimeout function(code-1), which will reject the promise with the \"Time Limit Exceeded\" message after the specified time t has passed.\\n\\nUsing Promise.race, we wait for either the fn(...args) promise or the timeoutPromise to settle. If fn(...args) completes before the timeout, the result is assigned, and the timeoutId is cleared. Otherwise, if the timeout is reached first, the timeoutPromise rejects with the \"Time Limit Exceeded\" message.\\n\\nIn the catch block, we clear the timeoutId and rethrow the error to maintain consistency with the rejected promise behavior.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    const startTime = performance.now();\\n\\n    const result = await fn(...args);\\n\\n    const endTime = performance.now();\\n    const timeTaken = endTime - startTime;\\n\\n    return new Promise((resolve, reject) => {\\n      if (timeTaken > t) {\\n        reject(\"Time Limit Exceeded\",t);\\n      }\\n\\n      resolve(result);\\n    });\\n  };\\n};\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async (...args) => {\\n    let timeoutId;\\n\\n    const timeoutPromise = new Promise((resolve, reject) => {\\n      timeoutId = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    try {\\n      const result = await Promise.race([fn(...args), timeoutPromise]);\\n      clearTimeout(timeoutId);\\n      return result;\\n    } catch (error) {\\n      clearTimeout(timeoutId);\\n      throw error;\\n    }\\n  };\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529368,
                "title": "easy-to-understand-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n           return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            setTimeout(() => {reject(\"Time Limit Exceeded\")}, t);\\n        })]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n           return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            setTimeout(() => {reject(\"Time Limit Exceeded\")}, t);\\n        })]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407275,
                "title": "effective-js-solution-using-promise-race-with-explanation",
                "content": "\\nThe problem is asking us to write a function that takes an asynchronous function fn and a time limit t, and returns a new version of fn that will reject with the message \"Time Limit Exceeded\" if it takes longer than t milliseconds to complete.\\n\\n\\n# Approach\\nWe can use `Promise.race` to race the original promise returned by fn against a new promise that will reject after t milliseconds if fn hasn\\'t completed yet.\\n\\nIf fn completes before the timeout, the implementation will return the result of fn. However, if the timeout expires before fn completes, the implementation will reject with the message \"Time Limit Exceeded\".\\n\\nWe also keep track of the amount of time elapsed between the start of fn and the completion of the promise (using `Date.now()`), and throw an error if the elapsed time exceeds t. This ensures that our implementation accurately enforces the time limit even if fn takes slightly longer to complete than the specified time limit.\\n\\n# Complexity\\n\\n## Time complexity:\\n\\nThe time complexity of the timeLimited function depends on the time complexity of the fn function passed as an argument. In the worst case, if fn takes longer than the time limit t, the function will have a time complexity of **O(1)**, because it will reject the promise immediately after the timeout expires. If fn completes before the timeout, the time complexity will be the **same as fn**, because it is simply invoking fn with the provided arguments.\\n\\n## Space complexity:\\nThe space complexity of the timeLimited function is constant because the function creates only a few variables to keep track of the timeout and elapsed time, and none of these variables depend on the size of the input.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n     const start = Date.now();\\n     const result = await Promise.race([fn(...args), new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))]);\\n      const elapsed = Date.now() - start;\\n     if (elapsed >= t) {\\n        throw \"Time Limit Exceeded\";\\n    }\\n       return result;\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n     const start = Date.now();\\n     const result = await Promise.race([fn(...args), new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))]);\\n      const elapsed = Date.now() - start;\\n     if (elapsed >= t) {\\n        throw \"Time Limit Exceeded\";\\n    }\\n       return result;\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102368,
                "title": "easy-promise-solution-34-lines-javascript-beats-100",
                "content": "```\\n// Define timeLimit function\\nvar timeLimit = function(fn, t) {\\n    // Return async function\\n    return async function(...args) {\\n        // Call the provided function\\n        const fns = fn(...args);\\n        // Create a promise for timeout\\n        const p = new Promise((res, rej) => {\\n            // Set a timeout for t milliseconds\\n            setTimeout(() => {\\n                // Reject the promise if timeout\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        // Race between function and timeout\\n        return Promise.race([fns, p]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Define timeLimit function\\nvar timeLimit = function(fn, t) {\\n    // Return async function\\n    return async function(...args) {\\n        // Call the provided function\\n        const fns = fn(...args);\\n        // Create a promise for timeout\\n        const p = new Promise((res, rej) => {\\n            // Set a timeout for t milliseconds\\n            setTimeout(() => {\\n                // Reject the promise if timeout\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        // Race between function and timeout\\n        return Promise.race([fns, p]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092683,
                "title": "the-timelimit-function-return-new-async-function-that-can-be-use-as-a-wrapper-around-other-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    \\n\\treturn async function(...args) {\\n        let funcExec = fn(...args);\\n        let funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n        return Promise.race([funcExec, funcRej])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    \\n\\treturn async function(...args) {\\n        let funcExec = fn(...args);\\n        let funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n        return Promise.race([funcExec, funcRej])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089503,
                "title": "promise-time-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n      const _execution=fn(...args)\\n      const _timeLimit=new Promise((_,reject)=>{\\n          setTimeout(()=>{\\n              reject(\"Time Limit Exceeded\")\\n          },t)\\n      })\\n      return Promise.race([_execution, _timeLimit])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n      const _execution=fn(...args)\\n      const _timeLimit=new Promise((_,reject)=>{\\n          setTimeout(()=>{\\n              reject(\"Time Limit Exceeded\")\\n          },t)\\n      })\\n      return Promise.race([_execution, _timeLimit])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087877,
                "title": "promise-time-limit-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077698,
                "title": "the-most-simple-and-single-liner-solution-using-promise",
                "content": "# Intuition\\nConsider 2 methods/promise which ever executes first, return the first executed method.\\n# Approach\\nWe can make the use of Promise.race() to solve the problem. This is exactly what question tryies to make you learn.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([fn(...args), new Promise((res,rej)=>setTimeout(rej,t,\\'Time Limit Exceeded\\'))])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([fn(...args), new Promise((res,rej)=>setTimeout(rej,t,\\'Time Limit Exceeded\\'))])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061021,
                "title": "easiest-solution",
                "content": "# Approach\\nPromise.race is the best way to solve this. All you need are 2 promise objects, one is result of fn(...args) and second one is called from a timeout function that will wait for t mseconds.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let promise1 = fn(...args)\\n        let promise2 = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n        })\\n        return Promise.race([promise1,promise2])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let promise1 = fn(...args)\\n        let promise2 = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n        })\\n        return Promise.race([promise1,promise2])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041202,
                "title": "await-solution-detailed-explanation-of-javascript-event-loop-beginner-friendly",
                "content": "# Intuition\\nTo start off we know that if we want to have a time limit a `setTimeout` is needed. This `setTimeout` has to reject our promise within time `t`. Why did I know that we need a `Promise`? Well if the words resolve and reject are in the problem description it is then pretty obvious. \\n\\n# Approach\\nThe approach is quite standard: set a timeout, await the data, resolve it, and then reject it if time `t` has elapsed.\\n\\nAdditionally, there are a couple of important considerations. Simply leaving the `setTimeout` as is could potentially result in memory leaks, especially if an infinite loop were to run. Therefore, for each call to the `timeLimit` function, it is essential to ensure that the timeout is cleared.\\n\\nHowever, there is one aspect that might be confusing\\u2014how can `setTimeout` and `fn` seemingly run concurrently in JavaScript, given that it is a single-threaded language? Let me explain why they can.\\n\\nYou see, `fn` is an asynchronous function, and so \"is\" `setTimeout`. But why is `fn` able to execute when `setTimeout` is called first?\\n\\nIf we were to visualize the call stack, it might look like this: `fn` (called second) -> `setTimeout` (called first) -> next line to be executed. So how is it possible?\\n\\nWell that is because `setTimeout` works a little bit differently in the sense that when its called it will execute after `t` seconds and not in the asynchronous callstack (***Queue***) but rather in the normal one (***Stack***). So if `fn` is still calculating after `t` seconds the code in `setTimeout` will execute because it\\'s in the normal call stack and **set** the state or rejected. But what if `fn` finishes in time, what will happen to setTimeout? Well it would \"still\" execute but since we **set** the state of resolved before the time period of `t` to where that part of the call stack will not show up.\\n\\nIn summary, the order of execution may not match the order of function calls, and operations like `setTimeout` and `await` interact within the JavaScript event loop differently to determine the actual execution sequence. Clearing the `timeout` is essential to prevent potential memory leaks.\"\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ because `...args` can have the size of 0 &rarr; n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            try {\\n                const res = await fn(...args);\\n                resolve(res);\\n            } catch (err) {\\n                reject(err);\\n            } finally {\\n                clearTimeout(id);\\n            }\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            try {\\n                const res = await fn(...args);\\n                resolve(res);\\n            } catch (err) {\\n                reject(err);\\n            } finally {\\n                clearTimeout(id);\\n            }\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036955,
                "title": "a",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n  const Prmise =  new Promise((a,reject)=>{\\n setTimeout(()=>{\\nreject(\\'Time Limit Exceeded\\')\\n},t)\\n})\\nreturn Promise.race([Prmise, fn(...args)])\\n}}\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n  const Prmise =  new Promise((a,reject)=>{\\n setTimeout(()=>{\\nreject(\\'Time Limit Exceeded\\')\\n},t)\\n})\\nreturn Promise.race([Prmise, fn(...args)])\\n}}\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035522,
                "title": "multiple-clean-solution-with-explanation",
                "content": "\\n\\n# Explanation\\nThe function is supposed to return a new promise with either resolve or reject based on the provided time. So declare a variable `timeOut` that returns `reject(\"Time Limit Exceeded\")` after the provided time excedeed. If this is executed prior to whatever is returned from `fn(...args)`, promise is resolved with rejected no matter what the returned value of fn is at the later time.\\n\\nOn the other hand, if `fn(...args)` completes executing prior `setTimeout`, promise is considered fulfilled with whatever is returned from it and ignores the reject of `timeOut`.\\n\\n# Why `clearTimeout(timeOut)` on `fn(...args)`?\\nIf the fn(...args) is executed prior to setTimeout, we do not want this setTimeout to execute at latter point even if this doesn\\'t bring any value. We want the process to cancel it once our purpose is met. \\n\\n\\n# Approach 1\\nUsing `.then`\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeOut = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n\\n      fn(...args)\\n        .then((res) => resolve(res))\\n        .catch((err) => reject(err))\\n        .finally(() => clearTimeout(timeOut));\\n    });\\n  };\\n};\\n```\\n\\n\\n# Approach 2\\nUsing `async await`\\n\\nNote: One of the minor difference is we need to wrap the callback fn `(resolve, reject) => {}` with `async` unlike in `Approach 1`. We could technically have `async` wrapped in `Approach 1` as well but it works without as well.\\n\\n# code\\n```\\n\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeOut = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch (err) {\\n        reject(err);\\n      } finally {\\n        clearTimeout(timeOut);\\n      }\\n    });\\n  };\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeOut = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n\\n      fn(...args)\\n        .then((res) => resolve(res))\\n        .catch((err) => reject(err))\\n        .finally(() => clearTimeout(timeOut));\\n    });\\n  };\\n};\\n```\n```\\n\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeOut = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch (err) {\\n        reject(err);\\n      } finally {\\n        clearTimeout(timeOut);\\n      }\\n    });\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4017259,
                "title": "promise-time-limit-with-ukrainian-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\u0414\\u043B\\u044F \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043D\\u044F \\u0446\\u0456\\u0454\\u0457 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0456 \\u044F \\u0432\\u0438\\u043A\\u043E\\u0440\\u0438\\u0441\\u0442\\u043E\\u0432\\u0443\\u044E \\u043C\\u0435\\u0442\\u043E\\u0434 `race`, \\u044F\\u043A\\u0438\\u0439 \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454 \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442 \\u043F\\u0435\\u0440\\u0448\\u043E\\u0433\\u043E \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043E\\u0433\\u043E \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441\\u0443.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. \\u0421\\u043F\\u043E\\u0447\\u0430\\u0442\\u043A\\u0443 \\u0441\\u0442\\u0432\\u043E\\u0440\\u044E\\u044E \\u0437\\u043C\\u0456\\u043D\\u043D\\u0443 `originalPromise`, \\u044F\\u043A\\u0430 \\u043F\\u0440\\u0435\\u0434\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0454 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441, \\u044F\\u043A\\u0438\\u0439 \\u0431\\u0443\\u0434\\u0435 \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043E \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043F\\u0435\\u0432\\u043D\\u0438\\u0439 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0436\\u043E\\u043A \\u0447\\u0430\\u0441\\u0443.\\n2. \\u041F\\u043E\\u0442\\u0456\\u043C \\u0441\\u0442\\u0432\\u043E\\u0440\\u044E\\u044E \\u0437\\u043C\\u0456\\u043D\\u043D\\u0443 `timeLimiter`, \\u044F\\u043A\\u0430 \\u0432\\u0438\\u043A\\u043E\\u0440\\u0438\\u0441\\u0442\\u043E\\u0432\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u0434\\u043B\\u044F \\u043E\\u0431\\u043C\\u0435\\u0436\\u0435\\u043D\\u043D\\u044F \\u0447\\u0430\\u0441\\u0443 \\u0432\\u0438\\u043A\\u043E\\u043D\\u0430\\u043D\\u043D\\u044F \\u043F\\u0435\\u0440\\u0448\\u043E\\u0433\\u043E \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441\\u0443. \\u041D\\u0430\\u043F\\u0440\\u0438\\u043A\\u043B\\u0430\\u0434, \\u044F\\u043A\\u0449\\u043E \\u043F\\u0435\\u0440\\u0448\\u0438\\u0439 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441 \\u043D\\u0435 \\u0432\\u0438\\u0440\\u0456\\u0448\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u043F\\u0440\\u043E\\u0442\\u044F\\u0433\\u043E\\u043C 5 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434, \\u0432\\u0438\\u043A\\u043E\\u043D\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441 `timeLimiter`, \\u044F\\u043A\\u0438\\u0439 \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454 \\'Time Limit Exceeded\\'.\\n\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const originalPromise = fn(...args)\\n        const timeLimiter = new Promise((_, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n        return Promise.race([originalPromise, timeLimiter])\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const originalPromise = fn(...args)\\n        const timeLimiter = new Promise((_, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n        return Promise.race([originalPromise, timeLimiter])\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014698,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n       let funcExec = fn(...args);\\n        let funcRaj = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n       return Promise.race([funcExec, funcRaj])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n       let funcExec = fn(...args);\\n        let funcRaj = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n       return Promise.race([funcExec, funcRaj])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011255,
                "title": "solution",
                "content": "```\\r\\nconst timeLimit = (fn, t) => async (...args) => {\\r\\n  const promise1 = Promise.resolve(fn(...args));\\r\\n\\r\\n  const promise2 = new Promise((_, reject) => {\\r\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\r\\n  });\\r\\n\\r\\n  return Promise.race([promise1, promise2]);\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\r\\nconst timeLimit = (fn, t) => async (...args) => {\\r\\n  const promise1 = Promise.resolve(fn(...args));\\r\\n\\r\\n  const promise2 = new Promise((_, reject) => {\\r\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\r\\n  });\\r\\n\\r\\n  return Promise.race([promise1, promise2]);\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007367,
                "title": "the-10x-approach-promise-race",
                "content": "# Intuition\\nWhen we want to limit the execution time of a function, a common approach is to race the function against a timer. If the function completes before the timer, it\\'s successful. If the timer completes first, we know the function took too long.\\n\\n# Approach\\n1. We wrap the given function `fn` inside another function that will be returned. This allows us to intercept the arguments and control the execution.\\n2. We create a `timeoutPromise` that will reject after time `t` has passed.\\n3. We use `Promise.race` to race the function against the timeout, which returns the first *settled* promise, rather than the first *fulfilled* promise like in `Promise.any`. (See more @ [mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race#return_value)) If `fn` completes first, its result (or error) will be returned. If the timeout completes first, it will reject with \"Time Limit Exceeded\".\\n\\n# Complexity\\n- Time complexity:\\n  - The time complexity is dependent on the function `fn` that is passed in. The `timeLimit` function itself just adds a constant overhead for setting up the race condition.\\n\\n- Space complexity:\\n  - $$O(1)$$: The space complexity is constant since we are only creating a few promises and not using any data structures that grow with input size.\\n\\n# Code\\n```typescript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((_,reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([fn(...args), timeoutPromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# Intuition\\nWhen we want to limit the execution time of a function, a common approach is to race the function against a timer. If the function completes before the timer, it\\'s successful. If the timer completes first, we know the function took too long.\\n\\n# Approach\\n1. We wrap the given function `fn` inside another function that will be returned. This allows us to intercept the arguments and control the execution.\\n2. We create a `timeoutPromise` that will reject after time `t` has passed.\\n3. We use `Promise.race` to race the function against the timeout, which returns the first *settled* promise, rather than the first *fulfilled* promise like in `Promise.any`. (See more @ [mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race#return_value)) If `fn` completes first, its result (or error) will be returned. If the timeout completes first, it will reject with \"Time Limit Exceeded\".\\n\\n# Complexity\\n- Time complexity:\\n  - The time complexity is dependent on the function `fn` that is passed in. The `timeLimit` function itself just adds a constant overhead for setting up the race condition.\\n\\n- Space complexity:\\n  - $$O(1)$$: The space complexity is constant since we are only creating a few promises and not using any data structures that grow with input size.\\n\\n# Code\\n```typescript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((_,reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([fn(...args), timeoutPromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3993804,
                "title": "easy-solution",
                "content": "# Code\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        // Create a promise that calls fn with the given arguments\\n        let fnPromise = fn(...args);\\n        // Create a promise that rejects after t milliseconds\\n        let timeoutPromise = new Promise((_, reject) => setTimeout(reject, t, \"Time Limit Exceeded\"));\\n        // Return a promise that races fn and timeout\\n        return Promise.race([fnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        // Create a promise that calls fn with the given arguments\\n        let fnPromise = fn(...args);\\n        // Create a promise that rejects after t milliseconds\\n        let timeoutPromise = new Promise((_, reject) => setTimeout(reject, t, \"Time Limit Exceeded\"));\\n        // Return a promise that races fn and timeout\\n        return Promise.race([fnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984040,
                "title": "js",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = function (fn, t) {\\n    return async function (...args) {\\n        return new Promise((res, rej) => {\\n            const timer = setTimeout(() => rej(\\'Time Limit Exceeded\\'), t);\\n\\n            fn(...args)\\n                .then((result) => {\\n                    clearTimeout(timer);\\n                    res(result);\\n                })\\n                .catch((error) => rej(error));\\n        });\\n    };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = function (fn, t) {\\n    return async function (...args) {\\n        return new Promise((res, rej) => {\\n            const timer = setTimeout(() => rej(\\'Time Limit Exceeded\\'), t);\\n\\n            fn(...args)\\n                .then((result) => {\\n                    clearTimeout(timer);\\n                    res(result);\\n                })\\n                .catch((error) => rej(error));\\n        });\\n    };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982844,
                "title": "simple-solution-with-promise-race",
                "content": "# What is Promise.race\\n\\n`race()` is a static method of the Promise class that accepts an array of promises and returns the data of first completed promise irrespective of whether it\\'s accepted or rejected.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = (fn, t) => {\\n    return async function (...args) {\\n        // Original Promise Function\\n        const promise = fn(...args);\\n\\n        // Function to reject promise after timeout\\n        const timeOutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        });\\n\\n        // race method which returns first settled promise data.\\n        return Promise.race([promise, timeOutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = (fn, t) => {\\n    return async function (...args) {\\n        // Original Promise Function\\n        const promise = fn(...args);\\n\\n        // Function to reject promise after timeout\\n        const timeOutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        });\\n\\n        // race method which returns first settled promise data.\\n        return Promise.race([promise, timeOutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978684,
                "title": "2-very-simple-approaches",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeLimitPr = new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\\'Time Limit Exceeded\\'),t)\\n        })\\n        \\n        return Promise.race([timeLimitPr,fn(...args)]);\\n    }\\n};\\n```\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\\'Time Limit Exceeded\\'),t)\\n            fn(...args).then(resolve).catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeLimitPr = new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\\'Time Limit Exceeded\\'),t)\\n        })\\n        \\n        return Promise.race([timeLimitPr,fn(...args)]);\\n    }\\n};\\n```\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\\'Time Limit Exceeded\\'),t)\\n            fn(...args).then(resolve).catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978018,
                "title": "easy-solution-go-for-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {  \\n                const ans = fn(...args);\\n\\n               const p = new Promise((resolve, reject) => { setTimeout(()=> {\\n                reject(\"Time Limit Exceeded\");\\n                 }, t) });\\n\\n                return await Promise.race([p, ans]);\\n  // Both resolve, but promise2 is faster\\n        }\\n        \\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {  \\n                const ans = fn(...args);\\n\\n               const p = new Promise((resolve, reject) => { setTimeout(()=> {\\n                reject(\"Time Limit Exceeded\");\\n                 }, t) });\\n\\n                return await Promise.race([p, ans]);\\n  // Both resolve, but promise2 is faster\\n        }\\n        \\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3950782,
                "title": "settimeout-with-async-await-promise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNote that you need the try catch block to catch when the `reject()` by setTimeout\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n       return new Promise(async(resolve,reject)=>{\\n            const timeout = setTimeout(()=>{\\n                reject(\\'Time Limit Exceeded\\');\\n            },t);\\n            try{\\n            const result = await fn(...args);\\n            resolve(result);\\n            }catch(e){\\n                reject(e);\\n            }finally{\\n            clearTimeout(timeout);\\n            }\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n       return new Promise(async(resolve,reject)=>{\\n            const timeout = setTimeout(()=>{\\n                reject(\\'Time Limit Exceeded\\');\\n            },t);\\n            try{\\n            const result = await fn(...args);\\n            resolve(result);\\n            }catch(e){\\n                reject(e);\\n            }finally{\\n            clearTimeout(timeout);\\n            }\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944940,
                "title": "js-explanation-with-code",
                "content": "# Intuition\\nUsing Promise, settimeout.\\n\\n# Approach\\nSimplifying, we have to return a rejected promise if the fn function which returns a resolved result does not complete in the given t ms.\\n\\n- we make to promises one with the given functin fn which is a promise function,\\n- other promise is a rejected promise, which gets executed in t ms\\n- Now, we use Promsie.race to see which promise finishes earlier, Promise.race takes input as an array of promises.\\n\\n# Complexity\\n- Time complexity:\\nO(fn)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = (fn,t) => {\\n    return async (...args) => {\\n       const originalPromise = fn(...args);\\n       const rejectPromise = new Promise((resolve, reject) =>{setTimeout(()=>{reject(\"Time Limit Exceeded\")},t)});\\n\\n       return Promise.race([originalPromise, rejectPromise]);\\n    }\\n}\\n\\n\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = (fn,t) => {\\n    return async (...args) => {\\n       const originalPromise = fn(...args);\\n       const rejectPromise = new Promise((resolve, reject) =>{setTimeout(()=>{reject(\"Time Limit Exceeded\")},t)});\\n\\n       return Promise.race([originalPromise, rejectPromise]);\\n    }\\n}\\n\\n\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932697,
                "title": "typescript-race-solution",
                "content": "# Approach\\nWe use *Promise.race* to solve a problem\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n            return Promise.race( [\\n                fn( ...args ),\\n                new Promise( ( _, reject ) => setTimeout( () => reject( \\'Time Limit Exceeded\\' ), t ) )\\n            ] )\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n            return Promise.race( [\\n                fn( ...args ),\\n                new Promise( ( _, reject ) => setTimeout( () => reject( \\'Time Limit Exceeded\\' ), t ) )\\n            ] )\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923944,
                "title": "extremely-simple-typescript-solution",
                "content": "# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => (...args) =>\\n  new Promise((resolve, reject) => {\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    fn(...args)\\n      .then(resolve)\\n      .catch(reject);\\n  });\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => (...args) =>\\n  new Promise((resolve, reject) => {\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    fn(...args)\\n      .then(resolve)\\n      .catch(reject);\\n  });\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3858244,
                "title": "typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\t\\treturn async function(...args:any[]) {\\n            return new Promise(async (resolve,reject)=>{\\n            const timeoutId = setTimeout(() => {\\n             clearTimeout(timeoutId);\\n             reject(\"Time Limit Exceeded\");\\n             }, t);\\n               await fn(...args).then((sol)=>{\\n                 //  clearTimeout(timeoutId);\\n                    resolve(sol);\\n                }).catch((err)=>{\\n                   //clearTimeout(timeoutId);\\n                    reject(err);\\n                });\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\t\\treturn async function(...args:any[]) {\\n            return new Promise(async (resolve,reject)=>{\\n            const timeoutId = setTimeout(() => {\\n             clearTimeout(timeoutId);\\n             reject(\"Time Limit Exceeded\");\\n             }, t);\\n               await fn(...args).then((sol)=>{\\n                 //  clearTimeout(timeoutId);\\n                    resolve(sol);\\n                }).catch((err)=>{\\n                   //clearTimeout(timeoutId);\\n                    reject(err);\\n                });\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853008,
                "title": "2637-promise-time-limit",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const funct = fn(...args);\\n\\n        const timeout = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([funct, timeout]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const funct = fn(...args);\\n\\n        const timeout = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([funct, timeout]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830247,
                "title": "simple-soln-for-timeouts-using-promise-race",
                "content": "# Note \\nPromise.race() is a an method that represents the eventual completion of an very first asynchronous operation either it is fulfilled or rejected. (Already resolved promises are returned first and \\'non-promise\\' values).\\n\\n# Code\\n```\\nconst timeLimit = (fn, time) => {\\n  return (...args)=> {\\n    return Promise.race([\\n      fn(...args),\\n      new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n        reject(\"Time Limit Exceeded\")\\n        }, time);\\n      }),\\n    ]);\\n  };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst timeLimit = (fn, time) => {\\n  return (...args)=> {\\n    return Promise.race([\\n      fn(...args),\\n      new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n        reject(\"Time Limit Exceeded\")\\n        }, time);\\n      }),\\n    ]);\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3819491,
                "title": "this-type-of-qns-wants-you-to-control-the-state-of-the-promise",
                "content": "# Intuition\\nFor such qns never uses async await as they want you to suspend the promise for a time and run functions in parallel. \\nAsync await makes logic sequential and doesnt give you the explicit control over resolve and rejection of the promise, it always return a fullfilled promise once the function call terminates. \\nUsing native promise you can run function in parallel to timeout and then also be able to control which rejects and resolves. \\nIf a fn is faster than timeout  will be first fullfilled as either a resolve/reject otherwise timeout will be fullfilled as a rejection.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t)    \\n            fn(...args).then(res).catch(rej)                                \\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t)    \\n            fn(...args).then(res).catch(rej)                                \\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3808985,
                "title": "typescript-o-max-t-n-1",
                "content": "# Code\\n```\\ntype Fn = (...params: any[]) => Promise<unknown>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn function(...args) {\\n        return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            return setTimeout(reject, t, \"Time Limit Exceeded\");\\n        })]);\\n    }\\n};\\n```\\n\\n# Complexity\\n`fn` is denoted as `T(n)`, where `n` is the size of the input.\\n\\n- Time complexity: $$O(max(T(n), 1))$$\\n- Space complexity: $$O(max(T(n), 1))$$",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<unknown>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn function(...args) {\\n        return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            return setTimeout(reject, t, \"Time Limit Exceeded\");\\n        })]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805803,
                "title": "typescript-solution-4-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args): Promise<any> {\\n       return new Promise<any>((resolve, reject) => {\\n            setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n            fn(...args).then(resolve, reject);\\n        }); \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args): Promise<any> {\\n       return new Promise<any>((resolve, reject) => {\\n            setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n            fn(...args).then(resolve, reject);\\n        }); \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786119,
                "title": "super-easy-and-imp-concept-promise-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the problem requires two distinct conditions to execute and compete with each other on the basis of time so it seems like a good place to use promise.race() .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDefine the two separate promises - the function acts inherently as a promise when it executes later on in the code.\\nIn the end we use promise.race to return whichever promise that executes first. \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise1 = fn(...args)\\n        const promise2 = new Promise((resolve,reject)=>{\\n            setTimeout(reject,t,\"Time Limit Exceeded\")\\n        })\\n        \\n        return  Promise.race([promise1,promise2])\\n\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise1 = fn(...args)\\n        const promise2 = new Promise((resolve,reject)=>{\\n            setTimeout(reject,t,\"Time Limit Exceeded\")\\n        })\\n        \\n        return  Promise.race([promise1,promise2])\\n\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3757854,
                "title": "ts-very-simple-implementation-promise",
                "content": "# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n            fn(...args).then((result)=>resolve(result)).catch((error)=> reject(error))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n            fn(...args).then((result)=>resolve(result)).catch((error)=> reject(error))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3703511,
                "title": "promise-race-concept",
                "content": "# Intuition\\nBoth of them are promise. Whichever gives outcome first will be run, may it be resolve or reject. \\nWe pass an iterable in the Promise race method.\\nIterable consists of all the promises to check for resolve/reject whichever completes first.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const first = fn(...args);\\n        const second = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            }, t)\\n        });\\n        return Promise.race([first, second]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const first = fn(...args);\\n        const second = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            }, t)\\n        });\\n        return Promise.race([first, second]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694266,
                "title": "time-limit-problem-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const FuncPromise = fn(...args);\\n\\n        const prom1 = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([FuncPromise, prom1]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const FuncPromise = fn(...args);\\n\\n        const prom1 = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([FuncPromise, prom1]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678465,
                "title": "typescript-solution-using-promise-race",
                "content": "# Code\\n```\\ntype AsyncFunction = (...params: any[]) => Promise<any>;\\n\\n// This problem is essentially a race between two conditions:\\n// 1. Timeout function resolves first -> throw error\\n// 2. Original function resolves first -> resolve value\\nfunction timeLimit(fn: AsyncFunction, timeout: number): AsyncFunction {\\n    return async function (...args) {\\n        return Promise.race([\\n            fn(...args),\\n            rejectAfterTime(timeout)\\n        ])\\n    }\\n};\\n\\nfunction rejectAfterTime(timeout: number): Promise<void> {\\n    return new Promise<void>((resolve, reject) => {\\n        setTimeout(() => {\\n            reject(\\'Time Limit Exceeded\\');\\n       }, timeout); \\n    });\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype AsyncFunction = (...params: any[]) => Promise<any>;\\n\\n// This problem is essentially a race between two conditions:\\n// 1. Timeout function resolves first -> throw error\\n// 2. Original function resolves first -> resolve value\\nfunction timeLimit(fn: AsyncFunction, timeout: number): AsyncFunction {\\n    return async function (...args) {\\n        return Promise.race([\\n            fn(...args),\\n            rejectAfterTime(timeout)\\n        ])\\n    }\\n};\\n\\nfunction rejectAfterTime(timeout: number): Promise<void> {\\n    return new Promise<void>((resolve, reject) => {\\n        setTimeout(() => {\\n            reject(\\'Time Limit Exceeded\\');\\n       }, timeout); \\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669060,
                "title": "delightful",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nfunction timeLimit(fn, t) {\\n  return async (...args) => {\\n    return Promise.race([\\n        fn(...args),\\n        new Promise((_, rejected) => setTimeout(rejected, t, \"Time Limit Exceeded\"))\\n    ])\\n  };\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nfunction timeLimit(fn, t) {\\n  return async (...args) => {\\n    return Promise.race([\\n        fn(...args),\\n        new Promise((_, rejected) => setTimeout(rejected, t, \"Time Limit Exceeded\"))\\n    ])\\n  };\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3652375,
                "title": "solution-using-promise-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere there are 2 async process. whichever completes first we have to get its resp and clear the others. Promise.race([]) helps us with the promise handling for this use case.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple logic\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let fnExec = fn(...args);\\n        let timeoutProm = new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t);\\n        });\\n        return Promise.race([fnExec, timeoutProm]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let fnExec = fn(...args);\\n        let timeoutProm = new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t);\\n        });\\n        return Promise.race([fnExec, timeoutProm]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3597609,
                "title": "js-solution-use-promise-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([\\n            new Promise((_, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t)), \\n            fn(...args)\\n        ]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([\\n            new Promise((_, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t)), \\n            fn(...args)\\n        ]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3597394,
                "title": "promise-time-limit",
                "content": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        return new Promise((res, rej) => { \\n            setTimeout(() => {\\n               rej(\\'Time Limit Exceeded\\'); \\n            }, t)\\n            \\n            fn(...args)\\n            .then((result) => {\\n                res(result);\\n            })\\n            .catch((error) => {\\n                rej(error)\\n            })\\n        });        \\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        return new Promise((res, rej) => { \\n            setTimeout(() => {\\n               rej(\\'Time Limit Exceeded\\'); \\n            }, t)\\n            \\n            fn(...args)\\n            .then((result) => {\\n                res(result);\\n            })\\n            .catch((error) => {\\n                rej(error)\\n            })\\n        });        \\n    }\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593505,
                "title": "day-12-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => { \\n                reject(\"Time Limit Exceeded\"); \\n            }, t);\\n\\n            fn(...args)\\n                .then(resolve)\\n                .catch(reject)\\n                .finally(() => {\\n                    clearTimeout(timeout);\\n                });\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => { \\n                reject(\"Time Limit Exceeded\"); \\n            }, t);\\n\\n            fn(...args)\\n                .then(resolve)\\n                .catch(reject)\\n                .finally(() => {\\n                    clearTimeout(timeout);\\n                });\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3578751,
                "title": "promise-race-method-javascript",
                "content": "Promise.race is a method that takes an array of promises as input and returns a new promise. It resolves or rejects and stops as soon as the first promise in the input array resolves or rejects.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    const endsInTimeT = new Promise((resolve, reject) => {    \\n        setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t+1);\\n    });\\n    \\n\\treturn async function(...args) {\\n        const racePromise = Promise.race([endsInTimeT, fn(...args)]);\\n        return racePromise\\n                .then((result) => { \\n                  return result;\\n                })\\n                .catch((error) => {   \\n                   throw error;\\n                });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    const endsInTimeT = new Promise((resolve, reject) => {    \\n        setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t+1);\\n    });\\n    \\n\\treturn async function(...args) {\\n        const racePromise = Promise.race([endsInTimeT, fn(...args)]);\\n        return racePromise\\n                .then((result) => { \\n                  return result;\\n                })\\n                .catch((error) => {   \\n                   throw error;\\n                });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555466,
                "title": "simple-and-easy-stepwise-explanation-to-understand-core-concept-as-well-as-code-written",
                "content": "Initially I found it difficult to understand the concept hence here is the simplified way of understanding.\\n1. setTimeout takes first parameter as function to execute after the time is completed and second parameter as time to wait before executing the function\\n2. fn(...args) starts executing asynchronously and the function in setTimeout is made to wait until time t gets completed\\n3. Before time out if function gets executed it is resolved else gives rejection\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t)\\n            fn(...args).then(res).catch(rej)\\n        }\\n        )\\n    }\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t)\\n            fn(...args).then(res).catch(rej)\\n        }\\n        )\\n    }\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548830,
                "title": "js-easy-solution-async-await-beats-100",
                "content": "```\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3543465,
                "title": "javascript-promises-with-comments",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        //return a promise that..\\n        return new Promise((res, rej) => {\\n            //...rejects as soon as soon as threshold `t` passes.\\n            const timeout = setTimeout(() => rej(`Time Limit Exceeded`),  t);\\n\\n            //...otherwise, resolves or rejects to the value that\\n            //fn resolves or reject to.\\n            fn(...args)\\n            .then(data => {\\n                //fn has resolved, clear the timeout.\\n                clearTimeout(timeout);\\n                res(data);\\n            })\\n            .catch(err => rej(err)); \\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        //return a promise that..\\n        return new Promise((res, rej) => {\\n            //...rejects as soon as soon as threshold `t` passes.\\n            const timeout = setTimeout(() => rej(`Time Limit Exceeded`),  t);\\n\\n            //...otherwise, resolves or rejects to the value that\\n            //fn resolves or reject to.\\n            fn(...args)\\n            .then(data => {\\n                //fn has resolved, clear the timeout.\\n                clearTimeout(timeout);\\n                res(data);\\n            })\\n            .catch(err => rej(err)); \\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3537709,
                "title": "js-day-12-day-30-two-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    For this Problem i have findout two solutions\\n        1. Using simple promise Callback\\n        2. Using Promise.race (Js inbuilt static method)\\n    This example is about to demonstrate my solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Approach first (Using promise callback)\\n- Return a new Promise with 2 inputs; resolve to continue with our function if everything is fine and reject to stop execution if something is wrong.\\n- Inside the returned promise, declare a timeout  which is a timeout function that will be executed based on input t  \\n    1. If time surpasses t then we return a reject expression with the Time Limit Exceeded string and will be catched in the catch callback function.\\n    2. After timeout we return the eventual function with its parameters (fn(...args)), then we proceed to solution (.then(resolve)), catch any  errors (.catch(reject)) ).\\n\\n---\\n\\n2. Approach Second (Using Promise.race inbuilt method)\\n\\n - The Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles(even Promise resolved or rejected)\\n    1. Return both inputs (function and the timelimit) inside Promise.race.\\n    2. So promise.race returns the first settled promise. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(t)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\n1. 1st Approach(Using Promise Callback)\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(()=>  reject(\\'Time Limit Exceeded\\'),t);\\n\\n             fn(...args)\\n             .then( resolve)\\n             .catch( reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n\\n---\\n2. 2nd Approach (Using Promise. race)\\n\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n       return Promise.race([fn(...args), new Promise((res,rej) => setTimeout(()=>rej(\"Time Limit Exceeded\"),t))])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n1. 1st Approach(Using Promise Callback)\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(()=>  reject(\\'Time Limit Exceeded\\'),t);\\n\\n             fn(...args)\\n             .then( resolve)\\n             .catch( reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n\\n---\\n2. 2nd Approach (Using Promise. race)\\n\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n       return Promise.race([fn(...args), new Promise((res,rej) => setTimeout(()=>rej(\"Time Limit Exceeded\"),t))])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3535424,
                "title": "promise-time-limit-problem",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => {\\n                clearTimeout(timeout);\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n\\n            fn(...args).then((result) => {\\n                clearTimeout(timeout);\\n                resolve(result);\\n            }).catch((error) => {\\n                clearTimeout(timeout);\\n                reject(error);\\n            });\\n        });\\n    }\\n};\\n\\n/**\\n * let limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => {\\n                clearTimeout(timeout);\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n\\n            fn(...args).then((result) => {\\n                clearTimeout(timeout);\\n                resolve(result);\\n            }).catch((error) => {\\n                clearTimeout(timeout);\\n                reject(error);\\n            });\\n        });\\n    }\\n};\\n\\n/**\\n * let limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3534588,
                "title": "sol-n-javascript-typescript-easy",
                "content": "# Revised Approach\\n\\nTo create a time-limited version of an asynchronous function, we can make use of the Promise.race() method. We\\'ll create a new Promise that rejects with the string \"Time Limit Exceeded\" after the specified time limit. We\\'ll also invoke the original function and return the result of the Promise.race() method, which will either be the resolved value of the original function or the rejected value indicating the time limit was exceeded.\\n\\n# Complexity Analysis\\n\\nThe time complexity is dependent on the execution time of the original function. If the original function resolves or rejects within the time limit, the time complexity will be determined by the original function. Otherwise, it will be determined by the time limit.\\n\\nThe space complexity is constant as we\\'re not using any additional data structures that scale with the input size.\\n\\n# Code\\n\\n```javascript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function (...args: any[]): Promise<any> {\\n    const fns = fn(...args);\\n    const timeLimitPromise = new Promise((_, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    return Promise.race([fns, timeLimitPromise]);\\n  };\\n}\\n```\\n\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```javascript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function (...args: any[]): Promise<any> {\\n    const fns = fn(...args);\\n    const timeLimitPromise = new Promise((_, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    return Promise.race([fns, timeLimitPromise]);\\n  };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533947,
                "title": "javascript-code-only",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533778,
                "title": "beats-99-js-ts-promises-promise-time-limit-easy-solution-with-explanation",
                "content": "![image.png](https://assets.leetcode.com/users/images/12bd08fc-832a-41a0-9840-1bd0f7c8af74_1684310493.7335916.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI was thinking about using Promises, like everyone else. This example is about to demonstrate my solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Return a new `Promise` with 2 inputs; `resolve` to continue with our function if everything is fine and `reject` to stop execution if something is wrong.\\n    - Inside the returned promise, declare a `timeout` variable which is a timeout that will be executed based on time delay (if we have surpassed `t`) as we specify below.\\n    - If time surpasses `t` then we return a `reject` expression with the `Time Limit Exceeded` string.\\n    - After `timeout` we return the eventual function with its parameters (`fn(...a)`), then we proceed to solution (`.then(resolve)`), catch any potential errors (`.catch(reject)`) and finally clear `timeout` (`finally(() => clearTimeout(timeout))`).\\n\\n# Complexity\\n- Time complexity: `O(1)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n`JavaScript`\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\'); }, t);\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(timeout));\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n`TypeScript`\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t)\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(timeout));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n# Feedback\\nI would appreciate your feedback and would like to receive your comments and perspectives regarding my approach. I would also enjoy suggestions about how to hone my DSA skills because I am very new to this sector and it\\'s challenging at first. Thanks a lot!",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\'); }, t);\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(timeout));\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t)\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(timeout));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533059,
                "title": "using-promise-race-with-formatted-promise-s-responses",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const handlePromise = async (fn, fnName) => {\\n            try {\\n                const value = await fn(...args);\\n                return { fnName, state: \\'resolved\\', value };\\n            } catch (err) {\\n                return { fnName, state: \\'rejected\\', err };\\n            }\\n        }\\n\\n        const timedFn = async() => {\\n            await new Promise((res, rej) => {\\n                try {\\n                    setTimeout(res, t);\\n                }catch (err) {\\n                    rej(\\'Something went wrong.\\');\\n                }\\n            });\\n        }\\n\\n        const result = await Promise.race([handlePromise(fn, \\'fn\\'), handlePromise(timedFn, \\'timedFn\\')]);\\n\\n        if(result.fnName === \\'timedFn\\' && result.state === \\'resolved\\') {\\n            return Promise.reject(\\'Time Limit Exceeded\\');\\n        }\\n        \\n        if(result.fnName === \\'fn\\' && result.state === \\'resolved\\') {\\n            return Promise.resolve(result.value);\\n        }\\n\\n        return Promise.reject(result.err);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const handlePromise = async (fn, fnName) => {\\n            try {\\n                const value = await fn(...args);\\n                return { fnName, state: \\'resolved\\', value };\\n            } catch (err) {\\n                return { fnName, state: \\'rejected\\', err };\\n            }\\n        }\\n\\n        const timedFn = async() => {\\n            await new Promise((res, rej) => {\\n                try {\\n                    setTimeout(res, t);\\n                }catch (err) {\\n                    rej(\\'Something went wrong.\\');\\n                }\\n            });\\n        }\\n\\n        const result = await Promise.race([handlePromise(fn, \\'fn\\'), handlePromise(timedFn, \\'timedFn\\')]);\\n\\n        if(result.fnName === \\'timedFn\\' && result.state === \\'resolved\\') {\\n            return Promise.reject(\\'Time Limit Exceeded\\');\\n        }\\n        \\n        if(result.fnName === \\'fn\\' && result.state === \\'resolved\\') {\\n            return Promise.resolve(result.value);\\n        }\\n\\n        return Promise.reject(result.err);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3532549,
                "title": "creating-a-time-limited-version-of-an-asynchronous-function",
                "content": "# Intuition\\nThe goal is to create a time-limited version of an asynchronous function, where if the function takes longer than the specified time limit to fulfill, it rejects with a \"Time Limit Exceeded\" message.\\n\\n# Approach\\n1. The timeLimited function takes two arguments: fn, the original asynchronous function, and t, the time limit in milliseconds.\\n2. It returns a new function that acts as the time-limited version of fn.\\n3. Inside the new function, the original function fn is called with the provided arguments using the spread operator (...args), and its promise is stored in the promise variable.\\n4. A new promise timeoutPromise is created using the setTimeout function. If the timeout expires before the original function completes, the promise is rejected with the message \"Time Limit Exceeded\".\\n5. The Promise.race method is used to wait for either the original function\\'s promise or the timeout promise to settle. The settled promise (either resolved or rejected) will be returned.\\n6. If the original function completes before the timeout, its promise will resolve first, and the overall promise will resolve with the result.\\n7. If the timeout expires before the original function completes, the timeout promise will reject first, and the overall promise will reject with the \"Time Limit Exceeded\" message.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise = fn(...args);\\n        const timeoutPromise = new Promise((resolve, reject) => {\\n          setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n          }, t);\\n        });\\n        return Promise.race([promise, timeoutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise = fn(...args);\\n        const timeoutPromise = new Promise((resolve, reject) => {\\n          setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n          }, t);\\n        });\\n        return Promise.race([promise, timeoutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3532293,
                "title": "javascript-solution-with-return-await-new-promise",
                "content": "# Intuition\\nfllow the hints ;P\\n# Approach\\ncreate a new promise that you have to return and await. inside it start a timer that rejects when it is reached. Call the function and resolve/reject in the then/catch clause\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n\\treturn async function(...args) {\\n        return await new Promise((resolve, reject) => {\\n            setTimeout(()=> {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t)   \\n            fn(...args)\\n                .then((val) => resolve(val))\\n                .catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n\\treturn async function(...args) {\\n        return await new Promise((resolve, reject) => {\\n            setTimeout(()=> {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t)   \\n            fn(...args)\\n                .then((val) => resolve(val))\\n                .catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3532006,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        return new Promise((resolve, reject)=>{\\n           \\n           setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n           \\n           fn(...args)\\n            .then((res) => resolve(res))\\n            .catch((err) => reject(err))\\n           \\n\\n        })\\n        \\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        return new Promise((resolve, reject)=>{\\n           \\n           setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n           \\n           fn(...args)\\n            .then((res) => resolve(res))\\n            .catch((err) => reject(err))\\n           \\n\\n        })\\n        \\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531960,
                "title": "simple-explanation-of-solution-javascript-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn simpler terms, the problem is asking for a function that takes another function, and a time limit as inputs. The function should return a new function that, when called, will execute the provided function with the given arguments. However, if the execution takes longer than the specified time limit, the new function should reject the promise instead of resolving it.\\n\\nTo achieve this, we need to utilize a concept called `Promise.race()`. This concept allows us to create a race between multiple promises, and the first promise to either resolve or reject will determine the outcome of the race. In our case, we want to race between the execution of the function and a timeout promise.\\n\\nSo, the goal is to create a time-limited version of a function that either returns the resolved value within the specified time or rejects the promise with a timeout message if it exceeds the time limit.\\n\\n---\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this code, the `timeLimit` function takes an asynchronous function `fn` and a time limit `t` in milliseconds as arguments. It returns a new function that uses Promise.race to race between the `fn() promise` and a `timeout promise` created using setTimeout.\\n\\nIf `fn()` fulfills before the timeout occurs, the timeLimited function resolves with the same value. However, if `fn()` takes longer than t milliseconds to `fulfill`, the timeout promise will `reject` with the message `Time Limit Exceeded`.\\n\\n---\\n\\n# Code\\n```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n\\n        const functionPromise = fn(...args)\\n        const timePromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([functionPromise, timePromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n```typescript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\n\\treturn async function(...args) {\\n        const functionPromise = fn(...args)\\n        const timePromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([functionPromise, timePromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n\\n        const functionPromise = fn(...args)\\n        const timePromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([functionPromise, timePromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```typescript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\n\\treturn async function(...args) {\\n        const functionPromise = fn(...args)\\n        const timePromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([functionPromise, timePromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531840,
                "title": "promise-pool-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531817,
                "title": "promise-time-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const promise = fn(...args)\\n    const timeout = new Promise((resolve,reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n    });\\n    return Promise.race([promise,timeout])\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const promise = fn(...args)\\n    const timeout = new Promise((resolve,reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n    });\\n    return Promise.race([promise,timeout])\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531534,
                "title": "self-explanatory-two-solution-beginner-friendly",
                "content": "# Solution One - (Using Callback)\\n\\n# Code\\n\\n```\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise((resolve, reject) => {\\n      const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n      fn(...args)\\n        .then((res) => resolve(res))\\n        .catch((err) => reject(err))\\n        .finally(() => clearTimeout(id));\\n    });\\n  };\\n};\\n```\\n\\n# Solution Two - (Using async/await)\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async(resolve,reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n            try{\\n                const res = await fn(...args);\\n                resolve(res);\\n            }catch(err){\\n                reject(err);\\n            }\\n        })\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise((resolve, reject) => {\\n      const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n      fn(...args)\\n        .then((res) => resolve(res))\\n        .catch((err) => reject(err))\\n        .finally(() => clearTimeout(id));\\n    });\\n  };\\n};\\n```\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async(resolve,reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n            try{\\n                const res = await fn(...args);\\n                resolve(res);\\n            }catch(err){\\n                reject(err);\\n            }\\n        })\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531526,
                "title": "2637-promise-time-limit-javascript-day-12",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise= fn.apply(this,args);\\n        const timeout = new Promise((_,reject) =>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\");\\n            },t);\\n        });\\n        return Promise.race([promise,timeout]);\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise= fn.apply(this,args);\\n        const timeout = new Promise((_,reject) =>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\");\\n            },t);\\n        });\\n        return Promise.race([promise,timeout]);\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531456,
                "title": "simple-solution-easy-to-understand-o-1-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: **O(1)**\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n            const timeoutId = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args)\\n                .then((resolve))\\n                .catch(reject)\\n                .finally(() => clearTimeout(t));\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n            const timeoutId = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args)\\n                .then((resolve))\\n                .catch(reject)\\n                .finally(() => clearTimeout(t));\\n        });\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531404,
                "title": "you-just-need-to-know-the-promise-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou just need to know the Promise.race():\\n\\nThe Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.\\n\\n```\\nconst promise1 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 500, \\'one\\');\\n});\\n\\nconst promise2 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 100, \\'two\\');\\n});\\n\\nPromise.race([promise1, promise2]).then((value) => {\\n  console.log(value);\\n  // Both resolve, but promise2 is faster\\n});\\n// Expected output: \"two\"\\n\\n```\\n\\n# Approach\\nwe have fn which is the promise function and we need another promise function To throw a race between two Promises.\\n\\n# Complexity\\n- Time complexity: O(t)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n    const timeLimit =   new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n    })\\n\\n\\treturn async function(...args) {\\n        return await Promise.race([fn(...args),timeLimit]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst promise1 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 500, \\'one\\');\\n});\\n\\nconst promise2 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 100, \\'two\\');\\n});\\n\\nPromise.race([promise1, promise2]).then((value) => {\\n  console.log(value);\\n  // Both resolve, but promise2 is faster\\n});\\n// Expected output: \"two\"\\n\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n    const timeLimit =   new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n    })\\n\\n\\treturn async function(...args) {\\n        return await Promise.race([fn(...args),timeLimit]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531338,
                "title": "advanced-approach-with-concept-building-and-easy-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this problem we should know a in-built function Promise.race().Here is some information about Promise.race().\\n\\nThe Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.\\n\\nSo here we are just gonna create our new custom promise which will then be run against the given promise. So the winner will be executed.\\n\\n# Please upvote.\\u2705\\u261D\\uFE0F\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531293,
                "title": "java-script-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531291,
                "title": "easy-js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args).then(resolve).catch(reject);\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args).then(resolve).catch(reject);\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531245,
                "title": "beginner-s-js-solution",
                "content": "> DISCLAIMER: I am not a Pro, Just sharing my solution here to start a healthy discussion, if you feel it could have been better, please feel free to share your solution and thoughts \\uD83D\\uDE4F below\\n\\n# Intuition\\nPromise static method might be helpful \\uD83E\\uDD14\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F\\n\\n# Approach\\nIf we need to race between two promises which one reaches end state first and end state doesn\\'t matter than we can use Promise static method `Promise.race()`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/164dd62e-ac15-4f2c-8e02-6f19553df88f_1684249915.0756152.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n\\t\\tconst prom = new Promise((res,rej)=> setTimeout(()=>rej(\"Time Limit Exceeded\"),t));\\n        return Promise.race([prom,fn(...args)])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n\\t\\tconst prom = new Promise((res,rej)=> setTimeout(()=>rej(\"Time Limit Exceeded\"),t));\\n        return Promise.race([prom,fn(...args)])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531099,
                "title": "promise-time-limit-easy-solution-with-explanation",
                "content": "# Intuition\\nThe intuition behind this problem is to limit the execution time of a given function to a specific duration. If the function takes longer than the specified time limit, it should be terminated and return a predefined error message.\\n\\n# Approach\\nThe approach to solving this problem is to wrap the given function in another function that incorporates a timeout mechanism. The wrapper function will execute the original function and also create a timeout promise that rejects with an error message after the specified time limit. By using Promise.race, we can wait for either the original function to complete or the timeout to occur. Whichever promise resolves or rejects first will be the result of the overall wrapper function.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\nThe space complexity of the wrapper function is also O(1) since it doesn\\'t use any additional data structures that scale with the input size.\\n\\n- Space complexity: $$O(1)$$\\nThe space complexity of the wrapper function is also O(1) since it doesn\\'t use any additional data structures that scale with the input size.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    const promise = fn(...args);\\n    const timeout = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    });\\n    return Promise.race([promise, timeout]); // Return a promise that resolves or rejects based on which promise resolves or rejects first\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    const promise = fn(...args);\\n    const timeout = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    });\\n    return Promise.race([promise, timeout]); // Return a promise that resolves or rejects based on which promise resolves or rejects first\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531083,
                "title": "easy-solution-o-1",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const rePromise = fn(...args);\\n        const tlPromise = new Promise((_, rej) => {\\n            setTimeout(() => {\\n                rej(\"Time Limit Exceeded\")\\n            }, t);\\n        });\\n        return Promise.race([rePromise, tlPromise]);\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const rePromise = fn(...args);\\n        const tlPromise = new Promise((_, rej) => {\\n            setTimeout(() => {\\n                rej(\"Time Limit Exceeded\")\\n            }, t);\\n        });\\n        return Promise.race([rePromise, tlPromise]);\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530980,
                "title": "2637-promise-time-limit-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can create a time-limited version of an asynchronous function by using the Promise.race() method to race between the original function and a timeout promise. Here\\'s an example implementation in JavaScript:\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the above code, the timeLimited function takes two arguments: fn (the original asynchronous function) and t (the time limit in milliseconds). It returns a new asynchronous function that wraps the original function.\\n\\nInside the new function, we create a timeout promise using setTimeout which will reject with the string \"Time Limit Exceeded\" after t milliseconds. Then, we use Promise.race() to race between the original function fn(...args) and the timeout promise. Whichever promise resolves or rejects first will be returned by Promise.race().\\n\\n```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((resolve, reject) =>{\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n        });\\n        try{\\n            const result = await Promise.race([fn(...args), timeoutPromise]);\\n            return result;\\n        }catch(error){\\n            throw error;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the timeLimited function itself is constant, O(1), as it performs basic operations without any loops or recursive calls. However, the time complexity of executing the time-limited function depends on the time complexity of the original function fn.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the timeLimited function is also constant, O(1), as it only creates a few variables and promises regardless of the input size.\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((resolve, reject) =>{\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n        });\\n        try{\\n            const result = await Promise.race([fn(...args), timeoutPromise]);\\n            return result;\\n        }catch(error){\\n            throw error;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530877,
                "title": "js-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const time1 = fn(...args);\\n        const time2 = new Promise((res, rej) => {\\n            setTimeout(()=> {\\n                rej (\\'Time Limit Exceeded\\')\\n            }, t)\\n        });\\n\\n        return Promise.race([time1, time2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const time1 = fn(...args);\\n        const time2 = new Promise((res, rej) => {\\n            setTimeout(()=> {\\n                rej (\\'Time Limit Exceeded\\')\\n            }, t)\\n        });\\n\\n        return Promise.race([time1, time2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530843,
                "title": "async-w-o-async",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async(resolve,reject)=>{\\n            const id=setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n            //ASYNC way\\n            try{\\n                const res=await fn(...args);\\n                resolve(res)\\n            }catch(err){\\n                reject(err)\\n            }\\n            clearTimeout(id);\\n\\n            /*\\n            w/o async\\n            fn(...args)\\n                .then((res)=>resolve(res))\\n                .catch((err)=>reject(err))\\n                .finally(()=>clearTimeout(id))\\n            */\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async(resolve,reject)=>{\\n            const id=setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n            //ASYNC way\\n            try{\\n                const res=await fn(...args);\\n                resolve(res)\\n            }catch(err){\\n                reject(err)\\n            }\\n            clearTimeout(id);\\n\\n            /*\\n            w/o async\\n            fn(...args)\\n                .then((res)=>resolve(res))\\n                .catch((err)=>reject(err))\\n                .finally(()=>clearTimeout(id))\\n            */\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530628,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530512,
                "title": "solution-typescript-javascript",
                "content": "# Code\\n``` typescript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return Promise.race([\\n            fn(...args),\\n            new Promise((_, reject) => {\\n                setTimeout(\\n                    () => reject(\\'Time Limit Exceeded\\'),\\n                    t\\n                )\\n            })\\n        ]);  \\n    }\\n};\\n```\\n``` javascript []\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n         return Promise.race([\\n            fn(...args),\\n            new Promise((_, reject) => {\\n                setTimeout(\\n                    () => reject(\\'Time Limit Exceeded\\'),\\n                    t\\n                )\\n            })\\n        ]);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` typescript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return Promise.race([\\n            fn(...args),\\n            new Promise((_, reject) => {\\n                setTimeout(\\n                    () => reject(\\'Time Limit Exceeded\\'),\\n                    t\\n                )\\n            })\\n        ]);  \\n    }\\n};\\n```\n``` javascript []\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n         return Promise.race([\\n            fn(...args),\\n            new Promise((_, reject) => {\\n                setTimeout(\\n                    () => reject(\\'Time Limit Exceeded\\'),\\n                    t\\n                )\\n            })\\n        ]);  \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530496,
                "title": "explanation-from-the-senior-developer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code defines a function called timeLimit that takes two parameters: fn and t. Here\\'s a step-by-step explanation of how it works:\\n\\nThe timeLimit function is defined using the const keyword.\\nIt is an asynchronous function, indicated by the async keyword before the function declaration.\\nThe function takes two parameters: fn and t.\\nfn is a function that will be executed.\\nt is the time limit in milliseconds.\\nInside the function, a new anonymous async function is defined using the async function(...args) syntax. This function takes any number of arguments using the rest parameter syntax (...args).\\nThe originalFnPromise variable is declared and assigned the result of calling the fn function with the provided arguments (fn(...args)). This means that the fn function is executed with the passed arguments, and it returns a promise representing the asynchronous operation.\\nThe timeoutPromise variable is declared and assigned a new promise.\\nInside the timeoutPromise, a setTimeout function is used to delay the execution of its callback by t milliseconds.\\nIn the callback function, the promise is rejected by calling the reject function with the message \\'Time Limit Exceeded\\'. This means that if the setTimeout callback is executed after t milliseconds, the timeoutPromise will be rejected with the given error message.\\nThe Promise.race function is used to race between two promises: originalFnPromise and timeoutPromise.\\nThe Promise.race function takes an array of promises and returns a new promise that resolves or rejects as soon as one of the promises in the array settles (either resolves or rejects).\\nIn this case, it races between originalFnPromise and timeoutPromise, so whichever promise settles first will determine the outcome of the returned promise.\\nThe final result of the timeLimit function is the promise returned by Promise.race.\\nIf originalFnPromise settles (either resolves or rejects) before the timeoutPromise, the result of originalFnPromise will be passed through.\\nIf the timeoutPromise settles (rejects) before originalFnPromise, it means the time limit has been exceeded, and the rejection reason will be \\'Time Limit Exceeded\\'.\\nIn summary, the timeLimit function creates a wrapper function that adds a time limit to the execution of another function (fn). The wrapped function can be called with any number of arguments, and it returns a promise that resolves with the result of fn if it completes within the specified time (t), or rejects with the error message \\'Time Limit Exceeded\\' if fn takes longer than the specified time.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530495,
                "title": "easiest-explanation-let-s-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Promise:**\\n    - A JavaScript object which holds the producing code and calls to the consuming code.\\n    - It ensures to produce a single value when required (in the future).\\n    - It\\'s main purpose is to track & manage multiple asynchronous operations\\n    - It has *4 Stages*:\\n        1. *Fulfilled*: Promise succeeded\\n        2. *Rejected*: Promise failed\\n        3. *Pending*: Promise is still pending\\n        4. *Settled*: Promise is either fulfilled or rejected\\n    - Syntax:\\n    `var promise = new Promise(function(resolve, reject){\\n     //do something\\n});`\\n\\n- **setTimeout**:\\n    - This method is used to execute a function, after waiting for a specified number of milliseconds.\\n    - Syntax: `setTimeout(function, milliseconds);` \\n\\n- **Promise.race():** \\n    - It is one of the promise concurrency methods.\\n    - It is used when we want the first asynchronous task to complete, but do not care about its eventual state (either succeed or fail).\\n    - *For Example:* Take it as a race, so which ever promise gets successfully completed (fulfills or rejects) early will get executed and rest promise\\'s results will not be displayed as an output.\\n    - Syntax: `Promise.race(iterable);`\\n\\n\\n# Code\\n``` javaScript []\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalPromise = fn(...args);\\n\\n        const timeLimitPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalPromise, timeLimitPromise]);\\n    }\\n};\\n```\\n\\n\\uD83D\\uDC47\\uD83C\\uDFFC ***Do Share your Opinion, by voting.***",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javaScript []\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalPromise = fn(...args);\\n\\n        const timeLimitPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalPromise, timeLimitPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530493,
                "title": "simple-easy-and-sort-solution",
                "content": "```\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n   \\n    return new Promise((resolve,reject) => {\\n        setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n        fn(...args).then(resolve).catch(reject);\\n    })\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n   \\n    return new Promise((resolve,reject) => {\\n        setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n        fn(...args).then(resolve).catch(reject);\\n    })\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530483,
                "title": "chatgpt-code-snippet",
                "content": "# Intuition\\n\\nThe problem requires us to implement a time-limited version of an asynchronous function. Given an asynchronous function `fn` and a time limit `t` in milliseconds, we need to create a new function that behaves like the original function `fn` but rejects the promise with a \"Time Limit Exceeded\" message if it takes longer than `t` milliseconds to fulfill.\\n\\nTo solve this problem, we can use a wrapper function that wraps the original function `fn` and adds a timeout mechanism to enforce the time limit. If the wrapped function exceeds the specified time limit, we reject the promise with the appropriate message. Otherwise, we resolve the promise with the result.\\n\\n# Approach\\n\\n1. We define the `timeLimit` function that takes `fn` (the original asynchronous function) and `t` (the time limit) as input.\\n2. Inside the `timeLimit` function, we return a new wrapper function that accepts any number of arguments (`...args`).\\n3. In the wrapper function, we create a new promise using the `Promise` constructor. This promise will be returned to the caller of the wrapper function.\\n4. Within the promise, we start a timeout using `setTimeout` and specify the time limit `t` as the duration. If the timeout expires before the wrapped function resolves, we reject the promise with the message \"Time Limit Exceeded\".\\n5. We then invoke the original function `fn` with the provided arguments (`fn(...args)`). If the original function resolves before the timeout, we clear the timeout using `clearTimeout` and resolve the wrapper function\\'s promise with the result.\\n6. If the original function rejects, we also clear the timeout and reject the wrapper function\\'s promise with the error.\\n7. Finally, we return the wrapper function, which serves as the time-limited version of the original function.\\n\\n# Complexity Analysis\\n\\n## Time Complexity:\\nThe time complexity of the `timeLimit` function is constant, O(1), as it performs a fixed number of operations regardless of the size of the input.\\n\\n## Space Complexity:\\nThe space complexity is also constant, O(1), as no additional data structures or recursive calls are used. The memory usage remains constant throughout the execution.\\n\\n# Code\\n\\n```javascript\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\\'Time Limit Exceeded\\');\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeout);\\n          resolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeout);\\n          reject(error);\\n        });\\n    });\\n  };\\n};\\n```\\n\\n# Example Usage\\n\\n```javascript\\nconst limited = timeLimit((t) => new Promise((res) => setTimeout(res, t)), 100);\\nlimited(150).catch(console.log); // Output: \"Time Limit Exceeded\" at t=100ms\\n```\\n\\nIn this example, we create a time-limited version of an asynchronous function that waits for the specified time before resolving. The time limit is set to 100 milliseconds, but the function takes 150 milliseconds to complete. As a result, the promise is rejected with the \"Time Limit Exceeded\" message at t=100ms.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\\'Time Limit Exceeded\\');\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeout);\\n          resolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeout);\\n          reject(error);\\n        });\\n    });\\n  };\\n};\\n```\n```javascript\\nconst limited = timeLimit((t) => new Promise((res) => setTimeout(res, t)), 100);\\nlimited(150).catch(console.log); // Output: \"Time Limit Exceeded\" at t=100ms\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530316,
                "title": "easy-solution-3-line-code-75-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\nIt returns an asynchronous function that takes any number of arguments using the spread syntax ...args. This function executes the input function fn with the input arguments args and saves the result in a variable called s1.\\n\\nThe function also creates a new promise, s2, using the setTimeout method. This promise rejects with a message of \\'Time Limit Exceeded\\' if it is not resolved within t milliseconds.\\n\\nFinally, the function returns a promise that uses Promise.race to resolve with s1 if it is resolved before s2. Otherwise, it rejects with the message \\'Time Limit Exceeded\\'.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\n    var timeLimit = function(fn, t) {\\n   \\n\\treturn async function(...args) {\\n    const s1 = fn(...args)\\n    const s2= new Promise((res,rej)=>{setTimeout(()=>{ rej(\\'Time Limit Exceeded\\')},t) })\\n     return Promise.race([s1,s2])\\n    } \\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\n    var timeLimit = function(fn, t) {\\n   \\n\\treturn async function(...args) {\\n    const s1 = fn(...args)\\n    const s2= new Promise((res,rej)=>{setTimeout(()=>{ rej(\\'Time Limit Exceeded\\')},t) })\\n     return Promise.race([s1,s2])\\n    } \\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530225,
                "title": "js-promise-without-the-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObviously we have time window when we either resolve or fail.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. use setTimeout where our error is being sent to the promise \\n2. start our fn with args\\n3. when the timer gets resolved then we just fail\\n4. when the fn is complete  - we either resolve or fail depends when it succeeded\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (done, fail) => {\\n            let resolved = false;\\n            const timerOpLimitId = setTimeout(() => {\\n                resolved = true;\\n                fail(\\'Time Limit Exceeded\\');\\n            }, t ?? 0);\\n            let fnResult;\\n            try {\\n                fnResult = await (fn ? fn(...(args || [])) : Promise.resolve());\\n                resolved ? void 0 : done(fnResult);\\n            } catch (fnErrMsg) {\\n                resolved ? void 0 : fail(fnErrMsg);\\n            }\\n            clearTimeout(timerOpLimitId);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (done, fail) => {\\n            let resolved = false;\\n            const timerOpLimitId = setTimeout(() => {\\n                resolved = true;\\n                fail(\\'Time Limit Exceeded\\');\\n            }, t ?? 0);\\n            let fnResult;\\n            try {\\n                fnResult = await (fn ? fn(...(args || [])) : Promise.resolve());\\n                resolved ? void 0 : done(fnResult);\\n            } catch (fnErrMsg) {\\n                resolved ? void 0 : fail(fnErrMsg);\\n            }\\n            clearTimeout(timerOpLimitId);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530162,
                "title": "day-12-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t));\\n    const resultPromise = fn(...args);\\n\\n    return Promise.race([resultPromise, timeoutPromise]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t));\\n    const resultPromise = fn(...args);\\n\\n    return Promise.race([resultPromise, timeoutPromise]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530121,
                "title": "promise-settimeout-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args)\\n        .then(resolve)\\n        .catch(reject)\\n        .finally(() => clearTimeout(timeout));\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args)\\n        .then(resolve)\\n        .catch(reject)\\n        .finally(() => clearTimeout(timeout));\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530038,
                "title": "javascript-easy-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/822d61df-974d-44c0-8bb1-186b62dbbe65_1684225412.9392846.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530029,
                "title": "promise-time-limit-solution-with-promise-race-and-settimeout-js-day-12",
                "content": "# Intuition\\nTo solve this problem we need to take into account the time limit during which our function can be executed.\\nFor this we will use `setTimeout` inside a promise and the `Promise.race` method to get the first settled promise.\\n\\n# Approach\\nLets create a new Promise `timeLimitedPromise` to control execution time based on a time.\\nThen we should call it together with our function in `Promise.race`. \\n`race` method will return the first fulfilled promise and that will be our function call or time limit promise if time limit was exceeded.\\nP.s. We can omit errors as they are not specified in the problem requirements.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeLimitedPromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n        return Promise.race([\\n            fn(...args),\\n            timeLimitedPromise\\n        ])\\n    }\\n};\\n\\n```\\n\\n\\nIf you like this solution and it looks simple and clean please vote. It would motivate me ;)\\n\\nThanks!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeLimitedPromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n        return Promise.race([\\n            fn(...args),\\n            timeLimitedPromise\\n        ])\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529962,
                "title": "promise-time-limit-easy-solution",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"),t);\\n            fn(...args).then(res, rej);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"),t);\\n            fn(...args).then(res, rej);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529944,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n     const start = Date.now();\\n     const result = await Promise.race([fn(...args), new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))]);\\n      const elapsed = Date.now() - start;\\n     if (elapsed >= t) {\\n        throw \"Time Limit Exceeded\";\\n    }\\n       return result;\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n     const start = Date.now();\\n     const result = await Promise.race([fn(...args), new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))]);\\n      const elapsed = Date.now() - start;\\n     if (elapsed >= t) {\\n        throw \"Time Limit Exceeded\";\\n    }\\n       return result;\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529901,
                "title": "well-explained-clean-solution-promise-race",
                "content": "# Question Explanation\\nA promise \"fn\" is provided which is going to be resolved in some x time we dont know. We have to build a new Promise which should be rejected in \"t\" seconds.\\nIf the promise fn takes more than \"t\" seconds to be resolved then the newly created promise should reject by Time Limit Exceeded, else the resolved value of the \"fn\" promise should be returned.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nAll we have to do is to check which Promise is executed first, is it \\n\"fn\" Promise or the newly created promise.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Promise.race() static method takes an iterable of promises as input and returns a single Promise. This single promise is the promise which get resolved or rejected first.\\nHence, if \"fn\" promise gets resolved within t time, then is send the resolved value, else the newly created Prommise sends \"Time Limit Exceeded\".\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n\\treturn async function(...args) {\\n        \\n        const newPromise = new Promise((resolve, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n\\n        const actualPromise = fn(...args);\\n\\n        return Promise.race([actualPromise, newPromise]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n\\treturn async function(...args) {\\n        \\n        const newPromise = new Promise((resolve, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n\\n        const actualPromise = fn(...args);\\n\\n        return Promise.race([actualPromise, newPromise]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529870,
                "title": "day-12-js-simple-and-easy-promise-race-solution",
                "content": "# Intuition\\nThe Question states that we have given a fn function that returns a promise .\\n\\nNow we are also Given the timelimit t\\n\\nif the promise is resolved within t miliseconds then the promise with fn if returned\\n\\nElse the promise with **Time Limit Exceeded** is Returned\\n\\n# Approach\\nToday from one of the solution I learned about **Promise.race**\\n\\n1. **Promise.race** : it takes different promises and returns the promise that resolves faster\\n2. So We Are going to use this approach to solve the question\\n3. First we will have the promise returned by the function fn\\n\\n```\\n const ogPromise = fn(...args)\\n```\\n4. Now we will have a delayed promise with t time that rejects with message of \"TIME LIMIT EXCEEDED\"\\n5. We wil be using the setTimeout function for the delay of t miliseconds\\n\\n ```\\nconst DelayedPromise = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t);\\n        })\\n```\\n\\n6. Now we will be returning the promise with faster resolving time . i.e. if promise ogPromise is resolved first it is returned or if the promise with delayed time is resolved first then it is returned.\\n7. For this purpose we will be using Promise.rece with both promises as parameters\\n\\n```\\nPromise.race([ogPromise,DelayedPromise]);\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nHere n will be the max time required to resolve a promise\\n\\n- Space complexity:\\n $$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const ogPromise = fn(...args);\\n\\n        const DelayedPromise = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t);\\n        })\\n\\n        return Promise.race([ogPromise,DelayedPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n# **If You Like my solution Dont forget to upvote \\uD83D\\uDE07**\\n![upvote.jpg](https://assets.leetcode.com/users/images/2b07485f-1a17-487f-923c-66b3b03e39ca_1684221712.7089345.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n const ogPromise = fn(...args)\\n```\n```\\nconst DelayedPromise = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t);\\n        })\\n```\n```\\nPromise.race([ogPromise,DelayedPromise]);\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const ogPromise = fn(...args);\\n\\n        const DelayedPromise = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t);\\n        })\\n\\n        return Promise.race([ogPromise,DelayedPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529780,
                "title": "time-juggler-putting-async-functions-on-a-leash",
                "content": "# Intuition\\nThe timeLimit function takes an original asynchronous function fn and a time limit t as input. It returns a new asynchronous function that ensures the execution of fn is time-limited.\\n\\nInside the new function, a promise is created with a timeout using setTimeout to reject if the time limit is exceeded. fn is then invoked with the provided arguments, and its promise is chained to the timeout promise using .then() and .catch().\\n\\nIf fn resolves within the time limit, the new function resolves with the resolved value. If fn rejects or the time limit is exceeded, the new function rejects with the appropriate value or message.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe timeLimit function takes two parameters: fn, which represents the original asynchronous function, and t, which is the time limit in milliseconds.\\n\\nIt returns a new asynchronous function that accepts any number of arguments (...args).\\n\\nInside the new function, a promise is created using the Promise constructor. This promise is responsible for tracking the time limit.\\n\\nA setTimeout function is used to set up a timer. After the specified time t has elapsed, the timer triggers and the promise is rejected with the message \"Time Limit Exceeded\".\\n\\nThe original function fn is invoked with the provided arguments (fn(...args)). It returns a promise representing the execution of the original function.\\n\\nThe promise returned by fn(...args) is chained using .then() and .catch(). If the original function resolves within the time limit, the promise chain resolves with the resolved value. If it rejects, the promise chain rejects with the same error.\\n\\nThe promise chain is wrapped inside the outer promise created in step 3. This ensures that the overall promise returned by the new function resolves or rejects based on the execution of the original function and the time limit.\\n\\nThe new function returns the promise, allowing the caller to handle the result using .then() and .catch().\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\",);\\n            },t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\",);\\n            },t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529742,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\",);\\n            },t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\",);\\n            },t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529731,
                "title": "day-12",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n    const result = Promise.resolve(fn.apply(this, args));\\n    const timeout = new Promise((_, reject) =>\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    );\\n    return Promise.race([result, timeout]);\\n  };\\n};\\n\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n    const result = Promise.resolve(fn.apply(this, args));\\n    const timeout = new Promise((_, reject) =>\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    );\\n    return Promise.race([result, timeout]);\\n  };\\n};\\n\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529707,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing wrapper function having two argument fn and t.Now check fot each condition and return result accordingly;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate wrapper function having two argument fn(original function) and t(time limit).If the timer expire before the promise resolved , reject the promise by the string \"Time Limit Exceeded\".If the function complete before the time limit ,resolve the promise by result.At last return promise from async function.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(f(n));\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((delayresolve , reject)=>{\\n            const timeoutId= setTimeout(()=>{\\n                clearTimeout(timeoutId);\\n                reject(\"Time Limit Exceeded\");\\n            },t);\\n            fn(...args)\\n            .then((result)=>{\\n                clearTimeout(timeoutId);\\n                delayresolve(result);\\n            })\\n            .catch((error)=>{\\n                clearTimeout(timeoutId);\\n                reject(error);\\n            });\\n        });\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((delayresolve , reject)=>{\\n            const timeoutId= setTimeout(()=>{\\n                clearTimeout(timeoutId);\\n                reject(\"Time Limit Exceeded\");\\n            },t);\\n            fn(...args)\\n            .then((result)=>{\\n                clearTimeout(timeoutId);\\n                delayresolve(result);\\n            })\\n            .catch((error)=>{\\n                clearTimeout(timeoutId);\\n                reject(error);\\n            });\\n        });\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529678,
                "title": "promise-with-handlers",
                "content": "# Explanation\\n##### Given the time limit (t), the async function should :-\\n1. If function **(fn)** gets fullfilled (either *resolved* or *rejected* ) before time limit **(t)**, then either *resolve with the return value* or *reject with the error* related to the function (fn)\\n2. If function **(fn)** is *not fullfilled* before time limit **(t)**, then *reject* with the message (\"Time Limit Exceeded\") **at time (t)**;\\n\\n# Approach\\n1. Declare a **setTimeout** function to reject at time (t) if the function (fn) is not fullfilled before that time.\\n2. Invoke the function **(fn)** and attach handlers (**.then** -> to resolve with response and **.catch** to handle reject with errors). \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {   \\n\\treturn async function(...args) {        \\n       return new Promise((resolve,reject) => {\\n           // if time exceeds the time limit \"t\"\\n           setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n\\n           // if fullfilled before the time limit \"t\"\\n           fn(...args)\\n                .then((result) => resolve(result))\\n                .catch((err) => reject(err));          \\n       });    \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {   \\n\\treturn async function(...args) {        \\n       return new Promise((resolve,reject) => {\\n           // if time exceeds the time limit \"t\"\\n           setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n\\n           // if fullfilled before the time limit \"t\"\\n           fn(...args)\\n                .then((result) => resolve(result))\\n                .catch((err) => reject(err));          \\n       });    \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529574,
                "title": "easy-98-beaten-code-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const p1 = fn(...args)\\n        const p2 = new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\\'Time Limit Exceeded\\')               \\n            },t)\\n        })\\n\\n        return Promise.race([p1,p2])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const p1 = fn(...args)\\n        const p2 = new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\\'Time Limit Exceeded\\')               \\n            },t)\\n        })\\n\\n        return Promise.race([p1,p2])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529573,
                "title": "without-race-function-simple-typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n            fn(...args)\\n                .then(res)\\n                .catch(rej);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n            fn(...args)\\n                .then(res)\\n                .catch(rej);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529569,
                "title": "1-liner",
                "content": "\\n```\\n\\nconst timeLimit = (fn, t) => (...args) =>\\n    Promise.race([\\n      fn(...args),\\n      new Promise((_, reject) => setTimeout(reject, t, \\'Time Limit Exceeded\\')),\\n    ]);\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst timeLimit = (fn, t) => (...args) =>\\n    Promise.race([\\n      fn(...args),\\n      new Promise((_, reject) => setTimeout(reject, t, \\'Time Limit Exceeded\\')),\\n    ]);\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529501,
                "title": "js-promise-race-time-57ms-75-space-42mb-47",
                "content": "# Approach\\nWe\\'ll try out the `Promise.race` method which automatically returns the first promise to finish,\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        // timeout promise\\n        const timeout = new Promise ((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n        // function promise\\n        const func = fn(...args);\\n        // return first promise that resolves/rjects\\n        return Promise.race([timeout, func])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        // timeout promise\\n        const timeout = new Promise ((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n        // function promise\\n        const func = fn(...args);\\n        // return first promise that resolves/rjects\\n        return Promise.race([timeout, func])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529439,
                "title": "javascript-simple-javascript-typescript-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 70 ms, faster than 10.25% of JavaScript online submissions for Promise Time Limit.\\n# Memory Usage: 41.4 MB, less than 97.51% of JavaScript online submissions for Promise Time Limit.\\n\\n\\tvar timeLimit = function(fn, t) {\\n\\t\\treturn async function(...args) {\\n\\t\\t\\treturn new Promise((resolve, reject) => {\\n\\n\\t\\t\\t\\tsetTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t);\\n\\n\\t\\t\\t\\tfn(...args).then(resolve).catch(reject);\\n\\n\\t\\t\\t});\\n\\t\\t};\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 61 ms, faster than 71.67% of TypeScript online submissions for Promise Time Limit.\\n# Memory Usage: 42.8 MB, less than 77.11% of TypeScript online submissions for Promise Time Limit.\\n\\n\\ttype Fn = (...params: any[]) => Promise<any>;\\n\\n\\tfunction timeLimit(fn: Fn, t: number): Fn {\\n\\t\\treturn async function(...args) {\\n\\t\\t\\treturn new Promise((resolve, reject) => {\\n\\n\\t\\t\\t\\tsetTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t);\\n\\n\\t\\t\\t\\tfn(...args).then(resolve).catch(reject);\\n\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 70 ms, faster than 10.25% of JavaScript online submissions for Promise Time Limit.\\n# Memory Usage: 41.4 MB, less than 97.51% of JavaScript online submissions for Promise Time Limit.\\n\\n\\tvar timeLimit = function(fn, t) {\\n\\t\\treturn async function(...args) {\\n\\t\\t\\treturn new Promise((resolve, reject) => {\\n\\n\\t\\t\\t\\tsetTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t);\\n\\n\\t\\t\\t\\tfn(...args).then(resolve).catch(reject);\\n\\n\\t\\t\\t});\\n\\t\\t};\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 61 ms, faster than 71.67% of TypeScript online submissions for Promise Time Limit.\\n# Memory Usage: 42.8 MB, less than 77.11% of TypeScript online submissions for Promise Time Limit.\\n\\n\\ttype Fn = (...params: any[]) => Promise<any>;\\n\\n\\tfunction timeLimit(fn: Fn, t: number): Fn {\\n\\t\\treturn async function(...args) {\\n\\t\\t\\treturn new Promise((resolve, reject) => {\\n\\n\\t\\t\\t\\tsetTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t);\\n\\n\\t\\t\\t\\tfn(...args).then(resolve).catch(reject);\\n\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 3529432,
                "title": "promise-time-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => { // create a new promise to return \\n\\n        // create a timer to reject the promise if the `t` time passes\\n        const timeout = setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        // start using the function as usual if it\\'s succed before just return it\\n        fn(...args)\\n            .then(resolve)\\n            .catch(reject)\\n            // clear timer is needed to free memory from setTimeout - good practise\\n            .finally(() => clearTimeout(timeout));\\n        })\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => { // create a new promise to return \\n\\n        // create a timer to reject the promise if the `t` time passes\\n        const timeout = setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        // start using the function as usual if it\\'s succed before just return it\\n        fn(...args)\\n            .then(resolve)\\n            .catch(reject)\\n            // clear timer is needed to free memory from setTimeout - good practise\\n            .finally(() => clearTimeout(timeout));\\n        })\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529419,
                "title": "try-to-understand-the-problem",
                "content": "**Understand the problem -**\\n\\nGiven an asyncronous function `fn` and a time `t` in milliseconds, return a new time limited version of the input function.\\n\\nWe have to return a new time limited version of the input function. What is time limited function then ?\\n\\nA time limited function is a function that is identical to the original unless it takes longer than `t` milliseconds to fullfill. In that case, it will reject with \"Time Limit Exceeded\".  Note that it should reject with a string, not an Error.\\n\\nBreakdown the definition ->\\n\\nA time limited function is a function means we have to return a function (We have to return a time limited version of the input function)-> \\n\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args){}\\n};\\n```\\ntime limited function is identical to the original function ->\\nmeans return function is also asyncronous\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args){}\\n};\\n```\\nIf the input function take more time to resolve then it will reject with time limit exceeded otherwise resolve.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject) => {\\n            fn(...args).then((val) => resolve(val)). catch((err) => reject(err));\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\');\\n            },t);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args){}\\n};\\n```\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args){}\\n};\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject) => {\\n            fn(...args).then((val) => resolve(val)). catch((err) => reject(err));\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\');\\n            },t);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529397,
                "title": "js-solution-40-8-mb-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then(resolve).catch(reject);\\n        }\\n        );\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then(resolve).catch(reject);\\n        }\\n        );\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529377,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n\\n        const rejector=setTimeout(()=>{\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        \\n        fn(...args)\\n            .then(resolve)\\n            .catch(reject)\\n            .finally(()=>clearTimeout(rejector));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n\\n        const rejector=setTimeout(()=>{\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        \\n        fn(...args)\\n            .then(resolve)\\n            .catch(reject)\\n            .finally(()=>clearTimeout(rejector));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529369,
                "title": "day-12-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529362,
                "title": "javascript-simple-solution-using-promise-then-catch-and-finally",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(id))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(id))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529299,
                "title": "day-12-javascript-challenge",
                "content": "# Intuition\\nRace condition in Promise\\n\\n# Approach\\nUsed Promise.race for checking function call\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n    return async function (...args) {\\n        const returnPromise = fn(...args);\\n\\n        const timeLimitPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([returnPromise, timeLimitPromise])\\n    }\\n\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n    return async function (...args) {\\n        const returnPromise = fn(...args);\\n\\n        const timeLimitPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([returnPromise, timeLimitPromise])\\n    }\\n\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529294,
                "title": "time-limited-function-optimized-solution",
                "content": "# Intuition\\nThe problem requires us to implement a time-limited version of an asynchronous function. If the original function takes longer than the specified time limit to fulfill, it should reject with a \"Time Limit Exceeded\" message. Our task is to design an optimized solution that efficiently handles the time limit.\\n\\n# Approach\\nTo solve the problem, we can use the `Promise.race` method, which allows us to race two promises against each other: the result of the original function and a timer-based promise that rejects if the time limit is exceeded. By leveraging this approach, we can effectively control the execution time and handle the time limit with simplicity.\\n\\nIn the implementation, we define a higher-order function `timeLimit `that takes the original function `fn` and the time limit `t` as parameters. Inside this function, we return an asynchronous function that serves as the time-limited version of `fn`. Within this asynchronous function, we use `Promise.race` to race two promises: the result of `fn(...args)` and a new promise created using `setTimeout`. If the original function resolves or rejects before the timeout, the corresponding result or error will be returned. However, if the timeout occurs first, the promise will reject with the \"Time Limit Exceeded\" message.\\n\\n# Complexity\\n- Time complexity:\\n The time complexity of this solution depends on the execution time of the original function `fn` and the timeout duration `t`. In the worst case, if `fn` takes longer than `t` to complete, the time complexity will be determined by the longer of the two. Therefore, the time complexity can vary between **O(fn) and O(t)**, whichever is larger.\\n\\n\\n\\n- Space complexity:\\nThe space complexity of this solution is relatively low and remains constant. It primarily depends on the memory required to store the original function `fn`, the timeout duration `t`, and the arguments passed to the time-limited function. Hence, the space complexity is **O(1)**, as it does not grow significantly with the input size or time limit.\\n\\nPlease note that the actual time complexity will depend on the characteristics of the original function and the specified time limit, and it may vary in different scenarios.\\n# Code\\n```\\nconst timeLimit = (fn, t) => {\\n  return async function(...args) {\\n    return Promise.race([\\n      fn(...args),\\n      new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))\\n    ]);\\n  };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst timeLimit = (fn, t) => {\\n  return async function(...args) {\\n    return Promise.race([\\n      fn(...args),\\n      new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))\\n    ]);\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529278,
                "title": "easy-solution-with-promise-race",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let firstPromise = fn(...args);\\n        let secondPromise = new Promise((resolve, reject) => \\n                            setTimeout(() => reject(\"Time Limit Exceeded\"), t));\\n        return Promise.race([firstPromise, secondPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let firstPromise = fn(...args);\\n        let secondPromise = new Promise((resolve, reject) => \\n                            setTimeout(() => reject(\"Time Limit Exceeded\"), t));\\n        return Promise.race([firstPromise, secondPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529252,
                "title": "easy-javascript-solution",
                "content": "# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject)=> {\\n           const timeout =  setTimeout(() => {\\n                reject(\"Time Limit Exceeded\")\\n            },t) \\n\\n            fn(...args)\\n                .then(resolve)\\n                .catch(reject)\\n                .finally(() => clearTimeout(timeout))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject)=> {\\n           const timeout =  setTimeout(() => {\\n                reject(\"Time Limit Exceeded\")\\n            },t) \\n\\n            fn(...args)\\n                .then(resolve)\\n                .catch(reject)\\n                .finally(() => clearTimeout(timeout))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529248,
                "title": "promise-time-limit-in-1",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = function (fn, t) {\\n\\n    //  func is async and will return a Promise\\n  return async function (...args) {\\n    const timeout = new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    //    //  first Promise to reject  win the race\\n    const result = Promise.race([fn(...args), timeout]);\\n\\n    try {\\n      const value = await result;\\n      return value;\\n    } catch (error) {\\n         // If there is any error, throw it as a number\\n      throw error;\\n    }\\n  };\\n};\\n\\nconst fn = async (n) => {\\n  await new Promise((res) => setTimeout(res, 100));\\n  return n * n;\\n};\\n\\nconst limited = timeLimit(fn, 50);\\nlimited(5)\\n  .then(console.log) // Will not be called because the promise is rejected\\n  .catch(console.error); // {\"rejected\":\"Time Limit Exceeded\",\"time\":50}\\n\\n\\n\\n  // Time comp : - O(1)\\n  // space comp : - O(1)\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = function (fn, t) {\\n\\n    //  func is async and will return a Promise\\n  return async function (...args) {\\n    const timeout = new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    //    //  first Promise to reject  win the race\\n    const result = Promise.race([fn(...args), timeout]);\\n\\n    try {\\n      const value = await result;\\n      return value;\\n    } catch (error) {\\n         // If there is any error, throw it as a number\\n      throw error;\\n    }\\n  };\\n};\\n\\nconst fn = async (n) => {\\n  await new Promise((res) => setTimeout(res, 100));\\n  return n * n;\\n};\\n\\nconst limited = timeLimit(fn, 50);\\nlimited(5)\\n  .then(console.log) // Will not be called because the promise is rejected\\n  .catch(console.error); // {\"rejected\":\"Time Limit Exceeded\",\"time\":50}\\n\\n\\n\\n  // Time comp : - O(1)\\n  // space comp : - O(1)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529218,
                "title": "typescript-solution-with-promise-race",
                "content": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n  return async (...args) => {\\n    const timeoutPromise = new Promise((_, reject) => {\\n      setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n    });\\n\\n    const result = await Promise.race([timeoutPromise, fn(...args)]);\\n    return result;\\n  };\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n  return async (...args) => {\\n    const timeoutPromise = new Promise((_, reject) => {\\n      setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n    });\\n\\n    const result = await Promise.race([timeoutPromise, fn(...args)]);\\n    return result;\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529205,
                "title": "beats-98-74-with-promise-race",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n[Promise.race() documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)\\n# Approach\\nThe timeLimit function takes in an asynchronous function and a time limit in milliseconds as its arguments. It returns a new function that has the same signature as the original function. This returned function is also an asynchronous function that can be called with any number of arguments.\\n\\nInside the returned function, a timeout promise is created using setTimeout with the specified time limit. If the original function takes longer than the time limit, the timeout promise will reject with the error message \\'Time Limit Exceeded\\'.\\n\\n** Then, Promise.race is used to race the original function with the timeout promise. The result of the race is stored in a variable called result.\\n\\nIf the original function resolves before the timeout promise, the timeout promise is still active and needs to be cleared using clearTimeout. Then, result is returned.\\n\\nIf the timeout promise rejects first, clearTimeout is called to cancel the timer, and the function rejects with the string \\'Time Limit Exceeded\\'. **\\n\\nOverall, the timeLimit function provides a simple and effective way to time-limit an asynchronous function and return a specific error message if the time limit is exceeded.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529142,
                "title": "simple-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            setTimeout(() => {reject(\"Time Limit Exceeded\")}, t);\\n        })]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            setTimeout(() => {reject(\"Time Limit Exceeded\")}, t);\\n        })]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529093,
                "title": "typescript-solution",
                "content": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise<any>((resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            \\n            return fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(id))\\n        })\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise<any>((resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            \\n            return fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(id))\\n        })\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529087,
                "title": "with-promice",
                "content": "# With Promice\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout (() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout (() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529082,
                "title": "new-promise-javascript",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject); \\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject); \\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529035,
                "title": "easy-way-solution",
                "content": "Intuition\\nThe problem requires limiting the time a function takes to execute to prevent it from running indefinitely. To achieve this, we can use a timeout mechanism that rejects the promise if the function execution time exceeds the specified limit.\\n\\nApproach\\nWe can define a higher-order function timeLimit that takes in a function fn and a time limit t. The timeLimit function returns a new function that wraps the original function. This new function uses a Promise.race to race two promises:\\n\\nThe promise returned by the original function fn with its parameters.\\nA timeout promise that rejects with the message \"Time Limit Exceeded\" after t milliseconds.\\nIf the fn promise is resolved before the timeout, we clear the timeout using clearTimeout and return the resolved value. If the fn promise is rejected, we also clear the timeout and rethrow the error. If the timeout is triggered before the fn promise resolves, it rejects with the \"Time Limit Exceeded\" message.\\n\\nComplexity\\nTime complexity: The time complexity of this solution is O(1) because we are adding a constant amount of time complexity to each function call. The timeLimit function takes O(1) time, and the wrapped function takes the same time as the original function fn.\\nSpace complexity: The space complexity of this solution is O(1) because we are not creating any additional data structures.\\n#Code\\nconst timeLimit = (fn, t) => {\\n  return async (...args) => {\\n    let timeoutId;\\n    const timeoutPromise = new Promise((_, reject) => {\\n      timeoutId = setTimeout(() => {\\n        reject(\\'Time Limit Exceeded\\');\\n      }, t);\\n    });\\n\\n    try {\\n      const result = await Promise.race([fn(...args), timeoutPromise]);\\n      clearTimeout(timeoutId);\\n      return result;\\n    } catch (error) {\\n      clearTimeout(timeoutId);\\n      throw error;\\n    }\\n  };\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Intuition\\nThe problem requires limiting the time a function takes to execute to prevent it from running indefinitely. To achieve this, we can use a timeout mechanism that rejects the promise if the function execution time exceeds the specified limit.\\n\\nApproach\\nWe can define a higher-order function timeLimit that takes in a function fn and a time limit t. The timeLimit function returns a new function that wraps the original function. This new function uses a Promise.race to race two promises:\\n\\nThe promise returned by the original function fn with its parameters.\\nA timeout promise that rejects with the message \"Time Limit Exceeded\" after t milliseconds.\\nIf the fn promise is resolved before the timeout, we clear the timeout using clearTimeout and return the resolved value. If the fn promise is rejected, we also clear the timeout and rethrow the error. If the timeout is triggered before the fn promise resolves, it rejects with the \"Time Limit Exceeded\" message.\\n\\nComplexity\\nTime complexity: The time complexity of this solution is O(1) because we are adding a constant amount of time complexity to each function call. The timeLimit function takes O(1) time, and the wrapped function takes the same time as the original function fn.\\nSpace complexity: The space complexity of this solution is O(1) because we are not creating any additional data structures.\\n#Code\\nconst timeLimit = (fn, t) => {\\n  return async (...args) => {\\n    let timeoutId;\\n    const timeoutPromise = new Promise((_, reject) => {\\n      timeoutId = setTimeout(() => {\\n        reject(\\'Time Limit Exceeded\\');\\n      }, t);\\n    });\\n\\n    try {\\n      const result = await Promise.race([fn(...args), timeoutPromise]);\\n      clearTimeout(timeoutId);\\n      return result;\\n    } catch (error) {\\n      clearTimeout(timeoutId);\\n      throw error;\\n    }\\n  };\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3528977,
                "title": "using-promise-race-30-days-of-lc-javascript-challenge-js-and-ts-solution-day-11",
                "content": "## Intuition\\n- We use Javascript\\'s Promise.race function to choose between the timeout and the async function `fn`\\n- We create a `new Promise` `timeLimit` represent the countdown of the time limit `t`\\n- We create another variable to store represent the countdown of our function `fnTime`\\n- We then Promise.race `timeLimit` and `fnTime` and return whichever completes first\\n\\n## Code\\n``` javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let timeLimit = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t);});\\n        let fnTime = fn(...args)\\n        return Promise.race([timeLimit, fnTime])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n``` typescript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let timeLimit = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t);});\\n        let fnTime = fn(...args)\\n        return Promise.race([timeLimit, fnTime])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let timeLimit = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t);});\\n        let fnTime = fn(...args)\\n        return Promise.race([timeLimit, fnTime])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n``` typescript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let timeLimit = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t);});\\n        let fnTime = fn(...args)\\n        return Promise.race([timeLimit, fnTime])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528934,
                "title": "day-12-easy-solution-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n            fn(...args).then(resolve).catch(reject);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n            fn(...args).then(resolve).catch(reject);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528882,
                "title": "easy-algorithm-explained-javascript",
                "content": "# Intuition:\\nThe timeLimit function returns a higher-order function that takes two arguments: a function (fn) and a time limit (t), and returns a promise that wraps the execution of the fn function. If the fn function takes longer than t milliseconds to execute, the promise is rejected with a \"Time Limit Exceeded\" error message.\\n\\n# Algorithm:\\n\\n1. Define a timeLimit function that takes two arguments:\\n   - fn: the function to execute within the time limit\\n   - t: the time limit in milliseconds\\n2. The timeLimit function returns a new function that takes an arbitrary number of arguments using the spread syntax ...args.\\n3. Within the new function, return a Promise that wraps the execution of the fn function.\\n4. Set a timeout function that rejects the promise with a \"Time Limit Exceeded\" error message after t milliseconds.\\n5. Execute the fn function with the spread syntax ...args.\\n6. If the fn function resolves its promise, then resolve the outer promise with the same value.\\n7. If the fn function rejects its promise, then reject the outer promise with the same reason.\\n# Time complexity:\\nThe time complexity of the timeLimit function is O(1), as it performs a constant amount of work and does not depend on the size of the input.\\n\\n# Space complexity:\\nThe space complexity of the timeLimit function is O(1), as it uses a constant amount of memory and does not depend on the size of the input. However, the memory usage may increase depending on the implementation of the fn function.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise( (resolve, reject) => {\\n            setTimeout( () => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args)\\n            .then(resolve)\\n            .catch(reject);\\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise( (resolve, reject) => {\\n            setTimeout( () => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args)\\n            .then(resolve)\\n            .catch(reject);\\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528870,
                "title": "promise-race-js-solution",
                "content": "# Promises\\n\\nA `Promise` is an object representing the `eventual completion / failure`  of an `asynchronous` operation and its resulting value\\n\\n`Promises` are helpful as it provides a way to handle `asynchronous` operations involving a sequences of steps, making us write cleaner, maintainable `asynchronous` code\\n\\n### Three State Promise\\n\\n`Promise` has three states:\\n\\n- `Pending` - This is the initial state of a `Promise` it is yet `fulfilled` nor `rejected`\\n- `Fulfilled` - The `Promise` has successfully been `resolved` . Thus, the `resulting value` is now available\\n- `Rejected` - The `Promises` has `failed`  . Thus, an `error` or the `rejected reasoning` is now available\\n\\nFrom `Pending` state `Promise` can transition to either being `Fulfilled` or  `Rejected` . Once, a Promise is `Fulfilled` or  `Rejected` , it will remain in either one of these states with its fixed value\\n\\n### Promise.race\\n\\nWe can use `Promise.race` to directly handle the resolved and rejected states of `promise` or `timeout` for our code. Whichever promise settles first will determine the returned promise state\\n\\n- If the `promise` resolves first, the `timeLimit function` will properly display the desired output value\\n- If the `timeout` resolves first, the `timeLimit function` will properly reject with `Time Limit Exceeded` message\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise = fn(...args)\\n        const timeout = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n        })\\n        return Promise.race([promise, timeout])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise = fn(...args)\\n        const timeout = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n        })\\n        return Promise.race([promise, timeout])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528848,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528829,
                "title": "promise-solution-with-comments",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n        return new Promise((resolve, reject) => {\\n            // If this timeout runs, the time limit is exceeded and we reject the promise\\n            const timeout = setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n\\n            // Call fn with the arguments passed in\\n            fn(...args).then((res) => {\\n                // If it resolves successfully we clear the timeout so it won\\'t reject the promise\\n                clearTimeout(timeout);\\n                // And we resolve the promise with the result of calling fn()\\n                resolve(res);\\n            // If fn throws an error, we reject the promise with the error\\n            }).catch((err) => reject(err));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n        return new Promise((resolve, reject) => {\\n            // If this timeout runs, the time limit is exceeded and we reject the promise\\n            const timeout = setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n\\n            // Call fn with the arguments passed in\\n            fn(...args).then((res) => {\\n                // If it resolves successfully we clear the timeout so it won\\'t reject the promise\\n                clearTimeout(timeout);\\n                // And we resolve the promise with the result of calling fn()\\n                resolve(res);\\n            // If fn throws an error, we reject the promise with the error\\n            }).catch((err) => reject(err));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528819,
                "title": "video-blog-deep-dive",
                "content": "**DAY 12 - 30 Days of LC JS\\n2637. Promise Time Limit**\\n\\n**Easy Explanation:**\\nhttps://youtu.be/mKAAdiddkkw\\nhttps://code-crusaders.epizy.com/day-12-promise-time-limit/\\n\\n**Code**\\n``` javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args)\\n        .then(resolve)\\n        .catch(reject);\\n    });\\n  };\\n};\\n\\n```\\n\\n**Happy Coding ^_^**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args)\\n        .then(resolve)\\n        .catch(reject);\\n    });\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528786,
                "title": "day-12-javascript-typescript",
                "content": "# Code - JS\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        promise1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)});\\n        promise2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)});\\n        return Promise.race([promise1, promise2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n# TS\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const promise1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)});\\n        const  promise2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)});\\n        return Promise.race([promise1, promise2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        promise1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)});\\n        promise2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)});\\n        return Promise.race([promise1, promise2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const promise1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)});\\n        const  promise2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)});\\n        return Promise.race([promise1, promise2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521517,
                "title": "promise-time-limit-js-two-promise-60-ms",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {    \\n        p1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)})\\n        p2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)})\\n                        \\n        return Promise.race([p1, p2])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {    \\n        p1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)})\\n        p2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)})\\n                        \\n        return Promise.race([p1, p2])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515831,
                "title": "ts-promise-race-vs-returning-a-new-promise-52ms-42-8mb",
                "content": "This is a nice challenge, directly between the easier [sleep](https://leetcode.com/problems/sleep/) ([cracked here](https://leetcode.com/problems/sleep/solutions/3495914/)) and the more challenging [promise pool](https://leetcode.com/problems/promise-pool/) ([cracked here](https://leetcode.com/problems/promise-pool/solutions/3534230/)): definitely consider solving all of them to consolidate!\\n\\nFirst, let\\'s go with the easiest approach of having two promises running at the same time:\\n* `p1` will be our rejection promise, \"rejecting\" the planned message after `t` milliseconds;\\n* `p2` will be our resolve promise.\\n\\nWhat makes us solve this problem easily is the built-in `Promise` method [`.race()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race): unlike [`.any`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any) (click either to read the documentation on MDN), this will register both resolutions and rejections, giving us the result of the first one to happen, we want.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async function(...args) {\\n        // rejection promise\\n        const p1 = new Promise((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n        // resolve promise\\n        const p2 = new Promise((res) => res(fn(...args)));\\n        return Promise.race([p1, p2])\\n    }\\n};\\n```\\n\\nAnd since `async`-`await` is basically still syntactic sugar to get a promise effect, we don\\'t even need to wrap `p2` into a new one:\\n\\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async function(...args) {\\n        // rejection promise\\n        const p1 = new Promise((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n        // resolve promise\\n        const p2 = fn(...args);\\n        return Promise.race([p1, p2])\\n    }\\n};\\n```\\n\\nAlternatively we can just `return` a new `Promise` with inside an instruction to time out in `t` milliseconds and reject, followed by the call to our function `fn` with the matching resolution and rejection clauses (We need the latter for the fourth case, that tests that explicitly):\\n\\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async (...args) => {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(res).catch(rej);\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async function(...args) {\\n        // rejection promise\\n        const p1 = new Promise((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n        // resolve promise\\n        const p2 = new Promise((res) => res(fn(...args)));\\n        return Promise.race([p1, p2])\\n    }\\n};\\n```\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async function(...args) {\\n        // rejection promise\\n        const p1 = new Promise((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n        // resolve promise\\n        const p2 = fn(...args);\\n        return Promise.race([p1, p2])\\n    }\\n};\\n```\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async (...args) => {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(res).catch(rej);\\n        });\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3491503,
                "title": "using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve,reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve,reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3491055,
                "title": "typescript-3-lines",
                "content": "\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n    const timeLimit = new Promise((r, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n\\treturn async function(...args) {\\n        return await Promise.race([fn(...args), timeLimit]) \\n    }\\n};\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n    const timeLimit = new Promise((r, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n\\treturn async function(...args) {\\n        return await Promise.race([fn(...args), timeLimit]) \\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3488562,
                "title": "beginner-friendly-solution-detailed-explanation-about-promises",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Promises is object that will return a resolve - if fulfilled or reject - if failed or rejected. \\n- In this case, we are given a function with a set TimeOut, and a `t` number variable.\\n- We need to test wheter if the function given can be finished within `t` time\\n- Basic approach will be comparing the `t` with the time in the function, however we do not have the variable of time in the function because it uses `...args` as props.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Ways to do it is to make a promise with a setTimeout, that will return a  reject if not fulfilled. \\n2. We will delete the promise (setTimeout) if the function  given are executed first, using `.finally(()=> clearTimeout(timeoutId));` executed if the given function runs first\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n/**Creating new Promises, with a setTimeout of t */\\n        return new Promise((resolve, reject) => {\\n            const timeoutId = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve).catch(reject).finally(()=> clearTimeout(timeoutId));\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n/**Creating new Promises, with a setTimeout of t */\\n        return new Promise((resolve, reject) => {\\n            const timeoutId = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve).catch(reject).finally(()=> clearTimeout(timeoutId));\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3479510,
                "title": "typescript-simple-solution",
                "content": "```typescript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            fn(...args).then(resolve).catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            fn(...args).then(resolve).catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453361,
                "title": "using-simple-then-and-catch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej)=>{\\n            setTimeout(()=>{\\n                rej(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then((r)=>{\\n                res(r)\\n            }).catch((e)=>{\\n                rej(e)\\n            })\\n        })        \\n        \\n\\n\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej)=>{\\n            setTimeout(()=>{\\n                rej(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then((r)=>{\\n                res(r)\\n            }).catch((e)=>{\\n                rej(e)\\n            })\\n        })        \\n        \\n\\n\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3452980,
                "title": "javascript-ez-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timer = setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\');\\n            }, t);\\n            fn(...args).then((result) => {\\n                clearTimeout(timer);\\n                resolve(result);\\n            }).catch((err) => {\\n                clearTimeout(timer);\\n                reject(err);\\n            });\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timer = setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\');\\n            }, t);\\n            fn(...args).then((result) => {\\n                clearTimeout(timer);\\n                resolve(result);\\n            }).catch((err) => {\\n                clearTimeout(timer);\\n                reject(err);\\n            });\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3444251,
                "title": "one-liner",
                "content": "```\\nvar timeLimit = function(f, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([f(...args), new Promise((_, err) => setTimeout(() => err(\"Time Limit Exceeded\"), t))]);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(f, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([f(...args), new Promise((_, err) => setTimeout(() => err(\"Time Limit Exceeded\"), t))]);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3441155,
                "title": "a-bit-better-memory-usage",
                "content": "# Intuition\\nI have to create a function which return first Promise resolve or reject  depends on time limit.\\n\\n# Approach\\nmy aproach is a little different from others. I moved **maxDelay** function to the top of **timeLimit** function because it creates only when we call first time **timelimit** function and we avoid creating **maxDelay** function each call.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nconst timeLimit = (fn, t) => {\\n  const maxDelay = new Promise((_, rj) => setTimeout(() => {\\n    rj(\\'Time Limit Exceeded\\');\\n  }, t));\\n\\treturn async function(...args) {\\n    const res = await Promise.race([fn(...args), maxDelay]);\\n    return res;\\n  }\\n};\\n\\nconst limit = timeLimit(fn, t);\\n// creates maxDelay promise which already have t - time\\nlimit(5);\\n// by calling limit we just wait by method .race which one is faster and return\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst timeLimit = (fn, t) => {\\n  const maxDelay = new Promise((_, rj) => setTimeout(() => {\\n    rj(\\'Time Limit Exceeded\\');\\n  }, t));\\n\\treturn async function(...args) {\\n    const res = await Promise.race([fn(...args), maxDelay]);\\n    return res;\\n  }\\n};\\n\\nconst limit = timeLimit(fn, t);\\n// creates maxDelay promise which already have t - time\\nlimit(5);\\n// by calling limit we just wait by method .race which one is faster and return\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440059,
                "title": "with-arrow-function-and-promise-race-code-is-more-readable",
                "content": "# Approach\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = (fn, t) => (...args) =>\\n    Promise.race([\\n        fn(...args),\\n        new Promise((_, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n    ])\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = (fn, t) => (...args) =>\\n    Promise.race([\\n        fn(...args),\\n        new Promise((_, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n    ])\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3436392,
                "title": "10-short-typesrcipt-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        let rejectPromise = new Promise<any>((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t))\\n        return Promise.race([fn(...args), rejectPromise]); \\n    }\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        let rejectPromise = new Promise<any>((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t))\\n        return Promise.race([fn(...args), rejectPromise]); \\n    }\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433043,
                "title": "javascript-simplest-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let a = fn(...args);\\n        let b = new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\"Time Limit Exceeded\");\\n            },t);\\n        })\\n        return Promise.race([a,b]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let a = fn(...args);\\n        let b = new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\"Time Limit Exceeded\");\\n            },t);\\n        })\\n        return Promise.race([a,b]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1896498,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1862654,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1895484,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1895738,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1965010,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1895562,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1987420,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1941828,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1895951,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            }
        ]
    }
]