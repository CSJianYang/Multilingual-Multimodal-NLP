[
    {
        "title": "Combination Sum",
        "question_content": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n&nbsp;\nExample 1:\n\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\nExample 2:\n\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n\nExample 3:\n\nInput: candidates = [2], target = 1\nOutput: []\n\n&nbsp;\nConstraints:\n\n\t1 <= candidates.length <= 30\n\t2 <= candidates[i] <= 40\n\tAll elements of candidates are distinct.\n\t1 <= target <= 40",
        "solutions": [
            {
                "id": 1777569,
                "title": "full-explanation-with-state-space-tree-recursion-and-backtracking-well-explained-c",
                "content": "Reading the question we understand that we need every possible unique combination such that sum of the combination is equal to target.\\n\\nFor such questions where we have to find **\"every possible\"** we generally use **backtracking**.\\n\\nLet\\'s understand how can backtracking help us achieve what we want here.\\nBelow is an example with a **state space tree** for better understanding of how backtracking will be used in the solution.\\n\\n#### Example (State Space Tree):\\n\\n![image](https://assets.leetcode.com/users/images/a7b5e2bf-f7c5-4e3a-a040-5cb619027830_1645077072.6875963.jpeg)\\n\\nAs you might have noticed that we are not considering the whole array as possible options at every level, because we want **unique combinations**.\\ne.g. at the node **[2, 2, 3]**, the *possible options* for the next level are only *[3, 5]*. Why?? because if we consider the whole array as possible options, then we we will end up with [2, 2, 3, 2] (with 2 as a possible option), which has already been checked as [2, 2, 2, 3] (see the tree). So to *make the solution unique* we are only considering the *part of the array from current last element to the end element* (like in this example).\\n\\n#### Algorithm:\\n```\\n1. If the sum of the current combination is greater than target, then even if we move forward with this combination, the sum will only increase, so there is no fun to moving further with such a combination as we can never achieve the target sum from this. So backtrack from this.\\n2. If the sum of the current combination is equal to the target, then we have a solution, so store this combination in the answers. Now moving forward with this combnation also will only increase the sum and we can\\'t achieve the target sum again from this ever. So backtrack from here.\\n3. if we are here then that means the sum of the combination is still less that the target sum, and we have a scope of finding a combination whose sum can be equal to the target.\\n\\t\\ti) Now consider all possible options into this combination, one at a time.\\n\\t\\tii) Go check if considering the current option can give us the solution.\\n\\t\\tiii) Now when this option backtracks to this place again, now remove this option and try another option. e.g. at [2, 2, _ ] we have 3 options to fill the 3rd place i.e. [2, 3, 5].\\n\\t\\tSo firstly we will go on with [2, 2, 2]. Then when this backtracks to this place again, remove the last 2 and try the next option which is 3 that means [2, 2, 3].\\n\\t\\tWhen this also backtracks remove 3 to try 5, that means [2, 2, 5].\\n\\t\\tNow as all the options are exhausted for [2, 2, _ ], now backtrack to its previous state which is [2, 2], and so on...\\n```\\n\\n#### Code:\\n```cpp\\nclass Solution {\\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\\n        if(currSum>target) return; //backtrack\\n        if(currSum==target){\\n            ans.push_back(currComb); //store the solution and backtrack\\n            return;\\n        }\\n        \\n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\\n            currComb.push_back(candidates[i]); //put 1 option into the combination\\n            currSum+=candidates[i];\\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\\n            currSum-=candidates[i];\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> currComb;\\n        combination(candidates, target, currComb, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n***Plz upvote the post if you like the explanation.***\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. If the sum of the current combination is greater than target, then even if we move forward with this combination, the sum will only increase, so there is no fun to moving further with such a combination as we can never achieve the target sum from this. So backtrack from this.\\n2. If the sum of the current combination is equal to the target, then we have a solution, so store this combination in the answers. Now moving forward with this combnation also will only increase the sum and we can\\'t achieve the target sum again from this ever. So backtrack from here.\\n3. if we are here then that means the sum of the combination is still less that the target sum, and we have a scope of finding a combination whose sum can be equal to the target.\\n\\t\\ti) Now consider all possible options into this combination, one at a time.\\n\\t\\tii) Go check if considering the current option can give us the solution.\\n\\t\\tiii) Now when this option backtracks to this place again, now remove this option and try another option. e.g. at [2, 2, _ ] we have 3 options to fill the 3rd place i.e. [2, 3, 5].\\n\\t\\tSo firstly we will go on with [2, 2, 2]. Then when this backtracks to this place again, remove the last 2 and try the next option which is 3 that means [2, 2, 3].\\n\\t\\tWhen this also backtracks remove 3 to try 5, that means [2, 2, 5].\\n\\t\\tNow as all the options are exhausted for [2, 2, _ ], now backtrack to its previous state which is [2, 2], and so on...\\n```\n```cpp\\nclass Solution {\\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\\n        if(currSum>target) return; //backtrack\\n        if(currSum==target){\\n            ans.push_back(currComb); //store the solution and backtrack\\n            return;\\n        }\\n        \\n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\\n            currComb.push_back(candidates[i]); //put 1 option into the combination\\n            currSum+=candidates[i];\\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\\n            currSum-=candidates[i];\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> currComb;\\n        combination(candidates, target, currComb, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777334,
                "title": "c-detailed-explanation-w-tree-diagram-recursion-backtracking-each-step-explained",
                "content": "***Brief note about Question-***\\n* In simple words, we have to *return all possible combination of array whose sum is equal to a particular target.*\\n```\\nLet\\'s take an example not given in question -\\nSuppose our array is given to us as arr[]: [2, 3] and target as 6\\n\\nThen, all possible combinations of array whose sum is equal to 6 is-\\n[[2,2,2] , [3,3]]\\n\\n```\\n___________________\\n***General discussion on how we devlop approach-***\\n* This was a problem where we have to explore all possibility, make each combination and if sum of a combination becomes equal to target sum then we have to store that possible combination in our answer array.\\n\\n* One more thing we have to notice here is that, **for a particular element we have unlimited choice** i.e we can choose a element as many times as we want.\\n* But their is some restiction also on choosing a number.\\n* See for every number in making our target sum, we have two possibility i.e \\n1) **Whether to include that element in making our target sum**.\\n2) **Whether not to include that element in making our target sum**.\\n* We will try and explore each possible combination and if at a point we got our sum as zero then we will say yeah!!, we find a possible combination and include that combination in our answer.\\n\\n* Suppose if at any point our target sum becomes less than zero, then we will return from that point and will not explore further possibility by saying that, ok our target sum becomes negative that means from now no any combination is possible because we have given a non - negative array.\\n* See below tree diagram for more clarity.\\n_______________________\\n***How Tree diagram will work-***\\n* We will make a `op array`, that contains all the possible combinations sum of the array.\\n* We will start from the `index 0` and as we already discussed that for each and every element we have two possibility whether to include this element in making our answer or not, so we will explore all possibilities.\\n* op aray represents which elements this array contains now in making combination sum.\\n* Target represents the left combination sum that we have to make. Intially it is same as the original target that we have to make.\\n* The red cursor below the array, points that on which index we are currently standing.\\n* If at any point our target becomes zero, then we will include that combination in our answer array saying that yes, this is an possible combination and return from there.\\n* If at any point our target becomes less than zero, then we return from there saying that we are never able to make our cbination sum by this combination.\\n* If at any point we cross the size of the array then we will return from there saying that no more element is left to choose.\\n\\n* As we dicussed for every element we have two choices whether to include in our answer or not include in our answer.\\n* So, if we do not a include a element in our answer then without decreasing target sum, we will move to next index. **Why we do not decrese sum?** because we will choose not to include in this element in our combination, hence it does not contribute in making our sum.\\n* But, if we choose a particular element to include in our answer, then we will decrease the target sum but we will not move to next index. **Why we will not move to next index?** because for a specific element *we have unlimited number of choice*, so it may be possible that specific element again contribute in making our sum.\\n* If Image is not cleary visible to you, then for that I have uploaded it on my drive.\\n* **You may visit this link to see Image in good quality.**\\n* LINK :- [TREE DIAGRAM](https://drive.google.com/file/d/1dIVMnBcSlI0D1ZJRXsHR89WD4ZKZIxh2/view?usp=sharing)\\n_________________________\\n\\n![image](https://assets.leetcode.com/users/images/eb6d1bed-c1d3-4252-9d80-b44eb02a6654_1645069516.057088.jpeg)\\n_________________________\\n***Solution - I (using backtracking, Accepted)-***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // 2 D vector to store our answer\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\\n    {\\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\\n        if(target == 0) \\n        {\\n            ans.push_back(temp); // include that combination in our answer\\n            return; // and then return, we are now not gonna explore more possiblity\\n        }\\n        \\n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\\n        if(target < 0)\\n            return;\\n        \\n        // if index crosses the last index, we will return saying that no more element is left to choosee\\n        if(i == arr.size())\\n            return;\\n        \\n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \\n\\t\\t//so now, we are doing that\\n        \\n        // we are not taking the ith element,\\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\\n        solve(i + 1, arr, temp, target);\\n        \\n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\\n        \\n        temp.push_back(arr[i]); // including ith element\\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\\n        temp.pop_back(); // backtrack\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\\n        \\n        vector<int> temp; // temporary vector that tries all possible combination\\n        \\n        solve(0, arr, temp, target); // calling function, and see we start from index zero\\n        \\n        return ans; // finally return the answer array\\n    }\\n};\\n```\\n______________________\\n***Solution - II (using Recursion, Accepted)-***\\n```\\nclass Solution {\\npublic:\\n    // for the sake of convience, not to include again and again in my function call, I declare target here\\n    int target;\\n    \\n    vector<vector<int>> ans; // 2-D vector to store our answer\\n    \\n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\\n    {\\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\\n        \\n        if(i >= arr.size()) \\n        {\\n            return;\\n        }\\n        \\n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\\n        if(arr[i] + sum == target)\\n        {\\n            op.push_back(arr[i]);\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\\n        if(arr[i] + sum < target)\\n        {\\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\\n            vector<int> op1 = op;\\n            vector<int> op2 = op;\\n            \\n            op2.push_back(arr[i]);\\n            solve(arr, i, sum + arr[i], op2);\\n            solve(arr, i + 1, sum, op1);\\n        }\\n        else\\n        {\\n            solve(arr, i + 1, sum, op); // call for the next index\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\\n        \\n        target = required_target; // give target what he wants \\n        vector<int> op; // op array to try all possible combination\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        solve(arr, 0, 0, op); // call function\\n        \\n        return ans; // return the final answer array\\n    }\\n};\\n```\\n\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our array is given to us as arr[]: [2, 3] and target as 6\\n\\nThen, all possible combinations of array whose sum is equal to 6 is-\\n[[2,2,2] , [3,3]]\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // 2 D vector to store our answer\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\\n    {\\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\\n        if(target == 0) \\n        {\\n            ans.push_back(temp); // include that combination in our answer\\n            return; // and then return, we are now not gonna explore more possiblity\\n        }\\n        \\n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\\n        if(target < 0)\\n            return;\\n        \\n        // if index crosses the last index, we will return saying that no more element is left to choosee\\n        if(i == arr.size())\\n            return;\\n        \\n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \\n\\t\\t//so now, we are doing that\\n        \\n        // we are not taking the ith element,\\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\\n        solve(i + 1, arr, temp, target);\\n        \\n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\\n        \\n        temp.push_back(arr[i]); // including ith element\\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\\n        temp.pop_back(); // backtrack\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\\n        \\n        vector<int> temp; // temporary vector that tries all possible combination\\n        \\n        solve(0, arr, temp, target); // calling function, and see we start from index zero\\n        \\n        return ans; // finally return the answer array\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // for the sake of convience, not to include again and again in my function call, I declare target here\\n    int target;\\n    \\n    vector<vector<int>> ans; // 2-D vector to store our answer\\n    \\n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\\n    {\\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\\n        \\n        if(i >= arr.size()) \\n        {\\n            return;\\n        }\\n        \\n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\\n        if(arr[i] + sum == target)\\n        {\\n            op.push_back(arr[i]);\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\\n        if(arr[i] + sum < target)\\n        {\\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\\n            vector<int> op1 = op;\\n            vector<int> op2 = op;\\n            \\n            op2.push_back(arr[i]);\\n            solve(arr, i, sum + arr[i], op2);\\n            solve(arr, i + 1, sum, op1);\\n        }\\n        else\\n        {\\n            solve(arr, i + 1, sum, op); // call for the next index\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\\n        \\n        target = required_target; // give target what he wants \\n        vector<int> op; // op array to try all possible combination\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        solve(arr, 0, 0, op); // call function\\n        \\n        return ans; // return the final answer array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777135,
                "title": "c-easy-to-understand-backtracking",
                "content": "# 39. Combination Sum\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**EXPLANATION**\\n```\\n1. Sort the vector(non-decreasing).\\n2. First remove all the duplicates from vector.\\n3. Then use recursion and backtracking to solve \\n   the problem.\\n   (A) If at any time sub-problem sum == 0 then \\n       add that vector to the result (vector of \\n       vectors).\\n   (B) Else if sum is negative then ignore that \\n       sub-problem.\\n   (C) Else insert the present index in that \\n       vector to the current vector and call \\n       the function with sum = sum-ar[index] and\\n       index = index, then pop that element from \\n       current index (backtrack) and call the \\n       function with sum = sum and index = index+1\\n```\\n\\n**CODE WITH EXPLANATION**\\n\\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n\\n    void Sum(vector<int>& candidates, int target, vector<vector<int> >& res, vector<int>& r, int i)\\n    {\\n        \\n        if(target == 0)\\n        {\\n            // if we get exact answer\\n            res.push_back(r);\\n            return;\\n        }\\n        \\n        while(i <  candidates.size() && target - candidates[i] >= 0)\\n        {\\n            // Till every element in the array starting\\n            // from i which can contribute to the target\\n            r.push_back(candidates[i]);// add them to vector\\n            \\n            // recur for next numbers\\n            Sum(candidates,target - candidates[i],res,r,i);\\n            ++i;\\n            \\n            // Remove number from vector (backtracking)\\n            r.pop_back();\\n        }\\n}\\n    \\n     \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end()); // sort candidates array\\n        \\n        // remove duplicates\\n        candidates.erase(unique(candidates.begin(),candidates.end()),candidates.end());\\n        \\n        vector<int> r;\\n        vector<vector<int> > res;\\n        \\n        Sum(candidates,target,res,r,0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\n```\\n1. Sort the vector(non-decreasing).\\n2. First remove all the duplicates from vector.\\n3. Then use recursion and backtracking to solve \\n   the problem.\\n   (A) If at any time sub-problem sum == 0 then \\n       add that vector to the result (vector of \\n       vectors).\\n   (B) Else if sum is negative then ignore that \\n       sub-problem.\\n   (C) Else insert the present index in that \\n       vector to the current vector and call \\n       the function with sum = sum-ar[index] and\\n       index = index, then pop that element from \\n       current index (backtrack) and call the \\n       function with sum = sum and index = index+1\\n```\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n\\n    void Sum(vector<int>& candidates, int target, vector<vector<int> >& res, vector<int>& r, int i)\\n    {\\n        \\n        if(target == 0)\\n        {\\n            // if we get exact answer\\n            res.push_back(r);\\n            return;\\n        }\\n        \\n        while(i <  candidates.size() && target - candidates[i] >= 0)\\n        {\\n            // Till every element in the array starting\\n            // from i which can contribute to the target\\n            r.push_back(candidates[i]);// add them to vector\\n            \\n            // recur for next numbers\\n            Sum(candidates,target - candidates[i],res,r,i);\\n            ++i;\\n            \\n            // Remove number from vector (backtracking)\\n            r.pop_back();\\n        }\\n}\\n    \\n     \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end()); // sort candidates array\\n        \\n        // remove duplicates\\n        candidates.erase(unique(candidates.begin(),candidates.end()),candidates.end());\\n        \\n        vector<int> r;\\n        vector<vector<int> > res;\\n        \\n        Sum(candidates,target,res,r,0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16502,
                "title": "a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning",
                "content": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n \\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n \\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "codeTag": "Unknown"
            },
            {
                "id": 16510,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        ret = []\\n        self.dfs(candidates, target, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, path, ret):\\n        if target < 0:\\n            return \\n        if target == 0:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        ret = []\\n        self.dfs(candidates, target, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, path, ret):\\n        if target < 0:\\n            return \\n        if target == 0:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16496,
                "title": "accepted-16ms-c-solution-use-backtracking-easy-understand",
                "content": "Accepted 16ms c++ solution use backtracking for [Combination Sum][1]:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\\n            std::sort(candidates.begin(), candidates.end());\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum(candidates, target, res, combination, 0);\\n            return res;\\n        }\\n    private:\\n        void combinationSum(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n            if (!target) {\\n                res.push_back(combination);\\n                return;\\n            }\\n            for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {\\n                combination.push_back(candidates[i]);\\n                combinationSum(candidates, target - candidates[i], res, combination, i);\\n                combination.pop_back();\\n            }\\n        }\\n    };\\n\\nAccepted 12ms c++ solution use backtracking for [Combination Sum II][2]:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum2(std::vector<int> &candidates, int target) {\\n            std::sort(candidates.begin(), candidates.end());\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum2(candidates, target, res, combination, 0);\\n            return res;\\n        }\\n    private:\\n        void combinationSum2(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n            if (!target) {\\n                res.push_back(combination);\\n                return;\\n            }\\n            for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i)\\n                if (i == begin || candidates[i] != candidates[i - 1]) {\\n                    combination.push_back(candidates[i]);\\n                    combinationSum2(candidates, target - candidates[i], res, combination, i + 1);\\n                    combination.pop_back();\\n                }\\n        }\\n    };\\n\\nAccepted 0ms c++ solution use backtracking for [Combination Sum III][3]:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum3(int k, int n) {\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum3(n, res, combination, 1, k);\\n            return res;\\n        }\\n    private:\\n        void combinationSum3(int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin, int need) {\\n            if (!target) {\\n                res.push_back(combination);\\n                return;\\n            }\\n            else if (!need)\\n                return;\\n            for (int i = begin; i != 10 && target >= i * need + need * (need - 1) / 2; ++i) {\\n                combination.push_back(i);\\n                combinationSum3(target - i, res, combination, i + 1, need - 1);\\n                combination.pop_back();\\n            }\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/problems/combination-sum/\\n  [2]: https://leetcode.com/problems/combination-sum-ii/\\n  [3]: https://leetcode.com/problems/combination-sum-iii/",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\\n            std::sort(candidates.begin(), candidates.end());\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum(candidates, target, res, combination, 0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 429538,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16509,
                "title": "iterative-java-dp-solution",
                "content": "Hi guys!\\n\\nThe main idea reminds an approach for solving coins/knapsack problem - to store the result for all i < target and create the solution from them. For that for each t from 1 to our target we try every candidate which is less or equal to t in ascending order. For each candidate \"c\" we run through all combinations for target t-c starting with the value greater or equal than c to avoid duplicates and store only ordered combinations. \\n\\n    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] cands, int t) {\\n            Arrays.sort(cands); // sort candidates to try them in asc order\\n            List<List<List<Integer>>> dp = new ArrayList<>();\\n            for (int i = 1; i <= t; i++) { // run through all targets from 1 to t\\n                List<List<Integer>> newList = new ArrayList(); // combs for curr i\\n                // run through all candidates <= i\\n                for (int j = 0; j < cands.length && cands[j] <= i; j++) {\\n                    // special case when curr target is equal to curr candidate\\n                    if (i == cands[j]) newList.add(Arrays.asList(cands[j]));\\n                    // if current candidate is less than the target use prev results\\n                    else for (List<Integer> l : dp.get(i-cands[j]-1)) {\\n                        if (cands[j] <= l.get(0)) {\\n                            List cl = new ArrayList<>();\\n                            cl.add(cands[j]); cl.addAll(l);\\n                            newList.add(cl);\\n                        }\\n                    }\\n                }\\n                dp.add(newList);\\n            }\\n            return dp.get(t-1);\\n        }\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum(int[] cands, int t) {\\n            Arrays.sort(cands); // sort candidates to try them in asc order\\n            List<List<List<Integer>>> dp = new ArrayList<>();\\n            for (int i = 1; i <= t; i++) { // run through all targets from 1 to t\\n                List<List<Integer>> newList = new ArrayList(); // combs for curr i\\n                // run through all candidates <= i\\n                for (int j = 0; j < cands.length && cands[j] <= i; j++) {\\n                    // special case when curr target is equal to curr candidate\\n                    if (i == cands[j]) newList.add(Arrays.asList(cands[j]));\\n                    // if current candidate is less than the target use prev results\\n                    else for (List<Integer> l : dp.get(i-cands[j]-1)) {\\n                        if (cands[j] <= l.get(0)) {\\n                            List cl = new ArrayList<>();\\n                            cl.add(cands[j]); cl.addAll(l);\\n                            newList.add(cl);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 786891,
                "title": "c-two-differnt-aproch-easy-to-understand-with-comment",
                "content": "**Plz upvote my solution if you like it**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n\\t//global values shared between both function\\n    vector<vector<int>>result;\\n    vector<int>current;\\n    int sum;\\n    \\n    void function(vector<int>& candidates,int target,int index)\\n    {\\n        if(sum>target)return ;//base case if sum is greater then target then return \\n        \\n        if(sum==target){\\n            result.push_back(current);//id sum is equal to target then just add current to result\\n        }\\n        for(int i=index;i<candidates.size();i++){\\n            sum+=candidates[i];//and current value to sum\\n            current.push_back(candidates[i]);//and current value to current vector\\n            function(candidates,target,i);//again reccure for same index i\\n            sum-=candidates[i];//back track mean remove value that previously added\\n            current.pop_back();//remove the value that previously added to current \\n        }      \\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sum=0; // This sum is global you can see it on the top of code just a clarify if you have any doubt\\n        function(candidates,target,0);//i make result current and sum global to reduce the size of function for simplecity\\n        return result;//This result is also global \\n    }\\n};\\n\\'\\'\\'\\nNow second approch is bit tricky you have to be bit carefull or you can solve this approch using pen and paper \\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>>result;\\n    vector<int>current;\\n    \\n    void function(vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            result.push_back(current);\\n            return;\\n        }\\n        \\n        if(index==candidates.size() || target<0)return;\\n        \\n        current.push_back(candidates[index]);\\n        function(candidates,target-candidates[index],index);\\n        current.pop_back();\\n        function(candidates,target,index+1);      \\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        function(candidates,target,0);\\n        return result;\\n    }\\n};\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\t//global values shared between both function\\n    vector<vector<int>>result;\\n    vector<int>current;\\n    int sum;\\n    \\n    void function(vector<int>& candidates,int target,int index)\\n    {\\n        if(sum>target)return ;//base case if sum is greater then target then return \\n        \\n        if(sum==target){\\n            result.push_back(current);//id sum is equal to target then just add current to result\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 937255,
                "title": "python-3-dfs-backtracking-two-dp-methods-explanations",
                "content": "### Approach \\\\#1. DFS (Backtracking)\\n- Straight forward backtracking\\n- `cur`: current combination, `cur_sum` current combination sum, `idx` index current at (to avoid repeats)\\n- Time complexity: `O(N^(M/min_cand + 1))`, `N = len(candidates)`, `M = target`, `min_cand = min(candidates)`\\n- Space complexity: `O(M/min_cand)`\\n<iframe src=\"https://leetcode.com/playground/fwFMybYZ/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n\\n### Approach \\\\#2. DP (Slow)\\n- Read comment for more detail\\n- Time Complexity: `O(M*M*M*N)`, `N = len(candidates)`, `M = target`\\n- Space Complexity: `O(M*M)`\\n<iframe src=\"https://leetcode.com/playground/Qw6fiSbh/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n\\n### Approach \\\\#3. DP (Fast)\\n- Read comment for more detail\\n- Time Complexity: `O(M*M*N)`, `N = len(candidates)`, `M = target`\\n- Space Complexity: `O(M*M)`\\n<iframe src=\"https://leetcode.com/playground/d2qASVHs/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "### Approach \\\\#1. DFS (Backtracking)\\n- Straight forward backtracking\\n- `cur`: current combination, `cur_sum` current combination sum, `idx` index current at (to avoid repeats)\\n- Time complexity: `O(N^(M/min_cand + 1))`, `N = len(candidates)`, `M = target`, `min_cand = min(candidates)`\\n- Space complexity: `O(M/min_cand)`\\n<iframe src=\"https://leetcode.com/playground/fwFMybYZ/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n\\n### Approach \\\\#2. DP (Slow)\\n- Read comment for more detail\\n- Time Complexity: `O(M*M*M*N)`, `N = len(candidates)`, `M = target`\\n- Space Complexity: `O(M*M)`\\n<iframe src=\"https://leetcode.com/playground/Qw6fiSbh/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n\\n### Approach \\\\#3. DP (Fast)\\n- Read comment for more detail\\n- Time Complexity: `O(M*M*N)`, `N = len(candidates)`, `M = target`\\n- Space Complexity: `O(M*M)`\\n<iframe src=\"https://leetcode.com/playground/d2qASVHs/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 16521,
                "title": "java-solution-using-recursive",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        \\tArrays.sort(candidates);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            getResult(result, new ArrayList<Integer>(), candidates, target, 0);\\n            \\n            return result;\\n        }\\n        \\n        private void getResult(List<List<Integer>> result, List<Integer> cur, int candidates[], int target, int start){\\n        \\tif(target > 0){\\n        \\t\\tfor(int i = start; i < candidates.length && target >= candidates[i]; i++){\\n        \\t\\t\\tcur.add(candidates[i]);\\n        \\t\\t\\tgetResult(result, cur, candidates, target - candidates[i], i);\\n        \\t\\t\\tcur.remove(cur.size() - 1);\\n        \\t\\t}//for\\n        \\t}//if\\n        \\telse if(target == 0 ){\\n        \\t\\tresult.add(new ArrayList<Integer>(cur));\\n        \\t}//else if\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        \\tArrays.sort(candidates);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            getResult(result, new ArrayList<Integer>(), candidates, target, 0);\\n            \\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1755084,
                "title": "detailed-time-and-space-complexity-analysis-c-java-backtracking",
                "content": "**Time Complexity** - O(2^k) where k is the sum of target/candidate[i] from i = 0 to size of candidate - 1.\\n**Note-** *the time complexity of pushing cur into res is len_of_cur, so we can say TC - O( len_of_cur\\xD72^k)*\\n**Auxillary Space Complexity** - O(length_of_longest_combination).\\n\\n**Detailed explanation for time and auxillary space complexity** \\n\\n**Note-** *the space complexity i mentioned is the auxillary space complexity i.e. recursive stack space*\\n![image](https://assets.leetcode.com/users/images/72c0a206-7a8a-4109-95be-aea3ad7298e5_1644313045.9214947.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/725c0db0-a479-4412-aa89-6ad7965cde0b_1644409701.0079207.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/a11a8b81-ae82-478d-a99a-21c035fb1493_1644409707.9676895.jpeg)\\n\\n\\n\\n**C++ and Java Codes -**\\n<iframe src=\"https://leetcode.com/playground/kgQe9ngW/shared\" frameBorder=\"0\" width=\"1090\" height=\"430\"></iframe>",
                "solutionTags": [
                    "Java",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "**Time Complexity** - O(2^k) where k is the sum of target/candidate[i] from i = 0 to size of candidate - 1.\\n**Note-** *the time complexity of pushing cur into res is len_of_cur, so we can say TC - O( len_of_cur\\xD72^k)*\\n**Auxillary Space Complexity** - O(length_of_longest_combination).\\n\\n**Detailed explanation for time and auxillary space complexity** \\n\\n**Note-** *the space complexity i mentioned is the auxillary space complexity i.e. recursive stack space*\\n![image](https://assets.leetcode.com/users/images/72c0a206-7a8a-4109-95be-aea3ad7298e5_1644313045.9214947.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/725c0db0-a479-4412-aa89-6ad7965cde0b_1644409701.0079207.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/a11a8b81-ae82-478d-a99a-21c035fb1493_1644409707.9676895.jpeg)\\n\\n\\n\\n**C++ and Java Codes -**\\n<iframe src=\"https://leetcode.com/playground/kgQe9ngW/shared\" frameBorder=\"0\" width=\"1090\" height=\"430\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 16554,
                "title": "share-my-python-solution-beating-98-17",
                "content": "    class Solution(object):\\n    def combinationSum(self, candidates, target):\\n        result = []\\n        candidates = sorted(candidates)\\n        def dfs(remain, stack):\\n            if remain == 0:\\n                result.append(stack)\\n                return \\n\\n            for item in candidates:\\n                if item > remain: break\\n                if stack and item < stack[-1]: continue\\n                else:\\n                    dfs(remain - item, stack + [item])\\n        \\n        dfs(target, [])\\n        return result",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "    class Solution(object):\\n    def combinationSum(self, candidates, target):\\n        result = []\\n        candidates = sorted(candidates)\\n        def dfs(remain, stack):\\n            if remain == 0:\\n                result.append(stack)\\n                return \\n\\n            for item in candidates:\\n                if item > remain: break\\n                if stack and item < stack[-1]: continue\\n                else:\\n                    dfs(remain - item, stack + [item])\\n        \\n        dfs(target, [])\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 1103237,
                "title": "c-best-and-easy-dp-solution",
                "content": "Similar idea from the problem [coin-change-2](https://leetcode.com/problems/coin-change-2/) .\\nit is simplest and fastest dp solution, we don\\'t need to sort elements \\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n\\t\\t// dp vector to store all possible combinations of the target sum\\n        vector <vector <vector <int>>> dp(target+1);\\n        dp[0]={{}};\\n        for(int &i:nums)\\n        {\\n\\t\\t// Iterating through all the elements from array nums aka candidates\\n            for(int j=i;j<=target;j++)\\n            {\\n\\t\\t\\t// Finding all possible ways to achieve sum j from element i\\n                for(auto v:dp[j-i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n\\t\\t// Finally, returning our ans \\uD83D\\uDE43\\n        return dp[target];\\n    }\\n};\\n```\\nIf you liked this solution please upvote\\uD83D\\uDE4F if you have any query plz comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n\\t\\t// dp vector to store all possible combinations of the target sum\\n        vector <vector <vector <int>>> dp(target+1);\\n        dp[0]={{}};\\n        for(int &i:nums)\\n        {\\n\\t\\t// Iterating through all the elements from array nums aka candidates\\n            for(int j=i;j<=target;j++)\\n            {\\n\\t\\t\\t// Finding all possible ways to achieve sum j from element i\\n                for(auto v:dp[j-i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n\\t\\t// Finally, returning our ans \\uD83D\\uDE43\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875097,
                "title": "python-bactracking-solution-explained",
                "content": "This is classical backtracking problem, so let us use `BackTr(target, curr_sol, k)` function, where:\\n\\n1. `target` is target we need to build, if we get some number, we subtract if from target.\\n2. `curr_sol` is current solution built so far.\\n3. `k` is index in our `candidates`: each new number we take should have number more or equal than `k`.\\n\\nSo, no in algorighm we do:\\n1. If `target == 0`, it means we found solution, which is kept in `curr_sol`, so we add it to `self.sol` list of all found solutions.\\n2. If `target` if negative or `k` is more than number of candidates, we need to go back.\\n3. Finally, for each candidate index in `k,...`, we run our function recursively with updated parameters.\\n\\n**Complexity**: TBD\\n\\n```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        def BackTr(target, curr_sol, k):  \\n            if target == 0:\\n                self.sol.append(curr_sol)\\n\\n            if target < 0 or k >= len(candidates):\\n                return\\n\\n            for i in range(k, len(candidates)):\\n                BackTr(target - candidates[i], curr_sol + [candidates[i]], i)\\n        \\n        self.sol = []\\n        BackTr(target, [], 0)   \\n        return self.sol\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        def BackTr(target, curr_sol, k):  \\n            if target == 0:\\n                self.sol.append(curr_sol)\\n\\n            if target < 0 or k >= len(candidates):\\n                return\\n\\n            for i in range(k, len(candidates)):\\n                BackTr(target - candidates[i], curr_sol + [candidates[i]], i)\\n        \\n        self.sol = []\\n        BackTr(target, [], 0)   \\n        return self.sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752444,
                "title": "python-clear-explanation-and-intuition-using-combination-with-backtracking-solution",
                "content": "Here is a my backtracking-based solution. \\nTo fully understand the intuition behind my solution, I will first explaination how we implement combination using backtracking.\\n\\n### Combination\\n\\nTo get all combinations of length 2 from `[1,2,3]`\\n![image](https://assets.leetcode.com/users/images/941d85bd-dab4-4b09-a6d4-5e0e0aca94fc_1595578055.3871193.png)\\n\\n* We dont append the `1` to `[2]` because `[1, 2]` and `[2, 1]` are the same\\n* Same appies to `[3]`\\n\\n### Implementing combinations of sub array with target length\\n```\\nresults = []\\ntarget_length = 2\\narr = [1,2,3]\\n\\ndef combination(i, path):\\n\\n\\t# we have found our answer, lets return. Any code below this statement wont get executed and the recursion stops.\\n\\tif len(path) == target_length:\\n\\t\\tresults.append(path[:])\\n\\t\\treturn\\n\\n\\t# With each iteration of the for loop, we will reduce the number of candidates - [1, 2, 3] , [2, 3] , [3]\\n\\t# This is important to prevent duplicates. \\n\\tfor x in range(i, len(arr)):\\n\\t\\t# lets keep adding to path. \\t\\n\\t\\tpath.append(arr[x])\\n\\n\\t\\t# lets run combination again, if the path is not our target length, it will go to the for loop again.\\n\\t   combination(x, path)\\n\\n\\t   # backtrack, remove my last element, so i can move on .\\n\\t   path.pop()\\n   \\ncombination(0, [])\\n\\nassert combinations == [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]]\\n```\\n\\nNow instead of just finding combinations of a certain length, we replace the termination statement\\n*combination of k length*\\n\\n```\\n\\tif len(path) == target_length:\\n\\t\\tresults.append(path[:])\\n\\t\\treturn\\n```\\n\\nto \\n*combination of target sum*\\n\\n```\\n\\t\\t# termination 1. The sum is the target. stop recursion\\n\\t\\tif sum(path) == target:\\n\\t\\t\\tresults.append(path[:])\\n\\t\\t\\treturn \\n\\n\\t\\t# termination 2 (The sum is greater than the target). stop recursion\\n\\t\\tif sum(path) > target:\\n\\t\\t\\treturn \\n\\n```\\n\\n### Solution to combination sum.\\n\\nTherefore the solution to the problem is:\\n\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        results = []\\n        def helper(i, path):\\n            # endpoint 1 (we found a matching target)\\n            if sum(path) == target:\\n                results.append(path[:])\\n                return \\n\\t\\t\\t\\n\\t\\t\\t# endpoint 2 (The sum is greater than the target)\\n            if sum(path) > target:\\n                return \\n\\t\\t\\t\\n            for x in range(i, len(candidates)):\\n                path.append(candidates[x])\\n                helper(x, path)\\n                path.pop()\\n\\n        helper(0, [])\\n        return results\\n```\\t\\t\\n\\n### What you can do to understand the implementation better.\\n\\n1 . You can try not doing the backtracking step `path.pop()` and see how that affect the results.\\n2. You can print the `path` value in under the for loop.\\n\\n### Conclusion\\n\\nUsing backtracking to solve combinations problem can be easy once you figure out where and how to terminate.\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Combinatorics"
                ],
                "code": "```\\nresults = []\\ntarget_length = 2\\narr = [1,2,3]\\n\\ndef combination(i, path):\\n\\n\\t# we have found our answer, lets return. Any code below this statement wont get executed and the recursion stops.\\n\\tif len(path) == target_length:\\n\\t\\tresults.append(path[:])\\n\\t\\treturn\\n\\n\\t# With each iteration of the for loop, we will reduce the number of candidates - [1, 2, 3] , [2, 3] , [3]\\n\\t# This is important to prevent duplicates. \\n\\tfor x in range(i, len(arr)):\\n\\t\\t# lets keep adding to path. \\t\\n\\t\\tpath.append(arr[x])\\n\\n\\t\\t# lets run combination again, if the path is not our target length, it will go to the for loop again.\\n\\t   combination(x, path)\\n\\n\\t   # backtrack, remove my last element, so i can move on .\\n\\t   path.pop()\\n   \\ncombination(0, [])\\n\\nassert combinations == [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]]\\n```\n```\\n\\tif len(path) == target_length:\\n\\t\\tresults.append(path[:])\\n\\t\\treturn\\n```\n```\\n\\t\\t# termination 1. The sum is the target. stop recursion\\n\\t\\tif sum(path) == target:\\n\\t\\t\\tresults.append(path[:])\\n\\t\\t\\treturn \\n\\n\\t\\t# termination 2 (The sum is greater than the target). stop recursion\\n\\t\\tif sum(path) > target:\\n\\t\\t\\treturn \\n\\n```\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        results = []\\n        def helper(i, path):\\n            # endpoint 1 (we found a matching target)\\n            if sum(path) == target:\\n                results.append(path[:])\\n                return \\n\\t\\t\\t\\n\\t\\t\\t# endpoint 2 (The sum is greater than the target)\\n            if sum(path) > target:\\n                return \\n\\t\\t\\t\\n            for x in range(i, len(candidates)):\\n                path.append(candidates[x])\\n                helper(x, path)\\n                path.pop()\\n\\n        helper(0, [])\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875365,
                "title": "java-python-backtracking-clean-concise-very-fast-2ms",
                "content": "**Python ~ 32ms**\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()  # sort to terminate early when target < 0\\n        \\n        def backtracking(i, target, path):\\n            if target == 0:\\n                ans.append(path)\\n                return\\n            if i == len(candidates) or target < candidates[i]:\\n                return\\n            backtracking(i, target - candidates[i], path + [candidates[i]]) # Choose ith candidate\\n            backtracking(i + 1, target, path) # Skip ith candidate\\n        \\n        ans = []\\n        backtracking(0, target, [])\\n        return ans\\n```\\n\\n**Java ~ 2ms**\\n```java\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates); // sort to terminate early when target < 0\\n        backtracking(0, target, candidates, new LinkedList<>());\\n        return ans;\\n    }\\n    void backtracking(int i, int target, int[] candidates, LinkedList<Integer> path) {\\n        if (target == 0) {\\n            ans.add((List<Integer>) path.clone());\\n            return;\\n        }\\n        if (i == candidates.length || target < candidates[i]) return;\\n        \\n        path.addLast(candidates[i]);\\n        backtracking(i, target - candidates[i], candidates, path); // Choose ith candidate\\n        path.removeLast();\\n        \\n        backtracking(i + 1, target, candidates, path); // Skip ith candidate\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()  # sort to terminate early when target < 0\\n        \\n        def backtracking(i, target, path):\\n            if target == 0:\\n                ans.append(path)\\n                return\\n            if i == len(candidates) or target < candidates[i]:\\n                return\\n            backtracking(i, target - candidates[i], path + [candidates[i]]) # Choose ith candidate\\n            backtracking(i + 1, target, path) # Skip ith candidate\\n        \\n        ans = []\\n        backtracking(0, target, [])\\n        return ans\\n```\n```java\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates); // sort to terminate early when target < 0\\n        backtracking(0, target, candidates, new LinkedList<>());\\n        return ans;\\n    }\\n    void backtracking(int i, int target, int[] candidates, LinkedList<Integer> path) {\\n        if (target == 0) {\\n            ans.add((List<Integer>) path.clone());\\n            return;\\n        }\\n        if (i == candidates.length || target < candidates[i]) return;\\n        \\n        path.addLast(candidates[i]);\\n        backtracking(i, target - candidates[i], candidates, path); // Choose ith candidate\\n        path.removeLast();\\n        \\n        backtracking(i + 1, target, candidates, path); // Skip ith candidate\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16530,
                "title": "concise-backtracking-solution",
                "content": "We backtrack from successful searches as well because they are saved at the leafs of recursion tree\\n\\n    class Solution {\\n    public:\\n    \\n        void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n        {\\n            if(target == 0)\\n            {\\n                result.push_back(pSol);\\n                return;\\n            }\\n            \\n            if(next == num.size() || target - num[next] < 0)\\n                return;\\n                \\n            pSol.push_back(num[next]);\\n            search(num, next, pSol, target - num[next], result);\\n            pSol.pop_back();\\n            \\n            search(num, next + 1, pSol, target, result);\\n        }\\n    \\n        \\n        vector<vector<int> > combinationSum(vector<int> &num, int target) \\n        {\\n            vector<vector<int> > result;\\n            sort(num.begin(), num.end());\\n            vector<int> pSol;\\n            search(num, 0, pSol, target, result);\\n            return result;    \\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n    \\n        void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n        {\\n            if(target == 0)\\n            {\\n                result.push_back(pSol);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1778054,
                "title": "python-short-and-clean-solution-explained",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        self.ans = []                                   # for adding all the answers\\n        def traverse(candid, arr,sm):                   # arr : an array that contains the accused combination; sm : is the sum of all elements of arr \\n            if sm == target: self.ans.append(arr)       # If sum is equal to target then you know it, I know it, what to do\\n            if sm >= target: return                     # If sum is greater than target then no need to move further.\\n            for i in range(len(candid)):                # we will traverse each element from the array.\\n                traverse(candid[i:], arr + [candid[i]], sm+candid[i])   #most important, splice the array including the current index, splicing in order to handle the duplicates.\\n        traverse(candidates,[], 0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        self.ans = []                                   # for adding all the answers\\n        def traverse(candid, arr,sm):                   # arr : an array that contains the accused combination; sm : is the sum of all elements of arr \\n            if sm == target: self.ans.append(arr)       # If sum is equal to target then you know it, I know it, what to do\\n            if sm >= target: return                     # If sum is greater than target then no need to move further.\\n            for i in range(len(candid)):                # we will traverse each element from the array.\\n                traverse(candid[i:], arr + [candid[i]], sm+candid[i])   #most important, splice the array including the current index, splicing in order to handle the duplicates.\\n        traverse(candidates,[], 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16757,
                "title": "javascript-solution-with-backtracking",
                "content": "```js\\nfunction combinationSum(candidates, target) {\\n  var buffer = [];\\n  var result = [];\\n  search(0, target);\\n  return result;\\n\\n  function search(startIdx, target) {\\n    if (target === 0) return result.push(buffer.slice());\\n    if (target < 0) return;\\n    if (startIdx === candidates.length) return;\\n    buffer.push(candidates[startIdx]);\\n    search(startIdx, target - candidates[startIdx]);\\n    buffer.pop();\\n    search(startIdx + 1, target);\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```js\\nfunction combinationSum(candidates, target) {\\n  var buffer = [];\\n  var result = [];\\n  search(0, target);\\n  return result;\\n\\n  function search(startIdx, target) {\\n    if (target === 0) return result.push(buffer.slice());\\n    if (target < 0) return;\\n    if (startIdx === candidates.length) return;\\n    buffer.push(candidates[startIdx]);\\n    search(startIdx, target - candidates[startIdx]);\\n    buffer.pop();\\n    search(startIdx + 1, target);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351862,
                "title": "solution-swift-combination-sum-test-cases",
                "content": "```swift\\nclass Solution {\\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var comb: [Int] = [], uniqs: [[Int]] = []\\n        dfs(&uniqs, &comb, candidates.sorted(), target, 0)\\n        return uniqs\\n    }\\n    \\n    private func dfs(_ uniq: inout [[Int]], _ comb: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int) {\\n        guard t > 0 else { uniq.append(comb); return }\\n        for i in idx..<cands.count where cands[i] <= t {\\n            comb.append(cands[i])\\n            dfs(&uniq, &comb, cands, t - cands[i], i)\\n            comb.removeLast()\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 5 tests, with 0 failures (0 unexpected) in 0.039 (0.041) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\\n    /// 7 is a candidate, and 7 = 7.\\n    /// These are the only two combinations.\\n    func test0() {\\n        let value = solution.combinationSum([2,3,6,7], 7)\\n        XCTAssertEqual(value, [[2,2,3],[7]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum([2,3,5], 8)\\n        XCTAssertEqual(value, [[2,2,2,2],[2,3,3],[3,5]])\\n    }\\n    func test2() {\\n        let value = solution.combinationSum([2], 1)\\n        XCTAssertEqual(value, [])\\n    }\\n    func test3() {\\n        let value = solution.combinationSum([1], 1)\\n        XCTAssertEqual(value, [[1]])\\n    }\\n    func test4() {\\n        let value = solution.combinationSum([1], 2)\\n        XCTAssertEqual(value, [[1,1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var comb: [Int] = [], uniqs: [[Int]] = []\\n        dfs(&uniqs, &comb, candidates.sorted(), target, 0)\\n        return uniqs\\n    }\\n    \\n    private func dfs(_ uniq: inout [[Int]], _ comb: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int) {\\n        guard t > 0 else { uniq.append(comb); return }\\n        for i in idx..<cands.count where cands[i] <= t {\\n            comb.append(cands[i])\\n            dfs(&uniq, &comb, cands, t - cands[i], i)\\n            comb.removeLast()\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\\n    /// 7 is a candidate, and 7 = 7.\\n    /// These are the only two combinations.\\n    func test0() {\\n        let value = solution.combinationSum([2,3,6,7], 7)\\n        XCTAssertEqual(value, [[2,2,3],[7]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum([2,3,5], 8)\\n        XCTAssertEqual(value, [[2,2,2,2],[2,3,3],[3,5]])\\n    }\\n    func test2() {\\n        let value = solution.combinationSum([2], 1)\\n        XCTAssertEqual(value, [])\\n    }\\n    func test3() {\\n        let value = solution.combinationSum([1], 1)\\n        XCTAssertEqual(value, [[1]])\\n    }\\n    func test4() {\\n        let value = solution.combinationSum([1], 2)\\n        XCTAssertEqual(value, [[1,1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16713,
                "title": "a-solution-avoid-using-set",
                "content": "Sort the candidates and we choose from small to large recursively, every time we add a candidate to our possible sub result, we subtract the target to a new smaller one.\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ret = new LinkedList<List<Integer>>();\\n        Arrays.sort(candidates); // sort the candidates\\n        // collect possible candidates from small to large to eliminate duplicates,\\n        recurse(new ArrayList<Integer>(), target, candidates, 0, ret);\\n        return ret;\\n    }\\n    \\n    // the index here means we are allowed to choose candidates from that index\\n    private void recurse(List<Integer> list, int target, int[] candidates, int index, List<List<Integer>> ret) {\\n        if (target == 0) {\\n            ret.add(list);\\n            return;\\n        }\\n        for (int i = index; i < candidates.length; i++) {\\n            int newTarget = target - candidates[i];\\n            if (newTarget >= 0) {\\n                List<Integer> copy = new ArrayList<Integer>(list);\\n                copy.add(candidates[i]);\\n                recurse(copy, newTarget, candidates, i, ret);\\n            } else {\\n                break;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "Sort the candidates and we choose from small to large recursively, every time we add a candidate to our possible sub result, we subtract the target to a new smaller one.\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ret = new LinkedList<List<Integer>>();\\n        Arrays.sort(candidates); // sort the candidates\\n        // collect possible candidates from small to large to eliminate duplicates,\\n        recurse(new ArrayList<Integer>(), target, candidates, 0, ret);\\n        return ret;\\n    }\\n    \\n    // the index here means we are allowed to choose candidates from that index\\n    private void recurse(List<Integer> list, int target, int[] candidates, int index, List<List<Integer>> ret) {\\n        if (target == 0) {\\n            ret.add(list);\\n            return;\\n        }\\n        for (int i = index; i < candidates.length; i++) {\\n            int newTarget = target - candidates[i];\\n            if (newTarget >= 0) {\\n                List<Integer> copy = new ArrayList<Integer>(list);\\n                copy.add(candidates[i]);\\n                recurse(copy, newTarget, candidates, i, ret);\\n            } else {\\n                break;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 662307,
                "title": "javascript-clean-backtracking-solution",
                "content": "```javascript\\nvar combinationSum = function(candidates, target) {\\n    const result = [];\\n    \\n    function permute(arr=[], sum=0, idx=0) {\\n        if(sum > target) return;\\n        if(sum === target) result.push(arr);\\n        \\n        for(let i = idx; i < candidates.length; i++) {\\n            permute([...arr, candidates[i]], sum+candidates[i], i);\\n        }\\n    }\\n    permute()\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```javascript\\nvar combinationSum = function(candidates, target) {\\n    const result = [];\\n    \\n    function permute(arr=[], sum=0, idx=0) {\\n        if(sum > target) return;\\n        if(sum === target) result.push(arr);\\n        \\n        for(let i = idx; i < candidates.length; i++) {\\n            permute([...arr, candidates[i]], sum+candidates[i], i);\\n        }\\n    }\\n    permute()\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378325,
                "title": "javascript-solution-with-detailed-explanation",
                "content": "This is a question of backtracking and recursion and we got to this conclusion by following points\\n1.The question states we can use same number multiple times so we can think that \\n    it will take use of recursion \\n2.We need to find all possible unique combination of numbers that will result to our target to this should\\tmake us think it will use backtracking too\\n\\nSolution approach\\n1.We will take use of a backtracking recursive function which will take input as index, target and a temperory data structure(in this question stack will be suitable).\\n2.We already initialised the index because we wanna/may use it many times so intialising index outside the loop will be helpful\\n3.Target is our target that we want to achieve\\n4.Temperory data structure will store our combinations i.e numbers that may result to our target\\n5.The loop will start with index and end on our last index as obvious\\n6.We will add the current number to our temp DS and substract it from target\\n7.If our target is still not equal to zero i.e we still have some target to achieve\\n8.So we will keep on calling backtracking function and substraction the number from target to see if its zero or not\\n9.If it becomes zero then we achieved our target and we will push the temp DS values in the result as temp DS was storing the values which together resulted to our target\\n10.If we reached somewhere lower than zero that means our sum became greater than our target so we cannot take that number that made our sum greater than target\\n11.So we will return from their and because we are in a for loop after returning we will add next number of \"candidates array\" to our temperory datastructure and start backtracking recursion again\\n12.Make sure to remove the element from our temp DS because of which our sum became greater than our target\\n\\nIn general we can say this question is alll about selecting and not-selecting an element . We select an element if we haven\\'t reached our target\\nWe remove element from temp DS or don\\'t select an element if we go beyond our target\\n\\n    var combinationSum = function(candidates, target) {\\n        let index = 0\\n        let tempDataStruct = []\\n        let result = []\\n    \\n        function backtracking(index, target, tempDataStruct) {\\n            if(target === 0) {\\n                result.push([...tempDataStruct])\\n                return\\n            }\\n        \\n            if(target < 0) return;\\n        \\n            for(let i=index; i<candidates.length; i++) {\\n                tempDataStruct.push(candidates[i])\\n                backtracking(i, target-candidates[i], tempDataStruct)\\n                tempDataStruct.pop()\\n            }\\n        }\\n        backtracking(index, target, tempDataStruct)\\n        return result;\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "This is a question of backtracking and recursion and we got to this conclusion by following points\\n1.The question states we can use same number multiple times so we can think that \\n    it will take use of recursion \\n2.We need to find all possible unique combination of numbers that will result to our target to this should\\tmake us think it will use backtracking too\\n\\nSolution approach\\n1.We will take use of a backtracking recursive function which will take input as index, target and a temperory data structure(in this question stack will be suitable).\\n2.We already initialised the index because we wanna/may use it many times so intialising index outside the loop will be helpful\\n3.Target is our target that we want to achieve\\n4.Temperory data structure will store our combinations i.e numbers that may result to our target\\n5.The loop will start with index and end on our last index as obvious\\n6.We will add the current number to our temp DS and substract it from target\\n7.If our target is still not equal to zero i.e we still have some target to achieve\\n8.So we will keep on calling backtracking function and substraction the number from target to see if its zero or not\\n9.If it becomes zero then we achieved our target and we will push the temp DS values in the result as temp DS was storing the values which together resulted to our target\\n10.If we reached somewhere lower than zero that means our sum became greater than our target so we cannot take that number that made our sum greater than target\\n11.So we will return from their and because we are in a for loop after returning we will add next number of \"candidates array\" to our temperory datastructure and start backtracking recursion again\\n12.Make sure to remove the element from our temp DS because of which our sum became greater than our target\\n\\nIn general we can say this question is alll about selecting and not-selecting an element . We select an element if we haven\\'t reached our target\\nWe remove element from temp DS or don\\'t select an element if we go beyond our target\\n\\n    var combinationSum = function(candidates, target) {\\n        let index = 0\\n        let tempDataStruct = []\\n        let result = []\\n    \\n        function backtracking(index, target, tempDataStruct) {\\n            if(target === 0) {\\n                result.push([...tempDataStruct])\\n                return\\n            }\\n        \\n            if(target < 0) return;\\n        \\n            for(let i=index; i<candidates.length; i++) {\\n                tempDataStruct.push(candidates[i])\\n                backtracking(i, target-candidates[i], tempDataStruct)\\n                tempDataStruct.pop()\\n            }\\n        }\\n        backtracking(index, target, tempDataStruct)\\n        return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 742449,
                "title": "explanation-of-time-complexity",
                "content": "Ill try and explain the time complexity I know and understand the solution to be. In order to get the time complexity easily of these types of solutions, always consider the recursive tree.\\n\\nLets say we have 4 elements in our list (call it N) and a target = 7 (call it M):\\n\\nnums = [2,3,6,7]\\nAt every single level in our recursion tree we have N choices to decrease target by and then to recurse on.\\n\\nAt the first level target = 7 and we can chose 2,3,6,7.\\n\\n                                7\\n                         5    4    1   0\\n\\nAt the second level of our recursive tree where target=5 we also have 4 choices. Even though some of those choices would lead us\\nto a negative target which isnt valid we can approximate that we still have about 4 choices. So we can state that the number of recursive calls on each level of our recursive tree is 4 (N)\\n\\nSo now we have the number of elements on each level. However how many levels (heigh) will there be worst case?\\n\\nIf you consider a list with only 1s in it we can see the maximum height of our recursive tree is equal to target (M)\\n\\ntarget = 7\\nnums = [1, 1, 1, 1]\\n\\n                         7\\n                        /\\n                       6\\n                      /\\n                     5\\n                    /\\n                   4\\n                  ..\\n                 /\\n                1\\n\\nSo we know the number of elements on each level of our recursive tree (N) and we know the height of our recursive tree (M)\\n\\nTherefore we can say worst case scenario the time complexity is O(len(nums)^target) or O(N^M)\\n\\nO(n^m) time complexity\\n\\nHope this helps.",
                "solutionTags": [],
                "code": "Ill try and explain the time complexity I know and understand the solution to be. In order to get the time complexity easily of these types of solutions, always consider the recursive tree.\\n\\nLets say we have 4 elements in our list (call it N) and a target = 7 (call it M):\\n\\nnums = [2,3,6,7]\\nAt every single level in our recursion tree we have N choices to decrease target by and then to recurse on.\\n\\nAt the first level target = 7 and we can chose 2,3,6,7.\\n\\n                                7\\n                         5    4    1   0\\n\\nAt the second level of our recursive tree where target=5 we also have 4 choices. Even though some of those choices would lead us\\nto a negative target which isnt valid we can approximate that we still have about 4 choices. So we can state that the number of recursive calls on each level of our recursive tree is 4 (N)\\n\\nSo now we have the number of elements on each level. However how many levels (heigh) will there be worst case?\\n\\nIf you consider a list with only 1s in it we can see the maximum height of our recursive tree is equal to target (M)\\n\\ntarget = 7\\nnums = [1, 1, 1, 1]\\n\\n                         7\\n                        /\\n                       6\\n                      /\\n                     5\\n                    /\\n                   4\\n                  ..\\n                 /\\n                1\\n\\nSo we know the number of elements on each level of our recursive tree (N) and we know the height of our recursive tree (M)\\n\\nTherefore we can say worst case scenario the time complexity is O(len(nums)^target) or O(N^M)\\n\\nO(n^m) time complexity\\n\\nHope this helps.",
                "codeTag": "Unknown"
            },
            {
                "id": 16506,
                "title": "8-line-python-solution-dynamic-programming-beats-86-77",
                "content": "    def combinationSum(self, candidates, target):\\n        candidates.sort()\\n        dp = [[[]]] + [[] for i in xrange(target)]\\n        for i in xrange(1, target + 1):\\n            for number in candidates:\\n                if number > i: break\\n                for L in dp[i - number]:\\n                    if not L or number >= L[-1]: dp[i] += L + [number],\\n        return dp[target]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    def combinationSum(self, candidates, target):\\n        candidates.sort()\\n        dp = [[[]]] + [[] for i in xrange(target)]\\n        for i in xrange(1, target + 1):\\n            for number in candidates:\\n                if number > i: break\\n                for L in dp[i - number]:\\n                    if not L or number >= L[-1]: dp[i] += L + [number],\\n        return dp[target]",
                "codeTag": "Python3"
            },
            {
                "id": 3685211,
                "title": "beat-100-proper-step-by-step-explanation-simplest-approach",
                "content": "# Intuition\\nThe code follows a backtracking approach to find all combinations that sum up to the given target.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The code follows a backtracking approach to find all combinations that sum up to the given target.\\n2. The `combinationSum` method is the entry point for the backtracking process. It initializes the `ans` list to store the result and the `ls` list to track the current combination.\\n3. The `cum` method performs the backtracking. It takes the current array `c`, the remaining target value, and the starting index as parameters.\\n4. The base case is when the target value becomes zero. In this case, it means that the current combination in `ls` sums up to the target. Therefore, a copy of `ls` is added to the `ans` list as a valid combination.\\n5. The for loop iterates through the elements in the `c` array, starting from the given index `start`.\\n6. Within the loop, if the current element `c[i]` is less than or equal to the remaining target, it is a valid candidate to include in the combination.\\n7. The element `c[i]` is added to the `ls` list, and the `cum` method is recursively called with the updated target (subtracting `c[i]`) and the same starting index `i` to allow reusing the same element in subsequent combinations.\\n8. After the recursive call, the last element is removed from `ls` using `ls.remove(ls.size() - 1)`. This step is crucial for backtracking, as it ensures that the correct elements are considered for the next iteration of the loop.\\n9. The process continues with the next element in the loop until all combinations have been explored.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    ArrayList<Integer> ls = new ArrayList<>();\\n\\n    public List<List<Integer>> combinationSum(int[] c, int target) {\\n        cum(c, target, 0);\\n        return ans;\\n    }\\n\\n    public void cum(int[] c, int target, int start) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ls)); \\n            return;\\n        }\\n\\n        for (int i = start; i < c.length; i++) {\\n            if (c[i] <= target) {\\n                ls.add(c[i]);\\n                cum(c, target - c[i], i); \\n                ls.remove(ls.size() - 1); \\n            }\\n        }\\n    }\\n}\\n\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/c0566519-3a55-47c3-a7c3-c6ccf4f753f2_1687785256.2860038.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    ArrayList<Integer> ls = new ArrayList<>();\\n\\n    public List<List<Integer>> combinationSum(int[] c, int target) {\\n        cum(c, target, 0);\\n        return ans;\\n    }\\n\\n    public void cum(int[] c, int target, int start) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ls)); \\n            return;\\n        }\\n\\n        for (int i = start; i < c.length; i++) {\\n            if (c[i] <= target) {\\n                ls.add(c[i]);\\n                cum(c, target - c[i], i); \\n                ls.remove(ls.size() - 1); \\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778405,
                "title": "java-simple-approach-with-explanation-runtime-1-ms-100-faster",
                "content": "### Please upvote if you like the solution\\n\\n```\\nclass Solution {\\n    \\n    List<List<Integer>> resultList = new ArrayList<>();\\n    \\n    public List<List<Integer>> combinationSum(int[] arr, int target) {\\n            \\n        getTargetCombination(arr, 0, target, new ArrayList<Integer>());\\n        return resultList;\\n    }\\n    \\n    \\n    public void getTargetCombination(int[] arr, int position, int currentTarget, List<Integer> result) {\\n\\n        /**\\n         * Base case\\n         * 1. If currentTarget is reaching to Zero\\n         * 2. Current Position is equal to the length of the Array\\n         */\\n        if (currentTarget == 0) {\\n            resultList.add(new ArrayList<>(result));\\n            return;\\n        }\\n        if (position == arr.length) {\\n            return;\\n        }\\n\\n        /**\\n         * There are two cases\\n         * 1. Pick the current value if the current value (i.e arr[position]) is less than or equal to the currentTarget\\n         *    value then use the same attribute by passing the same position\\n         *\\n         *  2. Not picking up the current element by not reducing the currentTarget value and increasing the position\\n         */\\n        if (arr[position] <= currentTarget) {\\n            result.add(arr[position]);\\n            getTargetCombination(arr, position, currentTarget - arr[position], result);\\n            // removing the last element because post adding of the value the call came back\\n            result.remove(result.size() - 1);\\n        }\\n        // not picked\\n        getTargetCombination(arr, position + 1, currentTarget, result);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<List<Integer>> resultList = new ArrayList<>();\\n    \\n    public List<List<Integer>> combinationSum(int[] arr, int target) {\\n            \\n        getTargetCombination(arr, 0, target, new ArrayList<Integer>());\\n        return resultList;\\n    }\\n    \\n    \\n    public void getTargetCombination(int[] arr, int position, int currentTarget, List<Integer> result) {\\n\\n        /**\\n         * Base case\\n         * 1. If currentTarget is reaching to Zero\\n         * 2. Current Position is equal to the length of the Array\\n         */\\n        if (currentTarget == 0) {\\n            resultList.add(new ArrayList<>(result));\\n            return;\\n        }\\n        if (position == arr.length) {\\n            return;\\n        }\\n\\n        /**\\n         * There are two cases\\n         * 1. Pick the current value if the current value (i.e arr[position]) is less than or equal to the currentTarget\\n         *    value then use the same attribute by passing the same position\\n         *\\n         *  2. Not picking up the current element by not reducing the currentTarget value and increasing the position\\n         */\\n        if (arr[position] <= currentTarget) {\\n            result.add(arr[position]);\\n            getTargetCombination(arr, position, currentTarget - arr[position], result);\\n            // removing the last element because post adding of the value the call came back\\n            result.remove(result.size() - 1);\\n        }\\n        // not picked\\n        getTargetCombination(arr, position + 1, currentTarget, result);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16656,
                "title": "dynamic-programming-solution",
                "content": "It adapts the DP solution of coin change problem\\n\\n    class Solution {\\n    public:\\n    \\tvector<vector<int> > combinationSum(vector<int> &candidates, int target) {\\n    \\t\\tvector< vector< vector<int> > > combinations(target + 1, vector<vector<int>>());\\n    \\t\\tcombinations[0].push_back(vector<int>());\\n    \\t\\tfor (auto& score : candidates)\\n    \\t\\t\\tfor (int j = score; j <= target; j++)\\n    \\t\\t\\t\\tif (combinations[j - score].size() > 0)\\t{\\n    \\t\\t\\t\\t\\tauto tmp = combinations[j - score];\\n    \\t\\t\\t\\t\\tfor (auto& s : tmp)\\n    \\t\\t\\t\\t\\t\\ts.push_back(score);\\n    \\t\\t\\t\\t\\tcombinations[j].insert(combinations[j].end(), tmp.begin(), tmp.end());\\n    \\t\\t\\t\\t}\\n    \\t\\tauto ret = combinations[target];\\n    \\t\\tfor (int i = 0; i < ret.size(); i++)\\n    \\t\\t\\tsort(ret[i].begin(), ret[i].end());\\n    \\t\\treturn ret;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<vector<int> > combinationSum(vector<int> &candidates, int target) {\\n    \\t\\tvector< vector< vector<int> > > combinations(target + 1, vector<vector<int>>());\\n    \\t\\tcombinations[0].push_back(vector<int>());\\n    \\t\\tfor (auto& score : candidates)\\n    \\t\\t\\tfor (int j = score; j <= target; j++)\\n    \\t\\t\\t\\tif (combinations[j - score].size() > 0)\\t{\\n    \\t\\t\\t\\t\\tauto tmp = combinations[j - score];\\n    \\t\\t\\t\\t\\tfor (auto& s : tmp)\\n    \\t\\t\\t\\t\\t\\ts.push_back(score);\\n    \\t\\t\\t\\t\\tcombinations[j].insert(combinations[j].end(), tmp.begin(), tmp.end());\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 307982,
                "title": "heavily-commented-javascript-backtracking-solution",
                "content": "Here\\'s my heavily commented version, as I didn\\'t see many of those around yet.\\nI left the console.log in there, to help with getting the order of the execution.\\nRemove it for better performance.\\n\\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n        console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else if (t < 0) {\\n            console.log(\\'Dead path. Will our code actually ever get here?\\');\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                find(t - candidates[i], [...p, candidates[i]], i)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 // further, because of the 2nd check of the while loop condition.\\n                i++;\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n        console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else if (t < 0) {\\n            console.log(\\'Dead path. Will our code actually ever get here?\\');\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                find(t - candidates[i], [...p, candidates[i]], i)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 // further, because of the 2nd check of the while loop condition.\\n                i++;\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 815714,
                "title": "dfs-recursion-solution-with-illustration-to-understand-the-process",
                "content": "I\\'m using candidates[2,3,5] and target 8 as example. \\nIt\\'s pretty clear with the chart below how the function dfs is called recursively and how duplications like [3,5], [5,3] is avoided.\\nSome solutions sorted the candidates first, and some also have a if statement on if target <0. Both are not necessary.\\nAlso, I acutally found that sort the candidates may increase the number of operations. You can draw a similar chart with [5,3,2]. It has fewer operations. See codes following the chart below.\\n![image](https://assets.leetcode.com/users/images/600da56f-c155-40b7-bb44-186257125966_1598579025.1168523.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        self.dfs(candidates, target,[],res)\\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            self.dfs(candidates[i:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "I\\'m using candidates[2,3,5] and target 8 as example. \\nIt\\'s pretty clear with the chart below how the function dfs is called recursively and how duplications like [3,5], [5,3] is avoided.\\nSome solutions sorted the candidates first, and some also have a if statement on if target <0. Both are not necessary.\\nAlso, I acutally found that sort the candidates may increase the number of operations. You can draw a similar chart with [5,3,2]. It has fewer operations. See codes following the chart below.\\n![image](https://assets.leetcode.com/users/images/600da56f-c155-40b7-bb44-186257125966_1598579025.1168523.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        self.dfs(candidates, target,[],res)\\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            self.dfs(candidates[i:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 16669,
                "title": "c-backtracking-implementation",
                "content": "C# backtracking implementation\\n\\n        public IList<IList<int>> CombinationSum(int[] candidates, int target)\\n        {\\n            List<IList<int>> result = new List<IList<int>>();\\n            List<int> combination = new List<int>();\\n            Array.Sort(candidates);\\n            CombinationSum(result, candidates, combination, target, 0);\\n            return result;\\n        }\\n\\n        private void CombinationSum(IList<IList<int>> result, int[] candidates, IList<int> combination, int target, int start)\\n        {\\n            if (target == 0)\\n            {\\n                result.Add(new List<int>(combination));\\n                return;\\n            }\\n\\n            for (int i = start; i != candidates.Length && target >= candidates[i]; ++i)\\n            {\\n                combination.Add(candidates[i]);\\n                CombinationSum(result, candidates, combination, target - candidates[i], i);\\n                combination.Remove(combination.Last());\\n            }\\n        }",
                "solutionTags": [],
                "code": "C# backtracking implementation\\n\\n        public IList<IList<int>> CombinationSum(int[] candidates, int target)\\n        {\\n            List<IList<int>> result = new List<IList<int>>();\\n            List<int> combination = new List<int>();\\n            Array.Sort(candidates);\\n            CombinationSum(result, candidates, combination, target, 0);\\n            return result;\\n        }\\n\\n        private void CombinationSum(IList<IList<int>> result, int[] candidates, IList<int> combination, int target, int start)\\n        {\\n            if (target == 0)\\n            {\\n                result.Add(new List<int>(combination));\\n                return;\\n            }\\n\\n            for (int i = start; i != candidates.Length && target >= candidates[i]; ++i)\\n            {\\n                combination.Add(candidates[i]);\\n                CombinationSum(result, candidates, combination, target - candidates[i], i);\\n                combination.Remove(combination.Last());\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3237600,
                "title": "c-beats-100-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    void solve(int target,vector<int> &candidates,vector<vector<int>> &ans,int index)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            if(target-candidates[i]>=0)\\n               solve(target-candidates[i],candidates,ans,i);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        solve(target,candidates,ans,0);\\n        return ans;\\n    }\\n};\\n\\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/a9a3382a-a1b3-4c13-a59c-e5e41a1ca8fe_1677523515.9827046.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    void solve(int target,vector<int> &candidates,vector<vector<int>> &ans,int index)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            if(target-candidates[i]>=0)\\n               solve(target-candidates[i],candidates,ans,i);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        solve(target,candidates,ans,0);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920513,
                "title": "python",
                "content": "```\\ndef comboSum(target,candidates):\\n    \\'\\'\\'\\n    1. No duplicates\\n    2. Same number can be repeated\\n    3. Same combo is not repeated\\n\\n    \\'\\'\\'\\n\\n    result = []\\n\\n    def helper(start,sum_so_far,subset,level=0):\\n        space= \\' \\'*level\\n        print(f\\'{space} {subset}\\')\\n        if sum_so_far == target:\\n            result.append(subset[::])\\n            return\\n        if sum_so_far > target:\\n            return\\n\\n        for i in range(start,len(candidates)):\\n            num = candidates[i]\\n            subset.append(num)\\n            sum_so_far +=num\\n            level+=1\\n            helper(i,sum_so_far,subset,level)\\n            level-=1\\n            sum_so_far -=num\\n            subset.pop()\\n\\n    helper(0,0,[])\\n    return result\\n\\nif __name__ == \"__main__\":\\n    candidates = [1,2,3]\\n    target = 3\\n    print(comboSum(target,candidates))\\n\\t```\\n```",
                "solutionTags": [],
                "code": "```\\ndef comboSum(target,candidates):\\n    \\'\\'\\'\\n    1. No duplicates\\n    2. Same number can be repeated\\n    3. Same combo is not repeated\\n\\n    \\'\\'\\'\\n\\n    result = []\\n\\n    def helper(start,sum_so_far,subset,level=0):\\n        space= \\' \\'*level\\n        print(f\\'{space} {subset}\\')\\n        if sum_so_far == target:\\n            result.append(subset[::])\\n            return\\n        if sum_so_far > target:\\n            return\\n\\n        for i in range(start,len(candidates)):\\n            num = candidates[i]\\n            subset.append(num)\\n            sum_so_far +=num\\n            level+=1\\n            helper(i,sum_so_far,subset,level)\\n            level-=1\\n            sum_so_far -=num\\n            subset.pop()\\n\\n    helper(0,0,[])\\n    return result\\n\\nif __name__ == \"__main__\":\\n    candidates = [1,2,3]\\n    target = 3\\n    print(comboSum(target,candidates))\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1546400,
                "title": "java-backtracking-w-early-exit-detailed-time-complexity-explanation-added",
                "content": "**Backtracking - No Early Exit optimization**\\n```\\n/**\\n * Since this question allows same number to be used unlimited times, candidates\\n * array cannot have zero and negative numbers. As it will lead to infinite\\n * number of combinations. For example: candidates = [-1, 0, 1] and target = 1.\\n * This case will result in infinite solutions if same number can be used\\n * multiple times.\\n *\\n * Time Complexity:\\n * This problem can be converted to Combination Sum II. For example, candidates = [2,3,5,6] and target = 12.\\n * Then we can create an array = [2,2,2,2,2,2, 3,3,3,3, 5,5, 6,6].\\n * Now from this array we can use each number only once in the combination.\\n * Therefore total number of elements in this array N\\' equal to floor(T/n1) + floor(T/n2) + ... + floor(T/nN)\\n *\\n * 1. The length of the potential combinations can vary from 1 to k where k = T/M.\\n * 2. Total number of combinations of size k is C(N\\',k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N\\',1) + 2*C(N\\',2) + ... + k*C(N\\',k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N\\', i)).\\n * If k = N\\', then above time complexity becomes O(N\\' * 2^(N\\'-1))\\n *\\n * Space Complexity: O(T/M) -> This is used by recursion stack and temp list.\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0 || target <= 0) {\\n            return result;\\n        }\\n\\n        combinationSumHelper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSumHelper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            if (candidates[i] > target) {\\n                continue;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSumHelper(candidates, i, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Backtracking - With Early Exit optimization**\\n```java\\n/**\\n * In this solution we are sorting the input array, which allows us to early\\n * exit from the recursion if the current number is greater than the remaining\\n * target.\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * the time and space required for the sorting.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0 || target <= 0) {\\n            return result;\\n        }\\n        // Only benefit of sorting is that we can break early in the recursion if the\\n        // current number is greater than the remaining target.\\n        Arrays.sort(candidates);\\n        combinationSumHelper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSumHelper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSumHelper(candidates, i, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Combination Sum questions on LeetCode:\\n- [40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/1546439/Java-or-Backtracking-optimized-for-duplicate-candidates-(Detailed-TC-explanation-added))\\n- [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/1546449/Java-or-Optimized-Backtracking-w-Detailed-Time-Complexity-explanation)\\n- [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/discuss/1546467/Java-or-TC:-O(N*T)-or-SC:-O(T)-or-DP-(BottomUp-and-TopDown)-w-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * Since this question allows same number to be used unlimited times, candidates\\n * array cannot have zero and negative numbers. As it will lead to infinite\\n * number of combinations. For example: candidates = [-1, 0, 1] and target = 1.\\n * This case will result in infinite solutions if same number can be used\\n * multiple times.\\n *\\n * Time Complexity:\\n * This problem can be converted to Combination Sum II. For example, candidates = [2,3,5,6] and target = 12.\\n * Then we can create an array = [2,2,2,2,2,2, 3,3,3,3, 5,5, 6,6].\\n * Now from this array we can use each number only once in the combination.\\n * Therefore total number of elements in this array N\\' equal to floor(T/n1) + floor(T/n2) + ... + floor(T/nN)\\n *\\n * 1. The length of the potential combinations can vary from 1 to k where k = T/M.\\n * 2. Total number of combinations of size k is C(N\\',k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N\\',1) + 2*C(N\\',2) + ... + k*C(N\\',k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N\\', i)).\\n * If k = N\\', then above time complexity becomes O(N\\' * 2^(N\\'-1))\\n *\\n * Space Complexity: O(T/M) -> This is used by recursion stack and temp list.\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0 || target <= 0) {\\n            return result;\\n        }\\n\\n        combinationSumHelper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSumHelper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            if (candidates[i] > target) {\\n                continue;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSumHelper(candidates, i, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * In this solution we are sorting the input array, which allows us to early\\n * exit from the recursion if the current number is greater than the remaining\\n * target.\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * the time and space required for the sorting.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0 || target <= 0) {\\n            return result;\\n        }\\n        // Only benefit of sorting is that we can break early in the recursion if the\\n        // current number is greater than the remaining target.\\n        Arrays.sort(candidates);\\n        combinationSumHelper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSumHelper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSumHelper(candidates, i, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254479,
                "title": "20ms-cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target, int fm = 0) {\\n        if (target == 0){\\n            return {{}};\\n        }\\n        vector<vector<int>> res;\\n        for (int i = fm; i < candidates.size(); i++){\\n            if (target < candidates[i])\\n                continue;\\n\\n            for (vector<int> &b : combinationSum(candidates, target - candidates[i], i)){\\n                b.push_back(candidates[i]);\\n                res.push_back(b);\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target, int fm = 0) {\\n        if (target == 0){\\n            return {{}};\\n        }\\n        vector<vector<int>> res;\\n        for (int i = fm; i < candidates.size(); i++){\\n            if (target < candidates[i])\\n                continue;\\n\\n            for (vector<int> &b : combinationSum(candidates, target - candidates[i], i)){\\n                b.push_back(candidates[i]);\\n                res.push_back(b);\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16724,
                "title": "java-solution-backtracking",
                "content": "    public class Solution {\\n     \\n    \\tprivate List<List<Integer>> solution;\\n    \\n    \\tprivate List<Integer> curSolution;\\n    \\n    \\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\t\\tsolution = new ArrayList<List<Integer>>();\\n    \\t\\tcurSolution = new ArrayList<Integer>();\\n    \\t\\tArrays.sort(candidates);\\n    \\t\\tbackTrack(candidates, target, 0); \\n    \\t\\treturn solution;\\n    \\t}\\n    \\n    \\tprivate void backTrack(int[] candidates, int target, int lastIdx) {\\n    \\t\\tif (target == 0) {\\n    \\t\\t\\tsolution.add(new ArrayList<>(curSolution));\\n    \\t\\t}\\n    \\t\\telse if (target < 0) {\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tint i = lastIdx;\\n    \\t\\t\\twhile (i < candidates.length) {\\n    \\t\\t\\t\\tint candidate = candidates[i];\\n    \\t\\t\\t\\tcurSolution.add(candidate);\\n    \\t\\t\\t\\tbackTrack(candidates, target - candidate, i);\\n    \\t\\t\\t\\tcurSolution.remove(curSolution.size() - 1);\\n    \\t\\t\\t\\twhile (i < candidates.length && candidates[i] == candidate) {\\n    \\t\\t\\t\\t\\ti++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n     \\n    \\tprivate List<List<Integer>> solution;\\n    \\n    \\tprivate List<Integer> curSolution;\\n    \\n    \\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\t\\tsolution = new ArrayList<List<Integer>>();\\n    \\t\\tcurSolution = new ArrayList<Integer>();\\n    \\t\\tArrays.sort(candidates);\\n    \\t\\tbackTrack(candidates, target, 0); \\n    \\t\\treturn solution;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 16559,
                "title": "non-recursive-java-solution",
                "content": "    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        int i=0, size = candidates.length, sum=0;\\n        Stack<Integer> combi = new Stack<>(), indices = new Stack<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        while (i < size) {\\n        \\tif (sum + candidates[i]>= target) {\\n        \\t\\tif (sum + candidates[i] == target) {\\n        \\t\\t\\tcombi.push(candidates[i]);\\n        \\t\\t\\tresult.add(new ArrayList<>(combi));\\n        \\t\\t\\tcombi.pop();\\n        \\t\\t}\\n        \\t\\t// indices stack and combination stack should have the same size all the time\\n        \\t\\tif (!indices.empty()){\\n        \\t\\t\\tsum -= combi.pop();\\n        \\t\\t\\ti = indices.pop();\\n        \\t\\t\\twhile (i == size-1 && !indices.empty()) {\\n        \\t\\t\\t\\ti = indices.pop();\\n        \\t\\t\\t\\tsum -= combi.pop();\\n        \\t\\t\\t\\t\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\ti++;\\n        \\t} else {\\n        \\t\\tcombi.push(candidates[i]);\\n        \\t\\tsum +=candidates[i];\\n        \\t\\tindices.push(i);\\n        \\t}\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Backtracking",
                    "Stack"
                ],
                "code": "    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        int i=0, size = candidates.length, sum=0;\\n        Stack<Integer> combi = new Stack<>(), indices = new Stack<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        while (i < size) {\\n        \\tif (sum + candidates[i]>= target) {\\n        \\t\\tif (sum + candidates[i] == target) {\\n        \\t\\t\\tcombi.push(candidates[i]);\\n        \\t\\t\\tresult.add(new ArrayList<>(combi));\\n        \\t\\t\\tcombi.pop();\\n        \\t\\t}\\n        \\t\\t// indices stack and combination stack should have the same size all the time\\n        \\t\\tif (!indices.empty()){\\n        \\t\\t\\tsum -= combi.pop();\\n        \\t\\t\\ti = indices.pop();\\n        \\t\\t\\twhile (i == size-1 && !indices.empty()) {\\n        \\t\\t\\t\\ti = indices.pop();\\n        \\t\\t\\t\\tsum -= combi.pop();\\n        \\t\\t\\t\\t\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\ti++;\\n        \\t} else {\\n        \\t\\tcombi.push(candidates[i]);\\n        \\t\\tsum +=candidates[i];\\n        \\t\\tindices.push(i);\\n        \\t}\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1960396,
                "title": "java-98-fast-backtracking-and-recursion-full-explanation-with-comments",
                "content": "```\\n// Intuition behind this solution is thinking that \"CAN WE TAKE THE ELEMENT\" or \"NOT TAKING IT\" .\\n// By the above logic we can draw recursion tree\\n\\n/* \\n\\nNOTE : we can take any element any number of times in Combination sum 1\\nEX : [2,3,6,7] target = 7\\nans : [ [2,2,3] , [7] ]\\nSuppose calling function : funct(index,target,List<Integer> ds)\\nLeft tree : we are taking the element \\nRight tree : we are not\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2           3        6        7\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \\t  /   \\\\\\n                                       [0,5,{2}]  [i+1,7,{}]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /     \\\\\\n\\t\\t\\t\\t\\t    [0,3,{2,2}]    [i+1,5,{2}]\\n\\t\\t\\t\\t\\t\\t/     \\\\ \\n\\t\\t\\t [0,1,{2,2,2}]      [i+1,3,{2,2}]\\n\\t             /  \\\\                /   \\\\ \\n         Here  t = 0\\t    [1,0,{2,2,3}] = This is one of our answers\\n\\t\\t\\nLike that recursion tree will run and stops when i becomes arr.length and you can also stop at t becomes zero because then it will not be possible to take that element\\t\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] a, int t) {\\n        List<List<Integer>> ans = new ArrayList<>(); // ans list\\n        List<Integer> ls = new ArrayList<>();  // our inside list to store different combinations\\n        int index = 0; // starting from index 0\\n        combSum(index,ans,a,t,ls); // recursive function\\n        return ans;\\n    }\\n    static void combSum(int i,List<List<Integer>>ans,int a[],int t,List<Integer> ds) {\\n        // Base condition\\n\\t\\tif(i == a.length) {\\n            if(t == 0) {\\n                ans.add(new ArrayList<>(ds)); // ArrayList constructor constructs a list of specified collection . in our case it is List<Integer> ds\\n            }\\n            return;\\n        }\\n\\t\\t\\n\\t\\t// Check if the element at index is smaller than the target or not\\n        if(a[i] <= t) {\\n            ds.add(a[i]);\\n            combSum(i,ans,a,t-a[i],ds); // calls for same index and decreasing target by a[i]\\n            ds.remove(ds.size()-1); // during backtracking we will remove the added element in ds\\n        }\\n        combSum(i+1,ans,a,t,ds); // call for next index\\n    }\\n}\\n\\n/* Its time complexity will be : 2^target * k  ( k = putting ds in ans in base case )\\n\\nNOTE:  We are taking 2^target not 2^n because if we were allowed to take element only once(i.e in combination sum2) we can have n times pick/non-pick choices thats why its time complexity will be ( 2^n *k ) but here we are having a  choice to take one element multiple times . \\n\\nfor example : number = 2 , target = 10 we can pick/non-pick element 2 till t times \\nand if we distribute 2^t for n elements we can say on an average its time complexity will be 2^t\\n\\nSpace Complexity will be : ( k * x ) ( k = average length and x combinations ) ( Its totally dependent upon given conditions) */\\n\\n// Upvote if you like the explanation \\uD83D\\uDC4D\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// Intuition behind this solution is thinking that \"CAN WE TAKE THE ELEMENT\" or \"NOT TAKING IT\" .\\n// By the above logic we can draw recursion tree\\n\\n/* \\n\\nNOTE : we can take any element any number of times in Combination sum 1\\nEX : [2,3,6,7] target = 7\\nans : [ [2,2,3] , [7] ]\\nSuppose calling function : funct(index,target,List<Integer> ds)\\nLeft tree : we are taking the element \\nRight tree : we are not\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2           3        6        7\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \\t  /   \\\\\\n                                       [0,5,{2}]  [i+1,7,{}]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /     \\\\\\n\\t\\t\\t\\t\\t    [0,3,{2,2}]    [i+1,5,{2}]\\n\\t\\t\\t\\t\\t\\t/     \\\\ \\n\\t\\t\\t [0,1,{2,2,2}]      [i+1,3,{2,2}]\\n\\t             /  \\\\                /   \\\\ \\n         Here  t = 0\\t    [1,0,{2,2,3}] = This is one of our answers\\n\\t\\t\\nLike that recursion tree will run and stops when i becomes arr.length and you can also stop at t becomes zero because then it will not be possible to take that element\\t\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] a, int t) {\\n        List<List<Integer>> ans = new ArrayList<>(); // ans list\\n        List<Integer> ls = new ArrayList<>();  // our inside list to store different combinations\\n        int index = 0; // starting from index 0\\n        combSum(index,ans,a,t,ls); // recursive function\\n        return ans;\\n    }\\n    static void combSum(int i,List<List<Integer>>ans,int a[],int t,List<Integer> ds) {\\n        // Base condition\\n\\t\\tif(i == a.length) {\\n            if(t == 0) {\\n                ans.add(new ArrayList<>(ds)); // ArrayList constructor constructs a list of specified collection . in our case it is List<Integer> ds\\n            }\\n            return;\\n        }\\n\\t\\t\\n\\t\\t// Check if the element at index is smaller than the target or not\\n        if(a[i] <= t) {\\n            ds.add(a[i]);\\n            combSum(i,ans,a,t-a[i],ds); // calls for same index and decreasing target by a[i]\\n            ds.remove(ds.size()-1); // during backtracking we will remove the added element in ds\\n        }\\n        combSum(i+1,ans,a,t,ds); // call for next index\\n    }\\n}\\n\\n/* Its time complexity will be : 2^target * k  ( k = putting ds in ans in base case )\\n\\nNOTE:  We are taking 2^target not 2^n because if we were allowed to take element only once(i.e in combination sum2) we can have n times pick/non-pick choices thats why its time complexity will be ( 2^n *k ) but here we are having a  choice to take one element multiple times . \\n\\nfor example : number = 2 , target = 10 we can pick/non-pick element 2 till t times \\nand if we distribute 2^t for n elements we can say on an average its time complexity will be 2^t\\n\\nSpace Complexity will be : ( k * x ) ( k = average length and x combinations ) ( Its totally dependent upon given conditions) */\\n\\n// Upvote if you like the explanation \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177891,
                "title": "java-100-fastest-solution",
                "content": "```\\nclass Solution {\\n    \\n     void findAllways(int[] candidates,List<List<Integer>> finalList,ArrayList<Integer> list,int i,int target){\\n        if(target == 0)\\n            finalList.add(new ArrayList<Integer>(list));\\n        else{\\n            for(int j=i;j<candidates.length;j++)\\n            {\\n                if(candidates[j]<=target){\\n                list.add(candidates[j]);\\n                findAllways(candidates,finalList,list,j,target-candidates[j]);\\n                list.remove(list.size()-1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\n        List<List<Integer>> finalList = new ArrayList<>();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        findAllways(candidates,finalList,list,0,target);\\n        \\n        return finalList;\\n    }\\n    \\n}\\n``\\nPlease upvotes if find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n     void findAllways(int[] candidates,List<List<Integer>> finalList,ArrayList<Integer> list,int i,int target){\\n        if(target == 0)\\n            finalList.add(new ArrayList<Integer>(list));\\n        else{\\n            for(int j=i;j<candidates.length;j++)\\n            {\\n                if(candidates[j]<=target){\\n                list.add(candidates[j]);\\n                findAllways(candidates,finalList,list,j,target-candidates[j]);\\n                list.remove(list.size()-1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 371715,
                "title": "python-dynamic-programming-beats-99",
                "content": "I\\'m sharing both my recursive and dynamic programming solutions. The DP approach is about three times faster.\\n\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # return self.combinationSumRecurisve(candidates, target, [])\\n        return self.combinationSumDP(candidates, target)\\n    \\n    def combinationSumDP(self, candidates, target):\\n        dp = {}\\n        dp[0] = [[]]\\n        candidates.sort()\\n        for c in candidates:\\n            for t in range(c, target + 1):\\n                if (t-c) in dp:\\n                    if t not in dp:\\n                        dp[t] = []\\n                    for comb_t_m_c in dp[t-c]:\\n                        dp[t].append(comb_t_m_c + [c])\\n        return dp[target] if target in dp else []\\n        \\n    \\n    def combinationSumRecurisve(self, candidates, target, curr_nums):\\n        if target == 0:\\n            return [curr_nums]\\n        \\n        if len(candidates) == 0 or target <= 0:\\n            return []\\n        \\n        c = candidates[0]\\n        sol = self.combinationSumRecurisve(candidates[1:], target, curr_nums)\\n        sol.extend(self.combinationSumRecurisve(candidates, target - c, curr_nums + [c]))\\n        return sol\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # return self.combinationSumRecurisve(candidates, target, [])\\n        return self.combinationSumDP(candidates, target)\\n    \\n    def combinationSumDP(self, candidates, target):\\n        dp = {}\\n        dp[0] = [[]]\\n        candidates.sort()\\n        for c in candidates:\\n            for t in range(c, target + 1):\\n                if (t-c) in dp:\\n                    if t not in dp:\\n                        dp[t] = []\\n                    for comb_t_m_c in dp[t-c]:\\n                        dp[t].append(comb_t_m_c + [c])\\n        return dp[target] if target in dp else []\\n        \\n    \\n    def combinationSumRecurisve(self, candidates, target, curr_nums):\\n        if target == 0:\\n            return [curr_nums]\\n        \\n        if len(candidates) == 0 or target <= 0:\\n            return []\\n        \\n        c = candidates[0]\\n        sol = self.combinationSumRecurisve(candidates[1:], target, curr_nums)\\n        sol.extend(self.combinationSumRecurisve(candidates, target - c, curr_nums + [c]))\\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16735,
                "title": "share-my-15-line-dfs-java-code",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            Arrays.sort(candidates);\\n            dfs(ans, new ArrayList<Integer>(), candidates, target, 0);\\n            return ans;\\n        }\\n        \\n        private void dfs(List<List<Integer>> ans, List<Integer> list, int[] cand, int remain, int from) {\\n            if (remain < 0) { return; }\\n            if (remain == 0) { ans.add(new ArrayList<Integer>(list)); return; }\\n            for (int i=from; i<cand.length; ++i) {  //cand[] sorted; from is the starting point of picking elements at this level\\n                list.add(cand[i]);\\n                dfs(ans, list, cand, remain-cand[i], i);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            Arrays.sort(candidates);\\n            dfs(ans, new ArrayList<Integer>(), candidates, target, 0);\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 16814,
                "title": "simple-and-fast-dfs-solution-python-ac-98ms",
                "content": "    class Solution:\\n    # @param candidates, a list of integers\\n    # @param target, integer\\n    # @return a list of lists of integers\\n    def combinationSum(self, candidates, target):\\n        candidates.sort()\\n        stack = [(0, 0, [])]\\n        result = []\\n        while stack:\\n            total, start, res = stack.pop()\\n            if total == target:\\n                result.append(res)\\n            for n in range(start, len(candidates)):\\n                t = total + candidates[n]\\n                if t > target:\\n                    break\\n                stack.append((t, n, res + [candidates[n]]))\\n        return result\\n\\nJAVA\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        Stack<ArrayList<Integer>> stack = new Stack<ArrayList<Integer>>();\\n        Stack<Integer> sum = new Stack<Integer>();\\n        Stack<Integer> start = new Stack<Integer>();\\n        stack.push(new ArrayList<Integer>());\\n        sum.push(0);\\n        start.push(0);\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        while (!stack.isEmpty()) {\\n            List<Integer> res = stack.pop();\\n            int total = sum.pop();\\n            int begin = start.pop();\\n            if (total == target)\\n                result.add(res);\\n            else {\\n                for (int i = begin; i < candidates.length; i++) {\\n                    int t = total + candidates[i];\\n                    if (t > target)\\n                        break;\\n                    ArrayList<Integer> r = new ArrayList<Integer>(res);\\n                    r.add(candidates[i]);\\n                    stack.push(r);\\n                    sum.push(t);\\n                    start.push(i);\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param candidates, a list of integers\\n    # @param target, integer\\n    # @return a list of lists of integers\\n    def combinationSum(self, candidates, target):\\n        candidates.sort()\\n        stack = [(0, 0, [])]\\n        result = []\\n        while stack:\\n            total, start, res = stack.pop()\\n            if total == target:\\n                result.append(res)\\n            for n in range(start, len(candidates)):\\n                t = total + candidates[n]\\n                if t > target:\\n                    break\\n                stack.append((t, n, res + [candidates[n]]))\\n        return result\\n\\nJAVA\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        Stack<ArrayList<Integer>> stack = new Stack<ArrayList<Integer>>();\\n        Stack<Integer> sum = new Stack<Integer>();\\n        Stack<Integer> start = new Stack<Integer>();\\n        stack.push(new ArrayList<Integer>());\\n        sum.push(0);\\n        start.push(0);\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        while (!stack.isEmpty()) {\\n            List<Integer> res = stack.pop();\\n            int total = sum.pop();\\n            int begin = start.pop();\\n            if (total == target)\\n                result.add(res);\\n            else {\\n                for (int i = begin; i < candidates.length; i++) {\\n                    int t = total + candidates[i];\\n                    if (t > target)\\n                        break;\\n                    ArrayList<Integer> r = new ArrayList<Integer>(res);\\n                    r.add(candidates[i]);\\n                    stack.push(r);\\n                    sum.push(t);\\n                    start.push(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3696459,
                "title": "backtraking-4-connected-problems",
                "content": "# 1.combination sum\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res=[]\\n        def dfs(candidates,target,path,res):\\n            if target==0:\\n                res.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                dfs(candidates[i:],target-candidates[i],path+[candidates[i]],res)\\n        dfs(candidates,target,[],res)\\n        return res\\n```\\n# 2.combination sum II\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```\\n# 3. permutation\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            if len(nums)==0:\\n                ans.append(temp)\\n                return \\n            for i in range(len(nums)):\\n                back(nums[:i]+nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n```\\n# 4. Restore IP Address\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans,k=[],0\\n        def back(s,ans,k,temp=\\'\\'):\\n            if k==4 and len(s)==0:\\n                ans.append(temp[:-1])\\n                return\\n            if k==4 or len(s)==0:\\n                return \\n            for i in range(3):\\n                if k>4 or i+1>len(s):\\n                    break\\n                if int(s[:i+1])>255:\\n                    continue\\n                if i!=0 and s[0]==\"0\":\\n                    continue\\n                back(s[i+1:],ans,k+1,temp+s[:i+1]+\\'.\\')  \\n            return ans\\n        return back(s,ans,k,\\'\\')\\n```\\n# please upvote me it would encourage me alot\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res=[]\\n        def dfs(candidates,target,path,res):\\n            if target==0:\\n                res.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                dfs(candidates[i:],target-candidates[i],path+[candidates[i]],res)\\n        dfs(candidates,target,[],res)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            if len(nums)==0:\\n                ans.append(temp)\\n                return \\n            for i in range(len(nums)):\\n                back(nums[:i]+nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n```\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans,k=[],0\\n        def back(s,ans,k,temp=\\'\\'):\\n            if k==4 and len(s)==0:\\n                ans.append(temp[:-1])\\n                return\\n            if k==4 or len(s)==0:\\n                return \\n            for i in range(3):\\n                if k>4 or i+1>len(s):\\n                    break\\n                if int(s[:i+1])>255:\\n                    continue\\n                if i!=0 and s[0]==\"0\":\\n                    continue\\n                back(s[i+1:],ans,k+1,temp+s[:i+1]+\\'.\\')  \\n            return ans\\n        return back(s,ans,k,\\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090390,
                "title": "very-easy-c-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply do recursion and generate all the possible combinations to check if that combination result in target if not backtrack.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe ca use backtracking like the same way we generate all the sub sets of array here the thing is we have to check if the sum of that subset result in target or not . And also we should check repeatedly for the same element also so not call for i+1 instead i.\\n# Complexity\\n- Time complexity:$$O(n*2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(vector<int>&arr,int start,int rem,vector<int>&temp){\\n        if(rem<0)return;\\n        if(rem==0)ans.push_back(temp);\\n\\n        for(int i=start;i<arr.size();i++){\\n            temp.push_back(arr[i]);\\n            backtrack(arr,i,rem-arr[i],temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int>temp;\\n        backtrack(candidates,0,target,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(vector<int>&arr,int start,int rem,vector<int>&temp){\\n        if(rem<0)return;\\n        if(rem==0)ans.push_back(temp);\\n\\n        for(int i=start;i<arr.size();i++){\\n            temp.push_back(arr[i]);\\n            backtrack(arr,i,rem-arr[i],temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int>temp;\\n        backtrack(candidates,0,target,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060713,
                "title": "c-faster-than-100-00-super-clear-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t\\tvector<int>cur_path;\\n\\t\\t\\tlen = candidates.size();\\n\\t\\t\\tdfs ( candidates, target, cur_path, 0 );\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n\\tprivate:\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tint len;\\n\\t\\t\\n\\t\\tvoid dfs ( vector<int> &candidates, int target, vector<int> &cur_path, int start )\\n\\t\\t{\\n\\t\\t\\tif ( target < 0 ) return;\\n\\t\\t\\tif ( target == 0 )\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(cur_path);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor ( ; start < len; ++start )\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur_path.push_back( candidates[start] );\\n\\t\\t\\t\\tdfs ( candidates, target - candidates[start], cur_path, start );\\n\\t\\t\\t\\tcur_path.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t\\tvector<int>cur_path;\\n\\t\\t\\tlen = candidates.size();\\n\\t\\t\\tdfs ( candidates, target, cur_path, 0 );\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 632799,
                "title": "three-python-solutions-dp-bfs-backtrack-with-explanation-time-beats-88",
                "content": "### DP\\nConstruct a 1d table for recording combinations in a bottom-up manner. Time O(mn) where m denotes the number of candidates and n is the target.\\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tcache = [[] for _ in range(target + 1)]\\n\\tcache[0] = [[]]\\n\\tfor c in candidates:\\n\\t\\tfor i in range(target + 1):\\n\\t\\t\\tif i >= c:\\n\\t\\t\\t\\tfor temp_ans in cache[i - c]:\\n\\t\\t\\t\\t\\tcache[i].append(temp_ans + [c])\\n\\treturn cache[-1]\\n```\\n###  BFS\\nBasic idea is similar to [279. Perfect Squares](https://leetcode.com/problems/perfect-squares/)\\nFor each element pop from the queue, and for each possible candidates, minus it from the current target. If the result equals zeros then we get a solution; if the result is greater than zero then we keep push it into the queue; if the result is smaller than zero than we just stop proceeding there.\\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# BFS\\n\\tfrom collections import deque\\n\\tqueue = deque() # [cur_target, cur_ans]\\n\\tqueue.append((target, [], 0))\\n\\tans = []\\n\\twhile queue:\\n\\t\\tcur_target, cur_ans, cand_idx = queue.popleft()\\n\\t\\tfor i in range(cand_idx, len(candidates)):\\n\\t\\t\\tnew_target = cur_target - candidates[i]\\n\\t\\t\\tif new_target == 0:\\n\\t\\t\\t\\tans.append(cur_ans + [candidates[i]])\\n\\t\\t\\telif new_target > 0:\\n\\t\\t\\t\\tqueue.append((cur_target - candidates[i], cur_ans + [candidates[i]], i))\\n\\treturn ans\\n```\\n### Backtrack\\nThe idea is very similar to [77. Combinations](https://leetcode.com/problems/combinations/) but we need to record and pass `cur_sum`, and the base case is to check if `cur_sum` is equal to or larger than `target`. Time beats ~62%.\\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tdef combination_sum(cur_ans, cur_sum, cand_idx):\\n\\t\\t\\tif cur_sum >= target:\\n\\t\\t\\t\\tif cur_sum == target:\\n\\t\\t\\t\\t\\tans.append(cur_ans)\\n\\t\\t\\t\\treturn\\n\\t\\t\\tfor i in range(cand_idx, len(candidates)):\\n\\t\\t\\t\\tcombination_sum(cur_ans + [candidates[i]], cur_sum + candidates[i], i)\\n\\tans = []\\n\\tcombination_sum([], 0, 0)\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tcache = [[] for _ in range(target + 1)]\\n\\tcache[0] = [[]]\\n\\tfor c in candidates:\\n\\t\\tfor i in range(target + 1):\\n\\t\\t\\tif i >= c:\\n\\t\\t\\t\\tfor temp_ans in cache[i - c]:\\n\\t\\t\\t\\t\\tcache[i].append(temp_ans + [c])\\n\\treturn cache[-1]\\n```\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# BFS\\n\\tfrom collections import deque\\n\\tqueue = deque() # [cur_target, cur_ans]\\n\\tqueue.append((target, [], 0))\\n\\tans = []\\n\\twhile queue:\\n\\t\\tcur_target, cur_ans, cand_idx = queue.popleft()\\n\\t\\tfor i in range(cand_idx, len(candidates)):\\n\\t\\t\\tnew_target = cur_target - candidates[i]\\n\\t\\t\\tif new_target == 0:\\n\\t\\t\\t\\tans.append(cur_ans + [candidates[i]])\\n\\t\\t\\telif new_target > 0:\\n\\t\\t\\t\\tqueue.append((cur_target - candidates[i], cur_ans + [candidates[i]], i))\\n\\treturn ans\\n```\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tdef combination_sum(cur_ans, cur_sum, cand_idx):\\n\\t\\t\\tif cur_sum >= target:\\n\\t\\t\\t\\tif cur_sum == target:\\n\\t\\t\\t\\t\\tans.append(cur_ans)\\n\\t\\t\\t\\treturn\\n\\t\\t\\tfor i in range(cand_idx, len(candidates)):\\n\\t\\t\\t\\tcombination_sum(cur_ans + [candidates[i]], cur_sum + candidates[i], i)\\n\\tans = []\\n\\tcombination_sum([], 0, 0)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 162348,
                "title": "backtracking-with-explanations",
                "content": ">Base case: target == 0\\n\\n>Recursive case: target > 0\\nwe try nums[i] as a candidate of current combination and decrease target by nums[i] (only if target >= candidates[i])\\n\\n>`curRes` printed for the example` candidates = [2,3,6,7], target = 7`\\n```\\n[2]\\n[2, 2]\\n[2, 2, 2]\\n[2, 2, 3]\\n[2, 3]\\n[3]\\n[3, 3]\\n[6]\\n[7]\\n```\\n****\\n```\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        if (candidates == null || candidates.length == 0)\\n            return new ArrayList<>();\\n        \\n        List<List<Integer>> allRes = new ArrayList<>();\\n        combinationSumAfter(candidates, target, new ArrayList<>(), allRes, 0);\\n        return allRes;\\n    }\\n    \\n    private void combinationSumAfter(int[] candidates, int target, List<Integer> curRes, List<List<Integer>> allRes, int start) {\\n        if (target == 0) {\\n            // Base case.\\n            allRes.add(new ArrayList<>(curRes));\\n            return;\\n        }\\n        // Recursive case.\\n        for (int i = start; i < candidates.length; i++) {\\n            if (target - candidates[i] < 0) continue;\\n            curRes.add(candidates[i]);\\n            // System.out.println(curRes);\\n            combinationSumAfter(candidates, target - candidates[i], curRes, allRes, i);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n[2]\\n[2, 2]\\n[2, 2, 2]\\n[2, 2, 3]\\n[2, 3]\\n[3]\\n[3, 3]\\n[6]\\n[7]\\n```\n```\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        if (candidates == null || candidates.length == 0)\\n            return new ArrayList<>();\\n        \\n        List<List<Integer>> allRes = new ArrayList<>();\\n        combinationSumAfter(candidates, target, new ArrayList<>(), allRes, 0);\\n        return allRes;\\n    }\\n    \\n    private void combinationSumAfter(int[] candidates, int target, List<Integer> curRes, List<List<Integer>> allRes, int start) {\\n        if (target == 0) {\\n            // Base case.\\n            allRes.add(new ArrayList<>(curRes));\\n            return;\\n        }\\n        // Recursive case.\\n        for (int i = start; i < candidates.length; i++) {\\n            if (target - candidates[i] < 0) continue;\\n            curRes.add(candidates[i]);\\n            // System.out.println(curRes);\\n            combinationSumAfter(candidates, target - candidates[i], curRes, allRes, i);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3363912,
                "title": "backtracking-with-python3-well-explantation-easy-clear",
                "content": "# Intuition:\\nThe problem requires finding all possible combinations of elements from a given list of integers such that their sum is equal to a target value. The approach is to use backtracking to generate all possible combinations and keep track of the valid ones.\\n\\n# Approach:\\nThe given code defines a class Solution and a function combinationSum that takes a list of integers and a target value as input and returns a list of lists containing all valid combinations of integers that add up to the target value.\\n\\nThe approach used is recursive backtracking. The backtracking function takes two arguments, curr which represents the current combination and i which represents the index of the next element to be added to the combination.\\n\\nInitially, the current combination is empty and the index i is set to zero. Then, for each index j starting from i, the backtracking function is called recursively with the updated combination curr+[can[j]] and the index j. This ensures that all possible combinations are explored.\\n\\nThe function also checks if the current combination sum equals the target value and adds it to the result list if it is valid.\\n\\n# Complexity:\\n# Time complexity: \\nThe time complexity of the backtracking function is O(2^n), where n is the length of the input list can. This is because there are 2^n possible combinations of elements from the input list. Therefore, the time complexity of the entire function is O(2^n) as well.\\n\\n# Space complexity: \\nThe space complexity of the backtracking function is O(n) as the maximum number of elements that can be stored in the current combination at any point is n. The space complexity of the entire function is also O(2^n) as there can be at most 2^n valid combinations.\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum(self, can: List[int], target: int) -> List[List[int]]:\\n        res=[]\\n        def backtracking(curr: List[int],i:int):\\n            s=sum(curr)\\n            if s==target:\\n                res.append(curr)\\n            elif s<target:\\n                for j in range(i,len(can)):\\n                    backtracking(curr+[can[j]],j)\\n        backtracking([],0)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, can: List[int], target: int) -> List[List[int]]:\\n        res=[]\\n        def backtracking(curr: List[int],i:int):\\n            s=sum(curr)\\n            if s==target:\\n                res.append(curr)\\n            elif s<target:\\n                for j in range(i,len(can)):\\n                    backtracking(curr+[can[j]],j)\\n        backtracking([],0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905794,
                "title": "100-fastest-swift-solution-time-o-n-m-space-o-m",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n^m), where n is the length of candidates and m is the target value.\\n    //   - space: O(m), where m is the target value.\\n    \\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var comb = [Int]()\\n        \\n        backtrack(remain: target, comb: &comb, start: 0, candidates: candidates, ans: &ans)\\n        return ans\\n    }\\n\\n\\n    private func backtrack(remain: Int, comb: inout [Int], start: Int, candidates: [Int], ans: inout [[Int]]) {\\n        guard remain >= 0 else { return }\\n        guard remain != 0 else { ans.append(comb); return }\\n\\n        for i in start..<candidates.count {\\n            comb.append(candidates[i])\\n            backtrack(remain: remain - candidates[i], comb: &comb, start: i, candidates: candidates, ans: &ans)\\n            comb.removeLast()\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n^m), where n is the length of candidates and m is the target value.\\n    //   - space: O(m), where m is the target value.\\n    \\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var comb = [Int]()\\n        \\n        backtrack(remain: target, comb: &comb, start: 0, candidates: candidates, ans: &ans)\\n        return ans\\n    }\\n\\n\\n    private func backtrack(remain: Int, comb: inout [Int], start: Int, candidates: [Int], ans: inout [[Int]]) {\\n        guard remain >= 0 else { return }\\n        guard remain != 0 else { ans.append(comb); return }\\n\\n        for i in start..<candidates.count {\\n            comb.append(candidates[i])\\n            backtrack(remain: remain - candidates[i], comb: &comb, start: i, candidates: candidates, ans: &ans)\\n            comb.removeLast()\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595577,
                "title": "my-solution",
                "content": "```\\ndef comboSum(target,candidates):\\n    \\'\\'\\'\\n    1. No duplicates\\n    2. Same number can be repeated\\n    3. Same combo is not repeated\\n\\n    \\'\\'\\'\\n\\n    result = []\\n\\n    def helper(start,sum_so_far,subset,level=0):\\n        space= \\' \\'*level\\n        print(f\\'{space} {subset}\\')\\n        if sum_so_far == target:\\n            result.append(subset[::])\\n            return\\n        if sum_so_far > target:\\n            return\\n\\n        for i in range(start,len(candidates)):\\n            num = candidates[i]\\n            subset.append(num)\\n            sum_so_far +=num\\n            level+=1\\n            helper(i,sum_so_far,subset,level)\\n            level-=1\\n            sum_so_far -=num\\n            subset.pop()\\n\\n    helper(0,0,[])\\n    return result\\n\\nif __name__ == \"__main__\":\\n    candidates = [1,2,3]\\n    target = 3\\n    print(comboSum(target,candidates))\\n\\t```",
                "solutionTags": [],
                "code": "```\\ndef comboSum(target,candidates):\\n    \\'\\'\\'\\n    1. No duplicates\\n    2. Same number can be repeated\\n    3. Same combo is not repeated\\n\\n    \\'\\'\\'\\n\\n    result = []\\n\\n    def helper(start,sum_so_far,subset,level=0):\\n        space= \\' \\'*level\\n        print(f\\'{space} {subset}\\')\\n        if sum_so_far == target:\\n            result.append(subset[::])\\n            return\\n        if sum_so_far > target:\\n            return\\n\\n        for i in range(start,len(candidates)):\\n            num = candidates[i]\\n            subset.append(num)\\n            sum_so_far +=num\\n            level+=1\\n            helper(i,sum_so_far,subset,level)\\n            level-=1\\n            sum_so_far -=num\\n            subset.pop()\\n\\n    helper(0,0,[])\\n    return result\\n\\nif __name__ == \"__main__\":\\n    candidates = [1,2,3]\\n    target = 3\\n    print(comboSum(target,candidates))\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1560722,
                "title": "java-easy-solution-100-faster-recursion-and-backtracking",
                "content": "## Combination Sum\\n\\n![image](https://assets.leetcode.com/users/images/a0d936b8-ff90-48d7-9233-1235eaadf933_1636105505.476083.png)\\n\\n\\nThere are similar questions like 2sum, 3sum, 4sum in which we were required to find a given number of elements from array whose sum is equal to target element, but in this problem we are required to find all the possible subarray or sublists.\\nThe approach for this problem is similar to other problems on finding [subsets](https://leetcode.com/problems/subsets-ii/) and [permutation](https://leetcode.com/problems/permutations/).\\n\\n**Code**\\n\\n```java\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\tList<List<Integer>> list = new ArrayList<>();\\n\\tcombinationUtil(list, new ArrayList<>(), candidates, 0, target);\\n\\treturn list;\\n}\\n\\npublic void combinationUtil(List<List<Integer>> list, List<Integer> temp, int[] candidates, int start, int target) {\\n\\t// base case\\n\\tif(target == 0) {\\n\\t\\tlist.add(new ArrayList<>(temp));\\n\\t\\treturn;\\n\\t}\\n\\n\\t// recursion step\\n\\tfor(int i = start; i < candidates.length; i++) {\\n\\t\\tif(target < candidates[i]) continue;\\n\\n\\t\\ttemp.add(candidates[i]);\\n\\t\\tcombinationUtil(list, temp, candidates, i, target - candidates[i]);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\t}\\n}\\n```\\n\\n**Explanation**\\nSo we were required to find all the sub lists in which sum of elements equal to target given and each element can be taken any number of times. \\nLet\\'s understand recursive step first\\n\\n```java\\nfor(int i = start; i < candidates.length; i++) {\\n\\tif(target < candidates[i]) continue;\\n\\n\\ttemp.add(candidates[i]);\\n\\tcombinationUtil(list, temp, candidates, i, target - candidates[i]);\\n\\ttemp.remove(temp.size() - 1);\\n}\\n```\\n\\nHere I am starting from `0th index` and if the element is greater than or equal to the target then only I add that to my `temp` list otherwise `continue`, after adding to `temp` list make further call on to subarray starting from same `i` because it is given that same element can be taken as many times, so we have to consider the same element and check weather it makes a pair not.\\nThen after solving for `i` remove last element of temp and increment `i` to check for pair starting from next element. Do not forget to initialise `i` to `start` because we don\\'t want to start again from the `0th index` as that will give us duplicates.\\n\\n\\n![image](https://assets.leetcode.com/users/images/92604850-3aa5-402c-a76d-ada2b9581bfa_1636106847.534792.png)\\n\\nHope it helps\\nDo upvote\\nThanks\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\tList<List<Integer>> list = new ArrayList<>();\\n\\tcombinationUtil(list, new ArrayList<>(), candidates, 0, target);\\n\\treturn list;\\n}\\n\\npublic void combinationUtil(List<List<Integer>> list, List<Integer> temp, int[] candidates, int start, int target) {\\n\\t// base case\\n\\tif(target == 0) {\\n\\t\\tlist.add(new ArrayList<>(temp));\\n\\t\\treturn;\\n\\t}\\n\\n\\t// recursion step\\n\\tfor(int i = start; i < candidates.length; i++) {\\n\\t\\tif(target < candidates[i]) continue;\\n\\n\\t\\ttemp.add(candidates[i]);\\n\\t\\tcombinationUtil(list, temp, candidates, i, target - candidates[i]);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\t}\\n}\\n```\n```java\\nfor(int i = start; i < candidates.length; i++) {\\n\\tif(target < candidates[i]) continue;\\n\\n\\ttemp.add(candidates[i]);\\n\\tcombinationUtil(list, temp, candidates, i, target - candidates[i]);\\n\\ttemp.remove(temp.size() - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1382280,
                "title": "c-recursive-solution-easy-to-understand",
                "content": "```\\n   vector<vector<int>> ans;\\n    void solve(vector<int>& candidates, int target,int i,int sum,vector<int> temp)\\n    {\\n        \\n        if(target==sum )\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(sum>target || i>=candidates.size())\\n            return;\\n        temp.push_back(candidates[i]);\\n        solve(candidates,target,i,sum+candidates[i],temp);\\n        temp.pop_back();\\n        solve(candidates,target,i+1,sum,temp);\\n      \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target)\\n    {\\n        vector<int> temp;\\n        solve(candidates,target,0,0,temp);\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n   vector<vector<int>> ans;\\n    void solve(vector<int>& candidates, int target,int i,int sum,vector<int> temp)\\n    {\\n        \\n        if(target==sum )\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(sum>target || i>=candidates.size())\\n            return;\\n        temp.push_back(candidates[i]);\\n        solve(candidates,target,i,sum+candidates[i],temp);\\n        temp.pop_back();\\n        solve(candidates,target,i+1,sum,temp);\\n      \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target)\\n    {\\n        vector<int> temp;\\n        solve(candidates,target,0,0,temp);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 616872,
                "title": "intuitive-javascript-solution-with-backtracking",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n  const output = [];\\n   //The goal is to use backtracking to find all combinations.\\n  const findCombination = (remain, path, start) => {\\n    if (remain < 0) {\\n      return;\\n    }\\n    if (remain === 0) {\\n      output.push([...path]);\\n      return;\\n    }\\n    for (let i = start; i < candidates.length; i++) {\\n      // create a new path array to run the subroutine. It\\'s\\n      // cleaner than pushing and then reseting the array in \\n      // javascript.\\n      findCombination(remain - candidates[i], [...path, candidates[i]], i);    \\n    }\\n  }\\n  findCombination(target, [], 0);\\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n  const output = [];\\n   //The goal is to use backtracking to find all combinations.\\n  const findCombination = (remain, path, start) => {\\n    if (remain < 0) {\\n      return;\\n    }\\n    if (remain === 0) {\\n      output.push([...path]);\\n      return;\\n    }\\n    for (let i = start; i < candidates.length; i++) {\\n      // create a new path array to run the subroutine. It\\'s\\n      // cleaner than pushing and then reseting the array in \\n      // javascript.\\n      findCombination(remain - candidates[i], [...path, candidates[i]], i);    \\n    }\\n  }\\n  findCombination(target, [], 0);\\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389405,
                "title": "combination-1-method-for-6-problems-39-40-77-78-90-216",
                "content": "# Main Idea\\nAfter finishing all these problem, I found that the answers of the leetcode GOD, @caikehe, all use similar approach. So I challenge myself to try out DFS. I think DFS is more easy to understand.\\n\\nThe DFS function\\'s structure can mostly break down into\\n1. Check if it is the path we are looking for, if true, append it to the output.\\n2. Explore (loop through) all the possible next node and call its DFS and we may need to add some kind of constraints in the DFS to fullfill the requirement. For example, limit the possible next node in the next DFS, so we can only select in ascending order.\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/)\\n```python\\nclass Solution(object):\\n    def combinationSum(self, candidates, T):\\n        def dfs(min_i, target, path):\\n            if target<0:\\n                return\\n            elif target==0:\\n                opt.append(path)\\n            else:\\n                for i in xrange(min_i, len(candidates)):\\n                    num = candidates[i]\\n                    dfs(i, target-num, path+[num])\\n        opt = []\\n        candidates.sort()\\n        dfs(0, T, [])\\n        return opt\\n\"\"\"\\nThe key is to pick up number by ascending order, so we will not have duplicates.\\nIn order to do that, we use `min_i`, `min_i` means that we can only select index that is larger than `min_i`\\n\"\"\"\\n```\\n\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)\\n```python\\nclass Solution(object):\\n    def combinationSum2(self, candidates, T):\\n        def dfs(min_i, target, path):\\n            if target<0:\\n                return\\n            elif target==0:\\n                opt.append(path)\\n            else:\\n                for i in xrange(min_i, len(candidates)):\\n                    if i>min_i and candidates[i]==candidates[i-1]: continue #[2]\\n                    num = candidates[i]\\n                    dfs(i+1, target-num, path+[num]) #[1]\\n        opt = []\\n        candidates.sort()\\n        dfs(0, T, [])\\n        return opt\\n\"\"\"\\n1.\\nIn this problem, we can only select each number once.\\nThat is why we pass `i+1` to the `dfs()`.\\n\\n2.\\nAnother thing is preventing duplicates.\\nFor example, `[1,2,2,2,3]`\\nWe may end up using the first 2, the second 2, the third 2 to make 3 `[2, 3]`.\\nSo when we are looping all the possible candidates\\nWe need to `continue` if it is the not the first one in all the same element.\\nBecuase the first element is going to cover all the possibilities in its own `dfs()`.\\n\"\"\"\\n```\\n\\n[77. Combinations](https://leetcode.com/problems/combinations/)\\n```python\\nclass Solution(object):\\n    def combine(self, N, K):\\n        def dfs(min_num, path):\\n            if len(path)==K:\\n                opt.append(path)\\n                return\\n            else:\\n                for num in xrange(min_num, N+1):\\n                    dfs(num+1, path+[num])\\n        opt = []\\n        dfs(1, [])\\n        return opt\\n```\\n\\n# [90. Subsets II](https://leetcode.com/problems/subsets-ii/)\\n```python\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        nums.sort()\\n\\n        def dfs(nums, path):\\n            opt.append(path)\\n            if len(nums)==0: return\\n            for i, num in enumerate(nums):\\n                if i>0 and nums[i]==nums[i-1]: continue #[0]\\n                dfs(path+[num], nums[i+1:])\\n        opt = []\\n        dfs([], nums)\\n        return opt\\n\"\"\"\\nSince there is duplicate in the `nums`, if the `num` is the same as the previous, we need to skip it.\\nBecause in the previous DFS, the out come has include the existance of current node.\\n\"\"\"\\n```\\n\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/)\\n```python\\nclass Solution(object):\\n    def combinationSum3(self, K, N):\\n        def dfs(min_num, path):\\n            if len(path)==K and sum(path)==N:\\n                opt.append(path)\\n            for num in xrange(min_num, 10):\\n                dfs(path+[num], num+1)\\n        opt = []\\n        dfs([], 1)\\n        return opt\\n```\\n\\n# Big O\\nThe big O of these question are complicated and hard to analize. But according to some resource, all the combination problems are derived to be `O(2^N)`, N is the number of element. (`let s = target / min(nums[i])  T = C(s,1) + C(s, 2) + ... + C(s, s) = 2^s`) You can think of this answer as for each element it got two choices, to be chosen or not to be chosen.\\n\\nThe Space complexity is also `O(2^N)`, because we use recusive DFS. If we convert above to be iterative DFS, it may reduce to `O(N)`.\\n\\n# More Resources\\nCheck out my GitHub, https://github.com/wuduhren/leetcode-python for other topics.  \\nI really take time tried to make the best solution or explaination. Because I wanted to help others like me.  \\nIf you like my answer, a **star** on [GitHub](https://github.com/wuduhren/leetcode-python) means a lot to me.",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def combinationSum(self, candidates, T):\\n        def dfs(min_i, target, path):\\n            if target<0:\\n                return\\n            elif target==0:\\n                opt.append(path)\\n            else:\\n                for i in xrange(min_i, len(candidates)):\\n                    num = candidates[i]\\n                    dfs(i, target-num, path+[num])\\n        opt = []\\n        candidates.sort()\\n        dfs(0, T, [])\\n        return opt\\n\"\"\"\\nThe key is to pick up number by ascending order, so we will not have duplicates.\\nIn order to do that, we use `min_i`, `min_i` means that we can only select index that is larger than `min_i`\\n\"\"\"\\n```\n```python\\nclass Solution(object):\\n    def combinationSum2(self, candidates, T):\\n        def dfs(min_i, target, path):\\n            if target<0:\\n                return\\n            elif target==0:\\n                opt.append(path)\\n            else:\\n                for i in xrange(min_i, len(candidates)):\\n                    if i>min_i and candidates[i]==candidates[i-1]: continue #[2]\\n                    num = candidates[i]\\n                    dfs(i+1, target-num, path+[num]) #[1]\\n        opt = []\\n        candidates.sort()\\n        dfs(0, T, [])\\n        return opt\\n\"\"\"\\n1.\\nIn this problem, we can only select each number once.\\nThat is why we pass `i+1` to the `dfs()`.\\n\\n2.\\nAnother thing is preventing duplicates.\\nFor example, `[1,2,2,2,3]`\\nWe may end up using the first 2, the second 2, the third 2 to make 3 `[2, 3]`.\\nSo when we are looping all the possible candidates\\nWe need to `continue` if it is the not the first one in all the same element.\\nBecuase the first element is going to cover all the possibilities in its own `dfs()`.\\n\"\"\"\\n```\n```python\\nclass Solution(object):\\n    def combine(self, N, K):\\n        def dfs(min_num, path):\\n            if len(path)==K:\\n                opt.append(path)\\n                return\\n            else:\\n                for num in xrange(min_num, N+1):\\n                    dfs(num+1, path+[num])\\n        opt = []\\n        dfs(1, [])\\n        return opt\\n```\n```python\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        nums.sort()\\n\\n        def dfs(nums, path):\\n            opt.append(path)\\n            if len(nums)==0: return\\n            for i, num in enumerate(nums):\\n                if i>0 and nums[i]==nums[i-1]: continue #[0]\\n                dfs(path+[num], nums[i+1:])\\n        opt = []\\n        dfs([], nums)\\n        return opt\\n\"\"\"\\nSince there is duplicate in the `nums`, if the `num` is the same as the previous, we need to skip it.\\nBecause in the previous DFS, the out come has include the existance of current node.\\n\"\"\"\\n```\n```python\\nclass Solution(object):\\n    def combinationSum3(self, K, N):\\n        def dfs(min_num, path):\\n            if len(path)==K and sum(path)==N:\\n                opt.append(path)\\n            for num in xrange(min_num, 10):\\n                dfs(path+[num], num+1)\\n        opt = []\\n        dfs([], 1)\\n        return opt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16754,
                "title": "simple-java-solution",
                "content": "\\n    List<List<Integer>> res = new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        helper(candidates, 0, target, new ArrayList<Integer>());\\n        return res;\\n    }\\n    \\n    private void helper(int[] can, int start, int target,List<Integer> each) {\\n        for (int i = start; i < can.length; i++) {\\n            List<Integer> temp = new ArrayList<>(each);\\n            if (can[i] == target) {\\n                temp.add(can[i]);\\n                res.add(temp);\\n                break;\\n            } else if (can[i] < target) {\\n                temp.add(can[i]);\\n                helper(can, i, target - can[i], new ArrayList<>(temp));\\n            } else {break;}\\n        }\\n        return;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    List<List<Integer>> res = new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        helper(candidates, 0, target, new ArrayList<Integer>());\\n        return res;\\n    }\\n    \\n    private void helper(int[] can, int start, int target,List<Integer> each) {\\n        for (int i = start; i < can.length; i++) {\\n            List<Integer> temp = new ArrayList<>(each);\\n            if (can[i] == target) {\\n                temp.add(can[i]);\\n                res.add(temp);\\n                break;\\n            } else if (can[i] < target) {\\n                temp.add(can[i]);\\n                helper(can, i, target - can[i], new ArrayList<>(temp));\\n            } else {break;}\\n        }\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2378220,
                "title": "simple-java-solution-with-full-explanation-easy-to-understand-recursion-tree-drawn",
                "content": "```\\nPlease  \\uD83D\\uDD3C this.solution if(you understood == true)\\n```\\n\\nFirstly if we need to make anytype of choices we can use recursion like to pick the element or to not pick it :\\n\\n##### Recursive Function Call will take arguements :\\n\\n1. `index = 0`\\n2. array(candidates in this case)\\n3. target\\n4. ans `List<<List>>`\\n5. empty `List<>` \\n\\nhere like in case : [2,3,6,7] when target = 7 \\n\\n**Function Call will look Like this** : `combinationsFinder(index,arr,target,list<list<>>,list<>)`\\n\\n***Steps I took to solve:***\\n\\n1. Start from 0 index element i.e 2\\n\\n2. Now we have 2 choices either pick it or leave it (all about recursion)\\n\\n3. Like if we pick it then target will become 5 as 2 is already taken hence (target = target - candidates[i]) and then we will not increase the index as an element can be taken multiple times. We will add this to an ArrayList or Vector as per language pref. after function got called we will remove that element from the list.\\n\\n4. Second choice: if we not pick it target will remain as it is and index will increment by 1 (index = index+1). We will pass the list as it is (empty as no element added). Note: we are not picking element only if it greater than target. \\n\\n5. and lastly for the base condition (no more recursion call) if the target becomes 0 when our index reaches length of array we will add empty arrayList else return\\n\\n\\n**Recursion Tree HandDrawn (ps dont mind my drawing) :**\\n\\n![image](https://assets.leetcode.com/users/images/b152d9f9-f6ef-428b-afd5-28707474c205_1659611996.5682747.png)\\n\\n**Hope You Understood and If you all liked the explanation please upvote this Post** \\uD83D\\uDE0A\\n\\n***My Java Code is \\uD83D\\uDC47\\uD83C\\uDF55***\\n```\\n// Best Approach : Combinations - Recursion - PickNotPick\\n// Time Complexity : O(2^n*k)  -> k : length of arraylist\\n// Space Complexity : O(k)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        combinationsFinder(candidates,0,target,new ArrayList<>(),ans);\\n        \\n        return ans;\\n    }\\n    \\n    static void combinationsFinder(int[] arr,int idx,int target,List<Integer> list,List<List<Integer>> ans){\\n        \\n        if(idx == arr.length){\\n            if(target==0) ans.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        if(arr[idx]<=target){\\n            list.add(arr[idx]);\\n            combinationsFinder(arr,idx,target - arr[idx],list,ans);\\n            list.remove(list.size() - 1);\\n        }\\n        combinationsFinder(arr,idx+1,target,list,ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nPlease  \\uD83D\\uDD3C this.solution if(you understood == true)\\n```\n```\\n// Best Approach : Combinations - Recursion - PickNotPick\\n// Time Complexity : O(2^n*k)  -> k : length of arraylist\\n// Space Complexity : O(k)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        combinationsFinder(candidates,0,target,new ArrayList<>(),ans);\\n        \\n        return ans;\\n    }\\n    \\n    static void combinationsFinder(int[] arr,int idx,int target,List<Integer> list,List<List<Integer>> ans){\\n        \\n        if(idx == arr.length){\\n            if(target==0) ans.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        if(arr[idx]<=target){\\n            list.add(arr[idx]);\\n            combinationsFinder(arr,idx,target - arr[idx],list,ans);\\n            list.remove(list.size() - 1);\\n        }\\n        combinationsFinder(arr,idx+1,target,list,ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918913,
                "title": "easy-c-solution-using-recursion-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We can take an element multiple times and add them to get the target value.\\n- We\\u2019re using the help function where the base case is if the index reaches the last of our candidates array & the target became 0 then we\\u2019ll push temp to ans vector.\\n- Now there could be 2 possible cases:\\n    1. We\\u2019ll include the current element to our temp variable:\\n        - Check the current index value if it\\u2019s less than target then we can push it to temp and consider this as a part of our ans vector. Reduce the value from target.\\n        - after that we\\u2019ll pop the element from temp, as when it return from this call means that value didn\\u2019t give us expected ans.\\n    2. We won\\u2019t include the current element and move to the next element.\\n- **Time complexity:** O(2^k), where k is the sum of target/candidate[i] from i = 0 to size of candidate - 1.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        help(0, candidates, target, ans, temp);\\n        return ans;\\n    }\\n    \\n    void help(int index, vector<int>& candidates, int target, vector<vector<int>> &ans, vector<int> &temp){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n            \\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            help(index, candidates, target-candidates[index], ans, temp);\\n            temp.pop_back();\\n        }\\n        help(index+1, candidates, target, ans, temp);\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        help(0, candidates, target, ans, temp);\\n        return ans;\\n    }\\n    \\n    void help(int index, vector<int>& candidates, int target, vector<vector<int>> &ans, vector<int> &temp){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n            \\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            help(index, candidates, target-candidates[index], ans, temp);\\n            temp.pop_back();\\n        }\\n        help(index+1, candidates, target, ans, temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875295,
                "title": "javascript-typescript-dfs-solution-w-detailed-comments",
                "content": "**javascript:**\\n```\\nfunction combinationSum(candidates, target) {\\n    // result of all combinations that sum to target\\n    var res = [];\\n\\t\\n    /**\\n     * helper dfs method to generate all paths that sum to target\\n     * @param path current dfs path of numbers\\n     * @param sum current sum of numbers\\n     * @param last last index drawn\\n     */\\n    function dfs(path, sum, last) {\\n        // check if we\\'ve reached target sum (this is valid combo)\\n        if (sum === target) {\\n            // push to res and return to break\\n            res.push(path);\\n            return;\\n        }\\n        // iterate thru children (candidates in this case)\\n        // except, we start at last candidate drawn, to avoid duplicates\\n        for (var i = last; i < candidates.length; i++) {\\n            // check to see if adding this candidate can contribute to sum\\n            // don\\'t do anything if it exceeds (it won\\'t be valid)\\n            if (sum + candidates[i] <= target) {\\n                // note, it\\'s important we spread path (make a copy of it)\\n                // so that all calls in recursion tree aren\\'t modifying same array\\n                dfs([...path, candidates[i]], sum + candidates[i], i);\\n            }\\n        }\\n    }\\n\\t\\n    // sort candidates ascending. the reason why we do this is because, in our dfs,\\n    // when we\\'re going through candidates, and a number is too big for target (exceeds)\\n    // we don\\'t want to continue to the next number, it will only be bigger\\n    candidates.sort(function (a, b) {\\n        return a - b;\\n    });\\n\\t\\n    // start dfs (initial empty path, because none visited yet, so sum also 0)\\n    dfs([], 0, 0);\\n\\t\\n    return res;\\n}\\n```\\n\\n**typescript:**\\n```\\nfunction combinationSum(candidates: number[], target: number): number[][] {\\n    // result of all combinations that sum to target\\n    const res: number[][] = [];\\n\\n    /**\\n     * helper dfs method to generate all paths that sum to target\\n     * @param path current dfs path of numbers\\n     * @param sum current sum of numbers\\n     * @param last last index drawn\\n     */\\n    function dfs(path: number[], sum: number, last: number): void {\\n        // check if we\\'ve reached target sum (this is valid combo)\\n        if (sum === target) {\\n            // push to res and return to break\\n            res.push(path);\\n            return;\\n        }\\n\\n        // iterate thru children (candidates in this case)\\n        // except, we start at last candidate drawn, to avoid duplicates\\n        for (let i = last; i < candidates.length; i++) {\\n            // check to see if adding this candidate can contribute to sum\\n            // don\\'t do anything if it exceeds (it won\\'t be valid)\\n            if (sum + candidates[i] <= target) {\\n                // note, it\\'s important we spread path (make a copy of it)\\n                // so that all calls in recursion tree aren\\'t modifying same array\\n                dfs([...path, candidates[i]], sum + candidates[i], i);\\n            }\\n        }\\n    }\\n\\n    // sort candidates ascending. the reason why we do this is because, in our dfs,\\n    // when we\\'re going through candidates, and a number is too big for target (exceeds)\\n    // we don\\'t want to continue to the next number, it will only be bigger\\n    candidates.sort((a, b) => a - b);\\n\\n    // start dfs (initial empty path, because none visited yet, so sum also 0)\\n    dfs([], 0, 0);\\n\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction combinationSum(candidates, target) {\\n    // result of all combinations that sum to target\\n    var res = [];\\n\\t\\n    /**\\n     * helper dfs method to generate all paths that sum to target\\n     * @param path current dfs path of numbers\\n     * @param sum current sum of numbers\\n     * @param last last index drawn\\n     */\\n    function dfs(path, sum, last) {\\n        // check if we\\'ve reached target sum (this is valid combo)\\n        if (sum === target) {\\n            // push to res and return to break\\n            res.push(path);\\n            return;\\n        }\\n        // iterate thru children (candidates in this case)\\n        // except, we start at last candidate drawn, to avoid duplicates\\n        for (var i = last; i < candidates.length; i++) {\\n            // check to see if adding this candidate can contribute to sum\\n            // don\\'t do anything if it exceeds (it won\\'t be valid)\\n            if (sum + candidates[i] <= target) {\\n                // note, it\\'s important we spread path (make a copy of it)\\n                // so that all calls in recursion tree aren\\'t modifying same array\\n                dfs([...path, candidates[i]], sum + candidates[i], i);\\n            }\\n        }\\n    }\\n\\t\\n    // sort candidates ascending. the reason why we do this is because, in our dfs,\\n    // when we\\'re going through candidates, and a number is too big for target (exceeds)\\n    // we don\\'t want to continue to the next number, it will only be bigger\\n    candidates.sort(function (a, b) {\\n        return a - b;\\n    });\\n\\t\\n    // start dfs (initial empty path, because none visited yet, so sum also 0)\\n    dfs([], 0, 0);\\n\\t\\n    return res;\\n}\\n```\n```\\nfunction combinationSum(candidates: number[], target: number): number[][] {\\n    // result of all combinations that sum to target\\n    const res: number[][] = [];\\n\\n    /**\\n     * helper dfs method to generate all paths that sum to target\\n     * @param path current dfs path of numbers\\n     * @param sum current sum of numbers\\n     * @param last last index drawn\\n     */\\n    function dfs(path: number[], sum: number, last: number): void {\\n        // check if we\\'ve reached target sum (this is valid combo)\\n        if (sum === target) {\\n            // push to res and return to break\\n            res.push(path);\\n            return;\\n        }\\n\\n        // iterate thru children (candidates in this case)\\n        // except, we start at last candidate drawn, to avoid duplicates\\n        for (let i = last; i < candidates.length; i++) {\\n            // check to see if adding this candidate can contribute to sum\\n            // don\\'t do anything if it exceeds (it won\\'t be valid)\\n            if (sum + candidates[i] <= target) {\\n                // note, it\\'s important we spread path (make a copy of it)\\n                // so that all calls in recursion tree aren\\'t modifying same array\\n                dfs([...path, candidates[i]], sum + candidates[i], i);\\n            }\\n        }\\n    }\\n\\n    // sort candidates ascending. the reason why we do this is because, in our dfs,\\n    // when we\\'re going through candidates, and a number is too big for target (exceeds)\\n    // we don\\'t want to continue to the next number, it will only be bigger\\n    candidates.sort((a, b) => a - b);\\n\\n    // start dfs (initial empty path, because none visited yet, so sum also 0)\\n    dfs([], 0, 0);\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16550,
                "title": "swift-solution-backtracking",
                "content": "```\\nclass Solution {\\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var result = [[Int]]()\\n        var candidate = [Int]()\\n        \\n        backtracking(&result, &candidate, candidates.sorted(), target, 0)\\n        \\n        return result\\n    }\\n    \\n    private func backtracking(_ result: inout [[Int]], _ candidate: inout [Int], _ candidates: [Int], _ remain: Int, _ start: Int) {\\n        if remain < 0 {\\n            return\\n        } else if remain == 0 {\\n            result.append(candidate)\\n        } else {\\n            for i in start..<candidates.count {\\n                candidate.append(candidates[i])\\n                backtracking(&result, &candidate, candidates, remain - candidates[i], i)\\n                candidate.removeLast()\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var result = [[Int]]()\\n        var candidate = [Int]()\\n        \\n        backtracking(&result, &candidate, candidates.sorted(), target, 0)\\n        \\n        return result\\n    }\\n    \\n    private func backtracking(_ result: inout [[Int]], _ candidate: inout [Int], _ candidates: [Int], _ remain: Int, _ start: Int) {\\n        if remain < 0 {\\n            return\\n        } else if remain == 0 {\\n            result.append(candidate)\\n        } else {\\n            for i in start..<candidates.count {\\n                candidate.append(candidates[i])\\n                backtracking(&result, &candidate, candidates, remain - candidates[i], i)\\n                candidate.removeLast()\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16719,
                "title": "16-lines-concise-and-easy-understand-c-solution-backtracking",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, tmp, candidates, target, 0);\\n            return res;\\n        }\\n        void backtracking(vector<vector<int>>& res, vector<int>& tmp, vector<int>& candidates, int target, int index){\\n            if(target < 0) return;\\n            if(target == 0) {\\n                res.push_back(tmp);\\n                return;\\n            }\\n            for(int i = index; i < candidates.size(); i++){\\n                tmp.push_back(candidates[i]);\\n                backtracking(res, tmp, candidates, target - candidates[i], i);\\n                tmp.pop_back();\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, tmp, candidates, target, 0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 16761,
                "title": "c-backtracking-solution",
                "content": "        \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> nums;\\n        sort(candidates.begin(), candidates.end());\\n        dfs(candidates, target, 0, nums, res);\\n        return res;\\n    }\\n    \\n    void dfs(vector<int>& candidates, int target, int index, vector<int>& nums, vector<vector<int>>& res) {\\n        if (target < 0)\\n            return;\\n        if (target == 0) {\\n            res.push_back(nums);\\n            return;\\n        }\\n        for (int i=index; i<candidates.size(); i++) {\\n            nums.push_back(candidates[i]);\\n            dfs(candidates, target-candidates[i], i, nums, res);\\n            nums.pop_back();\\n        }\\n    }",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "        \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> nums;\\n        sort(candidates.begin(), candidates.end());\\n        dfs(candidates, target, 0, nums, res);\\n        return res;\\n    }\\n    \\n    void dfs(vector<int>& candidates, int target, int index, vector<int>& nums, vector<vector<int>>& res) {\\n        if (target < 0)\\n            return;\\n        if (target == 0) {\\n            res.push_back(nums);\\n            return;\\n        }\\n        for (int i=index; i<candidates.size(); i++) {\\n            nums.push_back(candidates[i]);\\n            dfs(candidates, target-candidates[i], i, nums, res);\\n            nums.pop_back();\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3534868,
                "title": "c-easy-to-understand",
                "content": "### Intuition:\\nThe problem requires us to find all unique combinations of numbers from the given candidates list that add up to the target value. We can start by considering each candidate as a possible choice at each step and recursively explore all possible paths until the target is reached or exceeded.\\n\\n\\n### Approach:\\n1. Create a vector to store all the unique combinations that add up to the target value. \\n2. Create a vector to store the current combination being explored.\\n3. Define a recursive helper function that takes in the candidates list, target value, start index, current combination, and the answer vector as parameters.\\n4. If the target value is reached, add the current combination to the answer vector and return.\\n5. If the target value is exceeded, return.\\n6. For each candidate starting from the start index, add it to the current combination and recursively call the helper function with the updated target value and start index.\\n7. After returning from the recursive call, remove the last added candidate from the current combination to explore other possibilities.\\n8. Return the answer vector.\\n \\n### Complexity:\\n- Time Complexity: The time complexity of the algorithm is O(N^target), where N is the length of the candidates list and target is the target value. This is because, in the worst-case scenario, we may have to explore all possible combinations of length target. \\n- Space Complexity: The space complexity of the algorithm is O(target) because of the recursive call stack. The space required to store the answer vector and the current combination is negligible compared to the stack space.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        helper(candidates, target, 0, curr, ans);\\n        return ans;\\n    }\\n    \\n    void helper(vector<int>& candidates, int target, int start, vector<int>& curr, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(target < 0){\\n            return;\\n        }\\n        for(int i=start; i<candidates.size(); i++){\\n            curr.push_back(candidates[i]);\\n            helper(candidates, target-candidates[i], i, curr, ans);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n\\n```\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        helper(candidates, target, 0, curr, ans);\\n        return ans;\\n    }\\n    \\n    void helper(vector<int>& candidates, int target, int start, vector<int>& curr, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(target < 0){\\n            return;\\n        }\\n        for(int i=start; i<candidates.size(); i++){\\n            curr.push_back(candidates[i]);\\n            helper(candidates, target-candidates[i], i, curr, ans);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211354,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all the given integers, and T is the target value. Thus the time complexity is exponential and this is expected because the algorithm is recursive backtracking.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(T/M), where T is the target value and M is the minimal element among all other candidates.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all\\n    the given integers, and T is the target value. Thus the time complexity is exponential and this is expected\\n    because the algorithm is recursive backtracking.\\n\\n    Space Complexity : O(T/M), where T is the target value and M is the minimal element among all other\\n    candidates.\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum(candidates, target-candidates[index], output, temp, index);\\n            temp.pop_back();\\n        }\\n        combinationSum(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all\\n    the given integers, and T is the target value. Thus the time complexity is exponential and this is expected\\n    because the algorithm is recursive backtracking.\\n\\n    Space Complexity : O(T/M), where T is the target value and M is the minimal element among all other\\n    candidates.\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                temp.push_back(candidates[i]);\\n                combinationSum(candidates, target-candidates[i], output, temp, i);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all\\n    the given integers, and T is the target value. Thus the time complexity is exponential and this is expected\\n    because the algorithm is recursive backtracking.\\n\\n    Space Complexity : O(T/M), where T is the target value and M is the minimal element among all other\\n    candidates.\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum(candidates, target-candidates[index], output, temp, index);\\n            temp.pop_back();\\n        }\\n        combinationSum(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all\\n    the given integers, and T is the target value. Thus the time complexity is exponential and this is expected\\n    because the algorithm is recursive backtracking.\\n\\n    Space Complexity : O(T/M), where T is the target value and M is the minimal element among all other\\n    candidates.\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                temp.push_back(candidates[i]);\\n                combinationSum(candidates, target-candidates[i], output, temp, i);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083701,
                "title": "94-javascript-fast-very-easy-to-understand-solution",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/kO95ZxxDpwI\\n\\n# Code\\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    let res = []\\n    let temp = []\\n    let iterate = (index,sum)=>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push([...temp])\\n            return;\\n        }\\n        for(let i =index; i<candidates.length;i++){\\n            if(candidates[i]>target)continue\\n            temp.push(candidates[i])\\n            iterate(i, sum+candidates[i])\\n            temp.pop()\\n        }\\n    }\\n    iterate(0,0)\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    let res = []\\n    let temp = []\\n    let iterate = (index,sum)=>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push([...temp])\\n            return;\\n        }\\n        for(let i =index; i<candidates.length;i++){\\n            if(candidates[i]>target)continue\\n            temp.push(candidates[i])\\n            iterate(i, sum+candidates[i])\\n            temp.pop()\\n        }\\n    }\\n    iterate(0,0)\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777024,
                "title": "java-dp",
                "content": "I solved this problem too many times with backtracking, lets solve it using DP (knapsack)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>>[] dp = new List[target + 1];\\n        dp[0] = new ArrayList<>();\\n        dp[0].add(new ArrayList<>());\\n          \\n        for (int c : candidates) {\\n            for (int i = c; i <= target; i++) {\\n                if (dp[i - c] != null) {\\n                    if (dp[i] == null)\\n                        dp[i] = new ArrayList<>();\\n                                    \\n                    for (List<Integer> list : dp[i - c]) {\\n                        List<Integer> copy = new ArrayList<>(list);\\n                        copy.add(c);\\n                        \\n                        dp[i].add(copy);\\n                    }\\n                }\\n            }            \\n        } \\n        \\n        return dp[target] == null ? new ArrayList<>() : dp[target];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>>[] dp = new List[target + 1];\\n        dp[0] = new ArrayList<>();\\n        dp[0].add(new ArrayList<>());\\n          \\n        for (int c : candidates) {\\n            for (int i = c; i <= target; i++) {\\n                if (dp[i - c] != null) {\\n                    if (dp[i] == null)\\n                        dp[i] = new ArrayList<>();\\n                                    \\n                    for (List<Integer> list : dp[i - c]) {\\n                        List<Integer> copy = new ArrayList<>(list);\\n                        copy.add(c);\\n                        \\n                        dp[i].add(copy);\\n                    }\\n                }\\n            }            \\n        } \\n        \\n        return dp[target] == null ? new ArrayList<>() : dp[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777011,
                "title": "java-recursion-4ms-daily-challenge-2-17-22",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        helper(candidates, target, 0, new ArrayList<Integer>());\\n        return res;\\n    }\\n    List<List<Integer>> res = new ArrayList<>();\\n    private void helper(int[] cands, int target, int stIdx, List<Integer> curList) {\\n        if (target == 0) res.add(curList);\\n        \\n        for (int i = stIdx; i < cands.length; i++) {\\n            if (cands[i] <= target) {\\n                List<Integer> list = new ArrayList<>(curList);\\n                list.add(cands[i]);\\n                helper(cands, target - cands[i], i, list);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        helper(candidates, target, 0, new ArrayList<Integer>());\\n        return res;\\n    }\\n    List<List<Integer>> res = new ArrayList<>();\\n    private void helper(int[] cands, int target, int stIdx, List<Integer> curList) {\\n        if (target == 0) res.add(curList);\\n        \\n        for (int i = stIdx; i < cands.length; i++) {\\n            if (cands[i] <= target) {\\n                List<Integer> list = new ArrayList<>(curList);\\n                list.add(cands[i]);\\n                helper(cands, target - cands[i], i, list);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874929,
                "title": "c-straightforward-backtracking-unbounded-knapsack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> combinations;\\n        vector<int> current;\\n        backtrack(candidates, target, 0, current, combinations);\\n        return combinations;\\n    }\\n    \\nprivate:\\n    void backtrack(vector<int>& candidates, int target, int index, vector<int>& current, vector<vector<int>>& combinations) {\\n        if (target == 0) {\\n            combinations.push_back(current);\\n            return;\\n        }\\n        if (target < 0 || index >= candidates.size()) return;\\n        current.push_back(candidates[index]);\\n        backtrack(candidates, target - current.back(), index, current, combinations);\\n        current.pop_back();\\n        backtrack(candidates, target, index + 1, current, combinations);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> combinations;\\n        vector<int> current;\\n        backtrack(candidates, target, 0, current, combinations);\\n        return combinations;\\n    }\\n    \\nprivate:\\n    void backtrack(vector<int>& candidates, int target, int index, vector<int>& current, vector<vector<int>>& combinations) {\\n        if (target == 0) {\\n            combinations.push_back(current);\\n            return;\\n        }\\n        if (target < 0 || index >= candidates.size()) return;\\n        current.push_back(candidates[index]);\\n        backtrack(candidates, target - current.back(), index, current, combinations);\\n        current.pop_back();\\n        backtrack(candidates, target, index + 1, current, combinations);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491067,
                "title": "python-simple-and-concise-clean-code",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates:\\n            return []\\n        \\n        ret = []\\n        \\n        def fn(nums, tmp):\\n            if sum(tmp) > target:\\n                return False\\n            elif sum(tmp) == target:\\n                ret.append(tmp)\\n                return True\\n            else:   # sum(tmp) < target\\n                for i in range(len(nums)):\\n                    fn(nums[i:],tmp+[nums[i]])\\n        \\n        fn(candidates,[])\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates:\\n            return []\\n        \\n        ret = []\\n        \\n        def fn(nums, tmp):\\n            if sum(tmp) > target:\\n                return False\\n            elif sum(tmp) == target:\\n                ret.append(tmp)\\n                return True\\n            else:   # sum(tmp) < target\\n                for i in range(len(nums)):\\n                    fn(nums[i:],tmp+[nums[i]])\\n        \\n        fn(candidates,[])\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 237525,
                "title": "python-simple-bactracking-solution-beats-99",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        ans = []\\n        def helper(candidates, target, t):\\n            if not target:\\n                ans.append(t)\\n                return\\n            for i, num in enumerate(candidates):\\n                if target >= num:\\n                    helper(candidates[i:], target - num, t + [num])\\n                else: break\\n        helper(candidates, target, [])\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        ans = []\\n        def helper(candidates, target, t):\\n            if not target:\\n                ans.append(t)\\n                return\\n            for i, num in enumerate(candidates):\\n                if target >= num:\\n                    helper(candidates[i:], target - num, t + [num])\\n                else: break\\n        helper(candidates, target, [])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16657,
                "title": "my-easy-understanding-dp-solution-c",
                "content": "Hi, here is my dp solution.  The idea is pretty similar with the dp solution of subset. :)\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;\\n        int size = candidates.size();\\n        if (size == 0) return result;\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<vector<int>>> dp(target + 1, vector<vector<int>>());\\n        dp[0].push_back(vector<int>());\\n        \\n        for (int i = 1; i <= target; ++i) {\\n            for (int j = 0; j < size && candidates[j] <= i; ++j) {\\n                for (int k = 0; k < dp[i - candidates[j]].size(); ++k) {\\n                    vector<int> temp = dp[i - candidates[j]][k];\\n                    if (temp.size() && (temp[temp.size() - 1] > candidates[j])) continue;\\n                    temp.push_back(candidates[j]);\\n                    dp[i].push_back(temp);\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "Hi, here is my dp solution.  The idea is pretty similar with the dp solution of subset. :)\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;\\n        int size = candidates.size();\\n        if (size == 0) return result;\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<vector<int>>> dp(target + 1, vector<vector<int>>());\\n        dp[0].push_back(vector<int>());\\n        \\n        for (int i = 1; i <= target; ++i) {\\n            for (int j = 0; j < size && candidates[j] <= i; ++j) {\\n                for (int k = 0; k < dp[i - candidates[j]].size(); ++k) {\\n                    vector<int> temp = dp[i - candidates[j]][k];\\n                    if (temp.size() && (temp[temp.size() - 1] > candidates[j])) continue;\\n                    temp.push_back(candidates[j]);\\n                    dp[i].push_back(temp);\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16758,
                "title": "javascript-solution",
                "content": "    function combinationSum(candidates, target) {\\n      candidates.sort((a, b) => a - b);\\n    \\n      var length = candidates.length;\\n      var res = [];\\n      search(0, [], target);\\n      return res;\\n    \\n      function search(idx, prefix, target) {\\n        if (target === 0) res.push(prefix.slice());\\n        if (idx === length) return;\\n        if (target <= 0) return;\\n    \\n        prefix.push(candidates[idx]);\\n        search(idx, prefix, target - candidates[idx]);\\n        prefix.pop();\\n        search(idx + 1, prefix, target);\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function combinationSum(candidates, target) {\\n      candidates.sort((a, b) => a - b);\\n    \\n      var length = candidates.length;\\n      var res = [];\\n      search(0, [], target);\\n      return res;\\n    \\n      function search(idx, prefix, target) {\\n        if (target === 0) res.push(prefix.slice());\\n        if (idx === length) return;\\n        if (target <= 0) return;\\n    \\n        prefix.push(candidates[idx]);\\n        search(idx, prefix, target - candidates[idx]);\\n        prefix.pop();\\n        search(idx + 1, prefix, target);\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 16829,
                "title": "a-recursive-yet-efficient-java-solution-with-explanation",
                "content": "The problem is a bit like N-queen problem, which is to say that we just need to enumerate all the possible solution recursively to get the final result. \\n\\nFirst of all, we need to sort the array, to ensure the combination to be unique and also the numbers in the combination to be listed in a non-descending order. \\n\\nThen, we define a recursive function with the signature as:  \\n\\n    combinationSum(int [] candidates, LinkedList vector, int start, int target)\\n\\nwhere `\\u201ccandidates\\u201d` is the list that we could take numbers from, `\\u201cvector\\u201d` is the list of combination that we have accumulated so far, `\\u201cstart\\u201d` is the starting point at which we could take numbers from forwards (no backwards), and `\\u201ctarget\\u201d` is the rest sum that we need to achieve.  \\n\\nAs a recursive function, the bottom cases for the combinationSum() are: \\n\\n1). The value of the `\\u201cstart\\u201d element` is equal to the `\\u201ctarget\\u201d`, we then find a combination, so just add the `\\u201cstart\\u201d element` to the `\\u201cvector\\u201d` and output the result. \\n\\n2). The value of the `\\u201cstart\\u201d element` is greater than the `\\u201ctarget\\u201d`, then it is impossible to find the combination onwards, because the `\\u201ccandidates\\u201d` list is sorted and all the following elements would be greater than the `\\u201ctarget\\u201d` as well. \\n\\n*Given the above recursive function, we could solve the problem by calling the function for each candidate starting from the start point. \\nFor each candidates, we first try to add the candidate into the `\\u201cvector\\u201d`, and then again starting from this candidate, we call the `combinationSum()` function to obtain the result for the new `\\u201ctarget\\u201d` afterwards.* \\n \\nHere is the code. \\n\\n\\n\\tprivate List<List<Integer>> res = new LinkedList<List<Integer>>();\\n\\t\\n\\tprivate void combinationSum(int [] candidates, LinkedList<Integer> vec,\\n\\t\\t\\t\\t\\t\\t\\t\\tint start, int target){\\n\\t\\t\\n\\t\\tfor(int i=start; i<candidates.length; ++i){\\n\\t\\t\\tif(candidates[i] < target){\\n\\t\\t\\t\\tLinkedList<Integer> newVec = new LinkedList<Integer>();\\n\\t\\t\\t\\tnewVec.addAll(vec);\\n\\t\\t\\t\\tnewVec.add(candidates[i]);\\n\\n\\t\\t\\t\\t// Try a new combination, one could repeat itself again, so start from \"i\", instead of \"i+1\" \\n\\t\\t\\t\\tcombinationSum(candidates, newVec, i, target-candidates[i]);\\t\\t\\t\\t\\n\\t\\t\\t}else if(candidates[i] == target){\\n\\n\\t\\t\\t\\t// Found a combination\\n\\t\\t\\t\\tLinkedList<Integer> newVec = new LinkedList<Integer>();\\n\\t\\t\\t\\tnewVec.addAll(vec);\\n\\t\\t\\t\\tnewVec.add(candidates[i]);\\n\\t\\t\\t\\tres.add(newVec);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t// candidates[i] > target, no need to continue\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\tArrays.sort(candidates);\\n    \\tLinkedList<Integer> vec = new LinkedList<Integer>();\\n    \\tthis.combinationSum(candidates, vec, 0, target);\\n    \\treturn res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "The problem is a bit like N-queen problem, which is to say that we just need to enumerate all the possible solution recursively to get the final result. \\n\\nFirst of all, we need to sort the array, to ensure the combination to be unique and also the numbers in the combination to be listed in a non-descending order. \\n\\nThen, we define a recursive function with the signature as:  \\n\\n    combinationSum(int [] candidates, LinkedList vector, int start, int target)\\n\\nwhere `\\u201ccandidates\\u201d` is the list that we could take numbers from, `\\u201cvector\\u201d` is the list of combination that we have accumulated so far, `\\u201cstart\\u201d` is the starting point at which we could take numbers from forwards (no backwards), and `\\u201ctarget\\u201d` is the rest sum that we need to achieve.  \\n\\nAs a recursive function, the bottom cases for the combinationSum() are: \\n\\n1). The value of the `\\u201cstart\\u201d element` is equal to the `\\u201ctarget\\u201d`, we then find a combination, so just add the `\\u201cstart\\u201d element` to the `\\u201cvector\\u201d` and output the result. \\n\\n2). The value of the `\\u201cstart\\u201d element` is greater than the `\\u201ctarget\\u201d`, then it is impossible to find the combination onwards, because the `\\u201ccandidates\\u201d` list is sorted and all the following elements would be greater than the `\\u201ctarget\\u201d` as well. \\n\\n*Given the above recursive function, we could solve the problem by calling the function for each candidate starting from the start point. \\nFor each candidates, we first try to add the candidate into the `\\u201cvector\\u201d`, and then again starting from this candidate, we call the `combinationSum()` function to obtain the result for the new `\\u201ctarget\\u201d` afterwards.* \\n \\nHere is the code. \\n\\n\\n\\tprivate List<List<Integer>> res = new LinkedList<List<Integer>>();\\n\\t\\n\\tprivate void combinationSum(int [] candidates, LinkedList<Integer> vec,\\n\\t\\t\\t\\t\\t\\t\\t\\tint start, int target){\\n\\t\\t\\n\\t\\tfor(int i=start; i<candidates.length; ++i){\\n\\t\\t\\tif(candidates[i] < target){\\n\\t\\t\\t\\tLinkedList<Integer> newVec = new LinkedList<Integer>();\\n\\t\\t\\t\\tnewVec.addAll(vec);\\n\\t\\t\\t\\tnewVec.add(candidates[i]);\\n\\n\\t\\t\\t\\t// Try a new combination, one could repeat itself again, so start from \"i\", instead of \"i+1\" \\n\\t\\t\\t\\tcombinationSum(candidates, newVec, i, target-candidates[i]);\\t\\t\\t\\t\\n\\t\\t\\t}else if(candidates[i] == target){\\n\\n\\t\\t\\t\\t// Found a combination\\n\\t\\t\\t\\tLinkedList<Integer> newVec = new LinkedList<Integer>();\\n\\t\\t\\t\\tnewVec.addAll(vec);\\n\\t\\t\\t\\tnewVec.add(candidates[i]);\\n\\t\\t\\t\\tres.add(newVec);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t// candidates[i] > target, no need to continue\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\tArrays.sort(candidates);\\n    \\tLinkedList<Integer> vec = new LinkedList<Integer>();\\n    \\tthis.combinationSum(candidates, vec, 0, target);\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16825,
                "title": "recursive-java-solution",
                "content": "    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates); // sort the array, so the result could be increasing order\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\n        for(int i = 0; i < candidates.length; i++){\\n            // target smaller than current number, jump the current and rest of numbers\\n            if(target < candidates[i]) continue;\\n\\n            // if target is equal to the current number,add it to a new list and add that list to result          \\n            else if(target == candidates[i]){\\n                List<Integer> set = new ArrayList<Integer>();\\n                set.add(candidates[i]);\\n                result.add(set);\\n            }\\n\\n            // if the target is smaller the current number,call this function again\\n            else{\\n                // use modified array which not includes those numbers that before i to eliminate the duplicates\\n                int[] array = Arrays.copyOfRange(candidates,i,candidates.length);\\n\\n                // call this function. pass the new target and modified array.\\n                List<List<Integer>> temp = combinationSum(array, target - candidates[i]);\\n\\n                // for each list in the return list, add current number in the front of list, then add it to result\\n                // attention that if return list is null, this enhanced for loop will not perform. \\n                for(List<Integer> list:temp){\\n                    list.add(0,candidates[i]);\\n                    result.add(list);\\n                } \\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\nThey key point is passing new target and modified array. Pass the modified array to make sure no duplicates set. If the new target could not find a match number, the return list will be null, thus this null list will not be added to the result list.",
                "solutionTags": [],
                "code": "    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates); // sort the array, so the result could be increasing order\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\n        for(int i = 0; i < candidates.length; i++){\\n            // target smaller than current number, jump the current and rest of numbers\\n            if(target < candidates[i]) continue;\\n\\n            // if target is equal to the current number,add it to a new list and add that list to result          \\n            else if(target == candidates[i]){\\n                List<Integer> set = new ArrayList<Integer>();\\n                set.add(candidates[i]);\\n                result.add(set);\\n            }\\n\\n            // if the target is smaller the current number,call this function again\\n            else{\\n                // use modified array which not includes those numbers that before i to eliminate the duplicates\\n                int[] array = Arrays.copyOfRange(candidates,i,candidates.length);\\n\\n                // call this function. pass the new target and modified array.\\n                List<List<Integer>> temp = combinationSum(array, target - candidates[i]);\\n\\n                // for each list in the return list, add current number in the front of list, then add it to result\\n                // attention that if return list is null, this enhanced for loop will not perform. \\n                for(List<Integer> list:temp){\\n                    list.add(0,candidates[i]);\\n                    result.add(list);\\n                } \\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\nThey key point is passing new target and modified array. Pass the modified array to make sure no duplicates set. If the new target could not find a match number, the return list will be null, thus this null list will not be added to the result list.",
                "codeTag": "Unknown"
            },
            {
                "id": 2774330,
                "title": "combinations-sum-1-java-solution-easy-recursive-approach",
                "content": "//Using Subset Pattern To Generate Combinations i.e. Include or Not Include\\n//but this time the change is made when we include the element ,we are not going to increase our index\\n//instead of increasing index we have given that we can use one element as many time as we want that\\'s why we are \\n//not going to increment index\\n\\n\\n![image](https://assets.leetcode.com/users/images/fd71fb68-bc08-4678-806c-66163da7721e_1667491488.5400312.jpeg)\\n\\n//Three Base cases\\n1. if(sum==target)  --> add subset ans into final ans arraylist\\n2. if(sum>target) --> return\\n3. if(index > arr.length) --> return\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        helper(0,candidates,target,0,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\nT.C :- O(2^target  *  k)  // k is the average length/size of subset \\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        helper(0,candidates,target,0,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\nT.C :- O(2^target  *  k)  // k is the average length/size of subset \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717214,
                "title": "easy-backtracking-solution-with-explanation-and-complexity-analysis",
                "content": "## General Algorithm \\nThe comination sum problems are those typical problems which can be solve with basic understanding of `backtracking` and `recursion`.\\nThese problems generally require 2 recursive calls which are as follows -\\n- you take `i th indexed` number form array and perform some operation (in this case, adding it to current-sum and inserting it in the list)\\n- you don\\'t take that number and performing operations that counter the operations in 1st recursive call (in this case, subtracting the number from current-sum and removing it from the list)\\n\\nIn this problem\\'s case, you take ith indexed number and add it to `current-sum` followed by inserting it in the `probable-ans lis`t. Now, if taking that number doesn\\'t work then anyways you subtract that number from `current sum` to bring it to it normal state and remove that number from `probable-ans-list`.\\n\\n**Base-case scenarios :**\\n- if `i` is greater that size of array; i.e. , all the elements of the array are visited.\\n- if `current-sum` is greater that target sum; because anyways, there is no point in finding sum with other numbers if current sum exceeds the target\\n\\n## Solution\\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> wrapper = new ArrayList<>();\\n        helper(wrapper, candidates, candidates.length, target, 0, 0, new ArrayList<>());\\n        return wrapper;\\n    }\\n    \\n    private void helper(List<List<Integer>> wrapper, int[] arr, int n, int target, int currSum, int i, List<Integer> probableAnsList) {\\n        if (i >= n) { \\n\\t\\t// Base-case 1\\n            if (currSum == target)\\n                wrapper.add(new ArrayList<>(probableAnsList)); \\n\\t\\t\\t\\t/* cloning arraylist (adding new Arraylist) because java references same object here which we are in future going to mutate and if the cloned list is not added then mutated changes will be seen here as well. */\\n            return;\\n        }\\n        if (currSum > target) // base-case 2\\n            return;\\n        \\n\\t\\t// Including the i-th indexed number\\n        currSum += arr[i];\\n        probableAnsList.add(arr[i]);\\n        helper(wrapper, arr, n, target, currSum, i, probableAnsList);\\n\\t\\t\\n\\t\\t// excluding the i-th indexed number\\n        currSum -= arr[i];\\n        probableAnsList.remove(probableAnsList.size() - 1);\\n        helper(wrapper, arr, n, target, currSum, i + 1, probableAnsList);\\n        \\n        return;\\n    }\\n    \\n}\\n```\\n\\n## Complexity analysis\\n\\n- Time Complexity = **O(2 ^ target) * k**\\n\\t- Reason: \\n\\t\\t- `2 ^ target` because at each step we are making 2 recursive calls. \\n\\t\\tFor ex. if arr[] = {1,2,3} and target is 3; then one of the ansers will be [1,1,1] and for \"every 1\" we are either taking it or ignorig it.\\n\\t\\t- `* k` because once we get target == currSum, we are inserting the elements of `probableAnsList` in `wrapper` which is `O(size of probableAnsList)`\\n\\n- Space Complexity = O(number of elements in wrapper)\\n\\n\\uD83C\\uDF1F`Upvote` if you liked this solution \\uD83C\\uDF1F",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> wrapper = new ArrayList<>();\\n        helper(wrapper, candidates, candidates.length, target, 0, 0, new ArrayList<>());\\n        return wrapper;\\n    }\\n    \\n    private void helper(List<List<Integer>> wrapper, int[] arr, int n, int target, int currSum, int i, List<Integer> probableAnsList) {\\n        if (i >= n) { \\n\\t\\t// Base-case 1\\n            if (currSum == target)\\n                wrapper.add(new ArrayList<>(probableAnsList)); \\n\\t\\t\\t\\t/* cloning arraylist (adding new Arraylist) because java references same object here which we are in future going to mutate and if the cloned list is not added then mutated changes will be seen here as well. */\\n            return;\\n        }\\n        if (currSum > target) // base-case 2\\n            return;\\n        \\n\\t\\t// Including the i-th indexed number\\n        currSum += arr[i];\\n        probableAnsList.add(arr[i]);\\n        helper(wrapper, arr, n, target, currSum, i, probableAnsList);\\n\\t\\t\\n\\t\\t// excluding the i-th indexed number\\n        currSum -= arr[i];\\n        probableAnsList.remove(probableAnsList.size() - 1);\\n        helper(wrapper, arr, n, target, currSum, i + 1, probableAnsList);\\n        \\n        return;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370502,
                "title": "python-recursion-detailed-explanation",
                "content": "1. Take two empty array to hold the result.\\n2.  `ds` stack for picking and removing element while moving along recursion. \\n3.  `res` to store final result and return. \\n4.  Call a recursive function starting with index 0. \\n5.  For each call, we have two option, either to pick the element (if it is less than the **current target** value) or to not pick (greater than current target value). \\n6.  By Current target, I mean if we have picked up the previous element, our target becomes  `target - element at current index i` else our `target` remains the same. \\n7.  If we pick the element, the current index `i` will be incremented by 1 else it will remain same.\\n8.  Similarly if we have processed the recursive call where we see that the element we picked is wrong, for example, if we picked 3 two\\'s `[2, 2, 2]` in stack then while returning back to its parent call, we should remove the element which is not required. \\n9.  The base case for the recursion will be when we have reached to the last index of the array and if we found the current target is `0`, it means we have found one possible combination. \\n10.  Recursively call above steps and wohooo, we have reached the solution. \\n\\n\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def combination(i, target, ds, res):\\n            if i == len(candidates):\\n                if target == 0 and ds not in res:\\n                    res.append(ds.copy())\\n                return\\n            if candidates[i] <= target:\\n                ds.append(candidates[i])\\n                combination(i, target - candidates[i], ds, res)\\n                ds.pop()\\n            combination(i + 1, target, ds, res)\\n            return res\\n        return combination(0, target, ds = [], res = [])\\n```\\n\\n**Note** - I have used `ds.copy()` to avoid overwriting of array due to reference. You can refer to Python Deep Copy and Shallow Copy concept for more info\\n\\nIf you like the explanation and solution, don\\'t hesitate to upvote. Cheers !!",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def combination(i, target, ds, res):\\n            if i == len(candidates):\\n                if target == 0 and ds not in res:\\n                    res.append(ds.copy())\\n                return\\n            if candidates[i] <= target:\\n                ds.append(candidates[i])\\n                combination(i, target - candidates[i], ds, res)\\n                ds.pop()\\n            combination(i + 1, target, ds, res)\\n            return res\\n        return combination(0, target, ds = [], res = [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276784,
                "title": "python-backtracking-with-full-working-explanation",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:  # Time: O(2^len(Tree)) and Space: O(n)\\n        res = []\\n\\n        def dfs(i, cur, total):\\n            if total == target:  # when the conditions are met we will copy a copy of current list into the result list\\n                res.append(cur.copy())\\n                return\\n            \\n            if i >= len(candidates) or total > target: \\n                return\\n            \\n            cur.append(candidates[i])  # x=1 we choose to include the current index\\n            dfs(i, cur, total + candidates[i])\\n            cur.pop()  # x=0 we choose to ignore the current index\\n            dfs(i + 1, cur, total)\\n\\n        dfs(0, [], 0)\\n\\t\\t\\n        return res\\n```\\nFor example,\\nLet **candidates = [2, 3, 5]** & **target = 8**\\n1. res = [ ]\\n* def dfs(0, [], 0):\\nif 0 == 8 = False\\nif 0 >= 3 or 0 > 8 = False or False = False\\ncur = [2] --> \\n* dfs(0, [2], 0 + 2):\\nif 2 == 8 = False -> if 0 >= 3 or 2 > 8 = False or False = False\\ncur = [2, 2] --> \\n* dfs(0, [2, 2], 2 + 2):\\nif 4 == 8 = False -> if 0 >= 3 or 4 > 8 = False or False = False\\ncur = [2, 2, 2] --> \\n* dfs(0, [2, 2, 2], 4 + 2):\\nif 6 == 8 = False -> if 0 >= 3 or 6 > 8 = False or False = False\\ncur = [2, 2, 2, 2] --> \\n* dfs(0, [2, 2, 2, 2], 6 + 2):\\nif 8 == 8 = True: res = [ [2, 2, 2, 2] ] --> return\\n--> dfs(1, [2, 2, 2, 2], 6) -> cur = [2, 2, 2] --> \\n* dfs(1, [2, 2, 2], 6):\\nif 6 == 8 = False -> if 1 >= 3 or 6 > 8 = False or False = False\\ncur = [2, 2, 2, 3] --> \\n* dfs(1, [2, 2, 2, 3], 9):\\nif 9 == 8 = False -> if 1 >= 3 or 9 > 8 = False or True = True: return\\n--> dfs(1, [2, 2, 2, 3], 9) -> cur = [2, 2, 2] --> \\n* dfs(2, [2, 2, 2], 6):\\nif 6 == 8 = False -> if 2 >= 3 or 6 > 8 = False or False = False\\ncur = [2, 2, 2, 5] --> \\n* dfs(2, [2, 2, 2, 5], 11):\\nif 11 == 8 = False -> if 2 >= 3 or 11 > 8 = False or True = True: return\\n--> dfs(2, [2, 2, 2, 3], 9) -> cur = [2, 2, 2] --> \\n* dfs(3, [2, 2, 2], 6) ->\\nif 6 == 8 = False -> if 3 >= 3 or 6 > 8 = True or False = True: return\\n--> dfs(3, [2, 2, 2], 6) -> dfs(2, [2, 2, 2], 6) -> dfs(1, [2, 2, 2], 6) -> dfs(0, [2, 2, 2], 6) -> cur = [2, 2]\\n* dfs(1, [2, 2], 4) ->\\nif 4 == 8 = False -> if 1 >= 3 or 4 > 8 = False or False = False\\ncur = [2, 2, 3] --> \\n* dfs(1, [2, 2, 3], 7):\\nif 7 == 8 = False -> if 1 >= 3 or 7 > 8 = False or False = False\\ncur = [2, 2, 3, 3] --> \\n* dfs(1, [2, 2, 3, 3], 10):\\nif 10 == 8 = False -> if 1 >= 3 or 10 > 8 = False or True = True: return \\n--> dfs(1, [2, 2, 3, 3], 10) --> cur = [2, 3, 3] -->\\n* dfs(2, [2, 2, 3], 7):\\nif 7 == 8 = False -> if 2 >= 3 or 7 > 8 = False or False = False\\ncur = [2, 2, 3, 5] --> \\n* dfs(2, [2, 2, 3, 5], 12):\\nif 12 == 8 = False -> if 2 >= 3 or 12 > 8 = False or True = True: return \\n--> dfs(1, [2, 2, 3, 5], 12) --> cur = [2, 3, 3] -->\\n* dfs(3, [2, 2, 3], 7):\\nif 7 == 8 = False -> if 3 >= 3 or 7 > 8 = True or False = True: return \\n--> dfs(3, [2, 2, 3], 7) -> dfs(2, [2, 2, 3], 7) -> cur = [2, 2]\\n* dfs(2, [2, 2], 4):\\nif 4 == 8 = False -> if 2 >= 3 or 4 > 8 = False or False = False\\ncur = [2, 2, 5] --> \\n* dfs(2, [2, 2, 5], 9):\\nif 9 == 8 = False -> if 2 >= 3 or 9 > 8 = True or False = True: return\\n--> dfs(2, [2, 2, 5], 9) -> cur = [2, 2]\\n* dfs(3, [2, 2], 4):\\nif 4 == 8 = False -> if 3 >= 3 or 4 > 8 = True or False = True: return\\n--> dfs(2, [2, 2], 4) -> dfs(1, [2, 2], 4) -> dfs(0, [2, 2], 4) -> cur = [2] -->\\n* dfs(1, [2], 2):\\nif 2 == 8 = False -> if 1 >= 3 or 2 > 8 = False or False = False\\ncur = [2, 3] --> \\n* dfs(1, [2, 3], 5):\\nif 5 == 8 = False -> if 1 >= 3 or 5 > 8 = False or False = False\\ncur = [2, 3, 3] --> \\n* dfs(1, [2, 3, 3], 8):\\nif 8 == 8 = True: res = [ [2, 3, 3] ] --> return\\n--> dfs(1, [2, 3, 3], 6) -> cur = [2, 3] --> \\n* dfs(2, [2, 3], 5):\\nif 5 == 8 = False -> if 2 >= 3 or 5 > 8 = False or False = False\\ncur = [2, 3, 5] --> \\n* dfs(2, [2, 3, 5], 10):\\nif 10 == 8 = False -> if 2 >= 3 or 10 > 8 = False or True = True: return \\n--> dfs(2, [2, 3, 5], 10) -> cur = [2, 3] --> \\n* dfs(3, [2, 3], 5):\\nif 5 == 8 = False -> if 3 >= 3 or 5 > 8 = True or False = True: return \\n--> dfs(2, [2, 3], 5) -> dfs(1, [2, 3], 5) -> cur = [2] --> \\n* dfs(2, [2], 2):\\nif 2 == 8 = False -> if 2 >= 3 or 2 > 8 = False or False = False\\ncur = [2, 5] --> \\n* dfs(2, [2, 5], 7):\\nif 7 == 8 = False -> if 2 >= 3 or 7 > 8 = False or False = False\\ncur = [2, 5, 5] --> \\n* dfs(2, [2, 5, 5], 12):\\nif 12 == 8 = False -> if 2 >= 3 or 12 > 8 = False or True = True: return \\n--> dfs(2, [2, 5, 5], 12) -> cur = [2, [2, 5], 7)\\n* dfs(3, [2, 5], 7):\\nif 7 == 8 = False -> if 3 >= 3 or 7 > 8 = True or False = True: return \\n--> dfs(2, [2, 5], 7) -> cur = [2]\\n* dfs(3, [2], 2):\\nif 2 == 8 = False -> if 3 >= 3 or 2 > 8 = True or False = True: return \\n--> dfs(2, [2], 5) -> dfs(1, [2], 5) -> dfs(0, [2], 5) -> cur [ ]\\n3. Similarly, continue with the 3 branch and 5 branch.\\n4. Return the result list.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:  # Time: O(2^len(Tree)) and Space: O(n)\\n        res = []\\n\\n        def dfs(i, cur, total):\\n            if total == target:  # when the conditions are met we will copy a copy of current list into the result list\\n                res.append(cur.copy())\\n                return\\n            \\n            if i >= len(candidates) or total > target: \\n                return\\n            \\n            cur.append(candidates[i])  # x=1 we choose to include the current index\\n            dfs(i, cur, total + candidates[i])\\n            cur.pop()  # x=0 we choose to ignore the current index\\n            dfs(i + 1, cur, total)\\n\\n        dfs(0, [], 0)\\n\\t\\t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875252,
                "title": "combination-sum-c-backtracking-with-short-explanation",
                "content": "Apply backtracking. Add an element to the vector if it keeps the sum less than or equal to target. \\n\\nIf it any point our sum is equal to target, push this vector to our answer vector, else backtrack.\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>& ans, vector<int>& v, vector<int>& candidates, int target, int curr)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0) return;\\n        for(int i=curr;i<candidates.size();i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                v.push_back(candidates[i]);\\n                solve(ans,v,candidates,target-candidates[i],i);\\n                v.pop_back();\\n            }\\n            else break;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sort(candidates.begin(),candidates.end());\\n        solve(ans,v,candidates,target,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>& ans, vector<int>& v, vector<int>& candidates, int target, int curr)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0) return;\\n        for(int i=curr;i<candidates.size();i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                v.push_back(candidates[i]);\\n                solve(ans,v,candidates,target-candidates[i],i);\\n                v.pop_back();\\n            }\\n            else break;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sort(candidates.begin(),candidates.end());\\n        solve(ans,v,candidates,target,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843289,
                "title": "c-simple-and-easy-solution-with-backtracking-concept",
                "content": "Simple backtracking concept , if any problems please let me know in comment section.\\n\\nPoint to observe -> Recursion is used inside the loop(iteration).\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& candidates, int target,int index,vector<int> &v,vector<vector<int> > &ans){\\n        if(target<0)\\n            return;\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=index;i<candidates.size();i++){\\n            v.push_back(candidates[i]);\\n            solve(candidates,target-candidates[i],i,v,ans);\\n            v.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> >ans;\\n        vector<int> v;\\n        int index=0;\\n        solve(candidates,target,index,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& candidates, int target,int index,vector<int> &v,vector<vector<int> > &ans){\\n        if(target<0)\\n            return;\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=index;i<candidates.size();i++){\\n            v.push_back(candidates[i]);\\n            solve(candidates,target-candidates[i],i,v,ans);\\n            v.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> >ans;\\n        vector<int> v;\\n        int index=0;\\n        solve(candidates,target,index,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763691,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> v;\\n        vector<int> u;\\n         helper(candidates, target,0,v,u);\\n        return v;\\n    }\\n    \\n    void helper(vector<int>& candidates, int target,int i,vector<vector<int>>& result, vector<int>& current)\\n    {\\n        if(target==0){\\n            result.push_back(current);\\n            return ;\\n        }\\n        if(i==candidates.size() || target<0)\\n            return;\\n        \\n        current.push_back(candidates[i]);\\n        helper(candidates,target-candidates[i],i,result,current);\\n        current.pop_back();\\n        helper(candidates,target,i+1,result,current);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> v;\\n        vector<int> u;\\n         helper(candidates, target,0,v,u);\\n        return v;\\n    }\\n    \\n    void helper(vector<int>& candidates, int target,int i,vector<vector<int>>& result, vector<int>& current)\\n    {\\n        if(target==0){\\n            result.push_back(current);\\n            return ;\\n        }\\n        if(i==candidates.size() || target<0)\\n            return;\\n        \\n        current.push_back(candidates[i]);\\n        helper(candidates,target-candidates[i],i,result,current);\\n        current.pop_back();\\n        helper(candidates,target,i+1,result,current);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344320,
                "title": "python-easy-to-understand-solution-96-faster",
                "content": "\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        \\n        def backtrack ( currSum, currList, mainList ):\\n            \\n\\n            for i in range( len(mainList) ):\\n                \\n                # If we have found the target value then we don\\'t have to iterate in the loop any further\\n                # Optimization #2: Any sum we get after this will always be greater than or equal to the current sum. ( Since we initially sorted the list in Optimization #1  )\\n                if currSum + mainList[i] == target:\\n                    # Add the answer to the list\\n                    solution.append( currList + [mainList[i]] )\\n                    return\\n                \\n                # Since the current sum is already greater than target, no point iterating further. ( Optimization #2 )\\n                if currSum + mainList[i] > target:\\n                    return\\n                \\n                # current sum is still less than target, backtrack\\n                else:\\n                    # currSum = current sum from function parameter + current element\\n                    # currList = current list from function parameter + list(current element)\\n                    # mainList = mainList [ i ... len(candidates) ] ( slicing to avoid duplicates ) \\n                    backtrack( currSum + mainList[i], currList + [ mainList[i] ], mainList[i:] )\\n            \\n        \\n\\t\\t\\n        solution = []\\n        \\n\\t\\t# Call the backtrack function\\n\\t\\t\\t# Optimization #1: sorting the list \\n\\t\\tbacktrack( 0, [], sorted( candidates ) )\\n        \\n        return solution\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        \\n        def backtrack ( currSum, currList, mainList ):\\n            \\n\\n            for i in range( len(mainList) ):\\n                \\n                # If we have found the target value then we don\\'t have to iterate in the loop any further\\n                # Optimization #2: Any sum we get after this will always be greater than or equal to the current sum. ( Since we initially sorted the list in Optimization #1  )\\n                if currSum + mainList[i] == target:\\n                    # Add the answer to the list\\n                    solution.append( currList + [mainList[i]] )\\n                    return\\n                \\n                # Since the current sum is already greater than target, no point iterating further. ( Optimization #2 )\\n                if currSum + mainList[i] > target:\\n                    return\\n                \\n                # current sum is still less than target, backtrack\\n                else:\\n                    # currSum = current sum from function parameter + current element\\n                    # currList = current list from function parameter + list(current element)\\n                    # mainList = mainList [ i ... len(candidates) ] ( slicing to avoid duplicates ) \\n                    backtrack( currSum + mainList[i], currList + [ mainList[i] ], mainList[i:] )\\n            \\n        \\n\\t\\t\\n        solution = []\\n        \\n\\t\\t# Call the backtrack function\\n\\t\\t\\t# Optimization #1: sorting the list \\n\\t\\tbacktrack( 0, [], sorted( candidates ) )\\n        \\n        return solution\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310038,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 203331,
                "title": "ruby-backtracking-with-diagram",
                "content": "```ruby\\n# @param {Integer[]} candidates\\n# @param {Integer} target\\n# @return {Integer[][]}\\ndef combination_sum(candidates, target)\\n    return [] if !candidates || candidates.empty?\\n    bt(candidates, target)\\nend\\n\\ndef bt(candidates, target, idx = 0, path = [], result = [], total = 0)\\n    if total == target\\n        result.push(path)\\n        return\\n    end\\n\\n    idx.upto(candidates.size - 1) do |i|\\n        next if total + candidates[i] > target\\n        bt(candidates, target, i, path + [candidates[i]], result, total + candidates[i])\\n    end\\n\\n    result\\nend\\n\\n# 39. Combination Sum\\n# https://leetcode.com/problems/combination-sum/description/\\n\\n# Similar problem listed in articles\\n# https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)\\n# https://leetcode.com/problems/combination-sum/discuss/16496/Accepted-16ms-c++-solution-use-backtracking-easy-understand.\\n\\n# Points to remember\\n# 1. No duplicates combinations in result               (So we should consider each unique combination only once)\\n# 2. Combination can contain a number any no. of times  (This means combination with repitition)\\n# 3. All numbers are +ve                                (Allows for pruning totals > target)\\n\\n# Approach 1: Backtracking\\n\\n# Example: candidates = [2,3,6,7], target = 7\\n# dfs call with idx: 0 path: [] result: [] total: 0\\n# check with next candidate and prune i: 0 | candidate: 2\\n#     dfs call with idx: 0 path: [2] result: [] total: 2\\n#     check with next candidate and prune i: 0 | candidate: 2\\n#         dfs call with idx: 0 path: [2, 2] result: [] total: 4\\n#         check with next candidate and prune i: 0 | candidate: 2\\n#             dfs call with idx: 0 path: [2, 2, 2] result: [] total: 6\\n#             check with next candidate and prune i: 0 | candidate: 2\\n#             check with next candidate and prune i: 1 | candidate: 3\\n#             check with next candidate and prune i: 2 | candidate: 6\\n#             check with next candidate and prune i: 3 | candidate: 7\\n#             dfs retrn with idx: 0 path: [2, 2, 2] result: [] total: 6\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#             dfs call with idx: 1 path: [2, 2, 3] result: [] total: 7\\n#             dfs retrn with idx: 1 path: [2, 2, 3] result: [[2, 2, 3]] total: 7\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 0 path: [2, 2] result: [[2, 2, 3]] total: 4\\n#     check with next candidate and prune i: 1 | candidate: 3\\n#         dfs call with idx: 1 path: [2, 3] result: [[2, 2, 3]] total: 5\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 1 path: [2, 3] result: [[2, 2, 3]] total: 5\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 0 path: [2] result: [[2, 2, 3]] total: 2\\n# check with next candidate and prune i: 1 | candidate: 3\\n#     dfs call with idx: 1 path: [3] result: [[2, 2, 3]] total: 3\\n#     check with next candidate and prune i: 1 | candidate: 3\\n#         dfs call with idx: 1 path: [3, 3] result: [[2, 2, 3]] total: 6\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 1 path: [3, 3] result: [[2, 2, 3]] total: 6\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 1 path: [3] result: [[2, 2, 3]] total: 3\\n# check with next candidate and prune i: 2 | candidate: 6\\n#     dfs call with idx: 2 path: [6] result: [[2, 2, 3]] total: 6\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 2 path: [6] result: [[2, 2, 3]] total: 6\\n# check with next candidate and prune i: 3 | candidate: 7\\n#     dfs call with idx: 3 path: [7] result: [[2, 2, 3]] total: 7\\n#     dfs retrn with idx: 3 path: [7] result: [[2, 2, 3], [7]] total: 7\\n# dfs retrn with idx: 0 path: [] result: [[2, 2, 3], [7]] total: 0\\n# Refer to the diagram for recursion tree\\n```\\n![image](https://assets.leetcode.com/users/vkommi2/image_1544343701.png)\\n",
                "solutionTags": [],
                "code": "```ruby\\n# @param {Integer[]} candidates\\n# @param {Integer} target\\n# @return {Integer[][]}\\ndef combination_sum(candidates, target)\\n    return [] if !candidates || candidates.empty?\\n    bt(candidates, target)\\nend\\n\\ndef bt(candidates, target, idx = 0, path = [], result = [], total = 0)\\n    if total == target\\n        result.push(path)\\n        return\\n    end\\n\\n    idx.upto(candidates.size - 1) do |i|\\n        next if total + candidates[i] > target\\n        bt(candidates, target, i, path + [candidates[i]], result, total + candidates[i])\\n    end\\n\\n    result\\nend\\n\\n# 39. Combination Sum\\n# https://leetcode.com/problems/combination-sum/description/\\n\\n# Similar problem listed in articles\\n# https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)\\n# https://leetcode.com/problems/combination-sum/discuss/16496/Accepted-16ms-c++-solution-use-backtracking-easy-understand.\\n\\n# Points to remember\\n# 1. No duplicates combinations in result               (So we should consider each unique combination only once)\\n# 2. Combination can contain a number any no. of times  (This means combination with repitition)\\n# 3. All numbers are +ve                                (Allows for pruning totals > target)\\n\\n# Approach 1: Backtracking\\n\\n# Example: candidates = [2,3,6,7], target = 7\\n# dfs call with idx: 0 path: [] result: [] total: 0\\n# check with next candidate and prune i: 0 | candidate: 2\\n#     dfs call with idx: 0 path: [2] result: [] total: 2\\n#     check with next candidate and prune i: 0 | candidate: 2\\n#         dfs call with idx: 0 path: [2, 2] result: [] total: 4\\n#         check with next candidate and prune i: 0 | candidate: 2\\n#             dfs call with idx: 0 path: [2, 2, 2] result: [] total: 6\\n#             check with next candidate and prune i: 0 | candidate: 2\\n#             check with next candidate and prune i: 1 | candidate: 3\\n#             check with next candidate and prune i: 2 | candidate: 6\\n#             check with next candidate and prune i: 3 | candidate: 7\\n#             dfs retrn with idx: 0 path: [2, 2, 2] result: [] total: 6\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#             dfs call with idx: 1 path: [2, 2, 3] result: [] total: 7\\n#             dfs retrn with idx: 1 path: [2, 2, 3] result: [[2, 2, 3]] total: 7\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 0 path: [2, 2] result: [[2, 2, 3]] total: 4\\n#     check with next candidate and prune i: 1 | candidate: 3\\n#         dfs call with idx: 1 path: [2, 3] result: [[2, 2, 3]] total: 5\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 1 path: [2, 3] result: [[2, 2, 3]] total: 5\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 0 path: [2] result: [[2, 2, 3]] total: 2\\n# check with next candidate and prune i: 1 | candidate: 3\\n#     dfs call with idx: 1 path: [3] result: [[2, 2, 3]] total: 3\\n#     check with next candidate and prune i: 1 | candidate: 3\\n#         dfs call with idx: 1 path: [3, 3] result: [[2, 2, 3]] total: 6\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 1 path: [3, 3] result: [[2, 2, 3]] total: 6\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 1 path: [3] result: [[2, 2, 3]] total: 3\\n# check with next candidate and prune i: 2 | candidate: 6\\n#     dfs call with idx: 2 path: [6] result: [[2, 2, 3]] total: 6\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 2 path: [6] result: [[2, 2, 3]] total: 6\\n# check with next candidate and prune i: 3 | candidate: 7\\n#     dfs call with idx: 3 path: [7] result: [[2, 2, 3]] total: 7\\n#     dfs retrn with idx: 3 path: [7] result: [[2, 2, 3], [7]] total: 7\\n# dfs retrn with idx: 0 path: [] result: [[2, 2, 3], [7]] total: 0\\n# Refer to the diagram for recursion tree\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 16504,
                "title": "easy-to-understand-96-performance-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n            return combinationSum(candidates, target, 0);\\n        }\\n        \\n        public List<List<Integer>> combinationSum(int[] candidates, int target, int start) {\\n            \\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            Arrays.sort(candidates);\\n            for (int i = start; i < candidates.length; i++) {\\n                if (candidates[i] <target) {\\n                    for (List<Integer> ar : combinationSum(candidates, target - candidates[i], i)) {\\n                        ar.add(0, candidates[i]);\\n                        res.add(ar);\\n                    }\\n                } else if (candidates[i] == target) {\\n                    List<Integer> lst = new ArrayList<>();\\n                    lst.add(candidates[i]);\\n                    res.add(lst);\\n                } else\\n                    break;\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n            return combinationSum(candidates, target, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3521721,
                "title": "detailed-explanation-with-recursion-tree-backtracking-c-tc-o-k-2-t-sc-o-k-x",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every element we come across in the given array, we are faced with the choice of either picking it to subtract from the target, or not picking it. \\n\\nUsing this fact, we can traverse the given array and make recursive calls to the function for each element in the array, reducing the target by the value picked till either the index is equal to size of the array or the value of target reaches less than or equal to zero.\\n\\nIf target value reaches zero, it means that the combination of elements picked will add up to the target and is a valid solution.\\n\\n**NOTE:** Since this problem allows us to pick multiple instances of the same element, we will pass the current index of the array (instead of the next one) when recursively calling the function as we can choose to pick it again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPass 0, `target`, `candidates`, `temp` and `sol` to the function `genUniqueCombos` that will generate unique combinations of the numbers adding up to the target. The parameters passed represent the current index, target to be attained, given array, array holding possible combination and array holding all possible combinations respectively.\\n\\nIf the index we are currently at is less than or equal to the target, we can think about adding it to (one of possible) solution. Push it into `temp` and recursively call the function, only this time with target reduced by the element added.\\n\\nOnce function call is returned, remove the element added to `temp`.\\n\\nIf index we are currently at is greater than the target, we cannot add it to the solution. Simply recursively call the function with the next index.\\n\\nWe can set the base case as the current index becoming equal to the size of the array, or the target becoming less than or equal to zero. If the target is equal to zero, we can surely say that it is one of the possible solutions and can push it into `sol`.\\n\\n**PS:** Recursion tree for `candidates` = [1, 2, 3] and `target` = 3.\\n\\n![WhatsApp Image 2023-05-14 at 8.23.53 AM.jpeg](https://assets.leetcode.com/users/images/2c69be16-4196-4f42-9865-c93fbb4c1fb7_1684032984.0102649.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: $$O(k*2^t)$$, where k is the number of possible solutions and t is the target to be attained.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k*x)$$, where k is number of possible solutions and x is the size of the longest solution.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void genUniqueCombos(int idx, int target, vector<int>& candidates, vector<int>& temp, vector<vector<int>>& sol){\\n        if(idx==candidates.size()||target<=0){\\n            if(!target) sol.push_back(temp);\\n            return;\\n        }\\n\\n        if(candidates[idx]<=target){\\n            temp.push_back(candidates[idx]);\\n            genUniqueCombos(idx, target-candidates[idx], candidates, temp, sol);\\n            temp.pop_back();\\n        }\\n        genUniqueCombos(idx+1, target, candidates, temp, sol);\\n    }\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> sol;\\n\\n        genUniqueCombos(0, target, candidates, temp, sol);\\n        return sol;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void genUniqueCombos(int idx, int target, vector<int>& candidates, vector<int>& temp, vector<vector<int>>& sol){\\n        if(idx==candidates.size()||target<=0){\\n            if(!target) sol.push_back(temp);\\n            return;\\n        }\\n\\n        if(candidates[idx]<=target){\\n            temp.push_back(candidates[idx]);\\n            genUniqueCombos(idx, target-candidates[idx], candidates, temp, sol);\\n            temp.pop_back();\\n        }\\n        genUniqueCombos(idx+1, target, candidates, temp, sol);\\n    }\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> sol;\\n\\n        genUniqueCombos(0, target, candidates, temp, sol);\\n        return sol;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629817,
                "title": "java-solution-easy-approach",
                "content": "```\\n\\n```****JAVA Solution Easy Approach****\\npublic List<List<Integer>> combinationSum(int[] candidates, int target)\\n{\\n        List<List<Integer>> al = new ArrayList<>();\\n\\t\\t//taking an List of List which will traverse via Call by reference through recursion\\n        Combo(candidates, target, \"\", target, al);           // passing list of List in recursion logic\\n        return al;                                                             // returning the list after Recursion ends\\n    }\\nstatic void Combo(int a[], int N, String ans, int max, List<List<Integer>> al)\\n    {\\n        if(N==0) //base Condition when our targets equals to 0\\n        {\\n            ArrayList<Integer> cl = new ArrayList<>();\\n            StringTokenizer st = new StringTokenizer(ans.trim()); // Breaking the string ans into integers and adding them into list,( a new List will be created for each case when base condition get hit)\\n            int n = st.countTokens();\\n            for(int j=0 ; j<=n-1; j++)\\n            {\\n                cl.add(Integer.parseInt(st.nextToken()));\\n            }\\n            al.add(cl); //adding our list to--> list of list\\n        }\\n        else\\n        {\\n            for(int i=0; i<a.length; i++)\\n            {\\n                if(N-a[i]>=0&& a[i]<=max) //taking max variable for stoping the duplication of answer \\n                {\\n                Combo(a, N-a[i], ans+a[i]+\" \", a[i], al); // passing max as last a[i] which we included in our ans\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777309,
                "title": "python-3-dfs-recursion-solution-and-explanation",
                "content": "\\n# \\uD83C\\uDF1F[Python 3] DFS Recursion Solution and Explanation\\n\\n## 1\\uFE0F\\u20E3 Main Idea:\\n* Step 1. Sort candidates\\n* Step 2. Recurssive call our helper function\\n\\n### Helper Function\\n* We take currentList as one of our function\\'s input because every time we try to add in a new number from candidates\\n* Once we append in new number, we recurssive call helper function and this time make our target = target - num which we picked\\n* Also we use startIdx to prevent counting duplicated outputs\\n\\n## Complexity Analysis\\n* Time: O(N^T/M) : Let N be length of candidates, T be target value, M be minimum value along candidates \\n* Space: O(N^T/M : Let N be length of candidates, T be target value, M be minimum value along candidates\\n\\n> Because every time we may at worst expand N-way tree from certain point. But how do we know the tree\\'s **height**?\\n> For example: We have a smallest value 1, and target value 100. So at worst we will have a maximum height which is [1,1,1,...,1] total **100** length. So we can consider **T/M**\\n\\n## Code\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res = []\\n        self.calHelper([], 0, candidates, target, res)\\n        return res\\n        \\n    def calHelper(self, currentList, startIdx, candidates, target, res):\\n        # Once target == 0 means we found a vaild list\\n        if target == 0:\\n            res.append(currentList)\\n            return\\n        \\n        # Start from startIdx means we can use duplicate nums\\n        for i in range(startIdx, len(candidates)):\\n            num = candidates[i]\\n            if num <= target:\\n                self.calHelper(currentList + [num], i, candidates, target - num, res)\\n            # Since candidates are sorted, if we cant find a vaild num <= target we break\\n            else:\\n                break\\n```\\n\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res = []\\n        self.calHelper([], 0, candidates, target, res)\\n        return res\\n        \\n    def calHelper(self, currentList, startIdx, candidates, target, res):\\n        # Once target == 0 means we found a vaild list\\n        if target == 0:\\n            res.append(currentList)\\n            return\\n        \\n        # Start from startIdx means we can use duplicate nums\\n        for i in range(startIdx, len(candidates)):\\n            num = candidates[i]\\n            if num <= target:\\n                self.calHelper(currentList + [num], i, candidates, target - num, res)\\n            # Since candidates are sorted, if we cant find a vaild num <= target we break\\n            else:\\n                break\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777073,
                "title": "c-clean-easy-backtracking",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid findcombination(int ind,int target,vector<int> &arr,vector<vector<int>>&ans,vector<int>&ds){\\n\\t\\t\\tif(ind==arr.size()){\\n\\t\\t\\t\\tif(target==0){\\n\\t\\t\\t\\t\\tans.push_back(ds);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(arr[ind]<=target){\\n\\t\\t\\t\\tds.push_back(arr[ind]);\\n\\t\\t\\t\\tfindcombination(ind,target-arr[ind],arr,ans,ds);\\n\\t\\t\\t\\tds.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\tfindcombination(ind+1,target,arr,ans,ds);\\n\\t\\t}\\n\\t\\tvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t\\tvector<vector<int>>ans;\\n\\t\\t\\tvector<int>ds;\\n\\t\\t\\tfindcombination(0,target,candidates,ans,ds);\\n\\t\\t\\treturn ans; \\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid findcombination(int ind,int target,vector<int> &arr,vector<vector<int>>&ans,vector<int>&ds){\\n\\t\\t\\tif(ind==arr.size()){\\n\\t\\t\\t\\tif(target==0){\\n\\t\\t\\t\\t\\tans.push_back(ds);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1777025,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\n```\\nfunc combinationSum(candidates []int, target int) [][]int {\\n\\tvar ans [][]int\\n\\n\\tif len(candidates) == 0 {\\n\\t\\treturn ans\\n\\t}\\n\\n\\tbt(&ans, make([]int, 0), candidates, 0, target)\\n\\n\\treturn ans\\n}\\n\\nfunc bt(ans *[][]int, tmp, nums []int, idx, tgt int) {\\n\\tif tgt < 0 || idx > len(nums) {\\n\\t\\treturn\\n\\t}\\n\\n\\tif tgt == 0 {\\n\\t\\tcpyTmp := make([]int, len(tmp))\\n\\t\\tcopy(cpyTmp, tmp)\\n\\t\\t*ans = append(*ans, cpyTmp)\\n\\t}\\n\\n\\tfor i := idx; i < len(nums); i++ {\\n\\t\\ttmp = append(tmp, nums[i])\\n\\t\\tbt(ans, tmp, nums, i, tgt-nums[i])\\n\\t\\ttmp = tmp[:len(tmp)-1]\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc combinationSum(candidates []int, target int) [][]int {\\n\\tvar ans [][]int\\n\\n\\tif len(candidates) == 0 {\\n\\t\\treturn ans\\n\\t}\\n\\n\\tbt(&ans, make([]int, 0), candidates, 0, target)\\n\\n\\treturn ans\\n}\\n\\nfunc bt(ans *[][]int, tmp, nums []int, idx, tgt int) {\\n\\tif tgt < 0 || idx > len(nums) {\\n\\t\\treturn\\n\\t}\\n\\n\\tif tgt == 0 {\\n\\t\\tcpyTmp := make([]int, len(tmp))\\n\\t\\tcopy(cpyTmp, tmp)\\n\\t\\t*ans = append(*ans, cpyTmp)\\n\\t}\\n\\n\\tfor i := idx; i < len(nums); i++ {\\n\\t\\ttmp = append(tmp, nums[i])\\n\\t\\tbt(ans, tmp, nums, i, tgt-nums[i])\\n\\t\\ttmp = tmp[:len(tmp)-1]\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1594104,
                "title": "easy-java-solution-backtracking-for-beginners",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target){\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        combinationSumhelper(0,candidates,target,ans, new ArrayList<Integer>());\\n\\n        return ans ;\\n    }\\n\\n    // similar concept of taking and not taking\\n    public void  combinationSumhelper( int index ,int[] candidates, int target, List<List<Integer>> ans , List<Integer> insideList){\\n        if (index == candidates.length){\\n            if (target == 0){\\n                List<Integer> newInside = new ArrayList<>(insideList);\\n                ans.add(newInside);\\n            }\\n\\n            return;\\n        }\\n\\n        if (candidates[index] <= target){\\n            insideList.add(candidates[index]);\\n            // Taking the element\\n            combinationSumhelper(index,candidates,target-candidates[index],ans,insideList);\\n            // Backtracking\\n            insideList.remove(insideList.size() - 1);\\n        }\\n        // not taking the element\\n        combinationSumhelper(index+1,candidates,target,ans,insideList);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target){\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        combinationSumhelper(0,candidates,target,ans, new ArrayList<Integer>());\\n\\n        return ans ;\\n    }\\n\\n    // similar concept of taking and not taking\\n    public void  combinationSumhelper( int index ,int[] candidates, int target, List<List<Integer>> ans , List<Integer> insideList){\\n        if (index == candidates.length){\\n            if (target == 0){\\n                List<Integer> newInside = new ArrayList<>(insideList);\\n                ans.add(newInside);\\n            }\\n\\n            return;\\n        }\\n\\n        if (candidates[index] <= target){\\n            insideList.add(candidates[index]);\\n            // Taking the element\\n            combinationSumhelper(index,candidates,target-candidates[index],ans,insideList);\\n            // Backtracking\\n            insideList.remove(insideList.size() - 1);\\n        }\\n        // not taking the element\\n        combinationSumhelper(index+1,candidates,target,ans,insideList);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189310,
                "title": "java-bactracking-beats-99-in-both-time-and-memory-2ms-t-c-o-n-t-s-c-o-t",
                "content": "\\n\\t// O(N^T) O(T)\\n\\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> temp = new ArrayList<>();\\n\\t\\tArrays.sort(candidates);\\n\\t\\tcombinationSumRecHelper(candidates, 0, target, 0, ans, temp, candidates.length);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(N^T) O(T)\\n\\tpublic void combinationSumRecHelper(int[] candidates, int idx, int target, int curr, List<List<Integer>> ans,\\n\\t\\t\\tList<Integer> temp, int len) {\\n\\n\\t\\tif (curr == target) {\\n\\t\\t\\tans.add(new ArrayList<>(temp));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (curr > target || idx == len)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (curr + candidates[idx] > target)\\n\\t\\t\\treturn;\\n\\n\\t\\ttemp.add(candidates[idx]);\\n\\t\\tcombinationSumRecHelper(candidates, idx, target, curr + candidates[idx], ans, temp, len);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\n\\t\\tcombinationSumRecHelper(candidates, idx + 1, target, curr, ans, temp, len);\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// O(N^T) O(T)\\n\\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> temp = new ArrayList<>();\\n\\t\\tArrays.sort(candidates);\\n\\t\\tcombinationSumRecHelper(candidates, 0, target, 0, ans, temp, candidates.length);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(N^T) O(T)\\n\\tpublic void combinationSumRecHelper(int[] candidates, int idx, int target, int curr, List<List<Integer>> ans,\\n\\t\\t\\tList<Integer> temp, int len) {\\n\\n\\t\\tif (curr == target) {\\n\\t\\t\\tans.add(new ArrayList<>(temp));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (curr > target || idx == len)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (curr + candidates[idx] > target)\\n\\t\\t\\treturn;\\n\\n\\t\\ttemp.add(candidates[idx]);\\n\\t\\tcombinationSumRecHelper(candidates, idx, target, curr + candidates[idx], ans, temp, len);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\n\\t\\tcombinationSumRecHelper(candidates, idx + 1, target, curr, ans, temp, len);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 875304,
                "title": "java-combination-sum-recursion-100-fast-well-explained",
                "content": "This solution asks you to create a combination of the integers given IN ANY WAY to get sum as target. Also, the provided integers are unique. \\nWe undertake recusion since there are multiple possibilities for any integer. Any integer can be part of the list of numbers which add to target, or not be part of it, or be present multiple times.\\n\\n```\\nclass Solution {\\n    private List<List<Integer>> result;\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        result = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        recursiveHelper(candidates, target, new ArrayList<Integer>(), 0); \\n        return result;\\n    }\\n    \\n    private void recursiveHelper(int[] candidates, int target, List<Integer> list, int currIdx){\\n        if(target<0)\\n            return;\\n        \\n        for(int i=currIdx;i<candidates.length;i++){\\n            if(candidates[i]==target){\\n                 List<Integer> l = new ArrayList<>(list);\\n                 l.add(candidates[i]);\\n                 result.add(l);\\n                return;\\n            }\\n            if(candidates[i]>target)\\n                return;\\n            list.add(candidates[i]);\\n            recursiveHelper(candidates, target-candidates[i], list, i);\\n            list.remove(list.size()-1);\\n        }\\n        \\n    }\\n}\\n```\\n\\n\\n1. We need to find a combination of integers which sums to target. oR condition such that SUM- Target == 0. If such a list of numbers is present, that we add in the result set.\\n2. Now how and which number to add?\\n**Pruning 1**\\nWe\\'ll start by adding small numbers to the list (which sums up to target) and then large numbers. Hence we sort the list first. So if the target is not achievable by adding even the smallest number to the list, then it is useless to recurse and add large numebers, hence if **any candidate[i] > target, we stop the current recursion.**\\n\\n**Pruning 2**\\nAlso, while adding numbers we ensure when we add a large number, we do not add small number i.e. we avoid combination like [2,2,3] , [2,3,2], and [3,2,2] by only adding large number after small number. **So IN LOOP we start by index of the number added last time.**\\n\\n**Pruning 3**\\nWe always subtract number added to list from target. So if target is zero, we have a solution list to be added to result set.\\nIf target == any number, we add the number to list and stop our recursion here. No need to add another function call stack, saves memory and time.\\n\\n**BackTrack**\\nAfter adding an element to the list and calling recursion. We need to backtrack our step by removing the recently added element. Since here in JAVA list is passed by reference, we need to do that here. You could always pass a new list but that would be memory consuming since not always the newly created list will create a solution. Thus we only duplicate the list when we have the solution.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private List<List<Integer>> result;\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        result = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        recursiveHelper(candidates, target, new ArrayList<Integer>(), 0); \\n        return result;\\n    }\\n    \\n    private void recursiveHelper(int[] candidates, int target, List<Integer> list, int currIdx){\\n        if(target<0)\\n            return;\\n        \\n        for(int i=currIdx;i<candidates.length;i++){\\n            if(candidates[i]==target){\\n                 List<Integer> l = new ArrayList<>(list);\\n                 l.add(candidates[i]);\\n                 result.add(l);\\n                return;\\n            }\\n            if(candidates[i]>target)\\n                return;\\n            list.add(candidates[i]);\\n            recursiveHelper(candidates, target-candidates[i], list, i);\\n            list.remove(list.size()-1);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831159,
                "title": "java-easy-solution",
                "content": "**Please upvote if helpfull!**\\n```\\nclass Solution {\\n    List<List<Integer>> resultList = new ArrayList<>();\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\n\\n        helper(candidates, target, 0, 0, new ArrayList<>());\\n\\n        return resultList;\\n\\n    }\\n\\n    private void helper(int[] candidates, int target, int index, int sum, List<Integer> list) {\\n\\n        if (sum > target) return;\\n\\n        if (sum == target) {\\n\\n            resultList.add(new ArrayList(list));\\n        }\\n\\n        for (int i = index; i < candidates.length; i++) {\\n            \\n            list.add(candidates[i]);\\n            helper(candidates, target, i , sum + candidates[i], list);\\n            list.remove(list.size() - 1);\\n\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> resultList = new ArrayList<>();\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\n\\n        helper(candidates, target, 0, 0, new ArrayList<>());\\n\\n        return resultList;\\n\\n    }\\n\\n    private void helper(int[] candidates, int target, int index, int sum, List<Integer> list) {\\n\\n        if (sum > target) return;\\n\\n        if (sum == target) {\\n\\n            resultList.add(new ArrayList(list));\\n        }\\n\\n        for (int i = index; i < candidates.length; i++) {\\n            \\n            list.add(candidates[i]);\\n            helper(candidates, target, i , sum + candidates[i], list);\\n            list.remove(list.size() - 1);\\n\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708264,
                "title": "c-combinations-i-ii-and-iii",
                "content": "**Combinations I :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations II :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations III :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539779,
                "title": "java-2ms-solution-using-recursion-99-56",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Stack<Integer> comb = new Stack<>();\\n        find(candidates, target, comb, 0, result);\\n        return result;\\n    }\\n    private void find(int[] candidates, int target, Stack<Integer> comb, int k, List<List<Integer>> result) {\\n        for (int i = k; i < candidates.length; i++) {\\n            if (candidates[i] == target) {\\n                comb.push(candidates[i]);\\n                result.add(new ArrayList<>(comb));\\n                comb.pop();\\n            } else if (candidates[i] < target) {\\n                comb.push(candidates[i]);\\n                find(candidates, target - candidates[i], comb, i, result);\\n                comb.pop();\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Stack<Integer> comb = new Stack<>();\\n        find(candidates, target, comb, 0, result);\\n        return result;\\n    }\\n    private void find(int[] candidates, int target, Stack<Integer> comb, int k, List<List<Integer>> result) {\\n        for (int i = k; i < candidates.length; i++) {\\n            if (candidates[i] == target) {\\n                comb.push(candidates[i]);\\n                result.add(new ArrayList<>(comb));\\n                comb.pop();\\n            } else if (candidates[i] < target) {\\n                comb.push(candidates[i]);\\n                find(candidates, target - candidates[i], comb, i, result);\\n                comb.pop();\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485551,
                "title": "simple-java-recursion-solution",
                "content": "class Solution \\n{\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) \\n    {\\n        Arrays.sort(candidates);\\n        \\n        List<List<Integer>> result=new ArrayList<>();\\n        List<Integer> list=new ArrayList<>();\\n        \\n        helper(candidates,0,target,0,result,list);\\n        \\n        return result;\\n        \\n    }\\n    \\n    void helper(int candidates[],int start,int target,int sum,List<List<Integer>> result,List<Integer> list)\\n    {\\n        if(sum>target)\\n            return;\\n        \\n        if(sum==target)\\n        {\\n            result.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        for(int i=start;i<candidates.length;i++)\\n        {\\n            list.add(candidates[i]);\\n            helper(candidates,i,target,sum+candidates[i],result,list);\\n            list.remove(list.size()-1);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) \\n    {\\n        Arrays.sort(candidates);\\n        \\n        List<List<Integer>> result=new ArrayList<>();\\n        List<Integer> list=new ArrayList<>();\\n        \\n        helper(candidates,0,target,0,result,list);\\n        \\n        return result;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 459477,
                "title": "python-5-lines-dp-solution",
                "content": "We can simply use the approach for solving Coin Change II [#518](https://leetcode.com/problems/coin-change-2).\\nIt only takes 5 lines without sorting at first.\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = [[[]]] + [[] for _ in range(target)]\\n        for candidate in candidates:\\n            for i in range(candidate, target + 1):\\n                dp[i] += [sublist + [candidate] for sublist in dp[i - candidate]]\\n        return dp[target]\\n```\\nTime complexity O(length of candidates * target)\\nSpace complexity O(target^3)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = [[[]]] + [[] for _ in range(target)]\\n        for candidate in candidates:\\n            for i in range(candidate, target + 1):\\n                dp[i] += [sublist + [candidate] for sublist in dp[i - candidate]]\\n        return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255454,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        mem=collections.defaultdict(list)\\n        for i in range(target+1):\\n            for candidate in candidates:\\n                if candidate>i:\\n                    continue\\n                elif candidate==i:\\n                    mem[i].append([candidate])\\n                elif candidate<i:\\n                    tmp=mem[i-candidate]\\n                    for tmplist in tmp:\\n                        pair=[candidate]+tmplist\\n                        if sorted(pair) not in mem[i]:\\n                            mem[i].append(sorted(pair))\\n        return mem[target]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        mem=collections.defaultdict(list)\\n        for i in range(target+1):\\n            for candidate in candidates:\\n                if candidate>i:\\n                    continue\\n                elif candidate==i:\\n                    mem[i].append([candidate])\\n                elif candidate<i:\\n                    tmp=mem[i-candidate]\\n                    for tmplist in tmp:\\n                        pair=[candidate]+tmplist\\n                        if sorted(pair) not in mem[i]:\\n                            mem[i].append(sorted(pair))\\n        return mem[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 219346,
                "title": "python-easy-and-clean-iterative-backtracking",
                "content": "```python\\n def combinationSum(self, candidates, target):\\n\\tanswer = []\\n\\tstack = [([], 0, 0)]\\n\\twhile stack:\\n\\t\\tchosen, currSum, currIndex = stack.pop()\\n\\t\\tif currSum == target:\\n\\t\\t\\tanswer.append(chosen)\\n\\t\\t\\tcontinue\\n\\t\\tfor i in range(currIndex, len(candidates)):\\n\\t\\t\\tcandidate = candidates[i]\\n\\t\\t\\tif currSum + candidate > target:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tstack.append((chosen + [candidate], currSum + candidate, i))\\n\\treturn answer\\n```\\nNothing special here, just a simple and easy to read iterative approach to backtracking with a stack. The key here is that we only consider candidates from `currIndex` and onwards as we want to break the symmetry between the pair, leaving us with unique combinations.",
                "solutionTags": [],
                "code": "```python\\n def combinationSum(self, candidates, target):\\n\\tanswer = []\\n\\tstack = [([], 0, 0)]\\n\\twhile stack:\\n\\t\\tchosen, currSum, currIndex = stack.pop()\\n\\t\\tif currSum == target:\\n\\t\\t\\tanswer.append(chosen)\\n\\t\\t\\tcontinue\\n\\t\\tfor i in range(currIndex, len(candidates)):\\n\\t\\t\\tcandidate = candidates[i]\\n\\t\\t\\tif currSum + candidate > target:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tstack.append((chosen + [candidate], currSum + candidate, i))\\n\\treturn answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 16616,
                "title": "very-elegant-python-code-using-recursive-yield-iterator",
                "content": "    def combSum(A, x):\\n        if A == [] or x < A[0]:\\n            return\\n        elif x == A[0]:\\n            yield [x]\\n        else:\\n            for comb in combSum(A, x - A[0]):\\n                yield [A[0]] + comb\\n            for comb in combSum(A[1:], x):\\n                yield comb\\n    \\n    class Solution:\\n        def combinationSum(self, A, x):\\n            return list(combSum(sorted(set(A)), x))",
                "solutionTags": [],
                "code": "    def combSum(A, x):\\n        if A == [] or x < A[0]:\\n            return\\n        elif x == A[0]:\\n            yield [x]\\n        else:\\n            for comb in combSum(A, x - A[0]):\\n                yield [A[0]] + comb\\n            for comb in combSum(A[1:], x):\\n                yield comb\\n    \\n    class Solution:\\n        def combinationSum(self, A, x):\\n            return list(combSum(sorted(set(A)), x))",
                "codeTag": "Java"
            },
            {
                "id": 3597098,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\n$$Exponential$$\\n\\n- Space complexity:\\n$$Exponential$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (idx == n) {\\n            if (sum == target)\\n                ans.push_back(temp);\\n            return;\\n        }\\n        if ((sum + candidates[idx]) <= target) {\\n            sum += candidates[idx];\\n            temp.push_back(candidates[idx]);\\n            helper(idx, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[idx];\\n            temp.pop_back();\\n        }\\n        helper(idx+1, candidates, n, sum, target, temp, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (idx == n) {\\n            if (sum == target)\\n                ans.push_back(temp);\\n            return;\\n        }\\n        if ((sum + candidates[idx]) <= target) {\\n            sum += candidates[idx];\\n            temp.push_back(candidates[idx]);\\n            helper(idx, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[idx];\\n            temp.pop_back();\\n        }\\n        helper(idx+1, candidates, n, sum, target, temp, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473884,
                "title": "c-recursive-backtracking-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n      if(ind==arr.size()){\\n        if(target==0){\\n          ans.push_back(ds);\\n        }\\n        return;\\n      }\\n      if(arr[ind]<=target){\\n        ds.push_back(arr[ind]);\\n        findCombination(ind,target-arr[ind],arr,ans,ds);\\n        ds.pop_back();\\n      }\\n      findCombination(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n      if(ind==arr.size()){\\n        if(target==0){\\n          ans.push_back(ds);\\n        }\\n        return;\\n      }\\n      if(arr[ind]<=target){\\n        ds.push_back(arr[ind]);\\n        findCombination(ind,target-arr[ind],arr,ans,ds);\\n        ds.pop_back();\\n      }\\n      findCombination(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774204,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            arr.push_back(val[i]);\\n            solve(arr, i, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            arr.push_back(val[i]);\\n            solve(arr, i, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760114,
                "title": "java-easy-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> ans=new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] arr, int sum) {\\n        Arrays.sort(arr);\\n        helper(arr,sum,0,new ArrayList<>());\\n        return ans;\\n    }\\n    public void helper(int [] arr,int sum,int ind,List<Integer> temp){\\n        if(ind==arr.length){\\n            return;\\n        }\\n        \\n        if(arr[ind]==sum){\\n            ArrayList<Integer> temp2=new ArrayList<>();\\n            temp2.addAll(temp);\\n            temp2.add(arr[ind]);\\n            ans.add(temp2);\\n            return;\\n        }\\n        if(arr[ind]>sum){\\n            return;\\n        }\\n        \\n        helper(arr,sum,ind+1,temp);\\n        \\n        ArrayList<Integer> temp2=new ArrayList<>();\\n        temp2.addAll(temp);\\n        temp2.add(arr[ind]);\\n        helper(arr,sum-arr[ind],ind,temp2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans=new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] arr, int sum) {\\n        Arrays.sort(arr);\\n        helper(arr,sum,0,new ArrayList<>());\\n        return ans;\\n    }\\n    public void helper(int [] arr,int sum,int ind,List<Integer> temp){\\n        if(ind==arr.length){\\n            return;\\n        }\\n        \\n        if(arr[ind]==sum){\\n            ArrayList<Integer> temp2=new ArrayList<>();\\n            temp2.addAll(temp);\\n            temp2.add(arr[ind]);\\n            ans.add(temp2);\\n            return;\\n        }\\n        if(arr[ind]>sum){\\n            return;\\n        }\\n        \\n        helper(arr,sum,ind+1,temp);\\n        \\n        ArrayList<Integer> temp2=new ArrayList<>();\\n        temp2.addAll(temp);\\n        temp2.add(arr[ind]);\\n        helper(arr,sum-arr[ind],ind,temp2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969565,
                "title": "very-fast-98-c-dfs-solution",
                "content": "```\\n    public IList<IList<int>> CombinationSum(int[] candidates, int target)\\n    {\\n        List<IList<int>> results = new();\\n        Stack<int> current = new();\\n\\n        void Dfs(int index, int total)\\n        {\\n            if (total == target)\\n            {\\n                results.Add(current.ToArray());\\n                return;\\n            }\\n\\n            if (index >= candidates.Length || total > target)\\n            {\\n                return;\\n            }\\n\\n            current.Push(candidates[index]);\\n            Dfs(index, total + candidates[index]);\\n            current.Pop();\\n            Dfs(index + 1, total);\\n        }\\n\\n        Dfs(0, 0);\\n        return results;\\n    }\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n    public IList<IList<int>> CombinationSum(int[] candidates, int target)\\n    {\\n        List<IList<int>> results = new();\\n        Stack<int> current = new();\\n\\n        void Dfs(int index, int total)\\n        {\\n            if (total == target)\\n            {\\n                results.Add(current.ToArray());\\n                return;\\n            }\\n\\n            if (index >= candidates.Length || total > target)\\n            {\\n                return;\\n            }\\n\\n            current.Push(candidates[index]);\\n            Dfs(index, total + candidates[index]);\\n            current.Pop();\\n            Dfs(index + 1, total);\\n        }\\n\\n        Dfs(0, 0);\\n        return results;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1777361,
                "title": "recursive-solution-with-diagram",
                "content": "**DO upvote if you understand**\\n![image](https://assets.leetcode.com/users/images/270da9e8-b2c0-4f9f-9a63-24ba4c32722c_1645073544.489124.png)\\n\\n```\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<vector<int>>answer;\\n\\n        vector<int>currentAns;\\n\\n        solve(candidates , target , 0 , currentAns , answer);\\n    \\treturn answer;\\n    }\\n\\n    void solve(vector<int>& candidates, int target , int idx ,\\n    \\tvector<int>&currentAns , vector<vector<int>>&answer) {\\n\\n\\n    \\t//Base case \\n    \\tif( target == 0 ) {\\n    \\t\\t//if target is zero we have found the combination\\n    \\t\\tanswer.push_back(currentAns);\\n    \\t\\treturn;\\n    \\t}\\n    \\tif(idx >= candidates.size()) return;\\n    \\tint currentVal = candidates[idx];\\n    \\t\\n    \\t//pick the element\\n        //if current element is less or equal to target then do the combination\\n    \\tif(target >= currentVal) {\\n    \\t\\tcurrentAns.push_back(currentVal);\\n    \\t\\tsolve(candidates , target-currentVal , idx , currentAns ,answer);\\n    \\t\\t //make sure u remove the element while recursion is over\\n    \\t\\tcurrentAns.pop_back();\\n    \\t}\\n    \\t\\n    \\t//not pick up element\\n    \\tsolve(candidates , target , idx+1 , currentAns , answer);\\n\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<vector<int>>answer;\\n\\n        vector<int>currentAns;\\n\\n        solve(candidates , target , 0 , currentAns , answer);\\n    \\treturn answer;\\n    }\\n\\n    void solve(vector<int>& candidates, int target , int idx ,\\n    \\tvector<int>&currentAns , vector<vector<int>>&answer) {\\n\\n\\n    \\t//Base case \\n    \\tif( target == 0 ) {\\n    \\t\\t//if target is zero we have found the combination\\n    \\t\\tanswer.push_back(currentAns);\\n    \\t\\treturn;\\n    \\t}\\n    \\tif(idx >= candidates.size()) return;\\n    \\tint currentVal = candidates[idx];\\n    \\t\\n    \\t//pick the element\\n        //if current element is less or equal to target then do the combination\\n    \\tif(target >= currentVal) {\\n    \\t\\tcurrentAns.push_back(currentVal);\\n    \\t\\tsolve(candidates , target-currentVal , idx , currentAns ,answer);\\n    \\t\\t //make sure u remove the element while recursion is over\\n    \\t\\tcurrentAns.pop_back();\\n    \\t}\\n    \\t\\n    \\t//not pick up element\\n    \\tsolve(candidates , target , idx+1 , currentAns , answer);\\n\\n    }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777034,
                "title": "c-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&C,vector<int>&A,vector<vector<int>>&res,int target,int sum,int start)\\n    {\\n        if(sum == target)\\n        {\\n            res.push_back(A);\\n            return;\\n        }\\n        \\n        for(int i = start; i < C.size(); i++)\\n        {\\n            if(sum + C[i] <= target)\\n            {\\n                A.push_back(C[i]);\\n                sum += C[i];\\n                solve(C,A,res,target,sum,i);\\n                A.pop_back();\\n                sum -= C[i];\\n            }\\n        }\\n            \\n    }\\n    vector<vector<int>> combinationSum(vector<int>&C, int target) {\\n        vector<vector<int>>res;\\n        vector<int>A;\\n        solve(C,A,res,target,0,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&C,vector<int>&A,vector<vector<int>>&res,int target,int sum,int start)\\n    {\\n        if(sum == target)\\n        {\\n            res.push_back(A);\\n            return;\\n        }\\n        \\n        for(int i = start; i < C.size(); i++)\\n        {\\n            if(sum + C[i] <= target)\\n            {\\n                A.push_back(C[i]);\\n                sum += C[i];\\n                solve(C,A,res,target,sum,i);\\n                A.pop_back();\\n                sum -= C[i];\\n            }\\n        }\\n            \\n    }\\n    vector<vector<int>> combinationSum(vector<int>&C, int target) {\\n        vector<vector<int>>res;\\n        vector<int>A;\\n        solve(C,A,res,target,0,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634720,
                "title": "0ms-c-solution-backtracking-solution",
                "content": "*Please find the image below:*\\n![image](https://assets.leetcode.com/users/images/ade65dba-4375-492d-82b1-e31a6b377c14_1639865523.526272.png)\\n\\n```\\nclass Solution {\\npublic:\\n    void combinationSumHelper(int indx, vector<int>& arr, int target,vector<vector<int>>& result,  vector<int>& comb )\\n    {\\n        if(indx >=arr.size())\\n        {\\n            return;\\n        }\\n        \\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        \\n        if(arr[indx]<=target)\\n        {\\n        comb.push_back(arr[indx]);\\n        combinationSumHelper(indx,arr,target-arr[indx],result,comb);\\n        comb.pop_back();\\n        \\n        }\\n   \\n       combinationSumHelper(indx+1,arr,target,result,comb);\\n        \\n        \\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        combinationSumHelper(0,candidates,target,result,comb);\\n        return result;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void combinationSumHelper(int indx, vector<int>& arr, int target,vector<vector<int>>& result,  vector<int>& comb )\\n    {\\n        if(indx >=arr.size())\\n        {\\n            return;\\n        }\\n        \\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        \\n        if(arr[indx]<=target)\\n        {\\n        comb.push_back(arr[indx]);\\n        combinationSumHelper(indx,arr,target-arr[indx],result,comb);\\n        comb.pop_back();\\n        \\n        }\\n   \\n       combinationSumHelper(indx+1,arr,target,result,comb);\\n        \\n        \\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        combinationSumHelper(0,candidates,target,result,comb);\\n        return result;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626467,
                "title": "c-0ms-100-faster-3-approachs-comparison-explained",
                "content": "**Please upvote if you like the solution and any improvements or suggestion are welcomed in the comments.**\\n## Approach 1: Dynamic Programming\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\tvector <vector <vector <int>>> dp(target+1);\\n        dp[0]={{}};\\n        for(int i:candidates)\\n        {\\n            for(int j=i;j<=target;j++)\\n            {\\n                for(auto v:dp[j-i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n        return dp[target];\\n\\t}\\n};\\n```\\n\\n## Approach 2: Sorting, Backtracking and DFS\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t//sorting not needed but used for pruning\\n        sort(begin(candidates),end(candidates));\\n        int n=candidates.size();\\n\\t\\t//removing not possible elements\\n        while(n&&(candidates[n-1]>target)){n--;}\\n        int sum=target;\\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        findNextComboSum(candidates,result,comb,n,sum,0);\\n        return result;\\n    }\\n    //Function used to calculate the next possible combination until end of the possible candidates\\n    void findNextComboSum(vector<int>& candidates,vector<vector<int>>& res,\\n                         vector<int>& comb,int& n,int sum,int start){\\n        if(sum<0)return;\\n        if(sum==0)res.push_back(comb);\\n        for(int i=start;i<n;i++){\\n            comb.push_back(candidates[i]);\\n            findNextComboSum(candidates,res,comb,n,sum-candidates[i],i);\\n            comb.pop_back();\\n        }\\n    }\\n};\\n```\\n**Example-**\\nInput: **candidates = [2,3,6,7,8,9], target = 7**\\nOutput: **[[2,2,3],[7]]**\\n***Explanation:***\\nPruning- **possible candidates** =**[2,3,6,7]**\\nThe checking goes like-\\n[2]      => (7-2>0) => add 2\\n[2,2]     => (7-4>0)  => add 2\\n[2,2,2]  => (7-6>0)  => add 2 \\n[2,2,2,2]  => (7-8<0)  => remove 2, add 3\\n[2,2,2,3]  => (7-9<0)  => remove 3, add 6\\n[2,2,2,6]  => (7-12<0)  => remove 6, add 7\\n[2,2,2,7]  => (7-13<0)  => remove 7, remove2, add 3\\n**[2,2,3]  => (7-7==0)  => add to result** , remove 3 ,add 6\\n[2,2,6]  => (7-10<0)  => remove 6 ,add 7\\n[2,2,7]  => (7-11<0)  => remove 7 ,remove 2, add 3\\n[2,3]=> (7-5>0)=>add 3\\n[2,3,3] => (7-8<0)  => remove 3 ,add 6\\n[2,3,6] => (7-11<0)  => remove 6 ,add 7\\n[2,3,7] =>(7-12<0) =>remove 7, remove 3, add 6\\n[2,6] => (7-8<0) =>remove 6 , add 7\\n[2,7] =>(7-9<0) =>remove 7, remove 2, add 3\\n[3]=> (7-3>0) => add 3\\n[3,3] => (7-6>0) => add 3\\n[3,3,3] => (7-9<0)  => remove 3 ,add 6\\n[3,3,6] => (7-12<0)  => remove 6 ,add 7\\n[3,3,7] =>(7-13<0) =>remove 7, remove 3, add 6\\n[3,6]  => (7-9<0)  => remove 6 ,add 7\\n[3,7] =>  (7-10<0)  => remove 7 ,remove 3, add 6 \\n[6] =>(7-6>0) =>add 7\\n[6,7] =>(7-13<0) => remove 7 ,remove 6, add 7\\n**[7] => (7==7) =>add to result**\\nIn this way, we get the result as **[[2,2,3],[7]]**\\n\\n## Approach 3:: Optimizing DFS calls\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(begin(candidates),end(candidates));\\n        int n=candidates.size();\\n        while(n&&(candidates[n-1]>target)){n--;}\\n        int sum=target;\\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        findNextComboSum(candidates,result,comb,n,sum,0);\\n        return result;\\n    }\\n    \\n    bool findNextComboSum(vector<int>& candidates,vector<vector<int>>& res,\\n                         vector<int>& comb,int& n,int sum,int start){\\n        if(sum<0)return false;\\n        if(sum==0){res.push_back(comb);return true;}\\n        bool tryNext=true;\\n        for(int i=start;tryNext&&i<n;i++){\\n            comb.push_back(candidates[i]);\\n            tryNext=findNextComboSum(candidates,res,comb,n,sum-candidates[i],i);\\n            comb.pop_back();\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Example-**\\nInput: **candidates = [2,3,6,7,8,9], target = 7**\\nOutput: **[[2,2,3],[7]]**\\n***Explanation:***\\nPruning- **possible candidates** =**[2,3,6,7]**\\nThe checking goes like-\\n**tryNext=true**\\n[2]      => (7-2>0) => add 2\\n**tryNext=true**\\n[2,2]     => (7-4>0)  => add 2\\n**tryNext=true**\\n[2,2,2]  => (7-6>0)  => add 2 \\n**tryNext=true**\\n[2,2,2,2]  => **(7-8<0)  =>  tryNext=false**, remove 2,\\nremove2, add 3\\n**tryNext=true**\\n**[2,2,3]  => (7-7==0)  => add to result** , remove 3 ,add 6\\n**tryNext=true**\\n[2,2,6]  => **(7-10<0)  =>  tryNext=false** , remove 6\\nremove 2, add 3\\n**tryNext=true**\\n[2,3]=> (7-5>0)=>add 3\\n**tryNext=true**\\n[2,3,3] => **(7-8<0)  =>  tryNext=false** , remove 3,\\nremove 3, add 6\\n[2,6] => **(7-8<0) => tryNext=false** , remove 6 ,\\nremove 2, add 3\\n[3]=> (7-3>0) => add 3\\n**tryNext=true**\\n[3,3] => (7-6>0) => add 3\\n**tryNext=true**\\n[3,3,3] => **(7-9<0)  =>  tryNext=false** , remove 3 \\nremove 3, add 6\\n**tryNext=true**\\n[3,6]  => **(7-9<0)  =>  tryNext=false** , remove 6 \\nremove 3, add 6 \\n**tryNext=true**\\n[6] =>(7-6>0) =>add 7\\n**tryNext=true**\\n[6,7] =>**(7-13<0) =>  tryNext=false** , remove 7 ,remove 6, add 7\\n**tryNext=true**\\n**[7] => (7==7) =>add to result**\\nIn this way, we get the result as **[[2,2,3],[7]]**\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Combination Sum.\\nMemory Usage: 10.7 MB, less than 97.01% of C++ online submissions for Combination Sum.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\tvector <vector <vector <int>>> dp(target+1);\\n        dp[0]={{}};\\n        for(int i:candidates)\\n        {\\n            for(int j=i;j<=target;j++)\\n            {\\n                for(auto v:dp[j-i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n        return dp[target];\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t//sorting not needed but used for pruning\\n        sort(begin(candidates),end(candidates));\\n        int n=candidates.size();\\n\\t\\t//removing not possible elements\\n        while(n&&(candidates[n-1]>target)){n--;}\\n        int sum=target;\\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        findNextComboSum(candidates,result,comb,n,sum,0);\\n        return result;\\n    }\\n    //Function used to calculate the next possible combination until end of the possible candidates\\n    void findNextComboSum(vector<int>& candidates,vector<vector<int>>& res,\\n                         vector<int>& comb,int& n,int sum,int start){\\n        if(sum<0)return;\\n        if(sum==0)res.push_back(comb);\\n        for(int i=start;i<n;i++){\\n            comb.push_back(candidates[i]);\\n            findNextComboSum(candidates,res,comb,n,sum-candidates[i],i);\\n            comb.pop_back();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(begin(candidates),end(candidates));\\n        int n=candidates.size();\\n        while(n&&(candidates[n-1]>target)){n--;}\\n        int sum=target;\\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        findNextComboSum(candidates,result,comb,n,sum,0);\\n        return result;\\n    }\\n    \\n    bool findNextComboSum(vector<int>& candidates,vector<vector<int>>& res,\\n                         vector<int>& comb,int& n,int sum,int start){\\n        if(sum<0)return false;\\n        if(sum==0){res.push_back(comb);return true;}\\n        bool tryNext=true;\\n        for(int i=start;tryNext&&i<n;i++){\\n            comb.push_back(candidates[i]);\\n            tryNext=findNextComboSum(candidates,res,comb,n,sum-candidates[i],i);\\n            comb.pop_back();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561049,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        helper(candidates, list, new ArrayList<>(), target, 0);\\n        return list;\\n    }\\n    private void helper(int[] candidates, List<List<Integer>> list , List<Integer> tmp, int target, int i){\\n        if(target < 0)  return;\\n        else if(target == 0)    list.add(new ArrayList<>(tmp));\\n        else{\\n            while(i<candidates.length){\\n                tmp.add(candidates[i]);\\n                helper(candidates, list, tmp, target - candidates[i], i++);\\n                tmp.remove(tmp.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        helper(candidates, list, new ArrayList<>(), target, 0);\\n        return list;\\n    }\\n    private void helper(int[] candidates, List<List<Integer>> list , List<Integer> tmp, int target, int i){\\n        if(target < 0)  return;\\n        else if(target == 0)    list.add(new ArrayList<>(tmp));\\n        else{\\n            while(i<candidates.length){\\n                tmp.add(candidates[i]);\\n                helper(candidates, list, tmp, target - candidates[i], i++);\\n                tmp.remove(tmp.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427935,
                "title": "c-with-explanation-simple-and-easy-to-understand-for-na-ve-like-me",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    void help(vector<int>& cand,vector<vector<int>> &vec,vector<int> &v,int target,int n){\\n\\t//base case\\n        if(target==0){\\n            vec.push_back(v);\\n                return;\\n        }\\n        if(n==0){\\n            return;\\n        }\\n\\t//choice diagram \\n        if(cand[n-1]<=target){\\n            v.push_back(cand[n-1]);\\n            help(cand,vec,v,target-cand[n-1],n);\\n            v.pop_back();\\n        }\\n        help(cand,vec,v,target,n-1);\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& cand, int target) {\\n        vector<vector<int>> vec;\\n        vector<int> v;\\n        help(cand,vec,v,target,cand.size());\\n        return vec;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(vector<int>& cand,vector<vector<int>> &vec,vector<int> &v,int target,int n){\\n\\t//base case\\n        if(target==0){\\n            vec.push_back(v);\\n                return;\\n        }\\n        if(n==0){\\n            return;\\n        }\\n\\t//choice diagram \\n        if(cand[n-1]<=target){\\n            v.push_back(cand[n-1]);\\n            help(cand,vec,v,target-cand[n-1],n);\\n            v.pop_back();\\n        }\\n        help(cand,vec,v,target,n-1);\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& cand, int target) {\\n        vector<vector<int>> vec;\\n        vector<int> v;\\n        help(cand,vec,v,target,cand.size());\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278005,
                "title": "python-dfs-sort",
                "content": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        candidates.sort()\\n        def DFS(arr,sm,target,j):\\n            if sm==target:\\n                if arr not in ans:\\n                    ans.append(arr)\\n                return\\n            for i in range(j,len(candidates)):\\n                if sm+candidates[i]>target:\\n                    return\\n                DFS(arr+[candidates[i]],sm+candidates[i],target,i)\\n        DFS([],0,target,0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        candidates.sort()\\n        def DFS(arr,sm,target,j):\\n            if sm==target:\\n                if arr not in ans:\\n                    ans.append(arr)\\n                return\\n            for i in range(j,len(candidates)):\\n                if sm+candidates[i]>target:\\n                    return\\n                DFS(arr+[candidates[i]],sm+candidates[i],target,i)\\n        DFS([],0,target,0)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1234096,
                "title": "c-backtracking-with-explanation-easy-to-understand",
                "content": "The idea of my solution is simple. I will backtrack with vector result, vector current, int target, int current_sum (sum of this backtrack turn), int prev (to save index of candidates that we have already use in last backtrack). \\n1) I check if current_sum is larger than target or not. If yes I will immediatedly stop backtrack because if we continue to backtrack we only add a postive number to make current_sum larger.\\n2) If current_sum==target, I will push vector current to result then return\\n3) If we are step 3, it means that or current_sum still smaller than target and need to increase. Now we loop from previous index to last index of candidate (I do not loop from 1 because I will make the same vector. For example, if I already have 1, 2 and in backtrack with 2 if we loop from 1 we wiil have 2, 1 and it not valid), then we add the element we loop through to vector current and backtrack with vector current and current_sum + the element we just added.\\n\\nIf my solution is helpful, give me an upvote. Thank you for reading.\\n```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>> &result, vector<int> current, int target, int current_sum, vector<int> candidates, int previous){\\n        if(current_sum>target){\\n            return;\\n        }\\n        if(current_sum==target){\\n            result.push_back(current);\\n        }\\n        \\n        for(int i=previous; i<candidates.size(); i++){\\n            current.push_back(candidates[i]);\\n            backtrack(result, current, target, current_sum+candidates[i], candidates, i);\\n            current.pop_back();\\n        }\\n    }\\n        \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;\\n        vector<int> current;\\n        backtrack(result, current, target, 0, candidates, 0);\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    void backtrack(vector<vector<int>> &result, vector<int> current, int target, int current_sum, vector<int> candidates, int previous){\\n        if(current_sum>target){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1188545,
                "title": "top-down-using-memoization-solution-better-time-complexity-than-backtracking",
                "content": "The idea is that you memoize the generated combinations for each target, and bubble that up to the caller. The caller will then add the candidate that generated those lists to each of them. \\n\\nOf course we will have to dedupe at the end, because resuing solutions will generate duplicates. \\n\\nI am not so sure of the time complexity, but I beleive it would be this:\\n\\nO(N^2 * M) with N being the target and M being the length of array. We then have the sorting for deduping. So that would be O(MlogM)\\nThe result is O(M(logM * N^2)). Seems to be a better time complexity than backtracking.  \\n\\n```\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        # For memoization\\n        self.memo = {}\\n        \\n        def get_combo(candidates, target):\\n            \\n            if target < 0:\\n                return\\n\\n            if target == 0:\\n                # Return a list of list so we can add candidates to it\\n                return [[]]\\n            \\n            # Use memoization\\n            if target in self.memo:\\n                return self.memo[target]\\n            \\n            final_list = []\\n            for candidate in candidates:\\n                result = get_combo(candidates, target - candidate)\\n                if result:\\n                    for alist in result:\\n                        # deep copy\\n                        alist = list(alist)\\n                        # add candidate to each list returned\\n                        alist.append(candidate)\\n                        # add new list to final list\\n                        final_list.append(alist)\\n\\n            self.memo[target] = final_list             \\n            return final_list\\n        \\n        results = []\\n        \\n        # Dedupe\\n        aset = set()\\n        for alist in get_combo(candidates, target):\\n            alist = sorted(alist)\\n            if tuple(alist) not in aset:\\n                aset.add(tuple(alist))\\n                results.append(alist)\\n                \\n        return results\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        # For memoization\\n        self.memo = {}\\n        \\n        def get_combo(candidates, target):\\n            \\n            if target < 0:\\n                return\\n\\n            if target == 0:\\n                # Return a list of list so we can add candidates to it\\n                return [[]]\\n            \\n            # Use memoization\\n            if target in self.memo:\\n                return self.memo[target]\\n            \\n            final_list = []\\n            for candidate in candidates:\\n                result = get_combo(candidates, target - candidate)\\n                if result:\\n                    for alist in result:\\n                        # deep copy\\n                        alist = list(alist)\\n                        # add candidate to each list returned\\n                        alist.append(candidate)\\n                        # add new list to final list\\n                        final_list.append(alist)\\n\\n            self.memo[target] = final_list             \\n            return final_list\\n        \\n        results = []\\n        \\n        # Dedupe\\n        aset = set()\\n        for alist in get_combo(candidates, target):\\n            alist = sorted(alist)\\n            if tuple(alist) not in aset:\\n                aset.add(tuple(alist))\\n                results.append(alist)\\n                \\n        return results\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1151613,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(target, path, start):\\n            if target == 0: res.append(path)\\n            else:\\n                for i in range(start, len(candidates)):\\n                    if target - candidates[i] >= 0:\\n                        backtrack(target - candidates[i], path + [candidates[i]], i)\\n        \\n        res = []\\n        backtrack(target, [], 0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(target, path, start):\\n            if target == 0: res.append(path)\\n            else:\\n                for i in range(start, len(candidates)):\\n                    if target - candidates[i] >= 0:\\n                        backtrack(target - candidates[i], path + [candidates[i]], i)\\n        \\n        res = []\\n        backtrack(target, [], 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935010,
                "title": "well-commented-javascript-backtracking-solution-beats-99-81-o-n-t-m-time-space",
                "content": "**Explanation for the time/space complexity (taken directly from Solutions tab) below the code**\\n\\n```\\nvar combinationSum = function(candidates, target) {\\n  const combos = [];\\n  // Pass in the given args, plus combos, a currCombo array, and an index\\n  combinationSumHelper(candidates, target, combos, [], 0);\\n  return combos;\\n};\\n\\nvar combinationSumHelper = function(candidates, target, combos, currCombo, index) {\\n  // Since we subtract from target on each recursive call, we know that\\n  // the base case is when target === 0 (a valid combo)\\n  if (target === 0) combos.push([...currCombo]);\\n\\n  for (let i = index; i < candidates.length; i++) {\\n\\t// Just check to make sure the current number fits into target\\n    if (candidates[i] <= target) {\\n\\t  // Try to use the number by pushing to currCombo\\n      currCombo.push(candidates[i]);\\n\\t  // Recurse and subtract this number from target (now the next recursion will use the remainder)\\n\\t  // and pass in i as the index because we can use this number multiple times\\n      combinationSumHelper(candidates, target - candidates[i], combos, currCombo, i);\\n\\t  // Un-use the number so in the next iteration, you will use the next number\\n      currCombo.pop();\\n    }\\n  }\\n}\\n```\\n\\n**Copied directly from Solutions tab; explanation for time/space complexity (Space has the same reason as Time since Recursion stack reflects it):**\\n\\nLet N be the number of candidates, T be the target value, and M be the minimal value among the candidates.\\n\\n... the execution of the backtracking is unfolded as a DFS traversal in a n-ary tree. The total number of steps during the backtracking would be the number of nodes in the tree.\\n\\nAt each node, it takes a constant time to process, except the leaf nodes which could take a linear time to make a copy of combination. So we can say that the time complexity is linear to the number of nodes of the execution tree.\\n\\nHere we provide a loose upper bound on the number of nodes.\\n\\n* First of all, the fan-out of each node would be bounded to N, i.e. the total number of candidates.\\n\\n* The maximal depth of the tree, would be T/M, where we keep on adding the smallest element to the combination.\\n\\n* As we know, the maximal number of nodes in N-ary tree of T/M height would be N ^ ((T/M) +1)\\n\\nNote that, the actual number of nodes in the execution tree would be much smaller than the upper bound, since the fan-out of the nodes are decreasing level by level.",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar combinationSum = function(candidates, target) {\\n  const combos = [];\\n  // Pass in the given args, plus combos, a currCombo array, and an index\\n  combinationSumHelper(candidates, target, combos, [], 0);\\n  return combos;\\n};\\n\\nvar combinationSumHelper = function(candidates, target, combos, currCombo, index) {\\n  // Since we subtract from target on each recursive call, we know that\\n  // the base case is when target === 0 (a valid combo)\\n  if (target === 0) combos.push([...currCombo]);\\n\\n  for (let i = index; i < candidates.length; i++) {\\n\\t// Just check to make sure the current number fits into target\\n    if (candidates[i] <= target) {\\n\\t  // Try to use the number by pushing to currCombo\\n      currCombo.push(candidates[i]);\\n\\t  // Recurse and subtract this number from target (now the next recursion will use the remainder)\\n\\t  // and pass in i as the index because we can use this number multiple times\\n      combinationSumHelper(candidates, target - candidates[i], combos, currCombo, i);\\n\\t  // Un-use the number so in the next iteration, you will use the next number\\n      currCombo.pop();\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 875305,
                "title": "pyhton-simple-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=qs1-iEla-5M)\\nhttps://www.youtube.com/watch?v=qs1-iEla-5M\\n```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        self.res = []\\n        self.candidates = candidates\\n        self.backtrack([], 0, target)\\n        return self.res\\n    \\n    def backtrack(self, path, indx, target):\\n        \\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            self.res.append(path)\\n            return \\n        \\n        for x in range(indx, len(self.candidates)):\\n            self.backtrack(path+[self.candidates[x]], x, target - self.candidates[x])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        self.res = []\\n        self.candidates = candidates\\n        self.backtrack([], 0, target)\\n        return self.res\\n    \\n    def backtrack(self, path, indx, target):\\n        \\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            self.res.append(path)\\n            return \\n        \\n        for x in range(indx, len(self.candidates)):\\n            self.backtrack(path+[self.candidates[x]], x, target - self.candidates[x])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874860,
                "title": "java-clean-code-backtracking-technique",
                "content": "```\\nclass Solution {\\n\\t\\n\\tprivate void combinationSumUtil (int[] candidates, int target, int index, List<Integer> temp, List<List<Integer>> res) {\\n\\t\\t\\n\\t\\tif (target == 0) {\\n\\t\\t\\tres.add (new ArrayList <>(temp));\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (; index < candidates.length && target > 0; index++) {\\n\\t\\t\\ttemp.add (candidates[index]);\\n\\t\\t\\tcombinationSumUtil (candidates, target - candidates[index], index, temp, res);\\n\\t\\t\\ttemp.remove (temp.size () - 1);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic List<List<Integer>> combinationSum (int[] candidates, int target) {\\n\\t\\t\\n\\t\\tList<List<Integer>> res = new ArrayList <>();\\n\\t\\tcombinationSumUtil (candidates, target, 0, new ArrayList<Integer> (), res);\\n\\t\\t\\n\\t\\treturn res;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tprivate void combinationSumUtil (int[] candidates, int target, int index, List<Integer> temp, List<List<Integer>> res) {\\n\\t\\t\\n\\t\\tif (target == 0) {\\n\\t\\t\\tres.add (new ArrayList <>(temp));\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (; index < candidates.length && target > 0; index++) {\\n\\t\\t\\ttemp.add (candidates[index]);\\n\\t\\t\\tcombinationSumUtil (candidates, target - candidates[index], index, temp, res);\\n\\t\\t\\ttemp.remove (temp.size () - 1);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic List<List<Integer>> combinationSum (int[] candidates, int target) {\\n\\t\\t\\n\\t\\tList<List<Integer>> res = new ArrayList <>();\\n\\t\\tcombinationSumUtil (candidates, target, 0, new ArrayList<Integer> (), res);\\n\\t\\t\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845243,
                "title": "python-recursive-solution-faster-than-92-13-of-python3-online-submissions",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates:\\n            return []\\n        res = []\\n        candidates.sort()\\n        def helper(target, index, sub_list):\\n            if target == 0:\\n                res.append(sub_list)\\n            if target < 0 or index >= len(candidates):\\n                return\\n            for i in range(index, len(candidates)):\\n                #optimization\\n                if target < candidates[i]:\\n                    break\\n                helper(target-candidates[i], i, sub_list+[candidates[i]])\\n        helper(target, 0, [])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates:\\n            return []\\n        res = []\\n        candidates.sort()\\n        def helper(target, index, sub_list):\\n            if target == 0:\\n                res.append(sub_list)\\n            if target < 0 or index >= len(candidates):\\n                return\\n            for i in range(index, len(candidates)):\\n                #optimization\\n                if target < candidates[i]:\\n                    break\\n                helper(target-candidates[i], i, sub_list+[candidates[i]])\\n        helper(target, 0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762703,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{ \\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{ \\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643296,
                "title": "simple-recursion-python",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.answer=set()   # Set - To get rid of duplicates\\n        self.candidates=[]  \\n    def helper(self,target_,ans_=[]):\\n        if target_ < 0 : return\\n        elif target_ == 0 : \\n            self.answer.add(tuple(sorted(ans_))) # Sets can store only tuples not lists \\n            return          # Sorting it to make it distinguishable\\n        else:\\n            for i in self.candidates:\\n                self.helper(target_-i,ans_+[i])\\n    def combinationSum(self, candidates, target) -> List[List[int]]:\\n        self.candidates = candidates # Making it a data member caus\\' it never changes and \\n        self.helper(target)          #     no need to pass it for every recursion call\\n        return list(self.answer)\\n```\\n![image](https://assets.leetcode.com/users/ssvvbb6/image_1590044625.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.answer=set()   # Set - To get rid of duplicates\\n        self.candidates=[]  \\n    def helper(self,target_,ans_=[]):\\n        if target_ < 0 : return\\n        elif target_ == 0 : \\n            self.answer.add(tuple(sorted(ans_))) # Sets can store only tuples not lists \\n            return          # Sorting it to make it distinguishable\\n        else:\\n            for i in self.candidates:\\n                self.helper(target_-i,ans_+[i])\\n    def combinationSum(self, candidates, target) -> List[List[int]]:\\n        self.candidates = candidates # Making it a data member caus\\' it never changes and \\n        self.helper(target)          #     no need to pass it for every recursion call\\n        return list(self.answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521349,
                "title": "commented-python3-7-solution-faster-than-71-49-100-less-memory",
                "content": "unlike what I saw others post, i am not recalculating the sum every step, rather running the same solution for the remaining sum.\\nHope it helps!\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # if the target is reached - return \\n        if target == 0:\\n            return []\\n        \\n        # quit if we went out of bounds\\n        if target < 0:\\n            return None\\n        out = []\\n        \\n        # two cases here:\\n        # if a candidate is the target add to solutions \\n        # since everything after will be beyond the sum\\n        # if < target : get combinations on target-cur_candidate,\\n        # then merge each solution with the cur_candidate\\n\\n        for i in range(len(candidates)):\\n            candidate = candidates[i]\\n            if candidate == target:\\n                out.append([candidate])\\n\\n            if candidate < target:\\n                solutions = self.combinationSum(candidates[i:], target-candidate)\\n                for solution in solutions:\\n                    if solution is not None:\\n                        out.append([candidate, *solution])\\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # if the target is reached - return \\n        if target == 0:\\n            return []\\n        \\n        # quit if we went out of bounds\\n        if target < 0:\\n            return None\\n        out = []\\n        \\n        # two cases here:\\n        # if a candidate is the target add to solutions \\n        # since everything after will be beyond the sum\\n        # if < target : get combinations on target-cur_candidate,\\n        # then merge each solution with the cur_candidate\\n\\n        for i in range(len(candidates)):\\n            candidate = candidates[i]\\n            if candidate == target:\\n                out.append([candidate])\\n\\n            if candidate < target:\\n                solutions = self.combinationSum(candidates[i:], target-candidate)\\n                for solution in solutions:\\n                    if solution is not None:\\n                        out.append([candidate, *solution])\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519968,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> finalResult;\\n    vector<int> result;\\npublic:\\n    void combinationSumUtil(const vector<int>& candidates, int target, int size)\\n    {\\n        if(target == 0)\\n        {\\n            finalResult.push_back(result);\\n            return;\\n        }\\n        if(target<0) return;\\n        if(size<=0 && target>=1) return;\\n        result.push_back(candidates[size-1]);\\n        combinationSumUtil(candidates, target-candidates[size-1], size);\\n        result.pop_back();\\n        combinationSumUtil(candidates, target, size-1);\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        combinationSumUtil(candidates,target,candidates.size());\\n        return finalResult;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    vector<vector<int>> finalResult;\\n    vector<int> result;\\npublic:\\n    void combinationSumUtil(const vector<int>& candidates, int target, int size)\\n    {\\n        if(target == 0)\\n        {\\n            finalResult.push_back(result);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 499983,
                "title": "easy-to-understand-c-solution-backtracking",
                "content": "Runtime: 8 ms, faster than 97.96% of C++ online submissions for Combination Sum.\\nMemory Usage: 9.6 MB, less than 63.89% of C++ online submissions for Combination Sum.\\n```\\nclass Solution {\\n    vector<vector<int>> res;\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(candidates, target, 0, temp, 0);\\n        \\n        return res;\\n    }\\n    \\n    void solve(vector<int>& candidates, int target, int currSum, vector<int>& temp, int pos)\\n    {\\n        if(currSum > target)\\n            return;\\n        if(currSum == target)\\n        {\\n            res.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=pos; i<candidates.size(); i++)\\n        {\\n            currSum += candidates[i];\\n            temp.push_back(candidates[i]);\\n            solve(candidates, target, currSum, temp, i);\\n            currSum -= candidates[i];\\n            temp.pop_back();\\n        }\\n    }\\n};\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    vector<vector<int>> res;\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(candidates, target, 0, temp, 0);\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 403209,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n\\n    def combinationSum(self, candidates: [int], target: int) -> [[int]]:\\n        answer = []\\n\\n        universe = [([], 0)]\\n        for n in candidates:\\n            for (ls, v) in universe:\\n                if v + n == target:\\n                    answer.append(ls + [n])\\n                elif v + n < target:\\n                    universe.append((ls + [n], v + n))\\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n\\n    def combinationSum(self, candidates: [int], target: int) -> [[int]]:\\n        answer = []\\n\\n        universe = [([], 0)]\\n        for n in candidates:\\n            for (ls, v) in universe:\\n                if v + n == target:\\n                    answer.append(ls + [n])\\n                elif v + n < target:\\n                    universe.append((ls + [n], v + n))\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340436,
                "title": "a-6-line-python-dp-solution-with-explanation",
                "content": "Intuition: This is very similar to the classic Knapsack problem (how many ways can you add these numbers to get target), except we also have to keep track of the combinations.\\n\\nConsider the example\\n\\n```[2,3,5]```, with target 8. To reach 8, our last step must be adding 2, 3, or 5. So we take all the combinations that add up to 6, 5, or 3 respectively, and add the remaining number rin the last step. To eliminate duplicates, we iterate over the candidates first. (This guarantees that each new combination we\\'re adding is distinct.)\\n\\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0] = [[]]\\n        for candidate in candidates:\\n            for i in range(candidate, len(dp)): \\n                dp[i].extend(comb + [candidate] for comb in dp[i - candidate])\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```[2,3,5]```\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0] = [[]]\\n        for candidate in candidates:\\n            for i in range(candidate, len(dp)): \\n                dp[i].extend(comb + [candidate] for comb in dp[i - candidate])\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 324671,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n\\tlet total = []\\n\\tfunction dfs (index, sum, result) {\\n\\t\\tif (sum === target) {\\n\\t\\t\\ttotal.push([...result])\\n\\t\\t}\\n\\t\\tif (sum > target) {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tfor (let i = index; i < candidates.length; i++) {\\n\\t\\t\\tresult.push(candidates[i])\\n\\t\\t\\tdfs(i, sum + candidates[i], result)\\n\\t\\t\\tresult.pop()\\n\\t\\t}\\n\\t}\\n\\tdfs(0, 0, [])\\n\\treturn total\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n\\tlet total = []\\n\\tfunction dfs (index, sum, result) {\\n\\t\\tif (sum === target) {\\n\\t\\t\\ttotal.push([...result])\\n\\t\\t}\\n\\t\\tif (sum > target) {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tfor (let i = index; i < candidates.length; i++) {\\n\\t\\t\\tresult.push(candidates[i])\\n\\t\\t\\tdfs(i, sum + candidates[i], result)\\n\\t\\t\\tresult.pop()\\n\\t\\t}\\n\\t}\\n\\tdfs(0, 0, [])\\n\\treturn total\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16608,
                "title": "backtracking-top-down-dp-bottom-up-dp-solutions-in-java",
                "content": "**Solution 1: Backtracking**\\n```\\nList<List<Integer>> combSum_BK(int[] a, int target) {\\n    List<List<Integer>> result = new ArrayList<>();\\n    backtrack(a, target, result, new ArrayList<>(), 0);\\n    return result;\\n}\\n\\nvoid backtrack(int[] a, int target, List<List<Integer>> result, List<Integer> path, int start) {\\n    if (target == 0) {\\n        result.add(new ArrayList<>(path));\\n        return;\\n    }\\n    for (int i = start; i < a.length; i++) {\\n        if (target - a[i] < 0) continue;\\n        path.add(a[i]);\\n        backtrack(a, target - a[i], result, path, i);\\n        path.remove(path.size() - 1);\\n    }\\n}\\n```\\n\\n**Solution 2: Top-Down DP**\\n```\\nList<List<Integer>> combSum_DP_TopDown(int[] a, int target) {\\n    List<List<List<Integer>>> dp = new ArrayList<>(target);\\n    Arrays.sort(a);\\n    for (int i = 0; i <= target; i++) dp.add(null);\\n    return subProblem(a, target, dp);\\n}\\n\\nList<List<Integer>> subProblem(int[] a, int target, List<List<List<Integer>>> dp) {\\n    if (dp.get(target) != null) return dp.get(target);  // Already calculated. Reuse.\\n    List<List<Integer>> current = new ArrayList<>();    // Not yet calculated.\\n    for (int candidate : a) {\\n        if (target - candidate < 0) break;      // Subproblem doesn't exist.\\n        if (target - candidate == 0) {          // Subproblem is candidate itself.\\n            List<Integer> single = new ArrayList<>(Arrays.asList(candidate));\\n            current.add(single);\\n            continue;\\n        }\\n        List<List<Integer>> old = subProblem(a, target - candidate, dp); //check Subproblem\\n        for (List<Integer> path : old) {            // Add candidate to all results.\\n            if (candidate > path.get(0)) continue;\\n            List<Integer> new_path = new ArrayList<>();        \\n            new_path.add(candidate);\\n            new_path.addAll(path);\\n            current.add(new_path);\\n        }\\n    }\\n    dp.set(target, current);    // Current problem results memoized.\\n    return dp.get(target);\\n}\\n```\\n\\n**Solution 3: Bottom-Up DP**\\n```\\nList<List<Integer>> comb_DP_BottomUp(int[] a, int target) {\\n    Arrays.sort(a);\\n    List<List<List<Integer>>> dp = new ArrayList<>();\\n    for (int i = 1; i <= target; i++) {\\n        List<List<Integer>> current = new ArrayList<>();\\n        for (int candidate : a) {\\n            int sub = i - candidate;    \\n            if (sub < 0) break;         // subproblem doesn't exist.\\n            if (sub == 0) {             // subproblem is candidate itself. \\n                current.add(Arrays.asList(candidate));              \\n                continue;\\n            }\\n            for (List<Integer> path : dp.get(sub - 1)) {    // subproblem is reused.\\n                if (candidate > path.get(0)) continue;\\n                List<Integer> new_path = new ArrayList<>();\\n                new_path.add(candidate);\\n                new_path.addAll(path);\\n                current.add(new_path);\\n            }\\n        }\\n        dp.add(current);\\n    }\\n    return dp.get(target - 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nList<List<Integer>> combSum_BK(int[] a, int target) {\\n    List<List<Integer>> result = new ArrayList<>();\\n    backtrack(a, target, result, new ArrayList<>(), 0);\\n    return result;\\n}\\n\\nvoid backtrack(int[] a, int target, List<List<Integer>> result, List<Integer> path, int start) {\\n    if (target == 0) {\\n        result.add(new ArrayList<>(path));\\n        return;\\n    }\\n    for (int i = start; i < a.length; i++) {\\n        if (target - a[i] < 0) continue;\\n        path.add(a[i]);\\n        backtrack(a, target - a[i], result, path, i);\\n        path.remove(path.size() - 1);\\n    }\\n}\\n```\n```\\nList<List<Integer>> combSum_DP_TopDown(int[] a, int target) {\\n    List<List<List<Integer>>> dp = new ArrayList<>(target);\\n    Arrays.sort(a);\\n    for (int i = 0; i <= target; i++) dp.add(null);\\n    return subProblem(a, target, dp);\\n}\\n\\nList<List<Integer>> subProblem(int[] a, int target, List<List<List<Integer>>> dp) {\\n    if (dp.get(target) != null) return dp.get(target);  // Already calculated. Reuse.\\n    List<List<Integer>> current = new ArrayList<>();    // Not yet calculated.\\n    for (int candidate : a) {\\n        if (target - candidate < 0) break;      // Subproblem doesn't exist.\\n        if (target - candidate == 0) {          // Subproblem is candidate itself.\\n            List<Integer> single = new ArrayList<>(Arrays.asList(candidate));\\n            current.add(single);\\n            continue;\\n        }\\n        List<List<Integer>> old = subProblem(a, target - candidate, dp); //check Subproblem\\n        for (List<Integer> path : old) {            // Add candidate to all results.\\n            if (candidate > path.get(0)) continue;\\n            List<Integer> new_path = new ArrayList<>();        \\n            new_path.add(candidate);\\n            new_path.addAll(path);\\n            current.add(new_path);\\n        }\\n    }\\n    dp.set(target, current);    // Current problem results memoized.\\n    return dp.get(target);\\n}\\n```\n```\\nList<List<Integer>> comb_DP_BottomUp(int[] a, int target) {\\n    Arrays.sort(a);\\n    List<List<List<Integer>>> dp = new ArrayList<>();\\n    for (int i = 1; i <= target; i++) {\\n        List<List<Integer>> current = new ArrayList<>();\\n        for (int candidate : a) {\\n            int sub = i - candidate;    \\n            if (sub < 0) break;         // subproblem doesn't exist.\\n            if (sub == 0) {             // subproblem is candidate itself. \\n                current.add(Arrays.asList(candidate));              \\n                continue;\\n            }\\n            for (List<Integer> path : dp.get(sub - 1)) {    // subproblem is reused.\\n                if (candidate > path.get(0)) continue;\\n                List<Integer> new_path = new ArrayList<>();\\n                new_path.add(candidate);\\n                new_path.addAll(path);\\n                current.add(new_path);\\n            }\\n        }\\n        dp.add(current);\\n    }\\n    return dp.get(target - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16658,
                "title": "4-problems-1-solution-java-solutions-for-combinations-combination-sum1-combination-sum2-combination-sum3",
                "content": "**Combinations**\\n\\n```\\npublic List<List<Integer>> combine(int n, int k) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, \\nList<List<Integer>> result) {\\n\\t\\tif(k == curPath.size()) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= n; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\\n\\n**CombinationSum1**\\n\\n\\n```\\n    public static List<List<Integer>> combinationSum(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\\n\\n**CombinationSum2**\\n\\n```\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t    if (i > start && nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```\\n\\n**CombinationSum3**\\n\\n```\\n\\n    public static List<List<Integer>> combinationSum3(int k, int n) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(k == curPath.size() && n == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= 9; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n - i, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Combinatorics"
                ],
                "code": "```\\npublic List<List<Integer>> combine(int n, int k) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, \\nList<List<Integer>> result) {\\n\\t\\tif(k == curPath.size()) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= n; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\n```\\n    public static List<List<Integer>> combinationSum(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\n```\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t    if (i > start && nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```\n```\\n\\n    public static List<List<Integer>> combinationSum3(int k, int n) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(k == curPath.size() && n == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= 9; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n - i, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16666,
                "title": "almost-same-solution-for-two-problems-combination-sum-and-combination-sum-ii-c-code-with-comments-fast",
                "content": "**Combination Sum** \\n\\ncode is explained as comments.\\n\\n    void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start){\\n                // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                   // if current element is bigger than the assigned target, there is \\n                   //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                   //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                   // keep searching for new elements with start as i since here duplicates are allowed\\n                elementSum(candidates,res,elements,target-candidates[i],i);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }\\n        \\n**Combination Sum II**\\n\\n\\n    void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start){\\n                 // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                 // we always want to count the first element in this recursive step even if it is the same \\n                 // as one before. To avoid overcounting, we just ignore the duplicates\\n                 // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                  // if current element is bigger than the assigned target, there is \\n                  //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                  //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                  // keep searching for new element with start as i + 1 because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }\\n        \\n\\nThank you",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "**Combination Sum** \\n\\ncode is explained as comments.\\n\\n    void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start){\\n                // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                   // if current element is bigger than the assigned target, there is \\n                   //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                   //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                   // keep searching for new elements with start as i since here duplicates are allowed\\n                elementSum(candidates,res,elements,target-candidates[i],i);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }\\n        \\n**Combination Sum II**\\n\\n\\n    void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start){\\n                 // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                 // we always want to count the first element in this recursive step even if it is the same \\n                 // as one before. To avoid overcounting, we just ignore the duplicates\\n                 // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                  // if current element is bigger than the assigned target, there is \\n                  //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                  //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                  // keep searching for new element with start as i + 1 because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }\\n        \\n\\nThank you",
                "codeTag": "Unknown"
            },
            {
                "id": 3919161,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    void solve(int ind, vector<int>&candidates, int &target, int sum, vector<vector<int>>&result , vector<int>&ans) \\n    {\\n        if(ind == candidates.size())\\n        {\\n            // if(sum == target)\\n            // {\\n            //     result.push_back(ans);\\n            // }\\n            return;\\n        }\\n\\n        if(sum >= target)\\n        {\\n            if(sum == target)\\n            {\\n                result.push_back(ans);\\n            }\\n            return;\\n        }\\n            ans.push_back(candidates[ind]);\\n            sum = sum + candidates[ind];\\n            solve(ind, candidates, target, sum, result, ans);\\n\\n            ans.pop_back();\\n            sum -= candidates[ind];\\n            solve(ind+1, candidates, target, sum, result, ans);\\n         \\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) \\n    {\\n        vector<vector<int>>result;\\n        vector<int>ans;\\n        solve(0, candidates, target, 0, result, ans);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void solve(int ind, vector<int>&candidates, int &target, int sum, vector<vector<int>>&result , vector<int>&ans) \\n    {\\n        if(ind == candidates.size())\\n        {\\n            // if(sum == target)\\n            // {\\n            //     result.push_back(ans);\\n            // }\\n            return;\\n        }\\n\\n        if(sum >= target)\\n        {\\n            if(sum == target)\\n            {\\n                result.push_back(ans);\\n            }\\n            return;\\n        }\\n            ans.push_back(candidates[ind]);\\n            sum = sum + candidates[ind];\\n            solve(ind, candidates, target, sum, result, ans);\\n\\n            ans.pop_back();\\n            sum -= candidates[ind];\\n            solve(ind+1, candidates, target, sum, result, ans);\\n         \\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) \\n    {\\n        vector<vector<int>>result;\\n        vector<int>ans;\\n        solve(0, candidates, target, 0, result, ans);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631074,
                "title": "most-optimized-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j,n,k-v[j],v,tmp,ans);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& v, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = v.size();\\n        solve(0,n,target,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j,n,k-v[j],v,tmp,ans);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& v, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = v.size();\\n        solve(0,n,target,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193246,
                "title": "simple-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        self.ans = []                                   # for adding all the answers\\n        def traverse(candid, arr,sm):                   # arr : an array that contains the accused combination; sm : is the sum of all elements of arr \\n            if sm == target: self.ans.append(arr)       # If sum is equal to target then you know it, I know it, what to do\\n            if sm >= target: return                     # If sum is greater than target then no need to move further.\\n            for i in range(len(candid)):                # we will traverse each element from the array.\\n                traverse(candid[i:], arr + [candid[i]], sm+candid[i])   #most important, splice the array including the current index, splicing in order to handle the duplicates.\\n        traverse(candidates,[], 0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        self.ans = []                                   # for adding all the answers\\n        def traverse(candid, arr,sm):                   # arr : an array that contains the accused combination; sm : is the sum of all elements of arr \\n            if sm == target: self.ans.append(arr)       # If sum is equal to target then you know it, I know it, what to do\\n            if sm >= target: return                     # If sum is greater than target then no need to move further.\\n            for i in range(len(candid)):                # we will traverse each element from the array.\\n                traverse(candid[i:], arr + [candid[i]], sm+candid[i])   #most important, splice the array including the current index, splicing in order to handle the duplicates.\\n        traverse(candidates,[], 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184895,
                "title": "all-in-one-iterative-vs-recursive-tree-diagram-detailed-explained-meme",
                "content": "![backtea.jpeg](https://assets.leetcode.com/users/images/8643339f-f6fa-43ec-91c4-47f8007c230d_1676377995.5688634.jpeg)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs you might have noticed that we are not considering the whole array as possible options at every level, because we want unique combinations.\\ne.g. at the node [2, 2, 3], the possible options for the next level are only [3, 5]. Why?? because if we consider the whole array as possible options, then we we will end up with [2, 2, 3, 2] (with 2 as a possible option), which has already been checked as [2, 2, 2, 3] (see the tree). So to make the solution unique we are only considering the part of the array from current last element to the end element (like in this example).\\n1. If the sum of the current combination is greater than target, then even if we move forward with this combination, the sum will only increase, so there is no fun to moving further with such a combination as we can never achieve the target sum from this. So backtrack from this.\\n2. If the sum of the current combination is equal to the target, then we have a solution, so store this combination in the answers. Now moving forward with this combnation also will only increase the sum and we can\\'t achieve the target sum again from this ever. So backtrack from here.\\n3. if we are here then that means the sum of the combination is still less that the target sum, and we have a scope of finding a combination whose sum can be equal to the target.\\n\\t\\ti) Now consider all possible options into this combination, one at a time.\\n\\t\\tii) Go check if considering the current option can give us the solution.\\n\\t\\tiii) Now when this option backtracks to this place again, now remove this option and try another option. e.g. at [2, 2, _ ] we have 3 options to fill the 3rd place i.e. [2, 3, 5].\\n\\t\\tSo firstly we will go on with [2, 2, 2]. Then when this backtracks to this place again, remove the last 2 and try the next option which is 3 that means [2, 2, 3].\\n\\t\\tWhen this also backtracks remove 3 to try 5, that means [2, 2, 5].\\n\\t\\tNow as all the options are exhausted for [2, 2, _ ], now backtrack to its previous state which is [2, 2], and so on...\\n\\n![disc.jpeg](https://assets.leetcode.com/users/images/6d68f170-7995-4c8e-9548-933a3412e358_1676378568.4791667.jpeg)\\n\\n\\nHow Tree diagram will work-\\n\\nWe will make a op array, that contains all the possible combinations sum of the array.\\n\\nWe will start from the index 0 and as we already discussed that for each and every element we have two possibility whether to include this element in making our answer or not, so we will explore all possibilities.\\n\\nop aray represents which elements this array contains now in making combination sum.\\n\\nTarget represents the left combination sum that we have to make. Intially it is same as the original target that we have to make.\\n\\nThe red cursor below the array, points that on which index we are currently standing.\\n\\nIf at any point our target becomes zero, then we will include that combination in our answer array saying that yes, this is an possible combination and return from there.\\n\\nIf at any point our target becomes less than zero, then we return from there saying that we are never able to make our cbination sum by this combination.\\n\\nIf at any point we cross the size of the array then we will return from there saying that no more element is left to choose.\\n\\nAs we dicussed for every element we have two choices whether to include in our answer or not include in our answer.\\n\\nSo, if we do not a include a element in our answer then without decreasing target sum, we will move to next index. Why we do not decrese sum? because we will choose not to include in this element in our combination, hence it does not contribute in making our sum.\\n\\nBut, if we choose a particular element to include in our answer, then we will decrease the target sum but we will not move to next index. Why we will not move to next index? because for a specific element we have unlimited number of choice, so it may be possible that specific element again contribute in making our sum.\\n\\nIf Image is not cleary visible to you, then for that I have uploaded it on my drive.\\n\\nYou may visit this link to see Image in good quality.\\n\\n# Code\\n```1_c++_recursive []\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // 2 D vector to store our answer\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\\n    {\\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\\n        if(target == 0) \\n        {\\n            ans.push_back(temp); // include that combination in our answer\\n            return; // and then return, we are now not gonna explore more possiblity\\n        }\\n        \\n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\\n        if(target < 0)\\n            return;\\n        \\n        // if index crosses the last index, we will return saying that no more element is left to choosee\\n        if(i == arr.size())\\n            return;\\n        \\n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \\n\\t\\t//so now, we are doing that\\n        \\n        // we are not taking the ith element,\\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\\n        solve(i + 1, arr, temp, target);\\n        \\n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\\n        \\n        temp.push_back(arr[i]); // including ith element\\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\\n        temp.pop_back(); // backtrack\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\\n        \\n        vector<int> temp; // temporary vector that tries all possible combination\\n        \\n        solve(0, arr, temp, target); // calling function, and see we start from index zero\\n        \\n        return ans; // finally return the answer array\\n    }\\n};\\n``` \\n```PYTHON_ITERATIVE []\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        ret = []\\n        self.dfs(candidates, target, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, path, ret):\\n        if target < 0:\\n            return \\n        if target == 0:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)\\n```\\n```c++_recursive []\\nclass Solution {\\npublic:\\n    // for the sake of convience, not to include again and again in my function call, I declare target here\\n    int target;\\n    \\n    vector<vector<int>> ans; // 2-D vector to store our answer\\n    \\n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\\n    {\\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\\n        \\n        if(i >= arr.size()) \\n        {\\n            return;\\n        }\\n        \\n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\\n        if(arr[i] + sum == target)\\n        {\\n            op.push_back(arr[i]);\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\\n        if(arr[i] + sum < target)\\n        {\\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\\n            vector<int> op1 = op;\\n            vector<int> op2 = op;\\n            \\n            op2.push_back(arr[i]);\\n            solve(arr, i, sum + arr[i], op2);\\n            solve(arr, i + 1, sum, op1);\\n        }\\n        else\\n        {\\n            solve(arr, i + 1, sum, op); // call for the next index\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\\n        \\n        target = required_target; // give target what he wants \\n        vector<int> op; // op array to try all possible combination\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        solve(arr, 0, 0, op); // call function\\n        \\n        return ans; // return the final answer array\\n    }\\n};\\n```\\n```java_iterative []\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        dfs(answer,new ArrayList<Integer>(), candidates,target,0,0);\\n        return answer;\\n    }\\n  private void dfs(List<List<Integer>> ans,List<Integer> subList,int A[],int target,int curInd,int curSum){\\n        if(curSum>target) return;\\n        if(curSum==target){\\n            ans.add(new ArrayList<>(subList));\\n            return;\\n        }\\n        for(int j=curInd;j<A.length;j++){\\n            subList.add(A[j]);\\n            dfs(ans,subList,A,target,j,curSum+A[j]);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n```\\n```c++ []\\nclass Solution {\\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\\n        if(currSum>target) return; //backtrack\\n        if(currSum==target){\\n            ans.push_back(currComb); //store the solution and backtrack\\n            return;\\n        }\\n        \\n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\\n            currComb.push_back(candidates[i]); //put 1 option into the combination\\n            currSum+=candidates[i];\\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\\n            currSum-=candidates[i];\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> currComb;\\n        combination(candidates, target, currComb, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n```\\n```java_recur []\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        dfs(answer,new ArrayList<Integer>(), candidates,target,0,0);\\n        return answer;\\n    }\\nprivate void dfs(List<List<Integer>> ans,List<Integer> subList,int A[],int target,int curInd,int curSum){\\n        if(curInd==A.length){\\n            if(target==curSum) ans.add(new ArrayList<>(subList));\\n            return;\\n        }\\n        if((curSum+A[curInd])<=target){\\n            subList.add(A[curInd]);\\n            dfs(ans,subList,A,target,curInd,curSum+A[curInd]);\\n            subList.remove(subList.size()-1);\\n        }\\n        dfs(ans,subList,A,target,curInd+1,curSum);\\n    }\\n```\\n# PYTHON\\n\\n```Combinations []\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\\n```Permutations_I []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\\n```Permutations_II []\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n```Subsets_1 []\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n```Subsets_II []\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n```Comb_Sum []\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n```Comb_sum_II []\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```\\n# java \\n\\n```subset []\\nSubsets : https://leetcode.com/problems/subsets/\\n\\npublic List<List<Integer>> subsets(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n    list.add(new ArrayList<>(tempList));\\n    for(int i = start; i < nums.length; i++){\\n        tempList.add(nums[i]);\\n        backtrack(list, tempList, nums, i + 1);\\n        tempList.remove(tempList.size() - 1);\\n    }\\n}\\n```\\n```subset2 []\\nSubsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/\\n\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n    list.add(new ArrayList<>(tempList));\\n    for(int i = start; i < nums.length; i++){\\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n        tempList.add(nums[i]);\\n        backtrack(list, tempList, nums, i + 1);\\n        tempList.remove(tempList.size() - 1);\\n    }\\n} \\n```\\n```perm []\\nPermutations : https://leetcode.com/problems/permutations/\\n\\npublic List<List<Integer>> permute(int[] nums) {\\n   List<List<Integer>> list = new ArrayList<>();\\n   // Arrays.sort(nums); // not necessary\\n   backtrack(list, new ArrayList<>(), nums);\\n   return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n   if(tempList.size() == nums.length){\\n      list.add(new ArrayList<>(tempList));\\n   } else{\\n      for(int i = 0; i < nums.length; i++){ \\n         if(tempList.contains(nums[i])) continue; // element already exists, skip\\n         tempList.add(nums[i]);\\n         backtrack(list, tempList, nums);\\n         tempList.remove(tempList.size() - 1);\\n      }\\n   }\\n} \\n```\\n```permu2 []\\nPermutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/\\n\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n    if(tempList.size() == nums.length){\\n        list.add(new ArrayList<>(tempList));\\n    } else{\\n        for(int i = 0; i < nums.length; i++){\\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n            used[i] = true; \\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, used);\\n            used[i] = false; \\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n```combSum []\\nCombination Sum : https://leetcode.com/problems/combination-sum/\\n\\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{ \\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n```com_sum2 []\\nCombination Sum II (can\\'t reuse same element) : https://leetcode.com/problems/combination-sum-ii/\\n\\npublic List<List<Integer>> combinationSum2(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n    \\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n            tempList.remove(tempList.size() - 1); \\n        }\\n    }\\n} \\n```\\n```palin_part []\\nPalindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/\\npublic List<List<String>> partition(String s) {\\n   List<List<String>> list = new ArrayList<>();\\n   backtrack(list, new ArrayList<>(), s, 0);\\n   return list;\\n}\\n\\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n   if(start == s.length())\\n      list.add(new ArrayList<>(tempList));\\n   else{\\n      for(int i = start; i < s.length(); i++){\\n         if(isPalindrome(s, start, i)){\\n            tempList.add(s.substring(start, i + 1));\\n            backtrack(list, tempList, s, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n         }\\n      }\\n   }\\n}\\n\\npublic boolean isPalindrome(String s, int low, int high){\\n   while(low < high)\\n      if(s.charAt(low++) != s.charAt(high--)) return false;\\n   return true;\\n} \\n```\\n\\n# c++ \\n```comsum1 []\\nAccepted 16ms c++ solution use backtracking for Combination Sum:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\\n        std::sort(candidates.begin(), candidates.end());\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum(candidates, target, res, combination, 0);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {\\n            combination.push_back(candidates[i]);\\n            combinationSum(candidates, target - candidates[i], res, combination, i);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\\n```comsum2 []\\nAccepted 12ms c++ solution use backtracking for Combination Sum II:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum2(std::vector<int> &candidates, int target) {\\n        std::sort(candidates.begin(), candidates.end());\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum2(candidates, target, res, combination, 0);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum2(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i)\\n            if (i == begin || candidates[i] != candidates[i - 1]) {\\n                combination.push_back(candidates[i]);\\n                combinationSum2(candidates, target - candidates[i], res, combination, i + 1);\\n                combination.pop_back();\\n            }\\n    }\\n};\\n```\\n```comSum2 []\\nAccepted 0ms c++ solution use backtracking for Combination Sum III:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum3(int k, int n) {\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum3(n, res, combination, 1, k);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum3(int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin, int need) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        else if (!need)\\n            return;\\n        for (int i = begin; i != 10 && target >= i * need + need * (need - 1) / 2; ++i) {\\n            combination.push_back(i);\\n            combinationSum3(target - i, res, combination, i + 1, need - 1);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity:o(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![mem2.png](https://assets.leetcode.com/users/images/8b0c18c6-2e7d-4ef3-a11b-1ff369dc24f2_1676378307.5784204.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```1_c++_recursive []\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // 2 D vector to store our answer\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\\n    {\\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\\n        if(target == 0) \\n        {\\n            ans.push_back(temp); // include that combination in our answer\\n            return; // and then return, we are now not gonna explore more possiblity\\n        }\\n        \\n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\\n        if(target < 0)\\n            return;\\n        \\n        // if index crosses the last index, we will return saying that no more element is left to choosee\\n        if(i == arr.size())\\n            return;\\n        \\n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \\n\\t\\t//so now, we are doing that\\n        \\n        // we are not taking the ith element,\\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\\n        solve(i + 1, arr, temp, target);\\n        \\n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\\n        \\n        temp.push_back(arr[i]); // including ith element\\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\\n        temp.pop_back(); // backtrack\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\\n        \\n        vector<int> temp; // temporary vector that tries all possible combination\\n        \\n        solve(0, arr, temp, target); // calling function, and see we start from index zero\\n        \\n        return ans; // finally return the answer array\\n    }\\n};\\n```\n```PYTHON_ITERATIVE []\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        ret = []\\n        self.dfs(candidates, target, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, path, ret):\\n        if target < 0:\\n            return \\n        if target == 0:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)\\n```\n```c++_recursive []\\nclass Solution {\\npublic:\\n    // for the sake of convience, not to include again and again in my function call, I declare target here\\n    int target;\\n    \\n    vector<vector<int>> ans; // 2-D vector to store our answer\\n    \\n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\\n    {\\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\\n        \\n        if(i >= arr.size()) \\n        {\\n            return;\\n        }\\n        \\n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\\n        if(arr[i] + sum == target)\\n        {\\n            op.push_back(arr[i]);\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\\n        if(arr[i] + sum < target)\\n        {\\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\\n            vector<int> op1 = op;\\n            vector<int> op2 = op;\\n            \\n            op2.push_back(arr[i]);\\n            solve(arr, i, sum + arr[i], op2);\\n            solve(arr, i + 1, sum, op1);\\n        }\\n        else\\n        {\\n            solve(arr, i + 1, sum, op); // call for the next index\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\\n        \\n        target = required_target; // give target what he wants \\n        vector<int> op; // op array to try all possible combination\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        solve(arr, 0, 0, op); // call function\\n        \\n        return ans; // return the final answer array\\n    }\\n};\\n```\n```java_iterative []\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        dfs(answer,new ArrayList<Integer>(), candidates,target,0,0);\\n        return answer;\\n    }\\n  private void dfs(List<List<Integer>> ans,List<Integer> subList,int A[],int target,int curInd,int curSum){\\n        if(curSum>target) return;\\n        if(curSum==target){\\n            ans.add(new ArrayList<>(subList));\\n            return;\\n        }\\n        for(int j=curInd;j<A.length;j++){\\n            subList.add(A[j]);\\n            dfs(ans,subList,A,target,j,curSum+A[j]);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n```\n```c++ []\\nclass Solution {\\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\\n        if(currSum>target) return; //backtrack\\n        if(currSum==target){\\n            ans.push_back(currComb); //store the solution and backtrack\\n            return;\\n        }\\n        \\n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\\n            currComb.push_back(candidates[i]); //put 1 option into the combination\\n            currSum+=candidates[i];\\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\\n            currSum-=candidates[i];\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> currComb;\\n        combination(candidates, target, currComb, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n```\n```java_recur []\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        dfs(answer,new ArrayList<Integer>(), candidates,target,0,0);\\n        return answer;\\n    }\\nprivate void dfs(List<List<Integer>> ans,List<Integer> subList,int A[],int target,int curInd,int curSum){\\n        if(curInd==A.length){\\n            if(target==curSum) ans.add(new ArrayList<>(subList));\\n            return;\\n        }\\n        if((curSum+A[curInd])<=target){\\n            subList.add(A[curInd]);\\n            dfs(ans,subList,A,target,curInd,curSum+A[curInd]);\\n            subList.remove(subList.size()-1);\\n        }\\n        dfs(ans,subList,A,target,curInd+1,curSum);\\n    }\\n```\n```Combinations []\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```Permutations_I []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```Permutations_II []\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```Subsets_1 []\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```Subsets_II []\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```Comb_Sum []\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```Comb_sum_II []\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```\n```subset []\\nSubsets : https://leetcode.com/problems/subsets/\\n\\npublic List<List<Integer>> subsets(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n    list.add(new ArrayList<>(tempList));\\n    for(int i = start; i < nums.length; i++){\\n        tempList.add(nums[i]);\\n        backtrack(list, tempList, nums, i + 1);\\n        tempList.remove(tempList.size() - 1);\\n    }\\n}\\n```\n```subset2 []\\nSubsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/\\n\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n    list.add(new ArrayList<>(tempList));\\n    for(int i = start; i < nums.length; i++){\\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n        tempList.add(nums[i]);\\n        backtrack(list, tempList, nums, i + 1);\\n        tempList.remove(tempList.size() - 1);\\n    }\\n} \\n```\n```perm []\\nPermutations : https://leetcode.com/problems/permutations/\\n\\npublic List<List<Integer>> permute(int[] nums) {\\n   List<List<Integer>> list = new ArrayList<>();\\n   // Arrays.sort(nums); // not necessary\\n   backtrack(list, new ArrayList<>(), nums);\\n   return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n   if(tempList.size() == nums.length){\\n      list.add(new ArrayList<>(tempList));\\n   } else{\\n      for(int i = 0; i < nums.length; i++){ \\n         if(tempList.contains(nums[i])) continue; // element already exists, skip\\n         tempList.add(nums[i]);\\n         backtrack(list, tempList, nums);\\n         tempList.remove(tempList.size() - 1);\\n      }\\n   }\\n} \\n```\n```permu2 []\\nPermutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/\\n\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n    if(tempList.size() == nums.length){\\n        list.add(new ArrayList<>(tempList));\\n    } else{\\n        for(int i = 0; i < nums.length; i++){\\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n            used[i] = true; \\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, used);\\n            used[i] = false; \\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```combSum []\\nCombination Sum : https://leetcode.com/problems/combination-sum/\\n\\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{ \\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```com_sum2 []\\nCombination Sum II (can\\'t reuse same element) : https://leetcode.com/problems/combination-sum-ii/\\n\\npublic List<List<Integer>> combinationSum2(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n    \\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n            tempList.remove(tempList.size() - 1); \\n        }\\n    }\\n} \\n```\n```palin_part []\\nPalindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/\\npublic List<List<String>> partition(String s) {\\n   List<List<String>> list = new ArrayList<>();\\n   backtrack(list, new ArrayList<>(), s, 0);\\n   return list;\\n}\\n\\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n   if(start == s.length())\\n      list.add(new ArrayList<>(tempList));\\n   else{\\n      for(int i = start; i < s.length(); i++){\\n         if(isPalindrome(s, start, i)){\\n            tempList.add(s.substring(start, i + 1));\\n            backtrack(list, tempList, s, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n         }\\n      }\\n   }\\n}\\n\\npublic boolean isPalindrome(String s, int low, int high){\\n   while(low < high)\\n      if(s.charAt(low++) != s.charAt(high--)) return false;\\n   return true;\\n} \\n```\n```comsum1 []\\nAccepted 16ms c++ solution use backtracking for Combination Sum:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\\n        std::sort(candidates.begin(), candidates.end());\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum(candidates, target, res, combination, 0);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {\\n            combination.push_back(candidates[i]);\\n            combinationSum(candidates, target - candidates[i], res, combination, i);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\n```comsum2 []\\nAccepted 12ms c++ solution use backtracking for Combination Sum II:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum2(std::vector<int> &candidates, int target) {\\n        std::sort(candidates.begin(), candidates.end());\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum2(candidates, target, res, combination, 0);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum2(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i)\\n            if (i == begin || candidates[i] != candidates[i - 1]) {\\n                combination.push_back(candidates[i]);\\n                combinationSum2(candidates, target - candidates[i], res, combination, i + 1);\\n                combination.pop_back();\\n            }\\n    }\\n};\\n```\n```comSum2 []\\nAccepted 0ms c++ solution use backtracking for Combination Sum III:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum3(int k, int n) {\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum3(n, res, combination, 1, k);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum3(int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin, int need) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        else if (!need)\\n            return;\\n        for (int i = begin; i != 10 && target >= i * need + need * (need - 1) / 2; ++i) {\\n            combination.push_back(i);\\n            combinationSum3(target - i, res, combination, i + 1, need - 1);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515817,
                "title": "combination-sum-python-faster-than-98-recursive-approach",
                "content": "```\\n# There are two possibities of making a combination, i.e., to take an element or to not take an element.\\n\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        final = []\\n        def get_combinations(ind, target, arr, result):\\n            if ind == len(arr):\\n                if target == 0:\\n                    final.append(result[:])\\n                return\\n            if arr[ind] <= target:\\n                result.append(arr[ind])\\n                get_combinations(ind, target-arr[ind], arr, result)  # to take the element\\n                result.pop()\\n            get_combinations(ind+1, target, arr, result)  # to not take the element\\n        get_combinations(0, target, candidates, [])\\n        return final\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# There are two possibities of making a combination, i.e., to take an element or to not take an element.\\n\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        final = []\\n        def get_combinations(ind, target, arr, result):\\n            if ind == len(arr):\\n                if target == 0:\\n                    final.append(result[:])\\n                return\\n            if arr[ind] <= target:\\n                result.append(arr[ind])\\n                get_combinations(ind, target-arr[ind], arr, result)  # to take the element\\n                result.pop()\\n            get_combinations(ind+1, target, arr, result)  # to not take the element\\n        get_combinations(0, target, candidates, [])\\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382056,
                "title": "python-faster-than-92-easy-solution",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        path = []\\n        answer = []\\n        def dp(idx, total):\\n            if total == target:\\n                answer.append(path[:])\\n                return\\n            if total > target:\\n                return\\n            \\n            for i in range(idx, len(candidates)):\\n                path.append(candidates[i])\\n                dp(i, total + candidates[i])\\n                path.pop()\\n        \\n        dp(0, 0)\\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        path = []\\n        answer = []\\n        def dp(idx, total):\\n            if total == target:\\n                answer.append(path[:])\\n                return\\n            if total > target:\\n                return\\n            \\n            for i in range(idx, len(candidates)):\\n                path.append(candidates[i])\\n                dp(i, total + candidates[i])\\n                path.pop()\\n        \\n        dp(0, 0)\\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378912,
                "title": "easy-c-detailed-explanation",
                "content": "For this a prior knowledge of recursion and backtracking is required thats it \\n\\n1st Click why recursion --- Since we need to know every kind of combination and also cant possible with regular                                               for and while loop \\n\\n2nd click ---- either include || either we not include it in our data structure approach that get in mind\\n\\nIn this method we just reduce the target till it become equal to 0 by taking each and every possible case of including or not including the combination \\n\\nthinking of approach is difficult but understanding it is much more easier \\n\\n\\nclass Solution {\\n    \\npublic:\\n     void FindCombination( int i , int target , vector<int>&arr , vector<int>&ds , vector<vector<int>>&ans)\\n     {\\n         if(i==arr.size())\\n         {\\n              if(target==0)\\n             {\\n                   ans.push_back(ds) ; \\n             }  \\n             return ; \\n         }      \\n         if(target >= arr[i])\\n         {\\n               ds.push_back(arr[i]) ; \\n              FindCombination(i , target-arr[i] , arr , ds , ans) ; \\n\\t\\t\\t  ds.pop_back() ; // here we are not increasing index so that same element \\n         }                     // pop_back() used for all not including conditions\\n\\t\\t     FindCombination(i+1,target,arr,ds,ans) ; \\n     }\\n   \\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>>ans ; \\n        vector<int>ds ;  // here we simply declare everything we required  \\n        FindCombination(0,target,candidates,ds,ans) ;  // pass it to our recursive function \\n        return ans ; \\n    }\\n};\\n\\nenjoy learning || enjoy leet code \\n\\nif everything is clear make sure to give a up vote",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\npublic:\\n     void FindCombination( int i , int target , vector<int>&arr , vector<int>&ds , vector<vector<int>>&ans)\\n     {\\n         if(i==arr.size())\\n         {\\n              if(target==0)\\n             {\\n                   ans.push_back(ds) ; \\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1777617,
                "title": "js-using-recurison",
                "content": "```\\n\\nconst combinationSum = function(candidates, target) {\\n    const len = candidates.length;\\n    const result = [];\\n    \\n    const recursiveFxn = (sum, idx, arr) => {\\n        if(idx >= len) {\\n            return;\\n        }\\n        if(sum < 0) {\\n            return;\\n        }\\n        if(sum === 0) {\\n            result.push([...arr]);\\n        }\\n        for(let i = idx; i < len; i++) {\\n            arr.push(candidates[i]);\\n            recursiveFxn(sum-candidates[i], i, arr);\\n            arr.pop(candidates[i]);\\n        }\\n        \\n    };\\n\\n    recursiveFxn(target, 0, []);\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nconst combinationSum = function(candidates, target) {\\n    const len = candidates.length;\\n    const result = [];\\n    \\n    const recursiveFxn = (sum, idx, arr) => {\\n        if(idx >= len) {\\n            return;\\n        }\\n        if(sum < 0) {\\n            return;\\n        }\\n        if(sum === 0) {\\n            result.push([...arr]);\\n        }\\n        for(let i = idx; i < len; i++) {\\n            arr.push(candidates[i]);\\n            recursiveFxn(sum-candidates[i], i, arr);\\n            arr.pop(candidates[i]);\\n        }\\n        \\n    };\\n\\n    recursiveFxn(target, 0, []);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777476,
                "title": "python3-easy-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        def dfs(i,arr,total):\\n            if total==target:\\n                ans.append(arr.copy())\\n                return\\n            if i>=len(candidates) or total>target:\\n                return\\n            \\n            arr.append(candidates[i])\\n            dfs(i, arr, total+candidates[i])\\n            arr.pop()\\n            dfs(i+1, arr, total)\\n        dfs(0,[],0)\\n        return ans\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        def dfs(i,arr,total):\\n            if total==target:\\n                ans.append(arr.copy())\\n                return\\n            if i>=len(candidates) or total>target:\\n                return\\n            \\n            arr.append(candidates[i])\\n            dfs(i, arr, total+candidates[i])\\n            arr.pop()\\n            dfs(i+1, arr, total)\\n        dfs(0,[],0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777439,
                "title": "javascript-intutive-solution",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(arr, target) {\\n    let result = []\\n    \\n    findCombination();\\n    return result\\n    \\n    function findCombination(start = 0, sum =0, ans = []){\\n        if(sum > target) return;\\n        if(sum === target){\\n            result.push(ans.slice());\\n        }\\n        \\n        for(let i=start; i<arr.length; i++){\\n            findCombination(i, sum + arr[i], [...ans, arr[i]]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(arr, target) {\\n    let result = []\\n    \\n    findCombination();\\n    return result\\n    \\n    function findCombination(start = 0, sum =0, ans = []){\\n        if(sum > target) return;\\n        if(sum === target){\\n            result.push(ans.slice());\\n        }\\n        \\n        for(let i=start; i<arr.length; i++){\\n            findCombination(i, sum + arr[i], [...ans, arr[i]]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640643,
                "title": "easy-fast-simple-98-92-76-ms-41-1-mb",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    const resArr = []\\n    \\n    const dfs = (i = 0, sum = 0, currentArr = []) => {\\n        if (sum > target) return\\n        if (sum === target) {\\n            resArr.push([...currentArr])\\n            return\\n        }\\n        for (let j = i; j < candidates.length; j++) {\\n            currentArr.push(candidates[j])\\n            dfs(j, sum + candidates[j], currentArr)\\n            currentArr.pop()\\n        }\\n    }\\n    \\n    dfs()\\n    return resArr\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    const resArr = []\\n    \\n    const dfs = (i = 0, sum = 0, currentArr = []) => {\\n        if (sum > target) return\\n        if (sum === target) {\\n            resArr.push([...currentArr])\\n            return\\n        }\\n        for (let j = i; j < candidates.length; j++) {\\n            currentArr.push(candidates[j])\\n            dfs(j, sum + candidates[j], currentArr)\\n            currentArr.pop()\\n        }\\n    }\\n    \\n    dfs()\\n    return resArr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1606874,
                "title": "python-recursion-faster-than-97-9-with-comments-explanation",
                "content": "Pretty simple recusion here.  \\nFirst we verify that the list is sorted smallest to largest (problem didn\\'t specify), then we call into the recursive funciton which starts at the largest number and work backwards.\\n\\nIf the current value matches the target, we add it to the list of combinations on its own.\\n If value > target, or  target - value < smallest candidate, we skip this value.\\n For all other values, pass a slice of the candidate list up to and including the current index back into the recursive function with a new target of target-value.\\n  Then append the current value to all of those sub combinations and pass them back up.\\n\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # Edge Case\\n        if not candidates:\\n            return []\\n        \\n        # Define recursive function\\n        def rc(nums: list[int], target: int) -> list[list[int]]:\\n            nonlocal low_num\\n            combos = []\\n            for i in range(len(nums)-1, -1, -1):\\n                cur_val = nums[i]\\n                if cur_val == target:\\n                    combos.append([target])\\n                elif cur_val + low_num > target:\\n                     # Don\\'t waste time processing sub_combos for a number too large to be in any\\n                    continue\\n                else:\\n                    # Pass the list including current value into function to get all combos for sub-target.\\n                    sub_combos = rc(nums[:i+1], target - cur_val)\\n                    # Now add the current value to all of those combinations.\\n                    for sub in sub_combos:\\n                        sub.append(cur_val)\\n                        combos.append(sub)\\n            return combos\\n\\n        candidates.sort()   # The problem didn\\'t specify that candidates would be ordered.\\n        low_num = candidates[0]    # Used in rc to stop processing values that won\\'t be in any subgroup\\n        return rc(candidates, target)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6a2c3cd2-9879-4bbe-b588-8bbc7a3ce0a5_1638402728.3166742.png)\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # Edge Case\\n        if not candidates:\\n            return []\\n        \\n        # Define recursive function\\n        def rc(nums: list[int], target: int) -> list[list[int]]:\\n            nonlocal low_num\\n            combos = []\\n            for i in range(len(nums)-1, -1, -1):\\n                cur_val = nums[i]\\n                if cur_val == target:\\n                    combos.append([target])\\n                elif cur_val + low_num > target:\\n                     # Don\\'t waste time processing sub_combos for a number too large to be in any\\n                    continue\\n                else:\\n                    # Pass the list including current value into function to get all combos for sub-target.\\n                    sub_combos = rc(nums[:i+1], target - cur_val)\\n                    # Now add the current value to all of those combinations.\\n                    for sub in sub_combos:\\n                        sub.append(cur_val)\\n                        combos.append(sub)\\n            return combos\\n\\n        candidates.sort()   # The problem didn\\'t specify that candidates would be ordered.\\n        low_num = candidates[0]    # Used in rc to stop processing values that won\\'t be in any subgroup\\n        return rc(candidates, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573007,
                "title": "python-using-optimized-decision-tree",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        result = []\\n        def dfs(i, cur, total):\\n            if total == target:\\n                result.append(cur.copy())\\n                return\\n            if i >= len(candidates) or total > target: return\\n            cur.append(candidates[i])\\n            dfs(i, cur, total+candidates[i])\\n            cur.pop()\\n            dfs(i+1, cur, total)\\n            \\n        dfs(0, [], 0)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        result = []\\n        def dfs(i, cur, total):\\n            if total == target:\\n                result.append(cur.copy())\\n                return\\n            if i >= len(candidates) or total > target: return\\n            cur.append(candidates[i])\\n            dfs(i, cur, total+candidates[i])\\n            cur.pop()\\n            dfs(i+1, cur, total)\\n            \\n        dfs(0, [], 0)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435980,
                "title": "javascript-dfs-151ms",
                "content": "Did 40 https://leetcode.com/problems/combination-sum-ii/discuss/1435950/javascript-dfs-128ms first, small change\\n```\\nlet can, n;\\nconst combinationSum = (a, target) => {\\n    a.sort((x, y) => x - y);\\n    let res = [];\\n    can = a, n = a.length;\\n    dfs(target, 0, res, []);\\n    return res;\\n};\\n\\nconst dfs = (sum, start, res, path) => {\\n    if (sum == 0) return res.push([...path]);\\n    for (let i = start; i < n; i++) {\\n        if (can[i] > sum) return;\\n        path.push(can[i]);\\n        dfs(sum - can[i], i, res, path); // allow select the same number, change i + 1 to i \\n        path.pop();\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nlet can, n;\\nconst combinationSum = (a, target) => {\\n    a.sort((x, y) => x - y);\\n    let res = [];\\n    can = a, n = a.length;\\n    dfs(target, 0, res, []);\\n    return res;\\n};\\n\\nconst dfs = (sum, start, res, path) => {\\n    if (sum == 0) return res.push([...path]);\\n    for (let i = start; i < n; i++) {\\n        if (can[i] > sum) return;\\n        path.push(can[i]);\\n        dfs(sum - can[i], i, res, path); // allow select the same number, change i + 1 to i \\n        path.pop();\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1374609,
                "title": "java-backtracking-3ms",
                "content": "```\\nclass Solution \\n{\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) \\n    {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> curr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack( res , curr , 0 ,target,candidates,0);    \\n        return res;\\n    }\\n    public void backtrack( List<List<Integer>> res , List<Integer> curr , int sum ,int target,int[] candidates,int index)\\n    {\\n        if( sum == target )\\n        {\\n            if( !res.contains(curr) )\\n            {\\n                res.add(new ArrayList(curr));    \\n            }\\n            return;\\n        }\\n        for( int i = index ; i < candidates.length ; i++ )\\n        {\\n            if( sum + candidates[i] > target )\\n            {\\n                return;\\n            }\\n            curr.add( candidates[i] );\\n            sum = sum + candidates[i];\\n            backtrack( res , curr , sum , target , candidates ,i);  \\n            //adding index so it does\\'nt start from index 0 if current index is 1-n cauze that possiblity will have\\n            // already been covered when index was 0\\n\\t\\t\\t/*\\n\\t\\t\\teg [2,2,3] has been covered when index was at 0\\n\\t\\t\\tso we need not traverse to index 0 to get [3,2,2] because it\\'s already stored in res.\\n\\t\\t\\t*/\\n            curr.remove( curr.size() - 1 );\\n            sum = sum - candidates[i];\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) \\n    {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> curr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack( res , curr , 0 ,target,candidates,0);    \\n        return res;\\n    }\\n    public void backtrack( List<List<Integer>> res , List<Integer> curr , int sum ,int target,int[] candidates,int index)\\n    {\\n        if( sum == target )\\n        {\\n            if( !res.contains(curr) )\\n            {\\n                res.add(new ArrayList(curr));    \\n            }\\n            return;\\n        }\\n        for( int i = index ; i < candidates.length ; i++ )\\n        {\\n            if( sum + candidates[i] > target )\\n            {\\n                return;\\n            }\\n            curr.add( candidates[i] );\\n            sum = sum + candidates[i];\\n            backtrack( res , curr , sum , target , candidates ,i);  \\n            //adding index so it does\\'nt start from index 0 if current index is 1-n cauze that possiblity will have\\n            // already been covered when index was 0\\n\\t\\t\\t/*\\n\\t\\t\\teg [2,2,3] has been covered when index was at 0\\n\\t\\t\\tso we need not traverse to index 0 to get [3,2,2] because it\\'s already stored in res.\\n\\t\\t\\t*/\\n            curr.remove( curr.size() - 1 );\\n            sum = sum - candidates[i];\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283302,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n     List<List<Integer>> result=new ArrayList<>();\\n        recur(candidates,0,target,result,new ArrayList());\\n        return result;\\n    }\\n    public void recur(int[] c,int start,int target,List<List<Integer>> result,List<Integer> list)\\n    {\\n        if(target<0)\\n            return;\\n        if(target==0)\\n            result.add(new ArrayList(list));\\n        for(int i=start;i<c.length;i++)\\n        {\\n            list.add(c[i]);\\n            recur(c,i,target-c[i],result,list);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n     List<List<Integer>> result=new ArrayList<>();\\n        recur(candidates,0,target,result,new ArrayList());\\n        return result;\\n    }\\n    public void recur(int[] c,int start,int target,List<List<Integer>> result,List<Integer> list)\\n    {\\n        if(target<0)\\n            return;\\n        if(target==0)\\n            result.add(new ArrayList(list));\\n        for(int i=start;i<c.length;i++)\\n        {\\n            list.add(c[i]);\\n            recur(c,i,target-c[i],result,list);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204196,
                "title": "lessons-learned",
                "content": "**Related problems**: All try to teach recursion + loop combo\\n* https://leetcode.com/problems/permutations/ : **(Basics)** on every recursion, iteration starts from 0th index \\n* https://leetcode.com/problems/permutations-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern \\n* https://leetcode.com/problems/combinations/ : **(Basics)** on every recursion, iteration starts from next index (ie, adjacent index to parent recursion iteration index) \\n* https://leetcode.com/problems/combination-sum/ : **(Basics)** sorting helps to prune\\n* https://leetcode.com/problems/combination-sum-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern and Sort+skip adjacent duplicate elements pattern\\n* https://leetcode.com/problems/restore-ip-addresses/ : **(Advanced)** includes special char \\'.\\', StringBuilder, number conversion, number validity check, looped deletion\\n* https://leetcode.com/problems/24-game/ : **(Advanced)** \\n* If you have done the above problems, no need to do: https://leetcode.com/problems/combination-sum-iii/, https://leetcode.com/problems/subsets/, https://leetcode.com/problems/subsets-ii/, https://leetcode.com/problems/letter-combinations-of-a-phone-number/ . These are very similar to the above ones and you won\\'t gain much from these.\\n\\n**Code**:\\n```\\n// My first code\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        recurse(nums, target, 0, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int sum, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (sum == target) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (sum > target) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target, sum + nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Better: if you sort the candidates first, then you can skip computing next elements (might be a million next elements) by exiting early from the for loop as soon as you see a candidate that is bigger than the remaining target. Similar technique (not sorting always) can be applied in various backtracking problems to prune the recursive tree.\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);\\n        recurse(nums, target, 0, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int sum, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (sum == target) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (sum > target) return;\\n        \\n        for (int i = start; i < nums.length && sum + nums[i] <= target; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target, sum + nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Best: Nothing much. Just removed the redundant variable for \\'sum\\' and used \\'target\\' alone. Could use this little trick for various sum problems (already found in tree problems)\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length && target - nums[i] >= 0; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// My first code\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        recurse(nums, target, 0, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int sum, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (sum == target) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (sum > target) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target, sum + nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Better: if you sort the candidates first, then you can skip computing next elements (might be a million next elements) by exiting early from the for loop as soon as you see a candidate that is bigger than the remaining target. Similar technique (not sorting always) can be applied in various backtracking problems to prune the recursive tree.\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);\\n        recurse(nums, target, 0, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int sum, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (sum == target) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (sum > target) return;\\n        \\n        for (int i = start; i < nums.length && sum + nums[i] <= target; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target, sum + nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Best: Nothing much. Just removed the redundant variable for \\'sum\\' and used \\'target\\' alone. Could use this little trick for various sum problems (already found in tree problems)\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length && target - nums[i] >= 0; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141751,
                "title": "python3-no-sorting",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        def backtracking(output,start,res):\\n            if res == target:\\n                ans.append(list(output))\\n                return\\n            \\n            for i in range(start,len(candidates)):\\n                if res<=target:\\n                    output.append(candidates[i])\\n                    backtracking(output,i,res+candidates[i])\\n                    output.pop()\\n\\n        \\n        backtracking([],0,0)  \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        def backtracking(output,start,res):\\n            if res == target:\\n                ans.append(list(output))\\n                return\\n            \\n            for i in range(start,len(candidates)):\\n                if res<=target:\\n                    output.append(candidates[i])\\n                    backtracking(output,i,res+candidates[i])\\n                    output.pop()\\n\\n        \\n        backtracking([],0,0)  \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121660,
                "title": "share-my-c-recursive-solution-easy-and-clean-code",
                "content": "### **Code**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> tmp;\\n        helper(candidates, target, 0, res, tmp);\\n        return res;\\n    }\\n    void helper(vector<int>& candidates, int target, int start, vector<vector<int>>& res, vector<int>& tmp){\\n        for (int i = start; i < candidates.size(); ++i){\\n            int diff = target - candidates[i];\\n            if (diff == 0){\\n                tmp.push_back(candidates[i]);\\n                res.push_back(tmp);\\n                tmp.pop_back();\\n            }\\n            else if (diff > 0){\\n                tmp.push_back(candidates[i]);\\n                helper(candidates, diff, i, res, tmp);\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\n### **Performance**\\n- Runtime: 8 ms, faster than 78.42%\\n- Memory Usage: 10.8 MB, less than 91.65%",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> tmp;\\n        helper(candidates, target, 0, res, tmp);\\n        return res;\\n    }\\n    void helper(vector<int>& candidates, int target, int start, vector<vector<int>>& res, vector<int>& tmp){\\n        for (int i = start; i < candidates.size(); ++i){\\n            int diff = target - candidates[i];\\n            if (diff == 0){\\n                tmp.push_back(candidates[i]);\\n                res.push_back(tmp);\\n                tmp.pop_back();\\n            }\\n            else if (diff > 0){\\n                tmp.push_back(candidates[i]);\\n                helper(candidates, diff, i, res, tmp);\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564870,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568512,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1565727,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1566902,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1569455,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1567175,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568222,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568863,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1567176,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568455,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1564870,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568512,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1565727,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1566902,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1569455,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1567175,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568222,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568863,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1567176,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568455,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1872909,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1737630,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1572487,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1568861,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1568862,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1877541,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1568860,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1957710,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1845108,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1575383,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1572719,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1572280,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1571096,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1568859,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 2050310,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 2027858,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1910929,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1878594,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1863942,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1856096,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1853675,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1838875,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1816295,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1812483,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1810863,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1792169,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1757991,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1752613,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1742004,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1735237,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1734199,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1731903,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1728166,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1718488,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1709648,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1698847,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1679753,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1674057,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1671311,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1648678,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            }
        ]
    }
]