[
    {
        "title": "Defuse the Bomb",
        "question_content": "You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code&nbsp;of length of n&nbsp;and a key k.\nTo decrypt the code, you must replace every number. All the numbers are replaced simultaneously.\n\n\tIf k > 0, replace the ith number with the sum of the next k numbers.\n\tIf k < 0, replace the ith number with the sum of the previous k numbers.\n\tIf k == 0, replace the ith number with 0.\n\nAs code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].\nGiven the circular array code and an integer key k, return the decrypted code to defuse the bomb!\n&nbsp;\nExample 1:\n\nInput: code = [5,7,1,4], k = 3\nOutput: [12,10,16,13]\nExplanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.\n\nExample 2:\n\nInput: code = [1,2,3,4], k = 0\nOutput: [0,0,0,0]\nExplanation: When k is zero, the numbers are replaced by 0. \n\nExample 3:\n\nInput: code = [2,4,9,3], k = -2\nOutput: [12,5,6,13]\nExplanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.\n\n&nbsp;\nConstraints:\n\n\tn == code.length\n\t1 <= n&nbsp;<= 100\n\t1 <= code[i] <= 100\n\t-(n - 1) <= k <= n - 1",
        "solutions": [
            {
                "id": 935398,
                "title": "java-o-n-100-time-and-space-short-concise-sliding-window",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] res = new int[code.length];\\n        if (k == 0) return res;\\n        //Define the initial window and initial sum\\n        int start = 1, end = k, sum = 0;\\n        if (k < 0) {//If k < 0, the starting point will be end of the array.\\n            k = -k;\\n            start = code.length - k;\\n            end = code.length - 1;\\n        }\\n        for (int i = start; i <= end; i++) sum += code[i];\\n        //Scan through the code array as i moving to the right, update the window sum.\\n        for (int i = 0; i < code.length; i++) {\\n            res[i] = sum;\\n            sum -= code[(start++) % code.length];\\n            sum += code[(++end) % code.length];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] res = new int[code.length];\\n        if (k == 0) return res;\\n        //Define the initial window and initial sum\\n        int start = 1, end = k, sum = 0;\\n        if (k < 0) {//If k < 0, the starting point will be end of the array.\\n            k = -k;\\n            start = code.length - k;\\n            end = code.length - 1;\\n        }\\n        for (int i = start; i <= end; i++) sum += code[i];\\n        //Scan through the code array as i moving to the right, update the window sum.\\n        for (int i = 0; i < code.length; i++) {\\n            res[i] = sum;\\n            sum -= code[(start++) % code.length];\\n            sum += code[(++end) % code.length];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948726,
                "title": "c-sliding-window-linear-time-and-constant-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t// Taking a window of k elements\\n\\t\\t\\n\\t\\t// First window will be from index 1 to index k\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n\\t\\t   // if k is negative then the first window will be the last k elements\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        // maintaining first window\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            // sliding the window \\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t// Taking a window of k elements\\n\\t\\t\\n\\t\\t// First window will be from index 1 to index k\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n\\t\\t   // if k is negative then the first window will be the last k elements\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        // maintaining first window\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            // sliding the window \\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935444,
                "title": "clean-python-3-prefix-sum-o-n",
                "content": "Use the prefix sum trick to get range sum in O(1)\\nTime: `O(N)`\\nSpace: `O(N)`\\nThanks @WangQiuc\\'s suggestion.\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(1, 2 * n):\\n            prefix[i] += prefix[i - 1]\\n        for i in range(n):\\n            code[i] = prefix[i + k] - prefix[i]\\n        return code\\n```\\n\\nOne pass\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(2 * n):\\n            prefix[i] += i > 0 and prefix[i - 1]\\n            if k <= i < n + k:\\n                code[i - k] = prefix[i] - prefix[i - k]\\n        return code\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(1, 2 * n):\\n            prefix[i] += prefix[i - 1]\\n        for i in range(n):\\n            code[i] = prefix[i + k] - prefix[i]\\n        return code\\n```\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(2 * n):\\n            prefix[i] += i > 0 and prefix[i - 1]\\n            if k <= i < n + k:\\n                code[i - k] = prefix[i] - prefix[i - k]\\n        return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936749,
                "title": "pyhton3-beats-100-double-the-code-array",
                "content": "Double the ```code``` array so that it\\'s easy to iterate.\\n```class Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k==0: return [0 for i in code]\\n        temp = code\\n        code = code*2\\n        for i in range(len(temp)):\\n            if k>0:\\n                temp[i] = sum(code[i+1:i+k+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        return temp",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```code```",
                "codeTag": "Unknown"
            },
            {
                "id": 935478,
                "title": "python-3-clean-sliding-window",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```\\n\\n- for negative k: reverse params and result\\n- calculate sum of k element, then iteratively add new element and remove oldest one.\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935457,
                "title": "my-short-easy-to-understand-solution",
                "content": "To deal with this kind of problem, we need to play with the index wisely and carefully, just like defusing a bomb (lol). There are 3 points we need to notice:\\n\\n0. We need to return the result directly if k == 0 based on the problem statement. (I will handle this case specifically, to make it more readable and slightly faster :) )\\n1. We need to do ***%*** to make sure the index is always in-bound when k > 0;\\n2. We need to do ***+code.length*** to make sure it is alway > 0, and ***%*** to make sure the index is always in-bound when k < 0.\\n\\nHere is my code: \\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint[] result = new int[code.length];\\n\\tif (k == 0) {\\n\\t\\treturn result;\\n\\t}\\n\\tfor (int i = 0; i < result.length; i++) {\\n\\t\\tif (k > 0) {\\n\\t\\t\\tfor (int j = i + 1; j < i + k + 1; j++) {\\n\\t\\t\\t\\tresult[i] += code[j % code.length];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = i - 1; j > i + k - 1; j--) {\\n\\t\\t\\t\\tresult[i] += code[(j + code.length) % code.length];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;        \\n}\\n```\\n\\nPlease upvote if you find this is helpful! :)",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint[] result = new int[code.length];\\n\\tif (k == 0) {\\n\\t\\treturn result;\\n\\t}\\n\\tfor (int i = 0; i < result.length; i++) {\\n\\t\\tif (k > 0) {\\n\\t\\t\\tfor (int j = i + 1; j < i + k + 1; j++) {\\n\\t\\t\\t\\tresult[i] += code[j % code.length];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = i - 1; j > i + k - 1; j--) {\\n\\t\\t\\t\\tresult[i] += code[(j + code.length) % code.length];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942580,
                "title": "c-easy-solution-brute-force",
                "content": "if you don\\'t know how this code works,you could comment below.\\nI will try my best to answer your question! :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int>Ans(code.size(),0);\\n        \\n        for(int i = 0;i<code.size();i++){\\n            if (k > 0){\\n                int total = 0;\\n                for(int count = 1;count<=k;count++){\\n                    int num = i + count;\\n                    num = num % code.size(); \\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else if (k < 0){\\n                int total = 0;\\n                for(int count = -1;count>=k;count--){\\n                    int num = i + count;\\n                    if (num < 0){\\n                        num = code.size() + num;\\n                    }\\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else{\\n                Ans[i] = 0;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int>Ans(code.size(),0);\\n        \\n        for(int i = 0;i<code.size();i++){\\n            if (k > 0){\\n                int total = 0;\\n                for(int count = 1;count<=k;count++){\\n                    int num = i + count;\\n                    num = num % code.size(); \\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else if (k < 0){\\n                int total = 0;\\n                for(int count = -1;count>=k;count--){\\n                    int num = i + count;\\n                    if (num < 0){\\n                        num = code.size() + num;\\n                    }\\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else{\\n                Ans[i] = 0;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218554,
                "title": "very-easy-solution-explained-with-sample-implementation-break-the-cycle-prefix-suffix-sum",
                "content": "*------Please **upvote** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**EXPLANATION:**\\n\\n**Prerequisites -** *Prefix Sum* and *Suffix Sum* of an Array.\\n\\nFirst, we **simplify** the problem by **breaking the cycle.** \\n\\n*****How?*****  Just append the array to itself and the cycle will be broken into a linear array.\\n\\nTake the sample input array **code** as: **[5, 7, 1, 4]**\\nAppending it to itself, we get our new array **arr** as: **[5, 7, 1, 4, 5, 7, 1, 4]**.  We will now use this array for calculation.\\n\\n1. If **k = 0**: Just change all array elements of **code** to **0** and return **code**.\\n\\n2. If **k > 0**:  We calculate the **prefix** sum array **pre** of **arr** and our result for every index **i** would be **pre [i + k] - pre [i]**.  Sample implementation:\\n\\n**arr:** `[5, 7, 1, 4, 5, 7, 1, 4]`\\n**pre:** `[5, 12, 13, 17, 22, 29, 30, 34]`\\n\\n**k = 2**\\n\\nNow, for every index **i**: **code [i]** will become **pre [i + 2] - pre [i]**.\\n\\n**i = 0**: `code [0]` = `pre [0 + 2] - pre [0]` = `pre [2] - pre [0]` = **8**\\n**i = 1**: `code [1]` = `pre [1 + 2] - pre [1]` = `pre [3] - pre [1]` = **5**\\n**i = 2**: `code [2]` = `pre [2 + 2] - pre [2]` = `pre [4] - pre [2]` = **9**\\n**i = 3**: `code [3]` = `pre [3 + 2] - pre [3]` = `pre [5] - pre [3]` = **12**\\n\\nReturn **code** as **`[8, 5, 9, 12]`**\\n\\n3. If **k < 0**:  We calculate the **suffix** sum array **suf** of **arr** and our result for every index **i** would be **suf [i + n - k] - suf [i + n]** where **`n = length (code)`**.  Sample implementation:\\n\\n**arr:** `[5, 7, 1, 4, 5, 7, 1, 4]`\\n**suf:** `[34, 29, 22, 21, 17, 12, 5, 4]`\\n\\n**k = -2**\\n\\nHere, we will proceed in the reverse order (right - to - left) because the suffix sum is calculated from the right - to - left direction.\\n\\nNow, for every index **i**: **code [i]** will become **suf [i + 4 - 2] - suf [i + 4]**.\\n\\n**i = 3**: `code [3]` = `suf [3 + 4 - 2] - suf [3 + 4]` = `suf [5] - suf [7]` = **8**\\n**i = 2**: `code [2]` = `suf [2 + 4 - 2] - suf [2 + 4]` = `suf [4] - suf [6]` = **12**\\n**i = 1**: `code [1]` = `suf [1 + 4 - 2] - suf [1 + 4]` = `suf [3] - suf [5]` = **9**\\n**i = 0**: `code [0]` = `suf [0 + 4 - 2] - suf [0 + 4]` = `suf [2] - suf [4]` = **5**\\n\\nReturn **code** as **`[5, 9, 12, 8]`**\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = 0;\\n        }\\n        \\n        else if (k > 0) {\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int prefix [] = new int [arr.length];\\n            prefix [0] = arr [0];\\n            for (int i = 1; i < prefix.length; i++)\\n                prefix [i] = prefix [i-1] + arr [i];\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = prefix [i + k] - prefix [i];\\n        }\\n        \\n        else {\\n            k = Math.abs (k);\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int suffix [] = new int [arr.length];\\n            suffix [arr.length - 1] = arr [arr.length - 1];\\n            for (int i = suffix.length - 2; i >= 0; i--)\\n                suffix [i] = suffix [i+1] + arr [i];\\n            for (int i = code.length - 1; i >= 0; i--)\\n                code [i] = suffix [i + code.length - k] - suffix [i + code.length];\\n        }\\n        \\n        return code;\\n    }\\n}\\n```\\n\\nPlease **upvote!** if you like the solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = 0;\\n        }\\n        \\n        else if (k > 0) {\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int prefix [] = new int [arr.length];\\n            prefix [0] = arr [0];\\n            for (int i = 1; i < prefix.length; i++)\\n                prefix [i] = prefix [i-1] + arr [i];\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = prefix [i + k] - prefix [i];\\n        }\\n        \\n        else {\\n            k = Math.abs (k);\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int suffix [] = new int [arr.length];\\n            suffix [arr.length - 1] = arr [arr.length - 1];\\n            for (int i = suffix.length - 2; i >= 0; i--)\\n                suffix [i] = suffix [i+1] + arr [i];\\n            for (int i = code.length - 1; i >= 0; i--)\\n                code [i] = suffix [i + code.length - k] - suffix [i + code.length];\\n        }\\n        \\n        return code;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947553,
                "title": "java-o-n-using-prefix-sum-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] presum = new int[code.length];\\n        int[] postsum = new int[code.length];\\n\\t\\t\\n\\t\\t//Create prefix sum array\\n        int sum = 0;\\n        for(int i=0; i<code.length; ++i){\\n            sum += code[i];\\n            presum[i] = sum;\\n        }\\n        \\n\\t\\t//Create prefix sum array in reverse\\n        sum=0;\\n        for(int i=code.length-1; i>=0; --i){\\n            sum += code[i];\\n            postsum[i] = sum;\\n        }\\n        \\n        for(int i=0; i<code.length; ++i){\\n            if(k > 0){\\n                if((i+k) < code.length){\\n                    code[i] = presum[i+k]-presum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//presum[code.length-1] - presum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//presum[k-(code.length -i)]; --> Elements left of i\\n                    code[i] = presum[code.length-1] - presum[i] + presum[k-(code.length -i)];\\n                }   \\n            }else if(k == 0){\\n                code[i] = 0;\\n            }else{\\n                if(i+k >= 0){\\n                    code[i] = postsum[i+k] - postsum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//postsum[0] - postsum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//postsum[code.length+(i+k)] --> Elements left of i\\n                    code[i] = postsum[0] - postsum[i] + postsum[code.length+(i+k)];\\n                }\\n            }\\n        }\\n\\t\\t\\n        return code;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] presum = new int[code.length];\\n        int[] postsum = new int[code.length];\\n\\t\\t\\n\\t\\t//Create prefix sum array\\n        int sum = 0;\\n        for(int i=0; i<code.length; ++i){\\n            sum += code[i];\\n            presum[i] = sum;\\n        }\\n        \\n\\t\\t//Create prefix sum array in reverse\\n        sum=0;\\n        for(int i=code.length-1; i>=0; --i){\\n            sum += code[i];\\n            postsum[i] = sum;\\n        }\\n        \\n        for(int i=0; i<code.length; ++i){\\n            if(k > 0){\\n                if((i+k) < code.length){\\n                    code[i] = presum[i+k]-presum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//presum[code.length-1] - presum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//presum[k-(code.length -i)]; --> Elements left of i\\n                    code[i] = presum[code.length-1] - presum[i] + presum[k-(code.length -i)];\\n                }   \\n            }else if(k == 0){\\n                code[i] = 0;\\n            }else{\\n                if(i+k >= 0){\\n                    code[i] = postsum[i+k] - postsum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//postsum[0] - postsum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//postsum[code.length+(i+k)] --> Elements left of i\\n                    code[i] = postsum[0] - postsum[i] + postsum[code.length+(i+k)];\\n                }\\n            }\\n        }\\n\\t\\t\\n        return code;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285276,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n     public int[] decrypt(int[] code, int k) {\\n        int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int[] decrypt(int[] code, int k) {\\n        int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153936,
                "title": "simple-and-easy",
                "content": "```\\noutput = []\\nfor i in range(len(code)):\\n\\tif k > 0:\\n\\t\\tsum = 0\\n\\t\\tj = i+1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm-=1\\n\\t\\t\\tj+=1\\n\\t\\toutput.append(sum)\\n\\n\\telif k == 0:\\n\\t\\toutput.append(0)\\n\\n\\telse:\\n\\t\\tsum = 0\\n\\t\\tj = i-1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm+=1\\n\\t\\t\\tj-=1\\n\\t\\toutput.append(sum)\\n\\nreturn output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\noutput = []\\nfor i in range(len(code)):\\n\\tif k > 0:\\n\\t\\tsum = 0\\n\\t\\tj = i+1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm-=1\\n\\t\\t\\tj+=1\\n\\t\\toutput.append(sum)\\n\\n\\telif k == 0:\\n\\t\\toutput.append(0)\\n\\n\\telse:\\n\\t\\tsum = 0\\n\\t\\tj = i-1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm+=1\\n\\t\\t\\tj-=1\\n\\t\\toutput.append(sum)\\n\\nreturn output\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008102,
                "title": "go-o-n-0ms-2-3mb-sliding-window-with-wrapping-indexes",
                "content": "```\\nfunc decrypt(code []int, k int) []int {\\n    n := len(code)\\n    result := make([]int, n)\\n    if k == 0 {\\n        return result\\n    }\\n    start, end := 1, k + 1\\n    if k < 0 {\\n        start, end  =  n + k, n\\n    }\\n    s := 0\\n    for i := start; i < end; i++ {\\n        s += code[i]\\n    }\\n    for i := 0; i < n; i++ {\\n        result[i] = s\\n        s = s - code[(start + i) % n] + code[(end + i) % n]\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    n := len(code)\\n    result := make([]int, n)\\n    if k == 0 {\\n        return result\\n    }\\n    start, end := 1, k + 1\\n    if k < 0 {\\n        start, end  =  n + k, n\\n    }\\n    s := 0\\n    for i := start; i < end; i++ {\\n        s += code[i]\\n    }\\n    for i := 0; i < n; i++ {\\n        result[i] = s\\n        s = s - code[(start + i) % n] + code[(end + i) % n]\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942554,
                "title": "java-o-n-clear-explanation-beats-100",
                "content": "The idea is that for each index i, we will need to be able to query the sum of the next or prev k numbers - an easy way to achieve this is to cache the prefix sums.\\n\\nHowever, there is the added complexity of circular array so we can simply create a prefix sum array that is twice the normal length. Essentially caching the prefix sums of the array repeated.\\n\\ni.e. For something like A = [1,2,3,4], we can concatentate it with itself to create B = [1,2,3,4,1,2,3,4] so that it is easier to work with when applying circular things. \\n\\nWhen working with A, if k = 3 and i = 1, then normally we would have an add indexes 2, 3 and 4. However, index 4 would in fact be index 0 since we are working with a circular array. With our concatenated array B, we would be able to directly access index 4.\\n\\nTaking this concept 1 step further, we can then prefix sum cache this concatenated version which gives us a prefix sum cache that can find circular ranges. So if k < 0, we can find the range sum of [i-k, i-1] and if k > 0, we can find the range sum of [i+1, i+k].\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if(k == 0) return new int[code.length];\\n        \\n        int[] prefix = new int[code.length * 2 + 1];\\n        for(int i = 0; i < code.length * 2; i++) {\\n            prefix[i+1] = prefix[i] + code[i % code.length];\\n        }\\n        \\n        int[] ret = new int[code.length];\\n        for(int i = 0; i < code.length; i++) {\\n            int end = i + k;\\n            if(k < 0) {\\n                ret[i] = prefix[i + code.length] - prefix[end + code.length];\\n            }\\n            else {\\n                ret[i] = prefix[end + 1] - prefix[i+1];\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if(k == 0) return new int[code.length];\\n        \\n        int[] prefix = new int[code.length * 2 + 1];\\n        for(int i = 0; i < code.length * 2; i++) {\\n            prefix[i+1] = prefix[i] + code[i % code.length];\\n        }\\n        \\n        int[] ret = new int[code.length];\\n        for(int i = 0; i < code.length; i++) {\\n            int end = i + k;\\n            if(k < 0) {\\n                ret[i] = prefix[i + code.length] - prefix[end + code.length];\\n            }\\n            else {\\n                ret[i] = prefix[end + 1] - prefix[i+1];\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352139,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        l = code + code\\n        if k == 0:\\n            return [0]*n\\n        elif k > 0:\\n            ans = []\\n            for i in range(n):\\n                ans.append(sum(l[i+1:i+k+1]))\\n            return ans\\n        else:\\n            ans = []\\n            j = n\\n            for i in range(n):\\n                ans.append(sum(l[j+k:j]))\\n                j += 1\\n            return ans\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        l = code + code\\n        if k == 0:\\n            return [0]*n\\n        elif k > 0:\\n            ans = []\\n            for i in range(n):\\n                ans.append(sum(l[i+1:i+k+1]))\\n            return ans\\n        else:\\n            ans = []\\n            j = n\\n            for i in range(n):\\n                ans.append(sum(l[j+k:j]))\\n                j += 1\\n            return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 971143,
                "title": "javascript-simple",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    var res = new Array(code.length).fill(0)\\n    if (k > 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i + 1\\n            while(count < k){\\n                if (j === code.length) j = 0\\n                res[i] += code[j]\\n                count = count + 1\\n                j++\\n            }\\n        }\\n    }\\n    if (k < 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i - 1\\n            while(count > k){\\n                if (j === -1) j = code.length - 1\\n                res[i] += code[j]\\n                count = count - 1\\n                j--\\n            }\\n        }\\n    }\\n    return res \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    var res = new Array(code.length).fill(0)\\n    if (k > 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i + 1\\n            while(count < k){\\n                if (j === code.length) j = 0\\n                res[i] += code[j]\\n                count = count + 1\\n                j++\\n            }\\n        }\\n    }\\n    if (k < 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i - 1\\n            while(count > k){\\n                if (j === -1) j = code.length - 1\\n                res[i] += code[j]\\n                count = count - 1\\n                j--\\n            }\\n        }\\n    }\\n    return res \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367476,
                "title": "defuse-the-bomb-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int i, j, m, num;\\n        vector<int> ans;\\n        for(i=0 ; i<code.size() ; i++)\\n        {\\n            num=0;\\n            j = i;\\n            m = abs(k);\\n            while(m--)\\n            {\\n                if(k<0)\\n                {\\n                    j = j-1;\\n                    if(j<0)\\n                        j += code.size();\\n                    num += code[j];\\n                }\\n                else if(k>0)\\n                {\\n                    j = j+1;\\n                    if(j>=code.size())\\n                        j -= code.size();\\n                    num += code[j];\\n                }\\n            }\\n            ans.push_back(num);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int i, j, m, num;\\n        vector<int> ans;\\n        for(i=0 ; i<code.size() ; i++)\\n        {\\n            num=0;\\n            j = i;\\n            m = abs(k);\\n            while(m--)\\n            {\\n                if(k<0)\\n                {\\n                    j = j-1;\\n                    if(j<0)\\n                        j += code.size();\\n                    num += code[j];\\n                }\\n                else if(k>0)\\n                {\\n                    j = j+1;\\n                    if(j>=code.size())\\n                        j -= code.size();\\n                    num += code[j];\\n                }\\n            }\\n            ans.push_back(num);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482725,
                "title": "defuse-the-bomb",
                "content": "\\tclass Solution:\\n\\t\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n\\t\\t\\tlength = len(code) \\n\\t\\t\\tans=[0 for i in range(length)] \\n\\n\\t\\t\\tif k==0:  return ans \\n\\n\\t\\t\\tif k < 0:  code.reverse() \\n\\n\\t\\t\\tsumm = sum(code[:abs(k)])\\n\\n\\t\\t\\tfor i in range(length):\\n\\t\\t\\t\\t\\tsumm = summ-code[i]+code[(i+abs(k))%length]   \\n\\t\\t\\t\\t\\tans[i] = summ \\n\\n\\t\\t\\treturn reversed(ans) if k<0 else ans  \\n\\t\\t\\t\\n\\t\\t\\t",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n\\t\\t\\tlength = len(code) \\n\\t\\t\\tans=[0 for i in range(length)] \\n\\n\\t\\t\\tif k==0:  return ans \\n\\n\\t\\t\\tif k < 0:  code.reverse() \\n\\n\\t\\t\\tsumm = sum(code[:abs(k)])\\n\\n\\t\\t\\tfor i in range(length):\\n\\t\\t\\t\\t\\tsumm = summ-code[i]+code[(i+abs(k))%length]   \\n\\t\\t\\t\\t\\tans[i] = summ \\n\\n\\t\\t\\treturn reversed(ans) if k<0 else ans  \\n\\t\\t\\t\\n\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1903674,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0] * len(code)\\n        data = code + code\\n        result = [sum(data[i + 1: i + 1 + abs(k)]) for i in range(len(code))]\\n\\t\\t# result = []\\n        # for i in range(len(code)):\\n        #     result.append(sum(data[i + 1: i + 1 + abs(k)]))\\n        if 0 > k:\\n            return result[k - 1:] + result[:k - 1]\\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0] * len(code)\\n        data = code + code\\n        result = [sum(data[i + 1: i + 1 + abs(k)]) for i in range(len(code))]\\n\\t\\t# result = []\\n        # for i in range(len(code)):\\n        #     result.append(sum(data[i + 1: i + 1 + abs(k)]))\\n        if 0 > k:\\n            return result[k - 1:] + result[:k - 1]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384496,
                "title": "c-solution-simple-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n    vector<int> ans;\\n    int n=code.size();\\n    if (k > 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + 1, temp = 0;\\n            while (temp++ != k)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else if (k < 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + k + n, temp = k;\\n            while (temp++ != 0)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else\\n        for (int i = 0; i < n; i++)\\n            ans.push_back(0);\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n    vector<int> ans;\\n    int n=code.size();\\n    if (k > 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + 1, temp = 0;\\n            while (temp++ != k)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else if (k < 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + k + n, temp = k;\\n            while (temp++ != 0)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else\\n        for (int i = 0; i < n; i++)\\n            ans.push_back(0);\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152661,
                "title": "python-3-o-n-sliding-window-with-array-rotation",
                "content": "# Intuition\\nOn close inspection we find that K<0 case solution is just a rotated form of K>0 solution\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nReturn 0 array for k==0 case and for other case find the next k sum array by sliding window technique and in case the k value is negative then rotate the ans list by k-1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ans=[]\\n        s=0\\n        if k==0:\\n            ans = [0]*len(code)\\n        else:\\n            absK=abs(k)\\n            s=sum(code[0:absK])\\n            for i in range(len(code)):\\n                s=s-code[i]+code[(i+absK)%len(code)]\\n                ans.append(s)\\n            if k<0:\\n                ans=ans[k-1:]+ans[:k-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ans=[]\\n        s=0\\n        if k==0:\\n            ans = [0]*len(code)\\n        else:\\n            absK=abs(k)\\n            s=sum(code[0:absK])\\n            for i in range(len(code)):\\n                s=s-code[i]+code[(i+absK)%len(code)]\\n                ans.append(s)\\n            if k<0:\\n                ans=ans[k-1:]+ans[:k-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933571,
                "title": "java-sliding-window-explained",
                "content": "**Idea:** Use a sliding window to maintain sum\\n>**T/S:** O(n)/O(1), where n = size(code), (ignoring space for output)\\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tvar n = code.length;\\n\\treturn k > 0 \\n\\t\\t ? decrypt(code, new int[n], k, 1, k + 1) \\n\\t\\t : decrypt(code, new int[n], k, n + k, n);\\n}\\n\\n// [left, right)\\nprivate int[] decrypt(int[] code, int[] decode, int k, int left, int right) {\\n\\tif (k == 0)\\n\\t\\treturn decode;\\n\\t\\t\\n\\tvar sum = decode[0] = Arrays.stream(code, left, right).sum();\\n\\t\\n\\tfor (int i = 1, n = decode.length; i < n; i++, left++, right++)\\n\\t\\tdecode[i] = sum += code[right % n] - code[left % n];\\n\\t\\n\\treturn decode;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tvar n = code.length;\\n\\treturn k > 0 \\n\\t\\t ? decrypt(code, new int[n], k, 1, k + 1) \\n\\t\\t : decrypt(code, new int[n], k, n + k, n);\\n}\\n\\n// [left, right)\\nprivate int[] decrypt(int[] code, int[] decode, int k, int left, int right) {\\n\\tif (k == 0)\\n\\t\\treturn decode;\\n\\t\\t\\n\\tvar sum = decode[0] = Arrays.stream(code, left, right).sum();\\n\\t\\n\\tfor (int i = 1, n = decode.length; i < n; i++, left++, right++)\\n\\t\\tdecode[i] = sum += code[right % n] - code[left % n];\\n\\t\\n\\treturn decode;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2819345,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n\\n   class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n   class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599513,
                "title": "java-beats-100-simple",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int res[]=new int[code.length];\\n        if(k==0) return res;\\n        int i= (k>0) ? 1 : code.length-1;\\n        int j=i;\\n        int sum=0;\\n        if(k>0){\\n            while(--k>=0)\\n            {\\n               sum+=code[j++]; \\n            }\\n            j--;\\n        }else{\\n            while(++k<=0){\\n                sum+=code[j--]; \\n            }\\n            j++;\\n            int temp=j;\\n            j=i;\\n            i=temp;\\n        }\\n        \\n        for(int p=0;p<code.length;p++){\\n            res[p]=sum;\\n          //  System.out.println(i+\" \"+j);\\n            j=(j+1)%code.length;\\n            sum=sum+(code[j]-code[i]);\\n            i=(i+1)%code.length;\\n        }\\n        return res;\\n    }\\n}\\nPlease upvote if you like the solution \\uD83D\\uDE4F",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int res[]=new int[code.length];\\n        if(k==0) return res;\\n        int i= (k>0) ? 1 : code.length-1;\\n        int j=i;\\n        int sum=0;\\n        if(k>0){\\n            while(--k>=0)\\n            {\\n               sum+=code[j++]; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2304860,
                "title": "defuse-the-bomb-solution-in-c",
                "content": "**Here You Go =>**\\n\\n```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    int* result=malloc(codeSize*sizeof(int));\\n    int n1,sum;\\n    if (k>0){\\n        for (int i=0;i<codeSize;i++){           // To cover all elements in code array\\n            for (int j=1;j<=k;j++){             // Cover elements till k\\n                n1=code[(i+j)%codeSize];        // As it is a circular array, modulo by size of code array will give the desired result.\\n                                                // I recommend to DRY-RUN this line for Example in description to understand the working.\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;                               // Initialize n1 and sum to zero for next iteration.\\n            sum=0;\\n        }\\n    }\\n    \\n    // For k=0\\n    else if(k==0){\\n        for (int i=0;i<codeSize;i++)\\n            result[i]=0;                        // For k=0, simply initalize all elements in code array with 0\\n    }\\n    \\n    // For k<0\\n    else{\\n        for (int i=0;i<codeSize;i++){\\n            for (int j=1;j<=abs(k);j++){\\n                n1=code[(i+codeSize-j)%codeSize];       // Logic for negative k\\'s is almost same as of above. DRY-RUN this line of code for better understanding\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;\\n            sum=0;\\n        }   \\n    }\\n    *returnSize=codeSize;\\n    return result;              // Return the resultant array\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    int* result=malloc(codeSize*sizeof(int));\\n    int n1,sum;\\n    if (k>0){\\n        for (int i=0;i<codeSize;i++){           // To cover all elements in code array\\n            for (int j=1;j<=k;j++){             // Cover elements till k\\n                n1=code[(i+j)%codeSize];        // As it is a circular array, modulo by size of code array will give the desired result.\\n                                                // I recommend to DRY-RUN this line for Example in description to understand the working.\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;                               // Initialize n1 and sum to zero for next iteration.\\n            sum=0;\\n        }\\n    }\\n    \\n    // For k=0\\n    else if(k==0){\\n        for (int i=0;i<codeSize;i++)\\n            result[i]=0;                        // For k=0, simply initalize all elements in code array with 0\\n    }\\n    \\n    // For k<0\\n    else{\\n        for (int i=0;i<codeSize;i++){\\n            for (int j=1;j<=abs(k);j++){\\n                n1=code[(i+codeSize-j)%codeSize];       // Logic for negative k\\'s is almost same as of above. DRY-RUN this line of code for better understanding\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;\\n            sum=0;\\n        }   \\n    }\\n    *returnSize=codeSize;\\n    return result;              // Return the resultant array\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256306,
                "title": "c-straightforward-modulo",
                "content": "![image](https://assets.leetcode.com/users/images/7d3784bc-ac6c-4d88-82be-bd82375afbbc_1657312778.1436577.png)\\n\\n**T->O(n * k) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> decrypt(vector<int>& code, int k) {\\n\\t\\t\\tint n=code.size();\\n\\t\\t\\tvector<int>ans(n,0);\\n\\t\\t\\tif(k==0)return ans;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tif(k>0){\\n\\t\\t\\t\\t\\tfor(int j=(i+1)%n;count<k;j=(j+1)%n){\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tfor(int j=i-1;count<abs(k);j--){\\n\\t\\t\\t\\t\\t\\tif(j==-1)j=n-1;\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> decrypt(vector<int>& code, int k) {\\n\\t\\t\\tint n=code.size();\\n\\t\\t\\tvector<int>ans(n,0);\\n\\t\\t\\tif(k==0)return ans;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tif(k>0){\\n\\t\\t\\t\\t\\tfor(int j=(i+1)%n;count<k;j=(j+1)%n){\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2179759,
                "title": "c-100-fast-0ms-easy-to-understand",
                "content": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n         \\n         if(k==0)\\n             return ans;\\n         \\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0;\\n            int sum=0;\\n            int count=k;\\n            if(k>0)\\n            {\\n                 j=i+1;\\n                while(count--)\\n                {\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)\\n                   j=n-1;\\n                else\\n                   j=i-1;\\n                \\n                while(count++)\\n                {\\n                    sum+=code[j];\\n                    if(j==0)\\n                        j=n-1;\\n                    else\\n                        j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n         \\n         if(k==0)\\n             return ans;\\n         \\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0;\\n            int sum=0;\\n            int count=k;\\n            if(k>0)\\n            {\\n                 j=i+1;\\n                while(count--)\\n                {\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)\\n                   j=n-1;\\n                else\\n                   j=i-1;\\n                \\n                while(count++)\\n                {\\n                    sum+=code[j];\\n                    if(j==0)\\n                        j=n-1;\\n                    else\\n                        j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1674760,
                "title": "java-1ms-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len=code.length;\\n        int arr[]=new int[len];\\n        if(k==0)\\n            return arr;\\n        if(k>0)\\n        for(int i=0;i<len;i++)\\n        {\\n            int sum=0;\\n            for(int j=1;j<=k;j++)\\n            {\\n                sum+=code[(j+i)%len];\\n            }\\n            arr[i]=sum;\\n        }\\n        if(k<0)\\n        {\\n            k=-1*k;\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=1;j<=k;j++)\\n                {\\n                    sum+=code[(len-j+i)%len];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len=code.length;\\n        int arr[]=new int[len];\\n        if(k==0)\\n            return arr;\\n        if(k>0)\\n        for(int i=0;i<len;i++)\\n        {\\n            int sum=0;\\n            for(int j=1;j<=k;j++)\\n            {\\n                sum+=code[(j+i)%len];\\n            }\\n            arr[i]=sum;\\n        }\\n        if(k<0)\\n        {\\n            k=-1*k;\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=1;j<=k;j++)\\n                {\\n                    sum+=code[(len-j+i)%len];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172514,
                "title": "python-beats-99-using-modulus",
                "content": "```\\n```\\nr=[]\\n        n=len(code)\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(n):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(n):\\n                e=i+k\\n                if e>0:\\n                    x=sum(code[e:i])\\n                else:\\n                    x=sum(code[:i])+sum(code[n+e:])\\n                r.append(x)\\n            return r\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114282,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        a = code.copy()\\n        res = []\\n        if k==0:\\n            return [0]*n\\n        elif k>0:\\n            a += code\\n            for i in range(n):\\n                res.append(sum(a[i+1:i+k+1]))\\n        else:\\n            a = code+a\\n            k =abs(k)\\n            for i in range(n,len(a)):\\n                res.append(sum(a[i-k:i]))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        a = code.copy()\\n        res = []\\n        if k==0:\\n            return [0]*n\\n        elif k>0:\\n            a += code\\n            for i in range(n):\\n                res.append(sum(a[i+1:i+k+1]))\\n        else:\\n            a = code+a\\n            k =abs(k)\\n            for i in range(n,len(a)):\\n                res.append(sum(a[i-k:i]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010869,
                "title": "java-sum",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] sum = new int[len+1];\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++)\\n            sum[i+1] = sum[i] + code[i];\\n        if(k>0){\\n            for(int i=0; i<len; i++){\\n                if(i+k<len)\\n                    res[i] = sum[i+k+1]-sum[i+1];\\n                else\\n                    res[i] += sum[len]-sum[i+1]+sum[k-len+i+1];\\n            }\\n        }else if(k<0){\\n            k=-k;\\n            for(int i=0; i<len; i++){\\n                if(i-k>=0)\\n                    res[i] = sum[i]-sum[i-k];\\n                else\\n                    res[i] += sum[i]+sum[len]-sum[len-k+i];\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] sum = new int[len+1];\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++)\\n            sum[i+1] = sum[i] + code[i];\\n        if(k>0){\\n            for(int i=0; i<len; i++){\\n                if(i+k<len)\\n                    res[i] = sum[i+k+1]-sum[i+1];\\n                else\\n                    res[i] += sum[len]-sum[i+1]+sum[k-len+i+1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 941890,
                "title": "simple-5-line-python-faster-than-100-with-comments",
                "content": "```\\n    def decrypt(self, num: List[int], k: int) -> List[int]:\\n        n, w = len(num), abs(k)\\n        sums = [sum(num[1:w+1])]*n                      # sums[i] is the sum of a window of size |k| after i\\n        for i in range(1,n):\\n            sums[i] = sums[i-1] + num[(i+w)%n] - num[i]\\n        return sums if k>=0 else sums[~w:]+sums[:~w]    # if k is negative all we need to do is shift the sums to the right by |k|\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def decrypt(self, num: List[int], k: int) -> List[int]:\\n        n, w = len(num), abs(k)\\n        sums = [sum(num[1:w+1])]*n                      # sums[i] is the sum of a window of size |k| after i\\n        for i in range(1,n):\\n            sums[i] = sums[i-1] + num[(i+w)%n] - num[i]\\n        return sums if k>=0 else sums[~w:]+sums[:~w]    # if k is negative all we need to do is shift the sums to the right by |k|\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 938895,
                "title": "javascript-sliding-window",
                "content": "```\\nconst decrypt = (code, k) => {\\n  \\n  const decode = (code, k) => {\\n    const result = [];\\n    let sum = 0;\\n    for(let i = 0; i < k; i++)\\n      sum += code[i];\\n    \\n    for(let i = 0 ; i < code.length; i++){\\n      sum -= code[i];\\n      sum += code[(i+k) % code.length];\\n      result.push(sum);\\n    }\\n    return result;\\n  }\\n  \\n  return k > 0 ? decode(code,k) : decode(code.reverse(), -k).reverse();\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst decrypt = (code, k) => {\\n  \\n  const decode = (code, k) => {\\n    const result = [];\\n    let sum = 0;\\n    for(let i = 0; i < k; i++)\\n      sum += code[i];\\n    \\n    for(let i = 0 ; i < code.length; i++){\\n      sum -= code[i];\\n      sum += code[(i+k) % code.length];\\n      result.push(sum);\\n    }\\n    return result;\\n  }\\n  \\n  return k > 0 ? decode(code,k) : decode(code.reverse(), -k).reverse();\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936310,
                "title": "c-presum-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int N = code.size();\\n        vector<int> Sum(code), ans(N);\\n        for(int i=1; i<N; ++i) Sum[i] = Sum[i-1] + code[i];\\n        for(int i=0; i<N; ++i) {\\n            int start = (i + N + (k < 0 ? k - 1 : 0)) % N;\\n            int end = (i + N + (k > 0 ? k : -1)) % N;\\n            if(!k) ans[i] = 0;\\n            else if(start < end) ans[i] = Sum[end] - Sum[start];\\n            else                 ans[i] = Sum[end] + (Sum[N-1] - Sum[start]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int N = code.size();\\n        vector<int> Sum(code), ans(N);\\n        for(int i=1; i<N; ++i) Sum[i] = Sum[i-1] + code[i];\\n        for(int i=0; i<N; ++i) {\\n            int start = (i + N + (k < 0 ? k - 1 : 0)) % N;\\n            int end = (i + N + (k > 0 ? k : -1)) % N;\\n            if(!k) ans[i] = 0;\\n            else if(start < end) ans[i] = Sum[end] - Sum[start];\\n            else                 ans[i] = Sum[end] + (Sum[N-1] - Sum[start]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935724,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        res = [0] * n\\n        if k > 0:\\n            res[0] = sum(code[1 : k + 1])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[(i + k) % n] - code[i]\\n        elif k < 0:\\n            res[0] = sum(code[n + k : n])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[i - 1] - code[(n + k + i - 1) % n]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        res = [0] * n\\n        if k > 0:\\n            res[0] = sum(code[1 : k + 1])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[(i + k) % n] - code[i]\\n        elif k < 0:\\n            res[0] = sum(code[n + k : n])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[i - 1] - code[(n + k + i - 1) % n]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935407,
                "title": "c-easy-solution-100-faster-100-less-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> decrypt(vector<int> &code, int k)\\n    {\\n        vector<int> res(code.size(), 0);\\n        int it; // count of k values while doing sum\\n        if (k == 0)\\n            return res;\\n        else\\n        {\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                it = 0;\\n                if (k > 0)\\n                {\\n                    for (int j = i + 1; it < k; j++)\\n                    {\\n                        if (j == code.size())\\n                            j = 0;\\n                        res[i] += code[j];\\n                        it++;\\n                    }\\n                }\\n                else if (k < 0)\\n                {\\n                    for (int j = i - 1; it > k; j--)\\n                    {\\n                        if (j < 0)\\n                            j = code.size() - 1;\\n                        res[i] += code[j];\\n                        it--;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> decrypt(vector<int> &code, int k)\\n    {\\n        vector<int> res(code.size(), 0);\\n        int it; // count of k values while doing sum\\n        if (k == 0)\\n            return res;\\n        else\\n        {\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                it = 0;\\n                if (k > 0)\\n                {\\n                    for (int j = i + 1; it < k; j++)\\n                    {\\n                        if (j == code.size())\\n                            j = 0;\\n                        res[i] += code[j];\\n                        it++;\\n                    }\\n                }\\n                else if (k < 0)\\n                {\\n                    for (int j = i - 1; it > k; j--)\\n                    {\\n                        if (j < 0)\\n                            j = code.size() - 1;\\n                        res[i] += code[j];\\n                        it--;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935382,
                "title": "py3-duplicate-the-array-to-simplify-things",
                "content": "```\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        if k == 0:\\n            return [0] * n\\n        arr = code + code\\n        res = [0] * n\\n        if k > 0:\\n            for i in range(n):\\n                res[i] = sum(arr[i+1:i+k+1])\\n        else:\\n            k = -k\\n            for i in range(n):\\n                res[i] = sum(arr[n+i-k:n+i])\\n        return res",
                "solutionTags": [],
                "code": "```\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        if k == 0:\\n            return [0] * n\\n        arr = code + code\\n        res = [0] * n\\n        if k > 0:\\n            for i in range(n):\\n                res[i] = sum(arr[i+1:i+k+1])\\n        else:\\n            k = -k\\n            for i in range(n):\\n                res[i] = sum(arr[n+i-k:n+i])\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3912887,
                "title": "simple-list-slicing-and-loop-process-that-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# **O**(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# **O**(n)\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k>0:\\n            final=code+code[:k]\\n            for i in range(len(code)):\\n                code[i]=sum(final[i+1:k+1+i])\\n            return code\\n        if k==0:\\n            new=[0]*len(code)\\n            return new\\n        else:\\n            final=code[k:]+code\\n            for i in range(len(code)):\\n                code[i]=sum(final[i:i-k])\\n            return code\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k>0:\\n            final=code+code[:k]\\n            for i in range(len(code)):\\n                code[i]=sum(final[i+1:k+1+i])\\n            return code\\n        if k==0:\\n            new=[0]*len(code)\\n            return new\\n        else:\\n            final=code[k:]+code\\n            for i in range(len(code)):\\n                code[i]=sum(final[i:i-k])\\n            return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674815,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n        if(k==0)\\n            return ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0, sum=0, count=k;\\n            if(k>0)\\n            {\\n                j=i+1;\\n                while(count--){\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)  j=n-1;\\n                else   j=i-1;\\n                while(count++){\\n                    sum+=code[j];\\n                    if(j==0)    j=n-1;\\n                    else     j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n        if(k==0)\\n            return ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0, sum=0, count=k;\\n            if(k>0)\\n            {\\n                j=i+1;\\n                while(count--){\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)  j=n-1;\\n                else   j=i-1;\\n                while(count++){\\n                    sum+=code[j];\\n                    if(j==0)    j=n-1;\\n                    else     j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636938,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res=[]\\n        if k>0:       \\n            first=sum(code[:k])\\n            for i in range(len(code)):\\n                first=first-code[i]+code[(k+i)%(len(code))]\\n                res.append(first)\\n        elif k<0:\\n            first=sum(code[k:])\\n            print(first)\\n            for i in range(len(code)):\\n                res.append(first)\\n                first=first+code[i]-code[(k+i)%(len(code))]\\n        else:\\n            res=[0]*len(code)\\n        return res\\n```\\n\\n***Please Upvote***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res=[]\\n        if k>0:       \\n            first=sum(code[:k])\\n            for i in range(len(code)):\\n                first=first-code[i]+code[(k+i)%(len(code))]\\n                res.append(first)\\n        elif k<0:\\n            first=sum(code[k:])\\n            print(first)\\n            for i in range(len(code)):\\n                res.append(first)\\n                first=first+code[i]-code[(k+i)%(len(code))]\\n        else:\\n            res=[0]*len(code)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436766,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ind = 0\\n        li = [0 for i in range(len(code))]\\n        if k>0:\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(k):\\n                    if ind+1 >= len(code):\\n                        sum += code[(ind+1)%len(code)]\\n                    else:\\n                        sum += code[ind+1]\\n                    ind += 1\\n                li[j] = sum\\n        elif k<0:\\n            r = -k\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(r):\\n                    if ind-1 <0:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                    else:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                li[j] = sum\\n        return li\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ind = 0\\n        li = [0 for i in range(len(code))]\\n        if k>0:\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(k):\\n                    if ind+1 >= len(code):\\n                        sum += code[(ind+1)%len(code)]\\n                    else:\\n                        sum += code[ind+1]\\n                    ind += 1\\n                li[j] = sum\\n        elif k<0:\\n            r = -k\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(r):\\n                    if ind-1 <0:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                    else:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                li[j] = sum\\n        return li\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106935,
                "title": "easy-js-solution-in-10-lines",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let decoded = Array(code.length).fill(0)\\n    if (k==0) return decoded\\n\\n    let direction = k < 0 ? 1 : -1\\n\\n    for (let i = 0; i < code.length; i++)\\n        for (j=k; j != 0; j += direction){\\n            let idx = (i + j) % code.length // if our index is too high, lower it\\n            idx < 0 ? idx += code.length : idx // too low? increase it\\n            decoded[i] += code[idx]\\n        }\\n    return decoded\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let decoded = Array(code.length).fill(0)\\n    if (k==0) return decoded\\n\\n    let direction = k < 0 ? 1 : -1\\n\\n    for (let i = 0; i < code.length; i++)\\n        for (j=k; j != 0; j += direction){\\n            let idx = (i + j) % code.length // if our index is too high, lower it\\n            idx < 0 ? idx += code.length : idx // too low? increase it\\n            decoded[i] += code[idx]\\n        }\\n    return decoded\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2957477,
                "title": "runtime-55-ms-beats-100-memory-41-9-mb-beats-97-92",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nvar decrypt = function (code, k) {\\n    if (k === 0) return new Array(code.length).fill(0);\\n    var arr = code.concat(code, code, code);\\n    // console.log(arr)\\n    let res = [];\\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        let x = i + 1;\\n        let y = (code.length - 1) + i;\\n        if (k > 0) {\\n            for (let j = 0; j < k; j++) {\\n                sum += arr[x];\\n                x++;\\n            }\\n            res.push(sum);\\n        } else if (k < 0) {\\n            for (let j = 0; j < -k; j++) {\\n                sum += arr[y];\\n                y--;\\n            }\\n            res.push(sum);\\n        }\\n    }\\n    return res;\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/1fc69f57-672f-4bff-92c0-aa12825dcdb4_1672132892.8528547.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decrypt = function (code, k) {\\n    if (k === 0) return new Array(code.length).fill(0);\\n    var arr = code.concat(code, code, code);\\n    // console.log(arr)\\n    let res = [];\\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        let x = i + 1;\\n        let y = (code.length - 1) + i;\\n        if (k > 0) {\\n            for (let j = 0; j < k; j++) {\\n                sum += arr[x];\\n                x++;\\n            }\\n            res.push(sum);\\n        } else if (k < 0) {\\n            for (let j = 0; j < -k; j++) {\\n                sum += arr[y];\\n                y--;\\n            }\\n            res.push(sum);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2551093,
                "title": "java-brute-force-easy-to-understand",
                "content": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] ans=new int[code.length];\\n       if(k==0){\\n           for(int i=0;i<code.length;i++){\\n               code[i]=0;\\n               \\n           }\\n           return code;\\n       }\\n        else if(k>0){\\n            \\n            for(int i=0;i<code.length;i++){\\n                int sum=0;\\n                int count=0;\\n                int u=i+1;\\n                if(i==code.length-1){\\n                    u=0;\\n                }\\n                for(int j=u;j<code.length;j++){\\n                    \\n                    sum+=code[j];\\n                    count++;\\n                    if(j==code.length-1){\\n                        j=-1;                       \\n                    }\\n                    if(count==k){\\n                        break;\\n                    }\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                int sum=0;\\n                int count=0;\\n                int u=i-1;\\n                if(i==0){\\n                    u=code.length-1;\\n                }\\n                for(int j=u;j>=0;j--){\\n                    sum+=code[j];\\n                    count++;\\n                    if(count==Math.abs(k)){\\n                        break;\\n                    }\\n                    if(j==0){\\n                        j=code.length;\\n                    }\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n        \\n       \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] ans=new int[code.length];\\n       if(k==0){\\n           for(int i=0;i<code.length;i++){\\n               code[i]=0;\\n               \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2431302,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int n = code.size();\\n        \\n        vector<int> res(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sum = 0;\\n            \\n            if (k > 0)\\n                for(int j=1; j<=k; j++)\\n                    sum += code[(i + j) % n]; \\n            else if (k < 0)\\n                for(int j=1; j<=-k; j++)\\n                    sum += code[(i - j + n)%n];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int n = code.size();\\n        \\n        vector<int> res(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sum = 0;\\n            \\n            if (k > 0)\\n                for(int j=1; j<=k; j++)\\n                    sum += code[(i + j) % n]; \\n            else if (k < 0)\\n                for(int j=1; j<=-k; j++)\\n                    sum += code[(i - j + n)%n];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323353,
                "title": "c-solution-with-12ms-runtime",
                "content": "Stats for this solution:\\nRuntime: 12 ms, faster than 5.85% of C++ online submissions for Defuse the Bomb.\\nMemory Usage: 8.2 MB, less than 73.28% of C++ online submissions for Defuse the Bomb.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);\\n        if(k == 0) return res;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(k > 0) {\\n                for(int j = (i + 1) % n; count < k; j = (j + 1) % n) {\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            } else {\\n                for(int j = i - 1; count < abs(k); j--) {\\n                    if(j == -1) j = n - 1;\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);\\n        if(k == 0) return res;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(k > 0) {\\n                for(int j = (i + 1) % n; count < k; j = (j + 1) % n) {\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            } else {\\n                for(int j = i - 1; count < abs(k); j--) {\\n                    if(j == -1) j = n - 1;\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306730,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        length = len(code) \\n        code = code + code \\n        ans = [] \\n        \\n        if k > 0 :\\n            for i in range(length) :\\n                tmp = code[i+1:i+k+1]\\n                ans.append(sum(tmp))\\n        elif k < 0 : \\n            for i in range(length,len(code)):\\n                tmp = code[k+i:i]\\n                ans.append(sum(tmp))     \\n        else:\\n            return [0] * length \\n            \\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        length = len(code) \\n        code = code + code \\n        ans = [] \\n        \\n        if k > 0 :\\n            for i in range(length) :\\n                tmp = code[i+1:i+k+1]\\n                ans.append(sum(tmp))\\n        elif k < 0 : \\n            for i in range(length,len(code)):\\n                tmp = code[k+i:i]\\n                ans.append(sum(tmp))     \\n        else:\\n            return [0] * length \\n            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2051862,
                "title": "c-logic-two-loops-o-n2",
                "content": "Hi there , this is the simple logic that came into my mind at first, with O(n2) complexity\\nwould update a new thread if there comes another logic with better one.\\n\\nCODE- \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n= code.size();\\n         vector<int>res(n,0);\\n        if(k==0)\\n            return res;\\n        else if(k>0)\\n        {\\n            for(int ptr=0; ptr<n; ptr++)\\n            { \\n               int j=k;\\n                int i= ptr+1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i>n-1)\\n                       i%=n;\\n                   sum+=code[i];\\n                    i++;\\n               }\\n                res[ptr]=sum;\\n           }\\n        }\\n        else\\n        {\\n           for(int ptr=n-1; ptr>=0; ptr--)\\n           { \\n               int j=abs(k);\\n               int i=ptr-1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i<0)\\n                       i= n-abs(i);\\n                   sum+= code[i];\\n                   i--;\\n               }\\n               res[ptr]=sum;\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThanks for coming this far!  we can do thiss ! happy coding",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n= code.size();\\n         vector<int>res(n,0);\\n        if(k==0)\\n            return res;\\n        else if(k>0)\\n        {\\n            for(int ptr=0; ptr<n; ptr++)\\n            { \\n               int j=k;\\n                int i= ptr+1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i>n-1)\\n                       i%=n;\\n                   sum+=code[i];\\n                    i++;\\n               }\\n                res[ptr]=sum;\\n           }\\n        }\\n        else\\n        {\\n           for(int ptr=n-1; ptr>=0; ptr--)\\n           { \\n               int j=abs(k);\\n               int i=ptr-1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i<0)\\n                       i= n-abs(i);\\n                   sum+= code[i];\\n                   i--;\\n               }\\n               res[ptr]=sum;\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033540,
                "title": "straight-forward-prefix-sum-solution",
                "content": "using a map to keep track of all prefix sum from 0 -> 2 * n - 1, since its a circular array.\\ntime: o(n), space: o(n)\\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint n = code.length;\\n\\tint[] res = new int[n];\\n\\tif (k == 0) {\\n\\t\\treturn res;\\n\\t}\\n\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint[] temp = new int[n * 2];\\n\\n\\tfor (int i = 0; i < n * 2 ; i++) {\\n\\t\\ttemp[i] = code[i % n];\\n\\t}\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\tsum += temp[i];\\n\\t\\tmap.put(i, sum);\\n\\t}\\n\\n\\tint[] res = new int[code.length];\\n\\tif (k > 0) {\\n\\t\\tfor (int i = 0; i < code.length; i++) {\\n\\t\\t\\tres[i] = map.get(i + k) - map.get(i);\\n\\t\\t}\\n\\t} else if (k < 0) {\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = n; i < temp.length; i++) {\\n\\t\\t\\tres[index++] = map.get(i - 1) - map.get(i + k - 1);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint n = code.length;\\n\\tint[] res = new int[n];\\n\\tif (k == 0) {\\n\\t\\treturn res;\\n\\t}\\n\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint[] temp = new int[n * 2];\\n\\n\\tfor (int i = 0; i < n * 2 ; i++) {\\n\\t\\ttemp[i] = code[i % n];\\n\\t}\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\tsum += temp[i];\\n\\t\\tmap.put(i, sum);\\n\\t}\\n\\n\\tint[] res = new int[code.length];\\n\\tif (k > 0) {\\n\\t\\tfor (int i = 0; i < code.length; i++) {\\n\\t\\t\\tres[i] = map.get(i + k) - map.get(i);\\n\\t\\t}\\n\\t} else if (k < 0) {\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = n; i < temp.length; i++) {\\n\\t\\t\\tres[index++] = map.get(i - 1) - map.get(i + k - 1);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1992107,
                "title": "c-solution-t-o-nk-s-1",
                "content": "### C++ Solution:\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int mod_k = abs(k);\\n        \\n        vector<int> decrypted_code(code.size());\\n        \\n        if (k == 0)\\n            return decrypted_code;\\n        else if (k < 0)\\n        {\\n            // circular right\\n            // formula: right = (start - distance + n) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i - j + code.size()) % code.size()]; \\n            }\\n        }\\n        else\\n        {\\n            // circular left\\n            // formula: left = (start + distance) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i + j) % code.size()]; \\n            }\\n        }\\n        \\n        return decrypted_code;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int mod_k = abs(k);\\n        \\n        vector<int> decrypted_code(code.size());\\n        \\n        if (k == 0)\\n            return decrypted_code;\\n        else if (k < 0)\\n        {\\n            // circular right\\n            // formula: right = (start - distance + n) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i - j + code.size()) % code.size()]; \\n            }\\n        }\\n        else\\n        {\\n            // circular left\\n            // formula: left = (start + distance) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i + j) % code.size()]; \\n            }\\n        }\\n        \\n        return decrypted_code;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985487,
                "title": "short-and-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int l = code.size(), s;\\n        vector<int> v(l);\\n        for(int i=0; i<l; ++i){\\n            s = 0;\\n            if(k>0){\\n                for(int j=0; j<k; ++j){\\n                    if(i+1+j <l)\\n                        s += code[i+1+j];\\n                    else \\n                        s += code[(i+1+j) % l];\\n                }\\n            }\\n            else{\\n                for(int j=0; j<fabs(k); ++j){\\n                    if(i-1-j >=0)\\n                        s += code[i-1-j];\\n                    else \\n                        s += code[l-1+i-j];\\n                } \\n            }\\n            v[i] = s;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int l = code.size(), s;\\n        vector<int> v(l);\\n        for(int i=0; i<l; ++i){\\n            s = 0;\\n            if(k>0){\\n                for(int j=0; j<k; ++j){\\n                    if(i+1+j <l)\\n                        s += code[i+1+j];\\n                    else \\n                        s += code[(i+1+j) % l];\\n                }\\n            }\\n            else{\\n                for(int j=0; j<fabs(k); ++j){\\n                    if(i-1-j >=0)\\n                        s += code[i-1-j];\\n                    else \\n                        s += code[l-1+i-j];\\n                } \\n            }\\n            v[i] = s;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967947,
                "title": "simple-javascript-solution-faster-than-70",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nvar decrypt = (code, k) => {\\n    \\n    let result = [];\\n    \\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        \\n        if (k > 0) {\\n            for (let x = 1; x <= k; x++) {\\n                sum += code[(i+x) % code.length];\\n            }\\n        }\\n        \\n        if (k < 0) {\\n             for (let x = -1; x >= k; x--) {\\n                sum += code[(i + x + code.length) % code.length];\\n            }\\n        }\\n        \\n        result.push(sum);\\n    } \\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nvar decrypt = (code, k) => {\\n    \\n    let result = [];\\n    \\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        \\n        if (k > 0) {\\n            for (let x = 1; x <= k; x++) {\\n                sum += code[(i+x) % code.length];\\n            }\\n        }\\n        \\n        if (k < 0) {\\n             for (let x = -1; x >= k; x--) {\\n                sum += code[(i + x + code.length) % code.length];\\n            }\\n        }\\n        \\n        result.push(sum);\\n    } \\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862972,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        s=code*2\\n        for i in range(len(code)):\\n            if k==0:\\n                code[i]=0\\n            elif k>0:\\n                code[i]=sum(s[i+1:i+k+1])\\n            elif k<0:\\n                code[i] = sum(s[len(code) + i + k : len(code) + i])\\n        return code\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        s=code*2\\n        for i in range(len(code)):\\n            if k==0:\\n                code[i]=0\\n            elif k>0:\\n                code[i]=sum(s[i+1:i+k+1])\\n            elif k<0:\\n                code[i] = sum(s[len(code) + i + k : len(code) + i])\\n        return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830648,
                "title": "python-solution-using-extra-memory",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        # Handle the case where k is 0\\n        if k == 0:\\n            for i in range(len(code)):\\n                code[i] = 0\\n        \\n        # Handle the case where k > 0\\n        elif k > 0:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[i + 1:i+ k + 1])\\n        \\n        # Handle the case where k < 0\\n        else:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[len(code) + i + k : len(code) + i])\\n            \\n        return code        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        # Handle the case where k is 0\\n        if k == 0:\\n            for i in range(len(code)):\\n                code[i] = 0\\n        \\n        # Handle the case where k > 0\\n        elif k > 0:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[i + 1:i+ k + 1])\\n        \\n        # Handle the case where k < 0\\n        else:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[len(code) + i + k : len(code) + i])\\n            \\n        return code        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818728,
                "title": "python-single-pass-no-reverse-no-if-s",
                "content": "```\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        s = sum(code[i+1] for i in range(abs(k)))\\n        res = [0]*len(code)\\n        for i in range(len(code)):\\n            res[(i+(1-k)*(k<0))%len(code)] = s\\n            s -= code[(i+1)%len(code)]\\n            s += code[(i+1+abs(k))%len(code)]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        s = sum(code[i+1] for i in range(abs(k)))\\n        res = [0]*len(code)\\n        for i in range(len(code)):\\n            res[(i+(1-k)*(k<0))%len(code)] = s\\n            s -= code[(i+1)%len(code)]\\n            s += code[(i+1+abs(k))%len(code)]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1715964,
                "title": "easy-3-liner-python",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0 : return self.decrypt(code[::-1], -k)[::-1]\\n        code = code * 2\\n        return [sum(code[i+1:i+k+1]) for i in range(len(code)//2)]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0 : return self.decrypt(code[::-1], -k)[::-1]\\n        code = code * 2\\n        return [sum(code[i+1:i+k+1]) for i in range(len(code)//2)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640047,
                "title": "c-o-n-time-space-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        \\n        if(k==0)\\n        {\\n            return vector<int>(n);\\n        }\\n        \\n        int sum=0;\\n        int i=0;\\n        \\n        if(k>0)\\n        {\\n            vector<int> next_sum(n);\\n            \\n            for(i=0;i<k;i++)\\n            {\\n                sum+=code[i];\\n            }\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                sum=sum-code[j]+code[i];\\n                next_sum[j]= sum;\\n                i=(i+1) % n;\\n            }\\n            \\n            return next_sum;\\n            \\n        }\\n        \\n         // if k<0\\n        \\n        k=abs(k);\\n        \\n        vector<int> pre_sum(n);\\n        sum=0;\\n        i=n-1;\\n        \\n        for(i=n-1;i>n-1-k;i--)\\n        {\\n            sum+=code[i];\\n        }\\n        \\n        for(int j=n-1;j>=0;j--)\\n        {\\n            sum=sum-code[j]+code[i];\\n            pre_sum[j]=sum;\\n            i=i-1;\\n            if(i<0) { i=n-1; }\\n        }\\n        \\n        return pre_sum;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        \\n        if(k==0)\\n        {\\n            return vector<int>(n);\\n        }\\n        \\n        int sum=0;\\n        int i=0;\\n        \\n        if(k>0)\\n        {\\n            vector<int> next_sum(n);\\n            \\n            for(i=0;i<k;i++)\\n            {\\n                sum+=code[i];\\n            }\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                sum=sum-code[j]+code[i];\\n                next_sum[j]= sum;\\n                i=(i+1) % n;\\n            }\\n            \\n            return next_sum;\\n            \\n        }\\n        \\n         // if k<0\\n        \\n        k=abs(k);\\n        \\n        vector<int> pre_sum(n);\\n        sum=0;\\n        i=n-1;\\n        \\n        for(i=n-1;i>n-1-k;i--)\\n        {\\n            sum+=code[i];\\n        }\\n        \\n        for(int j=n-1;j>=0;j--)\\n        {\\n            sum=sum-code[j]+code[i];\\n            pre_sum[j]=sum;\\n            i=i-1;\\n            if(i<0) { i=n-1; }\\n        }\\n        \\n        return pre_sum;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623992,
                "title": "c-easy-to-understand-brute-force",
                "content": "**Brute force approach\\ntime complexity O(nxk)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int n=code.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=1,sum=0;\\n            int m=i;\\n            if(k<0)\\n            {\\n            m+=n;\\n            int j=-1;\\n            while(j>=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j--;\\n            }\\n            }\\n            else\\n            {\\n            while(j<=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j++;\\n            }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int n=code.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=1,sum=0;\\n            int m=i;\\n            if(k<0)\\n            {\\n            m+=n;\\n            int j=-1;\\n            while(j>=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j--;\\n            }\\n            }\\n            else\\n            {\\n            while(j<=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j++;\\n            }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603868,
                "title": "rust-fast-100",
                "content": "```\\n\\nstruct Solution{}\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if k == 0{\\n             return vec![0;code.len()];\\n        }else if k > 0{\\n            let mut v = vec![&code];\\n            for _ in 0..=(k/code.len() as i32){\\n                v.push(&code);\\n            }\\n            let chain = v.into_iter().flatten().collect::<Vec<&i32>>();\\n            let mut ans = vec![];\\n            for i in 0..code.len(){\\n                let mut x = 0;\\n                let mut count = 0;\\n                for j in (i+1)..chain.len(){\\n                    if count >= k{\\n                        break;\\n                    }\\n                    x += chain[j];\\n                    count +=1;\\n                }\\n                ans.push(x);                \\n            }\\n            ans\\n\\n        }else{\\n            let mut ans = vec![];          \\n            let vec = code.iter().cycle().take(((code.len() as i32 * code.len() as i32) - code.len() as i32) as usize).collect::<Vec<&i32>>();\\n            let v = vec.into_iter().rev().collect::<Vec<&i32>>();\\n            println!(\"{:?}\",v);\\n            let mut i= 0;\\n            while  i < v.len(){\\n                let mut m = 0;\\n                for j in 0..i32::abs(k){\\n                      m += v[i + j as usize];\\n                      print!(\"{} \",v[i+j as usize]);\\n                }\\n                println!();\\n                \\n                ans.push(m);\\n                i += code.len() - 1;       \\n            }\\n            ans\\n        }   \\n    }\\n}\\nfn main(){\\n    println!(\"{:?}\",Solution::decrypt(vec![2,4,9,3],-2));  \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn basic(){\\n        assert_eq!(Solution::decrypt(vec![5,7,1,4],3),vec![12,10,16,13]);\\n        assert_eq!(Solution::decrypt(vec![1,2,3,4],0),vec![0,0,0,0]);\\n        assert_eq!(Solution::decrypt(vec![2,4,9,3],-2),vec![12,5,6,13]);\\n        assert_eq!(Solution::decrypt(vec![10,5,7,7,3,2,10,3,6,9,1,6],-4),vec![22,26,22,28,29,22,19,22,18,21,28,19]); \\n    }    \\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\\nstruct Solution{}\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if k == 0{\\n             return vec![0;code.len()];\\n        }else if k > 0{\\n            let mut v = vec![&code];\\n            for _ in 0..=(k/code.len() as i32){\\n                v.push(&code);\\n            }\\n            let chain = v.into_iter().flatten().collect::<Vec<&i32>>();\\n            let mut ans = vec![];\\n            for i in 0..code.len(){\\n                let mut x = 0;\\n                let mut count = 0;\\n                for j in (i+1)..chain.len(){\\n                    if count >= k{\\n                        break;\\n                    }\\n                    x += chain[j];\\n                    count +=1;\\n                }\\n                ans.push(x);                \\n            }\\n            ans\\n\\n        }else{\\n            let mut ans = vec![];          \\n            let vec = code.iter().cycle().take(((code.len() as i32 * code.len() as i32) - code.len() as i32) as usize).collect::<Vec<&i32>>();\\n            let v = vec.into_iter().rev().collect::<Vec<&i32>>();\\n            println!(\"{:?}\",v);\\n            let mut i= 0;\\n            while  i < v.len(){\\n                let mut m = 0;\\n                for j in 0..i32::abs(k){\\n                      m += v[i + j as usize];\\n                      print!(\"{} \",v[i+j as usize]);\\n                }\\n                println!();\\n                \\n                ans.push(m);\\n                i += code.len() - 1;       \\n            }\\n            ans\\n        }   \\n    }\\n}\\nfn main(){\\n    println!(\"{:?}\",Solution::decrypt(vec![2,4,9,3],-2));  \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn basic(){\\n        assert_eq!(Solution::decrypt(vec![5,7,1,4],3),vec![12,10,16,13]);\\n        assert_eq!(Solution::decrypt(vec![1,2,3,4],0),vec![0,0,0,0]);\\n        assert_eq!(Solution::decrypt(vec![2,4,9,3],-2),vec![12,5,6,13]);\\n        assert_eq!(Solution::decrypt(vec![10,5,7,7,3,2,10,3,6,9,1,6],-4),vec![22,26,22,28,29,22,19,22,18,21,28,19]); \\n    }    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514918,
                "title": "c-0ms-o-n-k-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i+1); j <=(i+k); j++)\\n                    ans[i] += code[j%n];\\n            }\\n            \\n        }\\n        \\n        else if(k < 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i-1)%n; j >=(i-abs(k))%n; j--)\\n                {\\n                    if(j < 0)\\n                        ans[i] += code[n+j];\\n                    \\n                    else ans[i] += code[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i+1); j <=(i+k); j++)\\n                    ans[i] += code[j%n];\\n            }\\n            \\n        }\\n        \\n        else if(k < 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i-1)%n; j >=(i-abs(k))%n; j--)\\n                {\\n                    if(j < 0)\\n                        ans[i] += code[n+j];\\n                    \\n                    else ans[i] += code[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450462,
                "title": "easy-solution",
                "content": "just go with the flow \\ntwo things \\nto travel in counter clockwise direction:  **(n+j-1)%n**\\nto travel in clockwise direction:  **(n+i)%n**\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& nums, int k) \\n    {\\n    int n=nums.size();\\n    vector<int>ans(n,0);\\n    if(k==0)return ans;\\n    for(int i=0;i<n;i++)\\n    {\\n        int sum=0,j=k>0?(i+1)%n:(n+i-1)%n,count=0;\\n        if(k>0)while(count<k)sum+=nums[j],j=(j+1)%n,count++;\\n        if(k<0)while(count<abs(k))sum+=nums[j],j=(n+j-1)%n,count++;\\n        ans[i]=sum;\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& nums, int k) \\n    {\\n    int n=nums.size();\\n    vector<int>ans(n,0);\\n    if(k==0)return ans;\\n    for(int i=0;i<n;i++)\\n    {\\n        int sum=0,j=k>0?(i+1)%n:(n+i-1)%n,count=0;\\n        if(k>0)while(count<k)sum+=nums[j],j=(j+1)%n,count++;\\n        if(k<0)while(count<abs(k))sum+=nums[j],j=(n+j-1)%n,count++;\\n        ans[i]=sum;\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333655,
                "title": "python-solution",
                "content": "class Solution:\\n    \\n\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0]*len(code)    \\n        temp = code\\n        code = code*2\\n        for i in range(0,len(temp)):\\n            if k > 0:\\n                temp[i] = sum(code[i+1:k+i+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        \\n        return temp",
                "solutionTags": [],
                "code": "class Solution:\\n    \\n\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0]*len(code)    \\n        temp = code\\n        code = code*2\\n        for i in range(0,len(temp)):\\n            if k > 0:\\n                temp[i] = sum(code[i+1:k+i+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        \\n        return temp",
                "codeTag": "Java"
            },
            {
                "id": 1235556,
                "title": "python-two-lines-brute-force",
                "content": "Find the correct range based on the value of k, then sum the next/previous k values for each index using list comprehension.\\n\\n```python\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        n, range_ = len(code), range(1,k+1) if k > 0 else range(k, 0)\\n        return [sum([code[(i+j)%n] for j in range_]) for i in range(n)] if k else [0]*n\\n```",
                "solutionTags": [],
                "code": "```python\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        n, range_ = len(code), range(1,k+1) if k > 0 else range(k, 0)\\n        return [sum([code[(i+j)%n] for j in range_]) for i in range(n)] if k else [0]*n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1218451,
                "title": "100-python-array-concatenation-prefix-sum",
                "content": "```\\nimport math\\nclass Solution:\\n    def routine(self, code, k):\\n        append_times = int(math.ceil(abs(k) / len(code)))\\n        original_length = len(code)\\n        \\n        for i in range(1, append_times + 1):\\n            code += code\\n        \\n        prefixSum = [0]\\n        for num in code:\\n            prefixSum.append(prefixSum[-1] + num)\\n        \\n        if k > 0:\\n            for i in range(original_length):\\n                code[i] = prefixSum[i + k + 1] - prefixSum[i + 1]\\n        else:\\n            for i in range(original_length * append_times, len(code)):\\n                #    [0, 1, 0, 1]\\n                # [0, 0, 1, 1, 2]\\n                code[i] = prefixSum[i] - prefixSum[i + k]\\n        return code[: original_length] if k > 0 else code[-original_length:]\\n    \\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if not k:\\n            return [0] * len(code)\\n        return self.routine(code, k)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def routine(self, code, k):\\n        append_times = int(math.ceil(abs(k) / len(code)))\\n        original_length = len(code)\\n        \\n        for i in range(1, append_times + 1):\\n            code += code\\n        \\n        prefixSum = [0]\\n        for num in code:\\n            prefixSum.append(prefixSum[-1] + num)\\n        \\n        if k > 0:\\n            for i in range(original_length):\\n                code[i] = prefixSum[i + k + 1] - prefixSum[i + 1]\\n        else:\\n            for i in range(original_length * append_times, len(code)):\\n                #    [0, 1, 0, 1]\\n                # [0, 0, 1, 1, 2]\\n                code[i] = prefixSum[i] - prefixSum[i + k]\\n        return code[: original_length] if k > 0 else code[-original_length:]\\n    \\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if not k:\\n            return [0] * len(code)\\n        return self.routine(code, k)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218059,
                "title": "javascript-solution",
                "content": "```\\nvar decrypt = function(code, k) {\\n    const n = code.length;\\n    \\n    if (k === 0) return new Array(n).fill(0);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    if (k > 0) {\\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            sum += code[(i + k) % n];\\n            sum -= code[i];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    if (k < 0) {\\n        k = -k;\\n        \\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            res[(i + k) % n] = sum;\\n            \\n            sum -= code[i];\\n            sum += code[(i + k) % n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decrypt = function(code, k) {\\n    const n = code.length;\\n    \\n    if (k === 0) return new Array(n).fill(0);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    if (k > 0) {\\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            sum += code[(i + k) % n];\\n            sum -= code[i];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    if (k < 0) {\\n        k = -k;\\n        \\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            res[(i + k) % n] = sum;\\n            \\n            sum -= code[i];\\n            sum += code[(i + k) % n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207790,
                "title": "python-94",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        lc = len(code)\\n        res = [0]*lc\\n        code += code\\n        if k == 0:\\n            return res\\n\\t\\t# if k < 0 just swap the code around and swap the result back at the end\\n        if k < 0:\\n            code = code[::-1]\\n        for i in range(lc):\\n            res[i] = sum(code[i+1:i+1+abs(k)])\\n        return res[::-1] if k < 0 else res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        lc = len(code)\\n        res = [0]*lc\\n        code += code\\n        if k == 0:\\n            return res\\n\\t\\t# if k < 0 just swap the code around and swap the result back at the end\\n        if k < 0:\\n            code = code[::-1]\\n        for i in range(lc):\\n            res[i] = sum(code[i+1:i+1+abs(k)])\\n        return res[::-1] if k < 0 else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175703,
                "title": "100-efficient-solution-c",
                "content": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int s=0,c=0,t;\\n        ans = code;\\n        code.insert(code.end(),ans.begin(),ans.end());\\n        ans.clear();\\n        if(k > 0){\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(k==code.size()){\\n                    break;\\n                }\\n                for(int j=c;j<=k;j++){\\n                    s=s+code[j];\\n                    c++;\\n                }\\n\\n                ans.push_back(s);\\n                k++;\\n            }\\n            ans.erase(ans.begin()+(code.size()/2),ans.end());\\n        }\\n        else if(k < 0){\\n            t=abs(k);\\n            reverse(code.begin(),code.end());\\n            cout<<code.size();\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(t==code.size()){\\n                    break;\\n                }\\n                for(int j=c;j<=t;j++){\\n                    s=s+code[j];\\n                    c++;\\n                }\\n                ans.push_back(s);\\n                t++;\\n            }\\n            ans.erase(ans.begin()+(code.size()/2),ans.end());\\n            reverse(ans.begin(),ans.end());\\n        }\\n        else if(k==0){\\n             for(int i=1;i<=code.size()/2;i++){\\n                 ans.push_back(0);\\n             }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int s=0,c=0,t;\\n        ans = code;\\n        code.insert(code.end(),ans.begin(),ans.end());\\n        ans.clear();\\n        if(k > 0){\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(k==code.size()){\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1173463,
                "title": "rust-simple-solution",
                "content": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        let l  = code.len();\\n\\n        if k == 0 {\\n            return vec![0; l];\\n        };\\n\\n        let mut res = Vec::with_capacity(l);\\n        let mut start = match k.signum() {\\n            -1 => l as i32 + k,\\n            s => s,\\n        } as usize;\\n        let steps = k.abs() as usize;\\n\\n        for _ in 0..l {\\n            let mut s = 0;\\n            (start..start + steps).for_each(|j| s += code[j % l]);\\n            res.push(s);\\n            start += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        let l  = code.len();\\n\\n        if k == 0 {\\n            return vec![0; l];\\n        };\\n\\n        let mut res = Vec::with_capacity(l);\\n        let mut start = match k.signum() {\\n            -1 => l as i32 + k,\\n            s => s,\\n        } as usize;\\n        let steps = k.abs() as usize;\\n\\n        for _ in 0..l {\\n            let mut s = 0;\\n            (start..start + steps).for_each(|j| s += code[j % l]);\\n            res.push(s);\\n            start += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1172511,
                "title": "using-modulus",
                "content": "```\\nr=[]\\n        n=len(code)\\n        x=0\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(len(code)):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(len(code)):\\n                e=(i%n)\\n                s=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            q=r[len(r)-1]\\n            r=r[:len(r)-1]\\n            r.insert(0,q)\\n            return r\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nr=[]\\n        n=len(code)\\n        x=0\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(len(code)):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(len(code)):\\n                e=(i%n)\\n                s=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            q=r[len(r)-1]\\n            r=r[:len(r)-1]\\n            r.insert(0,q)\\n            return r\\n            \\n            \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114740,
                "title": "c-stupidly-concise",
                "content": "Sliding window. \\n\\n`i` is left, `j` is right, `n` is the sum of the current window. Keep moving `j` to the right, adding in whatever value we hit to our sum. \\n\\nIf the total window size hits the limit, pull up the left hand side of the window and drop the value at that index from our sum. Then set this sum into the correct index - just before the start of the window if `k` is positive, and just after the end of the window if `k` is negative.\\n```\\nvector<int> decrypt(vector<int>& code, int k) {\\n\\tvector<int> v(code.size());\\n\\tfor (int i = 0, j = 0, n = 0; i < code.size() && k; ++j) {\\n\\t\\tn += code[j % code.size()];\\n\\t\\tif (j - i == abs(k)) v[k > 0 ? i - 1 : (j + 1) % code.size()] = n -= code[i++];\\n\\t}\\n\\treturn v;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n\\tvector<int> v(code.size());\\n\\tfor (int i = 0, j = 0, n = 0; i < code.size() && k; ++j) {\\n\\t\\tn += code[j % code.size()];\\n\\t\\tif (j - i == abs(k)) v[k > 0 ? i - 1 : (j + 1) % code.size()] = n -= code[i++];\\n\\t}\\n\\treturn v;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1094993,
                "title": "python-solution-array-prefix-sum",
                "content": "Array Prefix sum approach.\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n_l=[]\\n        res=[]\\n        nn=1\\n        ctr=0\\n        if k<0:\\n            nn=0\\n        n=len(code)\\n        if k==0:\\n            return [0]*len(code)\\n        if not nn:\\n            k=k*-1\\n            code=code[::-1]\\n        for i in code:\\n            ctr+=i\\n            n_l.append(ctr)\\n        for i in range(n):\\n            if (i+k)<n:\\n                res.append(n_l[i+k]-n_l[i])\\n            else:\\n                res.append(n_l[n-1]-n_l[i]+n_l[(i+k)%n])\\n        if nn:\\n            return res\\n        else:\\n            return res[::-1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n_l=[]\\n        res=[]\\n        nn=1\\n        ctr=0\\n        if k<0:\\n            nn=0\\n        n=len(code)\\n        if k==0:\\n            return [0]*len(code)\\n        if not nn:\\n            k=k*-1\\n            code=code[::-1]\\n        for i in code:\\n            ctr+=i\\n            n_l.append(ctr)\\n        for i in range(n):\\n            if (i+k)<n:\\n                res.append(n_l[i+k]-n_l[i])\\n            else:\\n                res.append(n_l[n-1]-n_l[i]+n_l[(i+k)%n])\\n        if nn:\\n            return res\\n        else:\\n            return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080903,
                "title": "c-concise-solution-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ret;\\n        for (int i = 0; i < code.size(); i++) {\\n            int sum = 0;\\n            int direction = k > 0 ? 1 : -1;\\n\\t\\t\\tint j = i + direction;\\n            while (j != i + k + direction) {\\n                sum += code.at((j + code.size()) % code.size());\\n                j = j + direction;\\n            }\\n            ret.push_back(sum);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ret;\\n        for (int i = 0; i < code.size(); i++) {\\n            int sum = 0;\\n            int direction = k > 0 ? 1 : -1;\\n\\t\\t\\tint j = i + direction;\\n            while (j != i + k + direction) {\\n                sum += code.at((j + code.size()) % code.size());\\n                j = j + direction;\\n            }\\n            ret.push_back(sum);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069062,
                "title": "java-100",
                "content": "1. Calculation and its sequence are same for both directions.\\n2. If k is negative, rotate the result and return\\n```\\n    public int[] decrypt(int[] code, int k) {\\n        int[] cycle = new int[code.length];  \\n        if(k == 0) return cycle;\\n        \\n        int sum = 0;\\n        int t = Math.abs(k);\\n        \\n        for(int i = 0; i < t; i ++)\\n            sum += code[i];\\n        \\n        for(int i = 0; i < code.length; i ++){\\n            sum = sum - code[i] + code[(i + t)%code.length];\\n            cycle[i] = sum;\\n        }\\n        \\n        if(k > 0) return cycle;\\n        \\n        int[] res = new int[code.length];\\n        \\n        for(int i = 0; i < code.length; i ++)\\n            res[i] = cycle[(i + code.length - t - 1)%code.length];\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] decrypt(int[] code, int k) {\\n        int[] cycle = new int[code.length];  \\n        if(k == 0) return cycle;\\n        \\n        int sum = 0;\\n        int t = Math.abs(k);\\n        \\n        for(int i = 0; i < t; i ++)\\n            sum += code[i];\\n        \\n        for(int i = 0; i < code.length; i ++){\\n            sum = sum - code[i] + code[(i + t)%code.length];\\n            cycle[i] = sum;\\n        }\\n        \\n        if(k > 0) return cycle;\\n        \\n        int[] res = new int[code.length];\\n        \\n        for(int i = 0; i < code.length; i ++)\\n            res[i] = cycle[(i + code.length - t - 1)%code.length];\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054478,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        x = []\\n        \\n        if k == 0 :\\n            return [0]*len(code)\\n        \\n        elif k > 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [i+1:i+1+k]))\\n                \\n        elif k < 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [len(code)+i+k:len(code)+i]))\\n        \\n        return x\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        x = []\\n        \\n        if k == 0 :\\n            return [0]*len(code)\\n        \\n        elif k > 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [i+1:i+1+k]))\\n                \\n        elif k < 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [len(code)+i+k:len(code)+i]))\\n        \\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051935,
                "title": "0ms-simple-c-solution",
                "content": "\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    \\n    int *ptr=(int*)malloc(sizeof(int)*codeSize);\\n    *returnSize=codeSize;\\n    \\n    int i,j;\\n    \\n    for(i=0;i<codeSize;i++)\\n    {\\n        int sum=0;\\n        if(k>0)\\n        {\\n            if(i+k<codeSize)\\n            {\\n                for(j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=i+1;j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=0;j<i+k+1-codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            ptr[i]=0;\\n        }\\n        else\\n        {\\n            if(i+k>=0)\\n            {\\n                for(j=i+k;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=0;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=codeSize-(abs(k)-i);j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n    }\\n    \\n    return ptr;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    \\n    int *ptr=(int*)malloc(sizeof(int)*codeSize);\\n    *returnSize=codeSize;\\n    \\n    int i,j;\\n    \\n    for(i=0;i<codeSize;i++)\\n    {\\n        int sum=0;\\n        if(k>0)\\n        {\\n            if(i+k<codeSize)\\n            {\\n                for(j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=i+1;j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=0;j<i+k+1-codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            ptr[i]=0;\\n        }\\n        else\\n        {\\n            if(i+k>=0)\\n            {\\n                for(j=i+k;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=0;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=codeSize-(abs(k)-i);j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n    }\\n    \\n    return ptr;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036396,
                "title": "simple-c-with-circle-arr-comment-100-faster-85-better-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sum = 0;\\n        int n = code.size();\\n        int cnt = 0;\\n        vector<int> v(n);\\n        \\n        if (k > 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i+1; cnt < k; j++) {\\n                    if (j == n) j = 0; // circle logic - code[n+1] = code[0]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        else if (k < 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i-1; cnt < -k; j--) {\\n                    if (j < 0) j = n-1; // circle logic - code[-1] = code[n-1]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            } \\n        }\\n        \\n        else {\\n            for (int i = 0; i < n; ++i) {\\n                v[i] = 0;    \\n            }\\n        }\\n                    \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sum = 0;\\n        int n = code.size();\\n        int cnt = 0;\\n        vector<int> v(n);\\n        \\n        if (k > 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i+1; cnt < k; j++) {\\n                    if (j == n) j = 0; // circle logic - code[n+1] = code[0]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        else if (k < 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i-1; cnt < -k; j--) {\\n                    if (j < 0) j = n-1; // circle logic - code[-1] = code[n-1]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            } \\n        }\\n        \\n        else {\\n            for (int i = 0; i < n; ++i) {\\n                v[i] = 0;    \\n            }\\n        }\\n                    \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029160,
                "title": "simple-c-solution-100-faster",
                "content": "int n=code.size();\\n        if(k==0)\\n        {\\n            vector<int>v(n,0);\\n            return v;\\n        }\\n        \\n        vector<int>res;\\n        int q=0,sum=0,i=0,c=0;\\n         if(k>0)\\n        {\\n             i=1;\\n        while(q<n)\\n        {\\n            if(i<n)\\n            {  \\n                 sum=sum+code[i];\\n                c++;\\n                if(c==k)\\n                {\\n                    c=0;\\n                    res.push_back(sum);\\n                    sum=0;\\n                    q++;\\n                    i=q;\\n                }\\n                i++;\\n                     \\n            }\\n            else{\\n                i=0;\\n                \\n            }\\n            \\n        }\\n       \\n        return res;\\n        }\\n        else\\n        {\\n            i=n-1;\\n             while(q<n)\\n           {\\n                    if(i>=0)\\n                    {  \\n                          sum=sum+code[i];\\n                             c++;\\n                          if(c==abs(k))\\n                         {\\n                              c=0;\\n                             res.push_back(sum);\\n                             sum=0;\\n                             q++;\\n                              i=q;\\n                          }\\n                          i--;\\n                     \\n                     }\\n                     else\\n                          i=n-1;\\n        }\\n       \\n        return res;\\n        }\\n",
                "solutionTags": [],
                "code": "int n=code.size();\\n        if(k==0)\\n        {\\n            vector<int>v(n,0);\\n            return v;\\n        }\\n        \\n        vector<int>res;\\n        int q=0,sum=0,i=0,c=0;\\n         if(k>0)\\n        {\\n             i=1;\\n        while(q<n)\\n        {\\n            if(i<n)\\n            {  \\n                 sum=sum+code[i];\\n                c++;\\n                if(c==k)\\n                {\\n                    c=0;\\n                    res.push_back(sum);\\n                    sum=0;\\n                    q++;\\n                    i=q;\\n                }\\n                i++;\\n                     \\n            }\\n            else{\\n                i=0;\\n                \\n            }\\n            \\n        }\\n       \\n        return res;\\n        }\\n        else\\n        {\\n            i=n-1;\\n             while(q<n)\\n           {\\n                    if(i>=0)\\n                    {  \\n                          sum=sum+code[i];\\n                             c++;\\n                          if(c==abs(k))\\n                         {\\n                              c=0;\\n                             res.push_back(sum);\\n                             sum=0;\\n                             q++;\\n                              i=q;\\n                          }\\n                          i--;\\n                     \\n                     }\\n                     else\\n                          i=n-1;\\n        }\\n       \\n        return res;\\n        }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1029000,
                "title": "c-optimized-code-faster-than-90",
                "content": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        int i,j;\\n        vector< int>v(n,0);\\n        if(k==0)\\n        {\\n            return v;\\n        }\\n        int check;\\n        if(k>0)\\n        {\\n            for(i=0;i<n;i++)\\n            {\\n               int sum=0;\\n               check=k;\\n               j=i+1;\\n               while(check--)\\n               {\\n                    j=j%n;\\n                   sum+=code[j];\\n                   j++;\\n                   \\n                   \\n               }\\n                v[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(i=n-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                check=-k;\\n                j=i-1;\\n                if(j==-1)\\n                {\\n                    j=n-1;\\n                }\\n                while(check--)\\n                {\\n                    if(j==-1)\\n                    {\\n                        j=n-1;\\n                    }\\n                    sum+=code[j];\\n                    j--;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n       \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        int i,j;\\n        vector< int>v(n,0);\\n        if(k==0)\\n        {\\n            return v;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1003515,
                "title": "python3-easy-solution-with-list-index-manipulation",
                "content": "\\'\\'\\'\\n\\n\\n\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        retList = []\\n        \\n        if k == 0:\\n            for i in range(len(code)):\\n                retList.append(0)\\n                \\n            return retList\\n        \\n        if k > 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(k):\\n                    if i+1+j < len(code):\\n                        sumup += code[i+1+j]\\n                    else:\\n                        sumup += code[i+1+j-len(code)]\\n                \\n                retList.append(sumup)\\n                \\n            return retList\\n        \\n        if k < 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(abs(k)):\\n                    if i-j-1 < 0:\\n                        sumup += code[len(code)+i-j-1]\\n                    else:\\n                        sumup += code[i-j-1]\\n                        \\n                    \\n                retList.append(sumup)\\n                \\n            return retList",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\n\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        retList = []\\n        \\n        if k == 0:\\n            for i in range(len(code)):\\n                retList.append(0)\\n                \\n            return retList\\n        \\n        if k > 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(k):\\n                    if i+1+j < len(code):\\n                        sumup += code[i+1+j]\\n                    else:\\n                        sumup += code[i+1+j-len(code)]\\n                \\n                retList.append(sumup)\\n                \\n            return retList\\n        \\n        if k < 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(abs(k)):\\n                    if i-j-1 < 0:\\n                        sumup += code[len(code)+i-j-1]\\n                    else:\\n                        sumup += code[i-j-1]\\n                        \\n                    \\n                retList.append(sumup)\\n                \\n            return retList",
                "codeTag": "Python3"
            },
            {
                "id": 992601,
                "title": "java-brute-force-solution-beats-47-08",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int l = code.length;\\n        int output[] = new int[l];\\n        if (k > 0) {\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i + 1; count < k; j++) {\\n                    c += code[j % l];\\n                    count++;\\n                }\\n\\n                output[i] = c;\\n            }\\n        } else if (k < 0) {\\n\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i - 1; count < Math.abs(k); j--) {\\n                    c += code[(j + l) % l];\\n                    count++;\\n                }\\n                output[i] = c;\\n            }\\n\\n        } else {\\n            for (int i = 0; i < l; i++) {\\n                output[i] = 0;\\n            }\\n\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int l = code.length;\\n        int output[] = new int[l];\\n        if (k > 0) {\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i + 1; count < k; j++) {\\n                    c += code[j % l];\\n                    count++;\\n                }\\n\\n                output[i] = c;\\n            }\\n        } else if (k < 0) {\\n\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i - 1; count < Math.abs(k); j--) {\\n                    c += code[(j + l) % l];\\n                    count++;\\n                }\\n                output[i] = c;\\n            }\\n\\n        } else {\\n            for (int i = 0; i < l; i++) {\\n                output[i] = 0;\\n            }\\n\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984880,
                "title": "rust-o-n",
                "content": "Working through those type conversions, a prev sol helped. :) \\n\\n\\n```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if code.len() <= 0 {\\n            return code\\n        }\\n        let mut ret = vec![0; code.len()];\\n        let L  = ret.len();\\n        \\n        match k {\\n            0 => {}\\n            std::i32::MIN..=-1_i32 => {\\n                for i in 0..L {\\n                    for j in k..=-1 {\\n                        ret[i] += code[((i+L) as i32 + j ) as usize % L]\\n                    }\\n                }\\n            }\\n            1_i32..=std::i32::MAX => {\\n                for i in 0..L {\\n                    for j in 1..=k {\\n                        ret[i] += code[(i+j as usize)  % L]\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if code.len() <= 0 {\\n            return code\\n        }\\n        let mut ret = vec![0; code.len()];\\n        let L  = ret.len();\\n        \\n        match k {\\n            0 => {}\\n            std::i32::MIN..=-1_i32 => {\\n                for i in 0..L {\\n                    for j in k..=-1 {\\n                        ret[i] += code[((i+L) as i32 + j ) as usize % L]\\n                    }\\n                }\\n            }\\n            1_i32..=std::i32::MAX => {\\n                for i in 0..L {\\n                    for j in 1..=k {\\n                        ret[i] += code[(i+j as usize)  % L]\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 967756,
                "title": "simple-python-solution",
                "content": "```\\n    n = len(code) \\n    res = n * [0]\\n    code_extended = code * (abs(k)+1)  \\n    if k > 0:\\n        for i in range(n):\\n            res[i] = sum(code_extended[i+1:i+k+1])\\n    elif k < 0:\\n        k = abs(k)\\n        for i in range(k*n, (k+1)*n):\\n            res[i-k*n] = sum(code_extended[i-k:i])\\n    return res",
                "solutionTags": [],
                "code": "```\\n    n = len(code) \\n    res = n * [0]\\n    code_extended = code * (abs(k)+1)  \\n    if k > 0:\\n        for i in range(n):\\n            res[i] = sum(code_extended[i+1:i+k+1])\\n    elif k < 0:\\n        k = abs(k)\\n        for i in range(k*n, (k+1)*n):\\n            res[i-k*n] = sum(code_extended[i-k:i])\\n    return res",
                "codeTag": "Unknown"
            },
            {
                "id": 963902,
                "title": "go-solution-0ms-2-5mb",
                "content": "The idea is to form a temp slice that mimic the feature of circular array. It\\'ll be easy to locate the target elements, but with cost of higher memory usage.\\neg: \\nInput: code = [5,7,1,4] , k = -2\\ntemp would become  [5,7,1,4,**5,7,1,4**,5,7,1,4]\\n\\n```\\nfunc decrypt(code []int, k int) []int {\\n    var temp []int\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    n := len(code)\\n    for i:=n;i<2*n;i++ {\\n        var sum, j int = 0, k\\n        for j != 0  {\\n            sum += temp[i+j]\\n            if j < 0 { j++ }\\n            if j > 0 { j-- }\\n        }\\n        code[i-n] = sum\\n    }\\n    return code\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    var temp []int\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    n := len(code)\\n    for i:=n;i<2*n;i++ {\\n        var sum, j int = 0, k\\n        for j != 0  {\\n            sum += temp[i+j]\\n            if j < 0 { j++ }\\n            if j > 0 { j-- }\\n        }\\n        code[i-n] = sum\\n    }\\n    return code\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 959724,
                "title": "c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n = a.size(), s = 0;\\n        vector<int> prefix(n+1, 0);\\n        vector<int> ans(n, 0);\\n        // create prefix array \\n        for(int i=0; i<n; i++) {\\n            prefix[i+1] = prefix[i] + a[i];\\n        }\\n        \\n        if(k > 0) {\\n            for(int i=0; i<n; i++) {\\n\\t\\t\\t\\t// first part of the window \\n                int r = min(n-1, i+k);\\n                ans[i] += prefix[r+1] - prefix[i+1];\\n\\t\\t\\t\\t// second part of the window \\n                r = k - (r - i);\\n                ans[i] += prefix[r];\\n            }\\n        } else if(k < 0) {\\n            k = -k;\\n            for(int i=0; i<n; i++) {\\n                int l = max(0, i-k);\\n\\t\\t\\t\\t// first part of the window \\n                ans[i] += prefix[i] - prefix[l];\\n                l = k - (i - l);\\n\\t\\t\\t\\t// second part of the window \\n                ans[i] += prefix[n] - prefix[n-l]; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n = a.size(), s = 0;\\n        vector<int> prefix(n+1, 0);\\n        vector<int> ans(n, 0);\\n        // create prefix array \\n        for(int i=0; i<n; i++) {\\n            prefix[i+1] = prefix[i] + a[i];\\n        }\\n        \\n        if(k > 0) {\\n            for(int i=0; i<n; i++) {\\n\\t\\t\\t\\t// first part of the window \\n                int r = min(n-1, i+k);\\n                ans[i] += prefix[r+1] - prefix[i+1];\\n\\t\\t\\t\\t// second part of the window \\n                r = k - (r - i);\\n                ans[i] += prefix[r];\\n            }\\n        } else if(k < 0) {\\n            k = -k;\\n            for(int i=0; i<n; i++) {\\n                int l = max(0, i-k);\\n\\t\\t\\t\\t// first part of the window \\n                ans[i] += prefix[i] - prefix[l];\\n                l = k - (i - l);\\n\\t\\t\\t\\t// second part of the window \\n                ans[i] += prefix[n] - prefix[n-l]; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950114,
                "title": "java-solution-brute-force",
                "content": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] h = new int[code.length];\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    if (i + j == code.length) {\\n                        g = 0;\\n                    } else {\\n                        g++;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        else if (k == 0){\\n            for (int i = 0; i < code.length; i++) {\\n                h[i] = 0;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= (-1) * k; j++) {\\n                    if (i - j < 0 && g == 0){\\n                        g = code.length - 1;\\n                    }\\n                    else {\\n                        g --;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] h = new int[code.length];\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    if (i + j == code.length) {\\n                        g = 0;\\n                    } else {\\n                        g++;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        else if (k == 0){\\n            for (int i = 0; i < code.length; i++) {\\n                h[i] = 0;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= (-1) * k; j++) {\\n                    if (i - j < 0 && g == 0){\\n                        g = code.length - 1;\\n                    }\\n                    else {\\n                        g --;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943955,
                "title": "python-3-without-modulo-94-time",
                "content": "Quite a lengthy code but it does the job.\\n\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = []\\n        for x,i in enumerate(code):\\n            if k > 0:\\n                if (x+k+1) > len(code):  #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[x+1:x+k+1]) + sum(code[:(k-(len(code)-1-x))]))\\n                else:\\n                    res.append(sum(code[x+1:x+k+1]))        \\n            elif k == 0:\\n                return [0]*len(code)\\n            elif k < 0:\\n                if k+x < 0: #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[k+x:]) + sum(code[:x]))\\n                else:\\n                    res.append(sum(code[x+k:x]))\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = []\\n        for x,i in enumerate(code):\\n            if k > 0:\\n                if (x+k+1) > len(code):  #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[x+1:x+k+1]) + sum(code[:(k-(len(code)-1-x))]))\\n                else:\\n                    res.append(sum(code[x+1:x+k+1]))        \\n            elif k == 0:\\n                return [0]*len(code)\\n            elif k < 0:\\n                if k+x < 0: #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[k+x:]) + sum(code[:x]))\\n                else:\\n                    res.append(sum(code[x+k:x]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938270,
                "title": "more-understandable",
                "content": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        #defining range if k positive or negative\\n        #ranger[start, end]\\n        ranger= [1, abs(k+1)] if k>0 else [k, 0]\\n        mylist = []\\n        #run every number\\n        for c in range(len(code)):\\n            sum = 0\\n            #go through the range\\n            for index in range(ranger[0], ranger[1]):\\n                sum += code[(c+index)%len(code)]\\n            mylist.append(sum)\\n        return mylist\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        #defining range if k positive or negative\\n        #ranger[start, end]\\n        ranger= [1, abs(k+1)] if k>0 else [k, 0]\\n        mylist = []\\n        #run every number\\n        for c in range(len(code)):\\n            sum = 0\\n            #go through the range\\n            for index in range(ranger[0], ranger[1]):\\n                sum += code[(c+index)%len(code)]\\n            mylist.append(sum)\\n        return mylist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937967,
                "title": "c-o-n-time-o-1-additional-space",
                "content": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n);\\n        int runsum = 0;\\n        bool rev = 0;\\n        \\n        if (k < 0) {\\n            rev = 1;\\n            k = -k;\\n            reverse(code.begin(), code.end());\\n        }\\n        \\n        for (int i = 0; i <= k; i++)\\n            runsum += code[i];\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\trunsum -= code[i];\\n            ans[i] = runsum;\\n            runsum += code[(i + k + 1) % n];\\n        }\\n        if (rev)\\n\\t\\t\\treverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n);\\n        int runsum = 0;\\n        bool rev = 0;\\n        \\n        if (k < 0) {\\n            rev = 1;\\n            k = -k;\\n            reverse(code.begin(), code.end());\\n        }\\n        \\n        for (int i = 0; i <= k; i++)\\n            runsum += code[i];\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\trunsum -= code[i];\\n            ans[i] = runsum;\\n            runsum += code[(i + k + 1) % n];\\n        }\\n        if (rev)\\n\\t\\t\\treverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936993,
                "title": "java-10-liner-o-n",
                "content": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint currentSum = 0;\\n\\tfor(int i=0;i<Math.abs(k);i++) currentSum += code[k>0?i:code.length-1-i];\\n\\tint[] result = new int[code.length];\\n\\tif(k!=0)\\n\\t\\tfor(int i=0;i<code.length;i++) {\\n\\t\\t\\tint currentIndex = k > 0 ? i: code.length - 1 - i;\\n\\t\\t\\tcurrentSum = currentSum - code[currentIndex] + code[(code.length+currentIndex+k)%code.length];\\n\\t\\t\\tresult[currentIndex] = currentSum;\\n\\t\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint currentSum = 0;\\n\\tfor(int i=0;i<Math.abs(k);i++) currentSum += code[k>0?i:code.length-1-i];\\n\\tint[] result = new int[code.length];\\n\\tif(k!=0)\\n\\t\\tfor(int i=0;i<code.length;i++) {\\n\\t\\t\\tint currentIndex = k > 0 ? i: code.length - 1 - i;\\n\\t\\t\\tcurrentSum = currentSum - code[currentIndex] + code[(code.length+currentIndex+k)%code.length];\\n\\t\\t\\tresult[currentIndex] = currentSum;\\n\\t\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936660,
                "title": "java-0ms-sliding-window",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) return new int[code.length];\\n        \\n        int n = code.length;\\n        int ksum = 0;\\n        int[] res = new int[n];\\n        \\n        // build k size sum.\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) ksum += code[i];\\n            \\n        } else {\\n            for (int i = n - 1; i >= (n + k); i--) ksum += code[i];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n                int next = code[((n + i + k) % n)];\\n                int curr = code [i];\\n                \\n                if (k > 0) {\\n                    res[i] = ksum - curr + next;\\n                    ksum = res[i];\\n                }\\n                else {\\n                    res[i] = ksum;\\n                    ksum = ksum + curr - next; \\n                }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) return new int[code.length];\\n        \\n        int n = code.length;\\n        int ksum = 0;\\n        int[] res = new int[n];\\n        \\n        // build k size sum.\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) ksum += code[i];\\n            \\n        } else {\\n            for (int i = n - 1; i >= (n + k); i--) ksum += code[i];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n                int next = code[((n + i + k) % n)];\\n                int curr = code [i];\\n                \\n                if (k > 0) {\\n                    res[i] = ksum - curr + next;\\n                    ksum = res[i];\\n                }\\n                else {\\n                    res[i] = ksum;\\n                    ksum = ksum + curr - next; \\n                }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936226,
                "title": "defuse-the-bomb",
                "content": "c++  solution \\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n       \\n        \\n         int n=code.size();\\n         vector<int> ans;\\n         for(int i=0;i<n;i++){\\n             \\n             if(k==0){\\n                 ans.push_back(0);\\n             }\\n             else if(k>0){\\n                 int sum=0;\\n                 for(int j=i+1;j<=i+k;j++){\\n                     sum+=code[j%n];\\n                 }\\n                 ans.push_back(sum);\\n             }\\n             else{\\n                 int sum=0;\\n                 for(int j=i+k;j<=i-1;j++){\\n                     sum+=code[(j+n)%n];\\n                 }\\n                 ans.push_back(sum);     \\n             }\\n         }\\n         return ans;   \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n       \\n        \\n         int n=code.size();\\n         vector<int> ans;\\n         for(int i=0;i<n;i++){\\n             \\n             if(k==0){\\n                 ans.push_back(0);\\n             }\\n             else if(k>0){\\n                 int sum=0;\\n                 for(int j=i+1;j<=i+k;j++){\\n                     sum+=code[j%n];\\n                 }\\n                 ans.push_back(sum);\\n             }\\n             else{\\n                 int sum=0;\\n                 for(int j=i+k;j<=i-1;j++){\\n                     sum+=code[(j+n)%n];\\n                 }\\n                 ans.push_back(sum);     \\n             }\\n         }\\n         return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935446,
                "title": "javascript-o-n-k-time-complexity",
                "content": "```\\nvar decrypt = function(code, k) {\\n  const n = code.length;\\n\\n  let res = new Array(n).fill(0)\\n  if (k == 0) {\\n    return res;\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    if (k > 0) {\\n      for (let j = 0; j < k; j++) {\\n        let index = (i+1+j) % n;\\n        res[i] += code[index];\\n      }\\n    } else if (k < 0) {\\n      for (let j = 0; j < -k; j++) {\\n        let index = (i+n-j-1) % n;\\n        res[i] += code[index];\\n      }\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar decrypt = function(code, k) {\\n  const n = code.length;\\n\\n  let res = new Array(n).fill(0)\\n  if (k == 0) {\\n    return res;\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    if (k > 0) {\\n      for (let j = 0; j < k; j++) {\\n        let index = (i+1+j) % n;\\n        res[i] += code[index];\\n      }\\n    } else if (k < 0) {\\n      for (let j = 0; j < -k; j++) {\\n        let index = (i+n-j-1) % n;\\n        res[i] += code[index];\\n      }\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935431,
                "title": "easy-to-understand-o-nk-soln",
                "content": "```\\npublic int[] decrypt(int[] code, int k) {\\n        int n=code.length;\\n        int[] res=new int[n];\\n        if(k>0){\\n            for(int i=0;i<n;i++){\\n                for(int j=i+1;j<=i+k;j++)\\n                    res[i]+=code[j%n];\\n            }\\n        }\\n        else{\\n            for(int i=n-1;i>=0;i--){\\n                for(int j=i-1;j>=i+k;j--){\\n                    int idx=j>=0?j:j+n;\\n                    res[i]+=code[idx];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n        int n=code.length;\\n        int[] res=new int[n];\\n        if(k>0){\\n            for(int i=0;i<n;i++){\\n                for(int j=i+1;j<=i+k;j++)\\n                    res[i]+=code[j%n];\\n            }\\n        }\\n        else{\\n            for(int i=n-1;i>=0;i--){\\n                for(int j=i-1;j>=i+k;j--){\\n                    int idx=j>=0?j:j+n;\\n                    res[i]+=code[idx];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 935393,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res = code;\\n        res.insert(res.end(),code.begin(),code.end());\\n        vector<int> ans;\\n        if(k>0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int i=code.size();i<res.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res = code;\\n        res.insert(res.end(),code.begin(),code.end());\\n        vector<int> ans;\\n        if(k>0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int i=code.size();i<res.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935391,
                "title": "java-simple-o-nk-and-sliding-window-o-n-time-solutions",
                "content": "`O(NK)` time solutions:\\nJust do what is asked in the question\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int sum = 0;\\n            \\n            if (k > 0) {\\n                for (int j = 0; j < k; j++) {\\n                    sum += code[(i + j + 1) % n];\\n                }\\n            } else if (k < 0) {\\n                for (int j = 0; j < -k; j++) {\\n                    sum += code[(i + n - j - 1) % n];\\n                }\\n            }\\n            \\n            answer[i] = sum;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\n`O(N)` time solution\\nCompute sum for the first element. Continue computing sum for others maintaining sliding window\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        if (k == 0) {\\n            return answer;\\n        }\\n        \\n        int sum = 0;\\n        for (int idx = (n + k) % n, move = -k / Math.abs(k); idx != 0; idx = (idx + move) % n) {\\n            sum += code[idx];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            answer[i] = sum;\\n            \\n            if (k < 0) {\\n                sum -= code[(n + k + i) % n];\\n                sum += code[i];\\n            } else {\\n                sum -= code[(i + 1) % n];\\n                sum += code[(i + k + 1) % n];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int sum = 0;\\n            \\n            if (k > 0) {\\n                for (int j = 0; j < k; j++) {\\n                    sum += code[(i + j + 1) % n];\\n                }\\n            } else if (k < 0) {\\n                for (int j = 0; j < -k; j++) {\\n                    sum += code[(i + n - j - 1) % n];\\n                }\\n            }\\n            \\n            answer[i] = sum;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        if (k == 0) {\\n            return answer;\\n        }\\n        \\n        int sum = 0;\\n        for (int idx = (n + k) % n, move = -k / Math.abs(k); idx != 0; idx = (idx + move) % n) {\\n            sum += code[idx];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            answer[i] = sum;\\n            \\n            if (k < 0) {\\n                sum -= code[(n + k + i) % n];\\n                sum += code[i];\\n            } else {\\n                sum -= code[(i + 1) % n];\\n                sum += code[(i + k + 1) % n];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935388,
                "title": "java-0-ms-faster-than-100-00-39-4-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        int sum = 0;\\n        int n = code.length;\\n        int[] res = new int[n];\\n        if (k > 0) {\\n            for (int i = 0; i < n + k; ++i) {\\n                sum += code[i % n];\\n                if (i >= k) {\\n                    sum -= code[i - k];\\n                    res[i - k] = sum;\\n                }\\n            }\\n        } else {\\n            k = -k;\\n            for (int i = 0; i < n + k; ++i) {\\n                if (i >= k) {\\n                    res[i % n] = sum;\\n                    sum -= code[i - k];\\n                }\\n                sum += code[i % n];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        int sum = 0;\\n        int n = code.length;\\n        int[] res = new int[n];\\n        if (k > 0) {\\n            for (int i = 0; i < n + k; ++i) {\\n                sum += code[i % n];\\n                if (i >= k) {\\n                    sum -= code[i - k];\\n                    res[i - k] = sum;\\n                }\\n            }\\n        } else {\\n            k = -k;\\n            for (int i = 0; i < n + k; ++i) {\\n                if (i >= k) {\\n                    res[i % n] = sum;\\n                    sum -= code[i - k];\\n                }\\n                sum += code[i % n];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935385,
                "title": "brute-force-java",
                "content": "```\\n\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0)\\n        {\\n            return new int[code.length];\\n        }\\n        \\n        int[] res = new int[code.length];\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                for(int j = i + 1; j <= i + k; j++)\\n                {\\n                    res[i] += code[j % code.length];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                int l = Math.abs(k);\\n                for(int j = i - 1 + code.length; l > 0; j--)\\n                {\\n                    res[i] += code[j % code.length];\\n                    l--;\\n                }\\n            }\\n        }\\n        \\n        return res;        \\n    }\\n\\t\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0)\\n        {\\n            return new int[code.length];\\n        }\\n        \\n        int[] res = new int[code.length];\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                for(int j = i + 1; j <= i + k; j++)\\n                {\\n                    res[i] += code[j % code.length];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                int l = Math.abs(k);\\n                for(int j = i - 1 + code.length; l > 0; j--)\\n                {\\n                    res[i] += code[j % code.length];\\n                    l--;\\n                }\\n            }\\n        }\\n        \\n        return res;        \\n    }\\n\\t\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 935371,
                "title": "kt-js-py3-cpp-one-step-at-a-time",
                "content": "**Synopsis:**\\n\\nGenerate the answer `ans` one step at a time by accumulating the total sum of the `K` values adjacent to-the-right of each `i`<sup>th</sup> element of the input array `A`.  To simplify the code when `K` is negative, simply reverse `A` and return the reversed answer using positive `K`.\\n\\n---\\n\\n**Bi-Weekly Contest 39 Screenshare:**\\n\\n![image](https://assets.leetcode.com/users/images/2c2f0b1a-650d-43dc-bb60-fbd2340d74c1_1605370887.2933993.png)\\n\\nhttps://www.youtube.com/watch?v=tOBm0jYytpc\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun decrypt(A: IntArray, K: Int): IntArray {\\n        var N = A.size\\n        if (K == 0)\\n            return IntArray(N) { 0 }\\n        if (K < 0)\\n            return decrypt(A.reversed().toIntArray(), -K).reversed().toIntArray()\\n        var ans = mutableListOf<Int>()\\n        var step = { i: Int -> if (i + 1 < N) i + 1 else 0 }\\n        for (i in 0 until N) {\\n            var total = 0\\n            var j = step(i)\\n            for (steps in 0 until K) {\\n                total += A[j]\\n                j = step(j)\\n            }\\n            ans.add(total)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet decrypt = (A, K, ans = []) => {\\n    let N = A.length;\\n    if (!K)\\n        return Array(N).fill(0);\\n    if (K < 0)\\n        return decrypt(A.reverse(), -K).reverse();\\n    let step = i => i + 1 < N ? i + 1 : 0;\\n    for (let i = 0; i < N; ++i) {\\n        let steps = K,\\n            total = 0,\\n            j = step(i);\\n        while (steps--) total += A[j], j = step(j);\\n        ans.push(total);\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def decrypt(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        if not K:\\n            return [0] * N\\n        if K < 0:\\n            return self.decrypt(A[::-1], -K)[::-1]\\n        step = lambda i: i + 1 if i + 1 < N else 0\\n        ans = []\\n        for i in range(N):\\n            steps = K\\n            total = 0\\n            j = step(i)\\n            for _ in range(steps): total += A[j]; j = step(j)\\n            ans.append(total)\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI decrypt(VI& A, int K, VI ans = {}) {\\n        auto N = A.size();\\n        if (!K)\\n            return VI(N);\\n        if (K < 0) {\\n            reverse(A.begin(), A.end());\\n            ans = decrypt(A, -K);\\n            return { ans.rbegin(), ans.rend() };\\n        }\\n        auto step = [=](auto i) { return i + 1 < N ? i + 1 : 0; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto steps = K,\\n                 total = 0,\\n                 j = step(i);\\n            while (steps--) total += A[j], j = step(j);\\n            ans.push_back(total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun decrypt(A: IntArray, K: Int): IntArray {\\n        var N = A.size\\n        if (K == 0)\\n            return IntArray(N) { 0 }\\n        if (K < 0)\\n            return decrypt(A.reversed().toIntArray(), -K).reversed().toIntArray()\\n        var ans = mutableListOf<Int>()\\n        var step = { i: Int -> if (i + 1 < N) i + 1 else 0 }\\n        for (i in 0 until N) {\\n            var total = 0\\n            var j = step(i)\\n            for (steps in 0 until K) {\\n                total += A[j]\\n                j = step(j)\\n            }\\n            ans.add(total)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\n```\\nlet decrypt = (A, K, ans = []) => {\\n    let N = A.length;\\n    if (!K)\\n        return Array(N).fill(0);\\n    if (K < 0)\\n        return decrypt(A.reverse(), -K).reverse();\\n    let step = i => i + 1 < N ? i + 1 : 0;\\n    for (let i = 0; i < N; ++i) {\\n        let steps = K,\\n            total = 0,\\n            j = step(i);\\n        while (steps--) total += A[j], j = step(j);\\n        ans.push(total);\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def decrypt(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        if not K:\\n            return [0] * N\\n        if K < 0:\\n            return self.decrypt(A[::-1], -K)[::-1]\\n        step = lambda i: i + 1 if i + 1 < N else 0\\n        ans = []\\n        for i in range(N):\\n            steps = K\\n            total = 0\\n            j = step(i)\\n            for _ in range(steps): total += A[j]; j = step(j)\\n            ans.append(total)\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI decrypt(VI& A, int K, VI ans = {}) {\\n        auto N = A.size();\\n        if (!K)\\n            return VI(N);\\n        if (K < 0) {\\n            reverse(A.begin(), A.end());\\n            ans = decrypt(A, -K);\\n            return { ans.rbegin(), ans.rend() };\\n        }\\n        auto step = [=](auto i) { return i + 1 < N ? i + 1 : 0; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto steps = K,\\n                 total = 0,\\n                 j = step(i);\\n            while (steps--) total += A[j], j = step(j);\\n            ans.push_back(total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090277,
                "title": "loop-solution-time-complexity-o-n-k",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe inner loop iterates from 1 to the absolute value of k (inclusive). The purpose of this loop is to perform a certain number of shifts on the code list elements.\\n\\nInside this nested loop, there\\'s a conditional statement that checks whether k is greater than 0. If it is, it calculates the new value of newNum by adding the code element at the index (i+j)%n to newNum. If k is less than 0, it calculates newNum by adding the code element at the index (i-j)%n to newNum.\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(code)\\n        output = [0]*n\\n        if k == 0:\\n            return output\\n\\n        for i in range(n):\\n            newNum = 0\\n            for j in range(1,abs(k)+1):\\n                if k > 0:\\n                    newNum = newNum + code[(i+j)%n]\\n                else:\\n                    newNum = newNum + code[(i-j)%n]\\n            output[i] = newNum\\n        return output\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(code)\\n        output = [0]*n\\n        if k == 0:\\n            return output\\n\\n        for i in range(n):\\n            newNum = 0\\n            for j in range(1,abs(k)+1):\\n                if k > 0:\\n                    newNum = newNum + code[(i+j)%n]\\n                else:\\n                    newNum = newNum + code[(i-j)%n]\\n            output[i] = newNum\\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088740,
                "title": "easy-to-understand-java-solution-takes-only-1ms-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int sumg(int code[],int i,int k){//Function to find sum in case of k>0\\n        int s=0;i=i+1;\\n        while(k>0){\\n            if(i>code.length-1){\\n                 i=0;\\n                  s+=code[i];\\n            }\\n            else{\\n                s+=code[i];\\n            }\\n            i+=1;\\n            k--;\\n        }\\n        return s;\\n    }\\n    public int suml(int code[],int i,int k){//Function to find sum in case of k<0\\n       int s=0;i=i-1;\\n       while(k>0){\\n           if(i>=0&&i<code.length){\\n               s+=code[i];\\n           }\\n           else{\\n               i=code.length-1;\\n               s+=code[i];\\n           }\\n           i-=1;\\n           k-=1;\\n       }\\n       return s;\\n    }\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k==0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=0;\\n            }\\n            return ans;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=sumg(code,i,k);\\n            }\\n            return ans;\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=suml(code,i,k*(-1));\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumg(int code[],int i,int k){//Function to find sum in case of k>0\\n        int s=0;i=i+1;\\n        while(k>0){\\n            if(i>code.length-1){\\n                 i=0;\\n                  s+=code[i];\\n            }\\n            else{\\n                s+=code[i];\\n            }\\n            i+=1;\\n            k--;\\n        }\\n        return s;\\n    }\\n    public int suml(int code[],int i,int k){//Function to find sum in case of k<0\\n       int s=0;i=i-1;\\n       while(k>0){\\n           if(i>=0&&i<code.length){\\n               s+=code[i];\\n           }\\n           else{\\n               i=code.length-1;\\n               s+=code[i];\\n           }\\n           i-=1;\\n           k-=1;\\n       }\\n       return s;\\n    }\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k==0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=0;\\n            }\\n            return ans;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=sumg(code,i,k);\\n            }\\n            return ans;\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=suml(code,i,k*(-1));\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078307,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n=a.size(), j=0;\\n        vector<int> v(2*n, 0);\\n        vector<int> ret(n, 0);\\n        for(int i=0; i<n; ++i) v[i]=a[i];\\n        for(int i=n; i<2*n; ++i) v[i]=a[j++];\\n        if(k > 0) {\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=i+1; j<=i+k; ++j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n        } else if(k < 0) {\\n            k=abs(k);\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=n+i-1; j>(n+i-1)-k; --j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n=a.size(), j=0;\\n        vector<int> v(2*n, 0);\\n        vector<int> ret(n, 0);\\n        for(int i=0; i<n; ++i) v[i]=a[i];\\n        for(int i=n; i<2*n; ++i) v[i]=a[j++];\\n        if(k > 0) {\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=i+1; j<=i+k; ++j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n        } else if(k < 0) {\\n            k=abs(k);\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=n+i-1; j>(n+i-1)-k; --j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072718,
                "title": "c-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> v(code.size(), 0);\\n        if (k == 0){\\n            return v;\\n        }else if ( k > 0){\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    v[i] += code[(i+j)%code.size()];\\n                }\\n            }\\n            return v;\\n        }else{\\n            k = 0-k;\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    //cout << \"i \" << i << \" j \" << j << endl;\\n                    if ((i-j) >= 0){\\n                        v[i] += code[(i-j)%code.size()];\\n                    }else{\\n                        v[i] += code[code.size() - abs(i-j)%code.size()];\\n                    }\\n                }\\n            }\\n            return v;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> v(code.size(), 0);\\n        if (k == 0){\\n            return v;\\n        }else if ( k > 0){\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    v[i] += code[(i+j)%code.size()];\\n                }\\n            }\\n            return v;\\n        }else{\\n            k = 0-k;\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    //cout << \"i \" << i << \" j \" << j << endl;\\n                    if ((i-j) >= 0){\\n                        v[i] += code[(i-j)%code.size()];\\n                    }else{\\n                        v[i] += code[code.size() - abs(i-j)%code.size()];\\n                    }\\n                }\\n            }\\n            return v;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4064331,
                "title": "easy-cpp-solution-beats-100-in-runtime-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sz = code.size();\\n        vector<int> ans(sz, 0);\\n        if(k == 0) return ans;\\n        int start = k > 0 ? 1 : sz+k, end = k > 0 ? k : sz-1;\\n        for(int i=0; i<sz; i++){\\n            if(i == 0){\\n                for(int j=start; j<=end; j++)\\n                    ans[i] += code[j%sz];\\n            }\\n            else if(k > 0) ans[i] = ans[i-1] - code[i] + code[(i+k)%sz];\\n            else ans[i] = ans[i-1] - code[(i-1+sz+k)%sz] + code[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sz = code.size();\\n        vector<int> ans(sz, 0);\\n        if(k == 0) return ans;\\n        int start = k > 0 ? 1 : sz+k, end = k > 0 ? k : sz-1;\\n        for(int i=0; i<sz; i++){\\n            if(i == 0){\\n                for(int j=start; j<=end; j++)\\n                    ans[i] += code[j%sz];\\n            }\\n            else if(k > 0) ans[i] = ans[i-1] - code[i] + code[(i+k)%sz];\\n            else ans[i] = ans[i-1] - code[(i-1+sz+k)%sz] + code[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060974,
                "title": "2ms-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int result[]=new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                result[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i+1;j<code.length*2;j++)\\n                {\\n                    sum+=code[j%code.length];\\n                    k1++;\\n                    if(k1==k)\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n        }\\n        else if(k<0) {\\n\\n            for(int i=result.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i-1;j>=(-code.length);j--)\\n                {\\n                    if(j>=0)\\n                    {\\n                        sum+=code[j];\\n                    }\\n                    else if (j<0)\\n                    {\\n                        sum+=code[j+code.length];\\n                    }\\n                    k1++;\\n                    if(k1==Math.abs(k))\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int result[]=new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                result[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i+1;j<code.length*2;j++)\\n                {\\n                    sum+=code[j%code.length];\\n                    k1++;\\n                    if(k1==k)\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n        }\\n        else if(k<0) {\\n\\n            for(int i=result.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i-1;j>=(-code.length);j--)\\n                {\\n                    if(j>=0)\\n                    {\\n                        sum+=code[j];\\n                    }\\n                    else if (j<0)\\n                    {\\n                        sum+=code[j+code.length];\\n                    }\\n                    k1++;\\n                    if(k1==Math.abs(k))\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055984,
                "title": "simpler-as-much-for-beginner-beatz-100",
                "content": "## Complexity\\n####  Time complexity: O(n^2) \\n#### Space complexity: O(n) \\n\\n## Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = [0]*len(code)\\n\\n        if k > 0:\\n            for i in range(len(code)):\\n                temp = code[i+1:] + code\\n                res[i] = sum(temp[:k])\\n            return res\\n\\n        if k == 0:\\n            return res\\n\\n        else:\\n            for i in range(len(code)):\\n                temp = code+code[:i]\\n                res[i] = sum(temp[k:])\\n            return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = [0]*len(code)\\n\\n        if k > 0:\\n            for i in range(len(code)):\\n                temp = code[i+1:] + code\\n                res[i] = sum(temp[:k])\\n            return res\\n\\n        if k == 0:\\n            return res\\n\\n        else:\\n            for i in range(len(code)):\\n                temp = code+code[:i]\\n                res[i] = sum(temp[k:])\\n            return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038589,
                "title": "easy-and-understandable-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func decrypt(_ code: [Int], _ k: Int) -> [Int] {\\n        var answer:[Int] = []\\n        let codeExt = code + code + code\\n        let count = code.count\\n\\n        if k == 0 {\\n            answer = Array(repeating: 0, count: count)\\n        } else if k > 0{\\n            for i in 0..<count{\\n                let add = codeExt[count+1+i...count+i+k]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        } else {\\n            for i in 0..<count{\\n                let add = codeExt[count+k+i...count+i-1]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func decrypt(_ code: [Int], _ k: Int) -> [Int] {\\n        var answer:[Int] = []\\n        let codeExt = code + code + code\\n        let count = code.count\\n\\n        if k == 0 {\\n            answer = Array(repeating: 0, count: count)\\n        } else if k > 0{\\n            for i in 0..<count{\\n                let add = codeExt[count+1+i...count+i+k]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        } else {\\n            for i in 0..<count{\\n                let add = codeExt[count+k+i...count+i-1]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034311,
                "title": "beats-100-with-0ms-optimal-solution-with-explanation-tc-o-n-sc-o-n",
                "content": "# Intuition\\nk is basically a window of elements and we see this window moving across as we move ahead to populate our indices in the new array.\\n\\n# Approach\\nWe break down the problem into 3 parts. k==0 is straight forward. Our window slides for K>0 and K<0. the movement of the window is same, its just the starting and ending indices we have to identify for the different tow different cases of k. Once we do that we just create a for loop where we slide our window.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) and I believe it can\\'t be lower than that as we are supposed to return an array and we should always create a new one rather than modifying our input unless asked to.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        int sumArr = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n\\n        // when K=0 return the array as it is.\\n\\n        if(k==0){\\n            return arr;\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k>0){\\n            startIndex = 1;\\n            endIndex = k;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k<0){\\n            startIndex = code.length+k;\\n            endIndex = code.length-1;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // Now we just populate each index in the new array. while also incrementing our start and end index.\\n        for(int i = 0; i<code.length; i++){\\n            arr[i] = sumArr;\\n\\n            // if the pointer reaches the end, it comes back from the starting end and hence = 0.\\n            if(endIndex == code.length-1){\\n                endIndex = 0;\\n            }\\n            else{\\n                endIndex ++;\\n            }\\n            sumArr = sumArr - code[startIndex] + code[endIndex];\\n\\n            if(startIndex == code.length-1){\\n                startIndex = 0;\\n            }\\n            else{\\n                startIndex ++;\\n            }\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        int sumArr = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n\\n        // when K=0 return the array as it is.\\n\\n        if(k==0){\\n            return arr;\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k>0){\\n            startIndex = 1;\\n            endIndex = k;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k<0){\\n            startIndex = code.length+k;\\n            endIndex = code.length-1;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // Now we just populate each index in the new array. while also incrementing our start and end index.\\n        for(int i = 0; i<code.length; i++){\\n            arr[i] = sumArr;\\n\\n            // if the pointer reaches the end, it comes back from the starting end and hence = 0.\\n            if(endIndex == code.length-1){\\n                endIndex = 0;\\n            }\\n            else{\\n                endIndex ++;\\n            }\\n            sumArr = sumArr - code[startIndex] + code[endIndex];\\n\\n            if(startIndex == code.length-1){\\n                startIndex = 0;\\n            }\\n            else{\\n                startIndex ++;\\n            }\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033458,
                "title": "one-line-solution-using-a-cyclic-iterator",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)] if k > 0 else [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)] if k < 0 else [0]*len(code)\\n```\\n> More readable\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k > 0:\\n            return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)]\\n        if k < 0:\\n            return [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)]\\n        return [0]*len(code)\\n```",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)] if k > 0 else [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)] if k < 0 else [0]*len(code)\\n```\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k > 0:\\n            return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)]\\n        if k < 0:\\n            return [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)]\\n        return [0]*len(code)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020155,
                "title": "beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let result = []\\n    let sum \\n  \\n\\n    if( k > 0) {\\n        for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+k;j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n    }\\n    if(k === 0) {\\n        for(let k = 0; k <code.length;k++) {\\n            result.push(0)\\n        }\\n    }\\n\\n    if(k < 0) {\\n          let reverse = code.reverse()\\n         for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+(k*-1);j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n        result.reverse()\\n\\n    }\\n    return result \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let result = []\\n    let sum \\n  \\n\\n    if( k > 0) {\\n        for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+k;j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n    }\\n    if(k === 0) {\\n        for(let k = 0; k <code.length;k++) {\\n            result.push(0)\\n        }\\n    }\\n\\n    if(k < 0) {\\n          let reverse = code.reverse()\\n         for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+(k*-1);j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n        result.reverse()\\n\\n    }\\n    return result \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968965,
                "title": "c-0ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);  // Initialize the result vector\\n        if (k != 0) {\\n            for (int i = 0; i < n; i++) {\\n                int sum = 0;\\n                // Define the step direction\\n                // int step = k > 0 ? 1 : -1;\\n                int step;\\n                if(k>0){\\n                    step = 1;\\n                } else{\\n                    step = -1;\\n                }\\n                for (int j = 1; j <= abs(k); j++) {\\n                    // Calculate the new index with wrap-around\\n                    int index = (i + j * step + n) % n;\\n                    sum += code[index];\\n                }    \\n                res[i] = sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);  // Initialize the result vector\\n        if (k != 0) {\\n            for (int i = 0; i < n; i++) {\\n                int sum = 0;\\n                // Define the step direction\\n                // int step = k > 0 ? 1 : -1;\\n                int step;\\n                if(k>0){\\n                    step = 1;\\n                } else{\\n                    step = -1;\\n                }\\n                for (int j = 1; j <= abs(k); j++) {\\n                    // Calculate the new index with wrap-around\\n                    int index = (i + j * step + n) % n;\\n                    sum += code[index];\\n                }    \\n                res[i] = sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964778,
                "title": "sliding-window-reverse",
                "content": "# Intuition\\nWe can use sliding window for k > 0, for k < 0 we can reverse input and calculated outout.\\n\\n# Approach\\nFor k > 0, we can start by calculating first value with index 0, and sum from 1 to k.\\nNext we need to update n numbers, on each step we remove i + 1, element from the sum and add, k + i + 1 element to it. Use % of n to ensure data is read from ring buffer.\\nFor case when k < 0 we need to reverse input and output.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        const int n = code.size();\\n\\n        vector<int> result(n, 0);\\n        if (k == 0) {\\n            return result;\\n        }\\n\\n        bool rr = false;\\n        if (k < 0) {\\n            reverse(code.begin(), code.end());\\n            k = -k;\\n            rr = true;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 1;i <= k;i ++) {\\n            sum += code[i];\\n        }\\n\\n        int j = (k + 1) % n;\\n        for (int i = 0;i < code.size();i ++) {\\n            result[i] = sum;\\n            sum -= code[(i + 1) % n];\\n            sum += code[j % n];\\n            j ++;\\n        }\\n\\n        if (rr) {\\n            reverse(result.begin(), result.end());\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        const int n = code.size();\\n\\n        vector<int> result(n, 0);\\n        if (k == 0) {\\n            return result;\\n        }\\n\\n        bool rr = false;\\n        if (k < 0) {\\n            reverse(code.begin(), code.end());\\n            k = -k;\\n            rr = true;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 1;i <= k;i ++) {\\n            sum += code[i];\\n        }\\n\\n        int j = (k + 1) % n;\\n        for (int i = 0;i < code.size();i ++) {\\n            result[i] = sum;\\n            sum -= code[(i + 1) % n];\\n            sum += code[j % n];\\n            j ++;\\n        }\\n\\n        if (rr) {\\n            reverse(result.begin(), result.end());\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948273,
                "title": "cpp-solution",
                "content": "\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        vector<int> decrypt(vector<int> &code, int k)\\n        {\\n            int n = code.size(), sum = 0, t, idx = 0;\\n            vector<int> ans;\\n            if (k == 0)\\n            {\\n                vector<int> ans2(n);\\n                return ans2;\\n            }\\n            else if (k > 0)\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = k;\\n                    idx = i + 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == n)\\n                        {\\n                            idx = 0;\\n                        }\\n                        sum += code[idx++];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            else\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = abs(k);\\n                    idx = i - 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == -1)\\n                        {\\n                            idx = n - 1;\\n                        }\\n                        sum += code[idx--];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> decrypt(vector<int> &code, int k)\\n        {\\n            int n = code.size(), sum = 0, t, idx = 0;\\n            vector<int> ans;\\n            if (k == 0)\\n            {\\n                vector<int> ans2(n);\\n                return ans2;\\n            }\\n            else if (k > 0)\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = k;\\n                    idx = i + 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == n)\\n                        {\\n                            idx = 0;\\n                        }\\n                        sum += code[idx++];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            else\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = abs(k);\\n                    idx = i - 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == -1)\\n                        {\\n                            idx = n - 1;\\n                        }\\n                        sum += code[idx--];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942997,
                "title": "java-straightforward-t-s-o-m-runtime-78-80-1-ms-memory-93-29-41-1-mb",
                "content": "# Intuition & Approach\\nThis `decrypt` method that takes an integer array `code` and an integer `k` as input, and it returns an integer array `decrypt` as output. The purpose of this method is to \"decrypt\" the input array `code` using the given value of `k`. \\n\\n**Let\\'s break down the code step by step:**\\n\\n```\\npublic int[] decrypt(int[] code, int k) {\\n    int M = code.length;\\n    int[] decrypt = new int[M];\\n    \\n    if(k == 0)\\n        return decrypt;\\n````\\nHere, the method starts by defining a few variables:\\n\\n- `M` represents the length of the input array `code`.\\n\\n- An integer array `decrypt` is created with the same length as `code` to store the decrypted values.\\n\\n- The `if` condition checks if `k` is equal to `0`. If `k` is indeed `0`, then the decrypt array is returned as is (in accordance with the instructions), and the method terminates.\\n\\n```\\nfor(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n    int v = 0, adj = (k < 0) ? M + i : i;\\n    \\n    for(int j = 1; j <= e; j++) \\n        v += code[(adj + sgn * j) % M];\\n\\n    decrypt[i] = v;\\n}\\n```\\nIf `k` is not `0`, the method proceeds to this loop. This loop iterates through each index `i` of the `code` array. Here\\'s what happens in each iteration:\\n\\n- A variable `sgn` is set to either `-1` or `1` based on whether `k` is *negative* or *positive*. This is used to control the direction of decryption.\\n\\n- A variable `e` is set to the absolute value of `k`. This determines how many *steps of decryption will be performed*.\\n\\n- An integer variable `v` is initialized to `0`. This variable will accumulate the decrypted value for the current index `i`.\\n\\n- A variable `adj` is set to `M + i` if `k` is negative, or simply `i` if `k` is positive. This `adj` value is used to adjust the index when accessing elements from the `code` array.\\n\\n- An inner loop runs `e` times. In each iteration of the inner loop, it adds the value at the adjusted index `(adj + sgn * j) % M` to the variable `v`.\\n\\n- After the inner loop completes, the decrypted value for the current index `i` is stored in the `decrypt` array.\\n\\nFinally, the decrypted array `decrypt` is returned after the loop has processed all indices of the `code` array.\\n\\nIn summary, `decrypt` method decrypts the input code array by performing a series of circular shifts based on the value of `k`, and the result is stored in the `decrypt` array.\\n\\n\\n# Complexity\\n- Time complexity: $$T(M * e) = O(M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int M = code.length;\\n        int[] decrypt = new int[M];\\n        \\n        if(k == 0)\\n            return decrypt;\\n        \\n        for(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n            int v = 0, adj = (k < 0) ? M + i : i;\\n            \\n            for(int j = 1; j <= e; j++) \\n                v += code[(adj + sgn * j) % M];\\n\\n            decrypt[i] = v;\\n        }\\n\\n        return decrypt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n    int M = code.length;\\n    int[] decrypt = new int[M];\\n    \\n    if(k == 0)\\n        return decrypt;\\n```\n```\\nfor(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n    int v = 0, adj = (k < 0) ? M + i : i;\\n    \\n    for(int j = 1; j <= e; j++) \\n        v += code[(adj + sgn * j) % M];\\n\\n    decrypt[i] = v;\\n}\\n```\n``` java []\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int M = code.length;\\n        int[] decrypt = new int[M];\\n        \\n        if(k == 0)\\n            return decrypt;\\n        \\n        for(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n            int v = 0, adj = (k < 0) ? M + i : i;\\n            \\n            for(int j = 1; j <= e; j++) \\n                v += code[(adj + sgn * j) % M];\\n\\n            decrypt[i] = v;\\n        }\\n\\n        return decrypt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914589,
                "title": "c-beginner-friendly-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n   O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans(n,0);\\n        if(k>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<=k;j++)\\n                {\\n                    ans[i]=ans[i]+code[(i+j)%n];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=-1;j>=k;j--)\\n                {\\n                    int ind=(i+j)%n;\\n                    if(ind<0)\\n                    {\\n                        ind=ind+n;\\n                    }\\n                    ans[i]=ans[i]+code[ind];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans(n,0);\\n        if(k>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<=k;j++)\\n                {\\n                    ans[i]=ans[i]+code[(i+j)%n];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=-1;j>=k;j--)\\n                {\\n                    int ind=(i+j)%n;\\n                    if(ind<0)\\n                    {\\n                        ind=ind+n;\\n                    }\\n                    ans[i]=ans[i]+code[ind];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885410,
                "title": "runtime-54ms-memory-43-10-mb-easy-for-loop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function (code, k) {\\n    let arr = []\\n    if (k == 0) {\\n        return code.fill(0)\\n    }\\n    for (let i = 0; i < code.length; i++) {\\n        let val = 0\\n        let n = 0\\n        if (k < 0) {\\n            for (let j = i-1; n> k; j--) {\\n                 if (!code[j]) {\\n                    j = code.length-1\\n                } \\n                    val = val + code[j]\\n                    n--\\n            }\\n        }\\n        else {\\n            for (let j = i+1; n<k; j++) {\\n                if (!code[j]) {\\n                    j = 0\\n                } \\n                    val = val + code[j]\\n                    n++\\n            }\\n        }\\n        arr.push(val)\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function (code, k) {\\n    let arr = []\\n    if (k == 0) {\\n        return code.fill(0)\\n    }\\n    for (let i = 0; i < code.length; i++) {\\n        let val = 0\\n        let n = 0\\n        if (k < 0) {\\n            for (let j = i-1; n> k; j--) {\\n                 if (!code[j]) {\\n                    j = code.length-1\\n                } \\n                    val = val + code[j]\\n                    n--\\n            }\\n        }\\n        else {\\n            for (let j = i+1; n<k; j++) {\\n                if (!code[j]) {\\n                    j = 0\\n                } \\n                    val = val + code[j]\\n                    n++\\n            }\\n        }\\n        arr.push(val)\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3874629,
                "title": "simple-c-solution",
                "content": "# Intuition\\nGenerate the array just the way it is described in the problem description.\\n\\n# Approach\\nCreate an array of the same size, as all operations are done simultaneously, which means we should not edit the original array.\\n\\nFor every index in the array, we sum all the values that we need. \\n\\nsteps: the amount of steps we make. We have to make a total of abs(k) steps.\\nindex: The index of the value we add to sum. We have code to wrap it around if it goes beyond the array bounds.\\nsum: Sum of the values.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n\\n        vector<int> ans(n, 0);\\n\\n        for(int i = 0; i < code.size(); ++i) {\\n            int steps = 0;\\n            int index = i;\\n            int sum = 0;\\n            while(steps < abs(k)) {\\n                index += (k > 0) ? 1 : -1;\\n                if(index >= n) {\\n                    index = 0;\\n                } else if(index < 0) {\\n                    index = n - 1;\\n                }\\n\\n                sum += code[index];\\n                ++steps;\\n            }\\n\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n\\n        vector<int> ans(n, 0);\\n\\n        for(int i = 0; i < code.size(); ++i) {\\n            int steps = 0;\\n            int index = i;\\n            int sum = 0;\\n            while(steps < abs(k)) {\\n                index += (k > 0) ? 1 : -1;\\n                if(index >= n) {\\n                    index = 0;\\n                } else if(index < 0) {\\n                    index = n - 1;\\n                }\\n\\n                sum += code[index];\\n                ++steps;\\n            }\\n\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868122,
                "title": "java",
                "content": "\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        //next ele = (i+1)%n;\\n        //prev ele =(i-1+n)%n;\\n        int n = code.length;\\n        if(k==0)\\n        {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        else if(k>0)\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i+1)%n;\\n                for(int j=1; j<=k; j++)\\n                {\\n                    sum += code[start];\\n                    start = (start+1)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        else\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i-1+n)%n;\\n                for(int j=1; j<=Math.abs(k); j++)\\n                {\\n                    sum += code[start];\\n                    start = (start-1+n)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        //next ele = (i+1)%n;\\n        //prev ele =(i-1+n)%n;\\n        int n = code.length;\\n        if(k==0)\\n        {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        else if(k>0)\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i+1)%n;\\n                for(int j=1; j<=k; j++)\\n                {\\n                    sum += code[start];\\n                    start = (start+1)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        else\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i-1+n)%n;\\n                for(int j=1; j<=Math.abs(k); j++)\\n                {\\n                    sum += code[start];\\n                    start = (start-1+n)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861654,
                "title": "by-07chorno-c-o-ms-beats-1oo-the-best-answer-click-now-to-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int L = code.size(), tmp, j;\\n        vector<int> decode(L);\\n\\n        if(k == 0)\\n            return decode;\\n        else if(k > 0)\\n        {\\n            for(int i = 0; i < L; i ++)\\n            {\\n                j = i+1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j == L)\\n                        j = 0;\\n                    decode[i] += code[j++];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            k *= -1;\\n            for(int i = 0; i < L; i++)\\n            {\\n                j = i - 1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j < 0)\\n                        j = L - 1;\\n                    decode[i] += code[j--];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        return decode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int L = code.size(), tmp, j;\\n        vector<int> decode(L);\\n\\n        if(k == 0)\\n            return decode;\\n        else if(k > 0)\\n        {\\n            for(int i = 0; i < L; i ++)\\n            {\\n                j = i+1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j == L)\\n                        j = 0;\\n                    decode[i] += code[j++];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            k *= -1;\\n            for(int i = 0; i < L; i++)\\n            {\\n                j = i - 1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j < 0)\\n                        j = L - 1;\\n                    decode[i] += code[j--];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        return decode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838391,
                "title": "1652-defuse-the-bomb",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int n=code.length;\\n        int res[]=new int[n];\\n\\n        if(k==0)\\n         return res;\\n\\n        else{\\n            int i=0,j=0,sum=0;\\n\\n            while(i<n){\\n                sum+=code[(j+n)%n];\\n\\n                if((j-i+1+n)%n<Math.abs(k))\\n                    j++; \\n\\n                else{\\n\\n                    if(k>0)\\n                     res[(i-1+n)%n]=sum;\\n\\n                    else\\n                     res[(j+1+n)%n]=sum;\\n                    sum-=code[(i+n)%n];\\n                    i++;\\n                    j++; \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int n=code.length;\\n        int res[]=new int[n];\\n\\n        if(k==0)\\n         return res;\\n\\n        else{\\n            int i=0,j=0,sum=0;\\n\\n            while(i<n){\\n                sum+=code[(j+n)%n];\\n\\n                if((j-i+1+n)%n<Math.abs(k))\\n                    j++; \\n\\n                else{\\n\\n                    if(k>0)\\n                     res[(i-1+n)%n]=sum;\\n\\n                    else\\n                     res[(j+1+n)%n]=sum;\\n                    sum-=code[(i+n)%n];\\n                    i++;\\n                    j++; \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817286,
                "title": "my-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> sum(code.size(), 0);\\n        if(k>0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=1; i<=k; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                    \\n                }\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=k; i<=-1; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n\\n\\n    int getnumber(vector<int>& code, int index)\\n    {\\n        int N = code.size();\\n        if(index>=0)\\n        {\\n            return code[index % N];\\n        }\\n        else\\n        {\\n            while(index < 0)\\n            {\\n                index += N;\\n            }\\n            return code[index % N];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> sum(code.size(), 0);\\n        if(k>0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=1; i<=k; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                    \\n                }\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=k; i<=-1; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n\\n\\n    int getnumber(vector<int>& code, int index)\\n    {\\n        int N = code.size();\\n        if(index>=0)\\n        {\\n            return code[index % N];\\n        }\\n        else\\n        {\\n            while(index < 0)\\n            {\\n                index += N;\\n            }\\n            return code[index % N];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814537,
                "title": "using-fixed-size-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n      int n = code.size();\\n      vector<int>ans(n,0);\\n      if( k == 0 )\\n      return ans;\\n      int s = 1, e = k;\\n\\n      if( k<0 )\\n      {\\n          k*= -1;\\n          s = n-k;\\n          e = n-1;\\n      }\\n\\n      int sum = 0;\\n      for( int  i = s; i<=e; i++)\\n      {\\n          sum+= code[i];\\n      } \\n\\n      for( int i = 0; i<n; i++)\\n      {\\n          ans[i] = sum;\\n          sum-= code[(s++)%n];\\n          sum+= code[(++e)%n];\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n      int n = code.size();\\n      vector<int>ans(n,0);\\n      if( k == 0 )\\n      return ans;\\n      int s = 1, e = k;\\n\\n      if( k<0 )\\n      {\\n          k*= -1;\\n          s = n-k;\\n          e = n-1;\\n      }\\n\\n      int sum = 0;\\n      for( int  i = s; i<=e; i++)\\n      {\\n          sum+= code[i];\\n      } \\n\\n      for( int i = 0; i<n; i++)\\n      {\\n          ans[i] = sum;\\n          sum-= code[(s++)%n];\\n          sum+= code[(++e)%n];\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810699,
                "title": "easy-sliding-window-solution-beats-100",
                "content": "\\n# Approach\\nI think this is minor variation of fixed sliding window. \\n1. Here window is fixed however windowstart and windowEnd isn\\'t starting with 0.\\n2. Main idea is how to initialise windowStart i.e. l and windoEnd i.e r. If  k> 0 then l=1 and r=1. Else for negative k -> l,r= code.length + k i.e. if k=-2 and n=4 then l,r = 2\\n3. Like most of sliding window solutions, we will iterate for Math.abs(k) to calculate sum of window. And doing that, we will increment r. We make sure that r is reinitiaze to 0 when it reaches end of array.\\n4. Once we have the window sum, then it is easy sliding window with maintaining boundry condition for both l and r;\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n     int[] arr = new int[code.length];\\n     if(k==0){\\n         return arr;\\n     }\\n    int l = k > 0  ? 1 : code.length + k;\\n    int r=l;\\n    int itr = Math.abs(k);\\n    int sum=0;\\n    for(int i=0; i< itr ; i++){\\n        sum+=code[r];\\n        r++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n    }\\n    int idx =0;\\n    while(idx< code.length){\\n        arr[idx] = sum;\\n        sum = sum + code[r] - code[l];    \\n        idx++;\\n        r++;\\n        l++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n        if(l== code.length){\\n            l=0;\\n        }\\n    }\\n     return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n     int[] arr = new int[code.length];\\n     if(k==0){\\n         return arr;\\n     }\\n    int l = k > 0  ? 1 : code.length + k;\\n    int r=l;\\n    int itr = Math.abs(k);\\n    int sum=0;\\n    for(int i=0; i< itr ; i++){\\n        sum+=code[r];\\n        r++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n    }\\n    int idx =0;\\n    while(idx< code.length){\\n        arr[idx] = sum;\\n        sum = sum + code[r] - code[l];    \\n        idx++;\\n        r++;\\n        l++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n        if(l== code.length){\\n            l=0;\\n        }\\n    }\\n     return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809538,
                "title": "defuse-the-bomb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                arr[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            // int p=0;\\n            for(int i=code.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    if(j<0)\\n                    {\\n                        int l=j+code.length;\\n                        sum=sum+code[l%code.length];\\n                    }\\n                    else\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                arr[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            // int p=0;\\n            for(int i=code.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    if(j<0)\\n                    {\\n                        int l=j+code.length;\\n                        sum=sum+code[l%code.length];\\n                    }\\n                    else\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797556,
                "title": "c-sliding-window-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nto work on the circular array .We just need to think of modulo everytime we want to acess the next\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans1(n,0);\\n        vector<int>ans;\\n        int sum=0;\\n        if(k==0){\\n            return ans1;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n\\n            }\\n            return ans;\\n        }\\n        else{\\n            k=-1*k;\\n            reverse(code.begin(),code.end());\\n            //same code as in above \\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n            }\\n            reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans1(n,0);\\n        vector<int>ans;\\n        int sum=0;\\n        if(k==0){\\n            return ans1;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n\\n            }\\n            return ans;\\n        }\\n        else{\\n            k=-1*k;\\n            reverse(code.begin(),code.end());\\n            //same code as in above \\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n            }\\n            reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781729,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def decrypt(code: Array[Int], k: Int): Array[Int] = {\\n      val n = code.length\\n      val res = Array.ofDim[Int](n)\\n      if (k == 0) res\\n      else if (k > 0) {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to k) sum += code((i + j) % n)\\n          res(i) = sum\\n        }\\n        res\\n      } else {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to -k) sum += code((i - j + n) % n)\\n          res(i) = sum\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def decrypt(code: Array[Int], k: Int): Array[Int] = {\\n      val n = code.length\\n      val res = Array.ofDim[Int](n)\\n      if (k == 0) res\\n      else if (k > 0) {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to k) sum += code((i + j) % n)\\n          res(i) = sum\\n        }\\n        res\\n      } else {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to -k) sum += code((i - j + n) % n)\\n          res(i) = sum\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3763431,
                "title": "easiest-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>&c , int k){\\n        int n=c.size();\\n        vector<int>v(n,0);\\n        if(k==0){\\n            return v;\\n        }\\n        else if(k>0){\\n            for(int i=0; i<n; i++){\\n                int p = k;\\n                int d = i+1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = d%n;\\n                    sum+=c[idx];\\n                    d++;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                int p = -k;\\n                int d = i-1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = (d+n)%n;\\n                    sum+=c[idx];\\n                    d--; \\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>&c , int k){\\n        int n=c.size();\\n        vector<int>v(n,0);\\n        if(k==0){\\n            return v;\\n        }\\n        else if(k>0){\\n            for(int i=0; i<n; i++){\\n                int p = k;\\n                int d = i+1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = d%n;\\n                    sum+=c[idx];\\n                    d++;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                int p = -k;\\n                int d = i-1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = (d+n)%n;\\n                    sum+=c[idx];\\n                    d--; \\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732757,
                "title": "solution-1652-defuse-the-bomb",
                "content": "# Intuition\\nThe code aims to decrypt an array of integers using a given key. It iterates through each element in the input array and calls the helperSum function to calculate the decrypted value. The helperSum function calculates the sum of elements based on the given key and the starting index.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] ans = new int[len];\\n\\n        for (int i = 0; i < len; i++) {\\n            ans[i] = helperSum(code, i, k, len);\\n        }\\n\\n        return ans;\\n    }\\n\\n    static int helperSum (int[] arr, int start, int k, int len) {\\n        int ans = 0;\\n        int s = start;\\n\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) {\\n                ans += arr[(s + i + 1) % len];\\n            }\\n        }\\n\\n        if(k < 0) {\\n            k = Math.abs(k);\\n            int index = s - 1;\\n\\n            for (int i = 1; i <= k; i++) {\\n                if (index== -1) {\\n                    index = len - 1;\\n                }\\n                ans += arr[(index)];\\n                index--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] ans = new int[len];\\n\\n        for (int i = 0; i < len; i++) {\\n            ans[i] = helperSum(code, i, k, len);\\n        }\\n\\n        return ans;\\n    }\\n\\n    static int helperSum (int[] arr, int start, int k, int len) {\\n        int ans = 0;\\n        int s = start;\\n\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) {\\n                ans += arr[(s + i + 1) % len];\\n            }\\n        }\\n\\n        if(k < 0) {\\n            k = Math.abs(k);\\n            int index = s - 1;\\n\\n            for (int i = 1; i <= k; i++) {\\n                if (index== -1) {\\n                    index = len - 1;\\n                }\\n                ans += arr[(index)];\\n                index--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732315,
                "title": "easy-ts-solution",
                "content": "# Code\\n```\\nfunction decrypt(code: number[], k: number): number[] {\\n    const codeLen = code.length;\\n    let defuseCode = []\\n\\n    if(k === 0) return Array(codeLen).fill(k)\\n    \\n    let sum = 0;\\n\\n    for(let i = 0; i < codeLen; i++) {\\n        for(let j = 1; j <= Math.abs(k); j++){\\n            const _j = k < 0 ? -j : j;\\n            const index = Math.abs((codeLen+i+_j)%codeLen);\\n            sum += code[index];    \\n        }\\n        defuseCode.push(sum);\\n        sum = 0\\n    }\\n\\n    return defuseCode\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction decrypt(code: number[], k: number): number[] {\\n    const codeLen = code.length;\\n    let defuseCode = []\\n\\n    if(k === 0) return Array(codeLen).fill(k)\\n    \\n    let sum = 0;\\n\\n    for(let i = 0; i < codeLen; i++) {\\n        for(let j = 1; j <= Math.abs(k); j++){\\n            const _j = k < 0 ? -j : j;\\n            const index = Math.abs((codeLen+i+_j)%codeLen);\\n            sum += code[index];    \\n        }\\n        defuseCode.push(sum);\\n        sum = 0\\n    }\\n\\n    return defuseCode\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3726835,
                "title": "basic-and-explained-c-solution-easy-to-understand-array-basics-beginner-friendly",
                "content": "# Intuition\\nSure! Let me explain the code in first person and discuss its complexity.\\n\\nIn this code, I see a class named `Solution` with a member function `decrypt`. This function takes a reference to a vector of integers `code` and an integer `k` as input. It aims to decrypt the given code using a specific algorithm.\\n\\n\\n# Approach\\nNow, let\\'s go through the code step by step:\\n\\n1. The code starts with an `if` condition that checks if `k` is equal to 0. If this condition is true, it means there is no encryption to decrypt, so the function creates a new vector `ans` with the same size as `code` and fills it with 0s. This is done to return a vector of zeros as the decryption result.\\n\\n2. If `k` is not equal to 0, the code proceeds to the main decryption logic. It initializes an empty vector `ans` to store the decryption results.\\n\\n3. The code then enters a `for` loop that iterates over the elements of the `code` vector. Inside this loop:\\n   - It initializes `sum` and `count` variables to 0, which will be used to calculate the sum of elements and keep track of the number of elements considered.\\n   - It checks if `k` is greater than 0. If `k` is positive, it means we need to decrypt the code in the forward direction.\\n     - If the current index `i` is the last index of `code`, a nested `for` loop is used to iterate from the first element to the `k`th element of `code`. It calculates the sum of these elements and increments the `count` variable.\\n     - If the current index `i` is not the last index, another nested `for` loop is used to iterate from the next index to `k` elements ahead, wrapping around to the beginning if necessary. Again, it calculates the sum of these elements and increments the `count` variable.\\n   - If `k` is less than or equal to 0, it means we need to decrypt the code in the backward direction. The logic is similar to the forward direction, but it iterates in reverse order and wraps around from the last index to the beginning if necessary.\\n   - Finally, the calculated `sum` is added to the `ans` vector.\\n\\n4. After the loop finishes, the function returns the `ans` vector containing the decrypted code.\\n\\n- # Complexity\\n- Time complexity : The code uses two nested loops, each iterating over the elements of the `code` vector. Therefore, the time complexity is O(n^2), where n is the size of the vector.\\n- - Space complexity : The space complexity is O(n) as it uses additional space to store the decrypted code in the `ans` vector, which has the same size as `code`.\\n\\n![star-wars-bb8.gif](https://assets.leetcode.com/users/images/34d33a9f-faca-4c62-9e31-54d0b6ef0d2b_1688640507.0608313.gif)\\n\\n![upvote-raccoon.gif](https://assets.leetcode.com/users/images/e6ce0476-7e4e-47de-b6ba-05c64c207f7e_1688640515.7785654.gif)\\n\\n#Please do Upvote if you find the solution good\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        if(k == 0)\\n        {\\n            vector<int> ans(code.size(),0);\\n            return ans;\\n        }\\n        vector<int> ans;\\n        int sum,count;\\n        for(int i = 0 ; i<code.size() ; i++)\\n        {\\n            sum = 0;\\n            count = 0 ;\\n            if(k > 0)\\n            {\\n                if(i == code.size()-1)\\n                {\\n                    for(int j = 0 ; j<code.size() , count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i+1 ; j<code.size() ,count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == code.size()-1)\\n                        {\\n                            j = -1;\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n            else\\n            {\\n                if(i == 0)\\n                {\\n                    for(int j = code.size()-1 ; j>0 , count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i-1 ; j>=0 ,count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == 0)\\n                        {\\n                            j = code.size();\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}; //Please Upvote\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        if(k == 0)\\n        {\\n            vector<int> ans(code.size(),0);\\n            return ans;\\n        }\\n        vector<int> ans;\\n        int sum,count;\\n        for(int i = 0 ; i<code.size() ; i++)\\n        {\\n            sum = 0;\\n            count = 0 ;\\n            if(k > 0)\\n            {\\n                if(i == code.size()-1)\\n                {\\n                    for(int j = 0 ; j<code.size() , count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i+1 ; j<code.size() ,count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == code.size()-1)\\n                        {\\n                            j = -1;\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n            else\\n            {\\n                if(i == 0)\\n                {\\n                    for(int j = code.size()-1 ; j>0 , count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i-1 ; j>=0 ,count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == 0)\\n                        {\\n                            j = code.size();\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}; //Please Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701654,
                "title": "basic-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i+k-j)>=code.length)\\n                        sum+=code[(i+k-j)-code.length];\\n                    else\\n                        sum+=code[i+k-j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        if(k<0){\\n            k=-k;\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i-k+j)<0)\\n                        sum+=code[code.length+i-k+j];\\n                    else\\n                        sum+=code[i-k+j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i+k-j)>=code.length)\\n                        sum+=code[(i+k-j)-code.length];\\n                    else\\n                        sum+=code[i+k-j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        if(k<0){\\n            k=-k;\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i-k+j)<0)\\n                        sum+=code[code.length+i-k+j];\\n                    else\\n                        sum+=code[i-k+j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692467,
                "title": "day-30",
                "content": "# Complexity\\n- Time complexity:\\n-       O(n * abs(k)), \\n        where n is the length of the code list. This is because for\\n        each element in code, we perform a loop of length abs(k)\\n        to calculate the sum.\\n- Space complexity:\\n-       O(n) \\n        because we create a new list result of size n\\n        to store the decrypted code.\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        result = [0] * n\\n        \\n        if k != 0:\\n            for i in range(n):\\n                if k > 0:\\n                    for j in range(i + 1, i + k + 1):\\n                        result[i] += code[j % n]\\n                else:\\n                    for j in range(i + k, i):\\n                        result[i] += code[(j + n) % n]\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        result = [0] * n\\n        \\n        if k != 0:\\n            for i in range(n):\\n                if k > 0:\\n                    for j in range(i + 1, i + k + 1):\\n                        result[i] += code[j % n]\\n                else:\\n                    for j in range(i + k, i):\\n                        result[i] += code[(j + n) % n]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689987,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int arr[] = new int[code.length];\\n        if(k == 0) {\\n            return arr;\\n        }\\n\\n        if(k > 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        if(k < 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k * -1; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int arr[] = new int[code.length];\\n        if(k == 0) {\\n            return arr;\\n        }\\n\\n        if(k > 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        if(k < 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k * -1; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681291,
                "title": "sliding-window-solution-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> v(n);\\n        if(k>0){\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(n+i-1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else if(k<0){\\n            k=-k;\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(j+1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;++i){\\n                v[i]=0;\\n            }\\n        }\\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> v(n);\\n        if(k>0){\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(n+i-1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else if(k<0){\\n            k=-k;\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(j+1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;++i){\\n                v[i]=0;\\n            }\\n        }\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3680405,
                "title": "harshi-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& c, int k) {\\n        vector<int> l;\\n       int v=c.size();\\n        for(int i=0;i<c.size();i++){\\n             int s=0;\\n             int o=k;\\n             if(o<0){\\n             int p=abs(o);\\n             for(int j=o;j<0;j++){\\n                 int q;\\n                 if (i+j<0)\\n                    q=v+(i+j);\\n                 else  \\n                    q=i+j;\\n\\n                 s=s+c[q]; \\n                 o++;\\n             }\\n             }\\n             else{\\n                 for(int j=1;j<=o;j++)\\n             {  int r=(i+j)%(v);\\n                 s=s+c[r];\\n             }\\n             }\\n              l.push_back(s);\\n            }\\n        return l;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& c, int k) {\\n        vector<int> l;\\n       int v=c.size();\\n        for(int i=0;i<c.size();i++){\\n             int s=0;\\n             int o=k;\\n             if(o<0){\\n             int p=abs(o);\\n             for(int j=o;j<0;j++){\\n                 int q;\\n                 if (i+j<0)\\n                    q=v+(i+j);\\n                 else  \\n                    q=i+j;\\n\\n                 s=s+c[q]; \\n                 o++;\\n             }\\n             }\\n             else{\\n                 for(int j=1;j<=o;j++)\\n             {  int r=(i+j)%(v);\\n                 s=s+c[r];\\n             }\\n             }\\n              l.push_back(s);\\n            }\\n        return l;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673326,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                arr[i] = 0;\\n                return arr;\\n            }\\n        }\\n        int sum = 0;\\n        int ops;\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i + 1 <= code.length - 1 ? i + 1 : 0;\\n                int negative = 0;\\n                while (ops > 0) {\\n                    if (index <= code.length - 1) {\\n                        sum += code[index++];\\n                    } else {\\n                        sum += code[negative++];\\n                    }\\n                    ops--;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        } else {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i > 0 ? i - 1 : code.length - 1;\\n                int negative = code.length - 1;\\n                while (ops < 0) {\\n                    if (index >= 0) {\\n                        sum += code[index--];\\n                    } else {\\n                        sum += code[negative--];\\n                    }\\n                    ops++;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        }\\n        return arr;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                arr[i] = 0;\\n                return arr;\\n            }\\n        }\\n        int sum = 0;\\n        int ops;\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i + 1 <= code.length - 1 ? i + 1 : 0;\\n                int negative = 0;\\n                while (ops > 0) {\\n                    if (index <= code.length - 1) {\\n                        sum += code[index++];\\n                    } else {\\n                        sum += code[negative++];\\n                    }\\n                    ops--;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        } else {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i > 0 ? i - 1 : code.length - 1;\\n                int negative = code.length - 1;\\n                while (ops < 0) {\\n                    if (index >= 0) {\\n                        sum += code[index--];\\n                    } else {\\n                        sum += code[negative--];\\n                    }\\n                    ops++;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        }\\n        return arr;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665514,
                "title": "naive-method-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res;\\n        int sum = 0, n = code.size(); \\n        for(int i = 0; i<code.size();i++)\\n        {  \\n            sum =0; \\n             \\n            if(k>0)\\n            { \\n                for(int j = i+1;j<=i+k;j++)\\n                sum += code[j%n];\\n            }\\n            else if(k<0)\\n            {   \\n                for(int j =i-1; j>=i+k;j--)\\n                {\\n                     \\n                   sum += code[(j+n)%n];\\n                }\\n            }\\n            \\n            res.push_back(sum);\\n\\n        }\\n        \\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res;\\n        int sum = 0, n = code.size(); \\n        for(int i = 0; i<code.size();i++)\\n        {  \\n            sum =0; \\n             \\n            if(k>0)\\n            { \\n                for(int j = i+1;j<=i+k;j++)\\n                sum += code[j%n];\\n            }\\n            else if(k<0)\\n            {   \\n                for(int j =i-1; j>=i+k;j--)\\n                {\\n                     \\n                   sum += code[(j+n)%n];\\n                }\\n            }\\n            \\n            res.push_back(sum);\\n\\n        }\\n        \\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653280,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n\\n        if (k==0)\\n            return ans;\\n\\n        for (int i=0 ; i<n ; i++){\\n            int index;\\n            int sum = 0;\\n            if (k>0){\\n                int count = 0;\\n                index = i+1;\\n                while (index < n && count < k){\\n                    sum += code[index++];\\n                    count++;\\n                }\\n                if (count < k){\\n                    index = 0;\\n                    while (count < k){\\n                        sum += code[index++];\\n                        count++;\\n                    }\\n                }\\n            }\\n            else{\\n                int count = 0;\\n                index = i-1;\\n                while (index >= 0 && count < abs(k)){\\n                    sum += code[index--];\\n                    count++;\\n                }\\n                if (count < abs(k)){\\n                    index = n-1;\\n                    while (count < abs(k)){\\n                        sum += code[index--];\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n\\n        if (k==0)\\n            return ans;\\n\\n        for (int i=0 ; i<n ; i++){\\n            int index;\\n            int sum = 0;\\n            if (k>0){\\n                int count = 0;\\n                index = i+1;\\n                while (index < n && count < k){\\n                    sum += code[index++];\\n                    count++;\\n                }\\n                if (count < k){\\n                    index = 0;\\n                    while (count < k){\\n                        sum += code[index++];\\n                        count++;\\n                    }\\n                }\\n            }\\n            else{\\n                int count = 0;\\n                index = i-1;\\n                while (index >= 0 && count < abs(k)){\\n                    sum += code[index--];\\n                    count++;\\n                }\\n                if (count < abs(k)){\\n                    index = n-1;\\n                    while (count < abs(k)){\\n                        sum += code[index--];\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645630,
                "title": "go-solution-bomb-decode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc decrypt(code []int, k int) []int {\\n    var flag bool\\n\\n    var result []int\\n\\n    if k < 0{\\n        for i := 0; i < len(code) / 2; i ++{\\n            code[i], code[len(code) - 1 - i] = code[len(code) - 1 - i], code[i]\\n        }\\n        flag = true\\n        k *= -1\\n    }\\n\\n    for i := 0; i < len(code); i++{\\n        var num int\\n        for j := 0; j < k; j++{\\n            var val int\\n            val = i + j + 1\\n            if val > len(code) - 1{\\n                val = val - len(code)\\n            }\\n            num += code[val]\\n        }\\n        result = append(result, num)\\n    }\\n\\n    if flag == true{\\n        for i := 0; i < len(result) / 2; i ++{\\n            result[i], result[len(result) - 1 - i] = result[len(result) - 1 - i], result[i]\\n        }\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    var flag bool\\n\\n    var result []int\\n\\n    if k < 0{\\n        for i := 0; i < len(code) / 2; i ++{\\n            code[i], code[len(code) - 1 - i] = code[len(code) - 1 - i], code[i]\\n        }\\n        flag = true\\n        k *= -1\\n    }\\n\\n    for i := 0; i < len(code); i++{\\n        var num int\\n        for j := 0; j < k; j++{\\n            var val int\\n            val = i + j + 1\\n            if val > len(code) - 1{\\n                val = val - len(code)\\n            }\\n            num += code[val]\\n        }\\n        result = append(result, num)\\n    }\\n\\n    if flag == true{\\n        for i := 0; i < len(result) / 2; i ++{\\n            result[i], result[len(result) - 1 - i] = result[len(result) - 1 - i], result[i]\\n        }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3641800,
                "title": "java-easy-beginner-friendly-solution-80-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n    int n = code.length;\\n    int arr[] = new int[n];\\n    int sum=0;\\n   // for(int i=0;i<n;i++){\\n        if(k>0){\\n             for(int i=0;i<n;i++){\\n            for(int j=i+1;j<k+i+1;j++){\\n                if(j<n){\\n            sum+=code[j];\\n                }\\n                else{\\n                    sum+=code[j-n];\\n                }\\n            }\\n            arr[i] = sum;\\n        sum = 0;    \\n        }\\n        }\\n        if(k==0){\\n             for(int i=0;i<n;i++){\\n            arr[i] = 0;\\n        }\\n        }\\n        if(k<0) {\\n             for(int i=0;i<n;i++){\\n            for(int l=i-1;l>i-1+k;l--){\\n                if(l<0){\\n                    sum+=code[l+n];\\n                }\\n                else{\\n                    sum+=code[l];\\n                }\\n            }\\n            arr[i] = sum;\\n            sum=0;\\n        }\\n    }\\n    return arr;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n    int n = code.length;\\n    int arr[] = new int[n];\\n    int sum=0;\\n   // for(int i=0;i<n;i++){\\n        if(k>0){\\n             for(int i=0;i<n;i++){\\n            for(int j=i+1;j<k+i+1;j++){\\n                if(j<n){\\n            sum+=code[j];\\n                }\\n                else{\\n                    sum+=code[j-n];\\n                }\\n            }\\n            arr[i] = sum;\\n        sum = 0;    \\n        }\\n        }\\n        if(k==0){\\n             for(int i=0;i<n;i++){\\n            arr[i] = 0;\\n        }\\n        }\\n        if(k<0) {\\n             for(int i=0;i<n;i++){\\n            for(int l=i-1;l>i-1+k;l--){\\n                if(l<0){\\n                    sum+=code[l+n];\\n                }\\n                else{\\n                    sum+=code[l];\\n                }\\n            }\\n            arr[i] = sum;\\n            sum=0;\\n        }\\n    }\\n    return arr;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629016,
                "title": "defuse-the-bomb-js-intuitive-solution",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    len = code.length\\n    arr = []\\n\\n    for (let i = 0; i < len; i++) {        \\n        arr.push(scan(i))\\n    }\\n\\n    return arr\\n\\n    function scan(i) {        \\n        sum = 0\\n        s = k\\n\\n        if (s == 0) return 0\\n\\n        while (s > 0) {\\n            n = i + s\\n            if (n >= len) n = n - len             \\n            sum += code[n]\\n            s --\\n        }\\n\\n        while (s < 0) {\\n            n = i + s    \\n            sum += code.at(n)\\n            s ++\\n        }\\n\\n        return sum\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    len = code.length\\n    arr = []\\n\\n    for (let i = 0; i < len; i++) {        \\n        arr.push(scan(i))\\n    }\\n\\n    return arr\\n\\n    function scan(i) {        \\n        sum = 0\\n        s = k\\n\\n        if (s == 0) return 0\\n\\n        while (s > 0) {\\n            n = i + s\\n            if (n >= len) n = n - len             \\n            sum += code[n]\\n            s --\\n        }\\n\\n        while (s < 0) {\\n            n = i + s    \\n            sum += code.at(n)\\n            s ++\\n        }\\n\\n        return sum\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616240,
                "title": "c-100-faster-circular-sliding-window-with-explanation",
                "content": "# Intuition\\nThe problem clearly deals with an array and sub-array with a window size of k.\\n# Approach\\n3 cases:\\n 1. k==0 return res(output array) as it is with all 0s\\n 2. k>0 - we form a window of size k with pointers i and j, and move till i!=n-1 to ensure we calc the sum for each element. \\nElement to be updated given by i-1\\n 3. k>0 - we form a window of size k with pointers i and j, and move till i!=n-1 to ensure we calc the sum for each element. Element to be updated given by (j+1)%array.size()\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1) - excluding the output array\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& v, int k) {\\n        \\n        int n(v.size()),i(0),j(0),sum(0);\\n        vector<int> res(n,0);\\n\\n        if(k==0) return res;\\n        else if(k>0)\\n        {\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[n-1]=sum;\\n\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[i-1]=sum;\\n            }\\n        }\\n        else\\n        {\\n            sum=0;\\n            j=0;\\n            i=0;\\n            k=abs(k);\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[j+1]=sum;\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[(j+1)%n]=sum;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& v, int k) {\\n        \\n        int n(v.size()),i(0),j(0),sum(0);\\n        vector<int> res(n,0);\\n\\n        if(k==0) return res;\\n        else if(k>0)\\n        {\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[n-1]=sum;\\n\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[i-1]=sum;\\n            }\\n        }\\n        else\\n        {\\n            sum=0;\\n            j=0;\\n            i=0;\\n            k=abs(k);\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[j+1]=sum;\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[(j+1)%n]=sum;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578348,
                "title": "100-time-beat-memory-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:  O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int sum=0,n=code.size();\\n        bool flag=true;\\n        if(k<0)\\n        {\\n            k=-k;\\n            flag=false;\\n        }\\n        for(int i=1;i<=k;i++)\\n            sum+=code[i];\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(sum);\\n            sum+=code[(i+1+k)%n];\\n            sum-=code[(i+1)%n];\\n        }\\n        int l=v[0];\\n        if(flag==false)\\n        {\\n            for(int i=0;i<n;i++)\\n               code[i]=v[(n-k-1+i)%n];\\n            return code;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int sum=0,n=code.size();\\n        bool flag=true;\\n        if(k<0)\\n        {\\n            k=-k;\\n            flag=false;\\n        }\\n        for(int i=1;i<=k;i++)\\n            sum+=code[i];\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(sum);\\n            sum+=code[(i+1+k)%n];\\n            sum-=code[(i+1)%n];\\n        }\\n        int l=v[0];\\n        if(flag==false)\\n        {\\n            for(int i=0;i<n;i++)\\n               code[i]=v[(n-k-1+i)%n];\\n            return code;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576292,
                "title": "lets-defuse-it-yeahhhhhhhhhhhhhh",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to replace each element in the given code array with the sum of the k elements that come after it (if k > 0) or before it (if k < 0), considering the array wraps around. The intuition is to iterate through the code array and calculate the replacement value based on the specified rules.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution iterates through the code array, calling the ReplaceNum function for each element. In ReplaceNum, the replacement value is calculated by iterating k times in the specified direction (forward or backward), summing up the values encountered. The index is adjusted using the modulo operator for wrapping around the array.\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nint Replacenum(vector<int> &code, int i, int k):\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index];\\n            if(index >= code.size()){\\n                index = 0;\\n            }else{\\n                index++;\\n            }\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        while(k--){\\n            value += code[index];\\n            if(index < 0){\\n                index = code.size()-1;\\n            }else{\\n                index--;\\n            }\\n        }\\n        return value;\\n    }\\n\\nfor(int i=0; i<code.size(); i++){\\n    code[i] = ReplaceNum(code, i, k);\\n}\\n*/\\nclass Solution {\\npublic:\\n\\nint ReplaceNum(vector<int> &code, int i, int k){\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index % code.size()];\\n            index++;\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        if(index < 0 ){\\n            index = code.size()-1;\\n        }\\n        value += code[index];\\n        cout << index << \" \";\\n        int reps = abs(k)-1;\\n        while(reps--){\\n            cout << index << \" \";\\n            index--;\\n            if(index < 0){\\n                index = code.size()-1;\\n            }\\n            value += code[index];\\n        }\\n\\n        return value;\\n    };\\n};\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> Output_arr(code.size(),0);\\n        if(k == 0){\\n            return Output_arr;\\n        }\\n        for(int i=0; i<code.size(); i++){\\n            Output_arr[i] = ReplaceNum(code, i, k);\\n        }   \\n\\n        return Output_arr;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nint Replacenum(vector<int> &code, int i, int k):\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index];\\n            if(index >= code.size()){\\n                index = 0;\\n            }else{\\n                index++;\\n            }\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        while(k--){\\n            value += code[index];\\n            if(index < 0){\\n                index = code.size()-1;\\n            }else{\\n                index--;\\n            }\\n        }\\n        return value;\\n    }\\n\\nfor(int i=0; i<code.size(); i++){\\n    code[i] = ReplaceNum(code, i, k);\\n}\\n*/\\nclass Solution {\\npublic:\\n\\nint ReplaceNum(vector<int> &code, int i, int k){\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index % code.size()];\\n            index++;\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        if(index < 0 ){\\n            index = code.size()-1;\\n        }\\n        value += code[index];\\n        cout << index << \" \";\\n        int reps = abs(k)-1;\\n        while(reps--){\\n            cout << index << \" \";\\n            index--;\\n            if(index < 0){\\n                index = code.size()-1;\\n            }\\n            value += code[index];\\n        }\\n\\n        return value;\\n    };\\n};\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> Output_arr(code.size(),0);\\n        if(k == 0){\\n            return Output_arr;\\n        }\\n        for(int i=0; i<code.size(); i++){\\n            Output_arr[i] = ReplaceNum(code, i, k);\\n        }   \\n\\n        return Output_arr;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3574874,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        l=len(code)\\n        if k >0:\\n            ls = []\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,k):\\n                    dcode += code[(i+j+1)%l]\\n                ls.append(dcode)\\n        elif k==0:\\n            ls=[0]*l\\n        else:\\n            ls=[]\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,abs(k)):\\n                    dcode += code[(i-j-1)%l]\\n                ls.append(dcode)\\n        return ls\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        l=len(code)\\n        if k >0:\\n            ls = []\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,k):\\n                    dcode += code[(i+j+1)%l]\\n                ls.append(dcode)\\n        elif k==0:\\n            ls=[0]*l\\n        else:\\n            ls=[]\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,abs(k)):\\n                    dcode += code[(i-j-1)%l]\\n                ls.append(dcode)\\n        return ls\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570432,
                "title": "java-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    private int FindSum(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k-- > 0)\\n        {\\n            sum += code[idx % n];\\n            idx++;\\n        }\\n        return sum;\\n    }\\n    private int FindSum2(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k++ < 0)\\n        {\\n            sum += code[(idx + n) % n];\\n            idx--;\\n        }\\n        return sum;\\n    }\\n    public int[] decrypt(int[] code, int k) \\n    {\\n        int n = code.length;\\n        int ans[] = new int[n];\\n        if(k == 0) return ans;\\n\\n        if(k > 0)\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum(i + 1, code, k);\\n        }\\n        else\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum2(i - 1, code, k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    private int FindSum(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k-- > 0)\\n        {\\n            sum += code[idx % n];\\n            idx++;\\n        }\\n        return sum;\\n    }\\n    private int FindSum2(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k++ < 0)\\n        {\\n            sum += code[(idx + n) % n];\\n            idx--;\\n        }\\n        return sum;\\n    }\\n    public int[] decrypt(int[] code, int k) \\n    {\\n        int n = code.length;\\n        int ans[] = new int[n];\\n        if(k == 0) return ans;\\n\\n        if(k > 0)\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum(i + 1, code, k);\\n        }\\n        else\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum2(i - 1, code, k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562620,
                "title": "beginner-friendly-solution-to-the-problem-2ms-runtime",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int [] ans = new int[code.length];\\n        int code_length = code.length;\\n        int sum;\\n        int index;\\n        int count;\\n        if(k > 0){\\n            index = 0;\\n            while(index < code_length){\\n                sum = 0;\\n                count = 0;\\n                int i = (index+1)%code_length;\\n                while(count < k){\\n                    sum = sum + code[i];\\n                    i = (i+1)%code_length;\\n                    count++;\\n                }\\n                ans[index] = sum;\\n                index++;\\n            }\\n        }\\n        else if(k < 0){\\n            int [] new_array = reverse_array(code);\\n            ans = decrypt(new_array, k*-1);\\n            ans = reverse_array(ans);\\n        }\\n        else {\\n            return ans;\\n        }\\n        return ans;\\n    }\\n    public int[] reverse_array(int[] array){\\n        int first = 0;\\n        int last = array.length - 1;\\n        while(first <  last){\\n            array[first]  = array[first] + array[last];\\n            array[last] = array[first] - array[last];\\n            array[first] = array[first] - array[last];\\n            first++;\\n            last--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int [] ans = new int[code.length];\\n        int code_length = code.length;\\n        int sum;\\n        int index;\\n        int count;\\n        if(k > 0){\\n            index = 0;\\n            while(index < code_length){\\n                sum = 0;\\n                count = 0;\\n                int i = (index+1)%code_length;\\n                while(count < k){\\n                    sum = sum + code[i];\\n                    i = (i+1)%code_length;\\n                    count++;\\n                }\\n                ans[index] = sum;\\n                index++;\\n            }\\n        }\\n        else if(k < 0){\\n            int [] new_array = reverse_array(code);\\n            ans = decrypt(new_array, k*-1);\\n            ans = reverse_array(ans);\\n        }\\n        else {\\n            return ans;\\n        }\\n        return ans;\\n    }\\n    public int[] reverse_array(int[] array){\\n        int first = 0;\\n        int last = array.length - 1;\\n        while(first <  last){\\n            array[first]  = array[first] + array[last];\\n            array[last] = array[first] - array[last];\\n            array[first] = array[first] - array[last];\\n            first++;\\n            last--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559879,
                "title": "python-beat-93",
                "content": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return [0]*len(code)\\n        \\n        # idea is that a circular array\\n        # can be represent as array + array\\n        # ie [5,7,1,4]\\n        # repeated [5,7,1,4,5,7,1,4]\\n        # now apply sliding window from the front\\n        # if k > 0 otherwise start from the back\\n        \\n        repeated = code + code\\n        res = []\\n \\n        if k > 0:\\n            start_index = 0;\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index+1:start_index+1+k]))\\n                start_index+=1\\n        \\n        if k < 0:\\n            start_index = len(repeated)-1\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index-abs(k):start_index]))\\n                start_index-=1\\n            res.reverse()\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return [0]*len(code)\\n        \\n        # idea is that a circular array\\n        # can be represent as array + array\\n        # ie [5,7,1,4]\\n        # repeated [5,7,1,4,5,7,1,4]\\n        # now apply sliding window from the front\\n        # if k > 0 otherwise start from the back\\n        \\n        repeated = code + code\\n        res = []\\n \\n        if k > 0:\\n            start_index = 0;\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index+1:start_index+1+k]))\\n                start_index+=1\\n        \\n        if k < 0:\\n            start_index = len(repeated)-1\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index-abs(k):start_index]))\\n                start_index-=1\\n            res.reverse()\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559649,
                "title": "solution-using-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n         int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n         int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556345,
                "title": "defuse-the-bomb-java-easy",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr=new int[code.length];\\n        if(k==0){return arr;}\\n        if(k>0)\\n        {\\n           for(int i=0;i<code.length;i++)\\n           {\\n                arr[i]=kPositive(code,i+1,k);\\n           }\\n            return arr; \\n        }\\n    \\n        for(int i=0;i<code.length;i++)\\n        {\\n            arr[i]=kNegative(code,i-1,k);\\n        }\\n        return arr;\\n        \\n        \\n    }\\n    public int kPositive(int[] code,int index,int k)\\n    {\\n        int postSum=0;\\n        while(k!=0)\\n        {\\n            postSum+=code[(index)%code.length];\\n            index++;\\n            k--;\\n        }\\n        return postSum;\\n    }\\n    public int kNegative(int[] code,int index,int k)\\n    {\\n        int preSum=0;\\n        while(k!=0)\\n        {  \\n            if(index<0)\\n            {\\n                preSum+=code[code.length+index];\\n            }\\n            else\\n            {\\n               preSum+=code[index]; \\n            }\\n            \\n            index--;\\n            k++;\\n        }\\n        return preSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr=new int[code.length];\\n        if(k==0){return arr;}\\n        if(k>0)\\n        {\\n           for(int i=0;i<code.length;i++)\\n           {\\n                arr[i]=kPositive(code,i+1,k);\\n           }\\n            return arr; \\n        }\\n    \\n        for(int i=0;i<code.length;i++)\\n        {\\n            arr[i]=kNegative(code,i-1,k);\\n        }\\n        return arr;\\n        \\n        \\n    }\\n    public int kPositive(int[] code,int index,int k)\\n    {\\n        int postSum=0;\\n        while(k!=0)\\n        {\\n            postSum+=code[(index)%code.length];\\n            index++;\\n            k--;\\n        }\\n        return postSum;\\n    }\\n    public int kNegative(int[] code,int index,int k)\\n    {\\n        int preSum=0;\\n        while(k!=0)\\n        {  \\n            if(index<0)\\n            {\\n                preSum+=code[code.length+index];\\n            }\\n            else\\n            {\\n               preSum+=code[index]; \\n            }\\n            \\n            index--;\\n            k++;\\n        }\\n        return preSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556131,
                "title": "simple-and-easy-approch",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] arr, int k) {\\n        int op[] = new int[arr.length];\\n        int sum=0;\\n        for(int i=0; i<k; i++){\\n            sum+=arr[i];\\n        }\\n        if(k==0){\\n            return op;\\n        }else if(k>0){\\n            for(int i=0; i<arr.length; i++){\\n                op[i]=sum-arr[i]+arr[(i+k)%arr.length];\\n                sum=op[i];\\n            }\\n        }else{\\n            k=k*-1;\\n            for(int i=0; i<arr.length; i++){\\n                sum=0;\\n                for(int j=1; j<=k; j++){\\n                    sum+=arr[(arr.length-j+i)%arr.length];\\n                }\\n                op[i]=sum;\\n            }\\n        }\\n        \\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] arr, int k) {\\n        int op[] = new int[arr.length];\\n        int sum=0;\\n        for(int i=0; i<k; i++){\\n            sum+=arr[i];\\n        }\\n        if(k==0){\\n            return op;\\n        }else if(k>0){\\n            for(int i=0; i<arr.length; i++){\\n                op[i]=sum-arr[i]+arr[(i+k)%arr.length];\\n                sum=op[i];\\n            }\\n        }else{\\n            k=k*-1;\\n            for(int i=0; i<arr.length; i++){\\n                sum=0;\\n                for(int j=1; j<=k; j++){\\n                    sum+=arr[(arr.length-j+i)%arr.length];\\n                }\\n                op[i]=sum;\\n            }\\n        }\\n        \\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552363,
                "title": "java-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[] = new int[code.length];\\n        int sum = 0;\\n        if(k<0){            \\n            for(int i=code.length-2;i>=code.length-1+k;i--){\\n                sum += code[i];\\n            }\\n            ans[code.length-1] = sum;\\n            for(int i = code.length-2;i>=0;i--){\\n                int index = i+k < 0 ? code.length+(i+k) : i+k;                \\n                ans[i] = ans[i+1]-code[i]+code[index];\\n            }\\n        }else if(k>0){            \\n            for(int i=1;i<=k;i++){\\n                sum += code[i];\\n            }\\n            ans[0] = sum;\\n            for(int i=1;i<code.length;i++){\\n                int index = i+k>=code.length?i+k-code.length : i+k;\\n                ans[i] = ans[i-1]-code[i]+code[index];\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[] = new int[code.length];\\n        int sum = 0;\\n        if(k<0){            \\n            for(int i=code.length-2;i>=code.length-1+k;i--){\\n                sum += code[i];\\n            }\\n            ans[code.length-1] = sum;\\n            for(int i = code.length-2;i>=0;i--){\\n                int index = i+k < 0 ? code.length+(i+k) : i+k;                \\n                ans[i] = ans[i+1]-code[i]+code[index];\\n            }\\n        }else if(k>0){            \\n            for(int i=1;i<=k;i++){\\n                sum += code[i];\\n            }\\n            ans[0] = sum;\\n            for(int i=1;i<code.length;i++){\\n                int index = i+k>=code.length?i+k-code.length : i+k;\\n                ans[i] = ans[i-1]-code[i]+code[index];\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1743482,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 2043876,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 1913659,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 1734530,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Deletions to Make String Balanced",
        "question_content": "<p>You are given a string <code>s</code> consisting only of characters <code>&#39;a&#39;</code> and <code>&#39;b&#39;</code>​​​​.</p>\n\n<p>You can delete any number of characters in <code>s</code> to make <code>s</code> <strong>balanced</strong>. <code>s</code> is <strong>balanced</strong> if there is no pair of indices <code>(i,j)</code> such that <code>i &lt; j</code> and <code>s[i] = &#39;b&#39;</code> and <code>s[j]= &#39;a&#39;</code>.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of deletions needed to make </em><code>s</code><em> <strong>balanced</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aababbab&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You can either:\nDelete the characters at 0-indexed positions 2 and 6 (&quot;aa<u>b</u>abb<u>a</u>b&quot; -&gt; &quot;aaabbb&quot;), or\nDelete the characters at 0-indexed positions 3 and 6 (&quot;aab<u>a</u>bb<u>a</u>b&quot; -&gt; &quot;aabbbb&quot;).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bbaaaaabb&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The only solution is to delete the first two characters.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is&nbsp;<code>&#39;a&#39;</code> or <code>&#39;b&#39;</code>​​.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 935701,
                "title": "dp-solution-beats-100-with-explanation",
                "content": "\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n\\t\\t//dp stores number of chars to remove to make s.substring(0, i) valid\\n        int[] dp = new int[l + 1];\\n        int bcount = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                //case 1: keep current a. ==> prev chars must be a...a\\n                //so need to remove all \\'b\\' chars before i, which is bcount\\n                \\n                //case 2: remove current a ==> prev chars must be a...ab...b\\n                //so need to remove current a and whatever makes substring before current i valid which is dp[i];\\n                dp[i + 1] = Math.min(dp[i] + 1, bcount);\\n            } else {\\n                //since it is always valid to append \\'b\\' if substring before current i is valid, so just copy whatever makes substring before i valid which is dp[i];\\n                dp[i + 1] = dp[i];\\n                bcount++;\\n            }\\n        }\\n        \\n        return dp[l];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n\\t\\t//dp stores number of chars to remove to make s.substring(0, i) valid\\n        int[] dp = new int[l + 1];\\n        int bcount = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                //case 1: keep current a. ==> prev chars must be a...a\\n                //so need to remove all \\'b\\' chars before i, which is bcount\\n                \\n                //case 2: remove current a ==> prev chars must be a...ab...b\\n                //so need to remove current a and whatever makes substring before current i valid which is dp[i];\\n                dp[i + 1] = Math.min(dp[i] + 1, bcount);\\n            } else {\\n                //since it is always valid to append \\'b\\' if substring before current i is valid, so just copy whatever makes substring before i valid which is dp[i];\\n                dp[i + 1] = dp[i];\\n                bcount++;\\n            }\\n        }\\n        \\n        return dp[l];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997750,
                "title": "6-different-approaches-from-basic-to-the-most-optimal-c",
                "content": "Approach 1: Three passes with space O(n)\\nIn the first pass, we compute vector \"b\" which stores the count of character \\'b\\'. \\nIn the second pass, we compute vector \"a\" which stores the count of character \\'a\\'.\\nIn the third pass, we iterate through the string s. \\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        vector<int> b(n,0);\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            b[i]=c;\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        for(int i=0;i<n;i++) ans=min(ans,a[i]+b[i]);\\n        return ans;\\n        \\n    }\\n\\nApproach2: Two passes with space O(n)\\nWe compute vector a, and instead of computing vector b, we do the processing while iterating through the string itself.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        int c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(a[i]+c,ans);\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        return ans;\\n    }\\n\\nApproach 3: Two passes with space O(1).\\nInstead of using vector a and b, we use two variables count_a and count_b.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        //get the count of a\\'s in the first pass\\n        int count_a=0;\\n        for(int i=0;i<n;i++) if (s[i]==\\'a\\') count_a++;\\n        int count_b=0;\\n        int ans=n;\\n        //second pass\\n        //as you iterate through the string count b\\n        for(int i=0;i<n;i++)\\n        {\\n            if (s[i]==\\'a\\') count_a--;\\n            ans=min(ans,count_a+count_b);\\n            if (s[i]==\\'b\\') count_b++;\\n        }\\n        return ans;\\n        \\n    }\\n\\nApproach 4: Using stack(one pass and space O(n))\\n\\nIf we delete all occurrences of \"ba\", then we can get the desired string. We use stack for that.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        stack<char> stk;\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if (!stk.empty() && stk.top()==\\'b\\' && s[i]==\\'a\\')\\n                stk.pop(),c++;\\n            else stk.push(s[i]);\\n        }\\n        return c;\\n    }\\n\\nApproach 5: Using DP approach: one pass with space O(n)\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,0);\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') dp[i+1]=dp[i],count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                dp[i+1]=min(dp[i]+1,count_b);\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n\\nApproach 6: \\n\\nOne pass space O(1)\\nimprovisation on the approach 5\\n\\nNote that in the dp approach, to obtain the value of dp[i+1], we only need dp[i], and not dp[0]...dp[i-1]\\nHence, instead of dp array, we can also use a variable called ans to store dp[i].\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        //corresponingly ans variable represents dp[i]\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                ans=min(ans+1,count_b);\\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "Approach 1: Three passes with space O(n)\\nIn the first pass, we compute vector \"b\" which stores the count of character \\'b\\'. \\nIn the second pass, we compute vector \"a\" which stores the count of character \\'a\\'.\\nIn the third pass, we iterate through the string s. \\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        vector<int> b(n,0);\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            b[i]=c;\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        for(int i=0;i<n;i++) ans=min(ans,a[i]+b[i]);\\n        return ans;\\n        \\n    }\\n\\nApproach2: Two passes with space O(n)\\nWe compute vector a, and instead of computing vector b, we do the processing while iterating through the string itself.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        int c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(a[i]+c,ans);\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        return ans;\\n    }\\n\\nApproach 3: Two passes with space O(1).\\nInstead of using vector a and b, we use two variables count_a and count_b.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        //get the count of a\\'s in the first pass\\n        int count_a=0;\\n        for(int i=0;i<n;i++) if (s[i]==\\'a\\') count_a++;\\n        int count_b=0;\\n        int ans=n;\\n        //second pass\\n        //as you iterate through the string count b\\n        for(int i=0;i<n;i++)\\n        {\\n            if (s[i]==\\'a\\') count_a--;\\n            ans=min(ans,count_a+count_b);\\n            if (s[i]==\\'b\\') count_b++;\\n        }\\n        return ans;\\n        \\n    }\\n\\nApproach 4: Using stack(one pass and space O(n))\\n\\nIf we delete all occurrences of \"ba\", then we can get the desired string. We use stack for that.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        stack<char> stk;\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if (!stk.empty() && stk.top()==\\'b\\' && s[i]==\\'a\\')\\n                stk.pop(),c++;\\n            else stk.push(s[i]);\\n        }\\n        return c;\\n    }\\n\\nApproach 5: Using DP approach: one pass with space O(n)\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,0);\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') dp[i+1]=dp[i],count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                dp[i+1]=min(dp[i]+1,count_b);\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n\\nApproach 6: \\n\\nOne pass space O(1)\\nimprovisation on the approach 5\\n\\nNote that in the dp approach, to obtain the value of dp[i+1], we only need dp[i], and not dp[0]...dp[i-1]\\nHence, instead of dp array, we can also use a variable called ans to store dp[i].\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        //corresponingly ans variable represents dp[i]\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                ans=min(ans+1,count_b);\\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 935373,
                "title": "c-stack-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //Idea is to traverse from right to left & use stack to keep track if \\'b\\' comes before \\'a\\' in string\\n    //then we need to pop & need to delete that character\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int n =s.size();\\n        int res = 0;\\n        \\n        for(int i = n-1; i >=0; i--){\\n            char c = s[i];\\n            if(!st.empty() && st.top() < c){\\n                res++;\\n                st.pop();\\n            }else{\\n                st.push(c);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Idea is to traverse from right to left & use stack to keep track if \\'b\\' comes before \\'a\\' in string\\n    //then we need to pop & need to delete that character\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int n =s.size();\\n        int res = 0;\\n        \\n        for(int i = n-1; i >=0; i--){\\n            char c = s[i];\\n            if(!st.empty() && st.top() < c){\\n                res++;\\n                st.pop();\\n            }else{\\n                st.push(c);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936436,
                "title": "java-python-3-two-codes-1-pass-and-2-passes-w-brief-explanation-and-analysis",
                "content": "**Method 1: Use stack to cancel bad pairs**\\n\\nWhenever encounter a pair of `\"ba\"`, cancel both of them and count the number of cancellations; \\nWhy this works? \\nWhether delete `a` or `b` depending on the the character right after the last cancellation is `a` or `b`; If `a`, we have to delete `b`\\'s in all cancellations, otherwise delete either `a`\\'s or `b`\\'s. Therefore, we are sure there is no `ba` in the string.\\n\\n\\n**Q & A:**\\n\\nQ1: For this approach, it seems to be that it is more of `finding the number of deletions` rather than the `minimum` number of deletions. is there a proof that using a stack and cancelling bad pairs would lead us to the minimum deletions rather than just finding the number of deletions?\\nA1: All indices of character(s) inside stack are less than that  of those outside. Therefore, whenever we find a `\\'b\\'` inside and a `\\'a\\'` outside of the stack, we have to delete 1 (either `\\'a\\'` or `\\'b\\'`) to make the string balanced. In short, if there are total n bad pairs, then there must be n `\\'b\\'`\\'s in front of n `\\'a\\'`\\'s, and the n is the minimum deletions.\\n\\n**End of Q & A**.\\n\\n```java\\n    public int minimumDeletions(String s) {\\n        int cnt = 0;\\n        Deque<Character> stk = new ArrayDeque<>();\\n        for (char c : s.toCharArray()) {\\n            if (!stk.isEmpty() && stk.peek() == \\'b\\' && c == \\'a\\') {\\n                stk.pop();\\n                ++cnt;\\n            }else {\\n                stk.push(c);\\n            }\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        cnt, stack = 0, []\\n        for c in s:\\n            if stack and stack[-1] == \\'b\\' and c == \\'a\\':\\n                stack.pop()\\n                cnt += 1\\n            else:\\n                stack.append(c)\\n        return cnt\\n```\\n**Analysis:**\\n\\nTime & space: O(n), n = s.length().\\n\\n----\\n\\n**Method 2: Two passes with space O(1).**\\n\\nCount the total occurrences of `\\'a\\'` on the right and `\\'b\\'` on the left for each index, find the mininum;\\n\\n```java\\n    public int minimumDeletions(String s) {\\n        int a = s.chars().map(i -> i == \\'a\\' ? 1 : 0).sum();\\n        int cnt = a, b = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'b\\') {\\n                cnt = Math.min(cnt, a + b++);\\n            }else {\\n                --a;\\n            }\\n        }\\n        return Math.min(cnt, b);\\n    }\\n```\\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        a, b, cnt = s.count(\\'a\\'), 0, len(s)\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt = min(cnt, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(cnt, b)\\n```\\n**Analysis:**\\n\\nTime: O(n), space: O(1), n = s.length().\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minimumDeletions(String s) {\\n        int cnt = 0;\\n        Deque<Character> stk = new ArrayDeque<>();\\n        for (char c : s.toCharArray()) {\\n            if (!stk.isEmpty() && stk.peek() == \\'b\\' && c == \\'a\\') {\\n                stk.pop();\\n                ++cnt;\\n            }else {\\n                stk.push(c);\\n            }\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        cnt, stack = 0, []\\n        for c in s:\\n            if stack and stack[-1] == \\'b\\' and c == \\'a\\':\\n                stack.pop()\\n                cnt += 1\\n            else:\\n                stack.append(c)\\n        return cnt\\n```\n```java\\n    public int minimumDeletions(String s) {\\n        int a = s.chars().map(i -> i == \\'a\\' ? 1 : 0).sum();\\n        int cnt = a, b = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'b\\') {\\n                cnt = Math.min(cnt, a + b++);\\n            }else {\\n                --a;\\n            }\\n        }\\n        return Math.min(cnt, b);\\n    }\\n```\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        a, b, cnt = s.count(\\'a\\'), 0, len(s)\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt = min(cnt, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(cnt, b)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935464,
                "title": "python-dp-o-n-short-with-explanation",
                "content": "```\\ndef minimumDeletions(self, s: str) -> int:\\n        cnt_b = 0\\n        dp = [0]\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt_b+=1\\n                dp.append( dp[-1] )\\n            else:\\n                dp.append( min(cnt_b,dp[-1]+1) )\\n        return dp[-1]\\n```\\nThe problem can be formulated as DP.\\n\\nAt every point when you see  \\'a\\' , you have 2 options, \\n1. remove all the b\\'s you found earlier.  --> total cost = count_of_b\\nOR\\n2. delete the current \\'a\\'. --> total cost = cur_total_cost + 1\\n\\nIf u see a \\'b\\' , then no more cost.\\n\\nThus maintain the count of \\'b\\'s you found. \\n\\nPlease Upvote!",
                "solutionTags": [],
                "code": "```\\ndef minimumDeletions(self, s: str) -> int:\\n        cnt_b = 0\\n        dp = [0]\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt_b+=1\\n                dp.append( dp[-1] )\\n            else:\\n                dp.append( min(cnt_b,dp[-1]+1) )\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935372,
                "title": "c-find-split-location-simple-o-n-time-o-1-mem",
                "content": "My intuition for this problem is to keep track of the extra As and Bs to the right and left of each position and find the position with the minimun extra letters. \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int as = 0, bs = 0;\\n        for( const char& c : s )\\n            if( c == \\'a\\' )\\n                ++as;\\n        \\n        int del = as;\\n        for( const char& c : s )\\n        {\\n            if( c == \\'b\\' )\\n                ++bs;\\n            else\\n                --as;\\n            \\n            del = min( del, (as+bs) );\\n        }\\n        return del;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int as = 0, bs = 0;\\n        for( const char& c : s )\\n            if( c == \\'a\\' )\\n                ++as;\\n        \\n        int del = as;\\n        for( const char& c : s )\\n        {\\n            if( c == \\'b\\' )\\n                ++bs;\\n            else\\n                --as;\\n            \\n            del = min( del, (as+bs) );\\n        }\\n        return del;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935422,
                "title": "python-greedy-iterate-from-the-back",
                "content": "Refer to @wareag1e in the comment, the explanation is way better there.\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        a = 0\\n        res = 0\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == \\'a\\':\\n                a += 1\\n            elif s[i] == \\'b\\':\\n                if a > 0:\\n                    a -= 1\\n                    res += 1\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        a = 0\\n        res = 0\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == \\'a\\':\\n                a += 1\\n            elif s[i] == \\'b\\':\\n                if a > 0:\\n                    a -= 1\\n                    res += 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 935399,
                "title": "c-minimalism-o-n",
                "content": "#### Approach 1: Find the split point\\n```cpp\\nint minimumDeletions(string s) {\\n    int a = count(begin(s), end(s), \\'a\\'), b = 0, res = a;\\n    for (auto ch : s) {\\n        b += ch == \\'b\\';\\n        a -= ch == \\'a\\';\\n        res = min(res, b + a);\\n    }\\n    return res;\\n}\\n```\\n\\n#### Approach 2: Simulation\\nWe count the total number of \\'a\\' and \\'b\\'. Then, we \"eat\" all \\'a\\' from the left, and all \\'b\\' from the right.\\n\\nNow, we are at the decision point - do we remove from left of right?\\n\\nIt seems that greedy got accepted - we remove the charracter with the smaller count - but I am still thinking of the proof.\\n\\n```cpp\\nint minimumDeletions(string s) {\\n    int a = 0, b = 0, l = 0, r = s.size() - 1, res = 0;\\n    for (auto ch : s) {\\n        a += ch == \\'a\\'; \\n        b += ch == \\'b\\';\\n    }\\n    while (l < r) {\\n        if (a && s[l] == \\'a\\') {\\n            ++l;\\n            --a;\\n        }\\n        else if (b && s[r] == \\'b\\') {\\n            --r;\\n            --b;\\n        }\\n        else {\\n            ++res;\\n            if (a < b) {\\n                --a;\\n                --r;\\n            }\\n            else {\\n                --b;\\n                ++l;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minimumDeletions(string s) {\\n    int a = count(begin(s), end(s), \\'a\\'), b = 0, res = a;\\n    for (auto ch : s) {\\n        b += ch == \\'b\\';\\n        a -= ch == \\'a\\';\\n        res = min(res, b + a);\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint minimumDeletions(string s) {\\n    int a = 0, b = 0, l = 0, r = s.size() - 1, res = 0;\\n    for (auto ch : s) {\\n        a += ch == \\'a\\'; \\n        b += ch == \\'b\\';\\n    }\\n    while (l < r) {\\n        if (a && s[l] == \\'a\\') {\\n            ++l;\\n            --a;\\n        }\\n        else if (b && s[r] == \\'b\\') {\\n            --r;\\n            --b;\\n        }\\n        else {\\n            ++res;\\n            if (a < b) {\\n                --a;\\n                --r;\\n            }\\n            else {\\n                --b;\\n                ++l;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038781,
                "title": "simple-python-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        result = 0\\n        b_count = 0\\n        \\n        for c in s:\\n            if c == \"a\":\\n                result = min(b_count, result + 1)\\n            else:\\n                b_count += 1\\n        \\n        return result\\n```\\n\\nAt every point in our traversal, if we encounter an \"a\", we can either delete every \"b\" up to that point, or we can delete that one \"a\".\\n\\n```result``` keeps a running total of the number of deletions we have made so far to keep the string up until the current point balanced.\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        result = 0\\n        b_count = 0\\n        \\n        for c in s:\\n            if c == \"a\":\\n                result = min(b_count, result + 1)\\n            else:\\n                b_count += 1\\n        \\n        return result\\n```\n```result```",
                "codeTag": "Java"
            },
            {
                "id": 1020107,
                "title": "python-dp-solution-easy-to-understand",
                "content": "* O(n) for loop each character of the string s\\n* Track the minimum number of deletions to make a balanced string till current character, either ending with \\'a\\' or \\'b\\'.\\n* In the end, find the min of these two numbers\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        # track the minimum number of deletions to make the current string balanced ending with \\'a\\', \\'b\\'\\n        end_a, end_b = 0,0 \\n        for val in s:\\n            if val == \\'a\\':\\n                # to end with \\'a\\', nothing to do with previous ending with \\'a\\'\\n                # to end with \\'b\\', need to delete the current \\'a\\' from previous ending with \\'b\\'\\n                end_b += 1\\n            else:\\n                # to end with \\'a\\', need to delete the current \\'b\\' from previous ending with \\'a\\'\\n                # to end with \\'b\\', nothing to do, so just pick smaller of end_a, end_b\\n                end_a, end_b = end_a+1, min(end_a, end_b)\\n        return min(end_a, end_b)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        # track the minimum number of deletions to make the current string balanced ending with \\'a\\', \\'b\\'\\n        end_a, end_b = 0,0 \\n        for val in s:\\n            if val == \\'a\\':\\n                # to end with \\'a\\', nothing to do with previous ending with \\'a\\'\\n                # to end with \\'b\\', need to delete the current \\'a\\' from previous ending with \\'b\\'\\n                end_b += 1\\n            else:\\n                # to end with \\'a\\', need to delete the current \\'b\\' from previous ending with \\'a\\'\\n                # to end with \\'b\\', nothing to do, so just pick smaller of end_a, end_b\\n                end_a, end_b = end_a+1, min(end_a, end_b)\\n        return min(end_a, end_b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935481,
                "title": "java-dp-17-ms-faster-than-100-00-39-7-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int dp = 0, cntb = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'a\\') dp = Math.min(dp + 1, cntb);\\n            else ++cntb;\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int dp = 0, cntb = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'a\\') dp = Math.min(dp + 1, cntb);\\n            else ++cntb;\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878367,
                "title": "java-simple-and-easy-to-understand-with-comments-o-n-time",
                "content": "The whole problem boils down to the positions of A and B (using A and B instead of \\'a\\' and \\'b\\' so its easier to read and understand). All is good until all the As are before the Bs. It is balanced. It becomes a problem when As appears after Bs.\\n\\nTo solve it, start going through the string, char by char, and keep a count of the Bs (increment it). Once you have your Bs, then if an A appears, then you have to cut down a A for every B (decrement it) only if the count of B is greater than 0. You also need to track the number of decrements of Bs counts (total number of removals).\\n\\nConsider this string - aabbabb\\n\\nAll is well and good until its index = 4 (\\'a\\'). Now the countB = 2, decrement it (becomes 1), and increment the removal (becomes 1).\\n\\n```\\npublic static int minimumDeletions(String s) {\\n\\n        if (s == null || s.isEmpty()) return 0;\\n\\n        int countB = 0; //keep a count of Bs\\n        int removals = 0; //keep a count of removed As\\n\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            if (s.charAt(i) == \\'a\\') {\\n                if (countB > 0) { // only if there are Bs before this A\\n                    ++removals; // remove this A\\n                    --countB; // and decrement the Bs count\\n                }\\n            } else {\\n                ++countB; // keep incrementing the Bs count\\n            }\\n        }\\n       return removals;\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int minimumDeletions(String s) {\\n\\n        if (s == null || s.isEmpty()) return 0;\\n\\n        int countB = 0; //keep a count of Bs\\n        int removals = 0; //keep a count of removed As\\n\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            if (s.charAt(i) == \\'a\\') {\\n                if (countB > 0) { // only if there are Bs before this A\\n                    ++removals; // remove this A\\n                    --countB; // and decrement the Bs count\\n                }\\n            } else {\\n                ++countB; // keep incrementing the Bs count\\n            }\\n        }\\n       return removals;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 943968,
                "title": "java-dp-accepted-explanation",
                "content": "**We use Dynamic programming approach because for each substring we need to consider all cases !**\\n\\nFor the sake of explanation:\\n1. we iterate from left->right\\n2. we consider ideal case for us as \"bbbbbbbbbbbbbbb.......bbb\"\\n\\nWe move from left->right and so we consider the ideal case as all b\\'s because any number of b\\'s is valid as move from left->right(with no a\\'s in between).\\n\\nSo we consider \\'b\\' as our friendly character and \\'a\\' as our enemy .\\n\\n**So whenever we see a \\'b\\' we just increase the bCount by one and our answer for that particular substring(0..i) is dp[idx-1].**\\n\\n**But if we see an \\'a\\' then we need to take into consideration 2 cases :**\\n\\n**case 1:** keep current a. ==> prev chars must be a...a , so need to remove all \\'b\\' chars before i, which is bcount\\n                \\n **case 2:** remove current a ==> prev chars must be a...ab...b, so need to remove current a and whatever makes substring before current i valid which is dp[idx-1]+1;\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        //ideal case :  bbbbbbbbb\\n        int[] dp =  new int[s.length()+1];\\n        int idx =1;\\n        int bCount=0;\\n        \\n        for(int i =0 ;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'a\\')\\n            {\\n             dp[idx] = Math.min(dp[idx-1]+1,bCount);   \\n            }\\n            else\\n            {\\n                dp[idx]=dp[idx-1];\\n                bCount++;\\n            }\\n            \\n            idx++;\\n        }\\n        return dp[s.length()];\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        //ideal case :  bbbbbbbbb\\n        int[] dp =  new int[s.length()+1];\\n        int idx =1;\\n        int bCount=0;\\n        \\n        for(int i =0 ;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'a\\')\\n            {\\n             dp[idx] = Math.min(dp[idx-1]+1,bCount);   \\n            }\\n            else\\n            {\\n                dp[idx]=dp[idx-1];\\n                bCount++;\\n            }\\n            \\n            idx++;\\n        }\\n        return dp[s.length()];\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912995,
                "title": "python-easy-to-read-and-understand-stack",
                "content": "**Count the total number of ba pairs**\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack, res = [], 0\\n        for i in range(len(s)):\\n            if stack and s[i] == \"a\" and stack[-1] == \"b\":\\n                stack.pop()\\n                res += 1\\n            else:\\n                stack.append(s[i])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "**Count the total number of ba pairs**\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack, res = [], 0\\n        for i in range(len(s)):\\n            if stack and s[i] == \"a\" and stack[-1] == \"b\":\\n                stack.pop()\\n                res += 1\\n            else:\\n                stack.append(s[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1025601,
                "title": "c-o-n-time-complexity-and-o-1-space",
                "content": "Greedy. Use bCnt to record count for preserved b (have no way to be replaced by a) up till now, use res to record deletion count.  \\n\\nTraverse string s, for each char ch:\\n(1) If it\\'s b, we don\\'t know whether to delete it or not, only increase bCnt by 1. \\n(2) If it\\'s a, we will make deletion only when bCnt is > 0, which means there\\'re b preserved before and has no way to be replaced by traversed a. We might delete current a, or delete previous b, but we don\\'t know yet since this is decided by furture remainig chars. But no matter what we delete, the deletion cnt res will always increase by 1. Use the greedy idea, even if we delete current a, still decrease bCnt by 1 to indicate this b can be replaced by a if later we need it to be replaced\\n\\neg1. aabba\\naabb -> res = 0, bCnt = 2; \\naabba -> res = 1, bCnt = 1; \\nans: aabb\\n\\neg2. aabbaaa\\naabb -> res = 0, bCnt = 2; \\naabba -> res = 1, bCnt = 1 (aabb, or aaba)\\naabbaa -> res = 2, bCnt = 0 (aabb, or aaaa)\\naabbaaa -> res = 2, bCnt = 0 (aaaaa)\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCnt = 0;\\n        int res = 0;\\n        for (char& ch : s) {\\n            if (ch == \\'a\\' && bCnt > 0) {\\n                bCnt--;\\n                res++;\\n            }\\n            if (ch == \\'b\\') {\\n                bCnt++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCnt = 0;\\n        int res = 0;\\n        for (char& ch : s) {\\n            if (ch == \\'a\\' && bCnt > 0) {\\n                bCnt--;\\n                res++;\\n            }\\n            if (ch == \\'b\\') {\\n                bCnt++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948123,
                "title": "simple-c-solution-beats-90",
                "content": "The idea is really simple; you basically count the number of \\'a\\' characters in the string, and then iterate over the string to count the number of \\'b\\' characters. The sum of these 2 values at a given index is the number of deletions you need to make in order to balance the string. \\n\\nFrom there you simply return the minimum sum (deleteCount);\\n\\n```cpp\\nclass Solution {\\n    public:\\n        int minimumDeletions(string s) {\\n            int rightA = 0;\\n            int leftB = 0;\\n\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\'){\\n                    rightA += 1;\\n                }\\n            }\\n\\n            int deleteCount = leftB + rightA;\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\') {\\n                    rightA -= 1;\\n                } else {\\n                    leftB += 1;\\n                }\\n                \\n                if (leftB + rightA < deleteCount){\\n                    deleteCount = leftB + rightA;\\n                }\\n            }\\n            return deleteCount;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\n    public:\\n        int minimumDeletions(string s) {\\n            int rightA = 0;\\n            int leftB = 0;\\n\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\'){\\n                    rightA += 1;\\n                }\\n            }\\n\\n            int deleteCount = leftB + rightA;\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\') {\\n                    rightA -= 1;\\n                } else {\\n                    leftB += 1;\\n                }\\n                \\n                if (leftB + rightA < deleteCount){\\n                    deleteCount = leftB + rightA;\\n                }\\n            }\\n            return deleteCount;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510493,
                "title": "c-explained-intuitive-approach",
                "content": "My approach without using DP.\\n\\nThe resultant string must have all `a\\'s` to left and all `b\\'s` to the right.\\n\\n*  Count for every index, `number of b\\'s to there left` call it as array `bvec`\\n*  Count for every index, `number of a\\'s to there right`call it as array `avec`\\n*  Now, to remove all `b` from left and all `a` from right we need one index from which it will be minimum.\\n*  Therefore, we will traverse both the array and find the minimum `bvec[i] + avec[i]` for some `i` where `0 <= i < n`\\n\\nCode : \\n```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n = s.length();\\n        vector<int> bvec(n);\\n        vector<int> avec(n);\\n        \\n        int cnt = 0;\\n        // generate array for every index number of b\\'s to there left\\n        for(int i = 0; i < n; i++){\\n            bvec[i] = cnt;\\n            if(s[i] == \\'b\\'){\\n                cnt++;\\n            }\\n        }\\n        cnt = 0;\\n        // generate array for every index number of a\\'s to there right\\n        for(int i = n - 1; i >= 0; i--){\\n            avec[i] = cnt;\\n            if(s[i] == \\'a\\'){\\n                cnt++;\\n            }\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            mini = min(mini, bvec[i] + avec[i]);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n = s.length();\\n        vector<int> bvec(n);\\n        vector<int> avec(n);\\n        \\n        int cnt = 0;\\n        // generate array for every index number of b\\'s to there left\\n        for(int i = 0; i < n; i++){\\n            bvec[i] = cnt;\\n            if(s[i] == \\'b\\'){\\n                cnt++;\\n            }\\n        }\\n        cnt = 0;\\n        // generate array for every index number of a\\'s to there right\\n        for(int i = n - 1; i >= 0; i--){\\n            avec[i] = cnt;\\n            if(s[i] == \\'a\\'){\\n                cnt++;\\n            }\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            mini = min(mini, bvec[i] + avec[i]);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935616,
                "title": "easy-to-understand-solutions-with-optimization",
                "content": "To begin with, we can think about that **if we want to obtain the min deletion, what we can do?** For each index, if we find a pair that is not banlanced, we must do 2 things to make it banlanced:\\n\\n**1. Delete all \\'b\\'s before this index**\\n\\t**2. Delete all \\'a\\'s on and after this index**\\n\\nThen we can compare those **sums of deleting times** to find the min.\\n\\nSo, we can use 2 array, *aSum* represents **how many \\'a\\'s on its right**, *bSum* represents **how many \\'b\\'s on its left**.\\n```\\npublic int minimumDeletions(String s) {\\n\\tint length = s.length(), aSum[] = new int[length], bSum[] = new int[length], curMin = Integer.MAX_VALUE;\\n\\tfor (int i = length - 1; i >= 0; i--) {\\n\\t\\taSum[i] = (i < length - 1 ? aSum[i + 1] : 0) + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tbSum[i] = (i > 0 ? bSum[i - 1] : 0) + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length + 1; i++) {\\n\\t\\tcurMin = Math.min(curMin, (i > 0 ? bSum[i - 1] : 0) + (i == length ? 0 : aSum[i]));\\n\\t}\\n\\treturn curMin;\\n}\\n```\\n\\nWe also notice that each element in *aSum* and *bSum* is only use once, so **we can change that 2 arrays to 2 variables**:\\n```\\npublic int minimumDeletions(String s) {\\n\\tint aSum = 0, bSum = 0; \\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (c == \\'a\\')\\n\\t\\t\\taSum += 1;\\n\\t\\telse {\\n\\t\\t\\taSum = Math.min(aSum, bSum);\\n\\t\\t\\tbSum += 1;\\n\\t\\t}\\n\\t}\\n\\treturn Math.min(aSum, bSum);\\n}\\n```\\n\\n**Now we can see the space complexity reduce from O(n) to O(1).**\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int minimumDeletions(String s) {\\n\\tint length = s.length(), aSum[] = new int[length], bSum[] = new int[length], curMin = Integer.MAX_VALUE;\\n\\tfor (int i = length - 1; i >= 0; i--) {\\n\\t\\taSum[i] = (i < length - 1 ? aSum[i + 1] : 0) + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tbSum[i] = (i > 0 ? bSum[i - 1] : 0) + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length + 1; i++) {\\n\\t\\tcurMin = Math.min(curMin, (i > 0 ? bSum[i - 1] : 0) + (i == length ? 0 : aSum[i]));\\n\\t}\\n\\treturn curMin;\\n}\\n```\n```\\npublic int minimumDeletions(String s) {\\n\\tint aSum = 0, bSum = 0; \\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (c == \\'a\\')\\n\\t\\t\\taSum += 1;\\n\\t\\telse {\\n\\t\\t\\taSum = Math.min(aSum, bSum);\\n\\t\\t\\tbSum += 1;\\n\\t\\t}\\n\\t}\\n\\treturn Math.min(aSum, bSum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1189982,
                "title": "top-down-dp-and-greedy-solution-c",
                "content": "### Top Down Dynamic Programming\\n\\n182 ms\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[100001][2];\\n    \\n    int getMinDeletions(string& s, bool bPrev = false, int current = 0) {\\n        if(current >= s.size()) return 0;\\n        if(dp[current][(int)bPrev]) return dp[current][(int)bPrev];\\n        char ch = s[current];\\n        if(ch == \\'a\\' && bPrev) { // Delete the current a\\n            dp[current][(int)bPrev] = 1 + getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(bPrev) { // Continue since current is b\\n            dp[current][(int)bPrev] =  getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(ch == \\'a\\') { // If no b before and current a\\n            dp[current][(int)bPrev] = getMinDeletions(s,false,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        // Current is b\\n        dp[current][(int)bPrev] = min(getMinDeletions(s,true,current+1), 1 + getMinDeletions(s,false,current+1));\\n        return dp[current][(int)bPrev];\\n    }\\n    \\n    int minimumDeletions(string s) {\\n        memset(dp,0,sizeof(dp));\\n        return getMinDeletions(s);\\n    }\\n};\\n```\\n\\n### Greedy Approach\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    int minimumDeletions(string s) {\\n        int prefA[s.size()+1];\\n        int prefB[s.size()+1];\\n        memset(prefA, 0, sizeof(prefA));\\n        memset(prefB, 0, sizeof(prefB));\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            prefA[i+1] = prefA[i] + (s[i] == \\'a\\' ? 1 : 0);\\n            prefB[i+1] = prefB[i] + (s[i] == \\'b\\' ? 1 : 0);\\n        }\\n        \\n        int minMoves = INT_MAX;\\n        \\n        for(int i=0; i<=s.size(); i++) {\\n            minMoves = min(minMoves, prefB[i] + (prefA[s.size()] - prefA[i]));\\n        }\\n        \\n        return minMoves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[100001][2];\\n    \\n    int getMinDeletions(string& s, bool bPrev = false, int current = 0) {\\n        if(current >= s.size()) return 0;\\n        if(dp[current][(int)bPrev]) return dp[current][(int)bPrev];\\n        char ch = s[current];\\n        if(ch == \\'a\\' && bPrev) { // Delete the current a\\n            dp[current][(int)bPrev] = 1 + getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(bPrev) { // Continue since current is b\\n            dp[current][(int)bPrev] =  getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(ch == \\'a\\') { // If no b before and current a\\n            dp[current][(int)bPrev] = getMinDeletions(s,false,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        // Current is b\\n        dp[current][(int)bPrev] = min(getMinDeletions(s,true,current+1), 1 + getMinDeletions(s,false,current+1));\\n        return dp[current][(int)bPrev];\\n    }\\n    \\n    int minimumDeletions(string s) {\\n        memset(dp,0,sizeof(dp));\\n        return getMinDeletions(s);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    int minimumDeletions(string s) {\\n        int prefA[s.size()+1];\\n        int prefB[s.size()+1];\\n        memset(prefA, 0, sizeof(prefA));\\n        memset(prefB, 0, sizeof(prefB));\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            prefA[i+1] = prefA[i] + (s[i] == \\'a\\' ? 1 : 0);\\n            prefB[i+1] = prefB[i] + (s[i] == \\'b\\' ? 1 : 0);\\n        }\\n        \\n        int minMoves = INT_MAX;\\n        \\n        for(int i=0; i<=s.size(); i++) {\\n            minMoves = min(minMoves, prefB[i] + (prefA[s.size()] - prefA[i]));\\n        }\\n        \\n        return minMoves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935410,
                "title": "java-get-number-of-a-from-left-and-b-from-right-o-n-time-and-o-n-space",
                "content": "Maintain number of `a` from left and number of `b` from right. Can be solved in `O(1)` space. Here is `O(N)` space solution\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int[] counts = new int[n + 1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            counts[i] = counts[i + 1];\\n            if (s.charAt(i) == \\'a\\') {\\n                counts[i]++;\\n            }\\n        }\\n        \\n        int counter = 0;\\n        int answer = counts[0];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == \\'b\\') counter++;\\n            answer = Math.min(answer, counter + counts[i + 1]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int[] counts = new int[n + 1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            counts[i] = counts[i + 1];\\n            if (s.charAt(i) == \\'a\\') {\\n                counts[i]++;\\n            }\\n        }\\n        \\n        int counter = 0;\\n        int answer = counts[0];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == \\'b\\') counter++;\\n            answer = Math.min(answer, counter + counts[i + 1]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819350,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n            int countb=0;\\n    int ans=0;\\n    for(auto i:s)\\n    {\\n        if(i==\\'b\\'){countb++;}\\n        if(i==\\'a\\' && countb>0){ans++;countb--;}\\n    }\\n    \\n    return ans;\\n}\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n            int countb=0;\\n    int ans=0;\\n    for(auto i:s)\\n    {\\n        if(i==\\'b\\'){countb++;}\\n        if(i==\\'a\\' && countb>0){ans++;countb--;}\\n    }\\n    \\n    return ans;\\n}\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848583,
                "title": "easy-c-solution-fully-explained",
                "content": "**THE PROBLEM CAN BE EASILY SOLVED JUST WITH THE HELP OF OBSERVATION**\\n\\nLET US TAKE A VERY SIMPLE EXAMPLE\\n\\n**STRING  S = \"A A A B A A\"**\\n\\nWE CAN EASILY SAY THAT THE ANSWER IS 1, BUT HOW DO WE ACHIEVE THAT\\n\\nSIMPLEE, **WE CONSIDER EVERY POINT AS BALANCING POINT**\\n\\n1) *ON THE LEFT OF BALANCING POINT EVEYTHING SHOULD BE \"A\" ( THERE SHOULD BE NO B ) *\\n2) ON THE RIGHT OF BALANCING POINT EVERYTHING SHOULB BE \"B\"(THERE SHOULD BE NO A)\\n\\nNOW, IT SIMPLY MEANS THAT FOR A BALANCING POINT IF THERE ARE ANY \"B\" ON THE RIGHT HAND SIDE WE HAVE TO DELETE THEM AND IF THERE ARE ANY \"A\" ON THE RIGHT HAND SIDE OF THE BALANCING POINT WE HAVE TO DELETE THEM\\n\\nTOTAL DELETION = NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   \\n\\nLET US CALCULATE FOR EVERY INDEX FOR THE ABOVE EXAMPLE\\n\" A A A B A A\"\\nNO OF B ON THE LEFT OF EVERY INDEX = [0 ,0 ,0 ,0 ,1 , 1];\\nNO OF A ON THE RIGHT OF EVERY INDEX = [4, 3, 2, 2, 1, 0];\\n\\nNOW FOR INDEX WE HAVE TO CALCULATE **THE  NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   **\\n\\nAND AFTER CALCULATING FOR EVERY INDEX WE HAVE TO JUST TAKE THE MINIMUM\\n\\nHERE WE CAN SEE THAT (1+0) IS THE BEST BALANCING POINT WHERE WE HAVE TO DELETE 1 \"B\" AND 0 \"A\"\\n\\nTHE CODE FOR THE ABOVE SOLUTION IS\\n```\\n  int back[100001]={-1};\\n        int front[100001]={-1};\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                back[i] = count;\\n                count++;\\n            }\\n            else\\n            {\\n                back[i]=count;\\n            }\\n            \\n        }\\n        \\n     count =0;\\n        for(int i=s.size()-1; i>=0; i--)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                front[i]=count;\\n            }\\n            else\\n            {\\n                front[i]=count;\\n                count++;\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            \\n            \\n                int x = back[i]+front[i];\\n                //cout<<back[i]<<\" \";\\n                if(x<ans)\\n                {\\n                    ans = x;\\n                }\\n            \\n        }\\n        \\n        if(ans==INT_MAX)\\n        {\\n            return 0;\\n        }\\n        return ans;\\n        \\n        \\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "**THE PROBLEM CAN BE EASILY SOLVED JUST WITH THE HELP OF OBSERVATION**\\n\\nLET US TAKE A VERY SIMPLE EXAMPLE\\n\\n**STRING  S = \"A A A B A A\"**\\n\\nWE CAN EASILY SAY THAT THE ANSWER IS 1, BUT HOW DO WE ACHIEVE THAT\\n\\nSIMPLEE, **WE CONSIDER EVERY POINT AS BALANCING POINT**\\n\\n1) *ON THE LEFT OF BALANCING POINT EVEYTHING SHOULD BE \"A\" ( THERE SHOULD BE NO B ) *\\n2) ON THE RIGHT OF BALANCING POINT EVERYTHING SHOULB BE \"B\"(THERE SHOULD BE NO A)\\n\\nNOW, IT SIMPLY MEANS THAT FOR A BALANCING POINT IF THERE ARE ANY \"B\" ON THE RIGHT HAND SIDE WE HAVE TO DELETE THEM AND IF THERE ARE ANY \"A\" ON THE RIGHT HAND SIDE OF THE BALANCING POINT WE HAVE TO DELETE THEM\\n\\nTOTAL DELETION = NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   \\n\\nLET US CALCULATE FOR EVERY INDEX FOR THE ABOVE EXAMPLE\\n\" A A A B A A\"\\nNO OF B ON THE LEFT OF EVERY INDEX = [0 ,0 ,0 ,0 ,1 , 1];\\nNO OF A ON THE RIGHT OF EVERY INDEX = [4, 3, 2, 2, 1, 0];\\n\\nNOW FOR INDEX WE HAVE TO CALCULATE **THE  NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   **\\n\\nAND AFTER CALCULATING FOR EVERY INDEX WE HAVE TO JUST TAKE THE MINIMUM\\n\\nHERE WE CAN SEE THAT (1+0) IS THE BEST BALANCING POINT WHERE WE HAVE TO DELETE 1 \"B\" AND 0 \"A\"\\n\\nTHE CODE FOR THE ABOVE SOLUTION IS\\n```\\n  int back[100001]={-1};\\n        int front[100001]={-1};\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                back[i] = count;\\n                count++;\\n            }\\n            else\\n            {\\n                back[i]=count;\\n            }\\n            \\n        }\\n        \\n     count =0;\\n        for(int i=s.size()-1; i>=0; i--)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                front[i]=count;\\n            }\\n            else\\n            {\\n                front[i]=count;\\n                count++;\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            \\n            \\n                int x = back[i]+front[i];\\n                //cout<<back[i]<<\" \";\\n                if(x<ans)\\n                {\\n                    ans = x;\\n                }\\n            \\n        }\\n        \\n        if(ans==INT_MAX)\\n        {\\n            return 0;\\n        }\\n        return ans;\\n        \\n        \\n",
                "codeTag": "C++"
            },
            {
                "id": 1674644,
                "title": "c-solution-o-n-time-complexity-beginner-friendly",
                "content": "``` Easy implementation of stack. Time complexity is O(n) where n is length of string. ```\\n``` Just counted the pair of \"ba\" in the string. ```\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string str) {\\n        stack<char>s;         // Initialised the stack\\n        int c=0;\\n        s.push(str[0]);         // Pushed the first char of the string\\n        for(int i=1;i<str.length();i++)\\n        {\\n            if(s.empty())\\n                s.push(str[i]);\\n            else if(s.top()==\\'b\\' && str[i]==\\'a\\')     \\n            {\\n                c++;               // Increased the count of deletions\\n                s.pop();        // Pop the top of stack\\n            }\\n            else\\n                s.push(str[i]);\\n                \\n        }\\n        return c;\\n    }\\n};\\n```\\n``` If you like my approach then hit the like button to  keep me motivated to post more solutions like this.```",
                "solutionTags": [],
                "code": "``` Easy implementation of stack. Time complexity is O(n) where n is length of string. ```\n``` Just counted the pair of \"ba\" in the string. ```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string str) {\\n        stack<char>s;         // Initialised the stack\\n        int c=0;\\n        s.push(str[0]);         // Pushed the first char of the string\\n        for(int i=1;i<str.length();i++)\\n        {\\n            if(s.empty())\\n                s.push(str[i]);\\n            else if(s.top()==\\'b\\' && str[i]==\\'a\\')     \\n            {\\n                c++;               // Increased the count of deletions\\n                s.pop();        // Pop the top of stack\\n            }\\n            else\\n                s.push(str[i]);\\n                \\n        }\\n        return c;\\n    }\\n};\\n```\n``` If you like my approach then hit the like button to  keep me motivated to post more solutions like this.```",
                "codeTag": "Java"
            },
            {
                "id": 1643636,
                "title": "java-stack-simple-2-solutions-explained",
                "content": "The idea here is to simply push \\'b\\' onto a Stack whenever we encounter it.\\nBut what if we encounter \\'a\\', in this case we check if there is a \\'b\\' present already only then we pop \\'b\\' from the Stack (which signifies a Delete operation).\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        Stack<Character> balance = new Stack();\\n        char c = \\' \\';\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            c = s.charAt(i);\\n            if(!balance.empty() && (balance.peek() == \\'b\\' && c == \\'a\\'))\\n            {\\n                balance.pop();\\n                count++;\\n            }\\n            else if(c == \\'b\\')\\n                balance.push(c);\\n        }\\n        return count;\\n    }\\n}\\n```\\nA similar solution just without Stack \\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n        int prefix = 0;\\n        int total = 0;\\n        for (int i = 0; i < l; i++) \\n        {\\n            if (s.charAt(i) == \\'b\\') \\n                prefix++;\\n            else if(s.charAt(i) == \\'a\\' && prefix > 0)\\n            {\\n                prefix--;\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        Stack<Character> balance = new Stack();\\n        char c = \\' \\';\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            c = s.charAt(i);\\n            if(!balance.empty() && (balance.peek() == \\'b\\' && c == \\'a\\'))\\n            {\\n                balance.pop();\\n                count++;\\n            }\\n            else if(c == \\'b\\')\\n                balance.push(c);\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n        int prefix = 0;\\n        int total = 0;\\n        for (int i = 0; i < l; i++) \\n        {\\n            if (s.charAt(i) == \\'b\\') \\n                prefix++;\\n            else if(s.charAt(i) == \\'a\\' && prefix > 0)\\n            {\\n                prefix--;\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045562,
                "title": "best-and-easiest-solution-o-n-82-faster-solution",
                "content": "same as longest increasing subsequence concept\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n                a++;\\n            else\\n                b++;\\n            a=min(a,b);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n                a++;\\n            else\\n                b++;\\n            a=min(a,b);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939185,
                "title": "python-3-one-pass",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        \"\"\"\\n        Given a string s, this program determines the minimum\\n        number of deletions in s needed to make s balanced.\\n        \\n        At any point in s, it can be balanced by deleting all\\n        b\\'s to the left and all a\\'s to the right. This program\\n        scans s, determines the number of deletions at each\\n        point, and returns the minimum.\\n\\n        :param s: string containing only a\\'s and b\\'s\\n        :type s: str\\n        :return: minimum number of deletions in s needed to\\n                 make s balanced\\n        :rtype: int\\n        \"\"\"\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        delete_counts = [a_count + b_count]\\n        for char in s:\\n            if char == \\'a\\':\\n                a_count -= 1\\n            else:\\n                b_count += 1\\n            delete_counts.append(a_count + b_count)\\n        return min(delete_counts)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        \"\"\"\\n        Given a string s, this program determines the minimum\\n        number of deletions in s needed to make s balanced.\\n        \\n        At any point in s, it can be balanced by deleting all\\n        b\\'s to the left and all a\\'s to the right. This program\\n        scans s, determines the number of deletions at each\\n        point, and returns the minimum.\\n\\n        :param s: string containing only a\\'s and b\\'s\\n        :type s: str\\n        :return: minimum number of deletions in s needed to\\n                 make s balanced\\n        :rtype: int\\n        \"\"\"\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        delete_counts = [a_count + b_count]\\n        for char in s:\\n            if char == \\'a\\':\\n                a_count -= 1\\n            else:\\n                b_count += 1\\n            delete_counts.append(a_count + b_count)\\n        return min(delete_counts)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935460,
                "title": "simplest-solution-greedy-o-n",
                "content": "* Given a desired format (`aaa....aaabbbb....bbbb`), lets call the boundary where the transition happens from `a` to `b` as pivot.\\n* To get the desired format, we want to remove all `b` to the left of the pivot. Similarly, we want to remove all `a` to the right of the pivot.\\n* Instead of actually removing, we will keep the counts of `b` to the left of current index and `a` to the right of current index.\\n\\n```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = s.count(\\'a\\')\\n        b = 0\\n        res = len(s)\\n        for ch in s:\\n            if ch == \\'b\\':\\n                res = min(res, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(res, a+b)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = s.count(\\'a\\')\\n        b = 0\\n        res = len(s)\\n        for ch in s:\\n            if ch == \\'b\\':\\n                res = min(res, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(res, a+b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452670,
                "title": "python-stack-beats-95",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count = 0\\n        stack = []        \\n        for c in s:\\n            if c == \\'b\\':\\n                stack.append(c)\\n            elif stack:\\n                stack.pop()\\n                count += 1\\n        return count\\n               \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count = 0\\n        stack = []        \\n        for c in s:\\n            if c == \\'b\\':\\n                stack.append(c)\\n            elif stack:\\n                stack.pop()\\n                count += 1\\n        return count\\n               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000518,
                "title": "java-dp",
                "content": "Store min operation to make length `i` string balanced. To make `i+1` balanced, if `i+1`th character is `b`, keep the same, otherwise either delete all `b`s or delete one more `a` which is one more extra from `i`th result.\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        var len=s.length();\\n        int dp=0,bc=0;\\n        for(int i=0;i<len;i++) {\\n            if(s.charAt(i)==\\'b\\') bc++;\\n            else dp=Math.min(dp+1,bc);\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        var len=s.length();\\n        int dp=0,bc=0;\\n        for(int i=0;i<len;i++) {\\n            if(s.charAt(i)==\\'b\\') bc++;\\n            else dp=Math.min(dp+1,bc);\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935403,
                "title": "python-o-n",
                "content": "`a_right_count[i]`: the number of a at the right of index i\\n`b_left_count[i]`: the number of b at the left of index i\\n`a_right_count[i] + b_left_count[i]`: the number of deleted characters at index i\\n\\n```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_right_count = [0] * len(s)\\n        b_left_count = [0] * len(s)\\n        \\n        count = 0\\n        for i in range(len(s)):\\n            b_left_count[i] = count\\n            if s[i] == \\'b\\':\\n                count += 1\\n        \\n        count = 0\\n        for i in range(len(s) - 1 ,-1, -1):\\n            a_right_count[i] = count\\n            if s[i] == \\'a\\':\\n                count += 1\\n        \\n        min_delete = len(s)\\n        for i in range(len(s)):\\n            min_delete = min(min_delete, a_right_count[i] + b_left_count[i])\\n        return min_delete\\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_right_count = [0] * len(s)\\n        b_left_count = [0] * len(s)\\n        \\n        count = 0\\n        for i in range(len(s)):\\n            b_left_count[i] = count\\n            if s[i] == \\'b\\':\\n                count += 1\\n        \\n        count = 0\\n        for i in range(len(s) - 1 ,-1, -1):\\n            a_right_count[i] = count\\n            if s[i] == \\'a\\':\\n                count += 1\\n        \\n        min_delete = len(s)\\n        for i in range(len(s)):\\n            min_delete = min(min_delete, a_right_count[i] + b_left_count[i])\\n        return min_delete\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041057,
                "title": "prefix-suffix-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), cnt = 0, ans = 1e9;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), cnt = 0, ans = 1e9;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309277,
                "title": "dp-with-o-1-space",
                "content": "```\\n   int minimumDeletions(string s) \\n   {\\n        int i;\\n        int best = 0;\\n        int count = 0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'a\\')\\n                best = min(best+1, count); // if we have seen \\'a\\' then best will be minimun of converting all \\'b\\' till now or whatever was the best till now + 1 for this new \\'a\\' conversion.\\n            if(s[i] == \\'b\\')\\n                count++;  // count the number of \\'b\\'\\n        }\\n        return best;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n   int minimumDeletions(string s) \\n   {\\n        int i;\\n        int best = 0;\\n        int count = 0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'a\\')\\n                best = min(best+1, count); // if we have seen \\'a\\' then best will be minimun of converting all \\'b\\' till now or whatever was the best till now + 1 for this new \\'a\\' conversion.\\n            if(s[i] == \\'b\\')\\n                count++;  // count the number of \\'b\\'\\n        }\\n        return best;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2186582,
                "title": "c-prefix-suffix",
                "content": "* We want to make a sequence of characters such that all `a\\'s` are on left and all `b\\'s` are on right.\\n\\n * At each index of `s` , Keep all `a\\'s` from left till `i` and keep all `b\\'s`  from right till `i`. **Delete all remaining**. **Find minimum out of those**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>pref , suff ;\\n        int a = 0 ;\\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            a += s[i] == \\'a\\' ;\\n            pref.push_back(a) ;\\n        }\\n        int b = 0 ;\\n        for(int i = s.size() - 1 ; i >= 0 ; --i ){\\n            b += s[i] == \\'b\\' ;\\n            suff.push_back(b) ;\\n        }\\n        reverse(begin(suff),end(suff)) ; \\n        \\n        int dels = s.size() ;\\n        for(int i = 0 ; i < s.size() ; ++i ) dels = min(dels,(int)s.size() - pref[i] - suff[i]) ;\\n        return dels ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>pref , suff ;\\n        int a = 0 ;\\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            a += s[i] == \\'a\\' ;\\n            pref.push_back(a) ;\\n        }\\n        int b = 0 ;\\n        for(int i = s.size() - 1 ; i >= 0 ; --i ){\\n            b += s[i] == \\'b\\' ;\\n            suff.push_back(b) ;\\n        }\\n        reverse(begin(suff),end(suff)) ; \\n        \\n        int dels = s.size() ;\\n        for(int i = 0 ; i < s.size() ; ++i ) dels = min(dels,(int)s.size() - pref[i] - suff[i]) ;\\n        return dels ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075592,
                "title": "java-o-n-solution",
                "content": "```\\npublic int minimumDeletions(String s) {\\n\\n        int bCnt = 0;\\n        int ans =0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if(ch ==\\'b\\')bCnt++;\\n            if(bCnt>0 && ch==\\'a\\'){\\n                bCnt--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minimumDeletions(String s) {\\n\\n        int bCnt = 0;\\n        int ans =0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if(ch ==\\'b\\')bCnt++;\\n            if(bCnt>0 && ch==\\'a\\'){\\n                bCnt--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1941430,
                "title": "easy-javascript-bidirectional-dp",
                "content": "This uses the same solution from https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solution/\\nwhere you count the number of \\'b\\' you need to delete going from the left, and count the number of \\'a\\' you need to delete going from the right.\\nOnce you have a count, you find the min_deletion = left_dpA[i] + right_dpB[i]. Note, the bidirectional left shift and right shift is removed, by incrementing the counter after, which yields an non-inclusive character count. The character at i, can be either \\'a\\' or \\'b\\' and it wouldn\\'t effect the minimum delete because that intersection point will belong to left or right.\\n```\\nvar minimumDeletions = function(s) {\\n    const dpA = [];\\n    let counter = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        dpA[i] = counter;\\n        if (s[i] === \\'b\\') {\\n            counter++;\\n        }\\n    }\\n    \\n    counter = 0;\\n    const dpB = [];\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        dpB[i] = counter;\\n        if (s[i] === \\'a\\') {\\n            counter++;\\n        }\\n    }\\n\\n    let minDelete = s.length;\\n    for (let i = 0; i < s.length; i++) {\\n        minDelete = Math.min(minDelete, dpA[i] + dpB[i]);\\n    }\\n    \\n    return minDelete;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minimumDeletions = function(s) {\\n    const dpA = [];\\n    let counter = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        dpA[i] = counter;\\n        if (s[i] === \\'b\\') {\\n            counter++;\\n        }\\n    }\\n    \\n    counter = 0;\\n    const dpB = [];\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        dpB[i] = counter;\\n        if (s[i] === \\'a\\') {\\n            counter++;\\n        }\\n    }\\n\\n    let minDelete = s.length;\\n    for (let i = 0; i < s.length; i++) {\\n        minDelete = Math.min(minDelete, dpA[i] + dpB[i]);\\n    }\\n    \\n    return minDelete;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1700646,
                "title": "java-o-1-space-o-n-complexity",
                "content": "assume we have got answer for string s, then lets suppose a new character comes and get added\\nwe then have below situations for that new character:\\n1. if it is a \\'b\\' then nothing needed, because \\'b\\' at the end will still be balanced\\n2. if it is a \\'a\\' then number of deletion have to be increased from previous no_of_deletions\\nso new no_of_deletions = no_of_deletions + 1.\\nNow we have 2 counters, no_of_b & no_of_deletions. We will take whichever is lesser of the two.\\n```\\n        int b = 0, no_of_deletions = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'b\\') b++;\\n            else no_of_deletions++;\\n            no_of_deletions = Math.min(no_of_deletions, b);\\n        }\\n        return no_of_deletions;\\n```",
                "solutionTags": [],
                "code": "```\\n        int b = 0, no_of_deletions = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'b\\') b++;\\n            else no_of_deletions++;\\n            no_of_deletions = Math.min(no_of_deletions, b);\\n        }\\n        return no_of_deletions;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093898,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        ans = suffix = 0\\n        for c in reversed(s):\\n            if c == \"a\": suffix += 1\\n            else: ans = min(1 + ans, suffix)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        ans = suffix = 0\\n        for c in reversed(s):\\n            if c == \"a\": suffix += 1\\n            else: ans = min(1 + ans, suffix)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965905,
                "title": "c-100-o-n-time-o-1-space-dp-solution-with-explanation",
                "content": "This is classic DP problem. \\n```\\nLet nda[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'a\\'\\nLet ndb[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'b\\'\\n```\\n\\nNow loop over each char of str\\n```\\n\\tcase \\'a\\'\\n\\t\\tnda[i] = nda[i-1]   //No deletions required \\n\\t\\tndb[i] = ndb[i-1] + 1  // 1 deletion required\\n\\t\\tbreak;\\n\\tcase \\'b\\'\\n\\t\\tndb[i] = min(nda[i-1], ndb[i-1]) // previous sub-string doesnt matter, it can be \\'aa\\' or \\'bb\\' or \\'ab\\'\\n\\t\\tnda[i] = nda[i-1] + 1 // 1 deletion required\\n```\\nNow simply return Min of nda[last], ndb[last]\\nDry Run:\\n____aababbab\\nnda 00112334\\nndb 11011122\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>nda(s.size()+1,0);\\n        vector<int>ndb(s.size()+1,0);\\n        int i=1;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                ndb[i] = ndb[i-1] + 1;\\n                nda[i] = nda[i-1] + 0;\\n            }\\n            else{\\n                ndb[i] = min(ndb[i-1],nda[i-1]);\\n                nda[i] = nda[i-1] + 1;\\n            }\\n            i++;\\n        }\\n        return min(ndb[s.size()],nda[s.size()]);\\n    }\\n};\\n/*\\n____aababbab\\nnda 00112334\\nndb 11011122\\n*/\\n```\\nWe can Optimise into O(1) Space since we need only 2 variables\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int a = 0;\\n        int b = 0;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return min(a,b);\\n    }\\n};\\n/*\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nLet nda[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'a\\'\\nLet ndb[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'b\\'\\n```\n```\\n\\tcase \\'a\\'\\n\\t\\tnda[i] = nda[i-1]   //No deletions required \\n\\t\\tndb[i] = ndb[i-1] + 1  // 1 deletion required\\n\\t\\tbreak;\\n\\tcase \\'b\\'\\n\\t\\tndb[i] = min(nda[i-1], ndb[i-1]) // previous sub-string doesnt matter, it can be \\'aa\\' or \\'bb\\' or \\'ab\\'\\n\\t\\tnda[i] = nda[i-1] + 1 // 1 deletion required\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>nda(s.size()+1,0);\\n        vector<int>ndb(s.size()+1,0);\\n        int i=1;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                ndb[i] = ndb[i-1] + 1;\\n                nda[i] = nda[i-1] + 0;\\n            }\\n            else{\\n                ndb[i] = min(ndb[i-1],nda[i-1]);\\n                nda[i] = nda[i-1] + 1;\\n            }\\n            i++;\\n        }\\n        return min(ndb[s.size()],nda[s.size()]);\\n    }\\n};\\n/*\\n____aababbab\\nnda 00112334\\nndb 11011122\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int a = 0;\\n        int b = 0;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return min(a,b);\\n    }\\n};\\n/*\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938408,
                "title": "a-few-solutions",
                "content": "Consider each `i`<sup>th</sup> index as a \"pivot\" position where we can balance `s` via the following 2 operations:\\n\\n1. delete all characters `\\'b\\'`  \\uD83D\\uDC48 to-the-left of `i`\\n2. delete all characters `\\'a\\'`  \\uD83D\\uDC49 to-the-right of `i`\\n\\nLet us denote the results of operation 1 and and operation 2 above as `prefix` and `suffix` correspondingly.  Then we can find the minimum amount of deletions via `prefix[i] + suffix[i] - 1`, ie. add each `i`<sup>th</sup> `prefix` + `i`<sup>th</sup> `suffix` and subtract by `1` (since we only need to delete `\\'a\\'` xor `\\'b\\'`, but *not* both, at each candidate `i`<sup>th</sup> \"pivot\" index).\\n\\n*Example 1:*\\n```\\nInput: s = \"aababbab\"\\nOutput: 2\\n\\n     s = a a b a b b a b\\nprefix = 0 0 1 1 2 3 3 4\\nsuffix = 4 3 2 2 1 1 1 0\\n cands = 3 2 2 2 2 3 3 3  <-- minimum candidate is 2\\n```\\n\\n*Example 2:*\\n```\\nInput: s = \"bbaaaaabb\"\\nOutput: 2\\n\\n     s = b b a a a a a b b\\nprefix = 1 2 2 2 2 2 2 3 4\\nsuffix = 5 5 5 4 3 2 1 0 0\\n cands = 5 6 6 5 4 3 2 2 3  <-- minimum candidate is 2\\n ```\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumDeletions(s: String): Int {\\n        var N = s.length\\n        var prefix = IntArray(N) { 0 }\\n        var suffix = IntArray(N) { 0 }\\n        var beg = 0\\n        var end = N - 1\\n        for (i in beg..end)     prefix[i] = (if (s[i] == \\'b\\') 1 else 0) + (if (beg < i) prefix[i - 1] else 0)\\n        for (i in end downTo 0) suffix[i] = (if (s[i] == \\'a\\') 1 else 0) + (if (i < end) suffix[i + 1] else 0)\\n        return prefix.zip(suffix){ a, b -> a + b }.min()!!.minus(1)  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minimumDeletions = s => {\\n    let N = s.length;\\n    let A = s.split(\\'\\');\\n    let prefix = Array(N).fill(0),\\n        suffix = Array(N).fill(0);\\n    let beg = 0,\\n        end = N - 1;\\n    for (let i = beg; i <= end; ++i) prefix[i] = Number(A[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n    for (let i = end; beg <= i; --i) suffix[i] = Number(A[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n    return Math.min(..._.zip(prefix, suffix).map(([a, b]) => a + b)) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        N = len(s)\\n        prefix = [0] * N\\n        suffix = [0] * N\\n        for i in range(N):             prefix[i] = int(s[i] == \\'b\\') + (prefix[i - 1] if 0 < i     else 0)\\n        for i in range(N - 1, -1, -1): suffix[i] = int(s[i] == \\'a\\') + (suffix[i + 1] if i < N - 1 else 0)\\n        return min(a + b for a, b in zip(prefix, suffix)) - 1  # \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_deletions(s: String) -> i32 {\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        let mut prefix = vec![0; N];\\n        let mut suffix = vec![0; N];\\n        let (beg, end) = (0, N - 1);\\n        for i in 0..N {\\n            prefix[i] = if s[i] == \\'b\\' { 1 } else { 0 } + if beg < i { prefix[i - 1] } else { 0 };\\n        }\\n        for j in (0..N).rev() {\\n            suffix[j] = if s[j] == \\'a\\' { 1 } else { 0 } + if j < end { suffix[j + 1] } else { 0 };\\n        }\\n        prefix.iter().zip(suffix).map(|(a, b)| a + b).min().unwrap() - 1 // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minimumDeletions(string s) {\\n        int N = s.size();\\n        VI prefix(N),\\n           suffix(N),\\n           cands(N);\\n        int beg = 0,\\n            end = N - 1;\\n        for (auto i{ beg }; i <= end; ++i) prefix[i] = int(s[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n        for (auto i{ end }; beg <= i; --i) suffix[i] = int(s[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n        for (auto i{ 0 }; i < N; ++i)\\n            cands[i] = prefix[i] + suffix[i];\\n        return *min_element(cands.begin(), cands.end()) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nInput: s = \"aababbab\"\\nOutput: 2\\n\\n     s = a a b a b b a b\\nprefix = 0 0 1 1 2 3 3 4\\nsuffix = 4 3 2 2 1 1 1 0\\n cands = 3 2 2 2 2 3 3 3  <-- minimum candidate is 2\\n```\n```\\nInput: s = \"bbaaaaabb\"\\nOutput: 2\\n\\n     s = b b a a a a a b b\\nprefix = 1 2 2 2 2 2 2 3 4\\nsuffix = 5 5 5 4 3 2 1 0 0\\n cands = 5 6 6 5 4 3 2 2 3  <-- minimum candidate is 2\\n ```\n```\\nclass Solution {\\n    fun minimumDeletions(s: String): Int {\\n        var N = s.length\\n        var prefix = IntArray(N) { 0 }\\n        var suffix = IntArray(N) { 0 }\\n        var beg = 0\\n        var end = N - 1\\n        for (i in beg..end)     prefix[i] = (if (s[i] == \\'b\\') 1 else 0) + (if (beg < i) prefix[i - 1] else 0)\\n        for (i in end downTo 0) suffix[i] = (if (s[i] == \\'a\\') 1 else 0) + (if (i < end) suffix[i + 1] else 0)\\n        return prefix.zip(suffix){ a, b -> a + b }.min()!!.minus(1)  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\n```\\nlet minimumDeletions = s => {\\n    let N = s.length;\\n    let A = s.split(\\'\\');\\n    let prefix = Array(N).fill(0),\\n        suffix = Array(N).fill(0);\\n    let beg = 0,\\n        end = N - 1;\\n    for (let i = beg; i <= end; ++i) prefix[i] = Number(A[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n    for (let i = end; beg <= i; --i) suffix[i] = Number(A[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n    return Math.min(..._.zip(prefix, suffix).map(([a, b]) => a + b)) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n};\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        N = len(s)\\n        prefix = [0] * N\\n        suffix = [0] * N\\n        for i in range(N):             prefix[i] = int(s[i] == \\'b\\') + (prefix[i - 1] if 0 < i     else 0)\\n        for i in range(N - 1, -1, -1): suffix[i] = int(s[i] == \\'a\\') + (suffix[i + 1] if i < N - 1 else 0)\\n        return min(a + b for a, b in zip(prefix, suffix)) - 1  # \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n```\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_deletions(s: String) -> i32 {\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        let mut prefix = vec![0; N];\\n        let mut suffix = vec![0; N];\\n        let (beg, end) = (0, N - 1);\\n        for i in 0..N {\\n            prefix[i] = if s[i] == \\'b\\' { 1 } else { 0 } + if beg < i { prefix[i - 1] } else { 0 };\\n        }\\n        for j in (0..N).rev() {\\n            suffix[j] = if s[j] == \\'a\\' { 1 } else { 0 } + if j < end { suffix[j + 1] } else { 0 };\\n        }\\n        prefix.iter().zip(suffix).map(|(a, b)| a + b).min().unwrap() - 1 // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minimumDeletions(string s) {\\n        int N = s.size();\\n        VI prefix(N),\\n           suffix(N),\\n           cands(N);\\n        int beg = 0,\\n            end = N - 1;\\n        for (auto i{ beg }; i <= end; ++i) prefix[i] = int(s[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n        for (auto i{ end }; beg <= i; --i) suffix[i] = int(s[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n        for (auto i{ 0 }; i < N; ++i)\\n            cands[i] = prefix[i] + suffix[i];\\n        return *min_element(cands.begin(), cands.end()) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936514,
                "title": "javascript-time-o-n-space-o-1-100-both",
                "content": "I contrast to counting number of characters to delete, I count characters that I can keep in a balanced string that is subsequence of the whole string and calculate number of chars to delete by extracting it from the total string length. `lena` and `lenb` are lengths of the longest subsequences ending with `a` or `b` respectively. \\n- `a` can be appended only to subsequence ending with `a`, so the length of new subsequence ending with newly added `a` is `lena + 1`.\\n- `b` can be appended both to subsequence ending with `a` or `b` so the length of new subsequence will be `max(lena, lenb) + 1`.\\n```javascript\\nvar minimumDeletions = function (s) {\\n  let lena = 0;\\n  let lenb = 0;\\n  for (let ch of s) {\\n    if (\\'a\\' == ch) {\\n      ++lena;\\n    } else {\\n      lenb = Math.max(lena, lenb) + 1;\\n    }\\n  }\\n\\n  return s.length - Math.max(lena, lenb);\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar minimumDeletions = function (s) {\\n  let lena = 0;\\n  let lenb = 0;\\n  for (let ch of s) {\\n    if (\\'a\\' == ch) {\\n      ++lena;\\n    } else {\\n      lenb = Math.max(lena, lenb) + 1;\\n    }\\n  }\\n\\n  return s.length - Math.max(lena, lenb);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935437,
                "title": "time-o-n-space-o-1-without-stack",
                "content": "We count number of \\'a\\' and \\'b\\'.\\nAnd during traversing we make a decision:\\n1. either we remove \\'b\\'.\\n2. or we remove all upcoming \\'a\\'.\\n\\n```\\npublic int minimumDeletions(String s) {\\n    int a = 0, b = 0;\\n    for(char c : s.toCharArray()) {\\n        if (c == \\'a\\') a++;\\n        else b++;\\n    }\\n    int cA = 0, cB = 0, min = 0, delAll = a;\\n    for(int i = 0; i < s.length(); i++) {\\n        char c = s.charAt(i);\\n        if (a - cA == 0) break;\\n        if (c == \\'a\\') {\\n            cA++;\\n        } else {\\n            cB++;\\n            delAll = Math.min(a - cA + min, delAll);\\n            min++;\\n        }\\n    }\\n    return Math.min(delAll, min);;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumDeletions(String s) {\\n    int a = 0, b = 0;\\n    for(char c : s.toCharArray()) {\\n        if (c == \\'a\\') a++;\\n        else b++;\\n    }\\n    int cA = 0, cB = 0, min = 0, delAll = a;\\n    for(int i = 0; i < s.length(); i++) {\\n        char c = s.charAt(i);\\n        if (a - cA == 0) break;\\n        if (c == \\'a\\') {\\n            cA++;\\n        } else {\\n            cB++;\\n            delAll = Math.min(a - cA + min, delAll);\\n            min++;\\n        }\\n    }\\n    return Math.min(delAll, min);;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935387,
                "title": "python-short-and-simple-5-lines-o-n",
                "content": "If we are standing at some position, to make the string balanced by converting the left side to all *a*\\'s and the right side to all *b*\\'s, we need the number of deletions to equal the number of *b*\\'s on the left plus the number of *a*\\'s on the right.\\n\\nLet\\'s start with imaginary position right before the first (index 0) character. The number of needed deletions is the number of *a*\\'s on the right. To move to the next position in the string (between position 0 and 1, then between position 1 and 2, etc.), we need to subtract 1 from the calculated deletions if the current character is *a* (becase if moves from the right part to the left; thus, the number of needed deletions on the right decreases) and add 1 if the current character is b (becase if moves to the left part from the current position; i.e., the number of needed deletions on the left increases). \\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        min_del=del_chars=s.count(\"a\")\\n        for char in s+\"b\":\\n            min_del=min(min_del, del_chars)\\n            del_chars=del_chars+1 if char==\"b\" else del_chars-1\\n        return min_del\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        min_del=del_chars=s.count(\"a\")\\n        for char in s+\"b\":\\n            min_del=min(min_del, del_chars)\\n            del_chars=del_chars+1 if char==\"b\" else del_chars-1\\n        return min_del\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824481,
                "title": "c-very-easy-stack-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            char c = s[i];\\n            if(c == \\'a\\'){\\n                if(!st.empty()){\\n                    st.pop();\\n                    count++;\\n                }\\n            }\\n            else{\\n               st.push(c);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            char c = s[i];\\n            if(c == \\'a\\'){\\n                if(!st.empty()){\\n                    st.pop();\\n                    count++;\\n                }\\n            }\\n            else{\\n               st.push(c);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267946,
                "title": "lis-dp-o-n",
                "content": "# Approach\\nThe longest nonstrictly increasing subsequence is computed and then this is subtracted from the length of the input string.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(n)$\\n\\n$n$ is the length of the input string.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int lis(vector<int> & nums, int i, int p, vector<vector<int>> & dp) {\\n\\n        int n = nums.size();\\n\\n        if(i >= n)\\n            return 0;\\n\\n        if(dp[i][p] != -1)\\n            return dp[i][p];\\n\\n        int res = 0;\\n\\n        if(nums[i] >= p)\\n            res = max(res, 1 + lis(nums, i + 1, nums[i], dp));\\n            \\n        res = max(res, lis(nums, i + 1, p, dp));\\n\\n        dp[i][p] = res;\\n\\n        return res;\\n    }\\n\\n    int lengthOfLIS(vector<int> & nums) {\\n        \\n        int n = nums.size();\\n\\n        int uniqueNums = 2;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(uniqueNums, -1));\\n\\n        return lis(nums, 0, 0, dp);\\n    }\\n\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(auto c : s) {\\n            if(c == \\'a\\')\\n                nums.push_back(0);\\n            else \\n                nums.push_back(1);\\n        }\\n\\n        return s.length() - lengthOfLIS(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    int lis(vector<int> & nums, int i, int p, vector<vector<int>> & dp) {\\n\\n        int n = nums.size();\\n\\n        if(i >= n)\\n            return 0;\\n\\n        if(dp[i][p] != -1)\\n            return dp[i][p];\\n\\n        int res = 0;\\n\\n        if(nums[i] >= p)\\n            res = max(res, 1 + lis(nums, i + 1, nums[i], dp));\\n            \\n        res = max(res, lis(nums, i + 1, p, dp));\\n\\n        dp[i][p] = res;\\n\\n        return res;\\n    }\\n\\n    int lengthOfLIS(vector<int> & nums) {\\n        \\n        int n = nums.size();\\n\\n        int uniqueNums = 2;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(uniqueNums, -1));\\n\\n        return lis(nums, 0, 0, dp);\\n    }\\n\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(auto c : s) {\\n            if(c == \\'a\\')\\n                nums.push_back(0);\\n            else \\n                nums.push_back(1);\\n        }\\n\\n        return s.length() - lengthOfLIS(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198090,
                "title": "very-easy-approach-can-be-used-for-many-problems",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach PREFIX AND SUFFIX SUM\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.length(), cnt = 0;\\n        int ans = INT_MAX;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.length(), cnt = 0;\\n        int ans = INT_MAX;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971585,
                "title": "time-o-n-space-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[ Flip String to Monotone Increasing](https://leetcode.com/problems/flip-string-to-monotone-increasing/solutions/2912351/flip-string-to-monotone-increasing//)\\n\\nExactly Same\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        rightDel = s.count(\\'a\\')\\n        leftDel = 0\\n        ans = rightDel\\n        for i in range(len(s)):\\n            if s[i] == \\'b\\':\\n                leftDel += 1\\n            else:\\n                rightDel -= 1\\n                ans = min(ans,leftDel+rightDel)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        rightDel = s.count(\\'a\\')\\n        leftDel = 0\\n        ans = rightDel\\n        for i in range(len(s)):\\n            if s[i] == \\'b\\':\\n                leftDel += 1\\n            else:\\n                rightDel -= 1\\n                ans = min(ans,leftDel+rightDel)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918899,
                "title": "python3-solution-clean-concise-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```Python\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        ans, count = 0, 0\\n        for i in s:\\n            if i == \\'b\\':\\n                count += 1\\n            elif count:\\n                ans += 1\\n                count -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        ans, count = 0, 0\\n        for i in s:\\n            if i == \\'b\\':\\n                count += 1\\n            elif count:\\n                ans += 1\\n                count -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362604,
                "title": "python3-one-pass-o-1-mem-simple-and-intuitive",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n\\n        a_len = 0\\n        ab_len = 0\\n\\n        for c in s:\\n            if c == \"a\":\\n                a_len += 1\\n            else:\\n                ab_len = max(ab_len+1, a_len+1)\\n\\n        return n - max(a_len, ab_len)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n\\n        a_len = 0\\n        ab_len = 0\\n\\n        for c in s:\\n            if c == \"a\":\\n                a_len += 1\\n            else:\\n                ab_len = max(ab_len+1, a_len+1)\\n\\n        return n - max(a_len, ab_len)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340836,
                "title": "my-java-code-o-n-time-o-1-space",
                "content": "This question is similar to->  [https://leetcode.com/problems/flip-string-to-monotone-increasing/]\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int i = 0;\\n        for(i = 0; i < s.length(); i++){\\n            if(s.charAt(i)==\\'b\\')\\n                break;\\n        }\\n        int countflips = 0;\\n        int countb = 0;\\n        for(i=i; i < s.length(); i++){\\n            if(s.charAt(i)==\\'a\\') countflips++;\\n            \\n            else countb++;\\n            \\n            countflips = Math.min(countflips, countb);\\n        }    \\n        return countflips;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumDeletions(String s) {\\n        int i = 0;\\n        for(i = 0; i < s.length(); i++){\\n            if(s.charAt(i)==\\'b\\')\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2288528,
                "title": "this-should-be-classified-as-easy-problem-simple-java-solution",
                "content": "This is a very simple question.\\n\\tThe idea is straightforward, we need to keep a count of all the `\\'b\\'` that we have encountered. If we encounter an `\\'a\\'`, we need to decrement the count of `b`, since we have found more `b`s before `a`s. And doing that, we need to increment `deleteCt` since we have more `b` and we need to remove that.\\n\\n\\n```\\n    public int minimumDeletions(String s) {\\n        int bCt = 0, deleteCt = 0;\\n        for(char ch: s.toCharArray()){\\n            if(ch == \\'b\\')\\n                bCt = bCt <= 0 ? 1 : bCt + 1;\\n            else {\\n                if(bCt > 0){\\n                    deleteCt++;\\n                    bCt--;\\n                }\\n            }\\n        }\\n        return deleteCt;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n    public int minimumDeletions(String s) {\\n        int bCt = 0, deleteCt = 0;\\n        for(char ch: s.toCharArray()){\\n            if(ch == \\'b\\')\\n                bCt = bCt <= 0 ? 1 : bCt + 1;\\n            else {\\n                if(bCt > 0){\\n                    deleteCt++;\\n                    bCt--;\\n                }\\n            }\\n        }\\n        return deleteCt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228525,
                "title": "faster-than-83-clean-dp-solution-with-explanation",
                "content": "The idea is pretty simple here, we will iterate from index 0 to n-1 and calculate the current max length of balanced string from starting (0) to the current index i ( with the element i being present in it ).\\nNow for example  a a b a b a .\\nIn the above string dp[0]  = 1 ( the max length of balanced string is 1 including the index 0)\\nsimilary for dp[1] = 2 ( a a ).\\nSo we will keep a count of \\'a\\' , and anytime we will encounter a new \\'a\\' the current max length of balanced string would be  count_a + 1. ( The reasoning behind this is that if you want to end your balanced string with an \\'a\\' then you cant include the \\'b\\' in it ).\\nfor example in    a a b a b a \\nthe maximum length of balanced string that you can from ending at index 5 is 4 ( a a a a ) excluding the 2 \\'b\\'s .\\nNow what if we encounter a \\'b\\' , what would be the maximum length of balanced string ending at that index.\\nWell that would be max( previous_b_length , count_a) +1 , because there can be a \\'b\\' or an \\'a\\' before the next b and we would like to take the maximum of the the case.\\n\\nCode:\\n```\\n  int minimumDeletions(string s) {\\n        \\n        int n= s.size(),prevb=0;\\n        int dp[n],maxi=-1;\\n        int i,j,la=0,lb=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                la++;\\n                dp[i] = la;\\n                maxi = max(maxi,dp[i]);\\n            }\\n            if(s[i]==\\'b\\')\\n            {\\n                dp[i] =  max(la,prevb) + 1;\\n                maxi = max(maxi,dp[i]);\\n                prevb = dp[i];\\n            }\\n        }\\n        return n-maxi;\\n\\t\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The idea is pretty simple here, we will iterate from index 0 to n-1 and calculate the current max length of balanced string from starting (0) to the current index i ( with the element i being present in it ).\\nNow for example  a a b a b a .\\nIn the above string dp[0]  = 1 ( the max length of balanced string is 1 including the index 0)\\nsimilary for dp[1] = 2 ( a a ).\\nSo we will keep a count of \\'a\\' , and anytime we will encounter a new \\'a\\' the current max length of balanced string would be  count_a + 1. ( The reasoning behind this is that if you want to end your balanced string with an \\'a\\' then you cant include the \\'b\\' in it ).\\nfor example in    a a b a b a \\nthe maximum length of balanced string that you can from ending at index 5 is 4 ( a a a a ) excluding the 2 \\'b\\'s .\\nNow what if we encounter a \\'b\\' , what would be the maximum length of balanced string ending at that index.\\nWell that would be max( previous_b_length , count_a) +1 , because there can be a \\'b\\' or an \\'a\\' before the next b and we would like to take the maximum of the the case.\\n\\nCode:\\n```\\n  int minimumDeletions(string s) {\\n        \\n        int n= s.size(),prevb=0;\\n        int dp[n],maxi=-1;\\n        int i,j,la=0,lb=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                la++;\\n                dp[i] = la;\\n                maxi = max(maxi,dp[i]);\\n            }\\n            if(s[i]==\\'b\\')\\n            {\\n                dp[i] =  max(la,prevb) + 1;\\n                maxi = max(maxi,dp[i]);\\n                prevb = dp[i];\\n            }\\n        }\\n        return n-maxi;\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1977265,
                "title": "easy-o-n-time-o-1-space",
                "content": "Basic idea is pretty simple you have to convert string to aaaaa..(n times)bbbb...(m times) so for this, you can select after what index there should be no a\\'s present in the string and before that index there should be no b\\'s. You have to find the index which will give minimum sum of count of: b\\'s from start to index and a\\'s from index to end. Your answer is the sum. \\nSteps:\\n1) Calculate the countA.\\n2) Start iterating by keeping count of a and b, and ans = min(ans,countA-a+b).\\n3) Initially your ans will be countA (no a is considered initially).\\n![image](https://assets.leetcode.com/users/images/6b49cfb3-dbb9-4d2b-83d5-f90030230b8d_1650776896.3743162.png)\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int countA = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                countA++;\\n            }\\n        }\\n        int ans = countA;\\n        int tempA = 0;\\n        int tempB = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                tempA++;\\n            }\\n            else{\\n                tempB++;\\n            }\\n            ans = min(ans,(countA-tempA+tempB));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int countA = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                countA++;\\n            }\\n        }\\n        int ans = countA;\\n        int tempA = 0;\\n        int tempB = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                tempA++;\\n            }\\n            else{\\n                tempB++;\\n            }\\n            ans = min(ans,(countA-tempA+tempB));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775152,
                "title": "java-flip-string-to-monotone-increasing-o-n-time-o-1-space-one-pass",
                "content": "This question is exactly similar to the question Flip String to Monotone Increasing :\\nhttps://leetcode.com/problems/flip-string-to-monotone-increasing/\\n\\nThere we were trying to get minimum number of flips where in this question flip is same as delete.\\n\\n* Flip String to monotone Increasing :\\n\\n \\n        int flips=0;\\n\\t\\tint countOnes=0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\t\\n\\t\\t\\tif (s.charAt(i) == \\'0\\'  &&  countOnes > 0) {\\n\\t\\t\\t\\tflips += 1;\\n\\t\\t\\t\\tcountOnes --;\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(s.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tcountOnes += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn flips;    \\n    \\n\\t\\n* \\tMinimum deletions to make a string balanced :\\n\\n        int deletes=0;\\n\\t\\tint countBs=0;  //count number of consecutive b s\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\tif(s.charAt(i) == \\'a\\'  &&  countBs > 0) {\\n\\t\\t\\t\\tdeletes += 1;\\n\\t\\t\\t\\tcountBs --;\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\tif(s.charAt(i) == \\'b\\') {\\n\\t\\t\\t\\tcountBs += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn deletes;\\n    \\n\\n\\t",
                "solutionTags": [],
                "code": "This question is exactly similar to the question Flip String to Monotone Increasing :\\nhttps://leetcode.com/problems/flip-string-to-monotone-increasing/\\n\\nThere we were trying to get minimum number of flips where in this question flip is same as delete.\\n\\n* Flip String to monotone Increasing :\\n\\n \\n        int flips=0;\\n\\t\\tint countOnes=0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\t\\n\\t\\t\\tif (s.charAt(i) == \\'0\\'  &&  countOnes > 0) {\\n\\t\\t\\t\\tflips += 1;\\n\\t\\t\\t\\tcountOnes --;\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(s.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tcountOnes += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn flips;    \\n    \\n\\t\\n* \\tMinimum deletions to make a string balanced :\\n\\n        int deletes=0;\\n\\t\\tint countBs=0;  //count number of consecutive b s\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\tif(s.charAt(i) == \\'a\\'  &&  countBs > 0) {\\n\\t\\t\\t\\tdeletes += 1;\\n\\t\\t\\t\\tcountBs --;\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\tif(s.charAt(i) == \\'b\\') {\\n\\t\\t\\t\\tcountBs += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn deletes;\\n    \\n\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1662781,
                "title": "easy-c-solution-using-stack-start-counting-from-the-end-of-the-string",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n=s.size();\\n        int c=0;\\n        stack<char>t;\\n        \\n        int i=n-1;\\n        while(i>=0){\\n            \\n            if(t.empty()){\\n                t.push(s[i]);     \\n            }\\n            \\n            else if(t.top()==\\'a\\' && s[i]==\\'b\\'){\\n                c++;\\n                t.pop();         \\n            }\\n            \\n            else t.push(s[i]); \\n            i--;\\n        }    \\n\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n=s.size();\\n        int c=0;\\n        stack<char>t;\\n        \\n        int i=n-1;\\n        while(i>=0){\\n            \\n            if(t.empty()){\\n                t.push(s[i]);     \\n            }\\n            \\n            else if(t.top()==\\'a\\' && s[i]==\\'b\\'){\\n                c++;\\n                t.pop();         \\n            }\\n            \\n            else t.push(s[i]); \\n            i--;\\n        }    \\n\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511951,
                "title": "java-find-divide-point-solution-o-n-time-o-1-memory",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int aCount = 0;\\n        \\n\\t\\t// Count total number of a\\'s\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount++;\\n            }\\n        }\\n\\n        int bCount = 0;\\n        int min = aCount + bCount; // Base case when all numbers needs to be deleted\\n\\t\\t\\n\\t\\t// aCount = number of a\\'s on right, bCount = number of b\\'s at left\\n\\t\\t// at divide index `i`, there will be no a\\'s at index >= `i` and no b\\'s at index < `i`\\n\\t\\t// minimum number to be deleted = number of b\\'s deleted before divide index `i` + number of a\\'s deleted after divide index `i`\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount--; \\n            } else {\\n                bCount++;\\n            }\\n            \\n            min = Integer.min(aCount + bCount, min);\\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int aCount = 0;\\n        \\n\\t\\t// Count total number of a\\'s\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount++;\\n            }\\n        }\\n\\n        int bCount = 0;\\n        int min = aCount + bCount; // Base case when all numbers needs to be deleted\\n\\t\\t\\n\\t\\t// aCount = number of a\\'s on right, bCount = number of b\\'s at left\\n\\t\\t// at divide index `i`, there will be no a\\'s at index >= `i` and no b\\'s at index < `i`\\n\\t\\t// minimum number to be deleted = number of b\\'s deleted before divide index `i` + number of a\\'s deleted after divide index `i`\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount--; \\n            } else {\\n                bCount++;\\n            }\\n            \\n            min = Integer.min(aCount + bCount, min);\\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406992,
                "title": "3-different-python-easy-solution",
                "content": "# Using stack\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack = []\\n        count = 0\\n        \\n        for i in s:\\n            if stack and stack[-1] == \\'b\\' and i == \\'a\\':\\n                stack.pop()\\n                count += 1\\n            \\n            else:\\n                stack.append(i)\\n                \\n        return count\\n```\\n\\n        \\n\\n\\n# Using O(1) space, most optimal\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        ans = len(s) + 1\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                ans = min(ans, a_count + b_count)\\n                \\n            else:\\n                ans = min(ans, a_count + b_count)\\n                b_count += 1\\n                \\n        return ans\\n```\\n        \\n        \\n        \\n        \\n        \\n\\n# Using O(n) space\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = []\\n        b = []\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                a.append(a_count)\\n                b.append(b_count)\\n            \\n            else:\\n                a.append(a_count)\\n                b.append(b_count)\\n                b_count += 1\\n                \\n        ans = len(s) + 1\\n        \\n        for i in range(0,len(s)):\\n            ans = min(ans, a[i] + b[i])            \\n\\t\\t\\t\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack = []\\n        count = 0\\n        \\n        for i in s:\\n            if stack and stack[-1] == \\'b\\' and i == \\'a\\':\\n                stack.pop()\\n                count += 1\\n            \\n            else:\\n                stack.append(i)\\n                \\n        return count\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        ans = len(s) + 1\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                ans = min(ans, a_count + b_count)\\n                \\n            else:\\n                ans = min(ans, a_count + b_count)\\n                b_count += 1\\n                \\n        return ans\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = []\\n        b = []\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                a.append(a_count)\\n                b.append(b_count)\\n            \\n            else:\\n                a.append(a_count)\\n                b.append(b_count)\\n                b_count += 1\\n                \\n        ans = len(s) + 1\\n        \\n        for i in range(0,len(s)):\\n            ans = min(ans, a[i] + b[i])            \\n\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369807,
                "title": "easy-c-solution-o-n-time-with-explanation",
                "content": "Any time if we see an \\'a\\' we need to make a decision whether we: \\n- delete that \\'a\\'\\n- or delete all the previous \\'b\\'s\\n\\nwe calculate the deletion count for that \\'a\\' depending on which is least expensive - if the number of \\'b\\'s before this \\'a\\' is greater than the deletion count after deleting this \\'a\\' (i.e. +1 to the previous deletion count), then it makes sense NOT to delete all the previous \\'b\\'s because it would prove to be costlier than deleting this \\'a\\'.\\n\\nSimliarly, if the number of \\'b\\'s is lesser than the count of deletion after deleting this \\'a\\', we are better off deleting all the previous \\'b\\'s\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCountSoFar = 0, deleteCount = 0;\\n        for (char ch: s) {\\n//             at any point if we see \\'a\\', we either delete it or delete all previous \\'b\\'s depending on which is less expensive\\n            if (ch == \\'a\\') {\\n//                 if number of \\'b\\'s so far is greater, then delete this \\'a\\'\\n                if(bCountSoFar > deleteCount + 1)\\n                    deleteCount++;\\n//                 or else we delete the previous \\'b\\'s\\n                else deleteCount = bCountSoFar;\\n            }\\n            // keep counting the number of \\'b\\'s\\n            else if (ch == \\'b\\') ++bCountSoFar;\\n        }\\n        return deleteCount;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCountSoFar = 0, deleteCount = 0;\\n        for (char ch: s) {\\n//             at any point if we see \\'a\\', we either delete it or delete all previous \\'b\\'s depending on which is less expensive\\n            if (ch == \\'a\\') {\\n//                 if number of \\'b\\'s so far is greater, then delete this \\'a\\'\\n                if(bCountSoFar > deleteCount + 1)\\n                    deleteCount++;\\n//                 or else we delete the previous \\'b\\'s\\n                else deleteCount = bCountSoFar;\\n            }\\n            // keep counting the number of \\'b\\'s\\n            else if (ch == \\'b\\') ++bCountSoFar;\\n        }\\n        return deleteCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341776,
                "title": "c-pre-computed-arrays-basic-dp-explanation",
                "content": "Here I have pre-computed the two arrays \\'a\\' and \\'b\\' which hold the elements to be deleted.\\narray \\'a\\' : number of alphabets \\'a\\' to be deleted at index \\'i\\'.\\narray \\'b\\' : number of alphabets \\'b\\' to be deleted at index \\'i\\'.\\n\\n```\\nint minimumDeletions(string s) {\\n        vector<int>a(s.size(), 0), b(s.size(), 0);\\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            if(s[i] == \\'b\\')\\n                b[i] += i > 0 ? 1 + b[i - 1] : 1;\\n            else\\n                b[i] = (i > 0) ? b[i - 1] : 0;\\n            if(s[s.size() - 1 - i] == \\'a\\')\\n                a[s.size() - 1 - i] += (s.size() - 1 - i < s.size() - 1) ? 1 + a[s.size() - i] : 1;\\n            else\\n                a[s.size() - 1 - i] = (s.size() - 1 - i < s.size() - 1) ? a[s.size() - i] : 0;\\n        }\\n        int ans = min(a[0], b[s.size() - 1]);\\n        for(int i=0; i<s.size() - 1; ++i)\\n            ans = min(ans, b[i] + a[i + 1]);\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Here I have pre-computed the two arrays \\'a\\' and \\'b\\' which hold the elements to be deleted.\\narray \\'a\\' : number of alphabets \\'a\\' to be deleted at index \\'i\\'.\\narray \\'b\\' : number of alphabets \\'b\\' to be deleted at index \\'i\\'.\\n\\n```\\nint minimumDeletions(string s) {\\n        vector<int>a(s.size(), 0), b(s.size(), 0);\\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            if(s[i] == \\'b\\')\\n                b[i] += i > 0 ? 1 + b[i - 1] : 1;\\n            else\\n                b[i] = (i > 0) ? b[i - 1] : 0;\\n            if(s[s.size() - 1 - i] == \\'a\\')\\n                a[s.size() - 1 - i] += (s.size() - 1 - i < s.size() - 1) ? 1 + a[s.size() - i] : 1;\\n            else\\n                a[s.size() - 1 - i] = (s.size() - 1 - i < s.size() - 1) ? a[s.size() - i] : 0;\\n        }\\n        int ans = min(a[0], b[s.size() - 1]);\\n        for(int i=0; i<s.size() - 1; ++i)\\n            ans = min(ans, b[i] + a[i + 1]);\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1272492,
                "title": "c-simple-and-clear-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int x=0, y=0;\\n        vector<int> dp(n+1,0);\\n        if(s[0]==\\'a\\')\\n            x++;\\n        else\\n            y++;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && y!=0)\\n            {\\n                dp[i] = min(dp[i-1]+1, min(y,x+1));\\n            }\\n            else\\n                dp[i] = dp[i-1];\\n            if(s[i]==\\'a\\')\\n                x++;\\n            else\\n                y++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int x=0, y=0;\\n        vector<int> dp(n+1,0);\\n        if(s[0]==\\'a\\')\\n            x++;\\n        else\\n            y++;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && y!=0)\\n            {\\n                dp[i] = min(dp[i-1]+1, min(y,x+1));\\n            }\\n            else\\n                dp[i] = dp[i-1];\\n            if(s[i]==\\'a\\')\\n                x++;\\n            else\\n                y++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168221,
                "title": "cpp-dp-change-the-view-of-the-problem",
                "content": "You can change the view of the problem.\\nThe intent of the original problem is to find the minimum.\\nYou can find the maximum subsequence of the original string.\\nThe subsequence is like ->   a\\\\*b\\\\* , and then subtract the length of the subsequence from the original length.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int last_a = -1;\\n        int last_b = -1;\\n    \\n        int len = s.size();\\n        int max_len[len];\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (s[i] == \\'a\\') {\\n                if (last_a == -1) {\\n                    last_a = i;\\n                    max_len[i] = 1;\\n                } else {\\n                    max_len[i] = max_len[last_a] + 1;\\n                    last_a = i;\\n                }\\n            }\\n            \\n            if (s[i] == \\'b\\') {\\n                if (last_b == -1) {\\n                    last_b = i;\\n                    if (last_a == -1)\\n                        max_len[i] = 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a] + 1,1);\\n                } else {\\n                    if (last_a == -1)\\n                        max_len[i] = max_len[last_b] + 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a], max_len[last_b]) + 1;\\n                    last_b = i;\\n                }\\n            }\\n        }\\n        \\n        int maxmm = -1;\\n        for (int i = 0; i < len; i++)\\n            maxmm = max(maxmm, max_len[i]);\\n        \\n        return len - maxmm;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int last_a = -1;\\n        int last_b = -1;\\n    \\n        int len = s.size();\\n        int max_len[len];\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (s[i] == \\'a\\') {\\n                if (last_a == -1) {\\n                    last_a = i;\\n                    max_len[i] = 1;\\n                } else {\\n                    max_len[i] = max_len[last_a] + 1;\\n                    last_a = i;\\n                }\\n            }\\n            \\n            if (s[i] == \\'b\\') {\\n                if (last_b == -1) {\\n                    last_b = i;\\n                    if (last_a == -1)\\n                        max_len[i] = 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a] + 1,1);\\n                } else {\\n                    if (last_a == -1)\\n                        max_len[i] = max_len[last_b] + 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a], max_len[last_b]) + 1;\\n                    last_b = i;\\n                }\\n            }\\n        }\\n        \\n        int maxmm = -1;\\n        for (int i = 0; i < len; i++)\\n            maxmm = max(maxmm, max_len[i]);\\n        \\n        return len - maxmm;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163332,
                "title": "javascript-3-unique-solutions-stack-dp",
                "content": "Time: `O(N)`\\nSpace: `O(N)`\\n## Solution 1: Stack\\n```javascript\\nvar minimumDeletions = function(s) {\\n    const stack = [];\\n    let count = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        if(stack.length && stack[stack.length-1] > s[i]) {\\n            count++;\\n            stack.pop();\\n        } else {\\n            stack.push(s[i]);\\n        }\\n    }\\n    return count;\\n};\\n```\\n## Solution 2: DP\\n```javascript\\nvar minimumDeletions = function(s) {\\n    const dp = [0];\\n    let bCount = 0;\\n    \\n    if(s[0] == \\'b\\') bCount++;\\n    \\n    for(let i = 1; i < s.length; i++) {\\n        if(s[i] === \\'a\\') {\\n            dp[i] = Math.min(dp[i-1] + 1, bCount);\\n        } else {\\n            dp[i] = dp[i-1];\\n            bCount++\\n        }\\n    }\\n    return dp[s.length-1];\\n};\\n```\\n## Solution 3\\n```\\nvar minimumDeletions = function(s) {\\n    const aList = [], bList = [];\\n    let countA = 0, countB = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let j = s.length - 1 - i; // going backwards\\n        if(s[i] === \\'b\\') countB++;\\n        if(s[j] === \\'a\\') countA++;\\n        bList[i] = countB;\\n        aList[j] = countA;\\n    }\\n    \\n    function deleteCount(idx, til) {\\n        if(idx >= s.length-1) return 0;\\n        \\n        if(s[idx] === \\'b\\' && s[idx+1] === \\'a\\') {\\n            const deleteA = aList[idx];\\n            const deleteB = deleteCount(idx+2, idx) + bList[idx] - (bList[til] || 0);\\n            return Math.min(deleteA, deleteB);\\n        }\\n        return deleteCount(idx+1, til);\\n    }\\n    return deleteCount(0, -1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```javascript\\nvar minimumDeletions = function(s) {\\n    const stack = [];\\n    let count = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        if(stack.length && stack[stack.length-1] > s[i]) {\\n            count++;\\n            stack.pop();\\n        } else {\\n            stack.push(s[i]);\\n        }\\n    }\\n    return count;\\n};\\n```\n```javascript\\nvar minimumDeletions = function(s) {\\n    const dp = [0];\\n    let bCount = 0;\\n    \\n    if(s[0] == \\'b\\') bCount++;\\n    \\n    for(let i = 1; i < s.length; i++) {\\n        if(s[i] === \\'a\\') {\\n            dp[i] = Math.min(dp[i-1] + 1, bCount);\\n        } else {\\n            dp[i] = dp[i-1];\\n            bCount++\\n        }\\n    }\\n    return dp[s.length-1];\\n};\\n```\n```\\nvar minimumDeletions = function(s) {\\n    const aList = [], bList = [];\\n    let countA = 0, countB = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let j = s.length - 1 - i; // going backwards\\n        if(s[i] === \\'b\\') countB++;\\n        if(s[j] === \\'a\\') countA++;\\n        bList[i] = countB;\\n        aList[j] = countA;\\n    }\\n    \\n    function deleteCount(idx, til) {\\n        if(idx >= s.length-1) return 0;\\n        \\n        if(s[idx] === \\'b\\' && s[idx+1] === \\'a\\') {\\n            const deleteA = aList[idx];\\n            const deleteB = deleteCount(idx+2, idx) + bList[idx] - (bList[til] || 0);\\n            return Math.min(deleteA, deleteB);\\n        }\\n        return deleteCount(idx+1, til);\\n    }\\n    return deleteCount(0, -1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1133563,
                "title": "c-3-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int lasta = 0, lastb = 0;\\n        for(char i:s){\\n            if(i == \\'a\\') lastb++;\\n            else lastb=min(lasta++,lastb);\\n        }\\n        return min(lasta,lastb);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int lasta = 0, lastb = 0;\\n        for(char i:s){\\n            if(i == \\'a\\') lastb++;\\n            else lastb=min(lasta++,lastb);\\n        }\\n        return min(lasta,lastb);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937912,
                "title": "c-prefix-sum-with-explanation-and-example",
                "content": "A balance string is simply a lexical sorted string (all the `a` appear at left, `b` at right).\\nThe idea is to find the rightmost `a` in the longest balanced string.\\n\\ne.g. `s = \"aababbab\"`\\n\\nif choosing the `a` in index 6 as the last `a`, I will have to delete all the `b` at its left, and all the `a` at its right.\\n```\\n\"aababbab\"\\n       ^\\n\"aaxaxxxb\"\\n```\\nHowever, if I choose the `a` in index 3, I only have to delete `b` in index 2, `a` in index 6.\\n```\\n\"aababbab\"\\n    ^\\n\"aaxabbxb\"\\n```\\nBy observation, I have to use some way to efficiently get the number of `b`s on a given `a`\\'s left, and the number of `a`s on it\\'s right.\\n\\nThe way to achieve that is to use prefix sum:\\n```\\ns        = \"aababbab\"\\nas       = 432211100\\nbs       = 000112334\\n-----------------------\\ndeletion =  32323434\\n```\\nYou can see that the minimum deletion occurs when you choose `a` at index 1 and 3, which yields the answer `2`.\\n\\nNote: for handling cases that does not contain `a`, I add a dummy `a` infront of the original string. (that does not affect the answer since it is already at it\\'s right place)\\n```\\nint minimumDeletions(string s) {\\n    s = \\'a\\' + s;\\n    vector<int> as(s.size()+1);\\n    vector<int> bs(s.size()+1);\\n    int n = s.size();\\n\\n    for (int i = 0; i < s.size(); i++) {\\n      as[n-i-1] = as[n-i] + (s[n-i-1] == \\'a\\');\\n      bs[i+1] = bs[i] + (s[i] == \\'b\\');\\n    }\\n    \\n    int ans = n;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (s[i] == \\'a\\') {\\n        ans = min(ans, as[i+1] + bs[i]);\\n      }\\n    }\\n    \\n    return ans;\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\n\"aababbab\"\\n       ^\\n\"aaxaxxxb\"\\n```\n```\\n\"aababbab\"\\n    ^\\n\"aaxabbxb\"\\n```\n```\\ns        = \"aababbab\"\\nas       = 432211100\\nbs       = 000112334\\n-----------------------\\ndeletion =  32323434\\n```\n```\\nint minimumDeletions(string s) {\\n    s = \\'a\\' + s;\\n    vector<int> as(s.size()+1);\\n    vector<int> bs(s.size()+1);\\n    int n = s.size();\\n\\n    for (int i = 0; i < s.size(); i++) {\\n      as[n-i-1] = as[n-i] + (s[n-i-1] == \\'a\\');\\n      bs[i+1] = bs[i] + (s[i] == \\'b\\');\\n    }\\n    \\n    int ans = n;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (s[i] == \\'a\\') {\\n        ans = min(ans, as[i+1] + bs[i]);\\n      }\\n    }\\n    \\n    return ans;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 935739,
                "title": "python-solution",
                "content": "Initialize `res = [0] * len(s)`, and let `res[i]` be the solution of the problem for `s[:i + 1]`, i.e., `res[i]` is the number of minimum deletions to make `s[:i+1]` balanced. It\\'s easy to see that `res[0] = 0`, because a single character is always balanced. Then we loop `i` over `range(1, len(s))`, we know that if `s[i] == \\'b\\'`, then `res[i] = res[i - 1]`, because a trailing `\\'b\\'` appending to a balanced string will always be balanced. Hence the minimum deletion that makes `s[:i]` balanced will also make `s[:i+1]` balanced; Otherwise if `s[i] == \\'a\\'`, then `res[i] = min(res[i - 1] + 1, count_b)`, where `count_b` is the number of `\\'b\\'`s in `s[:i]`, this is because to make `s[:i+1]` balanced, we have two options -- either delete the last `a`, in which case the minimum deletion to make `s[:i+1]` balanced is `res[i - 1] + 1`, or delete all the `b`s in `s[:i]`, in  which case the minimum deletion to make `s[:i+1]` balanced is `count_b`. The overall minimum is then `res[i] = min(res[i - 1] + 1, count_b)`. Finally, we return `res[-1]` to be the solution of the problem.\\n\\nTime complexity: O(n), space complexity: O(n).\\n\\nSpace complexity can be further reduced to O(1), because we don\\'t really need the array `res`, we only need to save the minimum deletions for the previous iteration.\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        res = [0] * n\\n        count_b = 0\\n        if s[0] == \\'b\\':\\n            count_b = 1\\n        for i in range(1, n):\\n            if s[i] == \\'a\\':\\n                res[i] = min(1 + res[i - 1], count_b)\\n            else:\\n                count_b += 1\\n                res[i] = res[i - 1]\\n        return res[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        res = [0] * n\\n        count_b = 0\\n        if s[0] == \\'b\\':\\n            count_b = 1\\n        for i in range(1, n):\\n            if s[i] == \\'a\\':\\n                res[i] = min(1 + res[i - 1], count_b)\\n            else:\\n                count_b += 1\\n                res[i] = res[i - 1]\\n        return res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935455,
                "title": "java-easy-stack-solution",
                "content": "We iterate through the string and greedily adjust to make sure there are no (a)\\'s after any (b)\\'s. If we do, we remove the (b) and add to our min counter.\\n```\\n    public int minimumDeletions(String s) {\\n        Stack<Character> st = new Stack<>();\\n        int min = 0;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (!st.isEmpty() && st.peek() > c) {\\n                st.pop();\\n                min++;\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        \\n        return min;\\n    }",
                "solutionTags": [],
                "code": "We iterate through the string and greedily adjust to make sure there are no (a)\\'s after any (b)\\'s. If we do, we remove the (b) and add to our min counter.\\n```\\n    public int minimumDeletions(String s) {\\n        Stack<Character> st = new Stack<>();\\n        int min = 0;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (!st.isEmpty() && st.peek() > c) {\\n                st.pop();\\n                min++;\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        \\n        return min;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 935406,
                "title": "c-dp-o-n-easy-to-understand",
                "content": "Algorithm:\\n\\t1. Use DP to record the number of a and b.\\n\\t2. Find the suitable index(How to is in Implementation).\\n\\t3. Erase all \"b\"\\'s left to the index.\\n\\t4. Erase all \"a\"\\'s right to the index.\\n\\nImplementation:\\n\\t1.dp_a records frequency of \"a\" from right to left\\n\\t2.dp_b records frequency of \"b\" from left to right\\n\\t3.sum up dp_a and dp_b and find the smallest value substracted by 1\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp_a(s.size(),0);\\n        vector<int>dp_b(s.size(),0);\\n\\t\\t//record b\\n        for(int i = 0 ; i < s.size();++i){\\n            if(i==0&&s[i]==\\'b\\')\\n                dp_b[i]=1;\\n            else if(i==0&&s[i]==\\'a\\')\\n                dp_b[i]=0;\\n            else if(s[i]==\\'b\\')\\n                dp_b[i] = dp_b[i-1]+1;\\n            else\\n                dp_b[i]=dp_b[i-1];\\n        }\\n\\t\\t//record a\\n        for(int i = s.size()-1 ;i>=0;--i){\\n            if(i==s.size()-1&&s[i]==\\'a\\')\\n                dp_a[i]=1;\\n            else if(i==s.size()-1&&s[i]==\\'b\\')\\n                dp_a[i]=0;\\n            else if(s[i]==\\'a\\')\\n                dp_a[i] = dp_a[i+1]+1;\\n            else\\n                dp_a[i] = dp_a[i+1];\\n        }\\n\\t\\t//sum up dp_a and dp_b and find the smallest one\\n        int res=INT_MAX;\\n        for(int i = 0 ; i < s.size() ;++i){\\n            res=min(dp_b[i]+dp_a[i],res);\\n        }\\n        return res-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp_a(s.size(),0);\\n        vector<int>dp_b(s.size(),0);\\n\\t\\t//record b\\n        for(int i = 0 ; i < s.size();++i){\\n            if(i==0&&s[i]==\\'b\\')\\n                dp_b[i]=1;\\n            else if(i==0&&s[i]==\\'a\\')\\n                dp_b[i]=0;\\n            else if(s[i]==\\'b\\')\\n                dp_b[i] = dp_b[i-1]+1;\\n            else\\n                dp_b[i]=dp_b[i-1];\\n        }\\n\\t\\t//record a\\n        for(int i = s.size()-1 ;i>=0;--i){\\n            if(i==s.size()-1&&s[i]==\\'a\\')\\n                dp_a[i]=1;\\n            else if(i==s.size()-1&&s[i]==\\'b\\')\\n                dp_a[i]=0;\\n            else if(s[i]==\\'a\\')\\n                dp_a[i] = dp_a[i+1]+1;\\n            else\\n                dp_a[i] = dp_a[i+1];\\n        }\\n\\t\\t//sum up dp_a and dp_b and find the smallest one\\n        int res=INT_MAX;\\n        for(int i = 0 ; i < s.size() ;++i){\\n            res=min(dp_b[i]+dp_a[i],res);\\n        }\\n        return res-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935377,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        l, r = 0, n - 1\\n        c = Counter(s)\\n        res = 0\\n        while l < r:\\n            if s[r] == \\'b\\':\\n                r -= 1\\n                c[\\'b\\'] -= 1\\n                continue\\n            elif s[l] == \\'a\\':\\n                l += 1\\n                c[\\'a\\'] -= 1\\n                continue\\n            else: # b - a\\n                if c[\\'a\\'] <= c[\\'b\\']:\\n                    c[\\'a\\'] -= 1\\n                    res += 1\\n                    r -= 1\\n                else:\\n                    c[\\'b\\'] -= 1\\n                    res += 1\\n                    l += 1\\n        return res\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        l, r = 0, n - 1\\n        c = Counter(s)\\n        res = 0\\n        while l < r:\\n            if s[r] == \\'b\\':\\n                r -= 1\\n                c[\\'b\\'] -= 1\\n                continue\\n            elif s[l] == \\'a\\':\\n                l += 1\\n                c[\\'a\\'] -= 1\\n                continue\\n            else: # b - a\\n                if c[\\'a\\'] <= c[\\'b\\']:\\n                    c[\\'a\\'] -= 1\\n                    res += 1\\n                    r -= 1\\n                else:\\n                    c[\\'b\\'] -= 1\\n                    res += 1\\n                    l += 1\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 4030220,
                "title": "c-without-dp-lis-prefix-suffix-o-n-tc-o-1-sc",
                "content": "# Intuition\\nAs also mentioned in Hint , we need to find for every index the number of Bs before it and the number of A\\'s after it and the minimum one will be our answer .\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int cnta = 0, cntb = 0, ans = 1e5;\\n        for(auto i : s) cnta += i == \\'a\\';\\n        \\n        // Delete all the a\\'s that could be possible ans \\n        ans = cnta;\\n\\n        for(int i = 0 ; i<s.length() ; i++){\\n            cntb += s[i] == \\'b\\';\\n            cnta -= s[i] == \\'a\\';\\n\\n            ans = min(ans, cntb+cnta);\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int cnta = 0, cntb = 0, ans = 1e5;\\n        for(auto i : s) cnta += i == \\'a\\';\\n        \\n        // Delete all the a\\'s that could be possible ans \\n        ans = cnta;\\n\\n        for(int i = 0 ; i<s.length() ; i++){\\n            cntb += s[i] == \\'b\\';\\n            cnta -= s[i] == \\'a\\';\\n\\n            ans = min(ans, cntb+cnta);\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877461,
                "title": "lis-binary-search-tc-o-nlogn-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlength of LIS using binary search.\\n`Result = size of string - lengthOfLIS`\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(const char& ch : s) {\\n            if(ch == \\'a\\') nums.push_back(0);\\n            else nums.push_back(1);\\n        }\\n\\n        return s.size() - lengthOfLIS(nums);\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> lis;\\n        lis.push_back(nums[0]);\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] >= lis.back())\\n                lis.push_back(nums[i]);\\n            else{\\n                int idx = findCeil(lis, 0, lis.size(), nums[i]);\\n                lis[idx] = nums[i];\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n    \\n    int findCeil(vector<int> &lis, int l, int r, int x){\\n        while(l<r){\\n            int m = l + (r-l)/2;\\n            if(lis[m] > x)\\n                r = m;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return r;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(const char& ch : s) {\\n            if(ch == \\'a\\') nums.push_back(0);\\n            else nums.push_back(1);\\n        }\\n\\n        return s.size() - lengthOfLIS(nums);\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> lis;\\n        lis.push_back(nums[0]);\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] >= lis.back())\\n                lis.push_back(nums[i]);\\n            else{\\n                int idx = findCeil(lis, 0, lis.size(), nums[i]);\\n                lis[idx] = nums[i];\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n    \\n    int findCeil(vector<int> &lis, int l, int r, int x){\\n        while(l<r){\\n            int m = l + (r-l)/2;\\n            if(lis[m] > x)\\n                r = m;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return r;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824477,
                "title": "very-easy-stack-solution-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ans = 0;\\n\\n        stack<char> st;\\n\\n        for(int i=0;i<s.size();i++){\\n\\n            if(s[i]==\\'a\\'){\\n            if(!st.empty()){\\n                char top = st.top();\\n                if(top==\\'b\\') ans++;\\n                st.pop();\\n                }\\n            }\\n            else{\\n                st.push(\\'b\\');\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ans = 0;\\n\\n        stack<char> st;\\n\\n        for(int i=0;i<s.size();i++){\\n\\n            if(s[i]==\\'a\\'){\\n            if(!st.empty()){\\n                char top = st.top();\\n                if(top==\\'b\\') ans++;\\n                st.pop();\\n                }\\n            }\\n            else{\\n                st.push(\\'b\\');\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760035,
                "title": "simple-python-solution-using-dynamic-programming",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` python3 []\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_cnt = s.count(\\'a\\')\\n        result = a_cnt\\n        left_b = 0\\n        right_a = a_cnt\\n\\n        for char in s:\\n            if char == \\'a\\':\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n            result = min(result, right_a + left_b)\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "``` python3 []\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_cnt = s.count(\\'a\\')\\n        result = a_cnt\\n        left_b = 0\\n        right_a = a_cnt\\n\\n        for char in s:\\n            if char == \\'a\\':\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n            result = min(result, right_a + left_b)\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203527,
                "title": "python-idea-of-moving-partition-with-detailed-explanation-easy-understanding",
                "content": "# Intuition\\nWe need to find a partition such that if we remove the number of \"b\" to the left of that partition and remove the number of \"a\" on the right of that partition we get a balanced string. Details and example is shown below.\\n\\nWe would then check if the number of deletions with that particular partition and checck if this is a candidate for the minimum number of deletions. \\n\\n# Approach\\nWe can visualize the partition as following:-\\n\\nGiven s = \"aababbab\"\\n\\n`Partition at index 0: \" | aababbab \"` -> To make this balanced remove all b\\'s on left of the partition and remove all a\\'s on the right. So with this partition we would convert the string into \"bbbb\" since we would have to remove all a\\'s to the right(no b\\'s on the left of the partition)\\n\\n`Partition at index 1: \" a | ababbab \"` -> Following the above logic we try to convert it to a balanced string \"abbbb\" and check if the resultant string is a candidate for the answer by comparing to the current answer.\\n\\n`Partition at index 2: \" aa | babbab \"` -> possible balanced string is \"aabbbb\". So total 2 deletions of a\\'s on the right\\n\\n`Partition at index 3: \"aab | abbab\"` -> \"aabbb\"\\n`Partition at index 4: \" aaba | bbab \"` -> \"aaabbb\"\\n`Partition at index 5: \" aabab | bab \"` -> \"aaabb\"\\n`Partition at index 6: \" aababb | ab \"` -> \"aaab\"\\n`Partition at index 7: \" aababba | b \"` -> \"aaaab\"\\n`Partition at index 8: \" aababbab | \"` -> \"aaaa\"\\n\\n**Implementation :-**\\nMaintain variables to keep the count of a\\'s on left and right of partition and the number of b\\'s on the left and right. \\n\\nI have named them as `left_a, left_b, right_a, right_b`. Just add or subtract them as we move the partition. \\n\\nRather than explicitly moving a \"partition\" from LEFT to RIGHT, I am adding the characters into the LEFT-HALF of the partition as the implementation becomes easy that way. \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        C = Counter(s)\\n        left_a, left_b = 0, 0\\n        right_a, right_b = C[\"a\"], C[\"b\"]\\n\\n        deletions = right_a\\n        for char in s:\\n            if char == \"a\":\\n                right_a -= 1\\n                left_a += 1\\n            else:\\n                left_b += 1\\n                right_b -= 1\\n            deletions = min(deletions, left_b + right_a)\\n        \\n        return deletions\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        C = Counter(s)\\n        left_a, left_b = 0, 0\\n        right_a, right_b = C[\"a\"], C[\"b\"]\\n\\n        deletions = right_a\\n        for char in s:\\n            if char == \"a\":\\n                right_a -= 1\\n                left_a += 1\\n            else:\\n                left_b += 1\\n                right_b -= 1\\n            deletions = min(deletions, left_b + right_a)\\n        \\n        return deletions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086296,
                "title": "python-stack-approach",
                "content": "It is given that the string can be balanced, only if there are no pairs like -> \"ba\" in the string. \\n\\nAnd that\\'s the only thing which will make the string invalid. Hence, what we can do is, whenever we come across a situation where the previous character was a \"b\" but the current character is an \"a\", we know we have to make one deletion here. \\n\\nSo, we can simply use a stack to keep track of all the previous \"b\" and whenever we come across an \"a\", we can then check whether we have a \"b\" in the stack. If yes, it means, one deletion has to be made.\\n\\n```\\ndef minimumDeletions(self, s: str) -> int:\\n        # Since we want to ensure that the string is balanced in such as way that\\n        # There is no \"a\" after \"b\" in the final string\\n        # It means, whenever we come across something like \"ba\", we know we have to make one deletion\\n        deletions = 0\\n        \\n        # We will use this stack to put the \"b\" in it whenever we come across one\\n        # In short, this stack is only to keep track of previous \"b\"\\n        stack = []\\n        \\n        # Go through each character of the string\\n        for c in s:\\n            # If this is an \"a\"\\n            if c == \"a\":\\n                # Then, if the stack is not empty\\n                # It means, there was a \"b\" before it\\n                # So we need to make a deletion here\\n                if stack:\\n                    stack.pop()\\n                    deletions += 1\\n            # If it is a \"b\", just push it to the stack\\n            else: stack.append(c)\\n                \\n        return deletion\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef minimumDeletions(self, s: str) -> int:\\n        # Since we want to ensure that the string is balanced in such as way that\\n        # There is no \"a\" after \"b\" in the final string\\n        # It means, whenever we come across something like \"ba\", we know we have to make one deletion\\n        deletions = 0\\n        \\n        # We will use this stack to put the \"b\" in it whenever we come across one\\n        # In short, this stack is only to keep track of previous \"b\"\\n        stack = []\\n        \\n        # Go through each character of the string\\n        for c in s:\\n            # If this is an \"a\"\\n            if c == \"a\":\\n                # Then, if the stack is not empty\\n                # It means, there was a \"b\" before it\\n                # So we need to make a deletion here\\n                if stack:\\n                    stack.pop()\\n                    deletions += 1\\n            # If it is a \"b\", just push it to the stack\\n            else: stack.append(c)\\n                \\n        return deletion\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2793615,
                "title": "python-98-beats-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\n        l=len(s)\\n        i=0\\n        while i<l and s[i]!=\\'b\\':\\n            i+=1\\n        j=l-1\\n        while j>=0 and s[j]!=\\'a\\':\\n            j-=1\\n        if i==l or j==-1:\\n            return 0\\n        \\n        ca=0\\n        cb=0\\n        ans=0\\n        for k in range(i,j+1):\\n            if s[k]==\\'a\\':\\n                if cb>0: \\n                    if ca>=cb:\\n                        ans+=cb\\n                        ca=0\\n                        cb=0\\n                    else:\\n                        ca+=1\\n            else:\\n                cb+=1\\n        ans+=min(ca,cb)\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\n        l=len(s)\\n        i=0\\n        while i<l and s[i]!=\\'b\\':\\n            i+=1\\n        j=l-1\\n        while j>=0 and s[j]!=\\'a\\':\\n            j-=1\\n        if i==l or j==-1:\\n            return 0\\n        \\n        ca=0\\n        cb=0\\n        ans=0\\n        for k in range(i,j+1):\\n            if s[k]==\\'a\\':\\n                if cb>0: \\n                    if ca>=cb:\\n                        ans+=cb\\n                        ca=0\\n                        cb=0\\n                    else:\\n                        ca+=1\\n            else:\\n                cb+=1\\n        ans+=min(ca,cb)\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633113,
                "title": "c-using-prefix-and-suffix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int l[n];//number of b\\'s from left\\n        int r[n];//number of a\\'s from right\\n        l[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            l[i]=l[i-1];\\n            l[i]+=(s[i-1]==\\'b\\')? 1:0;\\n        }\\n        r[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            r[i]=r[i+1];\\n            r[i]+=(s[i+1]==\\'a\\')? 1:0;\\n        }\\n        int ans=INT_MAX;\\n        //for(int i=0;i<n;i++){cout<<r[i]<<\" \";}\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,l[i]+r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int l[n];//number of b\\'s from left\\n        int r[n];//number of a\\'s from right\\n        l[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            l[i]=l[i-1];\\n            l[i]+=(s[i-1]==\\'b\\')? 1:0;\\n        }\\n        r[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            r[i]=r[i+1];\\n            r[i]+=(s[i+1]==\\'a\\')? 1:0;\\n        }\\n        int ans=INT_MAX;\\n        //for(int i=0;i<n;i++){cout<<r[i]<<\" \";}\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,l[i]+r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2568565,
                "title": "python-solution",
                "content": "use b to count current number of \"b\", use res to keep tracking current solution, res[0] is min deletions needed if keeping current \"a\", res[1] is min deletions needed if not keeping current \"a\".\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, res = 0, [0, 0]\\n        for c in s:\\n            if c == \"a\":\\n                res = [b, min(res) + 1]\\n            else:\\n                b += 1\\n        return min(res)\\n```\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, a = 0, s.count(\"a\")\\n        res = a\\n        for c in s:\\n            if c == \"a\":\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, res = 0, [0, 0]\\n        for c in s:\\n            if c == \"a\":\\n                res = [b, min(res) + 1]\\n            else:\\n                b += 1\\n        return min(res)\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, a = 0, s.count(\"a\")\\n        res = a\\n        for c in s:\\n            if c == \"a\":\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524041,
                "title": "monotonic-string-solution",
                "content": "MInimum number of deletions =Minimum flip required to convert into montonic string\\n\\t\\t   \\n\\t\\t   int count_b=0;\\n        int flip=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                count_b++;\\n            else\\n                flip++;\\n            \\n            flip=min(count_b,flip);\\n        }\\n        \\n        return flip;\\n    }",
                "solutionTags": [],
                "code": "MInimum number of deletions =Minimum flip required to convert into montonic string\\n\\t\\t   \\n\\t\\t   int count_b=0;\\n        int flip=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                count_b++;\\n            else\\n                flip++;\\n            \\n            flip=min(count_b,flip);\\n        }\\n        \\n        return flip;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2520410,
                "title": "c-o-n-tc-space-complexity-o-1",
                "content": "* Iterate from last index to \\'0\\'.\\n* Keep the count of \\'a\\'\\n* If \\'b\\' encounters decrease count_of_a and increase your ans by 1\\n\\n\\n\\nclass Solution {\\npublic:\\n    int find_collision(string &s){\\n         int n = s.size();\\n        \\n        \\n        int ct_a=0;    // counter for \\'a\\'\\n        int ans=0;     // our answer\\n        \\n        for(int i = n-1 ; i>=0; --i){\\n            if(s[i]==\\'a\\')ct_a++;\\n            else if(s[i]==\\'b\\' && ct_a>0){\\n                ++ans; \\n                --ct_a;\\n            }\\n        }\\n        \\n        return ans;\\n      \\n    }\\n    \\n    \\n    \\n   int minimumDeletions(string s) {\\n      return find_collision(s);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int find_collision(string &s){\\n         int n = s.size();\\n        \\n        \\n        int ct_a=0;    // counter for \\'a\\'\\n        int ans=0;     // our answer\\n        \\n        for(int i = n-1 ; i>=0; --i){\\n            if(s[i]==\\'a\\')ct_a++;\\n            else if(s[i]==\\'b\\' && ct_a>0){\\n                ++ans; \\n                --ct_a;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2405583,
                "title": "partition-at-every-index-very-simple-c-solution",
                "content": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n\\n// get the number of characters that can be included in balanced string \\n\\n// keeping count for the number of a\\'s on left side\\n// traverse the string , making partition around every index \\n\\n\\nint minimumDeletions(string s) {    \\n    int n = s.size();\\n    int maxi = 0;\\n    int a_left = 0, b_right = 0;\\n\\n    for(char ch : s) {\\n        if(ch == \\'b\\') b_right++;\\n    }\\n\\n    for(int i = 0; i < n; i++) {\\n        if(s[i] == \\'a\\') {\\n            a_left++;\\n            maxi = max(maxi, a_left + b_right);\\n        }\\n        else  {\\n            // maxi = max(maxi, a_left + b_right);\\n            b_right--;\\n        }\\n    }\\n\\n    return n - maxi;\\n}\\n\\n\\nint main() {   \\n    string s = \"babaabbba\";\\n    cout<<minimumDeletions(s)<<endl;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n\\n// get the number of characters that can be included in balanced string \\n\\n// keeping count for the number of a\\'s on left side\\n// traverse the string , making partition around every index \\n\\n\\nint minimumDeletions(string s) {    \\n    int n = s.size();\\n    int maxi = 0;\\n    int a_left = 0, b_right = 0;\\n\\n    for(char ch : s) {\\n        if(ch == \\'b\\') b_right++;\\n    }\\n\\n    for(int i = 0; i < n; i++) {\\n        if(s[i] == \\'a\\') {\\n            a_left++;\\n            maxi = max(maxi, a_left + b_right);\\n        }\\n        else  {\\n            // maxi = max(maxi, a_left + b_right);\\n            b_right--;\\n        }\\n    }\\n\\n    return n - maxi;\\n}\\n\\n\\nint main() {   \\n    string s = \"babaabbba\";\\n    cout<<minimumDeletions(s)<<endl;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2383148,
                "title": "no-dp-simple-programming-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int n=s.size();\\n        \\n        int sol = INT_MAX;  int a=0, b=0, c1=0, c2=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'a\\') c1++;  else c2++;\\n        }\\n        if(c1==0 || c2==0) return 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sol = min(sol, (b + (c1-a)));\\n            if(s[i]==\\'a\\') a++;  else b++;\\n        }\\n        sol = min(sol, (b + (c1-a)));\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int n=s.size();\\n        \\n        int sol = INT_MAX;  int a=0, b=0, c1=0, c2=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'a\\') c1++;  else c2++;\\n        }\\n        if(c1==0 || c2==0) return 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sol = min(sol, (b + (c1-a)));\\n            if(s[i]==\\'a\\') a++;  else b++;\\n        }\\n        sol = min(sol, (b + (c1-a)));\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271337,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        int cntl = 0, cntr = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'b\\'){\\n                cntl++;\\n            }\\n            left[i] = cntl;\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i]==\\'a\\'){\\n                cntr++;\\n            }\\n            right[i] = cntr;\\n        }\\n        int res = min(right[0],left[n-1]);\\n        for(int i=0; i<n-1; i++){\\n            res = min(res,left[i]+right[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        int cntl = 0, cntr = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'b\\'){\\n                cntl++;\\n            }\\n            left[i] = cntl;\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i]==\\'a\\'){\\n                cntr++;\\n            }\\n            right[i] = cntr;\\n        }\\n        int res = min(right[0],left[n-1]);\\n        for(int i=0; i<n-1; i++){\\n            res = min(res,left[i]+right[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271324,
                "title": "70-tc-and-78-sc-easy-python-solution",
                "content": "```\\ndef minimumDeletions(self, s: str) -> int:\\n\\tstart = [0]\\n\\tlast = [0]\\n\\tfor i in s:\\n\\t\\tstart.append(start[-1] + int(i==\"b\"))\\n\\tfor i in s[::-1]:\\n\\t\\tlast.append(last[-1] + int(i==\"a\"))\\n\\tans = 10000000000\\n\\tfor i in range(len(start)):\\n\\t\\tans = min(ans, start[i] + last[-i-1])\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef minimumDeletions(self, s: str) -> int:\\n\\tstart = [0]\\n\\tlast = [0]\\n\\tfor i in s:\\n\\t\\tstart.append(start[-1] + int(i==\"b\"))\\n\\tfor i in s[::-1]:\\n\\t\\tlast.append(last[-1] + int(i==\"a\"))\\n\\tans = 10000000000\\n\\tfor i in range(len(start)):\\n\\t\\tans = min(ans, start[i] + last[-i-1])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2254688,
                "title": "c-o-n-clean-code-two-approach",
                "content": "### **Approach 1: Without Stack**\\n\\nclass Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n\\t// we are initializing ans with a, to consider the case where we want to delete all occurances of a.\\n        int a = count(s.begin(), s.end(), \\'a\\'), b = 0, ans = a;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            a -= s[i] == \\'a\\';\\n            b += s[i] == \\'b\\';\\n            \\n            ans = min(ans, b + a);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n**Time: O(N), Space: O(1).**\\n\\n### **Approach 2: Using Stack**\\n\\nclass Solution {\\npublic:\\n\\n\\tint minimumDeletions(string s) {\\n    int n=s.length();\\n    stack<char> stk;\\n    int c=0;\\n    for(int i=0;i<n;i++) {\\n        if (!stk.empty() && stk.top()==\\'b\\' && s[i]==\\'a\\')\\n\\t\\t\\t\\tstk.pop(),c++;\\n\\t\\t\\telse stk.push(s[i]);\\n\\t\\t}\\n\\t\\treturn c;\\n\\t}\\n};\\n\\n**Time: O(N), Space: O(N);**\\n\\nNote: Dry run for better understanding.\\nComment below for doubt or query.\\n**PLEASE UPVOTE IF HELPFUL!!!**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n\\t// we are initializing ans with a, to consider the case where we want to delete all occurances of a.\\n        int a = count(s.begin(), s.end(), \\'a\\'), b = 0, ans = a;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            a -= s[i] == \\'a\\';\\n            b += s[i] == \\'b\\';\\n            \\n            ans = min(ans, b + a);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2209310,
                "title": "simple-java-solution-with-o-n-time-and-o-1-space",
                "content": "\\n    \\n\\tpublic int minimumDeletions(String s) {\\n        \\n\\t\\tint n=s.length();\\n\\t\\tint min=Integer.MAX_VALUE;;\\n\\t\\tint countA=0, countB=0;\\n        \\n        for(int i=0; i<n; i++)\\n            countA = s.charAt(i) == \\'a\\' ? countA+1 : countA;\\n\\n        for(int i=0; i<n; i++){\\n            countA = s.charAt(i) == \\'a\\' ? countA-1 : countA;\\n            min=Math.min(min, countA + countB);\\n            countB = s.charAt(i) == \\'b\\' ? countB+1 : countB;\\n        }\\n        \\n        return min;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    \\n\\tpublic int minimumDeletions(String s) {\\n        \\n\\t\\tint n=s.length();\\n\\t\\tint min=Integer.MAX_VALUE;;\\n\\t\\tint countA=0, countB=0;\\n        \\n        for(int i=0; i<n; i++)\\n            countA = s.charAt(i) == \\'a\\' ? countA+1 : countA;\\n\\n        for(int i=0; i<n; i++){\\n            countA = s.charAt(i) == \\'a\\' ? countA-1 : countA;\\n            min=Math.min(min, countA + countB);\\n            countB = s.charAt(i) == \\'b\\' ? countB+1 : countB;\\n        }\\n        \\n        return min;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2181270,
                "title": "o-n-and-o-nlogn-solutions-in-c",
                "content": "**Method 1:** O(NlogN) - Map \\'a\\' -> 0 and \\'b\\' -> 1. Find longest non-decreasing sub-sequence\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int len = s.length();\\n        vector <int> arr;\\n        \\n        for(int i = 0; i < len; i++) {\\n            int d = s[i] - \\'a\\';\\n                \\n            if(arr.empty()) {\\n                arr.push_back(d);\\n            }\\n            else {\\n                if(d >= arr.back()) {\\n                    arr.push_back(d);\\n                }\\n                else {\\n                    int idx = upper_bound(arr.begin(), arr.end(), d) - arr.begin();\\n                    arr[idx] = d;\\n                }\\n            }\\n        }\\n        \\n        return len - arr.size();\\n    }\\n};\\n```\\n\\n**Method 2:** O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ta = 0, tb = 0, len = s.length();\\n        for(const char &ch : s) {\\n            tb += (ch == \\'b\\');\\n            ta += (ch == \\'a\\');\\n        }\\n        \\n        int x = 0, a = 0, b = 0, res = min(tb, ta); // make all \\'a\\' or all \\'b\\'\\n        for(const char &ch : s) {\\n            a += (ch == \\'a\\');\\n            b += (ch == \\'b\\');\\n            x++;\\n            \\n            // make left part (a) and right part (b)\\n            int op = b + (ta - a);\\n            \\n            res = min(res, op);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int len = s.length();\\n        vector <int> arr;\\n        \\n        for(int i = 0; i < len; i++) {\\n            int d = s[i] - \\'a\\';\\n                \\n            if(arr.empty()) {\\n                arr.push_back(d);\\n            }\\n            else {\\n                if(d >= arr.back()) {\\n                    arr.push_back(d);\\n                }\\n                else {\\n                    int idx = upper_bound(arr.begin(), arr.end(), d) - arr.begin();\\n                    arr[idx] = d;\\n                }\\n            }\\n        }\\n        \\n        return len - arr.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ta = 0, tb = 0, len = s.length();\\n        for(const char &ch : s) {\\n            tb += (ch == \\'b\\');\\n            ta += (ch == \\'a\\');\\n        }\\n        \\n        int x = 0, a = 0, b = 0, res = min(tb, ta); // make all \\'a\\' or all \\'b\\'\\n        for(const char &ch : s) {\\n            a += (ch == \\'a\\');\\n            b += (ch == \\'b\\');\\n            x++;\\n            \\n            // make left part (a) and right part (b)\\n            int op = b + (ta - a);\\n            \\n            res = min(res, op);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127919,
                "title": "simple-o-n-java-solution-without-dp",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int[] aS = new int[s.length()];\\n        int[] bS = new int[s.length()];\\n        \\n        int cnt = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            aS[i] = cnt;\\n            if(s.charAt(i) == \\'a\\') cnt++;\\n        }\\n        \\n        cnt = 0;\\n        for(int i = 0; i< s.length(); i++) {\\n            bS[i] = cnt;\\n            if(s.charAt(i) == \\'b\\') cnt++;\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i< s.length(); i++) {\\n            ans = Math.min(ans , aS[i] + bS[i]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int[] aS = new int[s.length()];\\n        int[] bS = new int[s.length()];\\n        \\n        int cnt = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            aS[i] = cnt;\\n            if(s.charAt(i) == \\'a\\') cnt++;\\n        }\\n        \\n        cnt = 0;\\n        for(int i = 0; i< s.length(); i++) {\\n            bS[i] = cnt;\\n            if(s.charAt(i) == \\'b\\') cnt++;\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i< s.length(); i++) {\\n            ans = Math.min(ans , aS[i] + bS[i]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108657,
                "title": "simplest-shortest-solution",
                "content": "a = max len string of the form aaa....aaa with possibly 0 a\\nab = max len string of the form aaa...aabb....bb with possibly 0 a and/or 0 b\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), a = 0, ab = 0;\\n        for(char &c : s) {\\n            if (c == \\'a\\') {\\n                a++;\\n                ab = max(ab, a);\\n            } else ab++;\\n        }\\n        return n - ab;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), a = 0, ab = 0;\\n        for(char &c : s) {\\n            if (c == \\'a\\') {\\n                a++;\\n                ab = max(ab, a);\\n            } else ab++;\\n        }\\n        return n - ab;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032143,
                "title": "python-simple-o-n-find-split-point",
                "content": "Basically, we want the string to end up to be \"aaaaaaaa\", or \"bbbbbbb\" or \"aaaabbbbb\". We just need to find an optimum split point in the string, whereby number of \"b\" to the left of split point + number of \"a\" to the right of split point is the minimum. \\n\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:        \\n\\n        left_b = 0  ###Keep track of number of \"b\" to the left of split point\\n        right_a = s.count(\"a\") ###Keep track of number of \"a\" to the right of split point\\n        \\n        min_deletion = right_a ###Delete all a\\n        \\n        ###Iterate through all potential position split point\\n        for i, char in enumerate(s):\\n            if char == \"a\":\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n                \\n            min_deletion = min(min_deletion, left_b + right_a)\\n            \\n            \\n        return min_deletion\\n            \\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:        \\n\\n        left_b = 0  ###Keep track of number of \"b\" to the left of split point\\n        right_a = s.count(\"a\") ###Keep track of number of \"a\" to the right of split point\\n        \\n        min_deletion = right_a ###Delete all a\\n        \\n        ###Iterate through all potential position split point\\n        for i, char in enumerate(s):\\n            if char == \"a\":\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n                \\n            min_deletion = min(min_deletion, left_b + right_a)\\n            \\n            \\n        return min_deletion\\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013333,
                "title": "python-prefix-sum",
                "content": "The question is similar to **926. Flip String to Monotone Increasing.**\\n\\nWe can apply the same logic as in the solution for question 926, create a prefix sum and find the sum of *\\'b\\'* to the left of a position in the string and *\\'a\\'* to the right of the position in the string, this sum would be the number of deletions required to make the string balanced.\\n\\nThen find the minimum of this sum by considering every possible position in the string.\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        prefix = [0]\\n        for i in range(0,len(s)):\\n            prefix.append(prefix[-1]+1 if s[i]==\\'b\\' else prefix[-1])\\n        print(prefix)\\n        mini = float(\\'inf\\')\\n        for i in range(len(prefix)):\\n            val=prefix[i]+(len(s)-i)-(prefix[-1]-prefix[i])\\n            mini=min(mini,val)\\n        return mini if mini!=float(\\'inf\\') else 0\\n```",
                "solutionTags": [
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        prefix = [0]\\n        for i in range(0,len(s)):\\n            prefix.append(prefix[-1]+1 if s[i]==\\'b\\' else prefix[-1])\\n        print(prefix)\\n        mini = float(\\'inf\\')\\n        for i in range(len(prefix)):\\n            val=prefix[i]+(len(s)-i)-(prefix[-1]-prefix[i])\\n            mini=min(mini,val)\\n        return mini if mini!=float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011120,
                "title": "c-dp-tabulation-and-space-optimized-solution-with-explanation-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n        \\n        //============================Tabulation DP Approach O(N) Time O(N) Space==============================//\\n//         vector<int> dp(s.size()+1);\\n//         int b = 0;\\n//         dp[0] = 0;\\n//         for(int i = 1; i<=s.size(); i++)\\n//         {\\n//             if(s[i-1]==\\'a\\')\\n//             {\\n//                 dp[i] = min(1+dp[i-1],b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n//             }\\n//             else\\n//             {\\n//                 dp[i] = dp[i-1], ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n//             }\\n//         }\\n//         return dp[s.size()];\\n        \\n        \\n        //========================Space Optimized DP O(N) Time O(1) Space =================================//\\n        //Since we are only using current and previous state of the dp array...!\\n        int prev = 0, curr = 0;\\n        int b = 0;\\n        for(int i = 1; i<=s.size(); i++)\\n        {\\n            if(s[i-1]==\\'a\\')\\n            {\\n                curr = min(1+prev,b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n            }\\n            else\\n            {\\n                curr = prev, ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n            }\\n            prev = curr;\\n        }\\n        \\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n        \\n        //============================Tabulation DP Approach O(N) Time O(N) Space==============================//\\n//         vector<int> dp(s.size()+1);\\n//         int b = 0;\\n//         dp[0] = 0;\\n//         for(int i = 1; i<=s.size(); i++)\\n//         {\\n//             if(s[i-1]==\\'a\\')\\n//             {\\n//                 dp[i] = min(1+dp[i-1],b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n//             }\\n//             else\\n//             {\\n//                 dp[i] = dp[i-1], ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n//             }\\n//         }\\n//         return dp[s.size()];\\n        \\n        \\n        //========================Space Optimized DP O(N) Time O(1) Space =================================//\\n        //Since we are only using current and previous state of the dp array...!\\n        int prev = 0, curr = 0;\\n        int b = 0;\\n        for(int i = 1; i<=s.size(); i++)\\n        {\\n            if(s[i-1]==\\'a\\')\\n            {\\n                curr = min(1+prev,b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n            }\\n            else\\n            {\\n                curr = prev, ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n            }\\n            prev = curr;\\n        }\\n        \\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006722,
                "title": "easy-to-understand-dp-solution-using-python-o-n",
                "content": "First we will create two arrays of n+1 size for storing a\\'s and b\\'s count. Now, the size of array needs to be n+1 because, we want to know that what will be the answer if we want to consider the first and last index.\\nStep1. Traverse the string and store count of a\\'s from left to right in dp_fron, including a on that position, we will start filling array from index 1 not 0\\nStep2. Repeat step1 from Right to Left for b\\'s cound and for this we will start filling from index n-1\\nStep3. We will count the a\\'s count and b\\'s count of each position and store the maximum count.\\nStep4. Subtract the max count with the length of array to get number of elements to remove.\\n```\\nn=len(s)\\ndp_front=[0]*(n+1)\\ndp_last=[0]*(n+1)\\n\\n\\nfor i in range(n):\\n    if s[i]==\"a\":\\n        dp_front[i+1]=dp_front[i]+1\\n    else:\\n        dp_front[i+1]=dp_front[i]\\n\\nfor i in range(n-1,-1,-1):\\n    if s[i]==\"b\":\\n        dp_last[i]=dp_last[i+1]+1\\n    else:\\n        dp_last[i]=dp_last[i+1]\\n\\nmax_val=0\\nfor i in range(n+1):\\n    max_val=max(max_val,dp_front[i]+dp_last[i])\\nans=n-max_val\\nprint(ans)\\n\\n```\\nThanks for reading it out, hope you finds this solution useful.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nn=len(s)\\ndp_front=[0]*(n+1)\\ndp_last=[0]*(n+1)\\n\\n\\nfor i in range(n):\\n    if s[i]==\"a\":\\n        dp_front[i+1]=dp_front[i]+1\\n    else:\\n        dp_front[i+1]=dp_front[i]\\n\\nfor i in range(n-1,-1,-1):\\n    if s[i]==\"b\":\\n        dp_last[i]=dp_last[i+1]+1\\n    else:\\n        dp_last[i]=dp_last[i+1]\\n\\nmax_val=0\\nfor i in range(n+1):\\n    max_val=max(max_val,dp_front[i]+dp_last[i])\\nans=n-max_val\\nprint(ans)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1965368,
                "title": "java",
                "content": "\"\"\"\\nclass Solution \\n{\\n    public int minimumDeletions(String s) \\n    {\\n        int aLeft = 0, bLeft = 0;\\n        int aRight = findCount(s, \\'a\\'), bRight = findCount(s, \\'b\\');\\n        \\n        /*Any one of the 2 can be utilized :\\n                 -------------------\\n              | int minDel = bRight; |\\n              | int minDel = aRight; |\\n                ---------------------\\n            i.e To get the right sequence, we can either delete all the a\\'s\\n            or all the b\\'s towards the right hand side*/\\n        \\n        \\n        int minDel = aRight;\\n        \\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            //To get the valid result, we need to delete all the b\\'s appearing towards the left and all the a\\'s appearing towards the right\\n            minDel = Math.min(minDel, bLeft + aRight);\\n            \\n            //Update the 4 counter variables appropriately (aRight, aLeft, bRight, bLeft)\\n            if(s.charAt(i) == \\'a\\')\\n            {\\n                aRight -= 1;\\n                aLeft += 1;\\n            }\\n            else\\n            {\\n                bRight -= 1;\\n                bLeft += 1;\\n            }\\n        }\\n        \\n        minDel = Math.min(minDel, bLeft + aRight);\\n        return minDel;\\n    }\\n    \\n    //Returns the count of character c in the String \\n    private int findCount(String s, char c)\\n    {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == c)\\n            {\\n                count += 1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\"\"\"",
                "solutionTags": [],
                "code": "class Solution \\n{\\n    public int minimumDeletions(String s) \\n    {\\n        int aLeft = 0, bLeft = 0;\\n        int aRight = findCount(s, \\'a\\'), bRight = findCount(s, \\'b\\');\\n        \\n        /*Any one of the 2 can be utilized :\\n                 -------------------\\n              | int minDel = bRight; |\\n              | int minDel = aRight; |\\n                ---------------------\\n            i.e To get the right sequence, we can either delete all the a\\'s\\n            or all the b\\'s towards the right hand side*/\\n        \\n        \\n        int minDel = aRight;\\n        \\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            //To get the valid result, we need to delete all the b\\'s appearing towards the left and all the a\\'s appearing towards the right\\n            minDel = Math.min(minDel, bLeft + aRight);\\n            \\n            //Update the 4 counter variables appropriately (aRight, aLeft, bRight, bLeft)\\n            if(s.charAt(i) == \\'a\\')\\n            {\\n                aRight -= 1;\\n                aLeft += 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1948314,
                "title": "weeb-does-python-c-prefix-suffix-sum",
                "content": "**Python**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef minimumDeletions(self, s: str) -> int:\\n\\t\\t\\tpreSum = [0] * (len(s) + 1)\\n\\t\\t\\tsufSum = [0] * (len(s) + 1)\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif s[i] == \"a\":\\n\\t\\t\\t\\t\\tpreSum[i] += 1 + preSum[i-1]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpreSum[i] = preSum[i-1]\\n\\n\\t\\t\\t\\tif s[len(s)-i-1] == \"b\":\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += 1 + sufSum[len(s)-i]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += sufSum[len(s)-i]\\n\\n\\t\\t\\tmaxStringLength = 0\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif preSum[i] + sufSum[i] > maxStringLength:\\n\\t\\t\\t\\t\\tmaxStringLength = preSum[i] + sufSum[i]\\n\\n\\t\\t\\treturn len(s) - maxStringLength\\n\\n**C++**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumDeletions(string s) {\\n\\t\\t\\tvector<int> preSum(s.size(), 0);\\n\\t\\t\\tvector<int> sufSum(s.size(), 0);\\n\\n\\t\\t\\tif (s[0] == \\'a\\') preSum[0] = 1;\\n\\t\\t\\tif (s[s.size()-1] == \\'b\\') sufSum[s.size()-1] = 1;\\n\\n\\t\\t\\tfor (int i=1; i<s.size(); i++){\\n\\t\\t\\t\\tif (s[i] == \\'a\\') preSum[i] += 1 + preSum[i-1];\\n\\n\\t\\t\\t\\telse{preSum[i] = preSum[i-1];}\\n\\n\\t\\t\\t\\tif (s[s.size()-i-1] == \\'b\\') sufSum[s.size()-i-1] += 1 + sufSum[s.size()-i];\\n\\n\\t\\t\\t\\telse{sufSum[s.size()-i-1] += sufSum[s.size()-i];}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint maxStringLen = 0;\\n\\n\\t\\t\\tfor (int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tif (preSum[i] + sufSum[i] > maxStringLen) maxStringLen = preSum[i] + sufSum[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn s.size() - maxStringLen;\\n\\t\\t}\\n\\t};\\n\\nTake a break, watch some anime\\nCheck out **\\u6BBA\\u3057\\u611B (Love of Kill)**\\n\\n\\n# Episodes: 12\\n# Genres: Action, Romance\\n# Themes: Adult Cast, Organized Crime\\n\\nIts a nice anime, watch it",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n\\t\\tdef minimumDeletions(self, s: str) -> int:\\n\\t\\t\\tpreSum = [0] * (len(s) + 1)\\n\\t\\t\\tsufSum = [0] * (len(s) + 1)\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif s[i] == \"a\":\\n\\t\\t\\t\\t\\tpreSum[i] += 1 + preSum[i-1]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpreSum[i] = preSum[i-1]\\n\\n\\t\\t\\t\\tif s[len(s)-i-1] == \"b\":\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += 1 + sufSum[len(s)-i]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += sufSum[len(s)-i]\\n\\n\\t\\t\\tmaxStringLength = 0\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif preSum[i] + sufSum[i] > maxStringLength:\\n\\t\\t\\t\\t\\tmaxStringLength = preSum[i] + sufSum[i]\\n\\n\\t\\t\\treturn len(s) - maxStringLength\\n\\n**C++**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumDeletions(string s) {\\n\\t\\t\\tvector<int> preSum(s.size(), 0);\\n\\t\\t\\tvector<int> sufSum(s.size(), 0);\\n\\n\\t\\t\\tif (s[0] == \\'a\\') preSum[0] = 1;\\n\\t\\t\\tif (s[s.size()-1] == \\'b\\') sufSum[s.size()-1] = 1;\\n\\n\\t\\t\\tfor (int i=1; i<s.size(); i++){\\n\\t\\t\\t\\tif (s[i] == \\'a\\') preSum[i] += 1 + preSum[i-1];\\n\\n\\t\\t\\t\\telse{preSum[i] = preSum[i-1];}",
                "codeTag": "Java"
            },
            {
                "id": 1946583,
                "title": "c-o-1-space-same-as-lc926-simple-solution-with-explanation",
                "content": "We just have two options when current character `s[i]` is `a`, and we already have best solution `res` for `0~i-1` : \\n(1) delete all `b` we have counted before\\n(2) only delete current character, sum with `res`\\nso `res = min(res+1, bcnt)`\\n\\n* time: `O(n)`\\n* space: `O(1)`\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bcnt = 0, res = 0;\\n        for (auto &ch: s) {\\n            if (ch == \\'a\\') {\\n                res = min(res+1, bcnt);\\n            } else {\\n                ++bcnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bcnt = 0, res = 0;\\n        for (auto &ch: s) {\\n            if (ch == \\'a\\') {\\n                res = min(res+1, bcnt);\\n            } else {\\n                ++bcnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918029,
                "title": "elegant-c-solution",
                "content": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int cnt1=0, cnt2=0;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                cnt1++; // the number of b appearing before a\\n            }\\n            else if(cnt1>0)\\n            {\\n                cnt1--; \\n                cnt2++;  \\n            }\\n            i++;\\n        }\\n        return cnt2;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int cnt1=0, cnt2=0;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                cnt1++; // the number of b appearing before a\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1901549,
                "title": "python-o-n-stack-with-explanation",
                "content": "Idea is to count the number of pairs of \"b\" and \"a\" such that \"a\" has appeared after a \"b\"\\n        \\n\\tuse stack\\n            see b? push to stack\\n            see a?\\n                if stack not empty: \\n                     pop from the stack and count it as a deletion \\nTime and space: O(n)\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\t\\tstack = [] \\n        counter = 0 \\n        \\n        for char in s:\\n            if char == \"b\":\\n                stack.append(char)\\n            \\n            elif stack:\\n                counter += 1\\n                stack.pop()\\n        \\n        return counter \\n            \\n        \\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\t\\tstack = [] \\n        counter = 0 \\n        \\n        for char in s:\\n            if char == \"b\":\\n                stack.append(char)\\n            \\n            elif stack:\\n                counter += 1\\n                stack.pop()\\n        \\n        return counter \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897453,
                "title": "cpp-prefix-sum-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        if(n==1)\\n        {\\n            if(s[0]==\\'a\\')\\n                return 0;\\n        }\\n        vector<int> a(n,0),b(n,0);\\n        if(s[0]==\\'b\\')\\n        {\\n            b[0]=1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                b[i]=b[i-1]+1;\\n            }\\n            else\\n            {\\n                b[i]=b[i-1];\\n            }\\n        }\\n        if(s[n-1]==\\'a\\')\\n        {\\n            a[n-1]=1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                a[i]=a[i+1]+1;\\n            }\\n            else\\n            {\\n                a[i]=a[i+1];\\n            }\\n        }\\n        int mi=n;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            mi=min(mi,a[i+1]+b[i-1]);\\n        }\\n        if(b[n-1]==n||a[0]==n)\\n            return 0;\\n        mi=min(mi,a[0]);\\n        mi=min(mi,b[n-1]);\\n        return mi;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        if(n==1)\\n        {\\n            if(s[0]==\\'a\\')\\n                return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1893179,
                "title": "java-find-the-longest-valid-sequence",
                "content": "This question translates to find the longest valid sequence and the answer would be length of string minus that. \\n\\nLet `a` be the length of a valid sequence that ends with an `a`.\\nLet `b` be the length of a valid sequence that ends with an `b`.\\n\\nCase 1 - When current char equals to a: We increment `a` by 1 as there is no way to transition from a valid sequence that ends with a `b` to `a`.\\nCase 2 - When current char equals to b: We can append this `b` to either `a` or `b` to form a valid sequence, that is, we take from `max(a, b)` and plus 1.\\n\\n\\n```Java\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (char ch : s.toCharArray()){\\n            if (ch == \\'a\\'){\\n                a++;\\n            }else{\\n                b = Math.max(a, b) + 1;\\n            }\\n        }\\n\\n        return s.length() - Math.max(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (char ch : s.toCharArray()){\\n            if (ch == \\'a\\'){\\n                a++;\\n            }else{\\n                b = Math.max(a, b) + 1;\\n            }\\n        }\\n\\n        return s.length() - Math.max(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880018,
                "title": "without-stack-o-1-space",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int count=0;\\n        //stack<char> st;\\n        int countb=0;\\n        int counta=0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'b\\'){\\n                countb++;\\n            }\\n            \\n            else{\\n                counta++;\\n            }\\n            \\n            if(countb!=0 && s[i]==\\'a\\'){\\n                countb--;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int count=0;\\n        //stack<char> st;\\n        int countb=0;\\n        int counta=0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'b\\'){\\n                countb++;\\n            }\\n            \\n            else{\\n                counta++;\\n            }\\n            \\n            if(countb!=0 && s[i]==\\'a\\'){\\n                countb--;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873217,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        \\n        int ans=INT_MIN;\\n        int cntb=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                cntb++;\\n        }       \\n        int a=0,b=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                a++;\\n                ans=max(ans,a+cntb-b);\\n            }\\n            else\\n            {\\n                b++;\\n                ans=max(ans,a+cntb-b+1);\\n            }\\n            \\n        }\\n        \\n        return n-ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        \\n        int ans=INT_MIN;\\n        int cntb=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                cntb++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1813674,
                "title": "c-prefix-sum-o-n",
                "content": "**Idea**\\nThere will exist atleast one index `i` before which we have to remove all `b` and after which will have to remove all `a`. Bulid a prefix(`left`) and suffix(`right`) array which contains no. of `b` till index `i` and no. of `a` after index `i` including `i`.\\nThen calculate min no. of operations by `min(left[i-1]+right[i])`. Take care of boundary cases.\\n**Time: O(n)**\\n**Space: O(n)**\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> left(s.size(),0),right(s.size(),0);\\n        \\n        if(s[0]==\\'b\\') left[0]++;\\n        for(int i = 1; i<s.size();++i){\\n            left[i] = left[i-1];\\n            if(s[i]==\\'b\\') left[i]++;\\n        }\\n        \\n        if(s[s.size()-1]==\\'a\\') right[s.size()-1]++;\\n        for(int i = s.size()-2;i>=0;--i){\\n            right[i] = right[i+1];\\n            if(s[i]==\\'a\\') right[i]++;\\n        }\\n        \\n        int re = min(right[0],left[s.size()-1]);\\n        for(int i = 1;i<s.size()-1;++i) re = min(re,left[i-1]+right[i]);\\n        \\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> left(s.size(),0),right(s.size(),0);\\n        \\n        if(s[0]==\\'b\\') left[0]++;\\n        for(int i = 1; i<s.size();++i){\\n            left[i] = left[i-1];\\n            if(s[i]==\\'b\\') left[i]++;\\n        }\\n        \\n        if(s[s.size()-1]==\\'a\\') right[s.size()-1]++;\\n        for(int i = s.size()-2;i>=0;--i){\\n            right[i] = right[i+1];\\n            if(s[i]==\\'a\\') right[i]++;\\n        }\\n        \\n        int re = min(right[0],left[s.size()-1]);\\n        for(int i = 1;i<s.size()-1;++i) re = min(re,left[i-1]+right[i]);\\n        \\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760353,
                "title": "c-o-n-t-c-o-1-s-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n         int n = s.size();\\n        \\n           // edge case\\n           if(n == 1) return 0;\\n        \\n           int count_a = 0;\\n           for(char ch : s){\\n               if(ch == \\'a\\') count_a++;\\n           }\\n           \\n           if(count_a == 0)  return 0;\\n           int curCount_b = 0, curCount_a;\\n        \\n           int ans = INT_MAX;\\n        \\n           for(char ch : s){\\n               if(ch == \\'a\\'){\\n                   curCount_a++;\\n                   ans = min(ans, curCount_b + count_a - curCount_a);\\n               }\\n               else {\\n                      ans = min(ans, curCount_b + count_a - curCount_a); \\n                      curCount_b++;\\n               }\\n           }\\n         \\n           return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n         int n = s.size();\\n        \\n           // edge case\\n           if(n == 1) return 0;\\n        \\n           int count_a = 0;\\n           for(char ch : s){\\n               if(ch == \\'a\\') count_a++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1754652,
                "title": "javascript-iterative-dynamic-programming-explanation",
                "content": "```\\n/** https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s) {\\n  if (s.length === 1) {\\n    return 0;\\n  }\\n  \\n  let bCount = Array(s.length+1).fill(0);\\n  \\n  // Count how many \\'b\\' from `0...i-1`\\n  for (let i = 0; i < s.length; i++) {\\n    bCount[i+1] = bCount[i];\\n    \\n    if (s[i] === \\'b\\') {\\n      bCount[i+1] += 1;\\n    }\\n  }\\n  \\n  let out = Infinity;\\n  \\n  // Find the least deletion operation needed to make string balance\\n  // To achieve that, we delete all \\'a\\' on the right + all \\'b\\' on the left of `i`\\n  for (let i = 0; i < s.length; i++) {\\n    // How many \\'b\\' on the left\\n    let bOnLeft = bCount[i];\\n    \\n    // How many \\'a\\' on the right\\n    // The formula is the length of `s` (0 indexed) - current position `i` minus how many \\'b\\' on the right\\n    // How many \\'b\\' on the right is easy to calculate by taking last \\'b\\' count and minus how many \\'b\\' at `i+1` then we get \\'b\\' count from `i...s.length-1`\\n    let length = s.length - 1;\\n    let bOnRight = bCount[bCount.length - 1] - bCount[i + 1];\\n    let aOnRight = length - i - bOnRight;\\n    \\n    out = Math.min(out, bOnLeft + aOnRight);\\n  }\\n  \\n  return out;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\n/** https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s) {\\n  if (s.length === 1) {\\n    return 0;\\n  }\\n  \\n  let bCount = Array(s.length+1).fill(0);\\n  \\n  // Count how many \\'b\\' from `0...i-1`\\n  for (let i = 0; i < s.length; i++) {\\n    bCount[i+1] = bCount[i];\\n    \\n    if (s[i] === \\'b\\') {\\n      bCount[i+1] += 1;\\n    }\\n  }\\n  \\n  let out = Infinity;\\n  \\n  // Find the least deletion operation needed to make string balance\\n  // To achieve that, we delete all \\'a\\' on the right + all \\'b\\' on the left of `i`\\n  for (let i = 0; i < s.length; i++) {\\n    // How many \\'b\\' on the left\\n    let bOnLeft = bCount[i];\\n    \\n    // How many \\'a\\' on the right\\n    // The formula is the length of `s` (0 indexed) - current position `i` minus how many \\'b\\' on the right\\n    // How many \\'b\\' on the right is easy to calculate by taking last \\'b\\' count and minus how many \\'b\\' at `i+1` then we get \\'b\\' count from `i...s.length-1`\\n    let length = s.length - 1;\\n    let bOnRight = bCount[bCount.length - 1] - bCount[i + 1];\\n    let aOnRight = length - i - bOnRight;\\n    \\n    out = Math.min(out, bOnLeft + aOnRight);\\n  }\\n  \\n  return out;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1699321,
                "title": "python3-simple-and-fast-o-n-time-o-1-space",
                "content": "We should loop through the string and keep track of the number of ***a***\\'s in the right side and the number of ***b***\\'s in the left side, the minimum sum of these two counts is the answer.\\n```\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        a, b = s.count(\\'a\\'), 0\\n        res = a + b\\n        for char in s:\\n            if char == \\'a\\':\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        a, b = s.count(\\'a\\'), 0\\n        res = a + b\\n        for char in s:\\n            if char == \\'a\\':\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641169,
                "title": "c-o-n-time-space-amateur-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumDeletions(string s) {\\n        int n = s.length();\\n        \\n        \\n        \\n        //1. Calculate the number of \\'b\\'s appearing before index i\\n        vector<int> leftB(n,0); \\n        for(int i=1;i<n;i++){\\n            leftB[i] = (s[i-1] == \\'b\\') + leftB[i-1];\\n        }\\n        \\n        //2. Calculate the number of \\'a\\'s appearing after index i\\n        vector<int> rightA(n,0);\\n        for(int i=n-2;i>=0;i--){\\n            rightA[i] = (s[i+1] == \\'a\\') + rightA[i+1];\\n        }\\n        \\n        //3. deletion for each index i = leftB[i] + rightA[i]\\n        //   find the index with minimum deletions\\n        int minDeletions = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            minDeletions = min(minDeletions, leftB[i] + rightA[i]);\\n        }\\n        \\n        return minDeletions;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumDeletions(string s) {\\n        int n = s.length();\\n        \\n        \\n        \\n        //1. Calculate the number of \\'b\\'s appearing before index i\\n        vector<int> leftB(n,0); \\n        for(int i=1;i<n;i++){\\n            leftB[i] = (s[i-1] == \\'b\\') + leftB[i-1];\\n        }\\n        \\n        //2. Calculate the number of \\'a\\'s appearing after index i\\n        vector<int> rightA(n,0);\\n        for(int i=n-2;i>=0;i--){\\n            rightA[i] = (s[i+1] == \\'a\\') + rightA[i+1];\\n        }\\n        \\n        //3. deletion for each index i = leftB[i] + rightA[i]\\n        //   find the index with minimum deletions\\n        int minDeletions = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            minDeletions = min(minDeletions, leftB[i] + rightA[i]);\\n        }\\n        \\n        return minDeletions;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624492,
                "title": "java-easy-10-line-o-n-o-1-dp-solution",
                "content": "@a: maximum length of valid string end with a\\n@b: maximum length of valid string end with b\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') a = a+1;\\n            else  b = Math.max(b+1, a+1);\\n        }\\n        return s.length()-Math.max(a,b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') a = a+1;\\n            else  b = Math.max(b+1, a+1);\\n        }\\n        return s.length()-Math.max(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591448,
                "title": "dp-c-easy-to-understand",
                "content": "You can remove only all the \\'a\\' after a certain point and the \\'b\\' before that point.\\nSo you are supposed to find the minimum among all those possible value.\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ca=0,cb=0;\\n        for(auto c:s){\\n            if(c==\\'a\\')ca++;\\n            else cb++;\\n        }\\n        int n=s.length();\\n        int ans=ca;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\')a++;\\n            else b++;\\n            ans=min(ans,ca-a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ca=0,cb=0;\\n        for(auto c:s){\\n            if(c==\\'a\\')ca++;\\n            else cb++;\\n        }\\n        int n=s.length();\\n        int ans=ca;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\')a++;\\n            else b++;\\n            ans=min(ans,ca-a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583404,
                "title": "c-time-o-n-space-o-1-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // let endA[i] be the length of the longest balanced string up to position i and ending with \\'a\\'\\n    // let endB[i] be the length of the longest balanced string up to position i and ending with \\'b\\'\\n    //\\n    // now, consider position i+1\\n    //\\n    // if s[i+1] == \\'a\\', we can form a longer balanced string by appending \\'a\\'\\n\\t// to the the longest balanced string ending with \\'a\\' up to position i,\\n    // thus\\n    //    endA[i+1] = endA[i] + 1\\n    // we cannot append \\'a\\' to a string ending with \\'b\\' to form a balance string so endB stays the same\\n    //    endB[i+1] = endB[i]\\n\\t//\\n    // if s[i+1] == \\'b\\', we can form a longer balanced string by appending \\'b\\'\\n\\t// to either the longest blanced string ending with \\'b\\' or \\'a\\' up to position i,\\n    // thus\\n    //    endB[i+1] = max(endB[i], endA[i]) + 1\\n    // endA stays the same\\n    //    endA[i+1] = endA[i]\\n    //\\n    // answer will be s.size() - max(endA[n], endB[n]);\\n\\t\\n    int minimumDeletions(string s) {\\n        std::ios_base::sync_with_stdio(0);\\n        std::cin.tie(0);\\n        \\n        int endA = 0, endB = 0;\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'a\\') {\\n                endA = endA + 1;\\n            } else {\\n                endB = std::max(endB + 1, endA + 1);\\n            }\\n        }\\n        \\n        return s.size() - std::max(endA, endB);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // let endA[i] be the length of the longest balanced string up to position i and ending with \\'a\\'\\n    // let endB[i] be the length of the longest balanced string up to position i and ending with \\'b\\'\\n    //\\n    // now, consider position i+1\\n    //\\n    // if s[i+1] == \\'a\\', we can form a longer balanced string by appending \\'a\\'\\n\\t// to the the longest balanced string ending with \\'a\\' up to position i,\\n    // thus\\n    //    endA[i+1] = endA[i] + 1\\n    // we cannot append \\'a\\' to a string ending with \\'b\\' to form a balance string so endB stays the same\\n    //    endB[i+1] = endB[i]\\n\\t//\\n    // if s[i+1] == \\'b\\', we can form a longer balanced string by appending \\'b\\'\\n\\t// to either the longest blanced string ending with \\'b\\' or \\'a\\' up to position i,\\n    // thus\\n    //    endB[i+1] = max(endB[i], endA[i]) + 1\\n    // endA stays the same\\n    //    endA[i+1] = endA[i]\\n    //\\n    // answer will be s.size() - max(endA[n], endB[n]);\\n\\t\\n    int minimumDeletions(string s) {\\n        std::ios_base::sync_with_stdio(0);\\n        std::cin.tie(0);\\n        \\n        int endA = 0, endB = 0;\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'a\\') {\\n                endA = endA + 1;\\n            } else {\\n                endB = std::max(endB + 1, endA + 1);\\n            }\\n        }\\n        \\n        return s.size() - std::max(endA, endB);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566086,
                "title": "java-dp-two-states-switch",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int end_a = 0;\\n        int end_b = 0;\\n        for(char c : s.toCharArray()){\\n            int cur_end_a;\\n            int cur_end_b;\\n            if(c == \\'a\\'){\\n                cur_end_a = end_a;\\n                cur_end_b = Math.min(end_a + 1, end_b + 1);\\n            }else{\\n                cur_end_a = end_a + 1;\\n                cur_end_b = Math.min(end_a, end_b);\\n            }\\n            end_a = cur_end_a;\\n            end_b = cur_end_b;\\n        }\\n        return Math.min(end_a, end_b);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int end_a = 0;\\n        int end_b = 0;\\n        for(char c : s.toCharArray()){\\n            int cur_end_a;\\n            int cur_end_b;\\n            if(c == \\'a\\'){\\n                cur_end_a = end_a;\\n                cur_end_b = Math.min(end_a + 1, end_b + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1551143,
                "title": "o-1-space-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b = 0 , ans = 0;\\n        for(int i = 0 ;i< s.length();i++){\\n            if(s[i] == \\'a\\'){\\n                ans = min(ans+1 , b);                \\n            }\\n            else b++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b = 0 , ans = 0;\\n        for(int i = 0 ;i< s.length();i++){\\n            if(s[i] == \\'a\\'){\\n                ans = min(ans+1 , b);                \\n            }\\n            else b++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540821,
                "title": "simple-python-solution",
                "content": "```\\ndef minimumDeletions(self, st: str) -> int:\\n        bCount = 0\\n        bCarr = []\\n        ln = 0\\n        for item in st:\\n            if item == \\'b\\':\\n                bCount +=1\\n            bCarr.append(bCount)\\n            ln +=1\\n\\n        dl = 0\\n        for i in range(ln):\\n            if st[i] == \\'a\\':\\n                if bCarr[i] - dl > 0:\\n                    dl +=1\\n\\n        return dl\\n```\\n\\n981MS, 17.8MB",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minimumDeletions(self, st: str) -> int:\\n        bCount = 0\\n        bCarr = []\\n        ln = 0\\n        for item in st:\\n            if item == \\'b\\':\\n                bCount +=1\\n            bCarr.append(bCount)\\n            ln +=1\\n\\n        dl = 0\\n        for i in range(ln):\\n            if st[i] == \\'a\\':\\n                if bCarr[i] - dl > 0:\\n                    dl +=1\\n\\n        return dl\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1530385,
                "title": "c-o-n-time-complexity-and-o-1-space-complexity-simple-and-concise-solution",
                "content": "```\\nint minimumDeletions(string s) {\\n        int res=0;\\n        int count_a=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'b\\' and count_a>0)\\n            {\\n                res++;\\n                count_a--;\\n            }\\n            else\\n                {\\n                if(s[i]==\\'a\\') count_a++;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumDeletions(string s) {\\n        int res=0;\\n        int count_a=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'b\\' and count_a>0)\\n            {\\n                res++;\\n                count_a--;\\n            }\\n            else\\n                {\\n                if(s[i]==\\'a\\') count_a++;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527058,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int countB = 0;\\n        int countA = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'b\\')\\n            {\\n                countB++;\\n            }\\n            else\\n            {\\n                countA++;\\n            }\\n            countA = Math.min(countA,countB);\\n        }\\n        return countA;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumDeletions(String s) {\\n        int countB = 0;\\n        int countA = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'b\\')\\n            {\\n                countB++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1459817,
                "title": "simple-c-solutions-same-as-926-flip-string-to-monotone-increasing",
                "content": "This is same as **problem 926(Flip String to Monotone Increasing)** where we need to **flip** 1\\'s or 0\\'s to make string monotone increasing. Here, we need to **delete** a\\'s or b\\'s to make it increasing.\\n**Explanation**: For every index we can store number of b\\'s before that index (**bs in the code**) and keep a variable **del(required deletions)** and increment it when we see a\\'s and for every index find min of del and number of bs.\\n\\n```\\n\\t\\tint bs=0;\\n\\t\\tint del= 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                bs++;\\n            }\\n            else\\n            {\\n                del++;\\n            }\\n            del= min(del, bs);\\n        }\\n        return del;\\n\\t\\t\\n\\t```\\n\\n**Dry run:**\\nex: s= \"aababbab\"\\n(Here we need to delete a\\'s at index 3 and 6 to make s as \"aabbbb\")\\ni=0:\\nbs=0, del=1\\ndel= min(del, bs) =>del=  min(0, 1)=0\\ni=1:\\nbs=0, del=1\\ndel= min(del, bs) =>del=  min(0, 1)=0\\ni=2:\\nbs=1, del=0\\ndel= min(del, bs) =>del=  min(1, 0)=0\\ni=3:\\nbs=1, del=1\\ndel= min(del, bs) =>del=  min(1, 1)=1\\ni=4:\\nbs=2, del=1\\ndel= min(del, bs) =>del=  min(1, 2)=1\\ni=5:\\nbs= 3, del= 1\\ndel= min(del, bs) =>del=  min(1, 3)=1\\ni=6:\\nbs= 3, del=2\\ndel= min(del, bs) =>del=  min(2, 3)=2\\ni=7:\\nbs= 4, del=2\\ndel= min(del, bs) =>del=  min(2, 4)=2\\n\\n(Hope this is clear, pls let me know if anything\\'s not clear)\\n",
                "solutionTags": [],
                "code": "```\\n\\t\\tint bs=0;\\n\\t\\tint del= 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                bs++;\\n            }\\n            else\\n            {\\n                del++;\\n            }\\n            del= min(del, bs);\\n        }\\n        return del;\\n\\t\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1453672,
                "title": "dp-solution-o-n",
                "content": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp(s.size()+1);\\n        int bcount=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                dp[i+1]=min(1+dp[i],bcount);\\n            }\\n            else\\n            {\\n                dp[i+1]=dp[i];\\n                bcount++;\\n            }\\n        }\\n       return dp[s.size()];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp(s.size()+1);\\n        int bcount=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                dp[i+1]=min(1+dp[i],bcount);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1402109,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'a\\') {\\n                b++;\\n            } else {\\n                b = min(a, b);\\n                a++;\\n            }\\n        }\\n        return min(a, b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'a\\') {\\n                b++;\\n            } else {\\n                b = min(a, b);\\n                a++;\\n            }\\n        }\\n        return min(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395482,
                "title": "c-minimization-maximization-solution-o-n",
                "content": "**Minimization Approach:**\\n\\nThe problem is exactly similar to [926. Flip String to Monotone Increasing](https://leetcode.com/problems/flip-string-to-monotone-increasing/). Its solution is described [here](https://leetcode.com/problems/flip-string-to-monotone-increasing/discuss/1395348/C++-Solution-O(N)).\\n\\n\\n```\\nHere we have to delete char from string such that there is no i<j and s[j]=a and s[i]=b means we have to\\ndelete chars to make it monotonic increasing from a to b which is same as monotonic increasing of binary\\nstring where a=0 and b=1. Also flipping 0 to 1 and 1 to 0 can be equally considered as a delete operation\\nfor this problem. So, we use the same solution approach of 926. Flip String to Monotone Increasing. \\n```\\n\\nRuntime: 84 ms, faster than 90.98% of C++ online submissions for Minimum Deletions to Make String Balanced.\\nMemory Usage: 22 MB, less than 93.87% of C++ online submissions for Minimum Deletions to Make String Balanced.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n        \\n        //track number of delete \\n        int del = 0;\\n        \\n        // counts prefix bs \\n        int b_c = 0;\\n        \\n        for(int i=0;i<sl;i++)\\n        {\\n            // need to delete when prefix b exists, otherwise ignore\\n            if(s[i]==\\'a\\')\\n            {\\n                if(b_c>0)del++;\\n                else continue;\\n            }\\n            else b_c++; // track prefix 1 count\\n            \\n            // get the minimum between delete and b count\\n            // if delete > b count then it means there is more suffix a then prefix b\\n            del = min(del,b_c);\\n        }\\n        \\n        return del;\\n    }\\n};\\n```\\n\\n**Maximization Approach:**\\n\\n```\\nAnother way to think about this problem is finding the Length of Longest Monotonic Increasing\\nSubsequence. Then the minimum delete will be String Length - Max LMIS. \\n\\nNow as there are only 2 char type in the string we can easily calculate the Max LMIS for ending char\\na and b. Let they are a_c and b_c. Now the LMIS ending with a must contain all previous \\'a\\' char and\\nso we just increment its count. Other hand, Max LMIS ending with b can have previous a chars a_c or \\nprevious Max LMIS of ending with b, b_c and we update b_c as max(a_c,b_c) + 1. The max LMIS will be\\nthe max value between a_c and b_c at last and thus minimum delete will be String Length - Max LMIS.\\n\\nExample : \\n\\nMax LMIS ending with a => \"aaaaaaaa\"\\n\\nMax LMIS ending with b => \"aaaaaaab\"  or \"aaaabbb\" or \"bbbbbbb\"\\n```\\n\\nRuntime: 88 ms, faster than 81.27% of C++ online submissions for Minimum Deletions to Make String Balanced.\\nMemory Usage: 22 MB, less than 75.72% of C++ online submissions for Minimum Deletions to Make String Balanced.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n                \\n        // Length of LMIS ending with a\\n        int a_c = 0;\\n        // Length of LMIS ending with a\\n        int b_c = 0;\\n\\n        // loop through string and find max LMIS ending with a and b\\n        for(int i=0;i<sl;i++)\\n        {\\n            // Max LMIS ending with a can only have previous a element and so we increment its count\\n            if(s[i]==\\'a\\')a_c++;\\n            \\n            // Max LMIS ending with b can have all previous a element or previous Max LMIS ending with b elements\\n            // thus we take the max between those and add the current b\\n            else b_c = max(a_c,b_c) + 1;\\n        }\\n        \\n        // minimum delete => Total length - Max LMIS => String Length - max(a_c,b_c)\\n        return sl-max(a_c,b_c);\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nHere we have to delete char from string such that there is no i<j and s[j]=a and s[i]=b means we have to\\ndelete chars to make it monotonic increasing from a to b which is same as monotonic increasing of binary\\nstring where a=0 and b=1. Also flipping 0 to 1 and 1 to 0 can be equally considered as a delete operation\\nfor this problem. So, we use the same solution approach of 926. Flip String to Monotone Increasing. \\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n        \\n        //track number of delete \\n        int del = 0;\\n        \\n        // counts prefix bs \\n        int b_c = 0;\\n        \\n        for(int i=0;i<sl;i++)\\n        {\\n            // need to delete when prefix b exists, otherwise ignore\\n            if(s[i]==\\'a\\')\\n            {\\n                if(b_c>0)del++;\\n                else continue;\\n            }\\n            else b_c++; // track prefix 1 count\\n            \\n            // get the minimum between delete and b count\\n            // if delete > b count then it means there is more suffix a then prefix b\\n            del = min(del,b_c);\\n        }\\n        \\n        return del;\\n    }\\n};\\n```\n```\\nAnother way to think about this problem is finding the Length of Longest Monotonic Increasing\\nSubsequence. Then the minimum delete will be String Length - Max LMIS. \\n\\nNow as there are only 2 char type in the string we can easily calculate the Max LMIS for ending char\\na and b. Let they are a_c and b_c. Now the LMIS ending with a must contain all previous \\'a\\' char and\\nso we just increment its count. Other hand, Max LMIS ending with b can have previous a chars a_c or \\nprevious Max LMIS of ending with b, b_c and we update b_c as max(a_c,b_c) + 1. The max LMIS will be\\nthe max value between a_c and b_c at last and thus minimum delete will be String Length - Max LMIS.\\n\\nExample : \\n\\nMax LMIS ending with a => \"aaaaaaaa\"\\n\\nMax LMIS ending with b => \"aaaaaaab\"  or \"aaaabbb\" or \"bbbbbbb\"\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n                \\n        // Length of LMIS ending with a\\n        int a_c = 0;\\n        // Length of LMIS ending with a\\n        int b_c = 0;\\n\\n        // loop through string and find max LMIS ending with a and b\\n        for(int i=0;i<sl;i++)\\n        {\\n            // Max LMIS ending with a can only have previous a element and so we increment its count\\n            if(s[i]==\\'a\\')a_c++;\\n            \\n            // Max LMIS ending with b can have all previous a element or previous Max LMIS ending with b elements\\n            // thus we take the max between those and add the current b\\n            else b_c = max(a_c,b_c) + 1;\\n        }\\n        \\n        // minimum delete => Total length - Max LMIS => String Length - max(a_c,b_c)\\n        return sl-max(a_c,b_c);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385337,
                "title": "c-simple-intuitive-solution-with-o-1-space",
                "content": "The idea here is to maintain a counter for the number of \\'b\\'.\\nTraversing the string from left to right, when the current character is \\'b\\', simply increment the counter by 1.\\nWhen the current character is \\'a\\', check if the counter is positive. If yes, simply decrement it by 1, and increase the answer by 1.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n     \\n        int ans=0,cb=0,i=0,n=s.size();\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && cb>0)\\n            {\\n                cb--;\\n                ans++;\\n            }\\n            else if(s[i]==\\'b\\')\\n            {\\n                cb++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n     \\n        int ans=0,cb=0,i=0,n=s.size();\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && cb>0)\\n            {\\n                cb--;\\n                ans++;\\n            }\\n            else if(s[i]==\\'b\\')\\n            {\\n                cb++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345829,
                "title": "short-c-solution-o-n-time-o-1-space-w-explanation",
                "content": "The resulting string will always be some number of a\\'s then some number of b\\'s\\nSo we know that we need find a split of the string such that the number of b\\'s in the left side + the number of a\\'s on the right side is minimised\\nThis can be done in constant time by first counting how many a\\'s there are in the string then iterate through the string and count the number of a\\'s and b\\'s seen so far. We know the number of a\\'s to the right of the current position is just total number of a\\'s minus current count of a\\'s.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int at = 0, bc = 0, ac = 0;\\n        for(char c : s) if(c == \\'a\\') ++at;\\n        int ans = at;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\') ++ac;\\n            else ++bc;\\n            int dels = bc + (at - ac);\\n            ans = min(ans, dels);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int at = 0, bc = 0, ac = 0;\\n        for(char c : s) if(c == \\'a\\') ++at;\\n        int ans = at;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\') ++ac;\\n            else ++bc;\\n            int dels = bc + (at - ac);\\n            ans = min(ans, dels);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318797,
                "title": "very-intuitive-two-pointer-python-o-n-time-and-o-1-space-solution",
                "content": "The idea is to use two pointers i and j where i traverses from left to right and j traverses from right to left.\\nWhile traversing right, get to the first position where s[i] == \\'b\\' and similarly while traversing left, get to the first position where s[j] == \\'a\\'. We also keep on adjusting the count of \\'a\\' and \\'b\\' accordingly. Now we reach to a point where s[0:i] is all \\'a\\' and s[j+1:] is all \\'b\\'. At this point we need to decide whether we want to delete \\'a\\' or \\'b\\'. So we go greedy and delete that char whose count is less. So if count_a < count_b, we delete char \\'a\\' else we delete char \\'b\\'.\\n\\n```\\ndef get_a_count(word):\\n    count = 0\\n    for ch in word:\\n        if ch == \\'a\\':\\n            count += 1\\n    return count        \\n    \\n\\ndef get_minimum_deletions(word):\\n    result = 0\\n    i = 0\\n    j = len(word)-1\\n    count_a = get_a_count(word)\\n    count_b = len(word)-count_a\\n    while i < j:\\n\\t    # get to the point where word[i] = \\'b\\'\\n        while i < j and word[i] == \\'a\\':\\n            i += 1\\n            count_a -= 1\\n\\t\\t# get to the point where word[j] = \\'a\\'\\t\\n        while i < j and word[j] == \\'b\\':\\n            j -= 1\\n            count_b -= 1\\n            \\n\\t\\t# we go greedy here and delete that char whose count is less\\n        if count_a != 0 and count_b != 0:\\n            if count_a < count_b:\\n                j -= 1  # simulates deletion of \\'a\\'\\n                result += 1\\n                count_a -= 1\\n            else:\\n                i += 1  # simulates deletion of \\'b\\'\\n                result += 1\\n                count_b -= 1\\n    return result\\n```\\t\\n\\t\\n",
                "solutionTags": [],
                "code": "```\\ndef get_a_count(word):\\n    count = 0\\n    for ch in word:\\n        if ch == \\'a\\':\\n            count += 1\\n    return count        \\n    \\n\\ndef get_minimum_deletions(word):\\n    result = 0\\n    i = 0\\n    j = len(word)-1\\n    count_a = get_a_count(word)\\n    count_b = len(word)-count_a\\n    while i < j:\\n\\t    # get to the point where word[i] = \\'b\\'\\n        while i < j and word[i] == \\'a\\':\\n            i += 1\\n            count_a -= 1\\n\\t\\t# get to the point where word[j] = \\'a\\'\\t\\n        while i < j and word[j] == \\'b\\':\\n            j -= 1\\n            count_b -= 1\\n            \\n\\t\\t# we go greedy here and delete that char whose count is less\\n        if count_a != 0 and count_b != 0:\\n            if count_a < count_b:\\n                j -= 1  # simulates deletion of \\'a\\'\\n                result += 1\\n                count_a -= 1\\n            else:\\n                i += 1  # simulates deletion of \\'b\\'\\n                result += 1\\n                count_b -= 1\\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1087213,
                "title": "dp-python-simplest-constant-space-o-n-solution",
                "content": "Idea: The problem can be converted to longest aaa\\\\*bbbb\\\\* subsequence. \\n- t0 means the longest subsequence ending with a. \\n- t1 means the longest subsequence ending with b.\\nTime complexity is O(N)\\nSpace: O(1)\\n```python\\ndef minimumDeletions(self, s: str) -> int:\\n\\tt0 = t1 = 0\\n\\tfor c in s:\\n\\t\\t# carry the previous status\\n\\t\\tn0, n1 = t0, t1 \\n\\t\\tif c == \\'a\\':\\n\\t\\t\\tn0 = t0 + 1\\n\\t\\telse:\\n\\t\\t\\tn1 = max(t0, t1) + 1\\n\\t\\tt0, t1 = n0, n1\\n\\treturn len(s) - max(t0, t1)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minimumDeletions(self, s: str) -> int:\\n\\tt0 = t1 = 0\\n\\tfor c in s:\\n\\t\\t# carry the previous status\\n\\t\\tn0, n1 = t0, t1 \\n\\t\\tif c == \\'a\\':\\n\\t\\t\\tn0 = t0 + 1\\n\\t\\telse:\\n\\t\\t\\tn1 = max(t0, t1) + 1\\n\\t\\tt0, t1 = n0, n1\\n\\treturn len(s) - max(t0, t1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1009031,
                "title": "java-greedy-tc-o-n-space-o-1-17ms-faster-thn-99-with-explained-easily",
                "content": "```\\n/* idea is we think of removing a\\'s occruing after b\\'s to make the string balanced ,so we conut the number of a\\'s \\nafter b\\'s , BUT if we see that the count of b is less than count of a uptill now , we remove the b\\'s instead of the \\na\\'s beacuse it costs less .\\nThen just reset both a , b count and continue iterating the string \\nlastly it might happen that count (a) > count (b) never occurs for the entire string or for some part of the \\nstring after some removals , so we add count of a after coming out of the for loop .\\n\\n*/\\n\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0 , b = 0 ,cnt = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'a\\'){\\n                if(b == 0)\\n                    continue ;\\n                a++;\\n                if(a > b){\\n                    cnt += b ;\\n                    b = 0;\\n                    a = 0;\\n                }\\n            }\\n            else\\n                b++;\\n        }\\n        // consider -> baababbaabbaaabaabbabbbabaaaaaabaabababaaababbb\"\\n        // add the cnt of the single a in the index == 43 in the last part becasue a > b never triggers \\n        // if it triggers a will be 0 !\\n        cnt += a; \\n        return cnt ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* idea is we think of removing a\\'s occruing after b\\'s to make the string balanced ,so we conut the number of a\\'s \\nafter b\\'s , BUT if we see that the count of b is less than count of a uptill now , we remove the b\\'s instead of the \\na\\'s beacuse it costs less .\\nThen just reset both a , b count and continue iterating the string \\nlastly it might happen that count (a) > count (b) never occurs for the entire string or for some part of the \\nstring after some removals , so we add count of a after coming out of the for loop .\\n\\n*/\\n\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0 , b = 0 ,cnt = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'a\\'){\\n                if(b == 0)\\n                    continue ;\\n                a++;\\n                if(a > b){\\n                    cnt += b ;\\n                    b = 0;\\n                    a = 0;\\n                }\\n            }\\n            else\\n                b++;\\n        }\\n        // consider -> baababbaabbaaabaabbabbbabaaaaaabaabababaaababbb\"\\n        // add the cnt of the single a in the index == 43 in the last part becasue a > b never triggers \\n        // if it triggers a will be 0 !\\n        cnt += a; \\n        return cnt ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004397,
                "title": "simplest-c-o-n-without-dp-same-as-monotone-increasing",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b=0,a=0,ans=0;\\n        for(char c:s){\\n            if(c==\\'a\\') a++;\\n        }\\n        ans=a;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'b\\'){\\n                b++;\\n            }\\n            else{\\n                a--;\\n            }\\n            ans=min(ans,a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b=0,a=0,ans=0;\\n        for(char c:s){\\n            if(c==\\'a\\') a++;\\n        }\\n        ans=a;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'b\\'){\\n                b++;\\n            }\\n            else{\\n                a--;\\n            }\\n            ans=min(ans,a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000047,
                "title": "java-very-easy-to-understand-solution",
                "content": "Question says that there shouldn\\'t be any **b** between **a\\'s sequences** and there shouldn\\'t be any **a** in **b\\'s sequences** and **b\\'s sequences** should be after **a\\'s sequences**.To make the string balance we can try to balance every substring and atlast our string will be balanced.\\n\\n*Intution*\\n1. Loop over the character of s\\n2. If the character is \\'b\\' then we don\\'t need to delete anything.\\n3. Otherwise we have two option.We can delete that character and our delete count increases by 1 or we want to delete every b to get this substring valid.\\n4. Our answer is the minimum of this value.\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int bcnt = 0;\\n        int deleted = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'b\\') bcnt++;\\n            else{\\n                deleted = Math.min(deleted+1,bcnt);\\n            }\\n        }\\n        return deleted;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int bcnt = 0;\\n        int deleted = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'b\\') bcnt++;\\n            else{\\n                deleted = Math.min(deleted+1,bcnt);\\n            }\\n        }\\n        return deleted;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975389,
                "title": "java-solution-using-stack-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n       Stack<Character> st = new Stack<>();\\n       int min_del = 0;\\n       for(char c : s.toCharArray()){\\n         //whenever find \\'b\\' on top of stack and \\'a\\' on string we\\n         //delete both from the stack but we delete only \\'a\\' or \\'b\\' depending\\n         //on the no of b\\'s on the left and the no of a\\'s on the right\\n         //to eliminate b a.\\n         if(!st.isEmpty() && st.peek() == \\'b\\' && c == \\'a\\'){\\n           st.pop();\\n           min_del++;\\n         }else st.push(c);\\n        }\\n       return min_del;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n       Stack<Character> st = new Stack<>();\\n       int min_del = 0;\\n       for(char c : s.toCharArray()){\\n         //whenever find \\'b\\' on top of stack and \\'a\\' on string we\\n         //delete both from the stack but we delete only \\'a\\' or \\'b\\' depending\\n         //on the no of b\\'s on the left and the no of a\\'s on the right\\n         //to eliminate b a.\\n         if(!st.isEmpty() && st.peek() == \\'b\\' && c == \\'a\\'){\\n           st.pop();\\n           min_del++;\\n         }else st.push(c);\\n        }\\n       return min_del;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965912,
                "title": "100-javascript-dp-o-1-space",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s)  {\\n        let a = 0;\\n        let b = 0;\\n        for(let ch of s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = Math.min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return Math.min(a,b);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s)  {\\n        let a = 0;\\n        let b = 0;\\n        for(let ch of s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = Math.min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return Math.min(a,b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955662,
                "title": "java-dp-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int len = s.length();\\n\\t\\t//endA and endB store the number of deletions if the resulting valid string ends with A and B\\n        int endA = 0, endB = 0;\\n        for (int i=0; i<len; i++) {\\n\\t\\t\\t//if current char is a, we need to delete it to make string ending with b valid\\n            if (s.charAt(i) == \\'a\\') {\\n                endB++;\\n            }\\n\\t\\t\\t//if b, we can append it to the string with minimum deletion to make a valid string ending with b\\n            else {\\n                endB = Math.min(endA, endB);\\n                endA++;\\n            }\\n        }\\n        return Math.min(endA, endB);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int len = s.length();\\n\\t\\t//endA and endB store the number of deletions if the resulting valid string ends with A and B\\n        int endA = 0, endB = 0;\\n        for (int i=0; i<len; i++) {\\n\\t\\t\\t//if current char is a, we need to delete it to make string ending with b valid\\n            if (s.charAt(i) == \\'a\\') {\\n                endB++;\\n            }\\n\\t\\t\\t//if b, we can append it to the string with minimum deletion to make a valid string ending with b\\n            else {\\n                endB = Math.min(endA, endB);\\n                endA++;\\n            }\\n        }\\n        return Math.min(endA, endB);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941114,
                "title": "6-line-c-dp-o-n-time-o-1-space-change-the-problem-definition-makes-it-easier",
                "content": "Explain in comments.\\n```\\nint minimumDeletions(string s) {\\n\\t// Change the problem to be: longest accending string you can get\\n\\t// DP: two states\\n\\t//      a: longest string ending with \\'a\\'\\n\\t//      b: longest string ending with \\'b\\'\\n\\t// Iterate through string, if we meet \\'a\\', a++. Otherwise, the string can either be:\\n\\t//      1. previous longest string ending with \\'a\\' plus the current \\'b\\'\\n\\t//      2. previous longest string ending with \\'b\\' plus the current \\'b\\'\\n\\t// The minimun deletion would be length of string minus the longer one ending in either \\'a\\' or \\'b\\'.\\n\\tint a = 0, b = 0;\\n\\tfor (auto c: s) {\\n\\t\\tif (c == \\'a\\') a++;\\n\\t\\telse b = max(a, b) + 1;\\n\\t}\\n\\treturn s.length() - max(a, b);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumDeletions(string s) {\\n\\t// Change the problem to be: longest accending string you can get\\n\\t// DP: two states\\n\\t//      a: longest string ending with \\'a\\'\\n\\t//      b: longest string ending with \\'b\\'\\n\\t// Iterate through string, if we meet \\'a\\', a++. Otherwise, the string can either be:\\n\\t//      1. previous longest string ending with \\'a\\' plus the current \\'b\\'\\n\\t//      2. previous longest string ending with \\'b\\' plus the current \\'b\\'\\n\\t// The minimun deletion would be length of string minus the longer one ending in either \\'a\\' or \\'b\\'.\\n\\tint a = 0, b = 0;\\n\\tfor (auto c: s) {\\n\\t\\tif (c == \\'a\\') a++;\\n\\t\\telse b = max(a, b) + 1;\\n\\t}\\n\\treturn s.length() - max(a, b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 939879,
                "title": "java-solution-easy-to-understand-concise-o-3n",
                "content": "```java\\n public int minimumDeletions(String s) {\\n        int[] a = new int[s.length() + 1];\\n        int[] b = new int[s.length() + 1];\\n        for (int i = 0; i < s.length(); i++) {\\n            a[i + 1] = a[i] + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n        }\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            b[i] = b[i + 1] + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n        }\\n        int r = s.length();\\n        for (int i = 0; i < s.length() + 1; i++) {\\n            r = Math.min(r, s.length() - a[i] - b[i]);\\n        }\\n        return r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n public int minimumDeletions(String s) {\\n        int[] a = new int[s.length() + 1];\\n        int[] b = new int[s.length() + 1];\\n        for (int i = 0; i < s.length(); i++) {\\n            a[i + 1] = a[i] + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n        }\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            b[i] = b[i + 1] + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n        }\\n        int r = s.length();\\n        for (int i = 0; i < s.length() + 1; i++) {\\n            r = Math.min(r, s.length() - a[i] - b[i]);\\n        }\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 939861,
                "title": "o-n-very-simple-idea",
                "content": "Say the final answer begins at position p in the original string. To make position p a valid position, you have to delete all b\\'s before that position and all a\\'s after that position. Now we just iterate over the string and consider each possible position and try to find a p where number of deletions is minimum :)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> countA(s.length(), 0);\\n        int cnt = 0;\\n        for(int i = s.length()-1; i >=0 ; i--)\\n        {\\n            countA[i] = cnt;\\n            if(s[i] == \\'a\\')\\n                cnt++;\\n        }\\n        \\n        vector<int> countB(s.length(), 0);    \\n        cnt = 0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            countB[i] = cnt;\\n            if(s[i] == \\'b\\')\\n                cnt++;\\n        }\\n        \\n        int minDel = s.length();\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            minDel = min(minDel, countB[i]+countA[i]);\\n        }\\n        \\n        return minDel;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> countA(s.length(), 0);\\n        int cnt = 0;\\n        for(int i = s.length()-1; i >=0 ; i--)\\n        {\\n            countA[i] = cnt;\\n            if(s[i] == \\'a\\')\\n                cnt++;\\n        }\\n        \\n        vector<int> countB(s.length(), 0);    \\n        cnt = 0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            countB[i] = cnt;\\n            if(s[i] == \\'b\\')\\n                cnt++;\\n        }\\n        \\n        int minDel = s.length();\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            minDel = min(minDel, countB[i]+countA[i]);\\n        }\\n        \\n        return minDel;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939204,
                "title": "runtime-beats-98-93-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n =s.size()-1,a = 0,res = 0;\\n        \\n        for(int i=n;i>=0;i--)\\n            if(s[i] == \\'a\\') a++;\\n            else if( s[i] == \\'b\\'&& a > 0) a--,res ++;\\n        \\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n =s.size()-1,a = 0,res = 0;\\n        \\n        for(int i=n;i>=0;i--)\\n            if(s[i] == \\'a\\') a++;\\n            else if( s[i] == \\'b\\'&& a > 0) a--,res ++;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936487,
                "title": "min-deletions-of-left-b-and-right-a",
                "content": "```\\n    fun minimumDeletions(s: String): Int {\\n        val N = s.length\\n        var (la, lb) = 0 to 0\\n        var ra = s.count { it == \\'a\\' }\\n        var rb = N - ra\\n        var ans = ra  \\n        for (ch in s) {\\n            if (ch == \\'a\\') {\\n                la += 1\\n                ra -= 1\\n            } else {\\n                lb += 1\\n                rb -= 1\\n            }\\n            ans = minOf(ans, lb + ra)\\n        }\\n        return ans\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun minimumDeletions(s: String): Int {\\n        val N = s.length\\n        var (la, lb) = 0 to 0\\n        var ra = s.count { it == \\'a\\' }\\n        var rb = N - ra\\n        var ans = ra  \\n        for (ch in s) {\\n            if (ch == \\'a\\') {\\n                la += 1\\n                ra -= 1\\n            } else {\\n                lb += 1\\n                rb -= 1\\n            }\\n            ans = minOf(ans, lb + ra)\\n        }\\n        return ans\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936468,
                "title": "swift-clean-code-o-n-time-o-1-space",
                "content": "result = length(s) - length of the valid longest subsequence\\n```\\nclass Solution {\\n    func minimumDeletions(_ s: String) -> Int {\\n        let n = s.count\\n        // maxA is the length of the longest subsequence end with \"a\" \\n        var maxA = 0\\n        // maxB is the length of the longest subsequence end with \"b\" \\n        var maxB = 0\\n        for c in s {\\n            if c == \"a\" {\\n                maxA += 1\\n            } else {\\n                maxB = max(maxA, maxB) + 1\\n            }\\n        }\\n        return n - max(maxA, maxB)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumDeletions(_ s: String) -> Int {\\n        let n = s.count\\n        // maxA is the length of the longest subsequence end with \"a\" \\n        var maxA = 0\\n        // maxB is the length of the longest subsequence end with \"b\" \\n        var maxB = 0\\n        for c in s {\\n            if c == \"a\" {\\n                maxA += 1\\n            } else {\\n                maxB = max(maxA, maxB) + 1\\n            }\\n        }\\n        return n - max(maxA, maxB)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936240,
                "title": "minimum-deletions-to-make-string-balanced",
                "content": "Minimum Deletions to Make String Balanced\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n       int n=s.size();\\n       int  pre[100005]={0},suff[100005]={0};\\n        \\n       pre[0]=0; \\n       for(int i=0;i<n;i++){\\n           pre[i+1]=pre[i];\\n           if(s[i]==\\'b\\'){\\n               pre[i+1]++;\\n           }\\n       }\\n        \\n       suff[n]=0;\\n       for(int i=n-1;i>=0;i--){\\n           suff[i]=suff[i+1];\\n           if(s[i]==\\'a\\'){\\n               suff[i]++;\\n           }\\n       }\\n        \\n    \\n        int ans=1e9;\\n        for(int i=0;i<=s.size();i++)\\n             ans=min(ans,pre[i]+suff[i]);\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n       int n=s.size();\\n       int  pre[100005]={0},suff[100005]={0};\\n        \\n       pre[0]=0; \\n       for(int i=0;i<n;i++){\\n           pre[i+1]=pre[i];\\n           if(s[i]==\\'b\\'){\\n               pre[i+1]++;\\n           }\\n       }\\n        \\n       suff[n]=0;\\n       for(int i=n-1;i>=0;i--){\\n           suff[i]=suff[i+1];\\n           if(s[i]==\\'a\\'){\\n               suff[i]++;\\n           }\\n       }\\n        \\n    \\n        int ans=1e9;\\n        for(int i=0;i<=s.size();i++)\\n             ans=min(ans,pre[i]+suff[i]);\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935797,
                "title": "java-count-the-number-of-a-s-and-b-s-left-and-right",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int cntA = 0;\\n        int cntB = 0;\\n        int[] leftA = new int[n];\\n        int[] leftB = new int[n];\\n        int[] rightA = new int[n];\\n        int[] rightB = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            leftA[i] = cntA;\\n            leftB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        cntA = cntB = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            rightA[i] = cntA;\\n            rightB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        int min = n;\\n        for (int i = 0; i < n; i++) {\\n            min = Math.min(min, leftB[i] + rightA[i]);\\n            if (s.charAt(i) == \\'a\\') {\\n                min = Math.min(min, leftB[i] + rightB[i]);\\n                min = Math.min(min, leftA[i] + rightA[i] + 1);\\n            }\\n            if (s.charAt(i) == \\'b\\') {\\n                min = Math.min(min, leftA[i] + rightA[i]);\\n                min = Math.min(min, leftB[i] + rightB[i] + 1);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int cntA = 0;\\n        int cntB = 0;\\n        int[] leftA = new int[n];\\n        int[] leftB = new int[n];\\n        int[] rightA = new int[n];\\n        int[] rightB = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            leftA[i] = cntA;\\n            leftB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        cntA = cntB = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            rightA[i] = cntA;\\n            rightB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        int min = n;\\n        for (int i = 0; i < n; i++) {\\n            min = Math.min(min, leftB[i] + rightA[i]);\\n            if (s.charAt(i) == \\'a\\') {\\n                min = Math.min(min, leftB[i] + rightB[i]);\\n                min = Math.min(min, leftA[i] + rightA[i] + 1);\\n            }\\n            if (s.charAt(i) == \\'b\\') {\\n                min = Math.min(min, leftA[i] + rightA[i]);\\n                min = Math.min(min, leftB[i] + rightB[i] + 1);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935691,
                "title": "java-simple-o-n-dp-solution-beats-100-time-and-space",
                "content": "dp[i] == Number of deletions to balance `str[0, i]`. Also `dp[0] == 0` since it\\'s balanced.\\nNow if we see an `a` then we have two choices\\n\\t- Delete the `a` in which case total steps will be `dp[i-1]+1`\\n\\t- Keep the `a` and delete all preceding `b`, in which case dp[i] = `total b count so far`\\n\\t- We pick the min of the above two\\nIf we see a `b` then nothing needs to be done as `b` at end is legit. We just update counter for number of seen `b`.\\nWe can make it work with no additional space by just tracking the total deletions so far.\\n\\nTime `O(N)`\\nSpace `O(1)`\\n\\n\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int totDel = 0, totB = s.charAt(0) == \\'b\\' ? 1 : 0;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                totDel = Math.min(totDel+1, totB);\\n            } else {\\n                totB++;\\n            }\\n        }\\n        return totDel;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int totDel = 0, totB = s.charAt(0) == \\'b\\' ? 1 : 0;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                totDel = Math.min(totDel+1, totB);\\n            } else {\\n                totB++;\\n            }\\n        }\\n        return totDel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935555,
                "title": "easy-c-100-better-in-time-and-100-better-in-space",
                "content": "\\'\\'\\'\\n\\npublic int MinimumDeletions(string s) {\\n        \\n        if(s.Length == 0) {\\n            return 0;\\n        }\\n        var minDeletes = s.Length;\\n        var deletes = new int[s.Length];\\n        var bCounts = 0;\\n        for(var i = 0; i < s.Length; i++)\\n        {\\n            deletes[i] = bCounts;\\n            if(s[i] == \\'b\\') {\\n                 bCounts++;\\n            }\\n        }\\n        \\n        var aCounts = 0;\\n        for(var i = s.Length-1; i >= 0; i--)\\n        {\\n             \\n            deletes[i] += aCounts;\\n            minDeletes = Math.Min(minDeletes,deletes[i]);\\n            if(s[i] == \\'a\\') {\\n                aCounts++;\\n             }\\n             \\n        }\\n        return minDeletes;\\n    }",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\npublic int MinimumDeletions(string s) {\\n        \\n        if(s.Length == 0) {\\n            return 0;\\n        }\\n        var minDeletes = s.Length;\\n        var deletes = new int[s.Length];\\n        var bCounts = 0;\\n        for(var i = 0; i < s.Length; i++)\\n        {\\n            deletes[i] = bCounts;\\n            if(s[i] == \\'b\\') {\\n                 bCounts++;\\n            }\\n        }\\n        \\n        var aCounts = 0;\\n        for(var i = s.Length-1; i >= 0; i--)\\n        {\\n             \\n            deletes[i] += aCounts;\\n            minDeletes = Math.Min(minDeletes,deletes[i]);\\n            if(s[i] == \\'a\\') {\\n                aCounts++;\\n             }\\n             \\n        }\\n        return minDeletes;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 935488,
                "title": "simple-python3-time-o-n-space-o-n",
                "content": "1. Counting all \"b\" from left to right, storing in array A.\\n2. Counting all \"a\" from right to left, storing is not needed\\n3. stored value in array A plus actual value of \"b\\' is number of deletions, if the point of \"...ab...\" is here\\n\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        m=len(s)\\n        if m<2: return 0\\n        \\n        A=[0]*m\\n        L=0\\n        b=0 # counting \"b\" from left\\n        while L<m:\\n            b+=s[L]==\\'b\\'\\n            A[L]=b\\n            L+=1\\n        \\n        minDel=b\\n        R=m-1\\n        a=0 # counting \"a\" from right\\n        while 0<=R:\\n            a+=s[R]==\\'a\\'\\n            minDel=min(minDel,A[R-1]+a)\\n            R-=1 \\n            \\n        return min(minDel,a) \\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        m=len(s)\\n        if m<2: return 0\\n        \\n        A=[0]*m\\n        L=0\\n        b=0 # counting \"b\" from left\\n        while L<m:\\n            b+=s[L]==\\'b\\'\\n            A[L]=b\\n            L+=1\\n        \\n        minDel=b\\n        R=m-1\\n        a=0 # counting \"a\" from right\\n        while 0<=R:\\n            a+=s[R]==\\'a\\'\\n            minDel=min(minDel,A[R-1]+a)\\n            R-=1 \\n            \\n        return min(minDel,a) \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 935418,
                "title": "easy-dp-c-explained-o-n-t-c",
                "content": "***Note : Random people downvote without even reading, do read and if helps dont atleast downvote, Thank You.***\\n***Note: Always welcome for optimisations, changes and advices.***\\n\\n***Intiution***\\n 1) Keep counting the number of encountered \\'b\\', uptill current index.\\n 2) If the current element is \\'b\\' , increse the count, and solution uptill current index will be same as of previous.\\n 3) If the element is an \\'a\\'. two case arise either previous encountered number of \\'b\\' is zero then solution upto current index is same as upto previous, else it will be the minimum of previous solution + 1 and deleting the previously encountered \\'b\\' uptill now.\\n \\n\\n```\\n\\nclass Solution \\n{\\npublic:\\n    int minimumDeletions(string s)\\n    {\\n        int no_of_b = 0;\\n        vector<int> dp( s.length(), 0 );\\n        \\n        no_of_b += ( s[0] == \\'b\\' ) ? 1 : 0;\\n        \\n        for( int i = 1; i<s.length(); i++ )\\n        {\\n            if( s[i] == \\'b\\' )\\n            {\\n                no_of_b++;\\n                dp[i] = dp[i-1];\\n            }\\n            else\\n            {\\n                if( no_of_b == 0 ) dp[i] = dp[i-1];\\n                else dp[i] = min( dp[i-1] + 1, no_of_b );\\n            }\\n        }\\n        \\n        return dp[s.length()-1];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution \\n{\\npublic:\\n    int minimumDeletions(string s)\\n    {\\n        int no_of_b = 0;\\n        vector<int> dp( s.length(), 0 );\\n        \\n        no_of_b += ( s[0] == \\'b\\' ) ? 1 : 0;\\n        \\n        for( int i = 1; i<s.length(); i++ )\\n        {\\n            if( s[i] == \\'b\\' )\\n            {\\n                no_of_b++;\\n                dp[i] = dp[i-1];\\n            }\\n            else\\n            {\\n                if( no_of_b == 0 ) dp[i] = dp[i-1];\\n                else dp[i] = min( dp[i-1] + 1, no_of_b );\\n            }\\n        }\\n        \\n        return dp[s.length()-1];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935416,
                "title": "python-variant-of-the-longest-increasing-subsequence",
                "content": "```\\nclass Solution(object):\\n    def minimumDeletions(self, s):\\n        dp = []\\n        for c in s:\\n            if c == \\'b\\':\\n                dp += c,\\n            else:\\n                if not dp:\\n                    dp += c,\\n                else:\\n                    if dp[-1] == \\'a\\':\\n                        dp += c,\\n                    else:\\n                        idx = bisect_right(dp, c)\\n                        dp[idx] = c\\n        return len(s) - len(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimumDeletions(self, s):\\n        dp = []\\n        for c in s:\\n            if c == \\'b\\':\\n                dp += c,\\n            else:\\n                if not dp:\\n                    dp += c,\\n                else:\\n                    if dp[-1] == \\'a\\':\\n                        dp += c,\\n                    else:\\n                        idx = bisect_right(dp, c)\\n                        dp[idx] = c\\n        return len(s) - len(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935411,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> a;\\n        int n = s.size();\\n        if(s.size() == 1){\\n            return 0;\\n        }\\n        a.push_back(0);\\n        if(s[0] == \\'a\\')\\n            a[0] = 1;\\n        for(int i = 1; i < n; i++){\\n            a.push_back(a[i - 1]);\\n            if(s[i] == \\'a\\'){\\n                a[i] ++;\\n            }\\n        }\\n        if(s.size() - a.back() == 0){\\n            return 0;\\n        }\\n        \\n        int ans = INT_MAX;\\n        int local;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                local = i - a[i] + a.back() - a[i];\\n                ans = min(ans, local);\\n            }\\n            \\n            \\n        }\\n        local = s.size() - a.back();\\n        ans = min(ans, local);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> a;\\n        int n = s.size();\\n        if(s.size() == 1){\\n            return 0;\\n        }\\n        a.push_back(0);\\n        if(s[0] == \\'a\\')\\n            a[0] = 1;\\n        for(int i = 1; i < n; i++){\\n            a.push_back(a[i - 1]);\\n            if(s[i] == \\'a\\'){\\n                a[i] ++;\\n            }\\n        }\\n        if(s.size() - a.back() == 0){\\n            return 0;\\n        }\\n        \\n        int ans = INT_MAX;\\n        int local;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                local = i - a[i] + a.back() - a[i];\\n                ans = min(ans, local);\\n            }\\n            \\n            \\n        }\\n        local = s.size() - a.back();\\n        ans = min(ans, local);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083281,
                "title": "easy-to-understand-javascript-solution-dp",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar minimumDeletions = function(s) {\\n    let a = b = 0;\\n\\n    for (const char of s) {\\n        char === \\'a\\'\\n            ? b = Math.min(a, b + 1)\\n            : a += 1;\\n    }\\n    return Math.min(a, b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumDeletions = function(s) {\\n    let a = b = 0;\\n\\n    for (const char of s) {\\n        char === \\'a\\'\\n            ? b = Math.min(a, b + 1)\\n            : a += 1;\\n    }\\n    return Math.min(a, b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039498,
                "title": "most-easiest-solution-using-stack-must-see-too-easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                st.push(\\'b\\');\\n            }\\n\\n            else if(s[i] == \\'a\\'){\\n                if(st.size() != 0){\\n                    if(st.top() == \\'b\\'){\\n                        st.pop();\\n                        count++;\\n                    }\\n                }\\n\\n                else{\\n                    st.push(\\'a\\');\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                st.push(\\'b\\');\\n            }\\n\\n            else if(s[i] == \\'a\\'){\\n                if(st.size() != 0){\\n                    if(st.top() == \\'b\\'){\\n                        st.pop();\\n                        count++;\\n                    }\\n                }\\n\\n                else{\\n                    st.push(\\'a\\');\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005377,
                "title": "c-simple-solution-tc-o-n-sc-o-1-explanation",
                "content": "# EXPLANATION \\nAt first we count the number of **\\'a\\'** present in string and store in **a**.\\nThen again traverse in string **s**.\\nIf that char is \\'a\\' then we decrease count of **a** and do **ans=min(ans,a+b)**.\\nElse, then we do **ans=min(ans,a+b)** and increase the count of \\'b\\' in **b**.\\nOur idea is that if current is \\'a\\' then we count the number of \\'b\\' in left of it and the number of \\'a\\' on right of it.\\nElse if that current is \\'b\\' then we count the number of \\'a\\' on right and \\'b\\' on left.\\nFinally return the minimum of it and return as **ans**.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ans=INT_MAX;\\n        for(auto x:s)\\n            if(x==\\'a\\')\\n                a++;\\n        for(auto x:s){\\n            if(x==\\'a\\'){\\n                a--;\\n                ans=min(ans,a+b);\\n            }\\n            else{\\n                ans=min(ans,b+a);\\n                b++;\\n            }\\n        }\\n        ans=(ans==INT_MAX)?0:ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ans=INT_MAX;\\n        for(auto x:s)\\n            if(x==\\'a\\')\\n                a++;\\n        for(auto x:s){\\n            if(x==\\'a\\'){\\n                a--;\\n                ans=min(ans,a+b);\\n            }\\n            else{\\n                ans=min(ans,b+a);\\n                b++;\\n            }\\n        }\\n        ans=(ans==INT_MAX)?0:ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002666,
                "title": "without-using-any-extra-space-and-without-using-dp-and-stack-here-is-my-o-n-time-and-o-1-space",
                "content": "# Intuition\\n  **Have a look at the below image :** \\n\\n![leetcode.jpg](https://assets.leetcode.com/users/images/18eea307-3a95-4dde-b808-9fded7848a88_1693852109.88309.jpeg)\\n\\nJust a simple approach man as we know that we don\\'t want that our string consist of \\'a\\' character after the \\'b\\' character and we can keep track of this thing from the back of the string because in the beginning we don\\'t know after \\'b\\' how many \\'a\\' were there and before \\'a\\' how many \\'b\\' were there and we don\\'t know whether we will get the minimum deletions at the left end or right hand but at the same time we can keep track of \"ba\" from the end in an easy manner.\\n\\nJust we need to keep the count of \\'a\\' character and as soon as we got the \\'b\\' character then simply we will check if the count of \\'a\\' is greater than 0 and if it that means we need to delete either \\'a\\' or \\'b\\' which will take 1 deletion operation only so in such cases we will increment our answer by 1 and will decrement the count of \\'a\\' by 1 because we have already deleted it.\\n\\nAt the end we will simply return our answer variable which will contains the required answer.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int ans=0,a=0;\\n        for(int i=n-1;i>=0;i--){\\n            char ch = s.charAt(i);\\n            if(ch==\\'a\\') a++;\\n            else if(ch==\\'b\\' && a!=0){\\n                ans+=1;\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# **If you find this helpful then please upvote me :)**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int ans=0,a=0;\\n        for(int i=n-1;i>=0;i--){\\n            char ch = s.charAt(i);\\n            if(ch==\\'a\\') a++;\\n            else if(ch==\\'b\\' && a!=0){\\n                ans+=1;\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998778,
                "title": "o-n-o-1-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        // stack<char> st;\\n        // int cnt=0;\\n        // for(auto ch:s)\\n        // {\\n        //     if(ch==\\'b\\')\\n        //     st.push(\\'b\\');\\n        //     if(ch==\\'a\\' && !st.empty())\\n        //     {\\n        //         st.pop();\\n        //         cnt++;\\n        //     }\\n        // }\\n        // return cnt;\\n        int cnt=0;\\n        int cntB=0;\\n        for(auto ch:s)\\n        {\\n            if(ch==\\'b\\')\\n            cntB++;\\n            else if(ch==\\'a\\' && cntB)\\n            {\\n                cntB--;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        // stack<char> st;\\n        // int cnt=0;\\n        // for(auto ch:s)\\n        // {\\n        //     if(ch==\\'b\\')\\n        //     st.push(\\'b\\');\\n        //     if(ch==\\'a\\' && !st.empty())\\n        //     {\\n        //         st.pop();\\n        //         cnt++;\\n        //     }\\n        // }\\n        // return cnt;\\n        int cnt=0;\\n        int cntB=0;\\n        for(auto ch:s)\\n        {\\n            if(ch==\\'b\\')\\n            cntB++;\\n            else if(ch==\\'a\\' && cntB)\\n            {\\n                cntB--;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981945,
                "title": "c-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int totalA = 0, totalB = 0;\\n        for(char c:s) {\\n            if(c ==\\'a\\'){\\n                totalA++;\\n            } else {\\n                totalB++;\\n            }\\n        }\\n        int min = std::min(totalA, totalB), pastA=0, pastB=0;\\n        for(int pos =1; pos<s.size(); pos++) {\\n            if(s[pos-1]==\\'a\\'){\\n                pastA++;\\n            } else {\\n                pastB++;\\n            }\\n            if(s[pos-1]==\\'a\\'&&s[pos]==\\'b\\') {\\n                int del = totalA-pastA + pastB;\\n                if(del<min){min = del;}\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int totalA = 0, totalB = 0;\\n        for(char c:s) {\\n            if(c ==\\'a\\'){\\n                totalA++;\\n            } else {\\n                totalB++;\\n            }\\n        }\\n        int min = std::min(totalA, totalB), pastA=0, pastB=0;\\n        for(int pos =1; pos<s.size(); pos++) {\\n            if(s[pos-1]==\\'a\\'){\\n                pastA++;\\n            } else {\\n                pastB++;\\n            }\\n            if(s[pos-1]==\\'a\\'&&s[pos]==\\'b\\') {\\n                int del = totalA-pastA + pastB;\\n                if(del<min){min = del;}\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971463,
                "title": "minimum-deletions-to-make-string-valid-using-stack",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        int len = s.length();\\n         \\n        Stack<Character> st = new Stack<Character>(); \\n         if (s == null || s.isEmpty()) return 0;\\n\\n        for( int i = 0 ; i < len ; i++){\\n          char c  = s.charAt(i);\\n\\n         if(!st.isEmpty() && c == \\'a\\'){\\n             st.pop();\\n             count++;\\n         }\\n         if(c == \\'b\\'){\\n             st.push(c);\\n          }\\n        }  \\n         return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        int len = s.length();\\n         \\n        Stack<Character> st = new Stack<Character>(); \\n         if (s == null || s.isEmpty()) return 0;\\n\\n        for( int i = 0 ; i < len ; i++){\\n          char c  = s.charAt(i);\\n\\n         if(!st.isEmpty() && c == \\'a\\'){\\n             st.pop();\\n             count++;\\n         }\\n         if(c == \\'b\\'){\\n             st.push(c);\\n          }\\n        }  \\n         return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958486,
                "title": "simple-python3-solution-92-47-simple-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to count the occurrences of \\'a\\' and \\'b\\' characters and use these counts to determine the minimum number of deletions needed to balance the string. We can match \\'a\\' characters with \\'b\\' characters to create pairs and eliminate the need for deletions. The goal is to minimize the total number of deletions required.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two variables a_count and b_count to keep track of the counts of \\'a\\' and \\'b\\' characters encountered in the string, and another variable total_deletions to track the total number of deletions needed.\\n\\n2. Iterate through each character c in the input string s:\\n\\n- If c is \\'a\\':\\n\\n    - If there are \\'b\\' characters encountered before (b_count > 0), it means we can form a balanced pair by matching this \\'a\\' with a \\'b\\', so decrement b_count and increment total_deletions by 1.\\n    - Otherwise, increment a_count by 1, indicating that we\\'ve encountered an \\'a\\' character.\\n\\n- If c is \\'b\\':\\n\\n    - Increment b_count by 1, indicating that we\\'ve encountered a \\'b\\' character.\\n\\n3. After processing all characters, the total_deletions will represent the minimum number of deletions needed to make the string balanced\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nBeats 85.96%of users with Python3\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\nBeats 92.47%of users with Python3\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count_a = 0\\n        count_b = 0\\n        min_deleted = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \"a\":\\n                if count_b >0:\\n                    count_b-=1\\n                    min_deleted+=1\\n                else:\\n                    count_a += 1\\n            elif s[i] == \"b\":\\n                count_b +=1\\n\\n        return min_deleted\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count_a = 0\\n        count_b = 0\\n        min_deleted = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \"a\":\\n                if count_b >0:\\n                    count_b-=1\\n                    min_deleted+=1\\n                else:\\n                    count_a += 1\\n            elif s[i] == \"b\":\\n                count_b +=1\\n\\n        return min_deleted\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958325,
                "title": "c-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n            int countb=0;\\n            int ans=0;\\n            for(auto i:s)\\n            {\\n                if(i==\\'b\\')\\n                countb++;\\n                if(i==\\'a\\' && countb>0)\\n                {\\n                    ans++;\\n                    countb--;\\n                }\\n            }\\n        return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n            int countb=0;\\n            int ans=0;\\n            for(auto i:s)\\n            {\\n                if(i==\\'b\\')\\n                countb++;\\n                if(i==\\'a\\' && countb>0)\\n                {\\n                    ans++;\\n                    countb--;\\n                }\\n            }\\n        return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1895764,
                "content": [
                    {
                        "username": "Aayush65",
                        "content": "Can anybody tell me why is this giving TLE, when that same (61st test case) is running in 300ms when run in the console.\\nCode:\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        \\n        memo = {}\\n        def dp(l: int, r: int) -> int:\\n            if (l, r) in memo:\\n                return memo[(l, r)]\\n            key = (l, r)\\n            while l < r and s[l] == \\'a\\':\\n                l += 1\\n            while r > l and s[r] == \\'b\\':\\n                r -= 1\\n            if l == r:\\n                return 0\\n            res = 1 + min(dp(l + 1, r), dp(l, r - 1))\\n            memo[key] = res\\n            return res\\n            \\n        return dp(0, len(s) - 1)\\n```"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "what is the (61st test case) ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Jumps to Reach Home",
        "question_content": "<p>A certain bug&#39;s home is on the x-axis at position <code>x</code>. Help them get there from position <code>0</code>.</p>\n\n<p>The bug jumps according to the following rules:</p>\n\n<ul>\n\t<li>It can jump exactly <code>a</code> positions <strong>forward</strong> (to the right).</li>\n\t<li>It can jump exactly <code>b</code> positions <strong>backward</strong> (to the left).</li>\n\t<li>It cannot jump backward twice in a row.</li>\n\t<li>It cannot jump to any <code>forbidden</code> positions.</li>\n</ul>\n\n<p>The bug may jump forward <strong>beyond</strong> its home, but it <strong>cannot jump</strong> to positions numbered with <strong>negative</strong> integers.</p>\n\n<p>Given an array of integers <code>forbidden</code>, where <code>forbidden[i]</code> means that the bug cannot jump to the position <code>forbidden[i]</code>, and integers <code>a</code>, <code>b</code>, and <code>x</code>, return <em>the minimum number of jumps needed for the bug to reach its home</em>. If there is no possible sequence of jumps that lands the bug on position <code>x</code>, return <code>-1.</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 3 jumps forward (0 -&gt; 3 -&gt; 6 -&gt; 9) will get the bug home.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\n<strong>Output:</strong> -1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> One jump forward (0 -&gt; 16) then one jump backward (16 -&gt; 7) will get the bug home.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= forbidden.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= a, b, forbidden[i] &lt;= 2000</code></li>\n\t<li><code>0 &lt;= x &lt;= 2000</code></li>\n\t<li>All the elements in <code>forbidden</code> are distinct.</li>\n\t<li>Position <code>x</code> is not forbidden.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 978357,
                "title": "c-bidirectional-bfs-solution-with-proof-for-search-upper-bound",
                "content": "The main difficulty with this problem is figuring out at what `x` should the search be terminated, since otherwise in the BFS one can keep adding `a` to infinity. Just for this part I think the problem should be labeled \"hard\"`. This problem is also unsolvabe without knowing Bezout\\'s Identity. \\n\\n**Proof that maximum search is capped at `stop = a+b+max(x, max(forbidden))`**:\\n\\nFirst thing to note is that all reachable positions must be a factor of `gcd(a,b)`. This is the result Bezout\\'s Identity (https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity). **Bezout\\'s Identity just states that for some integers `x`, `y`, `z`,`a`, `b`, `x*a+y*b = z*gcd(a,b)`.** \\n\\nWhat this means in the context of this problem, is that by applying `a` size steps forward `x` times and `b` size steps backward `y` times, we must reach some position that is a multiple of `gcd(a,b)`. This part is required to find an upper bound to the BFS search without guessing.\\n\\nFor this proof, there are two cases: `a  >= b` and `a < b`.\\n\\nThe first case is trivial. If `a  = b`, then there is no point going backwards. You will end up at the position you just came from. So if you cannot reach `x` before going beyond `x`, you cannot ever reach `x`. For `a > b`, if you go beyond `x` you can never go back to `x`. So the maximum search boundary for `a >= b` is at `x`, which is less than `stop`. \\n\\nSecond case is the real problem. If `a < b` then technically we can continuously add `a`, and still find some way  to retrace back, since we can keep adding `a` then minus `b` to go back `b-a` steps. However, this is only guaranteed if the path(s) back are not blocked by forbidden positions. Thus to verify if a path is possible, we must at least search past `max(x, max(forbidden))`. \\n\\nPast `max(x, max(forbidden)`, at some point you will start hitting repeat positions. For example, you can reach some position `pos` by going forward once, or by going a few steps forward and some back to reach the same position (this is guaranteed by Bezout\\'s Identity). But the latter should not be considered since you can already reach `pos` in 1 step. This is where the repeats come in. There are an infinitely number of ways to reach `pos`, but only the shortest needs to be considered. \\n\\nSo at what point does the paths start repeating? First we need to find the starting point. Assume `max_ = max(x, max(forbidden))`. The first reachable position is the first pos `p0 = n*gcd(a,b)` such that `p > max_`. Using this definition we can say that all positions `p = p0 + m*gcd(a,b), m >= 0` are reachable. \\n\\nThe next step is to figure when do we stop (for what `m` do we not continue). The intuition is that regardless of how far you  venture out, eventually you need to come back. Otherwise you won\\'t reach `x`. Initially, you must start before `max_`. Since you can only go forward `a`, you will end up at some position `(max_, max_+a]`. Since `gcd(a,b)` is a multiple of `a`, we can say that the positions we can first reach are `[p0, p0+gcd(a,b), p0+2*gcd(a,b), ... p0+a-gcd(a,b)]`. For these positions, we can reach them from \"beyond\" by going back `b`. Thus the positions we can come back from are `gcd(a,b)` multiples in range `[p0+b, p0+a-gcd(a,b)+b]`. This also means that `p0+a-gcd(a,b)+b` is the bound we should stop searching at. This is because of the repeats. We can reach `[p0, p0+a-gcd(a,b)]` from `[p0+b, p0+a-gcd(a,b)+b]` by going back one step. Anything beyond `p0+a-gcd(a,b)+b` will take **at least** 4 or more steps. First you have to go forward `a` to go beyond `p0+a-gcd(a,b)+b`, so you at least end up at `p0+a-gcd(a,b)+b+gcd(a,b) = p0+a+b`, then you go back `b`, and end up at `p0+a > p0+a-gcd(a,b)`. So now you have to at least do another cycle (go forward `a`, go back `b`) to arrive at `p0+a-b`, and in the best scenario `b > gcd(a,b)` you end up in `[p0, p0+a-gcd(a,b)]`. This shows that venturing beyond `p0+a-gcd(a,b)+b` will always lead to higher step count, and thus this is the stopping bound. \\n\\nSo now we know that the maximum boundary is `p0+a-gcd(a,b)+b`. Using description of `p0`, we can say `p0 = max_ + delta = c*gcd(a,b)`, where `delta <= gcd(a,b)`. Thus, we can create an upperbound for `p0` using `p0 = max_ + delta = max_ + gcd(a,b)`. This leads to the upper bound `p0+a-gcd(a,b)+b = max_+gcd(a,b)+a-gcd(a,b)+b = max_+a+b = a+b+max(x, max(forbidden)`. \\n\\n\\nRun-time is `O(max(x,max(forbidden))+a+b)+len(forbiddend)`, space is `O(max(x,max(forbidden))+a+b+len(forbidden))`. \\n\\n```\\n#define B_MASK 14\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        int g{std::gcd(a, b)};\\n        \\n        if(x % g) return -1; // No non-negative integers c1,c2 such that c1*a - c2*b == x\\n        int max_{x};\\n        std::bitset<1<<15> invalid;\\n        for(const auto &n: forbidden) max_ = std::max(max_, n), invalid.set(n);\\n        b\\n        int16_t stop{(int16_t)(max_+b+a)};\\n        \\n        /* Bidirectional BFS, good for when both start and end states are known, and the edge definition is \"bidirectional\"\\n\\t\\t   aka for edge \"a <--> b\", at \"a\" you know you can go to \"b\", and at \"b\" you know you can come from \"a\".\\n\\t\\t  The definition need not be symmetric, such as in this problem. */\\n        std::queue<std::pair<int16_t,int16_t>> qS, qE;\\n        int stepS{0}, stepE{0};\\n        qS.emplace(0,0), qS.emplace(-1,-1);\\n        qE.emplace(x,0), qE.emplace(x, 1), qE.emplace(-1,-1);\\n        \\n        std::vector<int16_t> visitedS(1<<15, -1), visitedE(1<<15, -1);\\n        \\n        bool useS{true};\\n        while(!qS.empty() || !qE.empty()) {\\n            if(useS) {\\n                auto [loc, bc]{qS.front()}; qS.pop();\\n                if(loc == -1) {\\n                    if(!qS.empty()) ++stepS, qS.emplace(-1,-1);\\n                    if(qS.empty() || qS.size() >= qE.size() && !qE.empty()) useS = false;\\n                    continue;\\n                }\\n\\n                int16_t key = {(int16_t)(loc|(bc<<B_MASK))};\\n                if(visitedS[key] != -1) continue;\\n                visitedS[key] = stepS;\\n                if(visitedE[key] != -1) return stepS + visitedE[key];\\n                \\n                if(loc+a <= stop && !invalid[loc+a] && visitedS[(key+a)%(1<<B_MASK)] == -1) qS.emplace(loc+a, 0);\\n                if(!bc && loc-b > 0 && !invalid[loc-b] && visitedS[(key-b)|(1<<B_MASK)] == -1) qS.emplace(loc-b, 1);\\n                    \\n            } else {\\n                auto [loc, bc]{qE.front()}; qE.pop();\\n                if(loc == -1) {\\n                    if(!qE.empty()) ++stepE, qE.emplace(-1,-1);\\n                    if(qE.empty() || qE.size() >= qS.size() && !qS.empty()) useS = true;\\n                    continue;\\n                }\\n                \\n                int16_t key = {(int16_t)(loc|(bc<<B_MASK))};\\n                if(visitedE[key] != -1) continue;\\n                visitedE[key] = stepE;\\n                if(visitedS[key] != -1) return stepE + visitedS[key];\\n\\n                if(loc-a >= 0 && !invalid[loc-a] && visitedE[key-a] == -1) qE.emplace(loc-a, bc);\\n                if(bc && loc+b <= stop && !invalid[loc+b] && visitedE[(key+b)%(1<<B_MASK)] == -1) qE.emplace(loc+b, 0);\\n            }\\n            \\n        }\\n        \\n        return -1; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define B_MASK 14\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        int g{std::gcd(a, b)};\\n        \\n        if(x % g) return -1; // No non-negative integers c1,c2 such that c1*a - c2*b == x\\n        int max_{x};\\n        std::bitset<1<<15> invalid;\\n        for(const auto &n: forbidden) max_ = std::max(max_, n), invalid.set(n);\\n        b\\n        int16_t stop{(int16_t)(max_+b+a)};\\n        \\n        /* Bidirectional BFS, good for when both start and end states are known, and the edge definition is \"bidirectional\"\\n\\t\\t   aka for edge \"a <--> b\", at \"a\" you know you can go to \"b\", and at \"b\" you know you can come from \"a\".\\n\\t\\t  The definition need not be symmetric, such as in this problem. */\\n        std::queue<std::pair<int16_t,int16_t>> qS, qE;\\n        int stepS{0}, stepE{0};\\n        qS.emplace(0,0), qS.emplace(-1,-1);\\n        qE.emplace(x,0), qE.emplace(x, 1), qE.emplace(-1,-1);\\n        \\n        std::vector<int16_t> visitedS(1<<15, -1), visitedE(1<<15, -1);\\n        \\n        bool useS{true};\\n        while(!qS.empty() || !qE.empty()) {\\n            if(useS) {\\n                auto [loc, bc]{qS.front()}; qS.pop();\\n                if(loc == -1) {\\n                    if(!qS.empty()) ++stepS, qS.emplace(-1,-1);\\n                    if(qS.empty() || qS.size() >= qE.size() && !qE.empty()) useS = false;\\n                    continue;\\n                }\\n\\n                int16_t key = {(int16_t)(loc|(bc<<B_MASK))};\\n                if(visitedS[key] != -1) continue;\\n                visitedS[key] = stepS;\\n                if(visitedE[key] != -1) return stepS + visitedE[key];\\n                \\n                if(loc+a <= stop && !invalid[loc+a] && visitedS[(key+a)%(1<<B_MASK)] == -1) qS.emplace(loc+a, 0);\\n                if(!bc && loc-b > 0 && !invalid[loc-b] && visitedS[(key-b)|(1<<B_MASK)] == -1) qS.emplace(loc-b, 1);\\n                    \\n            } else {\\n                auto [loc, bc]{qE.front()}; qE.pop();\\n                if(loc == -1) {\\n                    if(!qE.empty()) ++stepE, qE.emplace(-1,-1);\\n                    if(qE.empty() || qE.size() >= qS.size() && !qS.empty()) useS = true;\\n                    continue;\\n                }\\n                \\n                int16_t key = {(int16_t)(loc|(bc<<B_MASK))};\\n                if(visitedE[key] != -1) continue;\\n                visitedE[key] = stepE;\\n                if(visitedS[key] != -1) return stepE + visitedS[key];\\n\\n                if(loc-a >= 0 && !invalid[loc-a] && visitedE[key-a] == -1) qE.emplace(loc-a, bc);\\n                if(bc && loc+b <= stop && !invalid[loc+b] && visitedE[(key+b)%(1<<B_MASK)] == -1) qE.emplace(loc+b, 0);\\n            }\\n            \\n        }\\n        \\n        return -1; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935384,
                "title": "c-bfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\t\\tunordered_set<int> forbi(forbidden.begin(), forbidden.end());\\n\\t\\t\\tvector<vector<int>> visited(2,vector<int>(5000));\\n\\t\\t\\t// visited array has two states:\\n\\t\\t\\t// visited[0][i] means the ith cell was reached from its left hand side jumping forward, \\n\\t\\t\\t// visited[1][i] means the ith cell was reached from its right hand side jumping backward. \\n\\t\\t\\tqueue<pair<int,bool>> qu; \\n\\t\\t\\t// true means your last jump was backward jumping, you cannot jump backward in current step.\\n\\t\\t\\t// false, otherwise.\\n\\t\\t\\tqu.push({0,false});\\n\\t\\t\\tvisited[0][0] = 1;\\n\\t\\t\\tvisited[1][0] = 1;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\twhile(!qu.empty()) {\\n\\t\\t\\t\\tint len = qu.size();\\n\\t\\t\\t\\twhile(len > 0) {\\n\\t\\t\\t\\t\\tlen--;\\n\\t\\t\\t\\t\\tint cur = qu.front().first;\\n\\t\\t\\t\\t\\tbool flag = qu.front().second;\\n\\t\\t\\t\\t\\tif(cur == x) {\\n\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\t\\tif(forward < 5000 && visited[0][forward] == 0 && !forbi.count(forward)) {\\n\\t\\t\\t\\t\\t\\tqu.push({forward,false});\\n\\t\\t\\t\\t\\t\\tvisited[0][forward] = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(backward >=0 && visited[1][backward] == 0 && !forbi.count(backward) && !flag) {\\n\\t\\t\\t\\t\\t\\tqu.push({backward,true});\\n\\t\\t\\t\\t\\t\\tvisited[1][backward] = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\t\\tunordered_set<int> forbi(forbidden.begin(), forbidden.end());\\n\\t\\t\\tvector<vector<int>> visited(2,vector<int>(5000));\\n\\t\\t\\t// visited array has two states:\\n\\t\\t\\t// visited[0][i] means the ith cell was reached from its left hand side jumping forward, \\n\\t\\t\\t// visited[1][i] means the ith cell was reached from its right hand side jumping backward. \\n\\t\\t\\tqueue<pair<int,bool>> qu; \\n\\t\\t\\t// true means your last jump was backward jumping, you cannot jump backward in current step.\\n\\t\\t\\t// false, otherwise.\\n\\t\\t\\tqu.push({0,false}",
                "codeTag": "Java"
            },
            {
                "id": 936440,
                "title": "java-python-3-bfs-clean-codes-w-brief-explanation-and-analysis",
                "content": "**The key observation of the problem is that the variable to track the bug is a `vector`: direction and position.**\\n1. Use `0/True` and `1/False` to indicate forward and backward directions, respectively;\\n2. The bug at most need to reach `furthest = max(x, forbideen) + a + b` in order to arrive at `x`, hence the range of the position of the bug is `[0, furthest]`;\\n3. Use a Queue to maintain the vectors of the bug, use a Set to avoid forbidden positions and duplicates;\\n```java\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int steps = 0, furthest = x + a + b;\\n        Queue<Pair<Integer, Integer>> q = new LinkedList();\\n        q.offer(new Pair(0, 0)); // direction & position;\\n        Set<Pair<Integer, Integer>> seen = new HashSet<>(q);\\n        for (int pos : forbidden) {\\n            seen.add(new Pair(0, pos));\\n            seen.add(new Pair(1, pos));\\n            furthest = Math.max(furthest, pos + a + b);\\n        }\\n        while (!q.isEmpty()) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                Pair<Integer, Integer> p = q.poll();\\n                int dir = p.getKey(), pos = p.getValue();\\n                if (pos == x) {\\n                    return steps;\\n                }\\n                Pair<Integer, Integer> forward = new Pair<>(0, pos + a), backward = new Pair<>(1, pos - b);\\n                if (pos + a <= furthest && seen.add(forward)) {\\n                    q.offer(forward);\\n                }\\n                if (dir == 0 && pos - b >= 0 && seen.add(backward)) {\\n                    q.offer(backward);\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;                \\n    }\\n```\\n```python\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        dq, seen, steps, furthest = deque([(True, 0)]), {(True, 0)}, 0, max(x, max(forbidden)) + a + b\\n        for pos in forbidden:\\n            seen.add((True, pos)) \\n            seen.add((False, pos)) \\n        while dq:\\n            for _ in range(len(dq)):\\n                dir, pos = dq.popleft()\\n                if pos == x:\\n                    return steps\\n                forward, backward = (True, pos + a), (False, pos - b)\\n                if pos + a <= furthest and forward not in seen:\\n                    seen.add(forward)\\n                    dq.append(forward)\\n                if dir and pos - b > 0 and backward not in seen:\\n                    seen.add(backward)\\n                    dq.append(backward)    \\n            steps += 1         \\n        return -1\\n```\\n\\n**Analysis:**\\n\\nTime & space: O(max(x, max(forbidden)) + a + b).",
                "solutionTags": [],
                "code": "```java\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int steps = 0, furthest = x + a + b;\\n        Queue<Pair<Integer, Integer>> q = new LinkedList();\\n        q.offer(new Pair(0, 0)); // direction & position;\\n        Set<Pair<Integer, Integer>> seen = new HashSet<>(q);\\n        for (int pos : forbidden) {\\n            seen.add(new Pair(0, pos));\\n            seen.add(new Pair(1, pos));\\n            furthest = Math.max(furthest, pos + a + b);\\n        }\\n        while (!q.isEmpty()) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                Pair<Integer, Integer> p = q.poll();\\n                int dir = p.getKey(), pos = p.getValue();\\n                if (pos == x) {\\n                    return steps;\\n                }\\n                Pair<Integer, Integer> forward = new Pair<>(0, pos + a), backward = new Pair<>(1, pos - b);\\n                if (pos + a <= furthest && seen.add(forward)) {\\n                    q.offer(forward);\\n                }\\n                if (dir == 0 && pos - b >= 0 && seen.add(backward)) {\\n                    q.offer(backward);\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;                \\n    }\\n```\n```python\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        dq, seen, steps, furthest = deque([(True, 0)]), {(True, 0)}, 0, max(x, max(forbidden)) + a + b\\n        for pos in forbidden:\\n            seen.add((True, pos)) \\n            seen.add((False, pos)) \\n        while dq:\\n            for _ in range(len(dq)):\\n                dir, pos = dq.popleft()\\n                if pos == x:\\n                    return steps\\n                forward, backward = (True, pos + a), (False, pos - b)\\n                if pos + a <= furthest and forward not in seen:\\n                    seen.add(forward)\\n                    dq.append(forward)\\n                if dir and pos - b > 0 and backward not in seen:\\n                    seen.add(backward)\\n                    dq.append(backward)    \\n            steps += 1         \\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935419,
                "title": "python-deque-bfs-o-max-x-max-forbidden-a-b",
                "content": "The problem is actually quite straightforward. \\n\\nWe keep a deque *queue* of the positions to explore, and have an array *jumps* that records the number of jumps needed to reach the position. Forbidden positions in *jumps* are marked with -1.\\n\\nAt every step, we extract a position from *queue*. If we can make a jump forward - we update *jumps*, and add the new position to  *queue*.\\n\\nIf we can make the jump backward - we update *jumps*. As we cannot make two jumps backward, the *queue* is not updated. Instead, we check if we can make next jump forward (after the backward); if yes - we update *jumps* once again, and add the new position to  *queue*.\\n\\nFor performance, I use FIFO to extract positions from *queue*, because their required number of *jumps* is lower.\\n\\n**The role of *max_val***\\n\\nThis variable identifies the max. place for us to explore for solving the problem. It gives enough space after the last forbidden place or after *x* for the frog to try possible places. The basis for the formula is simple: the frog can freely jump backward from the last *a* spaces and not hit the forbidden, and if can jump forward from any of the b places after the last forbidden place.\\n\\nAssume that a=4, b=5. Let max. forbidden = 10. If we put the frog at any of the places in interval [11,19], it can jump to any of the places in the interval: e.g., 11->15->19->14->18->13->17->12->16->11.\\n\\nWe do need this feature, because if say forbidden = [1,2,3,5,6,7,10] and x=11, then the frog can jump to 11 only from 16, with the best path 0->4->8->12->16->11; thus, it needs that extra space beyond x and max(forbidden) to jump around.\\n\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \\n        max_val=max([x]+forbidden) +a+b\\n        \\n        jumps=[0]+[math.inf] * max_val\\n        for pos in forbidden: jumps[pos]=-1\\n        queue=deque([0])\\n        \\n        while queue:\\n            pos=queue.popleft()\\n            if pos+a<= max_val and jumps[pos+a]>jumps[pos]+1:\\n                queue.append(pos+a)\\n                jumps[pos+a]=jumps[pos]+1\\n            if pos-b>0 and  jumps[pos-b]>jumps[pos]+1:\\n                jumps[pos-b]=jumps[pos]+1\\n                if pos-b+a<= max_val and jumps[pos-b+a]>jumps[pos]+2:\\n                    queue.append(pos-b+a)\\n                    jumps[pos-b+a]=jumps[pos]+2\\n      \\n        return jumps[x] if jumps[x]<math.inf else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \\n        max_val=max([x]+forbidden) +a+b\\n        \\n        jumps=[0]+[math.inf] * max_val\\n        for pos in forbidden: jumps[pos]=-1\\n        queue=deque([0])\\n        \\n        while queue:\\n            pos=queue.popleft()\\n            if pos+a<= max_val and jumps[pos+a]>jumps[pos]+1:\\n                queue.append(pos+a)\\n                jumps[pos+a]=jumps[pos]+1\\n            if pos-b>0 and  jumps[pos-b]>jumps[pos]+1:\\n                jumps[pos-b]=jumps[pos]+1\\n                if pos-b+a<= max_val and jumps[pos-b+a]>jumps[pos]+2:\\n                    queue.append(pos-b+a)\\n                    jumps[pos-b+a]=jumps[pos]+2\\n      \\n        return jumps[x] if jumps[x]<math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159317,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    // to track the forbidden positions\\n    unordered_map<int,int>m;\\n    int dp[7001][2];\\n    int solve(int i,bool back,int a,int b,int x)\\n    {\\n        // base case\\n        if(i == x)return 0;\\n        // you cannot land on -ve n0.and blocked positions\\n        if( i < 0 || m.find(i)!= m.end() || i>6000 )\\n            return 1e9;\\n        \\n        \\n        if(dp[i][back]!=-1)return dp[i][back];\\n        int forward = 0;\\n        // either go forward \\n        dp[i][back] = 1 + solve(i+a,0,a,b,x);\\n        //go backward but cannot go consecutively 2 times\\n        if(!back)\\n        {\\n            dp[i][back] = min(dp[i][back],1 + solve(i-b,1,a,b,x));\\n        }\\n      \\n        return dp[i][back];\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        for(int i = 0 ; i<forbidden.size();i++)\\n            m[forbidden[i]] = 1;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(0,0,a,b,x);\\n        if(ans > 1e9)return -1;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // to track the forbidden positions\\n    unordered_map<int,int>m;\\n    int dp[7001][2];\\n    int solve(int i,bool back,int a,int b,int x)\\n    {\\n        // base case\\n        if(i == x)return 0;\\n        // you cannot land on -ve n0.and blocked positions\\n        if( i < 0 || m.find(i)!= m.end() || i>6000 )\\n            return 1e9;\\n        \\n        \\n        if(dp[i][back]!=-1)return dp[i][back];\\n        int forward = 0;\\n        // either go forward \\n        dp[i][back] = 1 + solve(i+a,0,a,b,x);\\n        //go backward but cannot go consecutively 2 times\\n        if(!back)\\n        {\\n            dp[i][back] = min(dp[i][back],1 + solve(i-b,1,a,b,x));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 935504,
                "title": "java-bfs-and-dfs-solution",
                "content": "Trick:\\n1.Need monitor both index and direction\\n2.Can\\'t go back twice, so max is Math.max(max value in forbidden, 2000) + 2 * b;\\n\\nDFS\\n```\\nclass Solution {\\n    private Map<String/*idx + direction*/, Integer> cache;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        cache = new HashMap<>();\\n        Set<Integer> visited = new HashSet<>(); \\n        Set<Integer> forbit = new HashSet<>();\\n        int maxLimit = 2000 + 2 * b;\\n        for(int num : forbidden){\\n            forbit.add(num);\\n            maxLimit = Math.max(maxLimit, num + 2 * b);\\n        }\\n        int val = helper(0, x, a, b, forbit, visited, 0, maxLimit);\\n        return val == Integer.MAX_VALUE ? -1 : val;\\n    }\\n    private int helper(int idx, int x, int a, int b, Set<Integer> forbit, Set<Integer> visited, int dir, int maxLimit){\\n        if(cache.containsKey(idx+\",\"+dir)){\\n            return cache.get(idx+\",\"+dir);\\n        }\\n        if(idx == x) return 0;\\n        if(idx < 0 || idx > maxLimit) return Integer.MAX_VALUE;\\n        visited.add(idx);\\n        int min = Integer.MAX_VALUE;\\n\\t\\t//try jump forward\\n        if(idx+a < maxLimit && !forbit.contains(idx+a) && !visited.contains(idx+a)){\\n            int step = helper(idx+a, x, a, b, forbit, visited, 0, maxLimit);\\n            if(step != Integer.MAX_VALUE){\\n                min = Math.min(min, step + 1);\\n            }\\n        }\\n\\t\\t//try jump back\\n       if(idx-b >= 0 && !forbit.contains(idx-b) && !visited.contains(idx-b) && dir != 1){\\n            int step = helper(idx-b, x, a, b, forbit, visited, 1, maxLimit);\\n            if(step != Integer.MAX_VALUE){\\n                min = Math.min(min, step + 1);\\n            }\\n        }\\n        visited.remove(idx);\\n        cache.put(idx+\",\"+dir, min);\\n        return min;\\n    }\\n}\\n```\\nBFS\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a1,a2)-> a1[0] - a2[0]);\\n        pq.offer(new int[]{0,0,0});//step, current index, direction(0 is back, 1 is forward)\\n        Set<Integer> forbit = new HashSet<>();\\n        Set<String> visited = new HashSet<>();\\n        int maxLimit = 2000 + 2 * b;\\n        for(int num : forbidden){\\n            forbit.add(num);\\n            maxLimit = Math.max(maxLimit, num + 2 * b);\\n        }\\n        while(!pq.isEmpty()){\\n            int[] node = pq.poll();\\n            int step = node[0];\\n            int idx = node[1];\\n            int dir = node[2];\\n            if(idx == x) return step;\\n\\t\\t\\t//try jump forward\\n            if(idx+a < maxLimit && !forbit.contains(idx+a) && !visited.contains(idx+a+\",\"+0)){\\n                visited.add(idx+a+\",\"+0);\\n                pq.offer(new int[]{step+1, idx+a, 0});\\n            }\\n\\t\\t\\t//try jump back\\n            if(idx-b >= 0 && !forbit.contains(idx-b) && !visited.contains(idx-b+\",\"+1) && dir != 1){\\n                visited.add(idx-b+\",\"+1);\\n                pq.offer(new int[]{step+1, idx-b, 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private Map<String/*idx + direction*/, Integer> cache;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        cache = new HashMap<>();\\n        Set<Integer> visited = new HashSet<>(); \\n        Set<Integer> forbit = new HashSet<>();\\n        int maxLimit = 2000 + 2 * b;\\n        for(int num : forbidden){\\n            forbit.add(num);\\n            maxLimit = Math.max(maxLimit, num + 2 * b);\\n        }\\n        int val = helper(0, x, a, b, forbit, visited, 0, maxLimit);\\n        return val == Integer.MAX_VALUE ? -1 : val;\\n    }\\n    private int helper(int idx, int x, int a, int b, Set<Integer> forbit, Set<Integer> visited, int dir, int maxLimit){\\n        if(cache.containsKey(idx+\",\"+dir)){\\n            return cache.get(idx+\",\"+dir);\\n        }\\n        if(idx == x) return 0;\\n        if(idx < 0 || idx > maxLimit) return Integer.MAX_VALUE;\\n        visited.add(idx);\\n        int min = Integer.MAX_VALUE;\\n\\t\\t//try jump forward\\n        if(idx+a < maxLimit && !forbit.contains(idx+a) && !visited.contains(idx+a)){\\n            int step = helper(idx+a, x, a, b, forbit, visited, 0, maxLimit);\\n            if(step != Integer.MAX_VALUE){\\n                min = Math.min(min, step + 1);\\n            }\\n        }\\n\\t\\t//try jump back\\n       if(idx-b >= 0 && !forbit.contains(idx-b) && !visited.contains(idx-b) && dir != 1){\\n            int step = helper(idx-b, x, a, b, forbit, visited, 1, maxLimit);\\n            if(step != Integer.MAX_VALUE){\\n                min = Math.min(min, step + 1);\\n            }\\n        }\\n        visited.remove(idx);\\n        cache.put(idx+\",\"+dir, min);\\n        return min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a1,a2)-> a1[0] - a2[0]);\\n        pq.offer(new int[]{0,0,0});//step, current index, direction(0 is back, 1 is forward)\\n        Set<Integer> forbit = new HashSet<>();\\n        Set<String> visited = new HashSet<>();\\n        int maxLimit = 2000 + 2 * b;\\n        for(int num : forbidden){\\n            forbit.add(num);\\n            maxLimit = Math.max(maxLimit, num + 2 * b);\\n        }\\n        while(!pq.isEmpty()){\\n            int[] node = pq.poll();\\n            int step = node[0];\\n            int idx = node[1];\\n            int dir = node[2];\\n            if(idx == x) return step;\\n\\t\\t\\t//try jump forward\\n            if(idx+a < maxLimit && !forbit.contains(idx+a) && !visited.contains(idx+a+\",\"+0)){\\n                visited.add(idx+a+\",\"+0);\\n                pq.offer(new int[]{step+1, idx+a, 0});\\n            }\\n\\t\\t\\t//try jump back\\n            if(idx-b >= 0 && !forbit.contains(idx-b) && !visited.contains(idx-b+\",\"+1) && dir != 1){\\n                visited.add(idx-b+\",\"+1);\\n                pq.offer(new int[]{step+1, idx-b, 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950952,
                "title": "fast-python-and-c-solution-with-explanation-bfs",
                "content": "The objective is to find the minimum number of hops. BFS is the ideal candidate for this question since it will provide the shortest path.\\n**Solution:**\\n1. We start exploring from `0` position. \\n2. At each position, we can either go forward by `a` and go backward by `b`. Thing to note here is we cannot go backward twice in a row so we will maintain a flag `isForward` to signal if the previous jump was a `forward` jump.\\n3. If the previous jump was `isForward` then we have 2 positions we can go to from current position `pos` -> `pos+a` and `pos-b`\\n4. If the previous jump was not `isForward` then we  can go to 1 position only from current position `pos` -> `pos+a`\\n5. To avoid going to the same `pos` multiple times we will maintain a `visited` data-structure which will keep track of already visited positions. We will also add forbidden positions to this data structure.\\n6. The tricky bit is to figure out when the forward limit. Since the question mentions that the max x is 2000. The absolute limit is `2000 + a + b`. As anything beyond this limit will always be greater than x because there is only one backward move allowed. So any position above this limit will not be added to the search queue.\\n7. Keep exploring the positions in the `queue` until you reach destination `x` in which case `return hops` or until the `queue` is empty in which case `return -1`\\n\\nPython\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        limit = 2000 + a + b\\n        visited = set(forbidden)\\n        myque = collections.deque([(0, True)]) # (pos, isForward) \\n        hops = 0\\n        while(myque):\\n            l = len(myque)\\n            while(l > 0):\\n                l -= 1\\n                pos, isForward = myque.popleft()\\n                if pos == x:\\n                    return hops\\n                if pos in visited: continue\\n                visited.add(pos)\\n                if isForward:\\n                    nxt_jump = pos - b\\n                    if nxt_jump >= 0:\\n                        myque.append((nxt_jump, False))\\n                nxt_jump = pos + a\\n                if nxt_jump <= limit:\\n                    myque.append((nxt_jump, True))\\n            hops += 1\\n        return -1\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        int limit = 2000 + a + b;\\n        std::queue<std::pair<int, int>> cur;\\n        cur.push({0, 1});\\n        std::unordered_set<int> visited;\\n        for (auto& x : forbidden){\\n            visited.insert(x);\\n        }\\n        \\n        int hops = 0;\\n        while(!cur.empty()){\\n            int size = cur.size();\\n            while(size--){\\n                auto it = cur.front(); cur.pop();\\n                int num = it.first;\\n                int forward = it.second;\\n                if (num == x) return hops;\\n                if (visited.count(num) != 0)\\n                    continue;\\n                visited.insert(num);\\n                if (forward){\\n                    int nxt = num - b;\\n                    if (nxt >= 0){\\n                        cur.push({nxt, 0});\\n                    }\\n                }\\n                int nxt = num + a;\\n                if (nxt <= limit){\\n                    cur.push({nxt, 1});\\n                }\\n            }\\n            ++hops;\\n        }\\n        return -1;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        limit = 2000 + a + b\\n        visited = set(forbidden)\\n        myque = collections.deque([(0, True)]) # (pos, isForward) \\n        hops = 0\\n        while(myque):\\n            l = len(myque)\\n            while(l > 0):\\n                l -= 1\\n                pos, isForward = myque.popleft()\\n                if pos == x:\\n                    return hops\\n                if pos in visited: continue\\n                visited.add(pos)\\n                if isForward:\\n                    nxt_jump = pos - b\\n                    if nxt_jump >= 0:\\n                        myque.append((nxt_jump, False))\\n                nxt_jump = pos + a\\n                if nxt_jump <= limit:\\n                    myque.append((nxt_jump, True))\\n            hops += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935401,
                "title": "python-dfs-issue-with-121-test-case-solved",
                "content": "**UPD:**\\n\\nI believe I have found the issue: I should be able to go back more if my back step is larger than my forward step. Thanks to @ShidaLei\\n for pointing it out.\\n\\n----------------------------------------------------------------------------------------------------------------\\nUpdated, working DFS solution, still not 100% about the \"toofar\" condition, one possibly could come up with test cases where this still breaks:\\n```\\ndef minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n\\tforbidden = set(forbidden)\\n\\ttoofar = max(forbidden) + b if a < b else x\\n\\tminsofar = -1\\n\\n\\tposition_cost = {}  # only record the cost when jumping forward\\n\\tdef minjumps(cur_pos = 0, jumped_back = False, jumpsmade = 0):\\n\\t\\tnonlocal minsofar, toofar\\n\\t\\tif cur_pos < 0 or \\\\\\n\\t\\t   cur_pos in forbidden or \\\\\\n\\t\\t   cur_pos - b > toofar or \\\\\\n\\t\\t   minsofar > -1 and jumpsmade > minsofar: return \\n\\n\\t\\tif cur_pos == x:\\n\\t\\t\\tminsofar = jumpsmade if minsofar == -1 else min(minsofar, jumpsmade)\\n\\t\\t\\treturn\\n\\n\\t\\tif jumped_back: # can only jump forward at this point\\n\\t\\t\\tminjumps(cur_pos + a, False, jumpsmade + 1)\\n\\t\\t\\treturn\\n\\t\\telif cur_pos not in position_cost: position_cost[cur_pos] = jumpsmade\\n\\t\\telif jumpsmade >= position_cost[cur_pos]: return\\n\\t\\telse: position_cost[cur_pos] = jumpsmade\\n\\n\\t\\tminjumps(cur_pos + a, False, jumpsmade + 1)\\n\\t\\tminjumps(cur_pos - b, True, jumpsmade + 1)\\n\\n\\tminjumps()\\n\\treturn minsofar\\n```\\n\\nTest case, for which I used to end up with  `-1` instead of `121`:\\n```\\n[162,118,178,152,167,100,40,74,199,186,26,73,200,127,30,124,193,84,184,36,103,149,153,9,54,154,133,95,45,198,79,157,64,122,59,71,48,177,82,35,14,176,16,108,111,6,168,31,134,164,136,72,98]\\n29\\n98\\n80\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n\\tforbidden = set(forbidden)\\n\\ttoofar = max(forbidden) + b if a < b else x\\n\\tminsofar = -1\\n\\n\\tposition_cost = {}  # only record the cost when jumping forward\\n\\tdef minjumps(cur_pos = 0, jumped_back = False, jumpsmade = 0):\\n\\t\\tnonlocal minsofar, toofar\\n\\t\\tif cur_pos < 0 or \\\\\\n\\t\\t   cur_pos in forbidden or \\\\\\n\\t\\t   cur_pos - b > toofar or \\\\\\n\\t\\t   minsofar > -1 and jumpsmade > minsofar: return \\n\\n\\t\\tif cur_pos == x:\\n\\t\\t\\tminsofar = jumpsmade if minsofar == -1 else min(minsofar, jumpsmade)\\n\\t\\t\\treturn\\n\\n\\t\\tif jumped_back: # can only jump forward at this point\\n\\t\\t\\tminjumps(cur_pos + a, False, jumpsmade + 1)\\n\\t\\t\\treturn\\n\\t\\telif cur_pos not in position_cost: position_cost[cur_pos] = jumpsmade\\n\\t\\telif jumpsmade >= position_cost[cur_pos]: return\\n\\t\\telse: position_cost[cur_pos] = jumpsmade\\n\\n\\t\\tminjumps(cur_pos + a, False, jumpsmade + 1)\\n\\t\\tminjumps(cur_pos - b, True, jumpsmade + 1)\\n\\n\\tminjumps()\\n\\treturn minsofar\\n```\n```\\n[162,118,178,152,167,100,40,74,199,186,26,73,200,127,30,124,193,84,184,36,103,149,153,9,54,154,133,95,45,198,79,157,64,122,59,71,48,177,82,35,14,176,16,108,111,6,168,31,134,164,136,72,98]\\n29\\n98\\n80\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1137466,
                "title": "c-recursive-dp-40ms",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    int dp[6001][2];\\n    \\n    \\n    int helper(int i, bool back , int a ,int b, int x) {\\n        if(i == x)\\n            return 0;\\n        if(i<0 || i>6000 || back>=2 || mp.find(i)!=mp.end())\\n            return 1e9;\\n        if(dp[i][back] != -1) \\n            return dp[i][back];\\n        \\n        dp[i][back] = 1+helper(i+a,0,a,b,x); //go forward\\n        \\n        if(!back) //cannot go consecutively backwards more than 1\\n        {\\n        dp[i][back] = min(dp[i][back] , helper(i-b,1,a,b,x)+1);  \\n        \\n        }\\n        return dp[i][back];\\n    }\\n    \\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++){\\n            mp[forbidden[i]] = 1;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = helper(0,0,a,b,x);\\n        if(ans>1e9) \\n               return -1;\\n        return ans;               \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    int dp[6001][2];\\n    \\n    \\n    int helper(int i, bool back , int a ,int b, int x) {\\n        if(i == x)\\n            return 0;\\n        if(i<0 || i>6000 || back>=2 || mp.find(i)!=mp.end())\\n            return 1e9;\\n        if(dp[i][back] != -1) \\n            return dp[i][back];\\n        \\n        dp[i][back] = 1+helper(i+a,0,a,b,x); //go forward\\n        \\n        if(!back) //cannot go consecutively backwards more than 1\\n        {\\n        dp[i][back] = min(dp[i][back] , helper(i-b,1,a,b,x)+1);  \\n        \\n        }\\n        return dp[i][back];\\n    }\\n    \\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++){\\n            mp[forbidden[i]] = 1;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = helper(0,0,a,b,x);\\n        if(ans>1e9) \\n               return -1;\\n        return ans;               \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375366,
                "title": "c-simple-c-code-2-approach",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n**BFS**\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6002, vector<int> (2,0));\\n        if(x == 0) return 0;\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            dp[num][0]++;\\n            dp[num][1]++;\\n        }\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({0,1});\\n        if(dp[x][1]) return -1;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> tp = q.front();\\n                q.pop();\\n                int val = tp.first;\\n                int ab = tp.second;\\n                if(val == x) return ans;\\n                if(ab)\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                    tmp = val - b;\\n                    if(tmp >= 0 && !dp[tmp][0])\\n                    {\\n                        q.push({tmp, 0});\\n                        dp[tmp][0]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**DFS**\\n```\\nclass Solution {\\n    unordered_map<int, int> um;\\n    int dfs(int a, int b, int x, int val, int pn, vector<vector<int>> &dp)\\n    {\\n        if(val == x) return 0;\\n        if(um.count(val)) return 6000;\\n        if(val < 0 || val > 6000) return 6000;\\n        if(dp[val][pn] != -1)\\n            return dp[val][pn];\\n        dp[val][pn] = 1 + dfs(a,b,x,val+a, 0, dp);\\n        if(pn == 0)\\n            dp[val][pn] = min(dp[val][pn], 1+dfs(a, b, x, val-b, 1,dp));\\n        return dp[val][pn];\\n    }\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6001, vector<int> (2, -1));\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            um[num]++;\\n        }\\n        int val = dfs(a, b, x, 0, 0, dp);\\n        if(val >= 6000) return -1;\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6002, vector<int> (2,0));\\n        if(x == 0) return 0;\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            dp[num][0]++;\\n            dp[num][1]++;\\n        }\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({0,1});\\n        if(dp[x][1]) return -1;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> tp = q.front();\\n                q.pop();\\n                int val = tp.first;\\n                int ab = tp.second;\\n                if(val == x) return ans;\\n                if(ab)\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                    tmp = val - b;\\n                    if(tmp >= 0 && !dp[tmp][0])\\n                    {\\n                        q.push({tmp, 0});\\n                        dp[tmp][0]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    unordered_map<int, int> um;\\n    int dfs(int a, int b, int x, int val, int pn, vector<vector<int>> &dp)\\n    {\\n        if(val == x) return 0;\\n        if(um.count(val)) return 6000;\\n        if(val < 0 || val > 6000) return 6000;\\n        if(dp[val][pn] != -1)\\n            return dp[val][pn];\\n        dp[val][pn] = 1 + dfs(a,b,x,val+a, 0, dp);\\n        if(pn == 0)\\n            dp[val][pn] = min(dp[val][pn], 1+dfs(a, b, x, val-b, 1,dp));\\n        return dp[val][pn];\\n    }\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6001, vector<int> (2, -1));\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            um[num]++;\\n        }\\n        int val = dfs(a, b, x, 0, 0, dp);\\n        if(val >= 6000) return -1;\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357034,
                "title": "c-bfs",
                "content": "simple bfs with only constraint to check previous step. 1 and 0 indicate backward and forward .\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int> v;\\n        queue<pair<int,int>> q; \\n        for(auto i:forbidden){\\n            v[i]=true;\\n        }\\n        q.push({0,0}) ; \\n        int ans = 0;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            while(size--){\\n                auto curr = q.front() ;\\n                q.pop() ;\\n                int num = curr.first;\\n                if(num == x){\\n                    return ans;\\n                }\\n               \\n                if(v[num] == true){\\n                    continue;\\n                } \\n                v[num]=true;\\n                if(curr.second == 0 && num-b>=0) {\\n                    q.push({(num-b),1});\\n                }\\n                if(num <= 2000+b){\\n                    q.push({(num+a),0});                 \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int> v;\\n        queue<pair<int,int>> q; \\n        for(auto i:forbidden){\\n            v[i]=true;\\n        }\\n        q.push({0,0}) ; \\n        int ans = 0;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            while(size--){\\n                auto curr = q.front() ;\\n                q.pop() ;\\n                int num = curr.first;\\n                if(num == x){\\n                    return ans;\\n                }\\n               \\n                if(v[num] == true){\\n                    continue;\\n                } \\n                v[num]=true;\\n                if(curr.second == 0 && num-b>=0) {\\n                    q.push({(num-b),1});\\n                }\\n                if(num <= 2000+b){\\n                    q.push({(num+a),0});                 \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966234,
                "title": "c-easy-to-understand-recursive-memoized-code-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    const int inf = 1e9;\\n  \\n    unordered_set<int> set;\\n  \\n    int dp[6005][2];\\n  \\n    int go(int pos, int target, int fwd, int bwd, int cnt)\\n    {\\n      if(pos == target)\\n        return 0;\\n      \\n      if(set.find(pos) != set.end() or pos < 0 or pos > 6000)\\n        return inf;\\n      \\n      if(dp[pos][cnt] != -1)\\n          return dp[pos][cnt];\\n      \\n      dp[pos][cnt] = 1 + go(pos + fwd, target, fwd, bwd, 0);\\n      dp[pos][cnt] = min(dp[pos][cnt],  (cnt) ? 1 + go(pos + fwd, target, fwd, bwd, 0) : 1 + go(pos - bwd, target, fwd, bwd, 1));\\n      \\n      return dp[pos][cnt];\\n    }\\n  \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n      for(int ele : forbidden)\\n        set.insert(ele);\\n      \\n      memset(dp, -1, sizeof dp);\\n      int ans = go(0, x, a, b, 0);\\n      return (ans >= 1e9) ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int inf = 1e9;\\n  \\n    unordered_set<int> set;\\n  \\n    int dp[6005][2];\\n  \\n    int go(int pos, int target, int fwd, int bwd, int cnt)\\n    {\\n      if(pos == target)\\n        return 0;\\n      \\n      if(set.find(pos) != set.end() or pos < 0 or pos > 6000)\\n        return inf;\\n      \\n      if(dp[pos][cnt] != -1)\\n          return dp[pos][cnt];\\n      \\n      dp[pos][cnt] = 1 + go(pos + fwd, target, fwd, bwd, 0);\\n      dp[pos][cnt] = min(dp[pos][cnt],  (cnt) ? 1 + go(pos + fwd, target, fwd, bwd, 0) : 1 + go(pos - bwd, target, fwd, bwd, 1));\\n      \\n      return dp[pos][cnt];\\n    }\\n  \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n      for(int ele : forbidden)\\n        set.insert(ele);\\n      \\n      memset(dp, -1, sizeof dp);\\n      int ans = go(0, x, a, b, 0);\\n      return (ans >= 1e9) ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935424,
                "title": "java-bfs-there-should-be-2-states-for-the-bfs-expansion",
                "content": "Mose people failing some test case is beacuse they use one state. \\nThere should be two state for the expansion :[currentPos,direction]\\n\\n`Additional Question` : why we can beak the position if we pass certain limit?\\nWe must considerate **Two Case**: a>b and  b>a\\n\\n1. if a>b, since we can go backward only 1 time,if x pass certain limit, after we do pos-b, the next step is always pos+a, which will increase the position further, the pos will only keep increasing and we can never go back\\n2. if b>a, in this case, since the backward is larger, we can go back by  at most  (b-a).  Let\\'s say out current pos is Y(Y>x,if not, just go forward).We want to reach x and (Y-x)%(b-a)=0.We may do (Y-x)/(b-a) steps. Y=(b-a)*x. We can see at some point, we can bound the Y \\n\\n\\n\\n```\\nclass Solution {\\n    Set<Integer>bad=new HashSet<>();\\n    Set<String>set=new HashSet<>();\\n    public int minimumJumps(int[] A, int a, int b, int x) {\\n        for(int i:A){\\n            bad.add(i);\\n        }\\n        \\n        Queue<int[]>q=new LinkedList<>();\\n        q.add(new int[]{0,0,0});\\n        set.add(\"0,0\");\\n        while(q.size()!=0){\\n            int pair[]=q.poll();\\n            \\n            int pos=pair[0],level=pair[1],state=pair[2];\\n            if(pos==x)return level;\\n            \\n            if(state>=0){\\n                if(pos<=10000&&!set.contains((pos+a)+\",0\")&&!bad.contains(pos+a)){\\n                    set.add((pos+a)+\",0\");\\n                    q.add(new int[]{pos+a,level+1,0});\\n                }\\n                \\n                if(!set.contains((pos-b)+\",-1\")&&!bad.contains(pos-b)&&pos-b>=0){\\n                    set.add((pos-b)+\",-1\");\\n                    q.add(new int[]{pos-b,level+1,-1});\\n                }\\n            }\\n            else if(state<0){\\n                if(pos<=10000&&!set.contains((pos+a)+\",0\")&&!bad.contains(pos+a)){\\n                    set.add((pos+a)+\",0\");\\n                    q.add(new int[]{pos+a,level+1,0});\\n                }\\n               \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<Integer>bad=new HashSet<>();\\n    Set<String>set=new HashSet<>();\\n    public int minimumJumps(int[] A, int a, int b, int x) {\\n        for(int i:A){\\n            bad.add(i);\\n        }\\n        \\n        Queue<int[]>q=new LinkedList<>();\\n        q.add(new int[]{0,0,0});\\n        set.add(\"0,0\");\\n        while(q.size()!=0){\\n            int pair[]=q.poll();\\n            \\n            int pos=pair[0],level=pair[1],state=pair[2];\\n            if(pos==x)return level;\\n            \\n            if(state>=0){\\n                if(pos<=10000&&!set.contains((pos+a)+\",0\")&&!bad.contains(pos+a)){\\n                    set.add((pos+a)+\",0\");\\n                    q.add(new int[]{pos+a,level+1,0});\\n                }\\n                \\n                if(!set.contains((pos-b)+\",-1\")&&!bad.contains(pos-b)&&pos-b>=0){\\n                    set.add((pos-b)+\",-1\");\\n                    q.add(new int[]{pos-b,level+1,-1});\\n                }\\n            }\\n            else if(state<0){\\n                if(pos<=10000&&!set.contains((pos+a)+\",0\")&&!bad.contains(pos+a)){\\n                    set.add((pos+a)+\",0\");\\n                    q.add(new int[]{pos+a,level+1,0});\\n                }\\n               \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943895,
                "title": "c-bfs-solution",
                "content": "```\\n// visited table is desgined for two conditions:\\n// visited when can go backward/can\\'t go backward\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> forbidIndex;\\n        for(auto f:forbidden){\\n            forbidIndex.insert(f);\\n        }\\n        vector<pair<bool,bool>> visited(6000, {false, false}); // visited when can go back, when can\\'t\\n        visited[0].first = true;\\n        queue<pair<int, bool>> q; // {current index, if prev step is jump backward}\\n        q.push({0, false});\\n        int stepCount = 0;\\n        while(q.size()){\\n            int size = q.size();\\n            while(size--){\\n                int curIndex = q.front().first;\\n                bool prevBackWard = q.front().second;\\n                q.pop();\\n                if(curIndex == x){\\n                    return stepCount;\\n                }else{\\n                    int nextIndex = curIndex+a;\\n                    if(nextIndex < 6000 && forbidIndex.count(nextIndex)==0 && !visited[nextIndex].first){\\n                        q.push({nextIndex, false});\\n                        visited[nextIndex].first = true;\\n                    }\\n                    if(!prevBackWard){ // we can jump backward now!\\n                        nextIndex = curIndex-b;\\n                        if(nextIndex > 0 && forbidIndex.count(nextIndex)==0 && !visited[nextIndex].second){\\n                            q.push({nextIndex, true});\\n                            visited[nextIndex].second = true;\\n                        }\\n                    }\\n                }\\n            }\\n            stepCount++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n// visited table is desgined for two conditions:\\n// visited when can go backward/can\\'t go backward\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> forbidIndex;\\n        for(auto f:forbidden){\\n            forbidIndex.insert(f);\\n        }\\n        vector<pair<bool,bool>> visited(6000, {false, false}); // visited when can go back, when can\\'t\\n        visited[0].first = true;\\n        queue<pair<int, bool>> q; // {current index, if prev step is jump backward}\\n        q.push({0, false});\\n        int stepCount = 0;\\n        while(q.size()){\\n            int size = q.size();\\n            while(size--){\\n                int curIndex = q.front().first;\\n                bool prevBackWard = q.front().second;\\n                q.pop();\\n                if(curIndex == x){\\n                    return stepCount;\\n                }else{\\n                    int nextIndex = curIndex+a;\\n                    if(nextIndex < 6000 && forbidIndex.count(nextIndex)==0 && !visited[nextIndex].first){\\n                        q.push({nextIndex, false});\\n                        visited[nextIndex].first = true;\\n                    }\\n                    if(!prevBackWard){ // we can jump backward now!\\n                        nextIndex = curIndex-b;\\n                        if(nextIndex > 0 && forbidIndex.count(nextIndex)==0 && !visited[nextIndex].second){\\n                            q.push({nextIndex, true});\\n                            visited[nextIndex].second = true;\\n                        }\\n                    }\\n                }\\n            }\\n            stepCount++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935517,
                "title": "simple-concise-cpp-bfs",
                "content": "```\\nusing tup = tuple<int, int, bool>; // location, count, previous_jump(forward or backward)\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<tup> que; // forward true\\n        set<pair<int, bool>> seen; //previous jump direction with its location\\n        que.push({0, 0, true});\\n        for (int i : forbidden) \\n            seen.insert({i, true}), seen.insert({i, false});\\n        while (!que.empty()) {\\n            auto [loc, count, forward] = que.front();\\n            que.pop();\\n            if (loc == x) \\n                return count;\\n            else if (seen.count({loc, forward}) || loc > 6000)\\n                continue;\\n            seen.insert({loc, forward});\\n            que.push({loc + a, count + 1, true});\\n            if (forward && loc >= b)\\n                que.push({loc - b, count + 1, false});\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nusing tup = tuple<int, int, bool>; // location, count, previous_jump(forward or backward)\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<tup> que; // forward true\\n        set<pair<int, bool>> seen; //previous jump direction with its location\\n        que.push({0, 0, true});\\n        for (int i : forbidden) \\n            seen.insert({i, true}), seen.insert({i, false});\\n        while (!que.empty()) {\\n            auto [loc, count, forward] = que.front();\\n            que.pop();\\n            if (loc == x) \\n                return count;\\n            else if (seen.count({loc, forward}) || loc > 6000)\\n                continue;\\n            seen.insert({loc, forward});\\n            que.push({loc + a, count + 1, true});\\n            if (forward && loc >= b)\\n                que.push({loc - b, count + 1, false});\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144639,
                "title": "java-bfs-with-details-explanation",
                "content": "Basically, this is a BFS issue, but the details make me crazy.\\n\\nBasically, the idea here is that :\\n- Start from index : 0 with direction forward ( you can set to backward too, if you want)\\n- Go to the next idx  with step `a` and `b`,  but we need to make sure \\n\\t- index  > 0\\n\\t-  if we move backward,  should no backward in a row\\n\\n\\nWith below thought in mind, you will be easily come with below solution:\\n## BFS initial version\\n\\n```\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<Integer> visitedIdx = new HashSet<>();\\n        int steps = 0;\\n        \\n        for (int f : forbidden) {\\n            visitedIdx.add(f);\\n        }\\n        \\n        q.offer(new int[]{0, 1});\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                \\n                int[] cur = q.poll();\\n                int value = cur[0];\\n                int direction = cur[1];\\n             \\n                if (!visitedIdx.contains(value) ) {\\n                    visitedIdx.add(value);\\n                    \\n                    if (value == x) {\\n                        return steps;\\n                    }\\n                    \\n                    if (value + a > 0 && !visitedIdx.contains(value + a)) {\\n                        q.offer(new int[]{value + a, 1});\\n                    }\\n                    \\n                    if (value - b > 0  && !visitedIdx.contains(value - b) && direction != 0) {\\n                        q.offer(new int[]{value - b, 0});\\n                    }\\n                    \\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n```\\n\\n#### issues \\n- you will get timeout for most of the case\\n\\n\\n##### solution\\n- we missed quit conditions in the for loop, so put `value <= 6000` , explantion can be found in the below part.\\n- the change can fixed some failed case, but the funny things is \\n\\n```\\n-  If i change the value 6000 to 6500, some cases passed when value <= 6000 failed after change the value to 6500.\\n \\n```\\n\\nAfter adding logs in the code, there is one impartant thing for the `visitedIdx` is that : \\n```\\nvisitedIdx  * *MUST* * contains the directions, because the same index can be visited both forward and backward, if we simply check the index without direction, we will lose the half possiblity. which can cause the result to -1.\\n\\n```\\n\\n## Final Version\\n\\n```\\n        //using BFS to find the target index, \\n        // first value indicate the idx, second value indicate the direction(0: back, 1: forward)\\n        \\n        // MOST important: for the visited set , we need to save the direction and idx, or we will lose the answer\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<List<Integer>> visitedIdx = new HashSet<>();\\n        int steps = 0;\\n        \\n        for (int f : forbidden) {\\n            visitedIdx.add(Arrays.asList(f, 1));\\n            visitedIdx.add(Arrays.asList(f, 0));\\n        }\\n        \\n        q.offer(new int[]{0, 1});\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                \\n                int[] cur = q.poll();\\n                int value = cur[0];\\n                int direction = cur[1];\\n                \\n                List<Integer> node = Arrays.asList(value, direction);\\n                \\n                \\n                // the reason why 6000 is becase: target x is max 2000, and a max 2000, \\n                // that means, x + a with max value to x + a + a \\n                if (!visitedIdx.contains(node) && value <= 6000) {\\n                    visitedIdx.add(node);\\n                    \\n                    if (value == x) {\\n                        return steps;\\n                    }\\n                    \\n                    if (value + a > 0 && !visitedIdx.contains(Arrays.asList(value + a, 1))) {\\n                        q.offer(new int[]{value + a, 1});\\n                    }\\n                    \\n                    if (value - b > 0  && !visitedIdx.contains(Arrays.asList(value - b, 0)) && direction != 0) {\\n                        q.offer(new int[]{value - b, 0});\\n                    }\\n                    \\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n```",
                "solutionTags": [],
                "code": "```\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<Integer> visitedIdx = new HashSet<>();\\n        int steps = 0;\\n        \\n        for (int f : forbidden) {\\n            visitedIdx.add(f);\\n        }\\n        \\n        q.offer(new int[]{0, 1});\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                \\n                int[] cur = q.poll();\\n                int value = cur[0];\\n                int direction = cur[1];\\n             \\n                if (!visitedIdx.contains(value) ) {\\n                    visitedIdx.add(value);\\n                    \\n                    if (value == x) {\\n                        return steps;\\n                    }\\n                    \\n                    if (value + a > 0 && !visitedIdx.contains(value + a)) {\\n                        q.offer(new int[]{value + a, 1});\\n                    }\\n                    \\n                    if (value - b > 0  && !visitedIdx.contains(value - b) && direction != 0) {\\n                        q.offer(new int[]{value - b, 0});\\n                    }\\n                    \\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n```\n```\\n-  If i change the value 6000 to 6500, some cases passed when value <= 6000 failed after change the value to 6500.\\n \\n```\n```\\nvisitedIdx  * *MUST* * contains the directions, because the same index can be visited both forward and backward, if we simply check the index without direction, we will lose the half possiblity. which can cause the result to -1.\\n\\n```\n```\\n        //using BFS to find the target index, \\n        // first value indicate the idx, second value indicate the direction(0: back, 1: forward)\\n        \\n        // MOST important: for the visited set , we need to save the direction and idx, or we will lose the answer\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<List<Integer>> visitedIdx = new HashSet<>();\\n        int steps = 0;\\n        \\n        for (int f : forbidden) {\\n            visitedIdx.add(Arrays.asList(f, 1));\\n            visitedIdx.add(Arrays.asList(f, 0));\\n        }\\n        \\n        q.offer(new int[]{0, 1});\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                \\n                int[] cur = q.poll();\\n                int value = cur[0];\\n                int direction = cur[1];\\n                \\n                List<Integer> node = Arrays.asList(value, direction);\\n                \\n                \\n                // the reason why 6000 is becase: target x is max 2000, and a max 2000, \\n                // that means, x + a with max value to x + a + a \\n                if (!visitedIdx.contains(node) && value <= 6000) {\\n                    visitedIdx.add(node);\\n                    \\n                    if (value == x) {\\n                        return steps;\\n                    }\\n                    \\n                    if (value + a > 0 && !visitedIdx.contains(Arrays.asList(value + a, 1))) {\\n                        q.offer(new int[]{value + a, 1});\\n                    }\\n                    \\n                    if (value - b > 0  && !visitedIdx.contains(Arrays.asList(value - b, 0)) && direction != 0) {\\n                        q.offer(new int[]{value - b, 0});\\n                    }\\n                    \\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935575,
                "title": "python-bfs-with-detailed-explanation",
                "content": "The basic setup is to do a BFS starting from position 0, and according to the rules, try to move forward or backward till we reach x. However, there are a few catches:\\n1. We cannot move backward twice in a row. To handle this, we store the state in the queue as `(0,1)` where the first element is the position and the second element is the direction of the last move. If the previous move was in the forward direction, then we can try the backwards direction.\\n2. We may land on the same position (`z`) either by moving forward (`p1 + a = z`) or backward (`p2 - b = z`). To handle this, we will iterate through the queue twice, and process all forward jumps first, then the backward jumps. The reason is because the forward jumps have no restrictions and we land on the same position, so we lose nothing by keeping only the forward jumps.\\n3. We need to bound the positions we search, otherwise the code will run forever. For the lower bound, it is given by the question that we cannot visit negative integers. For the upper bound, it is given by `max(x, max(forbidden)) + a + b`. This value is the largest position that we should explore such that it may be possible to backtrack to the bug\\'s home. For example, `a = 2, b = 3, forbidden = [7], x = 9`. We will take the path: `2 -> 4 -> 6 -> 8 -> 10 -> 12 -> 9`. Thus, at the very end we may need to go past our destination and then backtrack. We need to take into account both `x` and `max(forbidden)` because `max(forbidden)` can be insignificant or e.g. the following input: `forbidden = [10], a = 20, b = 19, x = 101`.\\n\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = deque([(0,1)])\\n        jumps = 0\\n        forbidden = set(forbidden)\\n        forbidden.add(0)\\n        MAX_DIST = max(x, max(forbidden)) + a + b\\n        while queue:\\n            tmp = deque()\\n            for elem in queue:\\n                (pos, direction) = elem\\n                if pos == x: return jumps\\n                forward = pos + a\\n                if forward not in forbidden and forward <= MAX_DIST:\\n                    tmp.append((forward, 1))\\n                    forbidden.add(forward)\\n            for elem in queue:\\n                (pos, direction) = elem\\n                if pos == x: return jumps\\n                backward = pos - b\\n                if direction != -1 and backward >= 0 and backward not in forbidden:\\n                    tmp.append((backward, -1))\\n                    forbidden.add(backward)\\n            queue = tmp\\n            jumps += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = deque([(0,1)])\\n        jumps = 0\\n        forbidden = set(forbidden)\\n        forbidden.add(0)\\n        MAX_DIST = max(x, max(forbidden)) + a + b\\n        while queue:\\n            tmp = deque()\\n            for elem in queue:\\n                (pos, direction) = elem\\n                if pos == x: return jumps\\n                forward = pos + a\\n                if forward not in forbidden and forward <= MAX_DIST:\\n                    tmp.append((forward, 1))\\n                    forbidden.add(forward)\\n            for elem in queue:\\n                (pos, direction) = elem\\n                if pos == x: return jumps\\n                backward = pos - b\\n                if direction != -1 and backward >= 0 and backward not in forbidden:\\n                    tmp.append((backward, -1))\\n                    forbidden.add(backward)\\n            queue = tmp\\n            jumps += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748557,
                "title": "c-bfs-clear-and-concise-solution-with-comments-65-time-78-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n      unordered_map<int, int> um;\\n      for(auto &pos: forbidden){  // Adding all the forbidden positions\\n        um[pos]++;\\n      }\\n      queue<pair<int, pair<int, bool>>> q;  \\n\\t  // Queue will store the Position, Number of hops and \\n\\t  // a bool variable that will denote if the last hop was in\\n\\t  // forward direction or backward (True: forward, False: backward)\\n      q.push({0, {0, true}});\\n      while(!q.empty()){\\n        auto node = q.front();\\n        int currPos = node.first, ans = node.second.first;\\n        bool canGoBackwards = node.second.second;  \\n        q.pop();\\n        if(currPos == x) return ans;\\n\\t\\t// If the position is already visited we do not add forward and backward from that position\\n        if(um.find(currPos) != um.end()) continue;  \\n        um[currPos]++;\\n        int forward = currPos + a, backward = currPos - b;\\n        if(canGoBackwards and backward >= 0){\\n          q.push({backward, {ans + 1, false}});\\n        }\\n        if(forward <= 2000 + a + b){    // 1 <= a, b, forbidden[i] <= 2000\\n          // We can at max come backwards from (2000 + a + b) position to x position\\n          q.push({forward, {ans + 1, true}});\\n        }\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n      unordered_map<int, int> um;\\n      for(auto &pos: forbidden){  // Adding all the forbidden positions\\n        um[pos]++;\\n      }\\n      queue<pair<int, pair<int, bool>>> q;  \\n\\t  // Queue will store the Position, Number of hops and \\n\\t  // a bool variable that will denote if the last hop was in\\n\\t  // forward direction or backward (True: forward, False: backward)\\n      q.push({0, {0, true}});\\n      while(!q.empty()){\\n        auto node = q.front();\\n        int currPos = node.first, ans = node.second.first;\\n        bool canGoBackwards = node.second.second;  \\n        q.pop();\\n        if(currPos == x) return ans;\\n\\t\\t// If the position is already visited we do not add forward and backward from that position\\n        if(um.find(currPos) != um.end()) continue;  \\n        um[currPos]++;\\n        int forward = currPos + a, backward = currPos - b;\\n        if(canGoBackwards and backward >= 0){\\n          q.push({backward, {ans + 1, false}});\\n        }\\n        if(forward <= 2000 + a + b){    // 1 <= a, b, forbidden[i] <= 2000\\n          // We can at max come backwards from (2000 + a + b) position to x position\\n          q.push({forward, {ans + 1, true}});\\n        }\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885961,
                "title": "c-bfs-easy-to-understand-solution",
                "content": "## **APPROACH**\\n* So consider this vector as graph and for any index i you have two options either to go right for exactly a steps  or left for exactly b steps  but you need to take care that no consectuve back steps(left) are taken.\\n* So to handle this we can keep track of last move in queue itself where before taking left step , we first check whether last move taken was in right or left.\\n* If lastMove was left , then only consider right step right now , but if lastMove was right , consider both left and right move.\\n* But now comes one more problem.\\n* Do we need to mark indexes as visited for both the steps?\\n* Actually not...\\n* See if you reach to some location **Q** through a backward step , now you cannot take one more backward , but it is possible that one backward is the place to reach **X** i.e the final destination.\\n* And also it is possible to reach **Q** from front taking a step and then one backward will reach to **X**.\\n* So to tackle this ,make sure to mark a point as visited only when you visit that from front direction and not from back direction.\\n\\n\\n## **CODE**\\u2714\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\n        unordered_set<int> visited(forbidden.begin(),forbidden.end());\\n        \\n        queue<pair<int,int>> q;  // here second value is what last move was taken\\n        q.push({0,1});          // 1 for to the right and -1 for left\\n        visited.insert(0);\\n        \\n        int level=0;\\n        while(!q.empty())\\n        {\\n            level++;\\n            int size=q.size();\\n            \\n            while(size--)\\n            {\\n                int u,lastMove;\\n                tie(u,lastMove)=q.front();\\n                q.pop();\\n                \\n                if(u==x)\\n                    return level-1;\\n                \\n                int forward=u+a;\\n                int backward=u-b;\\n                \\n                if(forward<=6000 && visited.find(forward)==visited.end())\\n                {\\n                    q.push({forward,1});\\n                    visited.insert(forward);  \\n                }\\n                \\n                if(lastMove==1 && backward>=0 && visited.find(backward)==visited.end() )\\n                {\\n                     q.push({backward,-1});\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n\\n### **TIME-COMPLEXITY :**\\nO(n) , n=6000\\nFor upper limit in right direction , took 6000 which is 3 times of maximum jump in right , not sure for this , how it works!!\\n### **SPACE-COMPLEXITY:**\\nO(n)",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\n        unordered_set<int> visited(forbidden.begin(),forbidden.end());\\n        \\n        queue<pair<int,int>> q;  // here second value is what last move was taken\\n        q.push({0,1});          // 1 for to the right and -1 for left\\n        visited.insert(0);\\n        \\n        int level=0;\\n        while(!q.empty())\\n        {\\n            level++;\\n            int size=q.size();\\n            \\n            while(size--)\\n            {\\n                int u,lastMove;\\n                tie(u,lastMove)=q.front();\\n                q.pop();\\n                \\n                if(u==x)\\n                    return level-1;\\n                \\n                int forward=u+a;\\n                int backward=u-b;\\n                \\n                if(forward<=6000 && visited.find(forward)==visited.end())\\n                {\\n                    q.push({forward,1});\\n                    visited.insert(forward);  \\n                }\\n                \\n                if(lastMove==1 && backward>=0 && visited.find(backward)==visited.end() )\\n                {\\n                     q.push({backward,-1});\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850544,
                "title": "c-solution-bfs-simple-commented",
                "content": "```\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t//to hold forbidden positions\\n\\tunordered_set<int> st{forbidden.begin(),forbidden.end()};\\n\\tqueue<pair<int,int>> Q;\\n\\t//pait {a,b} a---> position b----> last jump(forward===0 or backward==1)\\n\\tQ.push({0,0});\\n\\t//insert 0 in forbidden list\\n\\tst.insert(0);\\n\\tint steps=0;\\n\\twhile(!Q.empty()){\\n\\t\\tint s=Q.size();\\n\\t\\twhile(s--){\\n\\t\\t\\tint u=Q.front().first;\\n\\t\\t\\tint f=Q.front().second;\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tif(u==x) return steps;\\n\\t\\t\\t//r---->forward jump,l----->backward jump\\n\\t\\t\\tint r=u+a,l=u-b;\\n\\t\\t\\t//backward jump only if previous jump is forward and position is not in forbidden list\\n\\t\\t\\tif(!f and l>=0 and !st.count(l)){\\n\\t\\t\\t\\tst.insert(l);\\n\\t\\t\\t\\tQ.push({l,1});\\n\\t\\t\\t}\\n\\t\\t\\t// As x,a,b take max values of 2000 each, max forward jump can be 6000\\n\\t\\t\\tif(r<=6000 and !st.count(r)){\\n\\t\\t\\t\\tst.insert(r);\\n\\t\\t\\t\\tQ.push({r,0});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsteps++;\\n\\t}\\n\\treturn -1;\\n}\\n```\\n\\n**Please upvote: )**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t//to hold forbidden positions\\n\\tunordered_set<int> st{forbidden.begin(),forbidden.end()};\\n\\tqueue<pair<int,int>> Q;\\n\\t//pait {a,b} a---> position b----> last jump(forward===0 or backward==1)\\n\\tQ.push({0,0});\\n\\t//insert 0 in forbidden list\\n\\tst.insert(0);\\n\\tint steps=0;\\n\\twhile(!Q.empty()){\\n\\t\\tint s=Q.size();\\n\\t\\twhile(s--){\\n\\t\\t\\tint u=Q.front().first;\\n\\t\\t\\tint f=Q.front().second;\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tif(u==x) return steps;\\n\\t\\t\\t//r---->forward jump,l----->backward jump\\n\\t\\t\\tint r=u+a,l=u-b;\\n\\t\\t\\t//backward jump only if previous jump is forward and position is not in forbidden list\\n\\t\\t\\tif(!f and l>=0 and !st.count(l)){\\n\\t\\t\\t\\tst.insert(l);\\n\\t\\t\\t\\tQ.push({l,1});\\n\\t\\t\\t}\\n\\t\\t\\t// As x,a,b take max values of 2000 each, max forward jump can be 6000\\n\\t\\t\\tif(r<=6000 and !st.count(r)){\\n\\t\\t\\t\\tst.insert(r);\\n\\t\\t\\t\\tQ.push({r,0});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsteps++;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935774,
                "title": "python3-simple-bfs-100-faster-solution",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, t: int) -> int:\\n        if not t: return 0\\n        \\n        threshold = max(forbidden + [t]) + a + b\\n        forbidden = set(forbidden)\\n        seen = set([0])\\n        q = [[0,0]]\\n        \\n        while q:\\n            pos, steps = q.pop(0)\\n            \\n            if pos+a not in forbidden and pos+a not in seen and pos+a <= threshold: \\n                # Termination Condition\\n                if pos+a == t: return steps+1\\n                \\n                q.append([pos+a, steps+1])\\n                seen.add(pos+a)\\n                \\n            if pos-b > 0 and pos-b not in forbidden and pos-b not in seen: \\n                # Termination Condition\\n                if pos-b == t: return steps+1\\n                seen.add(pos-b)\\n                \\n                if pos-b+a not in forbidden and pos-b+a not in seen and pos-b+a <= threshold:\\n                    # Termination Condition\\n                    if pos-b+a == t: return steps+2\\n                    \\n                    q.append([pos-b+a, steps+2])\\n                    seen.add(pos-b+a)\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, t: int) -> int:\\n        if not t: return 0\\n        \\n        threshold = max(forbidden + [t]) + a + b\\n        forbidden = set(forbidden)\\n        seen = set([0])\\n        q = [[0,0]]\\n        \\n        while q:\\n            pos, steps = q.pop(0)\\n            \\n            if pos+a not in forbidden and pos+a not in seen and pos+a <= threshold: \\n                # Termination Condition\\n                if pos+a == t: return steps+1\\n                \\n                q.append([pos+a, steps+1])\\n                seen.add(pos+a)\\n                \\n            if pos-b > 0 and pos-b not in forbidden and pos-b not in seen: \\n                # Termination Condition\\n                if pos-b == t: return steps+1\\n                seen.add(pos-b)\\n                \\n                if pos-b+a not in forbidden and pos-b+a not in seen and pos-b+a <= threshold:\\n                    # Termination Condition\\n                    if pos-b+a == t: return steps+2\\n                    \\n                    q.append([pos-b+a, steps+2])\\n                    seen.add(pos-b+a)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935515,
                "title": "c-bfs",
                "content": "```\\npublic class Solution\\n{\\n    public int MinimumJumps(int[] forbidden, int a, int b, int x)\\n    {\\n        var invalid = new HashSet<int>(forbidden);\\n        var visited = new HashSet<(int,bool)>();\\n        var que = new Queue<(int Pos, bool IsBackward)>();\\n        que.Enqueue((0, false));\\n        int steps = 0;\\n        while (que.Count > 0)\\n        {\\n            int count = que.Count;\\n            while (count-- > 0)\\n            {\\n                var cur = que.Dequeue();\\n                if (cur.Pos == x) return steps;\\n                if(invalid.Contains(cur.Pos) || visited.Contains(cur)) continue;\\n                visited.Add(cur);\\n                if (cur.Pos + a <= 4000)\\n                    que.Enqueue((cur.Pos + a, false));\\n                if (cur.Pos - b >= 0 && !cur.IsBackward)\\n                    que.Enqueue((cur.Pos - b, true));                    \\n            }\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumJumps(int[] forbidden, int a, int b, int x)\\n    {\\n        var invalid = new HashSet<int>(forbidden);\\n        var visited = new HashSet<(int,bool)>();\\n        var que = new Queue<(int Pos, bool IsBackward)>();\\n        que.Enqueue((0, false));\\n        int steps = 0;\\n        while (que.Count > 0)\\n        {\\n            int count = que.Count;\\n            while (count-- > 0)\\n            {\\n                var cur = que.Dequeue();\\n                if (cur.Pos == x) return steps;\\n                if(invalid.Contains(cur.Pos) || visited.Contains(cur)) continue;\\n                visited.Add(cur);\\n                if (cur.Pos + a <= 4000)\\n                    que.Enqueue((cur.Pos + a, false));\\n                if (cur.Pos - b >= 0 && !cur.IsBackward)\\n                    que.Enqueue((cur.Pos - b, true));                    \\n            }\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605355,
                "title": "java-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int n = forbidden.length;\\n        //2D boolean to keep track of forward and backward visits\\n        boolean[][] visited = new boolean[6000][2];\\n        if(x == 0) return 0;\\n        for(int i = 0; i < n; i++){\\n            //for forbidden numbers we can not go to them\\n            //either forward or backward moment\\n            visited[forbidden[i]][0] = true;\\n            visited[forbidden[i]][1] = true; \\n        }\\n        int ans = 0;\\n        //queue to perform bfs\\n        Queue<int[]> q = new LinkedList();\\n        //array as input to keep track of both backward andd forward moment\\n        q.add(new int[]{0, 0});\\n        while(q.size() > 0){\\n            int size = q.size();\\n            while(size-- > 0){\\n                int[] pos = q.poll();\\n                //not processing already visited numbers\\n                if(visited[pos[0]][pos[1]]) continue;\\n                visited[pos[0]][pos[1]] = true;\\n                //if home found we return ans\\n                if(pos[0] == x) return ans;\\n                //6000 is the maximum possible value for forward moment\\n                if(pos[0] + a < 6000){\\n                    //forward moment shown marked by 0\\n                    q.add(new int[]{pos[0] + a, 0});\\n                }\\n                //to restrict double backward moment we mark backward\\n                //moment by adding 1\\n                if(pos[0] - b >= 0 && pos[1] != 1){\\n                    q.add(new int[]{pos[0] - b, 1});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nPlease upvote if find helful",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int n = forbidden.length;\\n        //2D boolean to keep track of forward and backward visits\\n        boolean[][] visited = new boolean[6000][2];\\n        if(x == 0) return 0;\\n        for(int i = 0; i < n; i++){\\n            //for forbidden numbers we can not go to them\\n            //either forward or backward moment\\n            visited[forbidden[i]][0] = true;\\n            visited[forbidden[i]][1] = true; \\n        }\\n        int ans = 0;\\n        //queue to perform bfs\\n        Queue<int[]> q = new LinkedList();\\n        //array as input to keep track of both backward andd forward moment\\n        q.add(new int[]{0, 0});\\n        while(q.size() > 0){\\n            int size = q.size();\\n            while(size-- > 0){\\n                int[] pos = q.poll();\\n                //not processing already visited numbers\\n                if(visited[pos[0]][pos[1]]) continue;\\n                visited[pos[0]][pos[1]] = true;\\n                //if home found we return ans\\n                if(pos[0] == x) return ans;\\n                //6000 is the maximum possible value for forward moment\\n                if(pos[0] + a < 6000){\\n                    //forward moment shown marked by 0\\n                    q.add(new int[]{pos[0] + a, 0});\\n                }\\n                //to restrict double backward moment we mark backward\\n                //moment by adding 1\\n                if(pos[0] - b >= 0 && pos[1] != 1){\\n                    q.add(new int[]{pos[0] - b, 1});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978766,
                "title": "python3-bfs-easy-understanding",
                "content": "```\\ndef minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        visited = set()\\n        q = deque([(0, 0)])\\n        forbidden = set(forbidden)\\n        furthest = max(x, max(forbidden)) + a + b\\n        \\n        res = 0\\n        while q:\\n            n = len(q)\\n            for _ in range(n):\\n                p, is_back = q.popleft()\\n                if p in forbidden or (p, is_back) in visited or p < 0 or p > furthest:\\n                    continue\\n                if p == x:\\n                    return res \\n                visited.add((p, is_back))\\n                q.append((p + a, 0))\\n                if not is_back:\\n                    q.append((p - b, 1))\\n                \\n            res += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        visited = set()\\n        q = deque([(0, 0)])\\n        forbidden = set(forbidden)\\n        furthest = max(x, max(forbidden)) + a + b\\n        \\n        res = 0\\n        while q:\\n            n = len(q)\\n            for _ in range(n):\\n                p, is_back = q.popleft()\\n                if p in forbidden or (p, is_back) in visited or p < 0 or p > furthest:\\n                    continue\\n                if p == x:\\n                    return res \\n                visited.add((p, is_back))\\n                q.append((p + a, 0))\\n                if not is_back:\\n                    q.append((p - b, 1))\\n                \\n            res += 1\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1540090,
                "title": "simple-bfs-clean-concise-well-coded",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \\n        forbidden = set(forbidden)\\n        limit = max(x,max(forbidden))+a+b\\n        seen = set()\\n        q = [(0,0,False)]\\n        while q:\\n            p,s,isb = q.pop(0)\\n            if p>limit or p<0 or p in forbidden or (p,isb) in seen:\\n                continue\\n            \\n            if p==x:\\n                return s\\n            \\n            q.append((p+a,s+1,False))\\n            if not isb:\\n                q.append((p-b,s+1,True))\\n            seen.add((p,isb))\\n        \\n        return -1\\n\\n**Thanks & Upvote if you got any help !!**\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \\n        forbidden = set(forbidden)\\n        limit = max(x,max(forbidden))+a+b\\n        seen = set()\\n        q = [(0,0,False)]\\n        while q:\\n            p,s,isb = q.pop(0)\\n            if p>limit or p<0 or p in forbidden or (p,isb) in seen:\\n                continue\\n            \\n            if p==x:\\n                return s\\n            \\n            q.append((p+a,s+1,False))\\n            if not isb:\\n                q.append((p-b,s+1,True))\\n            seen.add((p,isb))\\n        \\n        return -1\\n\\n**Thanks & Upvote if you got any help !!**\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1010334,
                "title": "bfs-javascript",
                "content": "```\\n\\nconst minimumJumps = (forbidden, a, b, x)  => {\\n    \\n  const visited = new Set(forbidden);\\n  const limit = 2000 + a + b;\\n  const q = [[0,  0, true]];\\n\\n  while(q.length){\\n    const [current, jumps, backJump] = q.shift();\\n    if(current == x )\\n      return jumps;\\n    \\n    if(visited.has(current))\\n      continue;\\n    \\n    visited.add(current);\\n    let nextJump\\n    if(backJump){\\n      nextJump = current - b;\\n      if(nextJump >= 0)\\n        q.push([nextJump, jumps+1, false]) \\n      }\\n      \\n    nextJump = current + a;\\n    if(nextJump <= limit)\\n      q.push([nextJump, jumps+1, true])\\n  }\\n  return -1;\\n  \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst minimumJumps = (forbidden, a, b, x)  => {\\n    \\n  const visited = new Set(forbidden);\\n  const limit = 2000 + a + b;\\n  const q = [[0,  0, true]];\\n\\n  while(q.length){\\n    const [current, jumps, backJump] = q.shift();\\n    if(current == x )\\n      return jumps;\\n    \\n    if(visited.has(current))\\n      continue;\\n    \\n    visited.add(current);\\n    let nextJump\\n    if(backJump){\\n      nextJump = current - b;\\n      if(nextJump >= 0)\\n        q.push([nextJump, jumps+1, false]) \\n      }\\n      \\n    nextJump = current + a;\\n    if(nextJump <= limit)\\n      q.push([nextJump, jumps+1, true])\\n  }\\n  return -1;\\n  \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2911334,
                "title": "c-solution",
                "content": "# Code\\n```\\n#define maxn 10005\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int, int> mp;\\n        for(auto x: forbidden) mp[x] = 1;\\n\\t\\tint vis[maxn][2] = {};\\n\\t\\tvis[0][0] = 1;\\n\\t\\tvis[0][1] = 1;\\n        queue<pair<int, int>> q; \\n\\t\\tq.push({0, 0});\\n\\t\\tint ans = 0;\\n\\t\\twhile(!q.empty()) {\\n            int len = q.size();\\n            while(len--) {\\n                int u = q.front().first;\\n                int fl = q.front().second;\\n                q.pop();\\n                if(u == x) return ans;\\n                int vf = u + a;\\n                int vb = u - b;\\n                if(vf < maxn and !vis[vf][0] and !mp[vf]) {\\n                    vis[vf][0] = 1;\\n                    q.push({vf, 0});\\n                }\\n                if(vb >= 0 and !vis[vb][1] and !mp[vb] and !fl) {\\n                    vis[vb][1] = 1;\\n                    q.push({vb, 1});\\n                }\\n            }\\n            ans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define maxn 10005\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int, int> mp;\\n        for(auto x: forbidden) mp[x] = 1;\\n\\t\\tint vis[maxn][2] = {};\\n\\t\\tvis[0][0] = 1;\\n\\t\\tvis[0][1] = 1;\\n        queue<pair<int, int>> q; \\n\\t\\tq.push({0, 0});\\n\\t\\tint ans = 0;\\n\\t\\twhile(!q.empty()) {\\n            int len = q.size();\\n            while(len--) {\\n                int u = q.front().first;\\n                int fl = q.front().second;\\n                q.pop();\\n                if(u == x) return ans;\\n                int vf = u + a;\\n                int vb = u - b;\\n                if(vf < maxn and !vis[vf][0] and !mp[vf]) {\\n                    vis[vf][0] = 1;\\n                    q.push({vf, 0});\\n                }\\n                if(vb >= 0 and !vis[vb][1] and !mp[vb] and !fl) {\\n                    vis[vb][1] = 1;\\n                    q.push({vb, 1});\\n                }\\n            }\\n            ans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087392,
                "title": "bfs",
                "content": "```cpp\\nmap<int, bool> visited;\\nint m = 0;\\n\\n// mark the forbidden position as visited.\\nfor (int f : forbidden)\\n{\\n\\tvisited[f] = true;\\n\\tm = max(m, f);\\n}\\n\\n// the trick\\nm = a + b + max(m, x);\\n\\n// bfs\\nqueue<pair<int, bool>> que;\\nint s = 0;\\nint c = 0;\\n\\nque.push({0, true});\\nvisited[0] = true;\\n\\nwhile (s = que.size())\\n{\\n\\twhile (s --)\\n\\t{\\n\\t\\tint i = que.front().first;\\n\\t\\tbool forward = que.front().second;\\n\\t\\tque.pop();\\n\\t\\t\\n\\t\\t// ending case\\n\\t\\tif (i == x)\\n\\t\\t\\treturn c;\\n\\t\\t\\n\\t\\t// check jump backward first\\n\\t\\tint ii = i - b;\\n\\n\\t\\tif (forward && ii >= 0 && ! visited[ii])\\n\\t\\t{\\n\\t\\t\\tque.push({ii, false});\\n\\t\\t\\tvisited[ii] = true;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// jump forward\\n\\t\\tint jj = i + a;\\n\\t\\t\\n\\t\\tif (jj <= m && ! visited[jj])\\n\\t\\t{\\n\\t\\t\\tque.push({jj, true});\\n\\t\\t\\tvisited[jj] = true;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t++ c;\\n}\\n\\nreturn -1;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nmap<int, bool> visited;\\nint m = 0;\\n\\n// mark the forbidden position as visited.\\nfor (int f : forbidden)\\n{\\n\\tvisited[f] = true;\\n\\tm = max(m, f);\\n}\\n\\n// the trick\\nm = a + b + max(m, x);\\n\\n// bfs\\nqueue<pair<int, bool>> que;\\nint s = 0;\\nint c = 0;\\n\\nque.push({0, true});\\nvisited[0] = true;\\n\\nwhile (s = que.size())\\n{\\n\\twhile (s --)\\n\\t{\\n\\t\\tint i = que.front().first;\\n\\t\\tbool forward = que.front().second;\\n\\t\\tque.pop();\\n\\t\\t\\n\\t\\t// ending case\\n\\t\\tif (i == x)\\n\\t\\t\\treturn c;\\n\\t\\t\\n\\t\\t// check jump backward first\\n\\t\\tint ii = i - b;\\n\\n\\t\\tif (forward && ii >= 0 && ! visited[ii])\\n\\t\\t{\\n\\t\\t\\tque.push({ii, false});\\n\\t\\t\\tvisited[ii] = true;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// jump forward\\n\\t\\tint jj = i + a;\\n\\t\\t\\n\\t\\tif (jj <= m && ! visited[jj])\\n\\t\\t{\\n\\t\\t\\tque.push({jj, true});\\n\\t\\t\\tvisited[jj] = true;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t++ c;\\n}\\n\\nreturn -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1689407,
                "title": "c-easy-bfs-solution-visited-track-dp-exploring-2-possibilities",
                "content": "```\\nclass Solution {\\nprivate:\\n    int bfs(unordered_set<int>& vis,int a,int b,int x){\\n        queue<pair<int,bool>> q;\\n        q.push({0,true});\\n        int ans = 0;\\n        \\n        while(!q.empty()){\\n            int count = q.size();\\n            for(int i=0; i<count; i++){\\n                int currPoint = q.front().first;\\n                bool currStatus = q.front().second;\\n                q.pop();\\n                \\n                if(currPoint == x) return ans;\\n                if(vis.count(currPoint)) continue;\\n                \\n                vis.insert(currPoint);\\n                \\n                if(currStatus && currPoint - b >= 0){\\n                    q.push({currPoint - b,false});\\n                }\\n                if(currPoint - b <= 2000){\\n                    q.push({currPoint + a,true});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> vis;\\n        for(int &v : forbidden) vis.insert(v);\\n        \\n        return bfs(vis,a,b,x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Memoization",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int bfs(unordered_set<int>& vis,int a,int b,int x){\\n        queue<pair<int,bool>> q;\\n        q.push({0,true});\\n        int ans = 0;\\n        \\n        while(!q.empty()){\\n            int count = q.size();\\n            for(int i=0; i<count; i++){\\n                int currPoint = q.front().first;\\n                bool currStatus = q.front().second;\\n                q.pop();\\n                \\n                if(currPoint == x) return ans;\\n                if(vis.count(currPoint)) continue;\\n                \\n                vis.insert(currPoint);\\n                \\n                if(currStatus && currPoint - b >= 0){\\n                    q.push({currPoint - b,false});\\n                }\\n                if(currPoint - b <= 2000){\\n                    q.push({currPoint + a,true});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> vis;\\n        for(int &v : forbidden) vis.insert(v);\\n        \\n        return bfs(vis,a,b,x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182751,
                "title": "python-3-memoization",
                "content": "The tricky part is to figure out the upper bound to stop the DFS. In the worst case, you could jump beyond home to avoid a forbidden point.\\n\\n```python\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        bound = max(max(forbidden) + a + b, x + b)\\n        memo = {}\\n\\n        def dp(pos, backward):\\n            if pos > bound or pos < 0 or pos in forbidden:\\n                return float(\\'inf\\')\\n            if pos == x:\\n                return 0\\n            if (pos, backward) not in memo:\\n                memo[pos, backward] = 1 + dp(pos + a, False)\\n                if not backward:\\n                    memo[pos, backward] = min(memo[pos, backward],\\n                                              1 + dp(pos - b, True))\\n            return memo[pos, backward]\\n\\n        ans = dp(0, True)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        bound = max(max(forbidden) + a + b, x + b)\\n        memo = {}\\n\\n        def dp(pos, backward):\\n            if pos > bound or pos < 0 or pos in forbidden:\\n                return float(\\'inf\\')\\n            if pos == x:\\n                return 0\\n            if (pos, backward) not in memo:\\n                memo[pos, backward] = 1 + dp(pos + a, False)\\n                if not backward:\\n                    memo[pos, backward] = min(memo[pos, backward],\\n                                              1 + dp(pos - b, True))\\n            return memo[pos, backward]\\n\\n        ans = dp(0, True)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935812,
                "title": "python-faster-than-100-of-python-submissions",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        # Shortest distance to x : min jumps\\n        forbidden = set(forbidden)\\n        queue = deque([(0,False)])\\n        ans = 0\\n        seen = set()\\n        seen.add((0,False))\\n        while queue:\\n            for _ in range(len(queue)):\\n                curr, is_last_backward = queue.popleft()\\n                if curr == x:\\n                    return ans\\n                \\n                # Jump forward\\n                next_pos = curr + a\\n                if next_pos not in forbidden and next_pos < 4000 and (next_pos,False) not in seen:\\n                    queue.append((next_pos, False))\\n                    seen.add((next_pos, False))\\n                # Jump backward\\n                if not is_last_backward:\\n                    next_pos = curr - b\\n                    if next_pos >= 0 and next_pos not in forbidden and (next_pos, True) not in seen :\\n                        queue.append((next_pos,True))\\n                        seen.add((next_pos, True))\\n         \\n                \\n            ans += 1\\n        \\n        return -1\\n            \\n            \\n            \\n            \\n    \\n\"\"\"\\n[14,4,18,1,15]\\n\\n\\na = 3\\nb = 15\\nx = 9\\n\\n0 -- > 3 -- > 6 -- > 9\\n\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        # Shortest distance to x : min jumps\\n        forbidden = set(forbidden)\\n        queue = deque([(0,False)])\\n        ans = 0\\n        seen = set()\\n        seen.add((0,False))\\n        while queue:\\n            for _ in range(len(queue)):\\n                curr, is_last_backward = queue.popleft()\\n                if curr == x:\\n                    return ans\\n                \\n                # Jump forward\\n                next_pos = curr + a\\n                if next_pos not in forbidden and next_pos < 4000 and (next_pos,False) not in seen:\\n                    queue.append((next_pos, False))\\n                    seen.add((next_pos, False))\\n                # Jump backward\\n                if not is_last_backward:\\n                    next_pos = curr - b\\n                    if next_pos >= 0 and next_pos not in forbidden and (next_pos, True) not in seen :\\n                        queue.append((next_pos,True))\\n                        seen.add((next_pos, True))\\n         \\n                \\n            ans += 1\\n        \\n        return -1\\n            \\n            \\n            \\n            \\n    \\n\"\"\"\\n[14,4,18,1,15]\\n\\n\\na = 3\\nb = 15\\nx = 9\\n\\n0 -- > 3 -- > 6 -- > 9\\n\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935436,
                "title": "java-bfs-with-simple-comments",
                "content": "```\\n\\tpublic int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        boolean[][] visited = new boolean[8888][2]; // [position][direction] indicates if already visited\\n        for (int i : forbidden) visited[i][0] = visited[i][1] = true;\\n        int ret = 0;\\n        LinkedList<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0}); // init with position 0 and right direction\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            for (int i = q.size(); i > 0; i--) {\\n                int[] p = q.poll();\\n                if (p[0] == x) return ret;\\n                int idx = p[0] - b;\\n                if (idx >= 0 && !visited[idx][1] && p[1] == 0) {\\n                    q.add(new int[]{idx, 1});\\n                    visited[idx][1] = true; // have to make it visited when you put it into the queue\\n                }\\n                idx = p[0] + a;\\n                if (!visited[idx][0] && idx <= 4000) { // position beyond 4000 will never reach x because of rule 3\\n                    q.add(new int[]{idx, 0});\\n                    visited[idx][0] = true;\\n                }\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        boolean[][] visited = new boolean[8888][2]; // [position][direction] indicates if already visited\\n        for (int i : forbidden) visited[i][0] = visited[i][1] = true;\\n        int ret = 0;\\n        LinkedList<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0}); // init with position 0 and right direction\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            for (int i = q.size(); i > 0; i--) {\\n                int[] p = q.poll();\\n                if (p[0] == x) return ret;\\n                int idx = p[0] - b;\\n                if (idx >= 0 && !visited[idx][1] && p[1] == 0) {\\n                    q.add(new int[]{idx, 1});\\n                    visited[idx][1] = true; // have to make it visited when you put it into the queue\\n                }\\n                idx = p[0] + a;\\n                if (!visited[idx][0] && idx <= 4000) { // position beyond 4000 will never reach x because of rule 3\\n                    q.add(new int[]{idx, 0});\\n                    visited[idx][0] = true;\\n                }\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935381,
                "title": "c-simulate-steps-using-dfs",
                "content": "> why you dont mark visit move2?\\n\\tans: If we move back we still want to allow forward jump from that index. If we mark them visited then we are blocking forward jump from that index.. which is not correct.\\n\\t\\n> why 4000\\nLooking at the constraint.. we can find that we can do back jump of maximum of 2000. If we have some answer (not -1) we must terminate our forward jump before `4000`. In all other cases it answer will be -1\\n\\n```\\nclass Solution {\\npublic:\\n    int MAX = 99999;\\n    unordered_set<int> visited;\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> f (forbidden.begin(), forbidden.end());\\n        visited = {};\\n        int res =  solve(f, 0,a, b, x, 1);\\n        \\n        return res >= MAX ? -1 : res-1;\\n    }\\n    \\n    int solve(unordered_set<int> &forbidden, int index, int a, int b, int x, int isBackJumpAllowed){\\n        if(index == x) {\\n            return 1;\\n        }\\n        int res1  = MAX;\\n        int move1 = index + a;\\n        if(forbidden.find(move1) == forbidden.end() && move1 >= 0 && visited.count(move1)==0 && move1 <= 4000){\\n            visited.insert(move1);\\n            res1  = solve(forbidden, move1, a, b, x, 1);\\n        }\\n        int res2  = MAX;\\n        int move2 = index - b;\\n        if(forbidden.find(move2) == forbidden.end() && move2 >= 0 && isBackJumpAllowed && visited.count(move2)==0){\\n            res2  = solve(forbidden, move2, a, b, x , 0);\\n        }\\n        return 1 + min(res1, res2);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MAX = 99999;\\n    unordered_set<int> visited;\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> f (forbidden.begin(), forbidden.end());\\n        visited = {};\\n        int res =  solve(f, 0,a, b, x, 1);\\n        \\n        return res >= MAX ? -1 : res-1;\\n    }\\n    \\n    int solve(unordered_set<int> &forbidden, int index, int a, int b, int x, int isBackJumpAllowed){\\n        if(index == x) {\\n            return 1;\\n        }\\n        int res1  = MAX;\\n        int move1 = index + a;\\n        if(forbidden.find(move1) == forbidden.end() && move1 >= 0 && visited.count(move1)==0 && move1 <= 4000){\\n            visited.insert(move1);\\n            res1  = solve(forbidden, move1, a, b, x, 1);\\n        }\\n        int res2  = MAX;\\n        int move2 = index - b;\\n        if(forbidden.find(move2) == forbidden.end() && move2 >= 0 && isBackJumpAllowed && visited.count(move2)==0){\\n            res2  = solve(forbidden, move2, a, b, x , 0);\\n        }\\n        return 1 + min(res1, res2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241529,
                "title": "python3-bfs-beats-100-with-explanation",
                "content": "# Intuition\\r\\n- We use BFS to find the minimum number of jumps required to reach the target position from the starting position.\\r\\n\\r\\n- We consider two types of moves: a forward jump of size \\'a\\', and a backward jump of size \\'b\\'.\\r\\n\\r\\n- We avoid forbidden positions, jumping backwards twice in a row and jumping into negative positions. \\r\\n\\r\\n- We keep track of positions that we have already visited to avoid revisiting them. Those can be added into set of forbidden positions.\\r\\n\\r\\n- If we cannot reach the target position from the starting position, we return -1.\\r\\n\\r\\n# Approach\\r\\n- We use BFS to explore all possible positions that we can reach from the starting position within a maximum of two forward jumps.\\r\\n- We start by setting upper and lower limits for the search, based on the target position and the highest forbidden position, and the minimum allowed position (0).\\r\\n- We create a queue to keep track of the positions to explore, their corresponding number of steps, and a boolean flag to indicate if we can or cannot make a backward jump from the current position.\\r\\n- For each position in the queue, we explore all possible forward jumps and backward jumps, as long as they are within the upper and lower limits and not forbidden, and we also use the boolean flag to prevent going backwards twice in a row.\\r\\n- If we reach the target position, we return the corresponding number of steps.\\r\\n- If we exhaust all possible positions to explore without reaching the target position, we return -1 to indicate that the target is unreachable\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: **O(U)**\\r\\n- Where U is the upper limit of the search space. In worse case scenario, the algorithm will have to explore all positions between in range(0, U)\\r\\n\\r\\n- Space complexity: **O(U)**\\r\\n- We need to keep track of all positions between 0 and U, and each position can be added to the queue at most once.\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\r\\n        # Create a set of forbidden positions, set the lower limit to 0, and set the upper limit to the maximum of the goal position, \\r\\n        # the maximum of the forbidden positions, and the sum of the jump lengths.\\r\\n        forbidden, lower, upper = set(forbidden), 0, max(x, max(forbidden)) + a + b\\r\\n        if 0 in forbidden:\\r\\n            return -1\\r\\n        \\r\\n        # Initialize a queue to hold the positions to be explored, set the number of steps to -1, and add the starting position to the queue.\\r\\n        queue, steps = deque(), -1\\r\\n        queue.append((0, True))\\r\\n        forbidden.add(0)\\r\\n        \\r\\n        # Loop through the positions in the queue until the queue is empty.\\r\\n        while queue:\\r\\n            # Increment the number of steps.\\r\\n            steps += 1\\r\\n            \\r\\n            # Loop through the positions in the queue that were added in the previous iteration.\\r\\n            for i in range(len(queue)):\\r\\n                # Remove the first position from the queue.\\r\\n                pos, canBackwards = queue.popleft()\\r\\n                \\r\\n                # Check if the current position is the goal position, if so, return the number of steps.\\r\\n                if pos == x:\\r\\n                    return steps\\r\\n                \\r\\n                # Check if it is possible to jump backwards from the current position and if the new position is not forbidden.\\r\\n                if (canBackwards and pos - b > 0 and pos-b not in forbidden):\\r\\n                    # Add the new position to the queue with canBackwards set to False, and add it to the forbidden set.\\r\\n                    queue.append((pos-b, False))\\r\\n                    forbidden.add(pos-b)\\r\\n                \\r\\n                # Check if it is possible to jump forwards from the current position and if the new position is not forbidden.\\r\\n                if (pos+a <= upper and pos+a not in forbidden):\\r\\n                    # Add the new position to the queue with canBackwards set to True, and add it to the forbidden set.\\r\\n                    queue.append((pos+a, True))\\r\\n                    forbidden.add(pos+a)\\r\\n        \\r\\n        # If the goal position is not reached, return -1.\\r\\n        return -1\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\r\\n        # Create a set of forbidden positions, set the lower limit to 0, and set the upper limit to the maximum of the goal position, \\r\\n        # the maximum of the forbidden positions, and the sum of the jump lengths.\\r\\n        forbidden, lower, upper = set(forbidden), 0, max(x, max(forbidden)) + a + b\\r\\n        if 0 in forbidden:\\r\\n            return -1\\r\\n        \\r\\n        # Initialize a queue to hold the positions to be explored, set the number of steps to -1, and add the starting position to the queue.\\r\\n        queue, steps = deque(), -1\\r\\n        queue.append((0, True))\\r\\n        forbidden.add(0)\\r\\n        \\r\\n        # Loop through the positions in the queue until the queue is empty.\\r\\n        while queue:\\r\\n            # Increment the number of steps.\\r\\n            steps += 1\\r\\n            \\r\\n            # Loop through the positions in the queue that were added in the previous iteration.\\r\\n            for i in range(len(queue)):\\r\\n                # Remove the first position from the queue.\\r\\n                pos, canBackwards = queue.popleft()\\r\\n                \\r\\n                # Check if the current position is the goal position, if so, return the number of steps.\\r\\n                if pos == x:\\r\\n                    return steps\\r\\n                \\r\\n                # Check if it is possible to jump backwards from the current position and if the new position is not forbidden.\\r\\n                if (canBackwards and pos - b > 0 and pos-b not in forbidden):\\r\\n                    # Add the new position to the queue with canBackwards set to False, and add it to the forbidden set.\\r\\n                    queue.append((pos-b, False))\\r\\n                    forbidden.add(pos-b)\\r\\n                \\r\\n                # Check if it is possible to jump forwards from the current position and if the new position is not forbidden.\\r\\n                if (pos+a <= upper and pos+a not in forbidden):\\r\\n                    # Add the new position to the queue with canBackwards set to True, and add it to the forbidden set.\\r\\n                    queue.append((pos+a, True))\\r\\n                    forbidden.add(pos+a)\\r\\n        \\r\\n        # If the goal position is not reached, return -1.\\r\\n        return -1\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085343,
                "title": "java-solution-6-ms-beats-99",
                "content": "# Code\\n```\\nclass Solution {\\n    class Pair {\\n        int pos;\\n        boolean dir;\\n        public Pair(int pos, boolean dir) {\\n            this.pos = pos;\\n            this.dir = dir;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] visited = new boolean[limit];\\n        for (int num: forbidden) {\\n            visited[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        visited[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                boolean dir = p.dir;\\n              \\n                if (pos == x) return step;\\n                \\n                if (dir==false) {\\n                    int backward = pos - b;\\n                  \\n                    if (backward > 0 && !visited[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        visited[backward] = true;\\n                    }\\n                }\\n                \\n                int forward = pos + a;\\n           \\n                if (forward < limit && !visited[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    visited[forward] = true;\\n                }\\n              \\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int pos;\\n        boolean dir;\\n        public Pair(int pos, boolean dir) {\\n            this.pos = pos;\\n            this.dir = dir;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] visited = new boolean[limit];\\n        for (int num: forbidden) {\\n            visited[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        visited[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                boolean dir = p.dir;\\n              \\n                if (pos == x) return step;\\n                \\n                if (dir==false) {\\n                    int backward = pos - b;\\n                  \\n                    if (backward > 0 && !visited[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        visited[backward] = true;\\n                    }\\n                }\\n                \\n                int forward = pos + a;\\n           \\n                if (forward < limit && !visited[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    visited[forward] = true;\\n                }\\n              \\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788411,
                "title": "c-2-approaches-dynamic-programming-recursive-memoization-simple-bfs",
                "content": "# Code\\n**IF YOU LIKE PLEASE UPVOTE, HAPPY CODING :)**\\n\\nDP Approach-------\\n\\n```\\nint fun(int pos,int a,int b,int x,unordered_map<int,int>&mp,int move,vector<vector<int>>&dp)\\n{\\n    if(pos==x)\\n    {\\n        return 0;\\n    }\\n    if(pos<0 || pos>6001 || mp.find(pos)!=mp.end()) return 1e9;\\n    if(dp[pos][move]!=-1) return dp[pos][move];\\n    int forward=0;\\n    dp[pos][move]=1+fun(pos+a,a,b,x,mp,0,dp);\\n    if(move==0)\\n    {\\n        dp[pos][move]=min(dp[pos][move],1+fun(pos-b,a,b,x,mp,1,dp));\\n    }\\n    return dp[pos][move];\\n}\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<forbidden.size();i++)\\n        {\\n            mp[forbidden[i]]=1;\\n        }\\n        vector<vector<int>>dp(7001,vector<int>(2,-1));\\n        int d=fun(0,a,b,x,mp,0,dp);\\n        if(d>=1e7) return -1;\\n        return d;\\n    }\\n```\\nUsing Simple BFS\\n\\n```\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x)\\n        {\\n            queue<pair<pair<int,int>,int>>q;\\n            unordered_map<int,int>mp;\\n            for(int i=0;i<forbidden.size();i++)\\n            {\\n                mp[forbidden[i]]=1;\\n            }\\n            q.push({{0,0},0});\\n            vector<vector<int>>vis(6001,vector<int>(2,0));\\n            vis[0][0]=1;\\n            while(!q.empty())\\n            {\\n                int pos=q.front().first.first;\\n                int move=q.front().first.second;\\n                int steps=q.front().second;\\n                q.pop();\\n                if(pos==x)\\n                {\\n                    return steps;\\n                }\\n                if(pos+a<6001 && mp.find(pos+a)==mp.end() && vis[pos+a][0]==0)\\n                {\\n                    q.push({{pos+a,0},steps+1});\\n                    vis[pos+a][0]=1;\\n                }\\n                if(pos-b>=0 && move==0 && mp.find(pos-b)==mp.end() && vis[pos-b][1]==0)\\n                {\\n                    q.push({{pos-b,1},steps+1});\\n                    vis[pos-b][1]=1;\\n                }\\n            }\\n            return -1;\\n        }\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nint fun(int pos,int a,int b,int x,unordered_map<int,int>&mp,int move,vector<vector<int>>&dp)\\n{\\n    if(pos==x)\\n    {\\n        return 0;\\n    }\\n    if(pos<0 || pos>6001 || mp.find(pos)!=mp.end()) return 1e9;\\n    if(dp[pos][move]!=-1) return dp[pos][move];\\n    int forward=0;\\n    dp[pos][move]=1+fun(pos+a,a,b,x,mp,0,dp);\\n    if(move==0)\\n    {\\n        dp[pos][move]=min(dp[pos][move],1+fun(pos-b,a,b,x,mp,1,dp));\\n    }\\n    return dp[pos][move];\\n}\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<forbidden.size();i++)\\n        {\\n            mp[forbidden[i]]=1;\\n        }\\n        vector<vector<int>>dp(7001,vector<int>(2,-1));\\n        int d=fun(0,a,b,x,mp,0,dp);\\n        if(d>=1e7) return -1;\\n        return d;\\n    }\\n```\n```\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x)\\n        {\\n            queue<pair<pair<int,int>,int>>q;\\n            unordered_map<int,int>mp;\\n            for(int i=0;i<forbidden.size();i++)\\n            {\\n                mp[forbidden[i]]=1;\\n            }\\n            q.push({{0,0},0});\\n            vector<vector<int>>vis(6001,vector<int>(2,0));\\n            vis[0][0]=1;\\n            while(!q.empty())\\n            {\\n                int pos=q.front().first.first;\\n                int move=q.front().first.second;\\n                int steps=q.front().second;\\n                q.pop();\\n                if(pos==x)\\n                {\\n                    return steps;\\n                }\\n                if(pos+a<6001 && mp.find(pos+a)==mp.end() && vis[pos+a][0]==0)\\n                {\\n                    q.push({{pos+a,0},steps+1});\\n                    vis[pos+a][0]=1;\\n                }\\n                if(pos-b>=0 && move==0 && mp.find(pos-b)==mp.end() && vis[pos-b][1]==0)\\n                {\\n                    q.push({{pos-b,1},steps+1});\\n                    vis[pos-b][1]=1;\\n                }\\n            }\\n            return -1;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2668948,
                "title": "c-clean-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        std::queue<std::pair<int, bool>> Q; Q.push({0, true});\\n        std::set<int> visited; \\n        for(int place : forbidden) visited.insert(place);\\n        \\n        int count = -1;\\n        while(!Q.empty()){\\n            count++;\\n            int length = Q.size();\\n            for(int i = 0; i < length; i++){\\n                auto [curr, forward] = Q.front(); Q.pop();\\n            \\n                if(visited.count(curr) > 0) continue;\\n\\n                if(curr == x) return count;\\n\\n                if(forward && curr - b >= 0) Q.push({curr - b, false});\\n                if(curr - b <= 2000) Q.push({curr + a, true});\\n\\n\\n                visited.insert(curr);\\n            }\\n        }\\n         return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        std::queue<std::pair<int, bool>> Q; Q.push({0, true});\\n        std::set<int> visited; \\n        for(int place : forbidden) visited.insert(place);\\n        \\n        int count = -1;\\n        while(!Q.empty()){\\n            count++;\\n            int length = Q.size();\\n            for(int i = 0; i < length; i++){\\n                auto [curr, forward] = Q.front(); Q.pop();\\n            \\n                if(visited.count(curr) > 0) continue;\\n\\n                if(curr == x) return count;\\n\\n                if(forward && curr - b >= 0) Q.push({curr - b, false});\\n                if(curr - b <= 2000) Q.push({curr + a, true});\\n\\n\\n                visited.insert(curr);\\n            }\\n        }\\n         return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263310,
                "title": "java-easy-bfs",
                "content": "Wonder why visited has FORWARD, BACKWARD presence?\\nto reach a num, say 10, we do not know if we reach 10 by adding a or subtracting b.\\n```\\nx + a = 10 (different combination)\\nx - b = 10 (different combination)\\n```\\n\\n**If you like the solution, please upvote! Happy Learning!**\\n```\\nclass Solution {\\n    private static final int FORWARD = 1;\\n    private static final int BACKWARD = 2;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<int[]> q = new LinkedList();\\n        q.add(new int[] {0, FORWARD});\\n        Set<String> visited = new HashSet();\\n        Set<Integer> forbiddenSet = new HashSet();\\n        int farthest = 2000 + 2 * b;\\n        for (int f: forbidden) {\\n            farthest = Math.max(farthest, f + 2 * b);\\n            forbiddenSet.add(f);\\n        }\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] current = q.poll();\\n                if (current[0] == x) {\\n                    return step;\\n                }\\n                \\n                int forward = current[0] + a;\\n                int backward = current[0] - b;\\n                \\n                if (forward <= farthest && !visited.contains(forward + \"|\" + FORWARD) && !forbiddenSet.contains(forward)) {\\n                    visited.add(forward + \"|\" + FORWARD);\\n                    q.add(new int[] {forward, FORWARD});\\n                }\\n                \\n                if (current[1] != BACKWARD && backward >= 0 && !visited.contains(backward + \"|\" + BACKWARD) && !forbiddenSet.contains(backward)) {\\n                    visited.add(backward + \"|\" + BACKWARD);\\n                    q.add(new int[] {backward, BACKWARD});\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nx + a = 10 (different combination)\\nx - b = 10 (different combination)\\n```\n```\\nclass Solution {\\n    private static final int FORWARD = 1;\\n    private static final int BACKWARD = 2;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<int[]> q = new LinkedList();\\n        q.add(new int[] {0, FORWARD});\\n        Set<String> visited = new HashSet();\\n        Set<Integer> forbiddenSet = new HashSet();\\n        int farthest = 2000 + 2 * b;\\n        for (int f: forbidden) {\\n            farthest = Math.max(farthest, f + 2 * b);\\n            forbiddenSet.add(f);\\n        }\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] current = q.poll();\\n                if (current[0] == x) {\\n                    return step;\\n                }\\n                \\n                int forward = current[0] + a;\\n                int backward = current[0] - b;\\n                \\n                if (forward <= farthest && !visited.contains(forward + \"|\" + FORWARD) && !forbiddenSet.contains(forward)) {\\n                    visited.add(forward + \"|\" + FORWARD);\\n                    q.add(new int[] {forward, FORWARD});\\n                }\\n                \\n                if (current[1] != BACKWARD && backward >= 0 && !visited.contains(backward + \"|\" + BACKWARD) && !forbiddenSet.contains(backward)) {\\n                    visited.add(backward + \"|\" + BACKWARD);\\n                    q.add(new int[] {backward, BACKWARD});\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250752,
                "title": "c-bfs",
                "content": "**Note:**\\nvis[x][0] denotes that we have visited the position x following forward direction (some other point--->x)\\nvis[x][1] denotes that we have visited the position x following backward direction (X<--some other point)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<pair<int,int>>q;\\n        q.push({0,0}); // pos, dir(0->forward 1->backward); // adding starting postion with direction as forward (0)\\n        int end=10000; // from constraints\\n        vector<vector<bool>>vis(end+1,vector<bool>(2,false));\\n        \\n        for(auto zone:forbidden){ // visit the all forbidden zone\\n            if(zone<=end)vis[zone][0]=true;\\n            if(zone<=end)vis[zone][1]=true;\\n        }\\n        if(vis[x][0])return -1; // if home is at forbidden zone\\n        vis[0][0]=true; // we assume we have visited at source by travelling forward as well as backwards.\\n        vis[0][1]=true;\\n        int jumps=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto rem=q.front(); q.pop();\\n                int pos=rem.first;\\n                int dir=rem.second;\\n                if(pos==x)return jumps;\\n                if(dir==0){ // if this position is travelled with forward direction then we can move forward as well as backward directiona.\\n                    if(((pos+a)<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                    if(((pos-b)>=0)&&(!vis[pos-b][1])){vis[pos-b][1]=true;q.push({pos-b,1});}\\n                        \\n                }else{ // if this position is travelled with backward direction then we can move only in forward direction\\n                    if((pos+a<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                }\\n            }\\n           jumps++; \\n            \\n        }\\n        return -1;\\n    }\\n};\\n\\n```\\nplz upvote if u like it",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<pair<int,int>>q;\\n        q.push({0,0}); // pos, dir(0->forward 1->backward); // adding starting postion with direction as forward (0)\\n        int end=10000; // from constraints\\n        vector<vector<bool>>vis(end+1,vector<bool>(2,false));\\n        \\n        for(auto zone:forbidden){ // visit the all forbidden zone\\n            if(zone<=end)vis[zone][0]=true;\\n            if(zone<=end)vis[zone][1]=true;\\n        }\\n        if(vis[x][0])return -1; // if home is at forbidden zone\\n        vis[0][0]=true; // we assume we have visited at source by travelling forward as well as backwards.\\n        vis[0][1]=true;\\n        int jumps=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto rem=q.front(); q.pop();\\n                int pos=rem.first;\\n                int dir=rem.second;\\n                if(pos==x)return jumps;\\n                if(dir==0){ // if this position is travelled with forward direction then we can move forward as well as backward directiona.\\n                    if(((pos+a)<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                    if(((pos-b)>=0)&&(!vis[pos-b][1])){vis[pos-b][1]=true;q.push({pos-b,1});}\\n                        \\n                }else{ // if this position is travelled with backward direction then we can move only in forward direction\\n                    if((pos+a<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                }\\n            }\\n           jumps++; \\n            \\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980115,
                "title": "java-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        \\n        // Visited Set\\n        Set<Integer> visited = new HashSet<Integer>();\\n        \\n        // Add forbidden coordinates to visited\\n        for (int i = 0; i < forbidden.length; i++) {\\n            visited.add(forbidden[i]);\\n        }\\n        \\n        // Distance/ Jumps map\\n        Map<Integer, Integer> jumps = new HashMap<>();\\n        jumps.put(0, 0);\\n        \\n        // BFS Queue\\n        Queue<Integer[]> q = new LinkedList<>();\\n        q.add(new Integer[] {0, 1});\\n        \\n        // BFS \\n        while (q.size() != 0) {\\n            \\n            Integer[] ud = q.poll();\\n            \\n            int u = ud[0], d = ud[1];\\n            \\n            // x found\\n            if (u == x) {\\n                return jumps.get(u);\\n            }\\n            \\n            // jump right\\n            if (u + a < 6001 && !visited.contains(u+a)) {\\n                q.add(new Integer[] {u+a, 1});\\n                visited.add(u+a);\\n                jumps.put(u+a, jumps.get(u) + 1);\\n            }\\n            \\n            // jump left\\n            if (d != -1 && u - b > -1 && !visited.contains(u-b)) {\\n                q.add(new Integer[] {u-b, -1});\\n                jumps.put(u-b, jumps.get(u) + 1);\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        \\n        // Visited Set\\n        Set<Integer> visited = new HashSet<Integer>();\\n        \\n        // Add forbidden coordinates to visited\\n        for (int i = 0; i < forbidden.length; i++) {\\n            visited.add(forbidden[i]);\\n        }\\n        \\n        // Distance/ Jumps map\\n        Map<Integer, Integer> jumps = new HashMap<>();\\n        jumps.put(0, 0);\\n        \\n        // BFS Queue\\n        Queue<Integer[]> q = new LinkedList<>();\\n        q.add(new Integer[] {0, 1});\\n        \\n        // BFS \\n        while (q.size() != 0) {\\n            \\n            Integer[] ud = q.poll();\\n            \\n            int u = ud[0], d = ud[1];\\n            \\n            // x found\\n            if (u == x) {\\n                return jumps.get(u);\\n            }\\n            \\n            // jump right\\n            if (u + a < 6001 && !visited.contains(u+a)) {\\n                q.add(new Integer[] {u+a, 1});\\n                visited.add(u+a);\\n                jumps.put(u+a, jumps.get(u) + 1);\\n            }\\n            \\n            // jump left\\n            if (d != -1 && u - b > -1 && !visited.contains(u-b)) {\\n                q.add(new Integer[] {u-b, -1});\\n                jumps.put(u-b, jumps.get(u) + 1);\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920366,
                "title": "java-bfs-faster-than-99-85",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        int i;\\n        boolean backward;\\n        public Pair(int i, boolean b) {\\n            this.i = i;\\n            this.backward = b;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] v = new boolean[limit];\\n        for (int num: forbidden) {\\n            v[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        v[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair c = q.poll();\\n                if (c.i == x) return step;\\n                if (!c.backward) {\\n                    int backward = c.i - b;\\n                    if (backward == x) return step + 1;\\n                    if (backward > 0 && !v[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        v[backward] = true;\\n                    }\\n                }\\n                int forward = c.i + a;\\n                if (forward == x) return step + 1;\\n                if (forward < limit && !v[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    v[forward] = true;\\n                }               \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int i;\\n        boolean backward;\\n        public Pair(int i, boolean b) {\\n            this.i = i;\\n            this.backward = b;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] v = new boolean[limit];\\n        for (int num: forbidden) {\\n            v[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        v[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair c = q.poll();\\n                if (c.i == x) return step;\\n                if (!c.backward) {\\n                    int backward = c.i - b;\\n                    if (backward == x) return step + 1;\\n                    if (backward > 0 && !v[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        v[backward] = true;\\n                    }\\n                }\\n                int forward = c.i + a;\\n                if (forward == x) return step + 1;\\n                if (forward < limit && !v[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    v[forward] = true;\\n                }               \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868193,
                "title": "javascript-clean-bfs-99",
                "content": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n  forbidden = new Set(forbidden);\\n  const upper = a + b + Math.max(x, Math.max(...forbidden))\\n  \\n  const queue = new Queue([[0, true, 0]]);\\n  while (!queue.isEmpty()) {\\n    const [cur, backward, jumps] = queue.dequeue();\\n    \\n    if (forbidden.has(cur)) continue;\\n    forbidden.add(cur);\\n    \\n    if (cur === x) return jumps\\n    \\n    const newPosB = cur - b\\n    if (!forbidden.has(newPosB) && newPosB > 0 && backward) queue.enqueue([newPosB, false, jumps + 1])\\n    \\n    const newPosA = cur + a\\n    if (!forbidden.has(newPosA) && newPosA <= upper) queue.enqueue([newPosA, true, jumps + 1])\\n  }\\n  \\n  return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n  forbidden = new Set(forbidden);\\n  const upper = a + b + Math.max(x, Math.max(...forbidden))\\n  \\n  const queue = new Queue([[0, true, 0]]);\\n  while (!queue.isEmpty()) {\\n    const [cur, backward, jumps] = queue.dequeue();\\n    \\n    if (forbidden.has(cur)) continue;\\n    forbidden.add(cur);\\n    \\n    if (cur === x) return jumps\\n    \\n    const newPosB = cur - b\\n    if (!forbidden.has(newPosB) && newPosB > 0 && backward) queue.enqueue([newPosB, false, jumps + 1])\\n    \\n    const newPosA = cur + a\\n    if (!forbidden.has(newPosA) && newPosA <= upper) queue.enqueue([newPosA, true, jumps + 1])\\n  }\\n  \\n  return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605214,
                "title": "c-bfs",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forb, int a, int b, int x) {\\n        unordered_set<int> forbidden(begin(forb), end(forb));\\n        \\n        using State = pair<int, bool>;\\n        \\n        queue<State> q;\\n        q.push({0, false});\\n        \\n        set<State> seen{{0, false}};\\n        \\n        int jumps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            \\n            for (int i = 0; i < size; ++i) {\\n                auto [pos, isBackward] = q.front();\\n                q.pop();\\n\\n                if (pos == x) {\\n                    return jumps;\\n                }\\n                \\n                // Go forward\\n                if (!seen.count({pos + a, false}) && pos < 4000 && !forbidden.count(pos + a)) {\\n                    seen.insert({pos + a, false});\\n                    q.push({pos + a, false});\\n                }\\n                \\n                // Go backward\\n                if (!isBackward && pos - b > 0 && !seen.count({pos - b, true}) && !forbidden.count(pos - b)) {\\n                    seen.insert({pos - b, true});\\n                    q.push({pos - b, true});\\n                }\\n            }\\n            ++jumps;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forb, int a, int b, int x) {\\n        unordered_set<int> forbidden(begin(forb), end(forb));\\n        \\n        using State = pair<int, bool>;\\n        \\n        queue<State> q;\\n        q.push({0, false});\\n        \\n        set<State> seen{{0, false}};\\n        \\n        int jumps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            \\n            for (int i = 0; i < size; ++i) {\\n                auto [pos, isBackward] = q.front();\\n                q.pop();\\n\\n                if (pos == x) {\\n                    return jumps;\\n                }\\n                \\n                // Go forward\\n                if (!seen.count({pos + a, false}) && pos < 4000 && !forbidden.count(pos + a)) {\\n                    seen.insert({pos + a, false});\\n                    q.push({pos + a, false});\\n                }\\n                \\n                // Go backward\\n                if (!isBackward && pos - b > 0 && !seen.count({pos - b, true}) && !forbidden.count(pos - b)) {\\n                    seen.insert({pos - b, true});\\n                    q.push({pos - b, true});\\n                }\\n            }\\n            ++jumps;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525906,
                "title": "java-easy-to-understand-dfs-code-with-explanation-15-ms-faster-than-94-04",
                "content": "**Key points to understand the solution.**\\n1. I have taken all variables which will be commonly used by all recursion calls commonly.\\n2. I have thought of two exit calls that are possible.\\n    a. First is when my currentNode is equal to my valueToReach value;\\n\\tb. If my currNode reaches >6000 ( max of a + max of b + max of c, got the each value from constraint as 2000),         I will simply return.\\n3. Now for understanding that when to mark a node as visited, consider the following diagram.\\n![image](https://assets.leetcode.com/users/images/056e01e4-b28b-4254-91d5-150509aff64c_1634463686.869404.jpeg)\\n4. There are two possibilities to reach from currNode - a ->currNode OR currNode + b -> currNode.\\n5. If we consider reaching to currNode from possibility 1, then there are two children possible currNode + a and currNode -b.\\n6. If we consider reaching to currNode from possibility 2, then there is one child possible i.e currNode -b.\\n7. If we mark currNode as visited because of possibility 2, then we will miss the one child of which will be currNode + a.\\n8. So we will always mark currNode as visited if we are taking a forward step from currNode - a or when previousSetp.equals(\"forward\").\\n\\n\\n\\n\\n```\\nclass Solution {\\n    int minJumps = Integer.MAX_VALUE;\\n    int max_val;\\n    int p;\\n    int q;\\n    int valueToReach;\\n    HashSet<Integer> visited;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        visited = new HashSet();\\n        for(int i =0;i<forbidden.length;i++){\\n            visited.add(forbidden[i]);\\n        }\\n        max_val = 6000;\\n        p = a;\\n        q = b;\\n        valueToReach = x;\\n        visited.add(0);\\n        dfs(0, 0, \"forward\");\\n        if(minJumps == Integer.MAX_VALUE)\\n            return -1;\\n        return minJumps;\\n    }\\n    \\n    public void dfs(int currNode, int jumps, String previousStep){\\n        if(currNode == valueToReach){\\n            minJumps = minJumps < jumps ? minJumps : jumps;\\n            return;\\n        }\\n        if(previousStep.equals(\"forward\"))\\n            visited.add(currNode);\\n        if(((currNode + p) < max_val) && !visited.contains(currNode + p)){\\n            \\n                dfs(currNode + p, jumps +1, \"forward\");\\n        }\\n        if(((currNode - q) < max_val)&& previousStep.equals(\"forward\")&& (currNode - q) >=0 && !visited.contains(currNode - q)){\\n                \\n                dfs(currNode - q, jumps + 1, \"back\");\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int minJumps = Integer.MAX_VALUE;\\n    int max_val;\\n    int p;\\n    int q;\\n    int valueToReach;\\n    HashSet<Integer> visited;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        visited = new HashSet();\\n        for(int i =0;i<forbidden.length;i++){\\n            visited.add(forbidden[i]);\\n        }\\n        max_val = 6000;\\n        p = a;\\n        q = b;\\n        valueToReach = x;\\n        visited.add(0);\\n        dfs(0, 0, \"forward\");\\n        if(minJumps == Integer.MAX_VALUE)\\n            return -1;\\n        return minJumps;\\n    }\\n    \\n    public void dfs(int currNode, int jumps, String previousStep){\\n        if(currNode == valueToReach){\\n            minJumps = minJumps < jumps ? minJumps : jumps;\\n            return;\\n        }\\n        if(previousStep.equals(\"forward\"))\\n            visited.add(currNode);\\n        if(((currNode + p) < max_val) && !visited.contains(currNode + p)){\\n            \\n                dfs(currNode + p, jumps +1, \"forward\");\\n        }\\n        if(((currNode - q) < max_val)&& previousStep.equals(\"forward\")&& (currNode - q) >=0 && !visited.contains(currNode - q)){\\n                \\n                dfs(currNode - q, jumps + 1, \"back\");\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450316,
                "title": "can-t-understand-how-changing-places-of-the-conditions-work",
                "content": "So I have this code for the problem\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int,bool> m;\\n        queue<pair<int,int>> queue;\\n        int ans = 0;\\n        for(int& n: forbidden) m[n]=true;\\n        queue.push(make_pair(0,0));\\n        while(!queue.empty()) {\\n            int size = queue.size();\\n            while(size--) {\\n                auto p = queue.front(); queue.pop();\\n                if(p.first == x) return ans;\\n                if(m[p.first]) continue;\\n                m[p.first]=true;\\n                \\n             \\n\\t\\t\\t\\t  // I\\'m calling this FORWARD CONDITION\\n                 if(p.first <= (2000+b)) {\\n                    queue.push(make_pair(p.first+a, 0));\\n                }\\n               \\n\\t\\t\\t      \\n                if(p.second == 0  && (p.first-b) >=0) {\\n                    queue.push(make_pair(p.first-b, 1));             \\n                }\\n\\t\\t\\t   \\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\\n\\nThis code is giving me wrong answer for some test cases. But after moving the FORWARD CONDITION below the other if condition, the code seems to work.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int,bool> m;\\n        queue<pair<int,int>> queue;\\n        int ans = 0;\\n        for(int& n: forbidden) m[n]=true;\\n        queue.push(make_pair(0,0));\\n        while(!queue.empty()) {\\n            int size = queue.size();\\n            while(size--) {\\n                auto p = queue.front(); queue.pop();\\n                if(p.first == x) return ans;\\n                if(m[p.first]) continue;\\n                m[p.first]=true;\\n                \\n                              \\n                if(p.second == 0  && (p.first-b) >=0) {\\n                    queue.push(make_pair(p.first-b, 1));             \\n                }\\n\\t\\t\\t\\t//FORWARD CONDITION moved below  \\n                 if(p.first <= (2000+b)) {\\n                    queue.push(make_pair(p.first+a, 0));\\n                }\\n               \\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code is working fine and I don\\'t undestand why. Can someone help?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int,bool> m;\\n        queue<pair<int,int>> queue;\\n        int ans = 0;\\n        for(int& n: forbidden) m[n]=true;\\n        queue.push(make_pair(0,0));\\n        while(!queue.empty()) {\\n            int size = queue.size();\\n            while(size--) {\\n                auto p = queue.front(); queue.pop();\\n                if(p.first == x) return ans;\\n                if(m[p.first]) continue;\\n                m[p.first]=true;\\n                \\n             \\n\\t\\t\\t\\t  // I\\'m calling this FORWARD CONDITION\\n                 if(p.first <= (2000+b)) {\\n                    queue.push(make_pair(p.first+a, 0));\\n                }\\n               \\n\\t\\t\\t      \\n                if(p.second == 0  && (p.first-b) >=0) {\\n                    queue.push(make_pair(p.first-b, 1));             \\n                }\\n\\t\\t\\t   \\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int,bool> m;\\n        queue<pair<int,int>> queue;\\n        int ans = 0;\\n        for(int& n: forbidden) m[n]=true;\\n        queue.push(make_pair(0,0));\\n        while(!queue.empty()) {\\n            int size = queue.size();\\n            while(size--) {\\n                auto p = queue.front(); queue.pop();\\n                if(p.first == x) return ans;\\n                if(m[p.first]) continue;\\n                m[p.first]=true;\\n                \\n                              \\n                if(p.second == 0  && (p.first-b) >=0) {\\n                    queue.push(make_pair(p.first-b, 1));             \\n                }\\n\\t\\t\\t\\t//FORWARD CONDITION moved below  \\n                 if(p.first <= (2000+b)) {\\n                    queue.push(make_pair(p.first+a, 0));\\n                }\\n               \\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027325,
                "title": "c-memoization",
                "content": "\\n```\\n    int memo(bool back, int start, int f, int b, int home, vector<vector<int>>& dp){\\n        if(start == home) return dp[start][back] = 0; \\n        if(start>6001|| start <0 || dp[start][back]== -2 ) return 1e5;\\n        if(dp[start][back] != -1) return dp[start][back]; \\n        dp[start][back] = 1+ memo(false,start+f, f,b,home, dp); \\n        if(!back) dp[start][back] = min(dp[start][back],1+memo(true,start-b, f,b,home, dp)); \\n        \\n        return dp[start][back] ; \\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6005, vector<int>(2, -1)); \\n        for(auto x:forbidden) dp[x][0] = -2, dp[x][1] = -2; \\n        int res = memo(false,0 , a,b,x , dp); \\n        return  res > 1e5 ? -1:res; \\n    }\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\n    int memo(bool back, int start, int f, int b, int home, vector<vector<int>>& dp){\\n        if(start == home) return dp[start][back] = 0; \\n        if(start>6001|| start <0 || dp[start][back]== -2 ) return 1e5;\\n        if(dp[start][back] != -1) return dp[start][back]; \\n        dp[start][back] = 1+ memo(false,start+f, f,b,home, dp); \\n        if(!back) dp[start][back] = min(dp[start][back],1+memo(true,start-b, f,b,home, dp)); \\n        \\n        return dp[start][back] ; \\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6005, vector<int>(2, -1)); \\n        for(auto x:forbidden) dp[x][0] = -2, dp[x][1] = -2; \\n        int res = memo(false,0 , a,b,x , dp); \\n        return  res > 1e5 ? -1:res; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935583,
                "title": "java-min-jumps-bug-100-fast",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        LinkedList<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n      \\n        boolean[][] visited = new boolean[4000][2];\\n        for(int i:forbidden){\\n          visited[i][0] = true;\\n          visited[i][1] = true;\\n        }\\n      \\n        while(!queue.isEmpty()){\\n          int curr[] = queue.remove();\\n          int pos = curr[0];\\n          int dir = curr[1];\\n          int level = curr[2];\\n          if(pos==x)\\n            return level;\\n          if(visited[pos][dir])\\n            continue;\\n          visited[pos][dir] = true;\\n          \\n          if(pos+a<4000)\\n            queue.add(new int[]{pos+a,0,level+1});\\n          \\n          if(pos-b>-1 && dir==0)\\n            queue.add(new int[]{pos-b,1,level+1});\\n        }\\n\\n        return -1;      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        LinkedList<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n      \\n        boolean[][] visited = new boolean[4000][2];\\n        for(int i:forbidden){\\n          visited[i][0] = true;\\n          visited[i][1] = true;\\n        }\\n      \\n        while(!queue.isEmpty()){\\n          int curr[] = queue.remove();\\n          int pos = curr[0];\\n          int dir = curr[1];\\n          int level = curr[2];\\n          if(pos==x)\\n            return level;\\n          if(visited[pos][dir])\\n            continue;\\n          visited[pos][dir] = true;\\n          \\n          if(pos+a<4000)\\n            queue.add(new int[]{pos+a,0,level+1});\\n          \\n          if(pos-b>-1 && dir==0)\\n            queue.add(new int[]{pos-b,1,level+1});\\n        }\\n\\n        return -1;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456541,
                "title": "simple-bfs-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int pos;\\n    boolean isBackward;\\n    Pair(int pos,boolean isBackward){\\n        this.pos=pos;\\n        this.isBackward=isBackward;\\n    }\\n}\\n\\n\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer>visited=new HashSet<>();\\n        for(int e:forbidden){\\n            visited.add(e);\\n        }\\n\\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(0,false));\\n        visited.add(0);\\n\\n        int limit=6000;// given in constarints (2000+2000+2000)\\n        int level=0;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                int pos=q.peek().pos;\\n                boolean isBackward=q.peek().isBackward;\\n                q.poll();\\n\\n                if(pos==x) return level;\\n\\n                if(!isBackward){\\n\\n                    int nextBackPos=pos-b;\\n                    if(nextBackPos>0 && !visited.contains(nextBackPos)){\\n                        visited.add(nextBackPos);\\n                        q.add(new Pair(nextBackPos,true));\\n                    }\\n                    \\n                }\\n                int nextForPos=pos+a;\\n                if(nextForPos<limit && !visited.contains(nextForPos)){\\n                    visited.add(nextForPos);\\n                    q.add(new Pair(nextForPos,false));\\n                }   \\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int pos;\\n    boolean isBackward;\\n    Pair(int pos,boolean isBackward){\\n        this.pos=pos;\\n        this.isBackward=isBackward;\\n    }\\n}\\n\\n\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer>visited=new HashSet<>();\\n        for(int e:forbidden){\\n            visited.add(e);\\n        }\\n\\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(0,false));\\n        visited.add(0);\\n\\n        int limit=6000;// given in constarints (2000+2000+2000)\\n        int level=0;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                int pos=q.peek().pos;\\n                boolean isBackward=q.peek().isBackward;\\n                q.poll();\\n\\n                if(pos==x) return level;\\n\\n                if(!isBackward){\\n\\n                    int nextBackPos=pos-b;\\n                    if(nextBackPos>0 && !visited.contains(nextBackPos)){\\n                        visited.add(nextBackPos);\\n                        q.add(new Pair(nextBackPos,true));\\n                    }\\n                    \\n                }\\n                int nextForPos=pos+a;\\n                if(nextForPos<limit && !visited.contains(nextForPos)){\\n                    visited.add(nextForPos);\\n                    q.add(new Pair(nextForPos,false));\\n                }   \\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788811,
                "title": "python-concise-bfs-easy-understanding",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden, visited, Q = set(forbidden), set(), deque()\\n        Q.append([0,0,True]) # [current_position, steps_taken_until_now, flag_for_saving_state_if_we_can_move_backward_from_this_position]\\n        threshold = max(forbidden) + x + a + b\\n        \\n        while Q:\\n            curr, steps, used = Q.popleft()\\n            \\n            if curr == x:\\n                return steps\\n            \\n            if (curr + a, False) not in visited and (curr + a) not in forbidden and (curr + a) <= threshold:\\n                Q.append([curr+a, steps+1, False])\\n                visited.add((curr+a, False))\\n            \\n            if (curr - b, True) not in visited and (curr - b) not in forbidden and not used and (curr - b) > 0 :\\n                Q.append([curr-b,steps + 1,True])\\n                visited.add((curr-b, True))\\n                         \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden, visited, Q = set(forbidden), set(), deque()\\n        Q.append([0,0,True]) # [current_position, steps_taken_until_now, flag_for_saving_state_if_we_can_move_backward_from_this_position]\\n        threshold = max(forbidden) + x + a + b\\n        \\n        while Q:\\n            curr, steps, used = Q.popleft()\\n            \\n            if curr == x:\\n                return steps\\n            \\n            if (curr + a, False) not in visited and (curr + a) not in forbidden and (curr + a) <= threshold:\\n                Q.append([curr+a, steps+1, False])\\n                visited.add((curr+a, False))\\n            \\n            if (curr - b, True) not in visited and (curr - b) not in forbidden and not used and (curr - b) > 0 :\\n                Q.append([curr-b,steps + 1,True])\\n                visited.add((curr-b, True))\\n                         \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694374,
                "title": "dfs-works-too",
                "content": "##### Java\\n```java\\nprivate int minimum = Integer.MAX_VALUE;\\n\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> forbiddenSet = Arrays.stream(forbidden).boxed().collect(Collectors.toSet());\\n        dfs(forbiddenSet, new HashSet<>(), x, 0, 0, a, b, false);\\n        return minimum == Integer.MAX_VALUE ? -1 : minimum;\\n    }\\n\\n    private void dfs(Set<Integer> forbidden, Set<Integer> visited, int target, int current, int jumps, int forward, int backward, boolean lastIsBack) {\\n        if (visited.contains(current) || forbidden.contains(current) || current < 0 || current > 6000 || jumps >= minimum)\\n            return;\\n\\n        if (!lastIsBack)\\n            visited.add(current);\\n        \\n        if (current == target)\\n            minimum = jumps;\\n        else {\\n            dfs(forbidden, visited, target, current + forward, jumps + 1, forward, backward, false);\\n            if (!lastIsBack)\\n                dfs(forbidden, visited, target, current - backward, jumps + 1, forward, backward, true);\\n        }\\n    }\\n```\\n\\n##### C++\\n```\\nprivate:\\n    int minimum = INT_MAX;\\n\\npublic:\\n    int minimumJumps(vector<int> &forbidden, int a, int b, int x) {\\n        unordered_set<int> forbiddenSet(forbidden.begin(), forbidden.end());\\n        unordered_set<int> visited;\\n        dfs(forbiddenSet, visited, x, 0, 0, a, b, false);\\n        return minimum == INT_MAX ? -1 : minimum;\\n    }\\n\\nprivate:\\n    void dfs(unordered_set<int> &forbidden, unordered_set<int> &visited, int target, int current, int jumps, int forward,int backward, bool lastIsBack) {\\n        if (visited.find(current) != visited.end() || forbidden.find(current) != visited.end() || current < 0 ||\\n            current > 6000 || jumps >= minimum)\\n            return;\\n\\n        if (!lastIsBack)\\n            visited.insert(current);\\n\\n        if (current == target)\\n            minimum = jumps;\\n        else {\\n            dfs(forbidden, visited, target, current + forward, jumps + 1, forward, backward, false);\\n            if (!lastIsBack)\\n                dfs(forbidden, visited, target, current - backward, jumps + 1, forward, backward, true);\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\nprivate int minimum = Integer.MAX_VALUE;\\n\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> forbiddenSet = Arrays.stream(forbidden).boxed().collect(Collectors.toSet());\\n        dfs(forbiddenSet, new HashSet<>(), x, 0, 0, a, b, false);\\n        return minimum == Integer.MAX_VALUE ? -1 : minimum;\\n    }\\n\\n    private void dfs(Set<Integer> forbidden, Set<Integer> visited, int target, int current, int jumps, int forward, int backward, boolean lastIsBack) {\\n        if (visited.contains(current) || forbidden.contains(current) || current < 0 || current > 6000 || jumps >= minimum)\\n            return;\\n\\n        if (!lastIsBack)\\n            visited.add(current);\\n        \\n        if (current == target)\\n            minimum = jumps;\\n        else {\\n            dfs(forbidden, visited, target, current + forward, jumps + 1, forward, backward, false);\\n            if (!lastIsBack)\\n                dfs(forbidden, visited, target, current - backward, jumps + 1, forward, backward, true);\\n        }\\n    }\\n```\n```\\nprivate:\\n    int minimum = INT_MAX;\\n\\npublic:\\n    int minimumJumps(vector<int> &forbidden, int a, int b, int x) {\\n        unordered_set<int> forbiddenSet(forbidden.begin(), forbidden.end());\\n        unordered_set<int> visited;\\n        dfs(forbiddenSet, visited, x, 0, 0, a, b, false);\\n        return minimum == INT_MAX ? -1 : minimum;\\n    }\\n\\nprivate:\\n    void dfs(unordered_set<int> &forbidden, unordered_set<int> &visited, int target, int current, int jumps, int forward,int backward, bool lastIsBack) {\\n        if (visited.find(current) != visited.end() || forbidden.find(current) != visited.end() || current < 0 ||\\n            current > 6000 || jumps >= minimum)\\n            return;\\n\\n        if (!lastIsBack)\\n            visited.insert(current);\\n\\n        if (current == target)\\n            minimum = jumps;\\n        else {\\n            dfs(forbidden, visited, target, current + forward, jumps + 1, forward, backward, false);\\n            if (!lastIsBack)\\n                dfs(forbidden, visited, target, current - backward, jumps + 1, forward, backward, true);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522402,
                "title": "python3-bfs-and-my-interpretation-of-how-to-find-the-upper-bound",
                "content": "```python\\nclass Solution1:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \"\"\"Very difficult one. I had the intuition correct, that by using BFS,\\n        we can always find the solution when x is reachable. The difficulty is\\n        when x is not reachable. Since we can always add a, there is no end\\n        to BFS. Thus, the key to the problem is to find the upper bound for\\n        BFS. If no solution is found within the upper bound, we can say x is\\n        not reachable.\\n\\n        To determine the upper bound, we have to use the Bezout\\'s Identity,\\n        which stipulates that given any integers u and v, a * v + b * v = n *\\n        gcd(a, b). In addition, we need some ingenuity, which is detailed in\\n        this post: https://leetcode.com/problems/minimum-jumps-to-reach-home/discuss/978357/C%2B%2B-bidirectional-BFS-solution-with-proof-for-search-upper-bound\\n\\n        I am going to describe here my understanding of finding the upper bound.\\n\\n        We know that if a >= b, we basically cannot go left. Thus, the upper\\n        bound is x itself. This means if we go beyond x, there is no way we\\n        can go back. So whenever we go beyond x, we know x is not reachable.\\n\\n        If a < b, we can go right and left. Now we can definitely go beyond x.\\n        Furthermore, to verify all possibilities, we have to go beyond\\n        max(forbidden), because the forbidden values add another layer of\\n        complexity. We must go beyond that to hit all possibilities associated\\n        with the forbidden value. Thus, the upper bound must be beyond max(x,\\n        max(forbidden)).\\n\\n        Given Bezout\\'s Identity, let p = n * gcd(a, b) that is the smallest\\n        value bigger than max(x, max(forbidden)). p is the left most point that\\n        we can reach beyond max(x, max(forbidden)). Notice that there is no\\n        more forbidden value to the right of p. Therefore, we don\\'t have to\\n        worry about the added complexity of forbidden values now.\\n\\n        Let\\'s say we are at p right now. The first move we can make that will\\n        land us in the new territory is p + a. Since a is a multiple of\\n        gcd(a, b), there are other points we can reach between p and p + a,\\n        such as:\\n\\n        p + gcd(a, b), p + 2 * gcd(a, b), ..., p - gcd(a, b) + a\\n\\n        Note that all these positions can only be reached by a left jump.\\n        Therefore, the upper bound must be p - gcd(a, b) + a + b.\\n\\n        One might ask, why can\\'t we go beyond p - gcd(a, b) + a + b? We\\n        certainly can, but going beyond p - gcd(a, b) + a + b won\\'t help us to\\n        reach x if we don\\'t go left. And if we go left, eventually we will end\\n        up at one of the positions in [p, p + a] again, and when that happens,\\n        we have already taken more steps than visiting the positions in\\n        [p, p + a] for the first time.\\n\\n        Therefore, the upper bound must be p - gcd(a, b) + a + b.\\n\\n        Since p = n * gcd(a, b) is the smallest multiple of gcd(a, b) that is\\n        larger than max(x, max(forbidden)), we have\\n        p - gcd(a, b) <= max(x, max(forbidden)). Thus, p - gcd(a, b) + a + b <=\\n        max(x, max(forbidden)) + a + b.\\n\\n        Therefore, it is perfectly okay for us to set the upper bound to be\\n        max(x, max(forbidden)) + a + b\\n\\n        Once we have the upper bound, we can use BFS to find the solution.\\n\\n        O(max(x, max(forbidden)) + a + b), 264 ms, faster than 31.58%\\n        \"\"\"\\n        upper_bound = max(x, max(forbidden)) + a + b\\n        forbidden = set(forbidden)\\n        queue = set([(0, False)])\\n        steps = 0\\n        visited = set()\\n        while queue:\\n            temp = set()\\n            for pos, is_pre_left in queue:\\n                visited.add(pos)\\n                if pos == x:\\n                    return steps\\n                if pos + a <= upper_bound and pos + a not in forbidden and pos + a not in visited:\\n                    temp.add((pos + a, False))\\n                if pos - b >= 0 and pos - b not in forbidden and pos - b not in visited and not is_pre_left:\\n                    temp.add((pos - b, True))\\n            if temp:\\n                steps += 1\\n            queue = temp\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution1:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \"\"\"Very difficult one. I had the intuition correct, that by using BFS,\\n        we can always find the solution when x is reachable. The difficulty is\\n        when x is not reachable. Since we can always add a, there is no end\\n        to BFS. Thus, the key to the problem is to find the upper bound for\\n        BFS. If no solution is found within the upper bound, we can say x is\\n        not reachable.\\n\\n        To determine the upper bound, we have to use the Bezout\\'s Identity,\\n        which stipulates that given any integers u and v, a * v + b * v = n *\\n        gcd(a, b). In addition, we need some ingenuity, which is detailed in\\n        this post: https://leetcode.com/problems/minimum-jumps-to-reach-home/discuss/978357/C%2B%2B-bidirectional-BFS-solution-with-proof-for-search-upper-bound\\n\\n        I am going to describe here my understanding of finding the upper bound.\\n\\n        We know that if a >= b, we basically cannot go left. Thus, the upper\\n        bound is x itself. This means if we go beyond x, there is no way we\\n        can go back. So whenever we go beyond x, we know x is not reachable.\\n\\n        If a < b, we can go right and left. Now we can definitely go beyond x.\\n        Furthermore, to verify all possibilities, we have to go beyond\\n        max(forbidden), because the forbidden values add another layer of\\n        complexity. We must go beyond that to hit all possibilities associated\\n        with the forbidden value. Thus, the upper bound must be beyond max(x,\\n        max(forbidden)).\\n\\n        Given Bezout\\'s Identity, let p = n * gcd(a, b) that is the smallest\\n        value bigger than max(x, max(forbidden)). p is the left most point that\\n        we can reach beyond max(x, max(forbidden)). Notice that there is no\\n        more forbidden value to the right of p. Therefore, we don\\'t have to\\n        worry about the added complexity of forbidden values now.\\n\\n        Let\\'s say we are at p right now. The first move we can make that will\\n        land us in the new territory is p + a. Since a is a multiple of\\n        gcd(a, b), there are other points we can reach between p and p + a,\\n        such as:\\n\\n        p + gcd(a, b), p + 2 * gcd(a, b), ..., p - gcd(a, b) + a\\n\\n        Note that all these positions can only be reached by a left jump.\\n        Therefore, the upper bound must be p - gcd(a, b) + a + b.\\n\\n        One might ask, why can\\'t we go beyond p - gcd(a, b) + a + b? We\\n        certainly can, but going beyond p - gcd(a, b) + a + b won\\'t help us to\\n        reach x if we don\\'t go left. And if we go left, eventually we will end\\n        up at one of the positions in [p, p + a] again, and when that happens,\\n        we have already taken more steps than visiting the positions in\\n        [p, p + a] for the first time.\\n\\n        Therefore, the upper bound must be p - gcd(a, b) + a + b.\\n\\n        Since p = n * gcd(a, b) is the smallest multiple of gcd(a, b) that is\\n        larger than max(x, max(forbidden)), we have\\n        p - gcd(a, b) <= max(x, max(forbidden)). Thus, p - gcd(a, b) + a + b <=\\n        max(x, max(forbidden)) + a + b.\\n\\n        Therefore, it is perfectly okay for us to set the upper bound to be\\n        max(x, max(forbidden)) + a + b\\n\\n        Once we have the upper bound, we can use BFS to find the solution.\\n\\n        O(max(x, max(forbidden)) + a + b), 264 ms, faster than 31.58%\\n        \"\"\"\\n        upper_bound = max(x, max(forbidden)) + a + b\\n        forbidden = set(forbidden)\\n        queue = set([(0, False)])\\n        steps = 0\\n        visited = set()\\n        while queue:\\n            temp = set()\\n            for pos, is_pre_left in queue:\\n                visited.add(pos)\\n                if pos == x:\\n                    return steps\\n                if pos + a <= upper_bound and pos + a not in forbidden and pos + a not in visited:\\n                    temp.add((pos + a, False))\\n                if pos - b >= 0 and pos - b not in forbidden and pos - b not in visited and not is_pre_left:\\n                    temp.add((pos - b, True))\\n            if temp:\\n                steps += 1\\n            queue = temp\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517465,
                "title": "c-bfs-easy-code-with-comments",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    // 3 -> Forbidden pos\\n    // 2 -> visited by forward move\\n    // 1 -> visited by backward move \\n    // 0 -> not visited\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int> m;\\n        for(auto x:forbidden)\\n            m[x]=3;\\n        \\n        int maxnum=10000;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        int res=0;\\n        m[0]=1;\\n        while(!q.empty())\\n        {\\n            int j=q.size();\\n            for(int i=0;i<j;i++)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                if(p.first==x)\\n                    return res;\\n                \\n                // <2 means either not visited or visited by backward move, so we can do a forward move\\n                if(p.first+a<=maxnum && m[p.first+a]<2)\\n                {\\n                    m[p.first+a]=2;\\n                    q.push({p.first+a,0});\\n                }\\n                if(p.first-b>0 && m[p.first-b]==0 && p.second==0)\\n                {\\n                    m[p.first-b]=1;\\n                    q.push({p.first-b,1});\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // 3 -> Forbidden pos\\n    // 2 -> visited by forward move\\n    // 1 -> visited by backward move \\n    // 0 -> not visited\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int> m;\\n        for(auto x:forbidden)\\n            m[x]=3;\\n        \\n        int maxnum=10000;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        int res=0;\\n        m[0]=1;\\n        while(!q.empty())\\n        {\\n            int j=q.size();\\n            for(int i=0;i<j;i++)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                if(p.first==x)\\n                    return res;\\n                \\n                // <2 means either not visited or visited by backward move, so we can do a forward move\\n                if(p.first+a<=maxnum && m[p.first+a]<2)\\n                {\\n                    m[p.first+a]=2;\\n                    q.push({p.first+a,0});\\n                }\\n                if(p.first-b>0 && m[p.first-b]==0 && p.second==0)\\n                {\\n                    m[p.first-b]=1;\\n                    q.push({p.first-b,1});\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436117,
                "title": "dp-memo-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    int dp[7001][2];\\n    int solve(int i,int a,int b,int x,bool back)\\n    {\\n      if(i==x)return 0;\\n      if((i<0) || (i>6000) || (mp.find(i)!=mp.end()))\\n      {\\n        return 1e9;\\n      }\\n      if(dp[i][back]!=-1)return dp[i][back];\\n      //go forword\\n      dp[i][back]=1+solve(i+a,a,b,x,false);\\n      \\n      if(back==false) dp[i][back]=min(dp[i][back],1+solve(i-b,a,b,x,true));\\n      \\n      return dp[i][back];\\n      \\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int f:forbidden)mp[f]++;\\n        memset(dp,-1,sizeof(dp));\\n        int res=solve(0,a,b,x,false);\\n        if(res>=1e9)return -1;\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    int dp[7001][2];\\n    int solve(int i,int a,int b,int x,bool back)\\n    {\\n      if(i==x)return 0;\\n      if((i<0) || (i>6000) || (mp.find(i)!=mp.end()))\\n      {\\n        return 1e9;\\n      }\\n      if(dp[i][back]!=-1)return dp[i][back];\\n      //go forword\\n      dp[i][back]=1+solve(i+a,a,b,x,false);\\n      \\n      if(back==false) dp[i][back]=min(dp[i][back],1+solve(i-b,a,b,x,true));\\n      \\n      return dp[i][back];\\n      \\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int f:forbidden)mp[f]++;\\n        memset(dp,-1,sizeof(dp));\\n        int res=solve(0,a,b,x,false);\\n        if(res>=1e9)return -1;\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364299,
                "title": "very-easy-bfs-stepwise-explanation",
                "content": "```\\n// Here We are Using BFS Since every time there can be neighbours \\n// at every step (consider neighbours here as moving forward and backward position (if possible)).\\n// So here we apply simple bfs traversal. \\n\\n// We are keeping track of backward movement by queue second value i.e. -1 \\n// here since here no consecutive backward movement is allowed.\\n\\n// Map is used so that if we some point again then simply return because that point is already under process in queue (it just like visited array in out normal dfs/bfs). \\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& nums, int a, int b, int x) {\\n        queue<pair<int,int>> q;\\n        map<int,bool>seen;\\n        \\n        // mark forbidden values as seen \\n        for( int i = 0 ; i < nums.size() ;  i++ ){\\n            seen[nums[i]] = true;\\n        }\\n        \\n        // first  => current index\\n        // second => track of backward movement : 0=>we can move backward, -1 means we cannot move backward(we already moved back in previous turn)\\n        // we dont allow it to go backward?? => NO as it mentions in the comment we cannot go to negative integer indexes\\n        q.push({0,-1});\\n        \\n        int lvl = -1;\\n        \\n        while(!q.empty()){\\n            \\n            // increment the level\\n            lvl++;\\n            int sz = q.size();\\n            \\n            // process all the elements that were in the queue (not the elements that are being added now)\\n            while(sz--){\\n                int node = q.front().first;\\n                int val = q.front().second;\\n                q.pop();\\n                   \\n                // we reached the target position\\n                if(node == x){\\n                        return lvl;\\n                    }\\n                   \\n                //if this is a forbidden node/ or a visited node\\n                if(seen[node]){\\n                        continue;\\n                    }\\n            \\n                // mark current node as visited \\n                seen[node]=true;\\n                \\n                //we already made a backward step in the previous iteration\\n                if(val==-1){\\n                    \\n                    // move forward by a units\\n                    int k = a+node;\\n                    \\n                    // 2000+b => is taken as it will be the max amount we can go as , if we go to this location and then take b steps back we reach x\\n                    if(node<=2000+b){\\n                        q.push({k,0});\\n                    }\\n                    \\n                }\\n               //we made a forward step in the previous iteration\\n\\n                else if(val==0){\\n                    int k1= a + node;\\n                    int k2= node - b;\\n                    \\n                    // condition given in the question to not move to negative indexes\\n                    if(k2>=0){\\n                        q.push({k2,-1});\\n                    }\\n                    // if we are able to reach an index less than 2000+b we can explore it once, as we might go to xmax+b , if say b=2000 & x=2000 & a =2000 then to reach x we need to come back from x+b backward by moving a once(as we cant move backward twice)\\n                    if(node<=2000+b){\\n                        q.push({k1,0});\\n                    }\\n                }\\n            }\\n        }\\n        // if we did not reach the target position\\n        return -1;\\n    }\\n};\\n```\\ncredits: @77jj",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Here We are Using BFS Since every time there can be neighbours \\n// at every step (consider neighbours here as moving forward and backward position (if possible)).\\n// So here we apply simple bfs traversal. \\n\\n// We are keeping track of backward movement by queue second value i.e. -1 \\n// here since here no consecutive backward movement is allowed.\\n\\n// Map is used so that if we some point again then simply return because that point is already under process in queue (it just like visited array in out normal dfs/bfs). \\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& nums, int a, int b, int x) {\\n        queue<pair<int,int>> q;\\n        map<int,bool>seen;\\n        \\n        // mark forbidden values as seen \\n        for( int i = 0 ; i < nums.size() ;  i++ ){\\n            seen[nums[i]] = true;\\n        }\\n        \\n        // first  => current index\\n        // second => track of backward movement : 0=>we can move backward, -1 means we cannot move backward(we already moved back in previous turn)\\n        // we dont allow it to go backward?? => NO as it mentions in the comment we cannot go to negative integer indexes\\n        q.push({0,-1});\\n        \\n        int lvl = -1;\\n        \\n        while(!q.empty()){\\n            \\n            // increment the level\\n            lvl++;\\n            int sz = q.size();\\n            \\n            // process all the elements that were in the queue (not the elements that are being added now)\\n            while(sz--){\\n                int node = q.front().first;\\n                int val = q.front().second;\\n                q.pop();\\n                   \\n                // we reached the target position\\n                if(node == x){\\n                        return lvl;\\n                    }\\n                   \\n                //if this is a forbidden node/ or a visited node\\n                if(seen[node]){\\n                        continue;\\n                    }\\n            \\n                // mark current node as visited \\n                seen[node]=true;\\n                \\n                //we already made a backward step in the previous iteration\\n                if(val==-1){\\n                    \\n                    // move forward by a units\\n                    int k = a+node;\\n                    \\n                    // 2000+b => is taken as it will be the max amount we can go as , if we go to this location and then take b steps back we reach x\\n                    if(node<=2000+b){\\n                        q.push({k,0});\\n                    }\\n                    \\n                }\\n               //we made a forward step in the previous iteration\\n\\n                else if(val==0){\\n                    int k1= a + node;\\n                    int k2= node - b;\\n                    \\n                    // condition given in the question to not move to negative indexes\\n                    if(k2>=0){\\n                        q.push({k2,-1});\\n                    }\\n                    // if we are able to reach an index less than 2000+b we can explore it once, as we might go to xmax+b , if say b=2000 & x=2000 & a =2000 then to reach x we need to come back from x+b backward by moving a once(as we cant move backward twice)\\n                    if(node<=2000+b){\\n                        q.push({k1,0});\\n                    }\\n                }\\n            }\\n        }\\n        // if we did not reach the target position\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101575,
                "title": "c-bfs-no-dp",
                "content": "```\\n// Here We are Using BFS Since every time there can be neighbours \\n// at evry step (consider neighbours here as moving forward and backward position (if possible)).\\n// So here we apply simple bfs traversal. \\n// We are keeping track of backward movement by queue second value i.e. -1 \\n// here since here no consecutive backward movement is allowed.\\n// Map is used so that if we some point again then simply return because that point is already under process in queue (it just like visited array in out normal dfs/bfs). \\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>&nums, int a, int b, int x) {\\n        queue<pair<int,int>>q;\\n        map<int,bool>seen;\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            seen[nums[i]] = true;\\n        }\\n        q.push({0,-1});\\n        int lvl = -1;\\n        while(!q.empty())\\n        {\\n            lvl++;\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int node = q.front().first;\\n                int val = q.front().second;\\n                q.pop();\\n                if(node==x)\\n                {\\n                    return lvl;\\n                }\\n                if(seen[node])\\n                {\\n                    continue;\\n                }\\n                seen[node] = true;\\n                if(val==-1)\\n                {\\n                    int k = a+node;\\n                    if(node<=2000+b)\\n                    {\\n                      q.push({k,0});\\n                    }\\n                }\\n                else if(val==0)\\n                {\\n                    int k1 = a + node;\\n                    int k2 = node - b;\\n                    if(k2>=0)\\n                    {\\n                       q.push({k2,-1});\\n                    }\\n                    if(node<=2000+b)\\n                    {\\n                       q.push({k1,0});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Please Upvote if You like the code and Explanation..!! :):)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n// Here We are Using BFS Since every time there can be neighbours \\n// at evry step (consider neighbours here as moving forward and backward position (if possible)).\\n// So here we apply simple bfs traversal. \\n// We are keeping track of backward movement by queue second value i.e. -1 \\n// here since here no consecutive backward movement is allowed.\\n// Map is used so that if we some point again then simply return because that point is already under process in queue (it just like visited array in out normal dfs/bfs). \\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>&nums, int a, int b, int x) {\\n        queue<pair<int,int>>q;\\n        map<int,bool>seen;\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            seen[nums[i]] = true;\\n        }\\n        q.push({0,-1});\\n        int lvl = -1;\\n        while(!q.empty())\\n        {\\n            lvl++;\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int node = q.front().first;\\n                int val = q.front().second;\\n                q.pop();\\n                if(node==x)\\n                {\\n                    return lvl;\\n                }\\n                if(seen[node])\\n                {\\n                    continue;\\n                }\\n                seen[node] = true;\\n                if(val==-1)\\n                {\\n                    int k = a+node;\\n                    if(node<=2000+b)\\n                    {\\n                      q.push({k,0});\\n                    }\\n                }\\n                else if(val==0)\\n                {\\n                    int k1 = a + node;\\n                    int k2 = node - b;\\n                    if(k2>=0)\\n                    {\\n                       q.push({k2,-1});\\n                    }\\n                    if(node<=2000+b)\\n                    {\\n                       q.push({k1,0});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092842,
                "title": "javascript-bfs",
                "content": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(Number.MAX_SAFE_INTEGER); d.push(t); } return d; };\\n\\nconst minimumJumps = (forbidden, a, b, x) => {\\n    // save min dis in 0 index for +a, 1 for -b\\n    let dis = initialize2DArray(100005, 2), q = [[0, \\'s\\']], se = new Set(forbidden);\\n    dis[0][0] = 0;\\n    while (q.length) {\\n        let [cur, mark] = q.shift(), next = [cur + a, cur - b];\\n        let curPos = mark == \\'b\\' ? 1 : 0;\\n        for (const ne of next) {\\n            if (se.has(ne)) continue;\\n            if (ne < 0 || ne >= dis.length) continue;\\n            if (ne < cur && mark == \\'b\\') continue; // doesn\\'t allow two consective backwards\\n            let pos = ne < cur ? 1 : 0;\\n            if (dis[ne][pos] > dis[cur][curPos] + 1) { // update min distance\\n                dis[ne][pos] = dis[cur][curPos] + 1;\\n                q.push([ne, ne < cur ? \\'b\\' : \\'f\\']);\\n            }\\n        }\\n    }\\n    let res = Math.min(dis[x][0], dis[x][1])\\n    return res == Number.MAX_SAFE_INTEGER ? -1 : res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(Number.MAX_SAFE_INTEGER); d.push(t); } return d; };\\n\\nconst minimumJumps = (forbidden, a, b, x) => {\\n    // save min dis in 0 index for +a, 1 for -b\\n    let dis = initialize2DArray(100005, 2), q = [[0, \\'s\\']], se = new Set(forbidden);\\n    dis[0][0] = 0;\\n    while (q.length) {\\n        let [cur, mark] = q.shift(), next = [cur + a, cur - b];\\n        let curPos = mark == \\'b\\' ? 1 : 0;\\n        for (const ne of next) {\\n            if (se.has(ne)) continue;\\n            if (ne < 0 || ne >= dis.length) continue;\\n            if (ne < cur && mark == \\'b\\') continue; // doesn\\'t allow two consective backwards\\n            let pos = ne < cur ? 1 : 0;\\n            if (dis[ne][pos] > dis[cur][curPos] + 1) { // update min distance\\n                dis[ne][pos] = dis[cur][curPos] + 1;\\n                q.push([ne, ne < cur ? \\'b\\' : \\'f\\']);\\n            }\\n        }\\n    }\\n    let res = Math.min(dis[x][0], dis[x][1])\\n    return res == Number.MAX_SAFE_INTEGER ? -1 : res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053201,
                "title": "javascript-dfs-memo",
                "content": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    let f = new Set(forbidden);\\n    let m = 2000 + 2 * b;\\n    let memo = {};\\n    let visited = new Set();\\n    let res = dfs(0, true);\\n    return res === Infinity ? -1 : res;\\n    \\n    function dfs(i,canJumpBack) {\\n        if (i === x) return 0;\\n        let key = `${i},${canJumpBack}`;\\n        visited.add(i);\\n        if (memo[key] !== undefined) return memo[key];\\n        if (i > m || i < 0) return Infinity;\\n        let min = Infinity;\\n        if (canJumpBack && !f.has(i - b) && !visited.has(i-b)) {\\n            min = Math.min(min, 1 + dfs(i - b, false));\\n        }\\n        \\n        if (!f.has(i + a) && !visited.has(i+a)) {\\n            min = Math.min(min, 1 + dfs(i + a, true));\\n        }\\n        \\n        visited.delete(i);\\n        return memo[key] = min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    let f = new Set(forbidden);\\n    let m = 2000 + 2 * b;\\n    let memo = {};\\n    let visited = new Set();\\n    let res = dfs(0, true);\\n    return res === Infinity ? -1 : res;\\n    \\n    function dfs(i,canJumpBack) {\\n        if (i === x) return 0;\\n        let key = `${i},${canJumpBack}`;\\n        visited.add(i);\\n        if (memo[key] !== undefined) return memo[key];\\n        if (i > m || i < 0) return Infinity;\\n        let min = Infinity;\\n        if (canJumpBack && !f.has(i - b) && !visited.has(i-b)) {\\n            min = Math.min(min, 1 + dfs(i - b, false));\\n        }\\n        \\n        if (!f.has(i + a) && !visited.has(i+a)) {\\n            min = Math.min(min, 1 + dfs(i + a, true));\\n        }\\n        \\n        visited.delete(i);\\n        return memo[key] = min;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2029519,
                "title": "java-bfs-beats-100",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        int pos;\\n        boolean dir;\\n        public Pair(int pos, boolean dir) {\\n            this.pos = pos;\\n            this.dir = dir;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] visited = new boolean[limit];\\n        for (int num: forbidden) {\\n            visited[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        visited[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                boolean dir = p.dir;\\n              \\n                if (pos == x) return step;\\n                \\n                if (dir==false) {\\n                    int backward = pos - b;\\n                  \\n                    if (backward > 0 && !visited[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        visited[backward] = true;\\n                    }\\n                }\\n                \\n                int forward = pos + a;\\n           \\n                if (forward < limit && !visited[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    visited[forward] = true;\\n                }\\n              \\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int pos;\\n        boolean dir;\\n        public Pair(int pos, boolean dir) {\\n            this.pos = pos;\\n            this.dir = dir;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] visited = new boolean[limit];\\n        for (int num: forbidden) {\\n            visited[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        visited[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                boolean dir = p.dir;\\n              \\n                if (pos == x) return step;\\n                \\n                if (dir==false) {\\n                    int backward = pos - b;\\n                  \\n                    if (backward > 0 && !visited[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        visited[backward] = true;\\n                    }\\n                }\\n                \\n                int forward = pos + a;\\n           \\n                if (forward < limit && !visited[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    visited[forward] = true;\\n                }\\n              \\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919466,
                "title": "c-bfs-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n    \\n    /*\\n        Since here we need to find the minimum jumps to reach bugs home, so BFS algorithm can help.\\n        Now let\\'s understand the question.\\n        \\n        Suppose we are standing at any position on the x-axis then three options can be there -\\n        1. Our current position is forbidden or we have reached this position earlier. so we don\\'t need to take any action from this                point\\n        2. We can jump a steps forward. Note that a and b can have maximum value of 2000 so we cannot go to a position where \\n            curPosition>2000+b because we wont reach home in this case.\\n        3. We can jump b steps backward. But this step can be taken only when our last jump was forward otherwise we dont need to\\n            jump backward.\\n        \\n        To handle case 1 we can use a hashmap which will store whether our current position is forbidden or we have reached this                position before.\\n        \\n        To handle case 2 and case 3 we need a queue of pairs whose first  value will store our jump and whether the jump was \\n        forward or backward.\\n        1 - denote jump was backward\\n        0 - denote jump was forward.\\n        \\n        now we will run BFS taking these cases into consideration and if we reach our target we return jumps else when\\n        queue gets exhausted we return from it.\\n    */\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,bool> mp;\\n        for(auto i:forbidden)\\n            mp[i]=true;\\n        queue<pair<int,int> > q;\\n        q.push({0,0});\\n        int jumps=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                auto cur=q.front();\\n                q.pop();\\n                if(cur.first==x)\\n                    return jumps;\\n                if(mp[cur.first]==true)\\n                    continue;\\n                mp[cur.first]=true;\\n                if(cur.first-b>=0 && cur.second==0)\\n                    q.push({cur.first-b,1});\\n                if(cur.first<=2000+b)\\n                    q.push({cur.first+a,0});\\n            }\\n            jumps++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    /*\\n        Since here we need to find the minimum jumps to reach bugs home, so BFS algorithm can help.\\n        Now let\\'s understand the question.\\n        \\n        Suppose we are standing at any position on the x-axis then three options can be there -\\n        1. Our current position is forbidden or we have reached this position earlier. so we don\\'t need to take any action from this                point\\n        2. We can jump a steps forward. Note that a and b can have maximum value of 2000 so we cannot go to a position where \\n            curPosition>2000+b because we wont reach home in this case.\\n        3. We can jump b steps backward. But this step can be taken only when our last jump was forward otherwise we dont need to\\n            jump backward.\\n        \\n        To handle case 1 we can use a hashmap which will store whether our current position is forbidden or we have reached this                position before.\\n        \\n        To handle case 2 and case 3 we need a queue of pairs whose first  value will store our jump and whether the jump was \\n        forward or backward.\\n        1 - denote jump was backward\\n        0 - denote jump was forward.\\n        \\n        now we will run BFS taking these cases into consideration and if we reach our target we return jumps else when\\n        queue gets exhausted we return from it.\\n    */\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,bool> mp;\\n        for(auto i:forbidden)\\n            mp[i]=true;\\n        queue<pair<int,int> > q;\\n        q.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1870865,
                "title": "dp-clean-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[6001][2]; //6000 or 6001 is maximum accessible distance and 2 is state forward/backward\\n    unordered_map<int,int> mp;//map to retrieve which value is forbidden otherwise we have to tarverse                                   //again and again in forbidden array\\n    int helper(int i,bool back,int a,int b,int x){\\n        if(i==x) return 0; \\n        if(i<0 || i>6000 || mp.find(i)!=mp.end() || back>=2) return 1e9; //Conddition we will not get ans\\n        if(dp[i][back]!=-1){\\n            return dp[i][back]; //if value is already stored return\\n        }\\n        dp[i][back]=1+helper(i+a,0,a,b,x); //1 is too denote we have taken 1 steps forward\\n        if(!back){\\n            dp[i][back]=min(dp[i][back],helper(i-b,1,a,b,x)+1); //We can not mve consecutively two times                                                                   //back\\n        }\\n        return dp[i][back];\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++){\\n            mp[forbidden[i]]=1;\\n        }\\n        memset(dp,-1,sizeof(dp));//Setting alll value of dp to -1\\n        int ans=helper(0,0,a,b,x);//First 0 will be starting index and second zero means forward step\\n        return ans>1e9?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[6001][2]; //6000 or 6001 is maximum accessible distance and 2 is state forward/backward\\n    unordered_map<int,int> mp;//map to retrieve which value is forbidden otherwise we have to tarverse                                   //again and again in forbidden array\\n    int helper(int i,bool back,int a,int b,int x){\\n        if(i==x) return 0; \\n        if(i<0 || i>6000 || mp.find(i)!=mp.end() || back>=2) return 1e9; //Conddition we will not get ans\\n        if(dp[i][back]!=-1){\\n            return dp[i][back]; //if value is already stored return\\n        }\\n        dp[i][back]=1+helper(i+a,0,a,b,x); //1 is too denote we have taken 1 steps forward\\n        if(!back){\\n            dp[i][back]=min(dp[i][back],helper(i-b,1,a,b,x)+1); //We can not mve consecutively two times                                                                   //back\\n        }\\n        return dp[i][back];\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++){\\n            mp[forbidden[i]]=1;\\n        }\\n        memset(dp,-1,sizeof(dp));//Setting alll value of dp to -1\\n        int ans=helper(0,0,a,b,x);//First 0 will be starting index and second zero means forward step\\n        return ans>1e9?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839974,
                "title": "simple-solution-in-java-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if(x == 0) return 0;\\n        \\n        // The bug cannot go in the backward direction two times\\n        \\n        HashSet<String> visited = new HashSet<>();\\n        for(int f : forbidden){\\n            visited.add(f+\",\"+1);\\n            visited.add(f+\",\"+0);\\n        }\\n        // Check if target is forbidden\\n        if(visited.contains(x+\",\"+0) || visited.contains(x+\",\"+1)) return -1;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        // Zero is the starting point\\n        // 1 -> Forward\\n        // 0 -> Backward\\n        queue.offer(new Pair(0, 1));\\n        visited.add(0+\",\"+1);\\n        \\n        int step = 0;\\n        while(!queue.isEmpty()){\\n            step++;\\n            \\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                Pair pa = queue.poll();\\n                \\n                /*\\n                   6000 because we don\\'t want to lose any state, as the max value of a and b is 2000, suppose if we take\\n\\t\\t\\t\\t   4000 value instead of 6000 and a and b are 2000, then 4000 and backward direction position will not \\n\\t\\t\\t\\t   be possible, to avoid that, take max value to be 6000 to be able to reach all the states \\n                */\\n                if(pa.x > 6000) continue; \\n                if(pa.x < 0) continue;\\n                \\n                // Check whether reached the target or not\\n                if((pa.x + a == x) || (pa.dir == 1 && pa.x - b == x)){\\n                   return step; \\n                }\\n                \\n                // Go forward\\n                if(!visited.contains( (pa.x + a) +\",\"+1)){\\n                    visited.add((pa.x + a)+\",\"+1);\\n                    queue.offer(new Pair(pa.x+a, 1));\\n                }\\n                \\n                // Go backward\\n                // Can only go backward if the current direction is not backward\\n                if(pa.dir != 0 && !visited.contains((pa.x - b) + \",\" + 0)){\\n                    visited.add((pa.x - b) + \",\" + 0);\\n                    queue.offer(new Pair(pa.x - b, 0));\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private class Pair{\\n        public int x;\\n        public int dir;\\n        \\n        public Pair(int x, int dir){\\n            this.x = x;\\n            this.dir = dir;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if(x == 0) return 0;\\n        \\n        // The bug cannot go in the backward direction two times\\n        \\n        HashSet<String> visited = new HashSet<>();\\n        for(int f : forbidden){\\n            visited.add(f+\",\"+1);\\n            visited.add(f+\",\"+0);\\n        }\\n        // Check if target is forbidden\\n        if(visited.contains(x+\",\"+0) || visited.contains(x+\",\"+1)) return -1;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        // Zero is the starting point\\n        // 1 -> Forward\\n        // 0 -> Backward\\n        queue.offer(new Pair(0, 1));\\n        visited.add(0+\",\"+1);\\n        \\n        int step = 0;\\n        while(!queue.isEmpty()){\\n            step++;\\n            \\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                Pair pa = queue.poll();\\n                \\n                /*\\n                   6000 because we don\\'t want to lose any state, as the max value of a and b is 2000, suppose if we take\\n\\t\\t\\t\\t   4000 value instead of 6000 and a and b are 2000, then 4000 and backward direction position will not \\n\\t\\t\\t\\t   be possible, to avoid that, take max value to be 6000 to be able to reach all the states \\n                */\\n                if(pa.x > 6000) continue; \\n                if(pa.x < 0) continue;\\n                \\n                // Check whether reached the target or not\\n                if((pa.x + a == x) || (pa.dir == 1 && pa.x - b == x)){\\n                   return step; \\n                }\\n                \\n                // Go forward\\n                if(!visited.contains( (pa.x + a) +\",\"+1)){\\n                    visited.add((pa.x + a)+\",\"+1);\\n                    queue.offer(new Pair(pa.x+a, 1));\\n                }\\n                \\n                // Go backward\\n                // Can only go backward if the current direction is not backward\\n                if(pa.dir != 0 && !visited.contains((pa.x - b) + \",\" + 0)){\\n                    visited.add((pa.x - b) + \",\" + 0);\\n                    queue.offer(new Pair(pa.x - b, 0));\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private class Pair{\\n        public int x;\\n        public int dir;\\n        \\n        public Pair(int x, int dir){\\n            this.x = x;\\n            this.dir = dir;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316296,
                "title": "easy-bfs-solution-ii",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>jumps;\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int, bool>mp;\\n        for(int i=0; i<forbidden.size(); i++)\\n            mp[forbidden[i]] = true;\\n        int n = 10001;\\n        jumps.resize(n, INT_MAX);\\n        jumps[0] = 0;\\n        \\n        queue<vector<int>>q;                     //currentPos, lastMove(0->forward, 1->backward), minJumps\\n        q.push({0, 0, 0});\\n        while(!q.empty()){\\n            auto top = q.front();\\n            q.pop();\\n            \\n            if(top[0] == x)\\n                return top[2];\\n            \\n            if(top[1] != 1 and mp.find(top[0] - b) == mp.end() and top[0]-b >= 0 and top[2]+1 < jumps[top[0] - b]){\\n                vector<int>v = {top[0] - b, 1, top[2]+1};\\n                q.push(v);\\n                jumps[top[0] - b] = top[2] + 1;\\n            }\\n            \\n            if(mp.find(top[0] + a) == mp.end() and top[0]+a < n and top[2]+1 < jumps[top[0]+a]){\\n                vector<int>v = {top[0] + a, 0, top[2]+1};\\n                q.push(v);\\n                jumps[top[0] + a] = top[2] + 1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>jumps;\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int, bool>mp;\\n        for(int i=0; i<forbidden.size(); i++)\\n            mp[forbidden[i]] = true;\\n        int n = 10001;\\n        jumps.resize(n, INT_MAX);\\n        jumps[0] = 0;\\n        \\n        queue<vector<int>>q;                     //currentPos, lastMove(0->forward, 1->backward), minJumps\\n        q.push({0, 0, 0});\\n        while(!q.empty()){\\n            auto top = q.front();\\n            q.pop();\\n            \\n            if(top[0] == x)\\n                return top[2];\\n            \\n            if(top[1] != 1 and mp.find(top[0] - b) == mp.end() and top[0]-b >= 0 and top[2]+1 < jumps[top[0] - b]){\\n                vector<int>v = {top[0] - b, 1, top[2]+1};\\n                q.push(v);\\n                jumps[top[0] - b] = top[2] + 1;\\n            }\\n            \\n            if(mp.find(top[0] + a) == mp.end() and top[0]+a < n and top[2]+1 < jumps[top[0]+a]){\\n                vector<int>v = {top[0] + a, 0, top[2]+1};\\n                q.push(v);\\n                jumps[top[0] + a] = top[2] + 1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248387,
                "title": "bfs-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\n        unordered_set<int> v;\\n        queue<pair<int,int>> q; // The second part of the pair is a flag which indicates whether the first is in reverse direction or not. \\n        for(int i = 0 ; i< forbidden.size() ; i++){\\n            v.insert(forbidden[i]) ;\\n        }\\n        q.push(make_pair(0,0)) ; // Since the first way to move is forward, second is 0.\\n        int ans = 0;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            while(size--){\\n                auto curr = q.front() ;\\n                q.pop() ;\\n                int num = curr.first;\\n                if(num == x){\\n                    return ans;\\n                }\\n               \\n                if(v.count(num) == 1){\\n                    continue;\\n                } \\n                v.insert(num);\\n                if(curr.second == 0){\\n                    // If curr.second is 1, it means that it cannot move backward second time. Hence, it is only executed when second is 0.\\n                    int step = num - b;\\n                    if(step >= 0){\\n                        q.push(make_pair(step,1));\\n                    }\\n                }\\n                int step = num+a;\\n                if(step <= 2000+a+b){\\n                    q.push(make_pair(step,0));\\n                    \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\n        unordered_set<int> v;\\n        queue<pair<int,int>> q; // The second part of the pair is a flag which indicates whether the first is in reverse direction or not. \\n        for(int i = 0 ; i< forbidden.size() ; i++){\\n            v.insert(forbidden[i]) ;\\n        }\\n        q.push(make_pair(0,0)) ; // Since the first way to move is forward, second is 0.\\n        int ans = 0;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            while(size--){\\n                auto curr = q.front() ;\\n                q.pop() ;\\n                int num = curr.first;\\n                if(num == x){\\n                    return ans;\\n                }\\n               \\n                if(v.count(num) == 1){\\n                    continue;\\n                } \\n                v.insert(num);\\n                if(curr.second == 0){\\n                    // If curr.second is 1, it means that it cannot move backward second time. Hence, it is only executed when second is 0.\\n                    int step = num - b;\\n                    if(step >= 0){\\n                        q.push(make_pair(step,1));\\n                    }\\n                }\\n                int step = num+a;\\n                if(step <= 2000+a+b){\\n                    q.push(make_pair(step,0));\\n                    \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242963,
                "title": "simple-bfs-solution-cpp",
                "content": "```\\nstruct info\\n    {\\n        int curr;bool flag;int count;\\n    };\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x)\\n    {\\n        unordered_map<int,int>vis;\\n        for(int i=0;i<forbidden.size();i++)\\n            vis[forbidden[i]]=1;\\n        queue<info>q1;\\n        q1.push({0,1,0});\\n        \\n        \\n        while(!q1.empty())\\n        {\\n            \\n            int curr=q1.front().curr;\\n            bool flag=q1.front().flag;\\n            int count=q1.front().count;\\n            //cout<<curr<<\" \";\\n            q1.pop();\\n            \\n            if(curr==x)\\n                return count;\\n            \\n            if(curr-b>=0 && vis[curr-b]==0 && flag==1)\\n            {\\n                q1.push({curr-b,0,count+1});\\n                vis[curr-b]=1;\\n            }\\n            if(vis[curr+a]==0 && curr+a<6000 )\\n            {\\n                q1.push({curr+a,1,count+1});\\n                vis[curr+a]=1;\\n            }\\n            \\n            count++;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nstruct info\\n    {\\n        int curr;bool flag;int count;\\n    };\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x)\\n    {\\n        unordered_map<int,int>vis;\\n        for(int i=0;i<forbidden.size();i++)\\n            vis[forbidden[i]]=1;\\n        queue<info>q1;\\n        q1.push({0,1,0});\\n        \\n        \\n        while(!q1.empty())\\n        {\\n            \\n            int curr=q1.front().curr;\\n            bool flag=q1.front().flag;\\n            int count=q1.front().count;\\n            //cout<<curr<<\" \";\\n            q1.pop();\\n            \\n            if(curr==x)\\n                return count;\\n            \\n            if(curr-b>=0 && vis[curr-b]==0 && flag==1)\\n            {\\n                q1.push({curr-b,0,count+1});\\n                vis[curr-b]=1;\\n            }\\n            if(vis[curr+a]==0 && curr+a<6000 )\\n            {\\n                q1.push({curr+a,1,count+1});\\n                vis[curr+a]=1;\\n            }\\n            \\n            count++;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n```",
                "codeTag": "C++"
            },
            {
                "id": 1145505,
                "title": "python-bfs-solution-using-deque",
                "content": "* it\\'s very hard to set the threshold, it can be changed if more test cases are involved.\\n\\nfrom collections import deque\\nclass Solution:\\n\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        stack = deque([(0,False,0)]) # first index records current position, second index records previous movement is backward or not, third index records the number of steps\\n        forbidden = set(forbidden)\\n        toofar = 6000 # very tricky threshold \\n        visited = set()\\n        while(stack):\\n            position, backward, step = stack.popleft()\\n            if position == x:\\n                return step\\n            if position> toofar or position in visited:\\n                continue\\n            if not backward: # we only add current position into visited when it is from forward movement\\n                visited.add(position)\\n            if position+a not in forbidden: # check if forward movement is possible \\n                stack.append((position+a, False, step+1))\\n            if position-b>0 and position-b not in forbidden and backward == False: # check if backward movement is possible\\n                stack.append((position-b, True, step+1))\\n        return -1",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "* it\\'s very hard to set the threshold, it can be changed if more test cases are involved.\\n\\nfrom collections import deque\\nclass Solution:\\n\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        stack = deque([(0,False,0)]) # first index records current position, second index records previous movement is backward or not, third index records the number of steps\\n        forbidden = set(forbidden)\\n        toofar = 6000 # very tricky threshold \\n        visited = set()\\n        while(stack):\\n            position, backward, step = stack.popleft()\\n            if position == x:\\n                return step\\n            if position> toofar or position in visited:\\n                continue\\n            if not backward: # we only add current position into visited when it is from forward movement\\n                visited.add(position)\\n            if position+a not in forbidden: # check if forward movement is possible \\n                stack.append((position+a, False, step+1))\\n            if position-b>0 and position-b not in forbidden and backward == False: # check if backward movement is possible\\n                stack.append((position-b, True, step+1))\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 1098702,
                "title": "easiest-bfs-java-solution",
                "content": "```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n\\n    public int minimumJumps(int[] f, int a, int b, int x) {\\n        Set<Integer> forbidden = Arrays.stream(f).boxed().collect(Collectors.toSet());\\n\\n        Queue<int[]> queue = new ArrayDeque<>();\\n\\n        queue.offer(new int[]{0, 0, 1});    // currentPosition, cost, canJumpBack\\n\\n        while (!queue.isEmpty()){\\n            int[] t = queue.poll();\\n            int pos = t[0];\\n            int cost = t[1];\\n            int canJumpBack = t[2];\\n\\n            if(pos == x) return cost;\\n            if(forbidden.contains(pos)) continue;\\n            forbidden.add(pos);\\n\\n            int next = pos + a;\\n            int prev = pos - b;\\n            \\n            if(!forbidden.contains(prev) && prev >= 0 && canJumpBack == 1) {\\n                queue.offer(new int[]{prev, cost + 1, 0});\\n            }\\n\\n            if(!forbidden.contains(next) && next < 6000) {\\n                queue.offer(new int[]{next, cost + 1, 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n\\n    public int minimumJumps(int[] f, int a, int b, int x) {\\n        Set<Integer> forbidden = Arrays.stream(f).boxed().collect(Collectors.toSet());\\n\\n        Queue<int[]> queue = new ArrayDeque<>();\\n\\n        queue.offer(new int[]{0, 0, 1});    // currentPosition, cost, canJumpBack\\n\\n        while (!queue.isEmpty()){\\n            int[] t = queue.poll();\\n            int pos = t[0];\\n            int cost = t[1];\\n            int canJumpBack = t[2];\\n\\n            if(pos == x) return cost;\\n            if(forbidden.contains(pos)) continue;\\n            forbidden.add(pos);\\n\\n            int next = pos + a;\\n            int prev = pos - b;\\n            \\n            if(!forbidden.contains(prev) && prev >= 0 && canJumpBack == 1) {\\n                queue.offer(new int[]{prev, cost + 1, 0});\\n            }\\n\\n            if(!forbidden.contains(next) && next < 6000) {\\n                queue.offer(new int[]{next, cost + 1, 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1093297,
                "title": "python-java-solution-bfs-faster-than-100-solutions",
                "content": "**Java Solution (15ms)**\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<int[]> queue=new LinkedList<>();\\n        queue.offer(new int[]{x,0,1});\\n        Set<Integer> vis=new HashSet<>();\\n        Integer lim=x;\\n        for (int i: forbidden) {vis.add(i); lim=Math.max(lim,i);};\\n        lim+=a+b;\\n        while (!queue.isEmpty()){\\n            int[] temp=queue.poll();\\n            int curr=temp[0], jumps=temp[1], is_b=temp[2];\\n            if(curr<0 || curr>lim || vis.contains(curr)) continue;\\n            vis.add(curr);\\n            if (curr==0) return jumps;\\n            if(is_b==1) queue.offer(new int[]{curr+b, jumps+1, 0});\\n            queue.offer(new int[]{curr-a, jumps+1, 1});\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Python Solution (76ms)**\\n```\\nclass Solution:\\n    def minimumJumps(self, vis: List[int], a: int, b: int, x: int) -> int:\\n        queue,vis=[(x,0,True)],set(vis)\\n        lim=max(max(vis),x)+a+b\\n        while queue:\\n            curr,jumps,is_b=queue.pop(0)\\n            if curr in vis or not 0<=curr<=lim: continue\\n            vis.add(curr)\\n            if curr==0: return jumps\\n            if is_b: queue.append((curr+b,jumps+1,False))\\n            queue.append((curr-a,jumps+1,True))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<int[]> queue=new LinkedList<>();\\n        queue.offer(new int[]{x,0,1});\\n        Set<Integer> vis=new HashSet<>();\\n        Integer lim=x;\\n        for (int i: forbidden) {vis.add(i); lim=Math.max(lim,i);};\\n        lim+=a+b;\\n        while (!queue.isEmpty()){\\n            int[] temp=queue.poll();\\n            int curr=temp[0], jumps=temp[1], is_b=temp[2];\\n            if(curr<0 || curr>lim || vis.contains(curr)) continue;\\n            vis.add(curr);\\n            if (curr==0) return jumps;\\n            if(is_b==1) queue.offer(new int[]{curr+b, jumps+1, 0});\\n            queue.offer(new int[]{curr-a, jumps+1, 1});\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minimumJumps(self, vis: List[int], a: int, b: int, x: int) -> int:\\n        queue,vis=[(x,0,True)],set(vis)\\n        lim=max(max(vis),x)+a+b\\n        while queue:\\n            curr,jumps,is_b=queue.pop(0)\\n            if curr in vis or not 0<=curr<=lim: continue\\n            vis.add(curr)\\n            if curr==0: return jumps\\n            if is_b: queue.append((curr+b,jumps+1,False))\\n            queue.append((curr-a,jumps+1,True))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083263,
                "title": "c-bfs-with-brief-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        int big = 6005;\\n        vector<vector<int>> dp(big, vector<int>(2, -1)); // Keep track of visited positions.\\n        \\n        for(auto f : forbidden) {\\n            dp[f][0] = -2;\\n            dp[f][1] = -2;\\n        }\\n        \\n        // vector {position, jumpBack, step}.\\n        queue<vector<int>> q;\\n        q.push({0, 0, 0});\\n        \\n        while(!q.empty()) {\\n            auto v = q.front();\\n            q.pop();\\n            \\n            if(v[0] == x) return v[2];\\n            \\n            // visited, including forbidden.\\n            if(dp[v[0]][v[1]] != -1) {\\n                continue;\\n            } \\n            \\n            dp[v[0]][v[1]] = 1; // Mark as visited.\\n            \\n            if(v[0] + a < big) q.push({v[0]+ a, 0, v[2] + 1});\\n            if(v[1] == 0 && v[0] - b >= 0) q.push({v[0] - b, 1, v[2] + 1});\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        int big = 6005;\\n        vector<vector<int>> dp(big, vector<int>(2, -1)); // Keep track of visited positions.\\n        \\n        for(auto f : forbidden) {\\n            dp[f][0] = -2;\\n            dp[f][1] = -2;\\n        }\\n        \\n        // vector {position, jumpBack, step}.\\n        queue<vector<int>> q;\\n        q.push({0, 0, 0});\\n        \\n        while(!q.empty()) {\\n            auto v = q.front();\\n            q.pop();\\n            \\n            if(v[0] == x) return v[2];\\n            \\n            // visited, including forbidden.\\n            if(dp[v[0]][v[1]] != -1) {\\n                continue;\\n            } \\n            \\n            dp[v[0]][v[1]] = 1; // Mark as visited.\\n            \\n            if(v[0] + a < big) q.push({v[0]+ a, 0, v[2] + 1});\\n            if(v[1] == 0 && v[0] - b >= 0) q.push({v[0] - b, 1, v[2] + 1});\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052778,
                "title": "python-easy-understanding-bfs-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        visited = set()\\n        limit = max(x, max(forbidden)) + a + b\\n        queue = [(0, 0, False)]\\n        while queue:\\n            pos, step, back = queue.pop(0)\\n            if pos > limit or pos < 0 or pos in forbidden or (pos, back) in visited:\\n                continue\\n            if pos == x:\\n                return step\\n            queue.append((pos+a, step+1, False))\\n            if not back: queue.append((pos-b, step+1, True))\\n            visited.add((pos, back))\\n        return -1\\n```\\nA traditional BFS solution by using queue. Each **element** in the queue contains:\\n* `pos`: The current position of the bug;\\n* `step`: The total step;\\n* `back`: Check if the previous step is jumping backward.\\n\\nThe **terminal conditions** is declared in the question:\\n1. `pos < 0`: The bug cannot jump to the negative position;\\n2. `pos in forbidden`: The bug cannot jump to the forbidden position;\\n3. `(pos, back) in visited`: To prevent the bug repeatly jumps between the previous and current position, it is noticeable that jump forward or backward to the position is totally different;\\n4. `pos > limit`: As `0 <= x <= 2000`, the maximum index of position will not beyond `limit`, which `limit = max(x, max(forbidden)) + a + b`.\\n\\nThe **recurrence**:\\n1. Jump forward: `queue.append((pos+a, step+1, False))`;\\n2. Jump backward: `queue.append((pos-b, step+1, True))` if the previoius step jumped forward (`if not back`).",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        visited = set()\\n        limit = max(x, max(forbidden)) + a + b\\n        queue = [(0, 0, False)]\\n        while queue:\\n            pos, step, back = queue.pop(0)\\n            if pos > limit or pos < 0 or pos in forbidden or (pos, back) in visited:\\n                continue\\n            if pos == x:\\n                return step\\n            queue.append((pos+a, step+1, False))\\n            if not back: queue.append((pos-b, step+1, True))\\n            visited.add((pos, back))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972220,
                "title": "python-recursive-approach-with-comments",
                "content": "```\\nimport functools \\n\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        denied = {}\\n        for i in forbidden:\\n            denied[i]=True\\n        visited = {}\\n        \\n        @lru_cache(None)\\n        def solve(position, is_back_jump_again):\\n            if (position, is_back_jump_again) in visited:   # If the condition is already visited.\\n                return float(\\'inf\\')\\n            else:\\n                visited[ (position, is_back_jump_again)] = True   # Else add it to visited list\\n            \\n            if position == x:   # Reached the required posiiton\\n                return 0\\n            \\n            if position in denied or position > 5998:  \\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tIf landed in the denied area or went too far from destination\\n\\t\\t\\t\\t\"\"\"\\n                return float(\\'inf\\')\\n            \\n            if is_back_jump_again or position-b<0: # If went in negative zone then move ahead only\\n                return 1 + solve(position+a, False)\\n            \\n            return 1 + min(solve(position+a, False), solve(position-b, True))\\n        \\n        ans = solve(0, False)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools \\n\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        denied = {}\\n        for i in forbidden:\\n            denied[i]=True\\n        visited = {}\\n        \\n        @lru_cache(None)\\n        def solve(position, is_back_jump_again):\\n            if (position, is_back_jump_again) in visited:   # If the condition is already visited.\\n                return float(\\'inf\\')\\n            else:\\n                visited[ (position, is_back_jump_again)] = True   # Else add it to visited list\\n            \\n            if position == x:   # Reached the required posiiton\\n                return 0\\n            \\n            if position in denied or position > 5998:  \\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tIf landed in the denied area or went too far from destination\\n\\t\\t\\t\\t\"\"\"\\n                return float(\\'inf\\')\\n            \\n            if is_back_jump_again or position-b<0: # If went in negative zone then move ahead only\\n                return 1 + solve(position+a, False)\\n            \\n            return 1 + min(solve(position+a, False), solve(position-b, True))\\n        \\n        ans = solve(0, False)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967434,
                "title": "the-simplest-bfs-ever-don-t-mark-backward-nodes-as-visited",
                "content": "Only important point is to not mark nodes where we have jumped backward as visited! Because then we could not go from that point backward once more. And we maybe could come to that point from forward direction and then go back. \\n```\\nclass Position {\\n\\tint x;\\n\\tint step;\\n\\tboolean backward;\\n\\t\\n\\tpublic Position(int x, int step, boolean backward) {\\n\\t\\tthis.x = x;\\n\\t\\tthis.step = step;\\n\\t\\tthis.backward = backward;\\n\\t}\\n}\\n\\npublic class Solution {\\n\\n\\tpublic int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        \\n\\t\\tif (x == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\tSet<Integer> forbiddenSet = new HashSet<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < forbidden.length; i++) {\\n\\t\\t\\tforbiddenSet.add(forbidden[i]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tSet<Integer> visited = new HashSet<>();\\n\\t\\t\\n\\t\\tvisited.add(0);\\n\\t\\t\\n\\t\\tQueue<Position> q = new LinkedList<>();\\n\\t\\t\\n\\t\\tif (!forbiddenSet.contains(a)) {\\n\\t\\t\\tq.add(new Position(a, 1, false));\\n\\t\\t}\\n\\t\\t\\n\\t\\twhile (!q.isEmpty()) {\\n\\t\\t\\t\\n\\t\\t\\tPosition position = q.remove();\\n\\t\\t\\t\\n\\t\\t\\tif (position.x == x) {\\n\\t\\t\\t\\treturn position.step;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (position.x + a <= 6000 && !forbiddenSet.contains(position.x + a)\\n\\t\\t\\t\\t\\t&& !visited.contains(position.x + a)) {\\n\\t\\t\\t\\tq.add(new Position(position.x + a, position.step + 1, false));\\n\\t\\t\\t\\tvisited.add(position.x + a);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (position.x - b > 0 && !position.backward && !forbiddenSet.contains(position.x - b)\\n\\t\\t\\t\\t\\t&& !visited.contains(position.x - b)) {\\n\\t\\t\\t\\tq.add(new Position(position.x - b, position.step + 1, true));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\tpublic int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        \\n\\t\\tif (x == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 940613,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        F = set(forbidden)\\n        visited = set()\\n        @lru_cache(None)\\n        def dfs(i,isPrevBack):\\n            if (i,isPrevBack) in visited: return math.inf\\n            else: visited.add((i,isPrevBack))\\n            if i == x: return 0\\n            if i in F or i > 6000: return math.inf\\n            if isPrevBack or i - b <= 0: return 1 + dfs(i + a, False)\\n            return 1 + min(dfs(i + a, False), dfs(i - b, True))\\n        ans = dfs(0,False)\\n        return ans if ans < math.inf else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        F = set(forbidden)\\n        visited = set()\\n        @lru_cache(None)\\n        def dfs(i,isPrevBack):\\n            if (i,isPrevBack) in visited: return math.inf\\n            else: visited.add((i,isPrevBack))\\n            if i == x: return 0\\n            if i in F or i > 6000: return math.inf\\n            if isPrevBack or i - b <= 0: return 1 + dfs(i + a, False)\\n            return 1 + min(dfs(i + a, False), dfs(i - b, True))\\n        ans = dfs(0,False)\\n        return ans if ans < math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936219,
                "title": "c-keeping-both-current-and-isback-in-state",
                "content": "```csharp\\npublic int MinimumJumps(int[] forbidden, int a, int b, int x)\\n{\\n\\tHashSet<int> blocked = new HashSet<int>(forbidden);\\n\\tHashSet<(int, bool)> visited = new HashSet<(int, bool)>();\\n\\tQueue<(int, bool)> q = new Queue<(int, bool)>();\\n\\n\\tq.Enqueue((0, false));\\n\\tvisited.Add((0, false));\\n\\tint result = 0;\\n\\tint maxForbidden = forbidden.Max();\\n\\tint max = Math.Max(x, maxForbidden) + 2 * a + b + 1;\\n\\n\\twhile(q.Count > 0)\\n\\t{\\n\\t\\tint count = q.Count;\\n\\t\\tfor(int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\t(int current, bool isBack) = q.Dequeue();                \\n\\t\\t\\tif(current == x)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint forward = current + a;\\n\\t\\t\\tint backward = current - b;\\n\\n\\t\\t\\tif(forward > 0 && forward < max && !blocked.Contains(forward) && !visited.Contains((forward, false)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited.Add((forward, false));\\n\\t\\t\\t\\tq.Enqueue((forward, false));\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(!isBack && backward > 0 && backward < max && !blocked.Contains(backward) && !visited.Contains((backward, true)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited.Add((backward, true));\\n\\t\\t\\t\\tq.Enqueue((backward, true));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tresult++;\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinimumJumps(int[] forbidden, int a, int b, int x)\\n{\\n\\tHashSet<int> blocked = new HashSet<int>(forbidden);\\n\\tHashSet<(int, bool)> visited = new HashSet<(int, bool)>();\\n\\tQueue<(int, bool)> q = new Queue<(int, bool)>();\\n\\n\\tq.Enqueue((0, false));\\n\\tvisited.Add((0, false));\\n\\tint result = 0;\\n\\tint maxForbidden = forbidden.Max();\\n\\tint max = Math.Max(x, maxForbidden) + 2 * a + b + 1;\\n\\n\\twhile(q.Count > 0)\\n\\t{\\n\\t\\tint count = q.Count;\\n\\t\\tfor(int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\t(int current, bool isBack) = q.Dequeue();                \\n\\t\\t\\tif(current == x)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint forward = current + a;\\n\\t\\t\\tint backward = current - b;\\n\\n\\t\\t\\tif(forward > 0 && forward < max && !blocked.Contains(forward) && !visited.Contains((forward, false)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited.Add((forward, false));\\n\\t\\t\\t\\tq.Enqueue((forward, false));\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(!isBack && backward > 0 && backward < max && !blocked.Contains(backward) && !visited.Contains((backward, true)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited.Add((backward, true));\\n\\t\\t\\t\\tq.Enqueue((backward, true));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tresult++;\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935605,
                "title": "python-bfs-faster-than-100",
                "content": "In the first I had the same issue with many people: can\\'t past the test case:\\n[162,118,178,152,167,100,40,74,199,186,26,73,200,127,30,124,193,84,184,36,103,149,153,9,54,154,133,95,45,198,79,157,64,122,59,71,48,177,82,35,14,176,16,108,111,6,168,31,134,164,136,72,98]\\n29\\n98\\n80\\n\\nThen I updated the code, key is about the visited set, if a position is in visited, we can\\'t ban it, because maybe we can still visit it in another direction. What we need to do is to make sure that we do not visit it in the same way as last time (forward or backward)\\n```\\nfrom queue import Queue\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x==0: return 0\\n        forbidden=set(forbidden)\\n        visited=set([(0,0)])\\n        Q=Queue()\\n        \\n        #record prevous jump, 1 means forward, -1 means backward\\n        Q.put((0,0))\\n        step=0\\n        \\n        while Q.qsize():\\n            n=Q.qsize()\\n            for _ in range(n):\\n                pos,prev=Q.get()\\n                if pos==x: return step\\n                visited.add((pos,prev))\\n\\n                forward,backward=pos+a,pos-b\\n                if (forward,1) not in visited and forward not in forbidden and forward<=max(forbidden) + 2*b:\\n                    Q.put((forward,1))\\n                    visited.add((forward,1))\\n                \\n                if (backward,-1) not in visited and backward not in forbidden and prev!=-1 and backward>=0:\\n                    Q.put((backward,-1))\\n                    visited.add((backward,-1))\\n            step+=1\\n        return -1\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom queue import Queue\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x==0: return 0\\n        forbidden=set(forbidden)\\n        visited=set([(0,0)])\\n        Q=Queue()\\n        \\n        #record prevous jump, 1 means forward, -1 means backward\\n        Q.put((0,0))\\n        step=0\\n        \\n        while Q.qsize():\\n            n=Q.qsize()\\n            for _ in range(n):\\n                pos,prev=Q.get()\\n                if pos==x: return step\\n                visited.add((pos,prev))\\n\\n                forward,backward=pos+a,pos-b\\n                if (forward,1) not in visited and forward not in forbidden and forward<=max(forbidden) + 2*b:\\n                    Q.put((forward,1))\\n                    visited.add((forward,1))\\n                \\n                if (backward,-1) not in visited and backward not in forbidden and prev!=-1 and backward>=0:\\n                    Q.put((backward,-1))\\n                    visited.add((backward,-1))\\n            step+=1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935461,
                "title": "c-dp-solution",
                "content": "```\\nconst int inf = 1e6;\\nint cache[6005][2];\\nint a,b,x;\\nint check_forbidden[6005];\\nint dp(int cur,int f)\\n{\\n    // f - > previously how many consecutive backward operation perform.\\n    //cur -> cur position of bug.   \\n   // stop condition of Memoization\\n    if(cur < 0 or cur > 6000 or check_forbidden[cur] or f >= 2) \\n        return inf;\\n    if(cur == x)\\n        return 0;\\n    int &ans = cache[cur][f];\\n    if(ans != -1)\\n        return ans;\\n    // forward operation\\n    ans = dp(cur+a,0) + 1;\\n    // backward operation \\n    ans = min(ans , dp(cur-b , f+1)+1);\\n \\xA0 \\xA0return ans;\\n\\t\\n}\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a1, int b1, int x1) {\\n        a = a1,b = b1,x = x1;\\n        // initialize  check_forbidden array by zero      \\n        memset(check_forbidden,0,sizeof(check_forbidden));\\n        // make the position in check_forbidden array 1 where bug cannot jump.     \\n        for(auto it : forbidden)\\n            check_forbidden[it] = 1;\\n        // initialize  cache array by -1 \\n        memset(cache,-1,sizeof(cache));\\n        int ans = dp(0,0);\\n        // means no possible sequence found         \\n        if(ans >= inf)\\n            ans = -1;\\n        return ans;\\n    }\\n};\\n```\\n***feel free to ask if having any doubt***",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nconst int inf = 1e6;\\nint cache[6005][2];\\nint a,b,x;\\nint check_forbidden[6005];\\nint dp(int cur,int f)\\n{\\n    // f - > previously how many consecutive backward operation perform.\\n    //cur -> cur position of bug.   \\n   // stop condition of Memoization\\n    if(cur < 0 or cur > 6000 or check_forbidden[cur] or f >= 2) \\n        return inf;\\n    if(cur == x)\\n        return 0;\\n    int &ans = cache[cur][f];\\n    if(ans != -1)\\n        return ans;\\n    // forward operation\\n    ans = dp(cur+a,0) + 1;\\n    // backward operation \\n    ans = min(ans , dp(cur-b , f+1)+1);\\n \\xA0 \\xA0return ans;\\n\\t\\n}\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a1, int b1, int x1) {\\n        a = a1,b = b1,x = x1;\\n        // initialize  check_forbidden array by zero      \\n        memset(check_forbidden,0,sizeof(check_forbidden));\\n        // make the position in check_forbidden array 1 where bug cannot jump.     \\n        for(auto it : forbidden)\\n            check_forbidden[it] = 1;\\n        // initialize  cache array by -1 \\n        memset(cache,-1,sizeof(cache));\\n        int ans = dp(0,0);\\n        // means no possible sequence found         \\n        if(ans >= inf)\\n            ans = -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824089,
                "title": "recursive-solution-memoisation-7-lines-of-code-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> blocked =  Arrays.stream(forbidden).boxed().collect(Collectors.toSet());\\n        final int MAX_POSITION = 6001, BACKWARD = 2;\\n        long[][] memo = new long[MAX_POSITION][BACKWARD];\\n        for(long[] row: memo) Arrays.fill(row, -1);\\n        long minJumps = getMinJumps(0, 0, a, b, x, blocked, memo);\\n        return minJumps >= Integer.MAX_VALUE ? - 1 : (int) minJumps;\\n    }\\n\\n    private long getMinJumps(int pos, int back, int f, int b, int home, Set<Integer> blocked, long[][] memo) {\\n        if(pos == home) return 0;\\n        if(pos < 0 || pos > 6000 || blocked.contains(pos) || back >= 2) return Integer.MAX_VALUE;\\n        if(memo[pos][back] != -1) return memo[pos][back];\\n        memo[pos][back] = 1L + getMinJumps(pos + f, 0, f, b, home, blocked, memo);\\n        if(back == 0) memo[pos][back] = Math.min(memo[pos][back], 1L + getMinJumps(pos - b, 1, f, b, home, blocked, memo));\\n        return memo[pos][back];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> blocked =  Arrays.stream(forbidden).boxed().collect(Collectors.toSet());\\n        final int MAX_POSITION = 6001, BACKWARD = 2;\\n        long[][] memo = new long[MAX_POSITION][BACKWARD];\\n        for(long[] row: memo) Arrays.fill(row, -1);\\n        long minJumps = getMinJumps(0, 0, a, b, x, blocked, memo);\\n        return minJumps >= Integer.MAX_VALUE ? - 1 : (int) minJumps;\\n    }\\n\\n    private long getMinJumps(int pos, int back, int f, int b, int home, Set<Integer> blocked, long[][] memo) {\\n        if(pos == home) return 0;\\n        if(pos < 0 || pos > 6000 || blocked.contains(pos) || back >= 2) return Integer.MAX_VALUE;\\n        if(memo[pos][back] != -1) return memo[pos][back];\\n        memo[pos][back] = 1L + getMinJumps(pos + f, 0, f, b, home, blocked, memo);\\n        if(back == 0) memo[pos][back] = Math.min(memo[pos][back], 1L + getMinJumps(pos - b, 1, f, b, home, blocked, memo));\\n        return memo[pos][back];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548500,
                "title": "simplest-c-well-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& f, int a, int b, int x) \\n    {\\n        int res = 0; \\n        unordered_set<int> s(f.begin(),f.end());\\n        queue<pair<int,pair<int,int>>> q; // {coordinate,{jump,prev_state}}\\n        q.push({0,{0,0}}); // 0 means no backward jump was taken you can go backward\\n        s.insert(0);// we need not to visit 0 again so we put it in set\\n        \\n        \\n        while(q.size() )\\n        {\\n            int c=q.front().first;\\n            //cout<<c<<\" \";\\n            int jump = q.front().second.first;\\n            int prev = q.front().second.second;\\n            q.pop();\\n            if(c==x)\\n            return jump;\\n            int back =  c - b ; \\n            int forward =  c + a;\\n            if(prev==0 && back>0 && s.find(back)==s.end())\\n            {\\n                q.push({back,{jump+1,1}});// we will change prev to 1 so in next step we can\\'t go backward twice\\n                s.insert(back); // marks as visited\\n            }\\n            if(forward<=10000 && s.find(forward)==s.end())\\n            {\\n                q.push({forward,{jump+1,0}});// we will set prev to 0 so we can take backward step in next step \\n               s.insert(forward); // marks as visited\\n            }\\n\\n        }\\n\\n        return -1;\\n\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& f, int a, int b, int x) \\n    {\\n        int res = 0; \\n        unordered_set<int> s(f.begin(),f.end());\\n        queue<pair<int,pair<int,int>>> q; // {coordinate,{jump,prev_state}}\\n        q.push({0,{0,0}}); // 0 means no backward jump was taken you can go backward\\n        s.insert(0);// we need not to visit 0 again so we put it in set\\n        \\n        \\n        while(q.size() )\\n        {\\n            int c=q.front().first;\\n            //cout<<c<<\" \";\\n            int jump = q.front().second.first;\\n            int prev = q.front().second.second;\\n            q.pop();\\n            if(c==x)\\n            return jump;\\n            int back =  c - b ; \\n            int forward =  c + a;\\n            if(prev==0 && back>0 && s.find(back)==s.end())\\n            {\\n                q.push({back,{jump+1,1}});// we will change prev to 1 so in next step we can\\'t go backward twice\\n                s.insert(back); // marks as visited\\n            }\\n            if(forward<=10000 && s.find(forward)==s.end())\\n            {\\n                q.push({forward,{jump+1,0}});// we will set prev to 0 so we can take backward step in next step \\n               s.insert(forward); // marks as visited\\n            }\\n\\n        }\\n\\n        return -1;\\n\\n   }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3037209,
                "title": "recursive-solution-memoization-beats-97-69-runtime-97-85-memory",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  Here to solve this problem using Recursive \\n  First we start Recurisve function with start = 0\\n  We have to two moves :\\n    1. go from start to start + forwardJumb\\n    2. go from start to start - backwardJumb\\n But here we make boolean called isBack to make sure we do not \\n Make the second move twice , and check the current state not less than zero or greater than greatest move = 7000 and this \\nstate not forbidden\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*3)\\n- Space complexity\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(N*3)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isForbidden[7001];\\n    int memo[7001][2];\\n    int forwardJumb , backwardJumb , target;\\n    int solve(int start , bool isBack){\\n        if(start >7000 ||start <0 ||isForbidden[start])\\n            return 1e9;\\n       if(start ==target)\\n           return 0 ; \\n     int &ret =memo[start][isBack];\\n      if(ret!=-1){\\n          return ret;\\n      }\\n    int op1 = 1e9 , op2 = 1e9;\\n    ret = 1e9;\\n    if(!isBack)\\n    op1 = solve(start - backwardJumb, true) + 1;\\n    op2 = solve(start + forwardJumb , false) + 1;\\n    return ret =min(op1,op2) ; \\n\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i = 0 ;i<forbidden.size();i++){\\n            isForbidden[forbidden[i]] = true;\\n        }\\n        for(int i = 0 ;i<7001;i++){\\n           memo[i][0] = memo[i][1] = -1;\\n        }\\n        forwardJumb = a;\\n        backwardJumb = b;\\n        target = x;\\n        int val = solve(0,false);\\n        return val >=1e9 ?-1:val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isForbidden[7001];\\n    int memo[7001][2];\\n    int forwardJumb , backwardJumb , target;\\n    int solve(int start , bool isBack){\\n        if(start >7000 ||start <0 ||isForbidden[start])\\n            return 1e9;\\n       if(start ==target)\\n           return 0 ; \\n     int &ret =memo[start][isBack];\\n      if(ret!=-1){\\n          return ret;\\n      }\\n    int op1 = 1e9 , op2 = 1e9;\\n    ret = 1e9;\\n    if(!isBack)\\n    op1 = solve(start - backwardJumb, true) + 1;\\n    op2 = solve(start + forwardJumb , false) + 1;\\n    return ret =min(op1,op2) ; \\n\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i = 0 ;i<forbidden.size();i++){\\n            isForbidden[forbidden[i]] = true;\\n        }\\n        for(int i = 0 ;i<7001;i++){\\n           memo[i][0] = memo[i][1] = -1;\\n        }\\n        forwardJumb = a;\\n        backwardJumb = b;\\n        target = x;\\n        int val = solve(0,false);\\n        return val >=1e9 ?-1:val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829346,
                "title": "java-bfs-solution-with-line-by-line-explanation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Node{\\n        int val;\\n        boolean isBackward;\\n        public Node(int val,boolean isBackward){\\n            this.val = val;\\n            this.isBackward = isBackward;\\n        }\\n    } // we create a node to keep track of current processed element and isBackward boolean variable to keep track if current processed element was from a backward traversal \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> visited = new HashSet<>();\\n        for(int seen : forbidden){\\n            visited.add(seen);\\n        }// we are not allowed to process elements in forbidden , so it behaves similar to visited elements \\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(new Node(0,false));\\n        visited.add(0);\\n        int level = 0;\\n        int limit = 6000;\\n        // limit should be the maximum limit a node value can go\\n        // 6000 because \\n        // 2000 is the max value of x acc to constraint\\n        // 2000 is the max value of a acc to constraint\\n        // 2000 is the max value of b acc to constraint\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Node curr = q.remove();\\n                if(curr.val == x){\\n                    return level;\\n                }// if current value is target , we return \\n                // for backward processing we check the current processed node has been from a backward proceeded node by checking isBackward , and we check if its non negative and if not already visisted we add in queue\\n                if(!curr.isBackward){\\n                    int nextBackPos = curr.val - b;\\n                    if(nextBackPos > 0 && !visited.contains(nextBackPos)){\\n                        q.offer(new Node(nextBackPos,true));\\n                        visited.add(nextBackPos);\\n                    }\\n                } \\n                // for forward processing , we check if not visisted and we check if its withtin limits , bcos if it exceeds the limit it will cause TLE , the program never ends , so define a limit and if conditions satisfies we add in queue \\n                int nextForwardPos = curr.val + a;\\n                if(nextForwardPos < limit && !visited.contains(nextForwardPos)){\\n                    q.offer(new Node(nextForwardPos,false));\\n                    visited.add(nextForwardPos);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Node{\\n        int val;\\n        boolean isBackward;\\n        public Node(int val,boolean isBackward){\\n            this.val = val;\\n            this.isBackward = isBackward;\\n        }\\n    } // we create a node to keep track of current processed element and isBackward boolean variable to keep track if current processed element was from a backward traversal \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> visited = new HashSet<>();\\n        for(int seen : forbidden){\\n            visited.add(seen);\\n        }// we are not allowed to process elements in forbidden , so it behaves similar to visited elements \\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(new Node(0,false));\\n        visited.add(0);\\n        int level = 0;\\n        int limit = 6000;\\n        // limit should be the maximum limit a node value can go\\n        // 6000 because \\n        // 2000 is the max value of x acc to constraint\\n        // 2000 is the max value of a acc to constraint\\n        // 2000 is the max value of b acc to constraint\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Node curr = q.remove();\\n                if(curr.val == x){\\n                    return level;\\n                }// if current value is target , we return \\n                // for backward processing we check the current processed node has been from a backward proceeded node by checking isBackward , and we check if its non negative and if not already visisted we add in queue\\n                if(!curr.isBackward){\\n                    int nextBackPos = curr.val - b;\\n                    if(nextBackPos > 0 && !visited.contains(nextBackPos)){\\n                        q.offer(new Node(nextBackPos,true));\\n                        visited.add(nextBackPos);\\n                    }\\n                } \\n                // for forward processing , we check if not visisted and we check if its withtin limits , bcos if it exceeds the limit it will cause TLE , the program never ends , so define a limit and if conditions satisfies we add in queue \\n                int nextForwardPos = curr.val + a;\\n                if(nextForwardPos < limit && !visited.contains(nextForwardPos)){\\n                    q.offer(new Node(nextForwardPos,false));\\n                    visited.add(nextForwardPos);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819352,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6002, vector<int> (2,0));\\n        if(x == 0) return 0;\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            dp[num][0]++;\\n            dp[num][1]++;\\n        }\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({0,1});\\n        if(dp[x][1]) return -1;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> tp = q.front();\\n                q.pop();\\n                int val = tp.first;\\n                int ab = tp.second;\\n                if(val == x) return ans;\\n                if(ab)\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                    tmp = val - b;\\n                    if(tmp >= 0 && !dp[tmp][0])\\n                    {\\n                        q.push({tmp, 0});\\n                        dp[tmp][0]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6002, vector<int> (2,0));\\n        if(x == 0) return 0;\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            dp[num][0]++;\\n            dp[num][1]++;\\n        }\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({0,1});\\n        if(dp[x][1]) return -1;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> tp = q.front();\\n                q.pop();\\n                int val = tp.first;\\n                int ab = tp.second;\\n                if(val == x) return ans;\\n                if(ab)\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                    tmp = val - b;\\n                    if(tmp >= 0 && !dp[tmp][0])\\n                    {\\n                        q.push({tmp, 0});\\n                        dp[tmp][0]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760953,
                "title": "java-bfs-easy-to-read-code",
                "content": "```\\nclass Step {\\n    int xValue, direction, stepsTaken;\\n    \\n    public Step(int xValue, int direction, int stepsTaken) {\\n        this.xValue = xValue;\\n        this.direction = direction;\\n        this.stepsTaken = stepsTaken;\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n        return (this.xValue + 1) * direction;\\n    }\\n    \\n    @Override\\n    public boolean equals(Object o) {\\n        Step that = (Step) o;\\n        return this.xValue == that.xValue && this.direction == that.direction;\\n    }\\n    \\n}\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Step> seen = new HashSet<>();\\n        for (int f : forbidden) {\\n            seen.add(new Step(f, 1, 0));\\n            seen.add(new Step(f, -1, 0));\\n        }\\n        Queue<Step> q = new LinkedList<>();\\n        q.add(new Step(0, 1, 0));\\n        while (!q.isEmpty()) {\\n            Step currStep = q.remove();\\n            if (currStep.xValue == x) return currStep.stepsTaken;\\n            //try moving forward\\n            // the reason why 6000 is becase: target x is max 2000, and a max 2000, \\n            // that means, x + a with max value to x + a + a \\n            if (currStep.xValue + a <= 6000) {\\n                Step nextStep = new Step(currStep.xValue + a, 1, currStep.stepsTaken + 1);\\n                if (!seen.contains(nextStep)) {\\n                    q.add(nextStep);\\n                    seen.add(nextStep);\\n                }\\n            }\\n            //try moving backward\\n            if (currStep.direction != -1 && currStep.xValue - b > 0) {\\n                Step nextStep = new Step(currStep.xValue - b, -1, currStep.stepsTaken + 1);\\n                if (!seen.contains(nextStep)) {\\n                    q.add(nextStep);\\n                    seen.add(nextStep);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Step {\\n    int xValue, direction, stepsTaken;\\n    \\n    public Step(int xValue, int direction, int stepsTaken) {\\n        this.xValue = xValue;\\n        this.direction = direction;\\n        this.stepsTaken = stepsTaken;\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n        return (this.xValue + 1) * direction;\\n    }\\n    \\n    @Override\\n    public boolean equals(Object o) {\\n        Step that = (Step) o;\\n        return this.xValue == that.xValue && this.direction == that.direction;\\n    }\\n    \\n}\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Step> seen = new HashSet<>();\\n        for (int f : forbidden) {\\n            seen.add(new Step(f, 1, 0));\\n            seen.add(new Step(f, -1, 0));\\n        }\\n        Queue<Step> q = new LinkedList<>();\\n        q.add(new Step(0, 1, 0));\\n        while (!q.isEmpty()) {\\n            Step currStep = q.remove();\\n            if (currStep.xValue == x) return currStep.stepsTaken;\\n            //try moving forward\\n            // the reason why 6000 is becase: target x is max 2000, and a max 2000, \\n            // that means, x + a with max value to x + a + a \\n            if (currStep.xValue + a <= 6000) {\\n                Step nextStep = new Step(currStep.xValue + a, 1, currStep.stepsTaken + 1);\\n                if (!seen.contains(nextStep)) {\\n                    q.add(nextStep);\\n                    seen.add(nextStep);\\n                }\\n            }\\n            //try moving backward\\n            if (currStep.direction != -1 && currStep.xValue - b > 0) {\\n                Step nextStep = new Step(currStep.xValue - b, -1, currStep.stepsTaken + 1);\\n                if (!seen.contains(nextStep)) {\\n                    q.add(nextStep);\\n                    seen.add(nextStep);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575572,
                "title": "c-simple-bfs",
                "content": "* vis[0][i] = 1= i is visited from left side\\n * vis[1][i] = 1= i is visited from the right side\\n * queue = {curr index, bool check}\\n * the bool variable tells us whether we can have a backward jump at this stage or not\\n * store the forbidden coordinates in a set\\n * push 0 into the queue\\n * start traversing, every time we have two options either move forward or backward\\n * check if that is possible or not\\n * if it is then add that one into the queue\\n * if at anytime we arrive at x then return the ans\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    typedef pair<int, bool> pi;\\n    int minimumJumps(vector<int> &forbidden, int a, int b, int x)\\n    {\\n        set<int> st(forbidden.begin(), forbidden.end());\\n        vector<vector<int>> vis(2, vector<int>(10000, 0));\\n        vis[0][0] = 1;\\n        vis[1][0] = 1;\\n        queue<pi> q;\\n        q.push({0, true});\\n        int ans = 0;\\n        while (!q.empty())\\n        {\\n            int n = q.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                int curr = q.front().first;\\n                bool canJumpBackward = q.front().second;\\n                q.pop();\\n                if (curr == x)\\n                    return ans;\\n                int p1 = curr + a;\\n                int p2 = curr - b;\\n                if (p1 < 10000 && vis[0][p1] == 0 && st.find(p1) == st.end())\\n                {\\n                    q.push({p1, true});\\n                    vis[0][p1] = 1;\\n                }\\n                if (p2 >= 0 && vis[1][p2] == 0 && st.find(p2) == st.end() && canJumpBackward == true)\\n                {\\n                    q.push({p2, false});\\n                    vis[1][p2] = 1;\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    typedef pair<int, bool> pi;\\n    int minimumJumps(vector<int> &forbidden, int a, int b, int x)\\n    {\\n        set<int> st(forbidden.begin(), forbidden.end());\\n        vector<vector<int>> vis(2, vector<int>(10000, 0));\\n        vis[0][0] = 1;\\n        vis[1][0] = 1;\\n        queue<pi> q;\\n        q.push({0, true});\\n        int ans = 0;\\n        while (!q.empty())\\n        {\\n            int n = q.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                int curr = q.front().first;\\n                bool canJumpBackward = q.front().second;\\n                q.pop();\\n                if (curr == x)\\n                    return ans;\\n                int p1 = curr + a;\\n                int p2 = curr - b;\\n                if (p1 < 10000 && vis[0][p1] == 0 && st.find(p1) == st.end())\\n                {\\n                    q.push({p1, true});\\n                    vis[0][p1] = 1;\\n                }\\n                if (p2 >= 0 && vis[1][p2] == 0 && st.find(p2) == st.end() && canJumpBackward == true)\\n                {\\n                    q.push({p2, false});\\n                    vis[1][p2] = 1;\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550370,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] nums, int a, int b, int x) {\\n        \\n        \\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n        \\n        HashMap<Integer,Integer> dp=new HashMap<>();\\n        HashSet<Integer> visited=new HashSet<>();\\n        boolean back=false;\\n        int res= Sol(set,a,b,0,x,back,dp,visited);\\n        \\n        if(res==Integer.MAX_VALUE) return -1;\\n        return res;\\n    }\\n    \\n    public int Sol(HashSet<Integer> set,int a,int b,int pos,int x,boolean back,HashMap<Integer,Integer>               dp,HashSet<Integer> vis){\\n         \\n         int res=Integer.MAX_VALUE;\\n        if(pos==x){\\n            return 0;\\n        }\\n        if(dp.containsKey(pos)) return dp.get(pos);\\n        \\n        if(pos>6000 || set.contains(pos) || pos<0 || vis.contains(pos) ) return res;\\n        \\n        vis.add(pos);\\n        int ans=res;\\n            if(!back)\\n            ans= Sol(set,a,b,pos-b,x,true,dp,vis);\\n           // else\\n            ans= Math.min(ans,Sol(set,a,b,pos+a,x,false,dp,vis));\\n        \\n         if(ans!=Integer.MAX_VALUE){\\n                res=Math.min(res,1+ans);\\n            }\\n        vis.remove(pos);\\n        dp.put(pos,res);\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] nums, int a, int b, int x) {\\n        \\n        \\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n        \\n        HashMap<Integer,Integer> dp=new HashMap<>();\\n        HashSet<Integer> visited=new HashSet<>();\\n        boolean back=false;\\n        int res= Sol(set,a,b,0,x,back,dp,visited);\\n        \\n        if(res==Integer.MAX_VALUE) return -1;\\n        return res;\\n    }\\n    \\n    public int Sol(HashSet<Integer> set,int a,int b,int pos,int x,boolean back,HashMap<Integer,Integer>               dp,HashSet<Integer> vis){\\n         \\n         int res=Integer.MAX_VALUE;\\n        if(pos==x){\\n            return 0;\\n        }\\n        if(dp.containsKey(pos)) return dp.get(pos);\\n        \\n        if(pos>6000 || set.contains(pos) || pos<0 || vis.contains(pos) ) return res;\\n        \\n        vis.add(pos);\\n        int ans=res;\\n            if(!back)\\n            ans= Sol(set,a,b,pos-b,x,true,dp,vis);\\n           // else\\n            ans= Math.min(ans,Sol(set,a,b,pos+a,x,false,dp,vis));\\n        \\n         if(ans!=Integer.MAX_VALUE){\\n                res=Math.min(res,1+ans);\\n            }\\n        vis.remove(pos);\\n        dp.put(pos,res);\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482322,
                "title": "c-clean-bidirectional-bfs-code-with-comments",
                "content": "```\\nclass Solution {\\n    //1 forward\\n    //0 backwards\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<pair<int,bool>> s; // we need a state of previous position also\\n        //we are using this set as our dp where int is curresponding to \"Position\" and bool value represents weather the last jump was in forward or backwards direction!\\n        \\n        for(auto &it :forbidden)\\n        {\\n             s.insert({it,false});\\n             s.insert({it,true});\\n        }\\n                            //BFS Traversal\\n        queue<vector<int>> q;\\n        q.push({0,1,0});\\n        s.insert({0,0});\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int currPos = q.front()[0];\\n                int prev = q.front()[1];\\n                int jTill = q.front()[2];\\n                if(currPos == x) return jTill;\\n                q.pop();\\n                \\n                //we can jump forward.... irrespective of previous jump\\n                int fPos = currPos + a;\\n                \\n                if(fPos < 6001 && s.find({fPos,true}) == s.end())\\n                {\\n                    q.push({fPos,1,jTill+1});\\n                }\\n                \\n                //once we encounter a perticular state we store it for future\\n                s.insert({fPos,true});\\n                \\n                //we can only jump backwards if we have made the previous jump in forward direction\\n                if(prev == 1)\\n                {\\n                    int bPos = currPos - b;\\n                    if(bPos < 6001 && bPos>=0 && s.find({bPos,false}) == s.end())\\n                    {\\n                        q.push({bPos,0,jTill+1});\\n                    }\\n                    \\n                    //once we encounter a perticular state we store it for future\\n                    s.insert({bPos,false}); \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    //1 forward\\n    //0 backwards\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<pair<int,bool>> s; // we need a state of previous position also\\n        //we are using this set as our dp where int is curresponding to \"Position\" and bool value represents weather the last jump was in forward or backwards direction!\\n        \\n        for(auto &it :forbidden)\\n        {\\n             s.insert({it,false});\\n             s.insert({it,true});\\n        }\\n                            //BFS Traversal\\n        queue<vector<int>> q;\\n        q.push({0,1,0});\\n        s.insert({0,0});\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int currPos = q.front()[0];\\n                int prev = q.front()[1];\\n                int jTill = q.front()[2];\\n                if(currPos == x) return jTill;\\n                q.pop();\\n                \\n                //we can jump forward.... irrespective of previous jump\\n                int fPos = currPos + a;\\n                \\n                if(fPos < 6001 && s.find({fPos,true}) == s.end())\\n                {\\n                    q.push({fPos,1,jTill+1});\\n                }\\n                \\n                //once we encounter a perticular state we store it for future\\n                s.insert({fPos,true});\\n                \\n                //we can only jump backwards if we have made the previous jump in forward direction\\n                if(prev == 1)\\n                {\\n                    int bPos = currPos - b;\\n                    if(bPos < 6001 && bPos>=0 && s.find({bPos,false}) == s.end())\\n                    {\\n                        q.push({bPos,0,jTill+1});\\n                    }\\n                    \\n                    //once we encounter a perticular state we store it for future\\n                    s.insert({bPos,false}); \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382606,
                "title": "simple-bfs-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\tunordered_set<int> forbi(forbidden.begin(), forbidden.end());\\n\\t\\t\\n\\t\\tint far = *max_element(forbidden.begin(),forbidden.end())+a+b;\\n        far = max(far,x+a+b);\\n        vector<vector<int>> visited(2,vector<int>(far+1));\\n\\t\\tqueue<pair<int,bool>> qu; \\n\\t\\t\\n\\t\\tqu.push({0,false});\\n\\t\\tvisited[0][0] = 1;\\n\\t\\tvisited[1][0] = 1;\\n\\t\\tint ans = 0;\\n\\t\\twhile(!qu.empty()) {\\n\\t\\t\\tint len = qu.size();\\n\\t\\t\\twhile(len > 0) {\\n\\t\\t\\t\\tlen--;\\n\\t\\t\\t\\tint cur = qu.front().first;\\n\\t\\t\\t\\tbool flag = qu.front().second;\\n\\t\\t\\t\\tif(cur == x) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\tif(forward <= far && visited[0][forward] == 0 && !forbi.count(forward)) {\\n\\t\\t\\t\\t\\tqu.push({forward,false});\\n\\t\\t\\t\\t\\tvisited[0][forward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(backward >=0 && visited[1][backward] == 0 && !forbi.count(backward) && !flag) {\\n\\t\\t\\t\\t\\tqu.push({backward,true});\\n\\t\\t\\t\\t\\tvisited[1][backward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\tunordered_set<int> forbi(forbidden.begin(), forbidden.end());\\n\\t\\t\\n\\t\\tint far = *max_element(forbidden.begin(),forbidden.end())+a+b;\\n        far = max(far,x+a+b);\\n        vector<vector<int>> visited(2,vector<int>(far+1));\\n\\t\\tqueue<pair<int,bool>> qu; \\n\\t\\t\\n\\t\\tqu.push({0,false});\\n\\t\\tvisited[0][0] = 1;\\n\\t\\tvisited[1][0] = 1;\\n\\t\\tint ans = 0;\\n\\t\\twhile(!qu.empty()) {\\n\\t\\t\\tint len = qu.size();\\n\\t\\t\\twhile(len > 0) {\\n\\t\\t\\t\\tlen--;\\n\\t\\t\\t\\tint cur = qu.front().first;\\n\\t\\t\\t\\tbool flag = qu.front().second;\\n\\t\\t\\t\\tif(cur == x) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\tif(forward <= far && visited[0][forward] == 0 && !forbi.count(forward)) {\\n\\t\\t\\t\\t\\tqu.push({forward,false});\\n\\t\\t\\t\\t\\tvisited[0][forward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(backward >=0 && visited[1][backward] == 0 && !forbi.count(backward) && !flag) {\\n\\t\\t\\t\\t\\tqu.push({backward,true});\\n\\t\\t\\t\\t\\tvisited[1][backward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304017,
                "title": "ruby-t-o-n-s-o-n-100-100-bfs",
                "content": "```\\n# @param {Integer[]} forbidden\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} x\\n# @return {Integer}\\ndef minimum_jumps(forbidden, a, b, x)\\n  return 0 if x == 0\\n  forbidden = Set.new(forbidden)\\n  queue = [[0, 0, false]]\\n  \\n  while (node, jump, last_backward = queue.shift)\\n    next_forward = node + a\\n    next_backward = node - b\\n    if !last_backward && next_backward >= 0 && next_backward < 6000 && !forbidden.include?(next_backward)\\n      return jump + 1 if next_backward == x\\n      queue << [next_backward, jump + 1, true]\\n      forbidden << next_backward\\n    end\\n    if next_forward < 6000 && !forbidden.include?(next_forward)\\n      return jump + 1 if next_forward == x\\n      queue << [next_forward, jump + 1, false]\\n      forbidden << next_forward\\n    end\\n  end\\n\\n  -1\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} forbidden\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} x\\n# @return {Integer}\\ndef minimum_jumps(forbidden, a, b, x)\\n  return 0 if x == 0\\n  forbidden = Set.new(forbidden)\\n  queue = [[0, 0, false]]\\n  \\n  while (node, jump, last_backward = queue.shift)\\n    next_forward = node + a\\n    next_backward = node - b\\n    if !last_backward && next_backward >= 0 && next_backward < 6000 && !forbidden.include?(next_backward)\\n      return jump + 1 if next_backward == x\\n      queue << [next_backward, jump + 1, true]\\n      forbidden << next_backward\\n    end\\n    if next_forward < 6000 && !forbidden.include?(next_forward)\\n      return jump + 1 if next_forward == x\\n      queue << [next_forward, jump + 1, false]\\n      forbidden << next_forward\\n    end\\n  end\\n\\n  -1\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 2285421,
                "title": "bfs-c-solution-97-25-faster",
                "content": "```\\nclass Solution {\\npublic:      \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n       vector<int> vis(6000,0);\\n       for(auto &i : forbidden) vis[i]=1;\\n        if(vis[x]==1) return -1;\\n        queue<pair<int,int>> q;\\n        q.push({0,1});\\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n               pair<int,int> cur_vx = q.front();\\n               q.pop();\\n               int par = cur_vx.first;\\n               int dir = cur_vx.second;\\n               if(par==x) return ans;\\n               if(vis[par]==1) continue;\\n               vis[par]=1;\\n                \\n               int l = par - b;\\n               int r = par + a;\\n               if(l>=0 && dir==1) q.push({l,0});\\n               if(par <= 2000 + b ) q.push({r,1});  \\n            } \\n            ans++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:      \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n       vector<int> vis(6000,0);\\n       for(auto &i : forbidden) vis[i]=1;\\n        if(vis[x]==1) return -1;\\n        queue<pair<int,int>> q;\\n        q.push({0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2280533,
                "title": "golang-bfs",
                "content": "````\\n\\ntype Pos struct {\\n\\tpos        int\\n\\tisBackward bool\\n}\\n\\nfunc minimumJumps(forbidden []int, a int, b int, x int) int {\\n\\n\\tjumps := 0\\n\\tsearchBoundary := max(forbidden) + x + a + b\\n\\n\\tvisit := make(map[Pos]struct{})\\n\\n\\tfmap := make(map[int]struct{})\\n\\tfor _, x := range forbidden {\\n\\t\\tfmap[x] = struct{}{}\\n\\t}\\n\\n\\tisSeen := func(pos Pos) bool {\\n\\t\\t_, ok := visit[pos]\\n\\t\\treturn ok\\n\\t}\\n\\tisForbidden := func(pos int) bool {\\n\\t\\t_, ok := fmap[pos]\\n\\t\\treturn ok\\n\\t}\\n\\n\\tqueue := []Pos{{0, false}}\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tcurrlen := len(queue)\\n\\t\\tfor _, currPos := range queue[:currlen] {\\n\\n\\t\\t\\tcurr, isBackward := currPos.pos, currPos.isBackward\\n\\t\\t\\tif curr == x {\\n\\t\\t\\t\\treturn jumps\\n\\t\\t\\t}\\n\\n\\t\\t\\t// move forward\\n\\t\\t\\tnextPos := Pos{curr + a, false}\\n\\t\\t\\tif !isForbidden(nextPos.pos) &&      //not in forbidden list\\n\\t\\t\\t\\tnextPos.pos < searchBoundary &&   //witin boundary\\n\\t\\t\\t\\t!isSeen(nextPos) {    //not visited before \\n\\t\\t\\t\\tqueue = append(queue, nextPos)\\n\\t\\t\\t\\tvisit[Pos{nextPos.pos, false}] = struct{}{}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//move backward\\n\\t\\t\\tnextPos = Pos{curr - b, true}\\n\\t\\t\\tif !isForbidden(nextPos.pos) && //is not in forbidden list\\n\\t\\t\\t\\tnextPos.pos >= 0 && // within boundary\\n\\t\\t\\t\\t!isSeen(nextPos) && //not visited before\\n\\t\\t\\t\\t!isBackward { //two consecutive backward movement is not allowed\\n\\t\\t\\t\\tqueue = append(queue, nextPos)\\n\\t\\t\\t\\tvisit[nextPos] = struct{}{}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tqueue = queue[currlen:]\\n\\t\\tjumps++\\n\\t}\\n\\n\\treturn -1\\n\\n}\\n\\n//get max element from array\\nfunc max(arr []int) int {\\n\\tmax := arr[0]\\n\\tfor _, val := range arr[1:] {\\n\\t\\tif val > max {\\n\\t\\t\\tmax = val\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n\\n\\n`````",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "````\\n\\ntype Pos struct {\\n\\tpos        int\\n\\tisBackward bool\\n}\\n\\nfunc minimumJumps(forbidden []int, a int, b int, x int) int {\\n\\n\\tjumps := 0\\n\\tsearchBoundary := max(forbidden) + x + a + b\\n\\n\\tvisit := make(map[Pos]struct{})\\n\\n\\tfmap := make(map[int]struct{})\\n\\tfor _, x := range forbidden {\\n\\t\\tfmap[x] = struct{}{}\\n\\t}\\n\\n\\tisSeen := func(pos Pos) bool {\\n\\t\\t_, ok := visit[pos]\\n\\t\\treturn ok\\n\\t}\\n\\tisForbidden := func(pos int) bool {\\n\\t\\t_, ok := fmap[pos]\\n\\t\\treturn ok\\n\\t}\\n\\n\\tqueue := []Pos{{0, false}}\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tcurrlen := len(queue)\\n\\t\\tfor _, currPos := range queue[:currlen] {\\n\\n\\t\\t\\tcurr, isBackward := currPos.pos, currPos.isBackward\\n\\t\\t\\tif curr == x {\\n\\t\\t\\t\\treturn jumps\\n\\t\\t\\t}\\n\\n\\t\\t\\t// move forward\\n\\t\\t\\tnextPos := Pos{curr + a, false}\\n\\t\\t\\tif !isForbidden(nextPos.pos) &&      //not in forbidden list\\n\\t\\t\\t\\tnextPos.pos < searchBoundary &&   //witin boundary\\n\\t\\t\\t\\t!isSeen(nextPos) {    //not visited before \\n\\t\\t\\t\\tqueue = append(queue, nextPos)\\n\\t\\t\\t\\tvisit[Pos{nextPos.pos, false}] = struct{}{}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//move backward\\n\\t\\t\\tnextPos = Pos{curr - b, true}\\n\\t\\t\\tif !isForbidden(nextPos.pos) && //is not in forbidden list\\n\\t\\t\\t\\tnextPos.pos >= 0 && // within boundary\\n\\t\\t\\t\\t!isSeen(nextPos) && //not visited before\\n\\t\\t\\t\\t!isBackward { //two consecutive backward movement is not allowed\\n\\t\\t\\t\\tqueue = append(queue, nextPos)\\n\\t\\t\\t\\tvisit[nextPos] = struct{}{}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tqueue = queue[currlen:]\\n\\t\\tjumps++\\n\\t}\\n\\n\\treturn -1\\n\\n}\\n\\n//get max element from array\\nfunc max(arr []int) int {\\n\\tmax := arr[0]\\n\\tfor _, val := range arr[1:] {\\n\\t\\tif val > max {\\n\\t\\t\\tmax = val\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2271420,
                "title": "bfs-c-detailed-solution",
                "content": "```\\n//vis[x][0] --> visited the position x following forward direction \\n//vis[x][1] --> visited the position x following backward direction \\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n         queue<pair<int,int>>q;//q{pos,dir} [0->forward,1->backward]\\n         q.push({0,0}); // adding starting postion with direction as forward (0)\\n         int end=10000; // constraint(can\\'t go further than this)\\n         vector<vector<int>>vis(end+1,vector<int>(2,0));\\n        \\n        // visit the all forbidden zone\\n        for(auto zone:forbidden){\\n            if(zone<=end)vis[zone][0]=true;\\n            if(zone<=end)vis[zone][1]=true;\\n        }\\n        \\n        if(vis[x][0])return -1; // if home is at forbidden zone\\n        \\n        //starting point is both forward and backward visited(if we reach starting point in    \\n        //backward direction then we can\\'t go any further because forward of starting was already marked\\n        //in the begenning) and hence it will be a trap state\\n        vis[0][0]=true,vis[0][1]=true;\\n        \\n        \\n        int jumps=0;\\n        \\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                pair<int,int>p=q.front();\\n                q.pop();\\n                \\n                int pos=p.first;\\n                int dir=p.second;\\n                \\n                if(pos==x)return jumps;//destination reached\\n                \\n                 // if this position is travelled with forward direction then we can move forward as   \\n                 // well as backward direction.\\n                if(dir==0){ \\n                    if(((pos+a)<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                    if(((pos-b)>=0)&&(!vis[pos-b][1])){vis[pos-b][1]=true;q.push({pos-b,1});}\\n                        \\n                }\\n                // if this position is travelled with backward direction then we can move only in \\n                //forward direction\\n                else{ \\n                    if((pos+a<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                }\\n            }\\n           jumps++; \\n            \\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n         queue<pair<int,int>>q;//q{pos,dir}",
                "codeTag": "Java"
            },
            {
                "id": 2191670,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& fb, int a, int b, int x) {\\n        int n=fb.size();\\n        if(x==0) return 0;\\n        map<int,int> mp;\\n        map<pair<int,int>,int> vis;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        for(int i=0;i<n;i++){\\n            mp[fb[i]]=1;\\n        }\\n        vis[{0,0}]=1;\\n        int step=1,fur=6000;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto curr=q.front();\\n                q.pop();\\n                int next_a=curr.first+a;\\n                if(next_a==x) return step;\\n                if(next_a>=0 && next_a<=fur && !vis.count({next_a,1}) && !mp.count(next_a)){\\n                    q.push({next_a,1});\\n                    vis[{next_a,1}]=1;\\n                }\\n                int next_b=curr.first-b;\\n                if(curr.second==1){\\n                    if(next_b==x) return step;\\n                    if(next_b>=0 && next_b<=fur && !vis.count({next_b,0}) && !mp.count(next_b)){\\n                        q.push({next_b,0});\\n                        vis[{next_b,0}]=1;\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumJumps(vector<int>& fb, int a, int b, int x) {\\n        int n=fb.size();\\n        if(x==0) return 0;\\n        map<int,int> mp;\\n        map<pair<int,int>,int> vis;\\n        queue<pair<int,int>> q;\\n        q.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2190113,
                "title": "rust-bfs",
                "content": "```rust\\nuse std::{\\n    borrow::Borrow,\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::hash_map::Entry::Occupied,\\n    collections::hash_map::Entry::Vacant,\\n    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},\\n    rc::Rc,\\n};\\n\\n\\n#[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\\nenum Move {\\n    Forward,\\n    Backward,\\n}\\n\\nimpl Solution {\\n    pub fn minimum_jumps(forbidden: Vec<i32>, right: i32, left: i32, current: i32) -> i32 {\\n        let mut res = 0;\\n        let mut queue = VecDeque::new();\\n        let mut visited: HashSet<(i32, Move)> = HashSet::new();\\n\\n        let min = 0;\\n        let max = std::cmp::max(*forbidden.iter().max().unwrap(), current) + right * 2 + left * 2;\\n\\n        for i in forbidden {\\n            visited.insert((i, Move::Forward));\\n            visited.insert((i, Move::Backward));\\n        }\\n\\n        queue.push_back((current, Move::Forward));\\n        queue.push_back((current, Move::Backward));\\n\\n        while !queue.is_empty() {\\n            let mut next_queue = VecDeque::new();\\n            while let Some(current) = queue.pop_front() {\\n                if visited.contains(&current) {\\n                    continue;\\n                }\\n                visited.insert(current);\\n                let (curr_idx, curr_move) = current;\\n\\n                if curr_idx == 0 {\\n                    return res;\\n                } else if curr_idx <= min || curr_idx >= max {\\n                    continue;\\n                }\\n\\n                match curr_move {\\n                    Move::Forward => {\\n                        next_queue.push_back((curr_idx - right, Move::Forward));\\n                        next_queue.push_back((curr_idx + left, Move::Backward));\\n                    }\\n                    Move::Backward => {\\n                        next_queue.push_back((curr_idx - right, Move::Forward));\\n                    }\\n                }\\n            }\\n\\n            queue = next_queue;\\n            res += 1;\\n\\n            // println!(\"{:?}\", queue);\\n        }\\n\\n        -1\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::{\\n    borrow::Borrow,\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::hash_map::Entry::Occupied,\\n    collections::hash_map::Entry::Vacant,\\n    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},\\n    rc::Rc,\\n};\\n\\n\\n#[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\\nenum Move {\\n    Forward,\\n    Backward,\\n}\\n\\nimpl Solution {\\n    pub fn minimum_jumps(forbidden: Vec<i32>, right: i32, left: i32, current: i32) -> i32 {\\n        let mut res = 0;\\n        let mut queue = VecDeque::new();\\n        let mut visited: HashSet<(i32, Move)> = HashSet::new();\\n\\n        let min = 0;\\n        let max = std::cmp::max(*forbidden.iter().max().unwrap(), current) + right * 2 + left * 2;\\n\\n        for i in forbidden {\\n            visited.insert((i, Move::Forward));\\n            visited.insert((i, Move::Backward));\\n        }\\n\\n        queue.push_back((current, Move::Forward));\\n        queue.push_back((current, Move::Backward));\\n\\n        while !queue.is_empty() {\\n            let mut next_queue = VecDeque::new();\\n            while let Some(current) = queue.pop_front() {\\n                if visited.contains(&current) {\\n                    continue;\\n                }\\n                visited.insert(current);\\n                let (curr_idx, curr_move) = current;\\n\\n                if curr_idx == 0 {\\n                    return res;\\n                } else if curr_idx <= min || curr_idx >= max {\\n                    continue;\\n                }\\n\\n                match curr_move {\\n                    Move::Forward => {\\n                        next_queue.push_back((curr_idx - right, Move::Forward));\\n                        next_queue.push_back((curr_idx + left, Move::Backward));\\n                    }\\n                    Move::Backward => {\\n                        next_queue.push_back((curr_idx - right, Move::Forward));\\n                    }\\n                }\\n            }\\n\\n            queue = next_queue;\\n            res += 1;\\n\\n            // println!(\"{:?}\", queue);\\n        }\\n\\n        -1\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2165190,
                "title": "c-dp-memoization-fast-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<int> fob;\\n    int dp[7001][2];\\n    int solver(int pos, int &home, int &a, int &b, bool left)\\n    {\\n        if(pos == home)return 0;\\n        if(pos < 0 || pos > 7000 || fob.find(pos) != fob.end())return 1e9;\\n        if(dp[pos][left] != -1) return dp[pos][left];\\n        \\n        dp[pos][left] = 1 + solver(pos + a, home, a, b, false);\\n        if(!left)\\n        {\\n            dp[pos][left] = min(dp[pos][left], 1 + solver(pos - b, home, a, b, true));\\n        }\\n        return dp[pos][left];\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(auto i: forbidden)fob.insert(i);\\n        memset(dp, -1, sizeof(dp));\\n        int ans = solver(0, x, a, b, false);\\n        return (ans >= 1e9)? -1: ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_set<int> fob;\\n    int dp[7001][2];\\n    int solver(int pos, int &home, int &a, int &b, bool left)\\n    {\\n        if(pos == home)return 0;\\n        if(pos < 0 || pos > 7000 || fob.find(pos) != fob.end())return 1e9;\\n        if(dp[pos][left] != -1) return dp[pos][left];\\n        \\n        dp[pos][left] = 1 + solver(pos + a, home, a, b, false);\\n        if(!left)\\n        {\\n            dp[pos][left] = min(dp[pos][left], 1 + solver(pos - b, home, a, b, true));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2164391,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> visited = new HashSet<>();\\n        int limit = 2000 + 2 * b + 1;\\n        for (int e : forbidden) {\\n            visited.add(e);\\n        }\\n        int steps = 0;\\n        Queue<Pair<Integer, Boolean>> q = new LinkedList<>();\\n        q.offer(new Pair<Integer, Boolean>(0, true));\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair<Integer, Boolean> pair = q.poll();\\n                int num = pair.getKey();\\n                boolean canJumpBackward = pair.getValue();\\n                if (num == x) {\\n                    return steps;\\n                }\\n                if (canJumpBackward) {\\n                   int backwardStep = num - b;\\n                   if (backwardStep > 0 && !visited.contains(backwardStep)) {\\n                       q.offer(new Pair<Integer, Boolean>(backwardStep, false));\\n                       visited.add(backwardStep);\\n                   }\\n                }\\n                int forwardStep = num + a;\\n                if (forwardStep < limit && !visited.contains(forwardStep)) {\\n                    q.offer(new Pair<Integer, Boolean>(forwardStep, true));\\n                    visited.add(forwardStep);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> visited = new HashSet<>();\\n        int limit = 2000 + 2 * b + 1;\\n        for (int e : forbidden) {\\n            visited.add(e);\\n        }\\n        int steps = 0;\\n        Queue<Pair<Integer, Boolean>> q = new LinkedList<>();\\n        q.offer(new Pair<Integer, Boolean>(0, true));\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair<Integer, Boolean> pair = q.poll();\\n                int num = pair.getKey();\\n                boolean canJumpBackward = pair.getValue();\\n                if (num == x) {\\n                    return steps;\\n                }\\n                if (canJumpBackward) {\\n                   int backwardStep = num - b;\\n                   if (backwardStep > 0 && !visited.contains(backwardStep)) {\\n                       q.offer(new Pair<Integer, Boolean>(backwardStep, false));\\n                       visited.add(backwardStep);\\n                   }\\n                }\\n                int forwardStep = num + a;\\n                if (forwardStep < limit && !visited.contains(forwardStep)) {\\n                    q.offer(new Pair<Integer, Boolean>(forwardStep, true));\\n                    visited.add(forwardStep);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143843,
                "title": "c-bfs-easy-to-understand",
                "content": "Simple Level Order Traversal.\\n\\nHow to identify If it\\'s a bfs based problem?\\n\\nThe thumb rule  is that if it asks to find the smallest or shortest type of problem in graph then there are 95% chances  that the problem will be solved with level order traversal using BFS technique. You can solve it recurssively but I think it is better to use BFS as in DFS it can go way deeper and we will get to the ans much later as compared to BFS.\\n\\nYou can optimize the Soln of DFS based approach using Memoization. Check out other threads as well for such soln.\\n\\n6000 was just an assumption of a safe long distance space. You can choice any number greater than 6000, it will work as well.\\n\\nPlease comment down all your doubts if there are any!\\n```\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\tset<int> st(forbidden.begin(), forbidden.end());\\n\\t\\tvector<int> visFwd(6000, 0);\\n\\t\\tvector<int>visBack(6000, 0);\\n\\t\\tqueue<pair<int,bool>> q; \\n\\t\\tq.push({0,false});\\n\\t\\tvisFwd[0] = 1;\\n\\t\\tvisBack[0] = 1;\\n\\t\\tint ans = 0;\\n\\t\\twhile(!q.empty()) {\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\twhile(size--) {\\n\\t\\t\\t\\tint cur = q.front().first;\\n\\t\\t\\t\\tbool flag = q.front().second;\\n\\t\\t\\t\\tq.pop();\\n                if(cur == x) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\tif(forward < 6000 && visFwd[forward] == 0 && !st.count(forward)) {\\n\\t\\t\\t\\t\\tq.push({forward,false});\\n\\t\\t\\t\\t\\tvisFwd[forward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(backward >=0 && visBack[backward] == 0 && !st.count(backward) && !flag) {\\n\\t\\t\\t\\t\\tq.push({backward,true});\\n\\t\\t\\t\\t\\tvisBack[backward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\tset<int> st(forbidden.begin(), forbidden.end());\\n\\t\\tvector<int> visFwd(6000, 0);\\n\\t\\tvector<int>visBack(6000, 0);\\n\\t\\tqueue<pair<int,bool>> q; \\n\\t\\tq.push({0,false});\\n\\t\\tvisFwd[0] = 1;\\n\\t\\tvisBack[0] = 1;\\n\\t\\tint ans = 0;\\n\\t\\twhile(!q.empty()) {\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\twhile(size--) {\\n\\t\\t\\t\\tint cur = q.front().first;\\n\\t\\t\\t\\tbool flag = q.front().second;\\n\\t\\t\\t\\tq.pop();\\n                if(cur == x) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\tif(forward < 6000 && visFwd[forward] == 0 && !st.count(forward)) {\\n\\t\\t\\t\\t\\tq.push({forward,false});\\n\\t\\t\\t\\t\\tvisFwd[forward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(backward >=0 && visBack[backward] == 0 && !st.count(backward) && !flag) {\\n\\t\\t\\t\\t\\tq.push({backward,true});\\n\\t\\t\\t\\t\\tvisBack[backward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137388,
                "title": "c-code-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    set<int> s;\\n    int dp[6005][3];\\n    \\n    int func(int a,int b,int x,int pos,int prev){\\n        if (pos==x){\\n            return 0;\\n        }\\n       \\n        if (s.count(pos) || pos<0 || pos>6000){\\n            return 1e9;\\n        }\\n        \\n        if (dp[pos][prev]!=-1){\\n            return dp[pos][prev];\\n        }\\n        \\n        \\n      \\n        dp[pos][prev]=1+func(a,b,x,pos+a,0);\\n        if (prev==0){\\n            dp[pos][prev]=min(dp[pos][prev],1+func(a,b,x,pos-b,1));\\n        }\\n        \\n     return dp[pos][prev];\\n    }\\n    \\n    int minimumJumps(vector<int>& v, int a, int b, int x) {\\n        for (auto it: v){\\n            s.insert(it);\\n        }\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        int ans=func(a,b,x,0,0);\\n        if (ans>=1e9){\\n            return -1;\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> s;\\n    int dp[6005][3];\\n    \\n    int func(int a,int b,int x,int pos,int prev){\\n        if (pos==x){\\n            return 0;\\n        }\\n       \\n        if (s.count(pos) || pos<0 || pos>6000){\\n            return 1e9;\\n        }\\n        \\n        if (dp[pos][prev]!=-1){\\n            return dp[pos][prev];\\n        }\\n        \\n        \\n      \\n        dp[pos][prev]=1+func(a,b,x,pos+a,0);\\n        if (prev==0){\\n            dp[pos][prev]=min(dp[pos][prev],1+func(a,b,x,pos-b,1));\\n        }\\n        \\n     return dp[pos][prev];\\n    }\\n    \\n    int minimumJumps(vector<int>& v, int a, int b, int x) {\\n        for (auto it: v){\\n            s.insert(it);\\n        }\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        int ans=func(a,b,x,0,0);\\n        if (ans>=1e9){\\n            return -1;\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130948,
                "title": "python-bfs-solution-beats-93-98",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, fb: List[int], a: int, b: int, x: int) -> int:\\n        fb = set(fb)\\n        q = deque([[0,0,True]])\\n        while(q):\\n            n,l,isf = q.popleft()\\n            if(n<0 or n in fb or n>2000+2*b):\\n                continue\\n            fb.add(n)\\n            if(n==x):\\n                return l\\n            if isf and n-b>0:\\n                q.append([n-b,l+1,False])                \\n            q.append([n+a,l+1,True])\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, fb: List[int], a: int, b: int, x: int) -> int:\\n        fb = set(fb)\\n        q = deque([[0,0,True]])\\n        while(q):\\n            n,l,isf = q.popleft()\\n            if(n<0 or n in fb or n>2000+2*b):\\n                continue\\n            fb.add(n)\\n            if(n==x):\\n                return l\\n            if isf and n-b>0:\\n                q.append([n-b,l+1,False])                \\n            q.append([n+a,l+1,True])\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086839,
                "title": "what-s-wrong-in-this-bfs-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n        unordered_set<int>forbid;\\n        unordered_set<int>visited;\\n        for(int index = 0; index < forbidden.size(); index++)   forbid.insert(forbidden[index]);\\n        \\n        queue<pair<int, bool>>q;\\n        int level = 0;\\n        q.push({0, false});\\n        visited.insert(0);\\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int index = q.front().first;\\n                bool lastBackward = q.front().second;\\n                q.pop();\\n                \\n                if(index == x)  return level;\\n                \\n                int forward = index + a;\\n                if(forward <= 1e6  && !forbid.count(forward) && !visited.count(forward))\\n                {\\n                    q.push({forward, false});\\n                    visited.insert(forward);\\n                }\\n                \\n                int backward = index-b;\\n                if(!lastBackward && backward >=0 && !forbid.count(backward) && !visited.count(backward))\\n                {\\n                    q.push({backward, true});\\n                    visited.insert(backward);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n        unordered_set<int>forbid;\\n        unordered_set<int>visited;\\n        for(int index = 0; index < forbidden.size(); index++)   forbid.insert(forbidden[index]);\\n        \\n        queue<pair<int, bool>>q;\\n        int level = 0;\\n        q.push({0, false});\\n        visited.insert(0);\\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int index = q.front().first;\\n                bool lastBackward = q.front().second;\\n                q.pop();\\n                \\n                if(index == x)  return level;\\n                \\n                int forward = index + a;\\n                if(forward <= 1e6  && !forbid.count(forward) && !visited.count(forward))\\n                {\\n                    q.push({forward, false});\\n                    visited.insert(forward);\\n                }\\n                \\n                int backward = index-b;\\n                if(!lastBackward && backward >=0 && !forbid.count(backward) && !visited.count(backward))\\n                {\\n                    q.push({backward, true});\\n                    visited.insert(backward);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043357,
                "title": "python-solution-problem-is-missing-some-test-cases-or-am-i-wrong",
                "content": "I think the solution must hash not only the positions, but how much backwards leaps we\\'ve made so far. However, solution with visited only on positions is accepted as well.\\n\\nThe reason why I think that is because there could be a test case where we explore in this manner\\n(a = 2, b = 2\\n            node/backward leaps\\n1 -> 2,    (2,0)\\n2 >  4      (4, 0)\\n4 < 2      (2, 1) - not added to the queue because we already visited 2.\\n\\nWhat am I missing?\\n\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \"\"\"\\n        1. Approach one: BFS: linear -> we visit every \"edge\" and \"vertex\" only once \\n        where edge is numbers from [0, x]\\n        and the vertex is all possibilities in the graph (i + a, i - b) for i in range(len(X)))\\n        \\n        2. Approach is Dijkstra\\'s -> we are going to prioritize more promizing nodes first \\n        \\n        3. Approach is A*, we are going to add is heuristic to speed up the computation process\\n        \\n        BFS LLD:\\n        \\n        notes:\\n        since frog can\\'t jump twice in the row backwards, we need to mark each visited we the number of backward jumps so that we can explore the cell with different backward leaps at each point\\n        \\n        2. we will merge forbidden to visited for simplicity \\n        \\n        3. we will return immideatly if 0 is frobbiden or\\n        \\n        we stop when the q has no more nodes, and return -1\\n        we stop when we pop node with value x.\\n        \"\"\"\\n        \\n        q = deque()\\n        visited = set()\\n        for f in forbidden:\\n            for i in range(2):\\n                visited.add((f,i))\\n            \\n        q.append((0,0, 0))\\n        \\n        furthest = max([x]+forbidden) +a+b      \\n        while q:\\n            node, bck, distance = q.popleft()\\n            \\n            if (node,bck) in visited:\\n                continue \\n                \\n            if node == x:\\n                return distance\\n            \\n            visited.add((node,bck))\\n            \\n            left_jump = node - b \\n            right_jump = node + a\\n            \\n            if left_jump > 0 and bck == 0:\\n                if (left_jump, 1) not in visited:\\n                    q.append((left_jump, 1, distance + 1))\\n                \\n            if right_jump <= furthest:\\n                if (right_jump, 0) not in visited:\\n                    q.append((right_jump, 0, distance + 1))\\n                \\n        return -1\\n            \\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "I think the solution must hash not only the positions, but how much backwards leaps we\\'ve made so far. However, solution with visited only on positions is accepted as well.\\n\\nThe reason why I think that is because there could be a test case where we explore in this manner\\n(a = 2, b = 2\\n            node/backward leaps\\n1 -> 2,    (2,0)\\n2 >  4      (4, 0)\\n4 < 2      (2, 1) - not added to the queue because we already visited 2.\\n\\nWhat am I missing?\\n\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \"\"\"\\n        1. Approach one: BFS: linear -> we visit every \"edge\" and \"vertex\" only once \\n        where edge is numbers from [0, x]\\n        and the vertex is all possibilities in the graph (i + a, i - b) for i in range(len(X)))\\n        \\n        2. Approach is Dijkstra\\'s -> we are going to prioritize more promizing nodes first \\n        \\n        3. Approach is A*, we are going to add is heuristic to speed up the computation process\\n        \\n        BFS LLD:\\n        \\n        notes:\\n        since frog can\\'t jump twice in the row backwards, we need to mark each visited we the number of backward jumps so that we can explore the cell with different backward leaps at each point\\n        \\n        2. we will merge forbidden to visited for simplicity \\n        \\n        3. we will return immideatly if 0 is frobbiden or\\n        \\n        we stop when the q has no more nodes, and return -1\\n        we stop when we pop node with value x.\\n        \"\"\"\\n        \\n        q = deque()\\n        visited = set()\\n        for f in forbidden:\\n            for i in range(2):\\n                visited.add((f,i))\\n            \\n        q.append((0,0, 0))\\n        \\n        furthest = max([x]+forbidden) +a+b      \\n        while q:\\n            node, bck, distance = q.popleft()\\n            \\n            if (node,bck) in visited:\\n                continue \\n                \\n            if node == x:\\n                return distance\\n            \\n            visited.add((node,bck))\\n            \\n            left_jump = node - b \\n            right_jump = node + a\\n            \\n            if left_jump > 0 and bck == 0:\\n                if (left_jump, 1) not in visited:\\n                    q.append((left_jump, 1, distance + 1))\\n                \\n            if right_jump <= furthest:\\n                if (right_jump, 0) not in visited:\\n                    q.append((right_jump, 0, distance + 1))\\n                \\n        return -1\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1937436,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        visited=set(forbidden)\\n        queue=[(0,0,True)]\\n        max_val=max([x]+forbidden) +a+b\\n        while queue:\\n            pos,steps,back=queue.pop(0)\\n            if pos==x:\\n                return steps\\n            \\n            if pos-b not in visited and back and pos-b>0:\\n                queue.append((pos-b,steps+1,not back))\\n                visited.add(pos-b)\\n            if pos+a not in visited  and pos+a<=max_val:\\n                queue.append((pos+a,steps+1,True))\\n                visited.add(pos+a)\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        visited=set(forbidden)\\n        queue=[(0,0,True)]\\n        max_val=max([x]+forbidden) +a+b\\n        while queue:\\n            pos,steps,back=queue.pop(0)\\n            if pos==x:\\n                return steps\\n            \\n            if pos-b not in visited and back and pos-b>0:\\n                queue.append((pos-b,steps+1,not back))\\n                visited.add(pos-b)\\n            if pos+a not in visited  and pos+a<=max_val:\\n                queue.append((pos+a,steps+1,True))\\n                visited.add(pos+a)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928962,
                "title": "java-bfs-solution",
                "content": "\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> set = new HashSet();\\n        Set<String> visit = new HashSet();\\n        for(int n : forbidden)\\n            set.add(n);\\n        \\n        Queue<int[]> q = new LinkedList();\\n        int moves = 0;\\n        int max = 2000 + 2*b;\\n        \\n        q.offer(new int[]{0, 0});\\n       \\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int[] current = q.poll();\\n                int pos = current[0], direction = current[1];\\n                \\n                if(pos == x) return moves;\\n                \\n                if(pos + a < max && !set.contains(pos + a) && !visit.contains(pos+a+\",\"+0))\\n                {\\n                    visit.add(pos+a+\",\"+0);\\n                    q.offer(new int[]{pos + a, 0});\\n                } \\n                \\n                if(direction == 0)\\n                {   \\n                    if(pos - b >= 0 && !set.contains(pos - b) && !visit.contains(pos-b+\",\"+1))\\n                    {\\n                        visit.add(pos-b+\",\"+1);\\n                        q.offer(new int[]{pos - b, 1});\\n                    }\\n                }\\n            }\\n            moves++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> set = new HashSet();\\n        Set<String> visit = new HashSet();\\n        for(int n : forbidden)\\n            set.add(n);\\n        \\n        Queue<int[]> q = new LinkedList();\\n        int moves = 0;\\n        int max = 2000 + 2*b;\\n        \\n        q.offer(new int[]{0, 0});\\n       \\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int[] current = q.poll();\\n                int pos = current[0], direction = current[1];\\n                \\n                if(pos == x) return moves;\\n                \\n                if(pos + a < max && !set.contains(pos + a) && !visit.contains(pos+a+\",\"+0))\\n                {\\n                    visit.add(pos+a+\",\"+0);\\n                    q.offer(new int[]{pos + a, 0});\\n                } \\n                \\n                if(direction == 0)\\n                {   \\n                    if(pos - b >= 0 && !set.contains(pos - b) && !visit.contains(pos-b+\",\"+1))\\n                    {\\n                        visit.add(pos-b+\",\"+1);\\n                        q.offer(new int[]{pos - b, 1});\\n                    }\\n                }\\n            }\\n            moves++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922705,
                "title": "cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        if(x == 0) return 0;\\n        \\n        int dp[6001] = {};\\n        \\n        for(int i: forbidden) dp[i] = -1;\\n        \\n        deque<pair<int, bool>> dq;\\n        dq.push_back({0, false});\\n        \\n        while(dq.size() > 0){\\n            \\n            auto [val, canGoBack] = dq.front();\\n            if(val == x) return dp[val];\\n            dq.pop_front();\\n            \\n            if(canGoBack && val - b > 0 && dp[val-b] == 0){\\n                dp[val-b] = 1 + dp[val];\\n                dq.push_back({val-b, false});\\n            }\\n            \\n            if(val + a <= 6000 && dp[val + a] == 0){\\n                dp[val + a] = 1 + dp[val];\\n                dq.push_back({val+a, true});\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        if(x == 0) return 0;\\n        \\n        int dp[6001] = {};\\n        \\n        for(int i: forbidden) dp[i] = -1;\\n        \\n        deque<pair<int, bool>> dq;\\n        dq.push_back({0, false});\\n        \\n        while(dq.size() > 0){\\n            \\n            auto [val, canGoBack] = dq.front();\\n            if(val == x) return dp[val];\\n            dq.pop_front();\\n            \\n            if(canGoBack && val - b > 0 && dp[val-b] == 0){\\n                dp[val-b] = 1 + dp[val];\\n                dq.push_back({val-b, false});\\n            }\\n            \\n            if(val + a <= 6000 && dp[val + a] == 0){\\n                dp[val + a] = 1 + dp[val];\\n                dq.push_back({val+a, true});\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902702,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int pos;\\n        int backcount;\\n        Pair(int pos,int backcount ){\\n            this.pos=pos;\\n            this.backcount=backcount;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        HashMap<Integer,Boolean> visited=new HashMap<>();\\n        Queue<Pair> queue=new LinkedList<>();\\n        for(int i:forbidden){\\n            visited.put(i,true);\\n        }\\n        queue.add(new Pair(0,0));\\n        \\n        int level=0;\\n        while(queue.size()>0){\\n            int size=queue.size();\\n            while(size-->0){\\n                Pair rem=queue.remove();\\n                if(rem.pos==x){\\n                    return level;\\n                }\\n                if(visited.containsKey(rem.pos)){\\n                    continue;\\n                }\\n                visited.put(rem.pos,true);\\n                if(rem.backcount==0&&rem.pos-b>=0){\\n                    queue.add(new Pair(rem.pos-b,1));\\n                }\\n                if(rem.pos<2000+b){\\n                    queue.add(new Pair(rem.pos+a,0));\\n                }\\n            }level++;\\n        }\\n    return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int pos;\\n        int backcount;\\n        Pair(int pos,int backcount ){\\n            this.pos=pos;\\n            this.backcount=backcount;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        HashMap<Integer,Boolean> visited=new HashMap<>();\\n        Queue<Pair> queue=new LinkedList<>();\\n        for(int i:forbidden){\\n            visited.put(i,true);\\n        }\\n        queue.add(new Pair(0,0));\\n        \\n        int level=0;\\n        while(queue.size()>0){\\n            int size=queue.size();\\n            while(size-->0){\\n                Pair rem=queue.remove();\\n                if(rem.pos==x){\\n                    return level;\\n                }\\n                if(visited.containsKey(rem.pos)){\\n                    continue;\\n                }\\n                visited.put(rem.pos,true);\\n                if(rem.backcount==0&&rem.pos-b>=0){\\n                    queue.add(new Pair(rem.pos-b,1));\\n                }\\n                if(rem.pos<2000+b){\\n                    queue.add(new Pair(rem.pos+a,0));\\n                }\\n            }level++;\\n        }\\n    return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893180,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        //marks forbidden position as visited\\n        set<int> visited(forbidden.begin(),forbidden.end());\\n\\n        queue<int> q;\\n        q.push(0);\\n        \\n        int step = 0;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n          \\n            //for all current level\\n            for(int i = 0; i < sz; i++){\\n                \\n                // to eliminate twice backword in a row we are pusing the value with negetive\\n                //to indicate that past move was backward\\n                \\n                int cur = q.front();\\n                q.pop();\\n                bool wasBack = cur < 0;\\n                cur = abs(cur);\\n                \\n                //if we reach distination\\n                if(cur == x) return step; \\n                \\n                int next = cur + a;\\n                \\n                //next < 6000 to handel when we are constantly going forward\\n                //outside the range of our interest\\n                // as max of x is 2000\\n                // and a ,b max is 2000\\n                if(next < 6000 && visited.find(next) == visited.end()){\\n                    visited.insert(next);\\n                    q.push(next);\\n                }\\n                \\n                next = cur - b;\\n                //past move wasnot back \\n                // we dont need to mark it visted\\n                //we we might come to it and with forward move and use one more backward\\n                // to reach destination\\n                if(!wasBack && next > 0 && visited.find(next) == visited.end()){\\n                    q.push(next * -1);\\n                }\\n            }\\n             step++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        //marks forbidden position as visited\\n        set<int> visited(forbidden.begin(),forbidden.end());\\n\\n        queue<int> q;\\n        q.push(0);\\n        \\n        int step = 0;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n          \\n            //for all current level\\n            for(int i = 0; i < sz; i++){\\n                \\n                // to eliminate twice backword in a row we are pusing the value with negetive\\n                //to indicate that past move was backward\\n                \\n                int cur = q.front();\\n                q.pop();\\n                bool wasBack = cur < 0;\\n                cur = abs(cur);\\n                \\n                //if we reach distination\\n                if(cur == x) return step; \\n                \\n                int next = cur + a;\\n                \\n                //next < 6000 to handel when we are constantly going forward\\n                //outside the range of our interest\\n                // as max of x is 2000\\n                // and a ,b max is 2000\\n                if(next < 6000 && visited.find(next) == visited.end()){\\n                    visited.insert(next);\\n                    q.push(next);\\n                }\\n                \\n                next = cur - b;\\n                //past move wasnot back \\n                // we dont need to mark it visted\\n                //we we might come to it and with forward move and use one more backward\\n                // to reach destination\\n                if(!wasBack && next > 0 && visited.find(next) == visited.end()){\\n                    q.push(next * -1);\\n                }\\n            }\\n             step++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878140,
                "title": "c-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[6005][2]={{0}},inf=1e9;\\n    set<int>st;\\n    int jump(int pos,int a,int b,int x,int cnt){\\n        if(pos==x)return 0;\\n        if(st.count(pos) || pos<0 || pos>6000) return inf;\\n        if(dp[pos][cnt]) return dp[pos][cnt];\\n        dp[pos][cnt]=1+jump(pos+a,a,b,x,0);\\n        return dp[pos][cnt]=min(dp[pos][cnt],cnt==0?1+jump(pos-b,a,b,x,1):dp[pos][cnt]);\\n    }\\n    int minimumJumps(vector<int>& f, int a, int b, int x) {\\n        st=set<int>(f.begin(),f.end());\\n        int ans= jump(0,a,b,x,0);\\n        return (ans>=inf)?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[6005][2]={{0}},inf=1e9;\\n    set<int>st;\\n    int jump(int pos,int a,int b,int x,int cnt){\\n        if(pos==x)return 0;\\n        if(st.count(pos) || pos<0 || pos>6000) return inf;\\n        if(dp[pos][cnt]) return dp[pos][cnt];\\n        dp[pos][cnt]=1+jump(pos+a,a,b,x,0);\\n        return dp[pos][cnt]=min(dp[pos][cnt],cnt==0?1+jump(pos-b,a,b,x,1):dp[pos][cnt]);\\n    }\\n    int minimumJumps(vector<int>& f, int a, int b, int x) {\\n        st=set<int>(f.begin(),f.end());\\n        int ans= jump(0,a,b,x,0);\\n        return (ans>=inf)?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846380,
                "title": "java-intuitive-solution-bfs-easy-with-comments-for-understanding",
                "content": "```\\nclass Solution {\\n    \\n    public class pair{\\n        int edge;\\n        boolean state;\\n        pair(int edge, boolean state){\\n            this.edge = edge;\\n            this.state = state;\\n        }\\n    }\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int ele : forbidden){\\n            // so that search could become easy for forbidden elements.\\n            list.add(ele);  \\n        }\\n        HashSet<String> vis = new HashSet<>(); \\n        // taking set as visited so that we don\\'t need to think about size of the visited array \\n\\t\\t// and will add node into it with the jump it came from\\n\\t\\t// e.g. if we reached at 2 from backward then we add b2 in visited set.\\n        Queue<pair> que = new LinkedList<>();\\n        que.add(new pair(0, false));\\n        // state true means from backward, false means from forward\\n        vis.add(\"f\" + 0);  // added from forward\\n        vis.add(\"b\" + 0);  // added from backward\\n        int level = 0;\\n        while(que.size() > 0){\\n            int size = que.size();\\n            while(size-- > 0){\\n                pair rem = que.remove();\\n                if(rem.edge == x){\\n                    return level;\\n                }\\n                \\n                int forward = rem.edge + a;\\n                int backward = rem.edge - b;\\n                boolean isback = rem.state;\\n                \\n                if(forward < 6000 && !list.contains(forward) && !vis.contains(\"f\" + forward)){\\n                    que.add(new pair(forward, false));\\n                    vis.add(\"f\" + forward);\\n                }\\n                if(backward >= 0 && !list.contains(backward) && !isback && !vis.contains(\"b\" + backward)){\\n                    que.add(new pair(backward, true));\\n                    vis.add(\"b\" + backward);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public class pair{\\n        int edge;\\n        boolean state;\\n        pair(int edge, boolean state){\\n            this.edge = edge;\\n            this.state = state;\\n        }\\n    }\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int ele : forbidden){\\n            // so that search could become easy for forbidden elements.\\n            list.add(ele);  \\n        }\\n        HashSet<String> vis = new HashSet<>(); \\n        // taking set as visited so that we don\\'t need to think about size of the visited array \\n\\t\\t// and will add node into it with the jump it came from\\n\\t\\t// e.g. if we reached at 2 from backward then we add b2 in visited set.\\n        Queue<pair> que = new LinkedList<>();\\n        que.add(new pair(0, false));\\n        // state true means from backward, false means from forward\\n        vis.add(\"f\" + 0);  // added from forward\\n        vis.add(\"b\" + 0);  // added from backward\\n        int level = 0;\\n        while(que.size() > 0){\\n            int size = que.size();\\n            while(size-- > 0){\\n                pair rem = que.remove();\\n                if(rem.edge == x){\\n                    return level;\\n                }\\n                \\n                int forward = rem.edge + a;\\n                int backward = rem.edge - b;\\n                boolean isback = rem.state;\\n                \\n                if(forward < 6000 && !list.contains(forward) && !vis.contains(\"f\" + forward)){\\n                    que.add(new pair(forward, false));\\n                    vis.add(\"f\" + forward);\\n                }\\n                if(backward >= 0 && !list.contains(backward) && !isback && !vis.contains(\"b\" + backward)){\\n                    que.add(new pair(backward, true));\\n                    vis.add(\"b\" + backward);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836781,
                "title": "bfs-using-set-with-detail-explanation-with-edge-case",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int minimumJumps(vector<int>& nums, int a, int b, int x) {\\n        \\n         queue<pair<int,pair<int,int>> > q;\\n        \\n        // put all element from forbidden array into set for check whether element present or not\\n        set<int> st;\\n        int n=nums.size(); \\n        for(int i=0;i<n;i++)\\n        {\\n            st.insert(nums[i]);\\n           \\n        }\\n        int ans=0;\\n         q.push({0,{0,0}});\\n      \\n        while(!q.empty())\\n        { \\n            \\n            int cnt=q.size();\\n             for(int i=0;i<cnt;i++)\\n             {\\n                      int curr=q.front().first;// curr position\\n                      int score=q.front().second.first; // step\\n                      int back=q.front().second.second;   // if back is 0 then we can traverse backside (jump backward twice in a row)\\n                      q.pop();\\n                      int forward=curr+a;\\n                      int backward=curr-b;\\n                 \\n                 \\n                      if(curr==x) // if curr position == x then return score\\n                           return score;\\n                 \\n                 \\n                      if(st.count(curr)) continue; // curr postion present in set then continue\\n                 \\n                       st.insert(curr);// otherwise put that element in set avoid repeatation on that position\\n                 \\n                    // backward operation\\n                       if(back==0 and backward>=0)\\n                         {\\n                            q.push({backward,{score+1,1}});\\n                         } \\n                    // forward operation\\n                       \\n                       if(backward<=2000)\\n                        {\\n                          q.push({forward,{score+1,0}});\\n                        }\\n              }\\n       }\\n         return -1;\\n    }\\n};\\n\\n\\n\\n\\n \\n\\nPLZZ UPVOTE IF YOU LIKE THE SOLUTION\\n     \\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int minimumJumps(vector<int>& nums, int a, int b, int x) {\\n        \\n         queue<pair<int,pair<int,int>> > q;\\n        \\n        // put all element from forbidden array into set for check whether element present or not\\n        set<int> st;\\n        int n=nums.size(); \\n        for(int i=0;i<n;i++)\\n        {\\n            st.insert(nums[i]);\\n           \\n        }\\n        int ans=0;\\n         q.push({0,{0,0}});\\n      \\n        while(!q.empty())\\n        { \\n            \\n            int cnt=q.size();\\n             for(int i=0;i<cnt;i++)\\n             {\\n                      int curr=q.front().first;// curr position\\n                      int score=q.front().second.first; // step\\n                      int back=q.front().second.second;   // if back is 0 then we can traverse backside (jump backward twice in a row)\\n                      q.pop();\\n                      int forward=curr+a;\\n                      int backward=curr-b;\\n                 \\n                 \\n                      if(curr==x) // if curr position == x then return score\\n                           return score;\\n                 \\n                 \\n                      if(st.count(curr)) continue; // curr postion present in set then continue\\n                 \\n                       st.insert(curr);// otherwise put that element in set avoid repeatation on that position\\n                 \\n                    // backward operation\\n                       if(back==0 and backward>=0)\\n                         {\\n                            q.push({backward,{score+1,1}});\\n                         } \\n                    // forward operation\\n                       \\n                       if(backward<=2000)\\n                        {\\n                          q.push({forward,{score+1,0}});\\n                        }\\n              }\\n       }\\n         return -1;\\n    }\\n};\\n\\n\\n\\n\\n \\n\\nPLZZ UPVOTE IF YOU LIKE THE SOLUTION\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828097,
                "title": "java-bfs",
                "content": "```\\nclass Position{\\n    int val;\\n    int direction;\\n    Position(int val, int direction){\\n        this.val = val;\\n        this.direction = direction;\\n    }\\n    @Override\\n    public String toString(){\\n        return this.val+\"#\"+this.direction;\\n    }\\n}\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x == 0)\\n            return 0;\\n        Set<Integer> forbiddenSet = new HashSet();\\n        Set<String> visited = new HashSet();\\n        for (int n: forbidden)\\n            forbiddenSet.add(n);\\n        Queue<Position> queue = new LinkedList();\\n        queue.offer(new Position(0,0));\\n        visited.add(0+\"#\"+0);\\n        int result = 0;\\n        int max = 10000;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            result++;\\n            while(size-->0){\\n                Position curr = queue.poll();\\n                int next_a = curr.val + a;\\n                if (next_a == x)\\n                    return result;\\n                if (next_a >= 0 && next_a < max && !forbiddenSet.contains(next_a) && visited.add(next_a+\"#\"+1))\\n                    queue.add(new Position(next_a, 1));\\n                if (curr.direction == 1){\\n                    int next_b = curr.val - b;\\n                    if (next_b == x)\\n                        return result;\\n                     if (next_b >= 0 && next_b < max && !forbiddenSet.contains(next_b) && visited.add(next_b+\"#\"+0))\\n                    queue.add(new Position(next_b, 0));\\n                    \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Position{\\n    int val;\\n    int direction;\\n    Position(int val, int direction){\\n        this.val = val;\\n        this.direction = direction;\\n    }\\n    @Override\\n    public String toString(){\\n        return this.val+\"#\"+this.direction;\\n    }\\n}\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x == 0)\\n            return 0;\\n        Set<Integer> forbiddenSet = new HashSet();\\n        Set<String> visited = new HashSet();\\n        for (int n: forbidden)\\n            forbiddenSet.add(n);\\n        Queue<Position> queue = new LinkedList();\\n        queue.offer(new Position(0,0));\\n        visited.add(0+\"#\"+0);\\n        int result = 0;\\n        int max = 10000;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            result++;\\n            while(size-->0){\\n                Position curr = queue.poll();\\n                int next_a = curr.val + a;\\n                if (next_a == x)\\n                    return result;\\n                if (next_a >= 0 && next_a < max && !forbiddenSet.contains(next_a) && visited.add(next_a+\"#\"+1))\\n                    queue.add(new Position(next_a, 1));\\n                if (curr.direction == 1){\\n                    int next_b = curr.val - b;\\n                    if (next_b == x)\\n                        return result;\\n                     if (next_b >= 0 && next_b < max && !forbiddenSet.contains(next_b) && visited.add(next_b+\"#\"+0))\\n                    queue.add(new Position(next_b, 0));\\n                    \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809146,
                "title": "easy-to-understand-standard-bfs",
                "content": "Don\\'t get confused by all the confusing top answers. Just apply standard bfs with some modifications\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        HashSet<Integer> visited = new HashSet<>();\\n        for(int val : forbidden){\\n             visited.add(val);\\n\\t\\t}\\n        Queue<int[]> queue = new LinkedList<>();\\n\\t\\t//adding initial state : (position, count of backward steps, jumps)\\n        queue.add(new int[]{0, 0, 0});\\n        visited.add(0);\\n        while(queue.size() > 0){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int[] first = queue.remove();\\n                int currPos = first[0];\\n                int count = first[1];\\n                int steps = first[2];\\n                if(currPos == x)\\n                    return steps;\\n                int backward = currPos - b;\\n                int forward = currPos + a;\\n                if(!visited.contains(backward) && count < 1){\\n                    if(backward > 0){\\n                        queue.add(new int[]{backward, count + 1, steps + 1});\\n                        visited.add(backward);\\n                    }    \\n                }\\n                if(!visited.contains(forward)){\\n                    if(forward <= 8000){\\n                        queue.add(new int[]{forward, 0, steps + 1});\\n                        visited.add(forward);\\n                    }    \\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        HashSet<Integer> visited = new HashSet<>();\\n        for(int val : forbidden){\\n             visited.add(val);\\n\\t\\t}\\n        Queue<int[]> queue = new LinkedList<>();\\n\\t\\t//adding initial state : (position, count of backward steps, jumps)\\n        queue.add(new int[]{0, 0, 0});\\n        visited.add(0);\\n        while(queue.size() > 0){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int[] first = queue.remove();\\n                int currPos = first[0];\\n                int count = first[1];\\n                int steps = first[2];\\n                if(currPos == x)\\n                    return steps;\\n                int backward = currPos - b;\\n                int forward = currPos + a;\\n                if(!visited.contains(backward) && count < 1){\\n                    if(backward > 0){\\n                        queue.add(new int[]{backward, count + 1, steps + 1});\\n                        visited.add(backward);\\n                    }    \\n                }\\n                if(!visited.contains(forward)){\\n                    if(forward <= 8000){\\n                        queue.add(new int[]{forward, 0, steps + 1});\\n                        visited.add(forward);\\n                    }    \\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807511,
                "title": "c-bfs-graph-easy-to-understand",
                "content": "\\n\\tclass Solution {\\n    public:\\n    int minimumJumps(vector<int>& fbdn, int a, int b, int x) {  \\n        if(x == 0) return 0;\\n\\t\\t\\n        queue<pair<int,int>>q;\\n        unordered_map<int,int>Map;\\n        set<pair<int,int>>vis;\\n        for(auto ele : fbdn) Map[ele]++;\\n        q.push({0,0});\\n        int steps = 0;\\n\\t\\t\\n        while(!q.empty()){\\n            int Size = q.size();\\n            for(int i = 0;i< Size;i++){\\n                auto [pos,times] = q.front();\\n                q.pop();\\n                if(pos < 0 || Map.count(pos) || pos > 10000 || vis.count({pos,times})) continue;\\n                if(pos == x || pos == x) return steps;\\n                vis.insert({pos, times});\\n                q.push({pos + a,0});\\n                if(times == 0) q.push({pos - b,1});\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n    public:\\n    int minimumJumps(vector<int>& fbdn, int a, int b, int x) {  \\n        if(x == 0) return 0;\\n\\t\\t\\n        queue<pair<int,int>>q;\\n        unordered_map<int,int>Map;\\n        set<pair<int,int>>vis;\\n        for(auto ele : fbdn) Map[ele]++;\\n        q.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1484679,
                "title": "java-bfs-solution",
                "content": "\\tclass Solution {\\n    class Node\\n    {\\n        int val;\\n        int dir;\\n        \\n        Node(int val, int dir)\\n        {\\n            this.val = val;\\n            this.dir = dir;\\n        }\\n        \\n        @Override\\n        public String toString()\\n        {\\n            return this.val + \" \" + this.dir;\\n        }\\n    }\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) \\n    {\\n        if(x == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        int steps = 0, furthest = 5000 + 2*b;\\n        Set<Integer> set =  new HashSet<>();\\n        Set<String> visited = new HashSet<>();\\n        for(int i = 0; i < forbidden.length; i++) \\n        {\\n            set.add(forbidden[i]);\\n            furthest = Math.max(furthest, forbidden[i] + 2*b);\\n        }\\n            \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(new Node(0,0));\\n        visited.add(0+\"-\"+0);\\n        steps++;\\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();   \\n            while(size-- > 0)\\n            {\\n                Node node = queue.poll();\\n                int nexta = node.val+a;\\n                \\n                if(nexta == x)\\n                {\\n                    return steps;\\n                }\\n                \\n                if(nexta >= 0 && nexta <= furthest && !set.contains(nexta) && \\n                   visited.add(nexta+\"-\"+1))\\n                {\\n                    queue.add(new Node(nexta, 1));\\n                }\\n                \\n                if(node.dir == 1)\\n                {\\n                    int nextb = node.val-b;\\n                    if(nextb == x)\\n                    {\\n                        return steps;\\n                    }\\n                    \\n                    if(nextb >= 0 && nextb <= furthest && !set.contains(nextb) && \\n                       visited.add(nextb+\"-\"+0))\\n                    {\\n                        queue.add(new Node(nextb, 0));    \\n                    }\\n                }\\n            }\\n            \\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    class Node\\n    {\\n        int val;\\n        int dir;\\n        \\n        Node(int val, int dir)\\n        {\\n            this.val = val;\\n            this.dir = dir;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1476948,
                "title": "c-dp-recursion",
                "content": "class Solution {\\npublic:\\n    \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\tunordered_map<int,int> mp;\\n    \\n    //here in dp 2D array eg dp[i][j] ,then i saves position & j saves if previously came backward or not\\n    int dp[6001][2];\\n\\n    int solve(int i,bool back,int a,int b,int x)\\n    {\\n        // if we reach the desired place return 0 ;\\n        if(i==x) return 0; \\n        \\n        //if position (i) is in negative or its a forbidden place or its beyond x\\n        //then return a max value;\\n        if(i<0 || mp.find(i)!=mp.end() || i>6000)\\n            return 1e9;\\n\\n        //memoziation\\n        if(dp[i][back]!=-1) return dp[i][back];\\n\\n        \\n        // go forward that is i+a;\\n        \\n        dp[i][back]=1+solve(i+a,false,a,b,x);\\n        \\n        //if back is false then previouly we didn\\'t go backward now we can\\n        if(!back)\\n        {\\n            // now we go backward make backward off \\n            \\n            dp[i][back]=min(dp[i][back],1+solve(i-b,1,a,b,x));\\n            \\n            //here we are taking minimum from going forward & backward;\\n        }\\n        return dp[i][back];\\n    }\\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        //save the forbidden cordinates to fetch in O(1) operation;\\n        for(auto &x :forbidden) mp[x]++; \\n\\n        memset(dp,-1,sizeof(dp));\\n\\n        // here second argument is false beccause at first we can go backward;\\n        int ans=solve(0,false,a,b,x);\\n\\n        if(ans>=1e9) return -1; //\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\tunordered_map<int,int> mp;\\n    \\n    //here in dp 2D array eg dp[i][j] ,then i saves position & j saves if previously came backward or not\\n    int dp[6001][2];\\n\\n    int solve(int i,bool back,int a,int b,int x)\\n    {\\n        // if we reach the desired place return 0 ;\\n        if(i==x) return 0; \\n        \\n        //if position (i) is in negative or its a forbidden place or its beyond x\\n        //then return a max value;\\n        if(i<0 || mp.find(i)!=mp.end() || i>6000)\\n            return 1e9;\\n\\n        //memoziation\\n        if(dp[i][back]!=-1) return dp[i][back];\\n\\n        \\n        // go forward that is i+a;\\n        \\n        dp[i][back]=1+solve(i+a,false,a,b,x);\\n        \\n        //if back is false then previouly we didn\\'t go backward now we can\\n        if(!back)\\n        {\\n            // now we go backward make backward off \\n            \\n            dp[i][back]=min(dp[i][back],1+solve(i-b,1,a,b,x));\\n            \\n            //here we are taking minimum from going forward & backward;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1416279,
                "title": "c-bfs-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool s[20000], v[20000];\\n    int minimumJumps(vector<int>& fb, int a, int b, int x) {\\n        queue<pair<int, int>> q;\\n        q.emplace(0, 0);\\n        int m = max(a, b);\\n        for (auto f : fb) s[f] = true;\\n        for (int i = 0; !q.empty(); i++) {\\n            for (int j = 0, e = q.size(); j < e; j++) {\\n                auto [cur, back] = q.front(); q.pop();\\n                if (cur == x) return i;\\n                \\n                if (cur <= x + 5 * m && !s[cur + a]) {\\n                    s[cur + a] = true;;\\n                    q.emplace(cur + a, 0);\\n                }\\n                if (cur - b > 0 && !back && !s[cur - b] && !v[cur - b]) {\\n                    v[cur - b] = true;\\n                    q.emplace(cur - b, 1);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool s[20000], v[20000];\\n    int minimumJumps(vector<int>& fb, int a, int b, int x) {\\n        queue<pair<int, int>> q;\\n        q.emplace(0, 0);\\n        int m = max(a, b);\\n        for (auto f : fb) s[f] = true;\\n        for (int i = 0; !q.empty(); i++) {\\n            for (int j = 0, e = q.size(); j < e; j++) {\\n                auto [cur, back] = q.front(); q.pop();\\n                if (cur == x) return i;\\n                \\n                if (cur <= x + 5 * m && !s[cur + a]) {\\n                    s[cur + a] = true;;\\n                    q.emplace(cur + a, 0);\\n                }\\n                if (cur - b > 0 && !back && !s[cur - b] && !v[cur - b]) {\\n                    v[cur - b] = true;\\n                    q.emplace(cur - b, 1);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314618,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        # each node in the queue is (position, jumped backward last time, number of steps)\\n        queue = collections.deque([(0, False, 0)])\\n        # Notice it is important to keep the False in seen not just the position\\n        seen = set([0, False])\\n        upper_bound = 6000\\n        def valid_position(pos, back):\\n            return 0 <= pos <= upper_bound and (pos, back) not in seen and pos not in forbidden\\n        \\n        while queue:\\n            for _ in range(len(queue)):\\n                pos, back, steps = queue.pop()\\n                if pos == x:\\n                    return steps\\n                if valid_position(pos + a, False):\\n                    seen.add((pos+a, back))\\n                    queue.appendleft((pos+a, False, steps+1))\\n                if not back and valid_position(pos-b, True):\\n                    seen.add((pos-b, True))\\n                    queue.appendleft((pos-b, True, steps+1))\\n        return -1                   \\n                        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        # each node in the queue is (position, jumped backward last time, number of steps)\\n        queue = collections.deque([(0, False, 0)])\\n        # Notice it is important to keep the False in seen not just the position\\n        seen = set([0, False])\\n        upper_bound = 6000\\n        def valid_position(pos, back):\\n            return 0 <= pos <= upper_bound and (pos, back) not in seen and pos not in forbidden\\n        \\n        while queue:\\n            for _ in range(len(queue)):\\n                pos, back, steps = queue.pop()\\n                if pos == x:\\n                    return steps\\n                if valid_position(pos + a, False):\\n                    seen.add((pos+a, back))\\n                    queue.appendleft((pos+a, False, steps+1))\\n                if not back and valid_position(pos-b, True):\\n                    seen.add((pos-b, True))\\n                    queue.appendleft((pos-b, True, steps+1))\\n        return -1                   \\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163359,
                "title": "faster-than-90-and-less-memory-than-92-c",
                "content": "```\\nstruct node{\\n    int   pos;      /* legal jump position */\\n    bool  backflag; /* if this pos is backward point*/\\n    int   jump;     /* step times */\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        node head = {0, false, 0};\\n        queue<node> q;\\n        q.push(head);\\n        bool visited[2001+2*2000] = {false};\\n        bool forbiddenList[2001+2*2000] = {false};\\n        int ret = -1;\\n\\n        for(auto c: forbidden)\\n        {\\n            forbiddenList[c] = true;\\n        }\\n        int backward = 0;\\n        int forward  = 0;\\n        while(q.empty() == false)\\n        {\\n            head = q.front();\\n            q.pop();\\n\\n            if(head.pos == x) /* bingo */\\n            {\\n                ret = head.jump;\\n                break;\\n            }\\n            if(visited[head.pos] == true)\\n                continue;\\n            if(head.backflag == false) //only set to visited when it isn\\'t backward node;\\n                visited[head.pos] = true;\\n\\n            forward  = head.pos + a; //go forward;\\n            backward = head.pos - b; //back;\\n            \\n            //handle the forward pos;\\n            if( (forward < 2000 + 2*2000 + 1)     && \\\\\\n                (forbiddenList[forward] == false) && \\\\\\n                (visited[forward] == false)/* cut the unnecessary path */ )\\n            {\\n                q.push({forward, false, head.jump+1});\\n            }\\n\\n            //handle the backward pos;\\n            if( (backward >0)                      && \\\\\\n                (forbiddenList[backward] == false) && \\\\\\n                (head.backflag == false)           && \\\\\\n                (visited[backward] == false) /* cut the unnecessary path */)\\n            {\\n                 q.push({backward, true, head.jump+1});\\n            }\\n        }\\n        return ret;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct node{\\n    int   pos;      /* legal jump position */\\n    bool  backflag; /* if this pos is backward point*/\\n    int   jump;     /* step times */\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        node head = {0, false, 0};\\n        queue<node> q;\\n        q.push(head);\\n        bool visited[2001+2*2000] = {false};\\n        bool forbiddenList[2001+2*2000] = {false};\\n        int ret = -1;\\n\\n        for(auto c: forbidden)\\n        {\\n            forbiddenList[c] = true;\\n        }\\n        int backward = 0;\\n        int forward  = 0;\\n        while(q.empty() == false)\\n        {\\n            head = q.front();\\n            q.pop();\\n\\n            if(head.pos == x) /* bingo */\\n            {\\n                ret = head.jump;\\n                break;\\n            }\\n            if(visited[head.pos] == true)\\n                continue;\\n            if(head.backflag == false) //only set to visited when it isn\\'t backward node;\\n                visited[head.pos] = true;\\n\\n            forward  = head.pos + a; //go forward;\\n            backward = head.pos - b; //back;\\n            \\n            //handle the forward pos;\\n            if( (forward < 2000 + 2*2000 + 1)     && \\\\\\n                (forbiddenList[forward] == false) && \\\\\\n                (visited[forward] == false)/* cut the unnecessary path */ )\\n            {\\n                q.push({forward, false, head.jump+1});\\n            }\\n\\n            //handle the backward pos;\\n            if( (backward >0)                      && \\\\\\n                (forbiddenList[backward] == false) && \\\\\\n                (head.backflag == false)           && \\\\\\n                (visited[backward] == false) /* cut the unnecessary path */)\\n            {\\n                 q.push({backward, true, head.jump+1});\\n            }\\n        }\\n        return ret;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146906,
                "title": "c-bfs-beats-95",
                "content": "```\\nclass Solution {\\n    struct Bug{\\n        int pos;\\n        bool isBackward;\\n    };\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        if(x == 0)\\n            return 0;\\n\\n        bool isVisited[6001][2] = {false, };\\n        isVisited[0][0] = isVisited[0][1] = true;\\n\\n        for(int num : forbidden) {\\n            isVisited[num][0] = isVisited[num][1] = true;\\n        }\\n\\n        queue<Bug> q;\\n\\n        q.push({0, false});\\n\\n        for(int jump = 0; !q.empty(); jump++) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                Bug bug = q.front();\\n                q.pop();\\n                if(!bug.isBackward && bug.pos >= b && !isVisited[bug.pos - b][1]) {\\n                    isVisited[bug.pos - b][1] = true;\\n                    if(bug.pos - b == x)\\n                        return jump + 1;\\n                    q.push({bug.pos - b, true});\\n                }\\n\\n                if(bug.pos + a <= 6000 && !isVisited[bug.pos + a][0]) {\\n                    isVisited[bug.pos + a][0] = true;\\n                    if(bug.pos + a == x)\\n                        return jump + 1;\\n                    q.push({bug.pos + a, false});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct Bug{\\n        int pos;\\n        bool isBackward;\\n    };\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        if(x == 0)\\n            return 0;\\n\\n        bool isVisited[6001][2] = {false, };\\n        isVisited[0][0] = isVisited[0][1] = true;\\n\\n        for(int num : forbidden) {\\n            isVisited[num][0] = isVisited[num][1] = true;\\n        }\\n\\n        queue<Bug> q;\\n\\n        q.push({0, false});\\n\\n        for(int jump = 0; !q.empty(); jump++) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                Bug bug = q.front();\\n                q.pop();\\n                if(!bug.isBackward && bug.pos >= b && !isVisited[bug.pos - b][1]) {\\n                    isVisited[bug.pos - b][1] = true;\\n                    if(bug.pos - b == x)\\n                        return jump + 1;\\n                    q.push({bug.pos - b, true});\\n                }\\n\\n                if(bug.pos + a <= 6000 && !isVisited[bug.pos + a][0]) {\\n                    isVisited[bug.pos + a][0] = true;\\n                    if(bug.pos + a == x)\\n                        return jump + 1;\\n                    q.push({bug.pos + a, false});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112959,
                "title": "help-me-figure-out-what-s-wrong-with-this-bfs",
                "content": "I\\'m confused as to what is wrong with this BFS, I\\'m assuming only two types of jumps are possible from a particular point, a or a-b, cause two b\\'s can\\'t be together.\\n```\\nint f(vector<bool> &reds, int a, int b, int x){\\n        queue<pair<int,int> > q;\\n        q.push({0,0});\\n        reds[0]=true;\\n        while(!q.empty()){\\n            auto [p,c] = q.front();\\n            q.pop();\\n            if(p==x){\\n                return c;\\n            }\\n            int np = p+a;\\n                if(np>0 && np<=5000 && !reds[np]){\\n                    q.push({np,c+1});\\n                    reds[np]=true;\\n                }\\n            np = p+a-b;\\n                if(np>0 && np<=5000 && !reds[np]){\\n                    q.push({np,c+2});\\n                    reds[np]=true;\\n                }\\n        }\\n        return -1;\\n    }\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<bool> reds(50001,false);\\n        for(int el:forbidden){\\n            reds[el]=true;\\n        }\\n        return f(reds,a,b,x);\\n    }\\n\\t",
                "solutionTags": [],
                "code": "I\\'m confused as to what is wrong with this BFS, I\\'m assuming only two types of jumps are possible from a particular point, a or a-b, cause two b\\'s can\\'t be together.\\n```\\nint f(vector<bool> &reds, int a, int b, int x){\\n        queue<pair<int,int> > q;\\n        q.push({0,0});\\n        reds[0]=true;\\n        while(!q.empty()){\\n            auto [p,c] = q.front();\\n            q.pop();\\n            if(p==x){\\n                return c;\\n            }\\n            int np = p+a;\\n                if(np>0 && np<=5000 && !reds[np]){\\n                    q.push({np,c+1});\\n                    reds[np]=true;\\n                }\\n            np = p+a-b;\\n                if(np>0 && np<=5000 && !reds[np]){\\n                    q.push({np,c+2});\\n                    reds[np]=true;\\n                }\\n        }\\n        return -1;\\n    }\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<bool> reds(50001,false);\\n        for(int el:forbidden){\\n            reds[el]=true;\\n        }\\n        return f(reds,a,b,x);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1103362,
                "title": "python3-bfs",
                "content": "\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        upper = max(forbidden | {x}) + a + b\\n        \\n        ans = 0\\n        queue = [(0, 0)]\\n        forbidden.add(0)\\n        while queue: \\n            newq = []\\n            for n, k in queue: \\n                if n == x: return ans\\n                if n+a <= upper and n+a not in forbidden: \\n                    newq.append((n+a, 0))\\n                    forbidden.add(n+a)\\n                if k == 0 and 0 <= n-b and n-b not in forbidden: \\n                    newq.append((n-b, 1))\\n            ans += 1\\n            queue = newq\\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        upper = max(forbidden | {x}) + a + b\\n        \\n        ans = 0\\n        queue = [(0, 0)]\\n        forbidden.add(0)\\n        while queue: \\n            newq = []\\n            for n, k in queue: \\n                if n == x: return ans\\n                if n+a <= upper and n+a not in forbidden: \\n                    newq.append((n+a, 0))\\n                    forbidden.add(n+a)\\n                if k == 0 and 0 <= n-b and n-b not in forbidden: \\n                    newq.append((n-b, 1))\\n            ans += 1\\n            queue = newq\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101895,
                "title": "why-does-it-not-work-if-i-push-next-in-the-queue-first-and-back-after-that",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<int> s(forbidden.begin(), forbidden.end());\\n        queue<vector<int>> q;\\n        q.push({0, 0, 1});\\n        while(!q.empty()) {\\n            auto it = q.front();\\n            q.pop();\\n            int start = it[0], steps = it[1], jump = it[2];\\n            if(start == x)\\n                return steps;\\n            if(s.find(start) != s.end())\\n                continue;\\n            s.insert(start);\\n            int next = start + a;\\n            int back = start - b;\\n            if(s.find(back) == s.end() && back > 0 && back < 7000 && jump == 1)\\n                q.push({back, steps + 1, 0});\\n            if(s.find(next) == s.end() && next > 0 && next < 7000)\\n                q.push({next, steps + 1, 1});\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<int> s(forbidden.begin(), forbidden.end());\\n        queue<vector<int>> q;\\n        q.push({0, 0, 1});\\n        while(!q.empty()) {\\n            auto it = q.front();\\n            q.pop();\\n            int start = it[0], steps = it[1], jump = it[2];\\n            if(start == x)\\n                return steps;\\n            if(s.find(start) != s.end())\\n                continue;\\n            s.insert(start);\\n            int next = start + a;\\n            int back = start - b;\\n            if(s.find(back) == s.end() && back > 0 && back < 7000 && jump == 1)\\n                q.push({back, steps + 1, 0});\\n            if(s.find(next) == s.end() && next > 0 && next < 7000)\\n                q.push({next, steps + 1, 1});\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086369,
                "title": "c-top-down-recursive-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[2][6005];\\n    int fun(int idx,int a,int b,int x,int back)\\n    {\\n         if(idx==x)\\n            return 0;\\n        if(idx>=6005||idx<0||dp[back][idx]==-2)\\n        {\\n            return 1e9;\\n        }\\n        \\n        if(dp[back][idx]!=-1)\\n            return dp[back][idx];\\n        \\n        \\n        dp[back][idx]=1+fun(idx+a,a,b,x,0);\\n        if(!back&&a!=b)\\n        {\\n            dp[back][idx]=min(dp[back][idx],1+fun(idx-b,a,b,x,1));\\n        }\\n        \\n        return dp[back][idx];\\n    }               \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        if(x==0)\\n            return 0;\\n        int i,n=forbidden.size();\\n        for(i=0;i<6005;i++)\\n        {\\n            dp[0][i]=-1;\\n            dp[1][i]=-1;\\n        }\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            dp[0][forbidden[i]]=-2;\\n            dp[1][forbidden[i]]=-2;\\n        }\\n        \\n        int res=fun(0,a,b,x,0);\\n        if(res>=1e9)\\n            return -1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[2][6005];\\n    int fun(int idx,int a,int b,int x,int back)\\n    {\\n         if(idx==x)\\n            return 0;\\n        if(idx>=6005||idx<0||dp[back][idx]==-2)\\n        {\\n            return 1e9;\\n        }\\n        \\n        if(dp[back][idx]!=-1)\\n            return dp[back][idx];\\n        \\n        \\n        dp[back][idx]=1+fun(idx+a,a,b,x,0);\\n        if(!back&&a!=b)\\n        {\\n            dp[back][idx]=min(dp[back][idx],1+fun(idx-b,a,b,x,1));\\n        }\\n        \\n        return dp[back][idx];\\n    }               \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        if(x==0)\\n            return 0;\\n        int i,n=forbidden.size();\\n        for(i=0;i<6005;i++)\\n        {\\n            dp[0][i]=-1;\\n            dp[1][i]=-1;\\n        }\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            dp[0][forbidden[i]]=-2;\\n            dp[1][forbidden[i]]=-2;\\n        }\\n        \\n        int res=fun(0,a,b,x,0);\\n        if(res>=1e9)\\n            return -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065457,
                "title": "both-dfs-memoization-and-bfs-solutions-python",
                "content": "DFS + Memoization\\n\\n```\\nclass Solution(object):\\n    def is_pos_valid(self, pos, forbidden_map):\\n        if pos in forbidden_map or pos < 0:\\n            return False\\n        return True\\n    \\n    def calculate_jumps(self, dp, pos, b_jump, fwd, bwd):\\n        if fwd < 0 and bwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = -1\\n            return -1\\n        elif fwd >= 0 and bwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = fwd + 1\\n            return fwd + 1\\n        elif bwd >= 0 and fwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = bwd + 1\\n            return bwd + 1\\n        \\n        dp[str(pos) + \"$\" + str(b_jump)] = min(fwd, bwd) + 1\\n        \\n        return min(fwd, bwd) + 1\\n        \\n    def get_min_jumps(self, a, b, x, forbidden_map, current_pos, jumps, dp, visited, b_jumps):\\n        if str(current_pos) + \"$\" + str(b_jumps) in dp:            \\n            return dp[str(current_pos) + \"$\" + str(b_jumps)]\\n        \\n        if current_pos in visited and visited[current_pos]:\\n            return -1\\n        \\n        if not self.is_pos_valid(current_pos, forbidden_map):\\n            return -1\\n        \\n        if current_pos > 2000+a+b:\\n            return -1\\n            \\n        if b_jumps >= 2:\\n            return -1\\n        \\n        if current_pos == x:\\n            return 0\\n               \\n        visited[current_pos] = True\\n        fwd = self.get_min_jumps(a, b, x, forbidden_map, current_pos+a, jumps, dp, visited, 0)\\n        bwd = self.get_min_jumps(a, b, x, forbidden_map, current_pos-b, jumps, dp, visited, b_jumps+1)\\n        visited[current_pos] = False\\n        \\n        return self.calculate_jumps(dp, current_pos, b_jumps, fwd, bwd)\\n    \\n    def create_forbidden_map(self, forbidden):\\n        forbidden_map = {}\\n        for pos in forbidden:\\n            forbidden_map[pos] = True\\n            \\n        return forbidden_map\\n            \\n    def minimumJumps(self, forbidden, a, b, x):\\n        max_num = pow(10, 7)\\n        forbidden_map = self.create_forbidden_map(forbidden)\\n        dp = {}\\n        return self.get_min_jumps(a,b,x,forbidden_map,0, 0, dp, {}, 0)\\n```\\n\\n\\n=============\\n\\nBFS Solution\\n\\n```\\nclass Solution(object):\\n    def get_key(self, pos, b_jump):\\n        return str(pos) + \"$\" + str(b_jump)\\n    \\n    def is_pos_valid(self, pos, forbidden_map):\\n        if pos in forbidden_map or pos < 0:\\n            return False\\n        return True\\n    \\n    def create_forbidden_map(self, forbidden):\\n        forbidden_map = {}\\n        for pos in forbidden:\\n            forbidden_map[pos] = True\\n            \\n        return forbidden_map\\n        \\n    def get_min_jumps(self, a, b, x, forbidden_map, bfs):\\n        q = deque()\\n        q.append(bfs)\\n        visited = {}\\n        visited[self.get_key(0, 0)] = True\\n        limit = 2000 + a + b\\n        \\n        while len(q) > 0:\\n            element = q.popleft()\\n            pos = element[0]\\n            b_jumps = element[1]\\n            jumps = element[2]\\n            \\n            if pos == x:\\n                return jumps\\n            \\n            if self.is_pos_valid(pos+a, forbidden_map) and self.get_key(pos+a, 0) not in visited and pos < limit:\\n                visited[self.get_key(pos+a, 0)] = True\\n                q.append([pos+a, 0, jumps+1])\\n            if b_jumps != 1:\\n                if self.is_pos_valid(pos-b, forbidden_map) and self.get_key(pos-b, 1) not in visited and pos < limit:\\n                    visited[self.get_key(pos-b, 1)] = True\\n                    q.append([pos-b, 1, jumps+1])\\n                    \\n        return -1\\n            \\n    def minimumJumps(self, forbidden, a, b, x):\\n        forbidden_map = self.create_forbidden_map(forbidden)\\n        return self.get_min_jumps(a,b,x,forbidden_map, [0, 0, 0])\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def is_pos_valid(self, pos, forbidden_map):\\n        if pos in forbidden_map or pos < 0:\\n            return False\\n        return True\\n    \\n    def calculate_jumps(self, dp, pos, b_jump, fwd, bwd):\\n        if fwd < 0 and bwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = -1\\n            return -1\\n        elif fwd >= 0 and bwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = fwd + 1\\n            return fwd + 1\\n        elif bwd >= 0 and fwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = bwd + 1\\n            return bwd + 1\\n        \\n        dp[str(pos) + \"$\" + str(b_jump)] = min(fwd, bwd) + 1\\n        \\n        return min(fwd, bwd) + 1\\n        \\n    def get_min_jumps(self, a, b, x, forbidden_map, current_pos, jumps, dp, visited, b_jumps):\\n        if str(current_pos) + \"$\" + str(b_jumps) in dp:            \\n            return dp[str(current_pos) + \"$\" + str(b_jumps)]\\n        \\n        if current_pos in visited and visited[current_pos]:\\n            return -1\\n        \\n        if not self.is_pos_valid(current_pos, forbidden_map):\\n            return -1\\n        \\n        if current_pos > 2000+a+b:\\n            return -1\\n            \\n        if b_jumps >= 2:\\n            return -1\\n        \\n        if current_pos == x:\\n            return 0\\n               \\n        visited[current_pos] = True\\n        fwd = self.get_min_jumps(a, b, x, forbidden_map, current_pos+a, jumps, dp, visited, 0)\\n        bwd = self.get_min_jumps(a, b, x, forbidden_map, current_pos-b, jumps, dp, visited, b_jumps+1)\\n        visited[current_pos] = False\\n        \\n        return self.calculate_jumps(dp, current_pos, b_jumps, fwd, bwd)\\n    \\n    def create_forbidden_map(self, forbidden):\\n        forbidden_map = {}\\n        for pos in forbidden:\\n            forbidden_map[pos] = True\\n            \\n        return forbidden_map\\n            \\n    def minimumJumps(self, forbidden, a, b, x):\\n        max_num = pow(10, 7)\\n        forbidden_map = self.create_forbidden_map(forbidden)\\n        dp = {}\\n        return self.get_min_jumps(a,b,x,forbidden_map,0, 0, dp, {}, 0)\\n```\n```\\nclass Solution(object):\\n    def get_key(self, pos, b_jump):\\n        return str(pos) + \"$\" + str(b_jump)\\n    \\n    def is_pos_valid(self, pos, forbidden_map):\\n        if pos in forbidden_map or pos < 0:\\n            return False\\n        return True\\n    \\n    def create_forbidden_map(self, forbidden):\\n        forbidden_map = {}\\n        for pos in forbidden:\\n            forbidden_map[pos] = True\\n            \\n        return forbidden_map\\n        \\n    def get_min_jumps(self, a, b, x, forbidden_map, bfs):\\n        q = deque()\\n        q.append(bfs)\\n        visited = {}\\n        visited[self.get_key(0, 0)] = True\\n        limit = 2000 + a + b\\n        \\n        while len(q) > 0:\\n            element = q.popleft()\\n            pos = element[0]\\n            b_jumps = element[1]\\n            jumps = element[2]\\n            \\n            if pos == x:\\n                return jumps\\n            \\n            if self.is_pos_valid(pos+a, forbidden_map) and self.get_key(pos+a, 0) not in visited and pos < limit:\\n                visited[self.get_key(pos+a, 0)] = True\\n                q.append([pos+a, 0, jumps+1])\\n            if b_jumps != 1:\\n                if self.is_pos_valid(pos-b, forbidden_map) and self.get_key(pos-b, 1) not in visited and pos < limit:\\n                    visited[self.get_key(pos-b, 1)] = True\\n                    q.append([pos-b, 1, jumps+1])\\n                    \\n        return -1\\n            \\n    def minimumJumps(self, forbidden, a, b, x):\\n        forbidden_map = self.create_forbidden_map(forbidden)\\n        return self.get_min_jumps(a,b,x,forbidden_map, [0, 0, 0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055681,
                "title": "javascript-bfs-solution-with-exmplanation",
                "content": "What I learned from this problem:\\n- reason why the limit is `2000+b`. the limit should be larger than the `(x+b)` or `forbidden_MAX+b`, due to the constraints, both `x` & `forbidden[i]` have a max value of 2000.\\n- use `datastructure/Queue`  or just Array, here just use Array is enough, because no sorting.\\n- destructure from array in ES6( [docs](https://googlechrome.github.io/samples/destructuring-es6/) )\\n\\n\\n```js\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    // 0 ------ x ---- x+b ----^\\n    //                 <------left\\n    var visited = new Set(forbidden);\\n    var limit = 2000+b; // max(x, forbidden_MAX) + b\\n    var q = [[0,0]];\\n    var step = 0;\\n    while(q.length>0)\\n    {\\n        var size = q.length;\\n        while(size>0)\\n        {\\n            var [cur,dir] = q.shift();\\n            size--;\\n            if(cur===x)\\n            {\\n                return step;\\n            }\\n            if(visited.has(cur))\\n            {\\n                continue;\\n            }\\n            visited.add(cur);\\n            if(dir === 0 && cur-b>=0)\\n            {\\n                q.push([cur-b, 1]);\\n            } \\n            if( cur <= limit )\\n            {\\n                q.push([cur+a, 0]);   \\n            }\\n           \\n        }\\n        step++;\\n    } // end while queue\\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    // 0 ------ x ---- x+b ----^\\n    //                 <------left\\n    var visited = new Set(forbidden);\\n    var limit = 2000+b; // max(x, forbidden_MAX) + b\\n    var q = [[0,0]];\\n    var step = 0;\\n    while(q.length>0)\\n    {\\n        var size = q.length;\\n        while(size>0)\\n        {\\n            var [cur,dir] = q.shift();\\n            size--;\\n            if(cur===x)\\n            {\\n                return step;\\n            }\\n            if(visited.has(cur))\\n            {\\n                continue;\\n            }\\n            visited.add(cur);\\n            if(dir === 0 && cur-b>=0)\\n            {\\n                q.push([cur-b, 1]);\\n            } \\n            if( cur <= limit )\\n            {\\n                q.push([cur+a, 0]);   \\n            }\\n           \\n        }\\n        step++;\\n    } // end while queue\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1006979,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n        if (x == 0)\\n            return 0;\\n        \\n        vector<vector<int>> steps(2, vector<int>(6001, INT_MAX));\\n        \\n        for(int i = 0; i < forbidden.size(); i++) \\n        {\\n            if(forbidden[i] < steps[0].size())\\n                steps[0][forbidden[i]] = steps[1][forbidden[i]] = -1;\\n        }\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        int step = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int pos = q.front().first;\\n                int dir = q.front().second;\\n                if(pos == x)\\n                    goto end;\\n                \\n                if (pos + a < steps[0].size() && steps[0][pos + a] == INT_MAX) {\\n                    steps[0][pos + a] = 1 + step;\\n                    q.push({pos + a, 0});\\n                }\\n                \\n                if (dir == 0 && pos - b >= 0 && steps[1][pos - b] == INT_MAX) {\\n                    steps[1][pos - b] = 1 + step;\\n                    q.push({pos - b, 1});\\n                }\\n                q.pop();\\n            }\\n            step++;    \\n        }\\n    end:\\n        int res = min(steps[0][x], steps[1][x]);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n        if (x == 0)\\n            return 0;\\n        \\n        vector<vector<int>> steps(2, vector<int>(6001, INT_MAX));\\n        \\n        for(int i = 0; i < forbidden.size(); i++) \\n        {\\n            if(forbidden[i] < steps[0].size())\\n                steps[0][forbidden[i]] = steps[1][forbidden[i]] = -1;\\n        }\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        int step = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int pos = q.front().first;\\n                int dir = q.front().second;\\n                if(pos == x)\\n                    goto end;\\n                \\n                if (pos + a < steps[0].size() && steps[0][pos + a] == INT_MAX) {\\n                    steps[0][pos + a] = 1 + step;\\n                    q.push({pos + a, 0});\\n                }\\n                \\n                if (dir == 0 && pos - b >= 0 && steps[1][pos - b] == INT_MAX) {\\n                    steps[1][pos - b] = 1 + step;\\n                    q.push({pos - b, 1});\\n                }\\n                q.pop();\\n            }\\n            step++;    \\n        }\\n    end:\\n        int res = min(steps[0][x], steps[1][x]);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003679,
                "title": "wrong-example-in-example-2-why-is-it-1-when-there-exists-a-solution",
                "content": "```\\nExample 2:\\n    Input: forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\\n    Output: -1\\nSolution: [15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 167, 154, 141, 128, 115, 102, 89, 76, 63, 50, 37, 24, 11]\\nSolution in 25 steps. \\n```\\nWhy is this solution wrong?",
                "solutionTags": [],
                "code": "```\\nExample 2:\\n    Input: forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\\n    Output: -1\\nSolution: [15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 167, 154, 141, 128, 115, 102, 89, 76, 63, 50, 37, 24, 11]\\nSolution in 25 steps. \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1002763,
                "title": "bfs-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\t\\tconst int n=6000;\\n\\t\\t\\tint v[n][2];\\n\\t\\t\\tmemset(v,-1,sizeof v);\\n\\t\\t\\tv[0][0]=v[0][1]=0;\\n\\t\\t\\tfor(int i:forbidden)v[i][0]=v[i][1]=INT_MAX;\\n\\t\\t\\tqueue<pair<int,bool>>q;\\n\\t\\t\\tq.push({0,1});\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint num=q.front().first;\\n\\t\\t\\t\\tbool ch=q.front().second;\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tif(num==x)return v[num][ch];\\n\\t\\t\\t\\tif(num+a<n&&v[num+a][0]==-1)\\n\\t\\t\\t\\t\\tq.push({num+a,0}),v[num+a][0]=v[num][ch]+1;\\n\\n\\t\\t\\t\\tif(!ch&&num-b>0&&v[num-b][1]==-1)\\n\\t\\t\\t\\t\\tq.push({num-b,1}),v[num-b][1]=v[num][ch]+1;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\t\\tconst int n=6000;\\n\\t\\t\\tint v[n][2];\\n\\t\\t\\tmemset(v,-1,sizeof v);\\n\\t\\t\\tv[0][0]=v[0][1]=0;\\n\\t\\t\\tfor(int i:forbidden)v[i][0]=v[i][1]=INT_MAX;\\n\\t\\t\\tqueue<pair<int,bool>>q;\\n\\t\\t\\tq.push({0,1}",
                "codeTag": "Java"
            },
            {
                "id": 958328,
                "title": "bfs-c",
                "content": "class Solution {\\n\\tpublic:\\n\\t\\n\\t\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int, int> m;\\n        bool visited[2][10000];\\n\\t\\t\\n\\t\\t\\n\\t\\t\\t// visited[ 0 ][ K ] = true ; means the Kth cell was reached by jumping forward,\\n\\t\\t\\t// visited[ 1 ][ K ] = true ; means the Kth cell was reached by jumping backward. \\n        memset(visited, false, sizeof(visited));\\n        queue<pair<int, int>> q;\\n\\t\\t\\t// queue<pair<val, 0>> indicates the val is obtained by moving forward\\n\\t\\t\\t//queue<pair<val, 1>> indicates the val is obtained by movind backward and so we cannot move backward again in this step\\n        pair<int, int> p;\\n        int level=0, size, forward, backward;\\n        q.push(make_pair(0, 0));\\n        \\n        for(int val : forbidden) \\n            m[val]=1;       //  m[val]==1 , means it is forbidden\\n    \\n        while(!q.empty())\\n        {\\n            size=q.size();\\n            while(size)\\n            {\\n                size--;\\n                p=q.front();\\n                q.pop();\\n                if(p.first==x)\\n                    return level;\\n                \\n                forward=p.first+a;\\n                backward=p.first-b;\\n                \\n                if(forward<6000 && m.find(forward)==m.end() && !visited[0][forward])\\n                {    \\n                    q.push(make_pair(forward, 0));\\n                    visited[0][forward]=true;\\n                }\\n                if(p.second==0 && p.first-b>0 && m.find(backward)==m.end() && !visited[1][backward])\\n                {\\n                    q.push(make_pair(backward, 1));\\n                    visited[1][backward]=true;\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\n\\t\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int, int> m;\\n        bool visited[2][10000];\\n\\t\\t\\n\\t\\t\\n\\t\\t\\t// visited[ 0 ][ K ] = true ; means the Kth cell was reached by jumping forward,\\n\\t\\t\\t// visited[ 1 ][ K ] = true ; means the Kth cell was reached by jumping backward. \\n        memset(visited, false, sizeof(visited));\\n        queue<pair<int, int>> q;\\n\\t\\t\\t// queue<pair<val, 0>> indicates the val is obtained by moving forward\\n\\t\\t\\t//queue<pair<val, 1>> indicates the val is obtained by movind backward and so we cannot move backward again in this step\\n        pair<int, int> p;\\n        int level=0, size, forward, backward;\\n        q.push(make_pair(0, 0));\\n        \\n        for(int val : forbidden) \\n            m[val]=1;       //  m[val]==1 , means it is forbidden\\n    \\n        while(!q.empty())\\n        {\\n            size=q.size();\\n            while(size)\\n            {\\n                size--;\\n                p=q.front();\\n                q.pop();\\n                if(p.first==x)\\n                    return level;\\n                \\n                forward=p.first+a;\\n                backward=p.first-b;\\n                \\n                if(forward<6000 && m.find(forward)==m.end() && !visited[0][forward])\\n                {    \\n                    q.push(make_pair(forward, 0));\\n                    visited[0][forward]=true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 953184,
                "title": "easy-c-bfs-solution",
                "content": "visited matrix to be marked as done when we can visit forward as well as backward from that particular index.\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        unordered_set<int> forbiddenSet(forbidden.begin() , forbidden.end());\\n        \\n        queue<pair<int, bool>> q;\\n        q.push({0,false});\\n        bool isBackward = false;\\n        vector<pair<bool, bool>> visited( 6000, {false,false}); // to check if we have visited both forard and backward from the index.\\n        int steps = 0;\\n        visited[0].first = false;\\n        visited[0].second = false;\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            while(n != 0)\\n            {\\n                auto temp = q.front();\\n                q.pop();\\n                \\n                if( temp.first == x)\\n                    return steps;\\n                \\n                int forward = temp.first+a;\\n                if( forward < 6000 and !forbiddenSet.count(forward) and visited[temp.first].first == false)\\n                {\\n                    q.push({forward,false});\\n                    visited[temp.first].first = true;\\n                }\\n                \\n                if(!temp.second)\\n                {\\n                    int backward = temp.first-b;\\n                    if( backward >= 0 and !forbiddenSet.count(backward)  and visited[temp.first].second == false)\\n                    {\\n                        q.push({backward,true});\\n                        visited[temp.first].second = true;\\n                    }\\n                }\\n                n--;\\n            }\\n            steps++;\\n        }\\n        return -1;       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        unordered_set<int> forbiddenSet(forbidden.begin() , forbidden.end());\\n        \\n        queue<pair<int, bool>> q;\\n        q.push({0,false});\\n        bool isBackward = false;\\n        vector<pair<bool, bool>> visited( 6000, {false,false}); // to check if we have visited both forard and backward from the index.\\n        int steps = 0;\\n        visited[0].first = false;\\n        visited[0].second = false;\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            while(n != 0)\\n            {\\n                auto temp = q.front();\\n                q.pop();\\n                \\n                if( temp.first == x)\\n                    return steps;\\n                \\n                int forward = temp.first+a;\\n                if( forward < 6000 and !forbiddenSet.count(forward) and visited[temp.first].first == false)\\n                {\\n                    q.push({forward,false});\\n                    visited[temp.first].first = true;\\n                }\\n                \\n                if(!temp.second)\\n                {\\n                    int backward = temp.first-b;\\n                    if( backward >= 0 and !forbiddenSet.count(backward)  and visited[temp.first].second == false)\\n                    {\\n                        q.push({backward,true});\\n                        visited[temp.first].second = true;\\n                    }\\n                }\\n                n--;\\n            }\\n            steps++;\\n        }\\n        return -1;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951091,
                "title": "easiest-approach-c-explaining-1998-1999-2000-2000-test-case-bfs",
                "content": "**I have applied restriction by 5998 because a=1999,b=2000,x=2000\\nAt max we can make a forward jump of max(a,b)+x\\nWhy?Because we can only make a single backward jump at once and if the region of finding x is in [2000,4000] and we go move any further beyond this range for example 4005 then we wont be able to reach our target x=2000 as 4005(a)-2000(b)=2005 which is inside our range but now we cant move further back because at max only 1 backward jump is allowed . So for the test case beyond the range i have rejected it.\\n**\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int>map(forbidden.begin(),forbidden.end());\\n        \\n        queue<pair<int,bool>>q;\\n        vector<vector<int>>vis(2,vector<int>(5998));// for the test case when a=1999 and b=2000 after 3 iterations value of a would 1999*3=5997 which would be less than 5998 that size needed to mark it visited.\\n        \\n       ** //Imp jump can be at max=max(a,b)+x because after that we cant go back as only 1 backward jump allowed at once**\\n        q.push({0,false});\\n        vis[0][0]=1;\\n        vis[1][0]=1;\\n        int ans=0;\\n        while(q.size()!=0){\\n            int n=q.size();\\n            while(n-->0){\\n                int cur=q.front().first;\\n                bool flag=q.front().second;\\n                if(cur==x){\\n                    return ans;\\n                }\\n                q.pop();\\n                int forw=cur+a;\\n                int back=cur-b;\\n                if(forw<5998 && vis[0][forw]==0 && !map.count(forw)){\\n                    q.push({forw,false});\\n                    vis[0][forw]=1;\\n                }\\n                if(back>=0 && vis[1][back]==0 && !map.count(back) && !flag){\\n                    q.push({back,true});\\n                    vis[1][back]=1;\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int>map(forbidden.begin(),forbidden.end());\\n        \\n        queue<pair<int,bool>>q;\\n        vector<vector<int>>vis(2,vector<int>(5998));// for the test case when a=1999 and b=2000 after 3 iterations value of a would 1999*3=5997 which would be less than 5998 that size needed to mark it visited.\\n        \\n       ** //Imp jump can be at max=max(a,b)+x because after that we cant go back as only 1 backward jump allowed at once**\\n        q.push({0,false}",
                "codeTag": "Java"
            },
            {
                "id": 938985,
                "title": "working-code-passing-all-testcases",
                "content": "Most codes are failing the testcase where the value could go above 4000 , Value can go above 4000 and then come back down ...\\n```\\nclass Solution {\\npublic:\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n        int c=0;\\n        q.push({-1});\\n        map<vector<int>,bool> visited;\\n        map<int,int> f;\\n        for(int i=0;i<forbidden.size();i++)\\n        {\\n            f[forbidden[i]]++;\\n        }\\n        while(q.size()>1)\\n        {\\n           vector<int> v = q.front();\\n            int front = v[0];\\n            cout<<front<<endl;\\n            q.pop();\\n            if(front>6000)\\n                continue;\\n            if(front ==-1)\\n           {\\n               c++;\\n               q.push({-1});\\n               continue;\\n           }\\n             if(visited[v]==1)\\n                continue;\\n            visited[v]=1;\\n            int back = v[1];\\n              if(front==x)\\n                return c;\\n            int z = front +a;\\n            int y = front - b;\\n            if(f[z]==false)\\n            {\\n                q.push({z,0});\\n            }\\n            if(back!=1)\\n            {\\n            if(f[y]==false&&y>=0)\\n            {\\n                q.push({y,1});\\n            }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n        int c=0;\\n        q.push({-1});\\n        map<vector<int>,bool> visited;\\n        map<int,int> f;\\n        for(int i=0;i<forbidden.size();i++)\\n        {\\n            f[forbidden[i]]++;\\n        }\\n        while(q.size()>1)\\n        {\\n           vector<int> v = q.front();\\n            int front = v[0];\\n            cout<<front<<endl;\\n            q.pop();\\n            if(front>6000)\\n                continue;\\n            if(front ==-1)\\n           {\\n               c++;\\n               q.push({-1});\\n               continue;\\n           }\\n             if(visited[v]==1)\\n                continue;\\n            visited[v]=1;\\n            int back = v[1];\\n              if(front==x)\\n                return c;\\n            int z = front +a;\\n            int y = front - b;\\n            if(f[z]==false)\\n            {\\n                q.push({z,0});\\n            }\\n            if(back!=1)\\n            {\\n            if(f[y]==false&&y>=0)\\n            {\\n                q.push({y,1});\\n            }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 937899,
                "title": "python-bfs-with-double-queue-80ms",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x == 0: return 0\\n        forb = set(forbidden)\\n        mx = x + a if a >= b else max(x, *forbidden) + a + b\\n        queueA, queueB = [], [0]\\n        count = 0\\n        while queueA or queueB:\\n            qA, qB = [], []\\n\\n            for v in queueA + queueB:\\n                if v == x: return count\\n                n = v + a\\n                if n in forb or n > mx: continue\\n\\n                qA.append(n); forb.add(n)\\n                \\n            for v in queueA:\\n                n = v - b\\n                if n in forb or n <= 0: continue\\n\\n                qB.append(n); forb.add(n)\\n\\n            queueA, queueB = qA, qB\\n            count += 1\\n            \\n        return -1\\n```\\n* *queueA* is created after forward steps\\n* *queueB* is created after backward steps\\n* if *a >= b* then maximum position is not depending on *b* or *forbidden*\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x == 0: return 0\\n        forb = set(forbidden)\\n        mx = x + a if a >= b else max(x, *forbidden) + a + b\\n        queueA, queueB = [], [0]\\n        count = 0\\n        while queueA or queueB:\\n            qA, qB = [], []\\n\\n            for v in queueA + queueB:\\n                if v == x: return count\\n                n = v + a\\n                if n in forb or n > mx: continue\\n\\n                qA.append(n); forb.add(n)\\n                \\n            for v in queueA:\\n                n = v - b\\n                if n in forb or n <= 0: continue\\n\\n                qB.append(n); forb.add(n)\\n\\n            queueA, queueB = qA, qB\\n            count += 1\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936339,
                "title": "bfs",
                "content": "Neighbours is formed by the current state of the node.\\nIf current state has moved forward, then we can go either back or forward.\\nIf current state has moved backward, then we can only go forward.\\n\\n\\n```\\n    fun minimumJumps(forbidden: IntArray, a: Int, b: Int, target: Int): Int {\\n        val banned = forbidden.toSet()\\n\\t\\tval max = forbidden.max()!! + a + b + target\\n        val queue: Queue<Pair<Int, Boolean>> = LinkedList()\\n        val dist: MutableMap<Pair<Int, Boolean>, Int> = HashMap()\\n        queue.offer(0 to true)\\n        dist[0 to true] = 0\\n        \\n        fun neighbours(node: Pair<Int, Boolean>): List<Pair<Int, Boolean>> {\\n            val ans: MutableList<Pair<Int, Boolean>> = ArrayList()\\n            var (loc, canGoBack) = node\\n            var newLoc = loc + a\\n            if (newLoc < max && banned.contains(newLoc).not()) {\\n                ans.add(newLoc to true)\\n            }\\n            if (canGoBack) {\\n                newLoc = loc - b\\n                if (newLoc >= 0 && banned.contains(newLoc).not()) {\\n                    ans.add(newLoc to false)\\n                }\\n            }\\n            return ans\\n        }\\n        \\n        while (queue.isNotEmpty()) {\\n            val node = queue.poll()\\n            if (node.first == target) {\\n                return dist[node]!!\\n            }\\n            for (nei in neighbours(node)) {\\n                if (dist.contains(nei).not()) {\\n                    dist[nei] = 1 + dist[node]!!\\n                    queue.offer(nei)\\n                }\\n            }\\n        }\\n        \\n        return -1\\n    }\\n```\\n\\nSource: https://bit.ly/36AlnAl",
                "solutionTags": [
                    "Kotlin",
                    "Breadth-First Search"
                ],
                "code": "```\\n    fun minimumJumps(forbidden: IntArray, a: Int, b: Int, target: Int): Int {\\n        val banned = forbidden.toSet()\\n\\t\\tval max = forbidden.max()!! + a + b + target\\n        val queue: Queue<Pair<Int, Boolean>> = LinkedList()\\n        val dist: MutableMap<Pair<Int, Boolean>, Int> = HashMap()\\n        queue.offer(0 to true)\\n        dist[0 to true] = 0\\n        \\n        fun neighbours(node: Pair<Int, Boolean>): List<Pair<Int, Boolean>> {\\n            val ans: MutableList<Pair<Int, Boolean>> = ArrayList()\\n            var (loc, canGoBack) = node\\n            var newLoc = loc + a\\n            if (newLoc < max && banned.contains(newLoc).not()) {\\n                ans.add(newLoc to true)\\n            }\\n            if (canGoBack) {\\n                newLoc = loc - b\\n                if (newLoc >= 0 && banned.contains(newLoc).not()) {\\n                    ans.add(newLoc to false)\\n                }\\n            }\\n            return ans\\n        }\\n        \\n        while (queue.isNotEmpty()) {\\n            val node = queue.poll()\\n            if (node.first == target) {\\n                return dist[node]!!\\n            }\\n            for (nei in neighbours(node)) {\\n                if (dist.contains(nei).not()) {\\n                    dist[nei] = 1 + dist[node]!!\\n                    queue.offer(nei)\\n                }\\n            }\\n        }\\n        \\n        return -1\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935851,
                "title": "java-very-simple-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        var forbid = new HashSet<Integer>();\\n        for(int i : forbidden) forbid.add(i);\\n        \\n        var visited = new int[2*2000];\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        q.add(0); // at\\n        q.add(0); // #jumps\\n        q.add(0); // isBackward\\n        \\n        while(!q.isEmpty())\\n        {\\n            int at = q.remove();\\n            int j = q.remove();\\n            int isback = q.remove();\\n            \\n            if(at == x) return j;\\n            \\n            if(at+a < 2*2000 && !forbid.contains(at+a) && visited[at+a] < 4) \\n                {q.add(at+a); q.add(j+1); q.add(0); visited[at+a]++;}\\n            if(isback == 0 && at >= b && !forbid.contains(at-b) && visited[at-b] < 4)\\n                {q.add(at-b); q.add(j+1); q.add(1); visited[at-b]++;}\\n        }\\n        \\n        return -1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        var forbid = new HashSet<Integer>();\\n        for(int i : forbidden) forbid.add(i);\\n        \\n        var visited = new int[2*2000];\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        q.add(0); // at\\n        q.add(0); // #jumps\\n        q.add(0); // isBackward\\n        \\n        while(!q.isEmpty())\\n        {\\n            int at = q.remove();\\n            int j = q.remove();\\n            int isback = q.remove();\\n            \\n            if(at == x) return j;\\n            \\n            if(at+a < 2*2000 && !forbid.contains(at+a) && visited[at+a] < 4) \\n                {q.add(at+a); q.add(j+1); q.add(0); visited[at+a]++;}\\n            if(isback == 0 && at >= b && !forbid.contains(at-b) && visited[at-b] < 4)\\n                {q.add(at-b); q.add(j+1); q.add(1); visited[at-b]++;}\\n        }\\n        \\n        return -1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935810,
                "title": "java-bfs-set-pair-avoid-fixed-size-visited-array",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\\n        Set<Pair<Integer, Integer>> set = new HashSet<>();\\n        int max = a + b + x;\\n        for (int i = 0; i < forbidden.length; i++) {\\n            set.add(new Pair<Integer, Integer>(forbidden[i], 0));\\n            set.add(new Pair<Integer, Integer>(forbidden[i], 1));\\n            max = Math.max(max, forbidden[i] + a + b);\\n        }\\n        queue.offer(new Pair<Integer, Integer>(0, 0));\\n        set.add(queue.peek());\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                Pair<Integer, Integer> p = queue.poll();\\n                if (p.getKey() == x) return steps;\\n                Pair<Integer, Integer> next = new Pair<Integer, Integer>(p.getKey() + a, 0);\\n                Pair<Integer, Integer> prev = new Pair<Integer, Integer>(p.getKey() - b, p.getValue() + 1);\\n                if (next.getKey() <= max && !set.contains(next)) {\\n                    set.add(next);\\n                    queue.offer(next);\\n                }\\n                if (prev.getKey() >= 0 && !set.contains(prev) && prev.getValue() < 2) {\\n                    set.add(prev);\\n                    queue.offer(prev);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\\n        Set<Pair<Integer, Integer>> set = new HashSet<>();\\n        int max = a + b + x;\\n        for (int i = 0; i < forbidden.length; i++) {\\n            set.add(new Pair<Integer, Integer>(forbidden[i], 0));\\n            set.add(new Pair<Integer, Integer>(forbidden[i], 1));\\n            max = Math.max(max, forbidden[i] + a + b);\\n        }\\n        queue.offer(new Pair<Integer, Integer>(0, 0));\\n        set.add(queue.peek());\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                Pair<Integer, Integer> p = queue.poll();\\n                if (p.getKey() == x) return steps;\\n                Pair<Integer, Integer> next = new Pair<Integer, Integer>(p.getKey() + a, 0);\\n                Pair<Integer, Integer> prev = new Pair<Integer, Integer>(p.getKey() - b, p.getValue() + 1);\\n                if (next.getKey() <= max && !set.contains(next)) {\\n                    set.add(next);\\n                    queue.offer(next);\\n                }\\n                if (prev.getKey() >= 0 && !set.contains(prev) && prev.getValue() < 2) {\\n                    set.add(prev);\\n                    queue.offer(prev);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935524,
                "title": "java-with-no-need-to-track-state-beats-100",
                "content": "For the life of me I cannot understand why people insist on tacking state (do we go backwards or forwards) in a solution like mine.\\n\\nOnly put positions into the queue that you reached on going back.\\nAnd only go forward from those positions that are in the queue.\\n\\n```\\n\\tfinal private Set<Integer> fset = new HashSet<>();\\n\\tprivate int[] axis;\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x==0)\\n\\t\\t\\treturn 0;\\n\\t\\tfor (int f : forbidden)\\n\\t\\t\\tfset.add(f);\\n\\t\\tif (fset.contains(a) || fset.contains(x))\\n\\t\\t\\treturn -1;\\n\\n\\t\\tint maxLen=10000;\\n\\t\\t\\n\\t\\taxis=new int[maxLen];\\n\\t\\tArrays.fill(axis, -1);\\n\\t\\taxis[0]=0;\\n\\t\\taxis[a]=1;\\n\\t\\tint cnt=1;\\n\\t\\tQueue<Integer> backs = new LinkedList<>();\\n\\t\\tfor (int i=a;i<maxLen;i+=a) {\\n\\t\\t\\tif (fset.contains(i))\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tif (i==x)\\n\\t\\t\\t\\treturn cnt;\\n\\t\\t\\taxis[i]=cnt;\\n\\t\\t\\tcnt++;\\n\\t\\t\\tif (i-b>0 && axis[i-b]<0 && !fset.contains(i-b))\\n\\t\\t\\t\\tbacks.add(i-b);\\n\\t\\t}\\n\\t\\tif (b==a)\\n\\t\\t\\treturn -1;\\n\\n\\t\\twhile (!backs.isEmpty()) {\\n\\t\\t\\tint size=backs.size();\\n\\t\\t\\tfor (int i=0;i<size;i++) {\\n\\t\\t\\t\\tint back=backs.remove();\\n\\t\\t\\t\\tint base=axis[back+b]+1;\\n\\t\\t\\t\\taxis[back]=base;\\n\\t\\t\\t\\tif (back==x)\\n\\t\\t\\t\\t\\treturn base;\\n\\t\\t\\t\\tbase++;\\n\\t\\t\\t\\tfor (int j=back+a;j<maxLen;j+=a) {\\n\\t\\t\\t\\t\\tif (fset.contains(j))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tif (axis[j]>0)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\taxis[j]=base;\\n\\t\\t\\t\\t\\tif (j==x)\\n\\t\\t\\t\\t\\t\\treturn base;\\n\\t\\t\\t\\t\\tbase++;\\n\\t\\t\\t\\t\\tif (j-b>0 && axis[j-b]<0 && !fset.contains(j-b))\\n\\t\\t\\t\\t\\t\\tbacks.add(j-b);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n    \\n```",
                "solutionTags": [],
                "code": "```\\n\\tfinal private Set<Integer> fset = new HashSet<>();\\n\\tprivate int[] axis;\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x==0)\\n\\t\\t\\treturn 0;\\n\\t\\tfor (int f : forbidden)\\n\\t\\t\\tfset.add(f);\\n\\t\\tif (fset.contains(a) || fset.contains(x))\\n\\t\\t\\treturn -1;\\n\\n\\t\\tint maxLen=10000;\\n\\t\\t\\n\\t\\taxis=new int[maxLen];\\n\\t\\tArrays.fill(axis, -1);\\n\\t\\taxis[0]=0;\\n\\t\\taxis[a]=1;\\n\\t\\tint cnt=1;\\n\\t\\tQueue<Integer> backs = new LinkedList<>();\\n\\t\\tfor (int i=a;i<maxLen;i+=a) {\\n\\t\\t\\tif (fset.contains(i))\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tif (i==x)\\n\\t\\t\\t\\treturn cnt;\\n\\t\\t\\taxis[i]=cnt;\\n\\t\\t\\tcnt++;\\n\\t\\t\\tif (i-b>0 && axis[i-b]<0 && !fset.contains(i-b))\\n\\t\\t\\t\\tbacks.add(i-b);\\n\\t\\t}\\n\\t\\tif (b==a)\\n\\t\\t\\treturn -1;\\n\\n\\t\\twhile (!backs.isEmpty()) {\\n\\t\\t\\tint size=backs.size();\\n\\t\\t\\tfor (int i=0;i<size;i++) {\\n\\t\\t\\t\\tint back=backs.remove();\\n\\t\\t\\t\\tint base=axis[back+b]+1;\\n\\t\\t\\t\\taxis[back]=base;\\n\\t\\t\\t\\tif (back==x)\\n\\t\\t\\t\\t\\treturn base;\\n\\t\\t\\t\\tbase++;\\n\\t\\t\\t\\tfor (int j=back+a;j<maxLen;j+=a) {\\n\\t\\t\\t\\t\\tif (fset.contains(j))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tif (axis[j]>0)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\taxis[j]=base;\\n\\t\\t\\t\\t\\tif (j==x)\\n\\t\\t\\t\\t\\t\\treturn base;\\n\\t\\t\\t\\t\\tbase++;\\n\\t\\t\\t\\t\\tif (j-b>0 && axis[j-b]<0 && !fset.contains(j-b))\\n\\t\\t\\t\\t\\t\\tbacks.add(j-b);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935443,
                "title": "go-bfs",
                "content": "I used BFS to solve this problem.  The basic idea is that you can move backwards only once so used a flag to keep track of that and you can move forwards each time.  I could not get this work without using the visited array.  Also I used 5000 because a,b <=2000 and x<=2000 so I suppose if you travel to 5000 which is about 3000 away from x and b cannot be greater than 2000,  You are not going to have chance to arrive at x, even if it is 2000.  \\n\\n```\\nfunc minimumJumps(forbidden []int, a int, b int, x int) int {\\n    forb := make(map[int]bool)\\n    for _, y := range forbidden {\\n        forb[y]=true\\n    }\\n    var queue [][3]int\\n    if _, found := forb[a]; found {\\n        return -1\\n    }\\n    var visited [5000]int\\n    visited[0]=1\\n    queue = append(queue, [3]int{0,1,0})\\n    for len(queue)>0 {\\n        cand := queue[0]\\n        loc := cand[0]\\n        steps := cand[2]\\n        flag := cand[1]\\n        if loc==x {\\n            return steps\\n        }\\n        queue[0]=[3]int{0,0,0}\\n        queue=queue[1:]\\n        backward := loc-b\\n        _, found := forb[backward]\\n        if flag==1 && !found && backward>=0 && visited[backward]==0 {\\n            queue=append(queue,[3]int{backward,0,steps+1})\\n            visited[backward]=1\\n        }\\n        forward := loc+a\\n        _, found = forb[forward]\\n        if !found && forward<5000 && visited[forward]==0 {\\n            queue=append(queue,[3]int{forward,1,steps+1})\\n            visited[forward]=1\\n        }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc minimumJumps(forbidden []int, a int, b int, x int) int {\\n    forb := make(map[int]bool)\\n    for _, y := range forbidden {\\n        forb[y]=true\\n    }\\n    var queue [][3]int\\n    if _, found := forb[a]; found {\\n        return -1\\n    }\\n    var visited [5000]int\\n    visited[0]=1\\n    queue = append(queue, [3]int{0,1,0})\\n    for len(queue)>0 {\\n        cand := queue[0]\\n        loc := cand[0]\\n        steps := cand[2]\\n        flag := cand[1]\\n        if loc==x {\\n            return steps\\n        }\\n        queue[0]=[3]int{0,0,0}\\n        queue=queue[1:]\\n        backward := loc-b\\n        _, found := forb[backward]\\n        if flag==1 && !found && backward>=0 && visited[backward]==0 {\\n            queue=append(queue,[3]int{backward,0,steps+1})\\n            visited[backward]=1\\n        }\\n        forward := loc+a\\n        _, found = forb[forward]\\n        if !found && forward<5000 && visited[forward]==0 {\\n            queue=append(queue,[3]int{forward,1,steps+1})\\n            visited[forward]=1\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935440,
                "title": "dfs-with-c",
                "content": "I should be more careful next time on what states I need to put in the dp and what should not be put. \\n```\\nclass Solution {\\npublic:\\n  \\n#define MAXN 10005\\n\\n\\ntypedef struct _Node { \\n    int value = -1; \\n}Node; \\n  \\nmap<pair<int,bool>,Node> f;\\n\\n\\nvoid dfs(int state, int a, int b, int x, int depth, bool inarow){\\n    if(state > MAXN)\\n        return;\\n    if(state < 0)\\n        return;\\n    pair<int,int> st = make_pair(state , inarow);\\n    if( (depth >= f[st].value && f[st].value >= 0) )\\n        return;\\n    Node xxx;\\n    xxx.value = depth;\\n    f[st] = xxx;\\n    \\n    if(state == x) return;\\n    if(inarow){\\n        dfs(state + a, a, b, x, depth + 1, false);\\n    }else{\\n        dfs(state + a, a, b, x, depth +1 , false);\\n        dfs(state - b, a, b, x, depth +1 , true);\\n    }\\n}\\n\\nint smin(int x, int y){\\n    if(x== y && x == -1)    return -1;\\n    if(x == -1) x = MAXN;\\n    if(y == -1) y = MAXN;\\n    return min(x,y);\\n}\\n\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        for(int i = 0; i < forbidden.size(); ++ i){\\n            Node xxx;\\n            xxx.value = 0;\\n            f[make_pair(forbidden[i],0)] = f[make_pair(forbidden[i],1)] = xxx;\\n        }\\n        \\n        dfs(0, a, b, x, 0, false);\\n        return smin(f[make_pair(x,0)].value,f[make_pair(x,1)].value);\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n#define MAXN 10005\\n\\n\\ntypedef struct _Node { \\n    int value = -1; \\n}Node; \\n  \\nmap<pair<int,bool>,Node> f;\\n\\n\\nvoid dfs(int state, int a, int b, int x, int depth, bool inarow){\\n    if(state > MAXN)\\n        return;\\n    if(state < 0)\\n        return;\\n    pair<int,int> st = make_pair(state , inarow);\\n    if( (depth >= f[st].value && f[st].value >= 0) )\\n        return;\\n    Node xxx;\\n    xxx.value = depth;\\n    f[st] = xxx;\\n    \\n    if(state == x) return;\\n    if(inarow){\\n        dfs(state + a, a, b, x, depth + 1, false);\\n    }else{\\n        dfs(state + a, a, b, x, depth +1 , false);\\n        dfs(state - b, a, b, x, depth +1 , true);\\n    }\\n}\\n\\nint smin(int x, int y){\\n    if(x== y && x == -1)    return -1;\\n    if(x == -1) x = MAXN;\\n    if(y == -1) y = MAXN;\\n    return min(x,y);\\n}\\n\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        for(int i = 0; i < forbidden.size(); ++ i){\\n            Node xxx;\\n            xxx.value = 0;\\n            f[make_pair(forbidden[i],0)] = f[make_pair(forbidden[i],1)] = xxx;\\n        }\\n        \\n        dfs(0, a, b, x, 0, false);\\n        return smin(f[make_pair(x,0)].value,f[make_pair(x,1)].value);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935383,
                "title": "86-87-passed-why-bfs-can-t-work-change-2000-4000-it-will-work",
                "content": "\\tvar minimumJumps = function(forbidden, a, b, x) {\\n\\t\\tforbidden = new Set(forbidden);\\n\\t\\tif (forbidden.has(0) || forbidden.has(x)) return -1;\\n\\t\\tif (x === 0) return 0;\\n\\t\\tconst seta = new Set([0]);\\n\\t\\tconst setb = new Set([0]);\\n\\n\\t\\tconst queue = [[0,0]];\\n\\t\\tlet step = 0;\\n\\n\\t\\twhile (queue.length) {\\n\\t\\t\\tlet size = queue.length;\\n\\n\\t\\t\\tfor (let i = 0; i < size; i++) {\\n\\t\\t\\t\\tlet [curr, time] = queue.shift();\\n\\t\\t\\t\\tlet na = curr + a;\\n\\n\\t\\t\\t\\tif (na >= 0 && !seta.has(na) && !forbidden.has(na)) {\\n\\t\\t\\t\\t\\tif (na === x) return step+1;\\n\\t\\t\\t\\t\\tif (!(a >= b && na > x+2*b)) {\\n\\t\\t\\t\\t\\t\\tqueue.push([na, 0]);\\n\\t\\t\\t\\t\\t\\tseta.add(na);   \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tlet nb = curr - b;\\n\\n\\t\\t\\t\\tif (nb >= 0 && time <= 1 && !setb.has(nb) && !forbidden.has(nb)) {\\n\\t\\t\\t\\t\\tif (nb === x) return step+1;\\n\\t\\t\\t\\t\\tqueue.push([nb, time+1]);\\n\\t\\t\\t\\t\\tsetb.add(nb);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tstep++;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t};",
                "solutionTags": [],
                "code": "\\tvar minimumJumps = function(forbidden, a, b, x) {\\n\\t\\tforbidden = new Set(forbidden);\\n\\t\\tif (forbidden.has(0) || forbidden.has(x)) return -1;\\n\\t\\tif (x === 0) return 0;\\n\\t\\tconst seta = new Set([0]);\\n\\t\\tconst setb = new Set([0]);\\n\\n\\t\\tconst queue = [[0,0]];\\n\\t\\tlet step = 0;\\n\\n\\t\\twhile (queue.length) {\\n\\t\\t\\tlet size = queue.length;\\n\\n\\t\\t\\tfor (let i = 0; i < size; i++) {\\n\\t\\t\\t\\tlet [curr, time] = queue.shift();\\n\\t\\t\\t\\tlet na = curr + a;\\n\\n\\t\\t\\t\\tif (na >= 0 && !seta.has(na) && !forbidden.has(na)) {\\n\\t\\t\\t\\t\\tif (na === x) return step+1;\\n\\t\\t\\t\\t\\tif (!(a >= b && na > x+2*b)) {\\n\\t\\t\\t\\t\\t\\tqueue.push([na, 0]);\\n\\t\\t\\t\\t\\t\\tseta.add(na);   \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tlet nb = curr - b;\\n\\n\\t\\t\\t\\tif (nb >= 0 && time <= 1 && !setb.has(nb) && !forbidden.has(nb)) {\\n\\t\\t\\t\\t\\tif (nb === x) return step+1;\\n\\t\\t\\t\\t\\tqueue.push([nb, time+1]);\\n\\t\\t\\t\\t\\tsetb.add(nb);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tstep++;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 4083736,
                "title": "easy-to-understand-javascript-solution-bfs",
                "content": "# Complexity\\n- Time complexity:\\n$$O(maxX*2)$$\\n\\n- Space complexity:\\n$$O(maxX*2)$$\\n\\n# Code\\n```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    const MAX_X = 2000 + a + b;\\n    const visited = new Set(forbidden);\\n    const queue = [{ position: 0, isBack: false }];\\n    let step = 0;\\n\\n    while (queue.length) {\\n        const size = queue.length;\\n\\n        for (let index = 0; index < size; index++) {\\n            const { position, isBack } = queue.shift();\\n\\n            if (position === x) return step;\\n            const forward = position + a;\\n            const back = position - b;\\n\\n            if (forward <= MAX_X && !visited.has(forward)) {\\n                visited.add(forward);\\n                queue.push({ position: forward, isBack: false });\\n            }\\n            if (back >= 0 && !isBack && !visited.has(back)) {\\n                queue.push({ position: back, isBack: true }); \\n            }\\n        }\\n        step += 1;\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    const MAX_X = 2000 + a + b;\\n    const visited = new Set(forbidden);\\n    const queue = [{ position: 0, isBack: false }];\\n    let step = 0;\\n\\n    while (queue.length) {\\n        const size = queue.length;\\n\\n        for (let index = 0; index < size; index++) {\\n            const { position, isBack } = queue.shift();\\n\\n            if (position === x) return step;\\n            const forward = position + a;\\n            const back = position - b;\\n\\n            if (forward <= MAX_X && !visited.has(forward)) {\\n                visited.add(forward);\\n                queue.push({ position: forward, isBack: false });\\n            }\\n            if (back >= 0 && !isBack && !visited.has(back)) {\\n                queue.push({ position: back, isBack: true }); \\n            }\\n        }\\n        step += 1;\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047716,
                "title": "recursion-memoization-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int dp[6001][2];\\n    unordered_map<int,int> mp;\\n    int f(int i, int back , int a ,int b, int x) \\n    {\\n        if(i==x) return 0;\\n        if(i<0 || i>6000 || back>=2 || mp.find(i)!=mp.end()) return 1e9;\\n        if(dp[i][back]!=-1) return dp[i][back];\\n        dp[i][back]=1+f(i+a,0,a,b,x); \\n        if(!back) dp[i][back]=min(dp[i][back],f(i-b,1,a,b,x)+1);  \\n        return dp[i][back];\\n    }\\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++) mp[forbidden[i]]=1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans=f(0,0,a,b,x);\\n        if(ans>1e9) return -1;\\n        return ans;               \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int dp[6001][2];\\n    unordered_map<int,int> mp;\\n    int f(int i, int back , int a ,int b, int x) \\n    {\\n        if(i==x) return 0;\\n        if(i<0 || i>6000 || back>=2 || mp.find(i)!=mp.end()) return 1e9;\\n        if(dp[i][back]!=-1) return dp[i][back];\\n        dp[i][back]=1+f(i+a,0,a,b,x); \\n        if(!back) dp[i][back]=min(dp[i][back],f(i-b,1,a,b,x)+1);  \\n        return dp[i][back];\\n    }\\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++) mp[forbidden[i]]=1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans=f(0,0,a,b,x);\\n        if(ans>1e9) return -1;\\n        return ans;               \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047456,
                "title": "upper-limit-to-search-with-b-greater-than-a",
                "content": "It\\'s not so difficult to find the upper limit of a breadth first search when $$b <= a$$. \\nFor the upper limit when $$b > a$$, this is a not so math-inclined approach. A movement sequence from A to Z across L like this \\n<pre>\\nM               Z    A      L    \\n|---------------|----|------|---|--|----|\\n                     |---------->      1\\n                                |==>   2\\n                <------------------|   3\\n</pre>\\ncan always be transformed into this without ever touching L\\n<pre>\\nM               Z     A     L      \\n|-|-------------|-----|-----|-----------|\\n  <-------------------|       1     \\n  |==>                        2\\n     |---------->             3\\n</pre>\\nIn the above pictures L stands for some upper limit. Both the first and third movement are single jumps, while the second might be composite of a serious of movements. Since our lovely frog is seeking her way with least jumps as possible, the second movement will never be longer than `b - a`, because if it were, she surely can go back `b - a` position(s) by two more jumps, a contradiction to the optimal assumption.\\nThe transformation can be achieved simply by switching the first the first jump and last jump. That\\'s to say, for any route that goes beyond some upper limit L, and can later go back (and might as well reach x finally),there is a corresponding route that \\n1. reaches the very same destination \\n2. does not goes beyond the limit L\\n3. does not goes back too far away to touch some lower limit which might be dangerous.\\n\\nRemaining task is to decide the accurate position of L which can be quite obvious from the above pictures.  \\n# Code\\n```ruby\\n# @param {Integer[]} forbidden\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} x\\n# @return {Integer}\\ndef minimum_jumps(forbidden, a, b, x)\\n  visited = Set.new\\n  lower = 0\\n  upper = [forbidden.max + a, x].max + b\\n  forbidden = forbidden.to_set\\n  q = [[0, 1, 0]]\\n  explore = lambda do |pos, dir, step|\\n    if pos >= lower && pos <= upper && !visited.include?(pos * dir) && !forbidden.include?(pos)\\n      visited << pos * dir\\n      q << [pos, dir, step]\\n    end\\n  end\\n  \\n  while (pos, dir, step = q.shift)\\n    return step if pos == x\\n\\n    explore[pos + a, 1, step + 1]\\n    explore[pos - b, -1, step + 1] if dir == 1\\n  end\\n\\n  -1\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[]} forbidden\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} x\\n# @return {Integer}\\ndef minimum_jumps(forbidden, a, b, x)\\n  visited = Set.new\\n  lower = 0\\n  upper = [forbidden.max + a, x].max + b\\n  forbidden = forbidden.to_set\\n  q = [[0, 1, 0]]\\n  explore = lambda do |pos, dir, step|\\n    if pos >= lower && pos <= upper && !visited.include?(pos * dir) && !forbidden.include?(pos)\\n      visited << pos * dir\\n      q << [pos, dir, step]\\n    end\\n  end\\n  \\n  while (pos, dir, step = q.shift)\\n    return step if pos == x\\n\\n    explore[pos + a, 1, step + 1]\\n    explore[pos - b, -1, step + 1] if dir == 1\\n  end\\n\\n  -1\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4034756,
                "title": "easy-solution",
                "content": "# Code\\n```javascript []\\n/**\\n * @param {number[]} forbidden\\n * @param {number} a\\n * @param {number} b\\n * @param {number} x\\n * @return {number}\\n */\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    let queue = [];\\n    const seen = new Set();\\n    const banned = new Set(forbidden);\\n\\n    queue.push([0, true])\\n    const maxPosition = a + b + Math.max(x, Math.max(...forbidden));\\n    let jumps = 0\\n\\n    while (queue.length) {\\n        let size = queue.length\\n\\n        while (size--) {\\n            let [cur, canGoBack] = queue.shift();\\n\\n            if (cur === x)\\n                return jumps;\\n            \\n            const forward = cur + a, backward = cur - b;\\n            const fkey = `${forward}-true`, bkey = `${backward}-false`;\\n\\n            if (!banned.has(forward) && forward <= maxPosition && !seen.has(fkey)) {\\n                queue.push([forward, true]);\\n                seen.add(fkey);\\n            }\\n    \\n            if (canGoBack && !banned.has(backward) && backward >= 0 && !seen.has(bkey)) {\\n                queue.push([backward, false]);\\n                seen.add(bkey);\\n            }\\n        }\\n\\n        jumps++;\\n    }\\n\\n    return -1\\n};\\n```\\n```python []\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = deque()\\n        seen = set()\\n        banned = set(forbidden)\\n\\n        jumps = 0\\n        queue.append((0, True))\\n        max_position = a + b + max(x, max(forbidden))\\n\\n        while queue:\\n            size = len(queue)\\n\\n            for _ in range(size):\\n                cur, can_go_backward = queue.popleft()\\n\\n                if cur == x:\\n                    return jumps\\n                \\n                forward = (cur + a, True)\\n                backward = (cur - b, False)\\n\\n                if forward[0] not in banned and forward[0] <= max_position and forward not in seen:\\n                    queue.append(forward)\\n                    seen.add(forward)\\n\\n                if can_go_backward and backward[0] not in banned and backward[0] >= 0 and backward not in seen:\\n                    queue.append(backward)\\n                    seen.add(backward)\\n                \\n            jumps += 1\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript []\\n/**\\n * @param {number[]} forbidden\\n * @param {number} a\\n * @param {number} b\\n * @param {number} x\\n * @return {number}\\n */\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    let queue = [];\\n    const seen = new Set();\\n    const banned = new Set(forbidden);\\n\\n    queue.push([0, true])\\n    const maxPosition = a + b + Math.max(x, Math.max(...forbidden));\\n    let jumps = 0\\n\\n    while (queue.length) {\\n        let size = queue.length\\n\\n        while (size--) {\\n            let [cur, canGoBack] = queue.shift();\\n\\n            if (cur === x)\\n                return jumps;\\n            \\n            const forward = cur + a, backward = cur - b;\\n            const fkey = `${forward}-true`, bkey = `${backward}-false`;\\n\\n            if (!banned.has(forward) && forward <= maxPosition && !seen.has(fkey)) {\\n                queue.push([forward, true]);\\n                seen.add(fkey);\\n            }\\n    \\n            if (canGoBack && !banned.has(backward) && backward >= 0 && !seen.has(bkey)) {\\n                queue.push([backward, false]);\\n                seen.add(bkey);\\n            }\\n        }\\n\\n        jumps++;\\n    }\\n\\n    return -1\\n};\\n```\n```python []\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = deque()\\n        seen = set()\\n        banned = set(forbidden)\\n\\n        jumps = 0\\n        queue.append((0, True))\\n        max_position = a + b + max(x, max(forbidden))\\n\\n        while queue:\\n            size = len(queue)\\n\\n            for _ in range(size):\\n                cur, can_go_backward = queue.popleft()\\n\\n                if cur == x:\\n                    return jumps\\n                \\n                forward = (cur + a, True)\\n                backward = (cur - b, False)\\n\\n                if forward[0] not in banned and forward[0] <= max_position and forward not in seen:\\n                    queue.append(forward)\\n                    seen.add(forward)\\n\\n                if can_go_backward and backward[0] not in banned and backward[0] >= 0 and backward not in seen:\\n                    queue.append(backward)\\n                    seen.add(backward)\\n                \\n            jumps += 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004958,
                "title": "java-simple-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n         int steps = 0, furthest = x + a + b;\\n        Queue<Pair<Integer, Integer>> q = new LinkedList();\\n        q.offer(new Pair(0, 0));\\n        Set<Pair<Integer, Integer>> set= new HashSet<>(q);\\n        for (int cur : forbidden) {\\n            set.add(new Pair(0, cur));\\n            set.add(new Pair(1, cur));\\n            furthest = Math.max(furthest, cur + a + b);\\n        }\\n        while (!q.isEmpty()) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                Pair<Integer, Integer> p = q.poll();\\n                int dir = p.getKey(), cur = p.getValue();\\n                if (cur == x) {\\n                    return steps;\\n                }\\n                Pair<Integer, Integer> forward = new Pair<>(0, cur+ a), backward = new Pair<>(1, cur- b);\\n                if (cur + a <= furthest && set.add(forward)) {\\n                    q.offer(forward);\\n                }\\n                if (dir == 0 && cur - b >= 0 && set.add(backward)) {\\n                    q.offer(backward);\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;                \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n         int steps = 0, furthest = x + a + b;\\n        Queue<Pair<Integer, Integer>> q = new LinkedList();\\n        q.offer(new Pair(0, 0));\\n        Set<Pair<Integer, Integer>> set= new HashSet<>(q);\\n        for (int cur : forbidden) {\\n            set.add(new Pair(0, cur));\\n            set.add(new Pair(1, cur));\\n            furthest = Math.max(furthest, cur + a + b);\\n        }\\n        while (!q.isEmpty()) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                Pair<Integer, Integer> p = q.poll();\\n                int dir = p.getKey(), cur = p.getValue();\\n                if (cur == x) {\\n                    return steps;\\n                }\\n                Pair<Integer, Integer> forward = new Pair<>(0, cur+ a), backward = new Pair<>(1, cur- b);\\n                if (cur + a <= furthest && set.add(forward)) {\\n                    q.offer(forward);\\n                }\\n                if (dir == 0 && cur - b >= 0 && set.add(backward)) {\\n                    q.offer(backward);\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;                \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000642,
                "title": "c-implementation-using-dynamic-programing",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[10001][3];\\n    int f(int i,int a,int b,int x,set<int> &st,int occ){\\n        // cout<<i<<\" \"<<x<<endl;\\n        if(st.find(i)!=st.end()){\\n            return 1e9;\\n        }\\n        if(i>10000){\\n            return 1e9;\\n        }\\n        if(i<0){\\n            return 1e9;\\n        }\\n       \\n        if(i==x){\\n          return 0;  \\n        }\\n        \\n        \\n        if(dp[i][occ]!=-1){\\n            return dp[i][occ];\\n        }\\n        \\n        st.insert(i);\\n        int ans=1e9;\\n        if(occ<=1){\\n            \\n        ans=min(ans,1+min(f(i+a,a,b,x,st,1),f(i-b,a,b,x,st,2)));\\n        }\\n        else{\\n            ans=1+min(ans,f(i+a,a,b,x,st,1));\\n        }\\n        st.erase(i);\\n        return dp[i][occ]=ans;\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<int>st;\\n        // if((abs(a-b)+x)%x!=0 && x%a!=0){\\n        //     return -1;\\n        // }       \\n        memset(dp,-1,sizeof(dp));\\n        for(auto c:forbidden){\\n            st.insert(c);\\n        }   \\n        \\n        int res=f(0,a,b,x,st,2);\\n        return res>=1e9?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10001][3];\\n    int f(int i,int a,int b,int x,set<int> &st,int occ){\\n        // cout<<i<<\" \"<<x<<endl;\\n        if(st.find(i)!=st.end()){\\n            return 1e9;\\n        }\\n        if(i>10000){\\n            return 1e9;\\n        }\\n        if(i<0){\\n            return 1e9;\\n        }\\n       \\n        if(i==x){\\n          return 0;  \\n        }\\n        \\n        \\n        if(dp[i][occ]!=-1){\\n            return dp[i][occ];\\n        }\\n        \\n        st.insert(i);\\n        int ans=1e9;\\n        if(occ<=1){\\n            \\n        ans=min(ans,1+min(f(i+a,a,b,x,st,1),f(i-b,a,b,x,st,2)));\\n        }\\n        else{\\n            ans=1+min(ans,f(i+a,a,b,x,st,1));\\n        }\\n        st.erase(i);\\n        return dp[i][occ]=ans;\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<int>st;\\n        // if((abs(a-b)+x)%x!=0 && x%a!=0){\\n        //     return -1;\\n        // }       \\n        memset(dp,-1,sizeof(dp));\\n        for(auto c:forbidden){\\n            st.insert(c);\\n        }   \\n        \\n        int res=f(0,a,b,x,st,2);\\n        return res>=1e9?-1:res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3983359,
                "title": "python-boundary-intuition-not-formal-explained",
                "content": "# Intuition\\nIdea is that at each position we have two choices to make: move back or move forward. It is intuitive that to get the fewest number of jumps we can use a BFS exploration.\\n\\nThe more difficult part is how to bound the states: it is possible we might come up with way too many states that have no purpose.\\n\\nThe idea behind the boundary is this: we make an alternative formulation where we want to find a **pos** where there exists a path from **pos** to 0 and **pos** to x (and **pos** is not 0 or x). What is the range of values this starting **pos** can have?\\n\\nx is within 0-2000. Since b is also 0-2000, in order to land on x, we must necessarily pass through some set of nodes between 0-4000 (since we can leap back only 2000 at a time, we can not skip from 4001 to 2000 for example). \\n\\nThis implies that once we have checked states 0-4000, we can determine whether it is possible to reach x and 0 (because if we can\\'t within 0-4000, we can\\'t starting from 4001-infinity either). To check all 4000 states, we again use similar logic: to reach 0-4000, we must have **pos** be within 0-6000. If we can\\'t get to a desired state in 0-4000 from within 0-6000, then we definitely can\\'t do it starting from 6001-infinity, since you\\'ll for sure pass through 4000-6000 with a pos starting outside of 6000. \\n\\nThis means our maximum boundary is roughly 6000 in order to check all 4000 states, which then tells us whether we succeed.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = [0]\\n        dp = defaultdict(lambda: float(\\'inf\\'))\\n        dp[0] = 0\\n        seen = set()\\n        while queue:\\n            pos = queue.pop(0)\\n            if pos == x:\\n                return dp[pos]\\n            if pos - b == x and (pos-b) not in forbidden:\\n                return dp[pos]+1\\n            seen.add(pos)\\n            p1, p2 = pos+a, max(0,pos+a-b)\\n            if p1 not in seen and p1 < 6000 and p1 not in forbidden:\\n                seen.add(p1)\\n                queue.append(p1)\\n                dp[p1] = min(dp[p1], dp[pos]+1)\\n            if p2 not in seen and p2 < 6000 and p2 not in forbidden and (pos-b) not in forbidden and (pos-b) >= 0:\\n                seen.add(p2)\\n                queue.append(p2)\\n                dp[p2] = min(dp[p2], dp[pos]+2)\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = [0]\\n        dp = defaultdict(lambda: float(\\'inf\\'))\\n        dp[0] = 0\\n        seen = set()\\n        while queue:\\n            pos = queue.pop(0)\\n            if pos == x:\\n                return dp[pos]\\n            if pos - b == x and (pos-b) not in forbidden:\\n                return dp[pos]+1\\n            seen.add(pos)\\n            p1, p2 = pos+a, max(0,pos+a-b)\\n            if p1 not in seen and p1 < 6000 and p1 not in forbidden:\\n                seen.add(p1)\\n                queue.append(p1)\\n                dp[p1] = min(dp[p1], dp[pos]+1)\\n            if p2 not in seen and p2 < 6000 and p2 not in forbidden and (pos-b) not in forbidden and (pos-b) >= 0:\\n                seen.add(p2)\\n                queue.append(p2)\\n                dp[p2] = min(dp[p2], dp[pos]+2)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961863,
                "title": "ts-bfs-66ms",
                "content": "# Complexity\\n![image.png](https://assets.leetcode.com/users/images/33300e18-54d5-49a9-b1f0-3705d91c37d2_1693037351.0296571.png)\\n\\n\\n# Code\\n```\\nfunction minimumJumps(forbidden: number[], a: number, b: number, x: number): number{\\n    // for tracking(column -> 0: forward / 1: backward)\\n    const check = Array.from({length:2}, () => new Array(10001).fill(0));\\n\\n    // check forbidden spot\\n    for(const danger of forbidden){\\n        check[1][danger] = 1;\\n        check[0][danger] = 1;\\n    }\\n\\n    // check start point(0)\\n    check[1][0] = 1;\\n    check[0][0] = 1;\\n    const queue =[[0,0]];\\n\\n    let answer = -1;\\n    let level = 0;\\n    while(queue.length) {\\n        const len = queue.length;\\n        for(let i = 0; i < len; i++) {\\n            const now = queue.shift();\\n            const dir = now[0];\\n            const move = now[1];\\n\\n            if(move === x) return level;\\n            if(move + a < 2000+a+b && check[0][move+a] === 0) {\\n                check[0][move+a] = 1;\\n                queue.push([0, move+a]);\\n            }\\n            if(move-b >= 0 && dir === 0 && check[1][move-b] === 0) {\\n                check[1][move-b] = 1;\\n                queue.push([1, move-b]);\\n            } \\n        }\\n        level++;\\n    }\\n\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction minimumJumps(forbidden: number[], a: number, b: number, x: number): number{\\n    // for tracking(column -> 0: forward / 1: backward)\\n    const check = Array.from({length:2}, () => new Array(10001).fill(0));\\n\\n    // check forbidden spot\\n    for(const danger of forbidden){\\n        check[1][danger] = 1;\\n        check[0][danger] = 1;\\n    }\\n\\n    // check start point(0)\\n    check[1][0] = 1;\\n    check[0][0] = 1;\\n    const queue =[[0,0]];\\n\\n    let answer = -1;\\n    let level = 0;\\n    while(queue.length) {\\n        const len = queue.length;\\n        for(let i = 0; i < len; i++) {\\n            const now = queue.shift();\\n            const dir = now[0];\\n            const move = now[1];\\n\\n            if(move === x) return level;\\n            if(move + a < 2000+a+b && check[0][move+a] === 0) {\\n                check[0][move+a] = 1;\\n                queue.push([0, move+a]);\\n            }\\n            if(move-b >= 0 && dir === 0 && check[1][move-b] === 0) {\\n                check[1][move-b] = 1;\\n                queue.push([1, move-b]);\\n            } \\n        }\\n        level++;\\n    }\\n\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938854,
                "title": "easy-solution-java-bfs-beats-89",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    class Jump {\\n        public int value;\\n        public boolean canJump;\\n        public Jump(int value, boolean canJump) {\\n            this.value = value;\\n            this.canJump = canJump;\\n        }\\n\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<Jump> queue = new LinkedList<>();\\n        Set<Integer> seen = new HashSet<>();\\n        for (int forbid: forbidden) {\\n            seen.add(forbid);\\n        }\\n        if (seen.contains(0))\\n            return -1;\\n        if (x==0) {\\n            return 0;\\n        }\\n        queue.add(new Jump(0, true));\\n        seen.add(0);\\n\\n        int noOfJumps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i =0; i<size; i++) {\\n                Jump currJump = queue.poll();\\n                int forward = currJump.value + a; \\n                int backward = currJump.value - b; \\n                if (currJump.value == x)\\n                    return noOfJumps;\\n                \\n                if (backward > 0 && currJump.canJump && !seen.contains(backward)) {\\n                    queue.add(new Jump(backward, false));\\n                    seen.add(backward);\\n                }\\n                \\n                if (forward < (2000 + 2 * b + 1) && !seen.contains(forward)) {\\n                    queue.add(new Jump(forward, true));\\n                    seen.add(forward);\\n                }\\n\\n            }\\n            noOfJumps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    class Jump {\\n        public int value;\\n        public boolean canJump;\\n        public Jump(int value, boolean canJump) {\\n            this.value = value;\\n            this.canJump = canJump;\\n        }\\n\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<Jump> queue = new LinkedList<>();\\n        Set<Integer> seen = new HashSet<>();\\n        for (int forbid: forbidden) {\\n            seen.add(forbid);\\n        }\\n        if (seen.contains(0))\\n            return -1;\\n        if (x==0) {\\n            return 0;\\n        }\\n        queue.add(new Jump(0, true));\\n        seen.add(0);\\n\\n        int noOfJumps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i =0; i<size; i++) {\\n                Jump currJump = queue.poll();\\n                int forward = currJump.value + a; \\n                int backward = currJump.value - b; \\n                if (currJump.value == x)\\n                    return noOfJumps;\\n                \\n                if (backward > 0 && currJump.canJump && !seen.contains(backward)) {\\n                    queue.add(new Jump(backward, false));\\n                    seen.add(backward);\\n                }\\n                \\n                if (forward < (2000 + 2 * b + 1) && !seen.contains(forward)) {\\n                    queue.add(new Jump(forward, true));\\n                    seen.add(forward);\\n                }\\n\\n            }\\n            noOfJumps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933386,
                "title": "full-detailed-commented-solution-in-easy-words-bfs-beats-98-easy-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n    //Pair class which will have the position and the direction\\n    class Pair\\n    {\\n         /* NOTE : Direction is boolean so : true -> traveling forward & false -> traveling backward*/\\n        int position;\\n        boolean direction;\\n        public Pair(int position, boolean direction)\\n        {\\n            this.position = position;\\n            this.direction = direction;\\n        }\\n\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n       \\n        //The total limit till where can go\\n        int limit = 2000 + 2 * b +1;\\n       \\n        //Visited Array to mark the forbidden nodes as well as the nodes which already visited\\n        boolean[] visited = new boolean[limit];\\n       \\n        //Marking all the forbidden values true so that whenever we will encounter these values we can skip.\\n        for(int n : forbidden)\\n        {\\n            visited[n] = true;\\n        }\\n        //We have to return minuimum steps this will keep the count\\n        int step = 0;\\n\\n        //Queue of type Pai.\\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        //Initially we will start from 0th position\\n        queue.add(new Pair(0,false));\\n        \\n        //Mark 0th postion visited \\n        visited[0] = true;\\n\\n        //Formal BFS Loop\\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            //Looping through the queue. \\n            for(int i = 0; i < size; i++)\\n            {\\n                //Removing the top element from the queue\\n                Pair p = queue.poll();\\n                \\n                //Extracting the position and the direction of the top most element of the queue.\\n                int position = p.position;\\n                boolean direction = p.direction;\\n                \\n                //Checking if the current position is equal to our destination if it is then return the steps \\n                if(position == x)\\n                    return step;\\n                \\n                //If Direction is false i.e. if we are moving in backward direction \\n                if(direction == false)\\n                {\\n                    // Get the backward location by subtracting current position from b\\n                    int moveBackward = position - b;\\n\\n                    //If backward value is greater than 0 and not visited then add it into the queue and \\n                    //mark it visited.\\n                    if(moveBackward > 0 && !visited[moveBackward])\\n                    {\\n                        queue.offer(new Pair(moveBackward,true));\\n                        visited[moveBackward] = true;\\n                    }\\n                }\\n               \\n                //If neither of the condition is true then that it means we are moving forward.\\n                //Get the next forward postion by adding a into current position \\n                int moveForward = position + a;\\n               \\n                //Check if moveForward value is less than the limit and not visited. If it is not \\n                //Then add this value into the queue and mark it as visited.\\n                if(moveForward < limit && !visited[moveForward])\\n                {\\n                    queue.offer(new Pair(moveForward,false));\\n                    visited[moveForward] = true;\\n                }\\n                \\n             }\\n             //Increment the step after looping the queue.\\n             step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //Pair class which will have the position and the direction\\n    class Pair\\n    {\\n         /* NOTE : Direction is boolean so : true -> traveling forward & false -> traveling backward*/\\n        int position;\\n        boolean direction;\\n        public Pair(int position, boolean direction)\\n        {\\n            this.position = position;\\n            this.direction = direction;\\n        }\\n\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n       \\n        //The total limit till where can go\\n        int limit = 2000 + 2 * b +1;\\n       \\n        //Visited Array to mark the forbidden nodes as well as the nodes which already visited\\n        boolean[] visited = new boolean[limit];\\n       \\n        //Marking all the forbidden values true so that whenever we will encounter these values we can skip.\\n        for(int n : forbidden)\\n        {\\n            visited[n] = true;\\n        }\\n        //We have to return minuimum steps this will keep the count\\n        int step = 0;\\n\\n        //Queue of type Pai.\\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        //Initially we will start from 0th position\\n        queue.add(new Pair(0,false));\\n        \\n        //Mark 0th postion visited \\n        visited[0] = true;\\n\\n        //Formal BFS Loop\\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            //Looping through the queue. \\n            for(int i = 0; i < size; i++)\\n            {\\n                //Removing the top element from the queue\\n                Pair p = queue.poll();\\n                \\n                //Extracting the position and the direction of the top most element of the queue.\\n                int position = p.position;\\n                boolean direction = p.direction;\\n                \\n                //Checking if the current position is equal to our destination if it is then return the steps \\n                if(position == x)\\n                    return step;\\n                \\n                //If Direction is false i.e. if we are moving in backward direction \\n                if(direction == false)\\n                {\\n                    // Get the backward location by subtracting current position from b\\n                    int moveBackward = position - b;\\n\\n                    //If backward value is greater than 0 and not visited then add it into the queue and \\n                    //mark it visited.\\n                    if(moveBackward > 0 && !visited[moveBackward])\\n                    {\\n                        queue.offer(new Pair(moveBackward,true));\\n                        visited[moveBackward] = true;\\n                    }\\n                }\\n               \\n                //If neither of the condition is true then that it means we are moving forward.\\n                //Get the next forward postion by adding a into current position \\n                int moveForward = position + a;\\n               \\n                //Check if moveForward value is less than the limit and not visited. If it is not \\n                //Then add this value into the queue and mark it as visited.\\n                if(moveForward < limit && !visited[moveForward])\\n                {\\n                    queue.offer(new Pair(moveForward,false));\\n                    visited[moveForward] = true;\\n                }\\n                \\n             }\\n             //Increment the step after looping the queue.\\n             step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787228,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x==0:return 0\\n        queue=deque()\\n        queue.append([0,False])\\n        idx=0\\n        maxstop=a+b+max(x,max(forbidden))\\n        seen=set(forbidden)\\n        while queue:\\n            size=len(queue)\\n            idx+=1\\n            # print(\"test: \",queue)\\n            while size>0:\\n                node,forward = queue.popleft()\\n                size-=1\\n                if node in seen:continue\\n                seen.add(node)\\n\\n                if forward and node-b>=0:\\n                    if node-b==x:return idx    \\n                    queue.append([node-b,False])\\n                \\n                if node+a==x:return idx\\n                elif node+a<=maxstop:\\n                    queue.append([node+a,True])\\n                \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x==0:return 0\\n        queue=deque()\\n        queue.append([0,False])\\n        idx=0\\n        maxstop=a+b+max(x,max(forbidden))\\n        seen=set(forbidden)\\n        while queue:\\n            size=len(queue)\\n            idx+=1\\n            # print(\"test: \",queue)\\n            while size>0:\\n                node,forward = queue.popleft()\\n                size-=1\\n                if node in seen:continue\\n                seen.add(node)\\n\\n                if forward and node-b>=0:\\n                    if node-b==x:return idx    \\n                    queue.append([node-b,False])\\n                \\n                if node+a==x:return idx\\n                elif node+a<=maxstop:\\n                    queue.append([node+a,True])\\n                \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773845,
                "title": "my-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The first solution is confusing as it uses a set to mark the visited sequence. The pair class have methods to help the set to remove the duplicates from it.\\n-  The second solution is quiet efficient as it only uses a boolean array to mark the visited combinations as a idx can be visited from backward and forward directions which is not unique.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n//     public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n//         if(x==0)return 0;\\n//         Set<Integer> set=new HashSet<>();\\n//         Set<Pair> v=new HashSet<>();\\n//         for(int f:forbidden){set.add(f);}\\n//         Queue<Pair> q=new LinkedList<>();\\n//         q.offer(new Pair(0,0,true));\\n//         v.add(new Pair(0,true));\\n        \\n//         while(!q.isEmpty()){\\n//             for(int i=q.size();i>0;i--)\\n//             {\\n//                 Pair p= q.poll();\\n//                 if(p.idx==x)return p.jumps;\\n//                 int f=p.idx+a;\\n//                 if(f<6000 && !set.contains(f)){\\n//                     Pair forw=new Pair(f,p.jumps+1,false);\\n//                     if(v.add(new Pair(f,false))) q.offer(forw);\\n//                 }\\n//                 if(p.flag)continue;\\n//                 int back=p.idx-b;\\n//                 if(!set.contains(back) && back>0){\\n//                     Pair backward=new Pair(back,p.jumps+1,true);\\n//                     if(v.add(new Pair(f,true)))q.offer(backward);\\n//                 }\\n//             }\\n//         }\\n//         return -1;\\n//     }\\n// }\\n// class Pair{\\n//     int idx;\\n//     int jumps;\\n//     boolean flag;\\n//     Pair(int idx,int jumps,boolean flag)\\n//     {\\n//         this.idx=idx;\\n//         this.jumps=jumps;\\n//         this.flag=flag;\\n//     }\\n//     Pair(int idx,boolean flag){\\n//         this.idx=idx;\\n//         this.flag=flag;\\n//     }\\n//     public int hashCode() {\\n//         return Objects.hash(idx, flag);\\n//     }\\n//     public boolean equals(Object obj) {\\n//         if (this == obj) {\\n//             return true;\\n//         }\\n//         Pair other = (Pair) obj;\\n//         return idx == other.idx && flag == other.flag;\\n//     }\\n// }\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x == 0) return 0;\\n\\n        int max=0;\\n        for(int f:forbidden)max=Math.max(max,f);\\n        max=Math.max(max,x);\\n        boolean[][] visited = new boolean[max+a+b+1][2];\\n\\n        for (int f : forbidden) {\\n            visited[f][0] = true;\\n            visited[f][1] = true;\\n        }\\n\\n        Queue<Pair> q = new LinkedList<>();\\n        q.offer(new Pair(0, 0, true));\\n        visited[0][0] = true;\\n\\n        while (!q.isEmpty()) {\\n            Pair p = q.poll();\\n            if (p.idx == x) return p.jumps;\\n\\n            int f = p.idx + a;\\n            if (f <= max+a+b && !visited[f][0]) {\\n                Pair forw = new Pair(f, p.jumps + 1, false);\\n                visited[f][0] = true;\\n                q.offer(forw);\\n            }\\n\\n            if (p.flag) continue;\\n\\n            int back = p.idx - b;\\n            if (back > 0 && !visited[back][1]) {\\n                Pair backward = new Pair(back, p.jumps + 1, true);\\n                visited[back][1] = true;\\n                q.offer(backward);\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\nclass Pair {\\n    int idx;\\n    int jumps;\\n    boolean flag;\\n\\n    Pair(int idx, int jumps, boolean flag) {\\n        this.idx = idx;\\n        this.jumps = jumps;\\n        this.flag = flag;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// class Solution {\\n//     public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n//         if(x==0)return 0;\\n//         Set<Integer> set=new HashSet<>();\\n//         Set<Pair> v=new HashSet<>();\\n//         for(int f:forbidden){set.add(f);}\\n//         Queue<Pair> q=new LinkedList<>();\\n//         q.offer(new Pair(0,0,true));\\n//         v.add(new Pair(0,true));\\n        \\n//         while(!q.isEmpty()){\\n//             for(int i=q.size();i>0;i--)\\n//             {\\n//                 Pair p= q.poll();\\n//                 if(p.idx==x)return p.jumps;\\n//                 int f=p.idx+a;\\n//                 if(f<6000 && !set.contains(f)){\\n//                     Pair forw=new Pair(f,p.jumps+1,false);\\n//                     if(v.add(new Pair(f,false))) q.offer(forw);\\n//                 }\\n//                 if(p.flag)continue;\\n//                 int back=p.idx-b;\\n//                 if(!set.contains(back) && back>0){\\n//                     Pair backward=new Pair(back,p.jumps+1,true);\\n//                     if(v.add(new Pair(f,true)))q.offer(backward);\\n//                 }\\n//             }\\n//         }\\n//         return -1;\\n//     }\\n// }\\n// class Pair{\\n//     int idx;\\n//     int jumps;\\n//     boolean flag;\\n//     Pair(int idx,int jumps,boolean flag)\\n//     {\\n//         this.idx=idx;\\n//         this.jumps=jumps;\\n//         this.flag=flag;\\n//     }\\n//     Pair(int idx,boolean flag){\\n//         this.idx=idx;\\n//         this.flag=flag;\\n//     }\\n//     public int hashCode() {\\n//         return Objects.hash(idx, flag);\\n//     }\\n//     public boolean equals(Object obj) {\\n//         if (this == obj) {\\n//             return true;\\n//         }\\n//         Pair other = (Pair) obj;\\n//         return idx == other.idx && flag == other.flag;\\n//     }\\n// }\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x == 0) return 0;\\n\\n        int max=0;\\n        for(int f:forbidden)max=Math.max(max,f);\\n        max=Math.max(max,x);\\n        boolean[][] visited = new boolean[max+a+b+1][2];\\n\\n        for (int f : forbidden) {\\n            visited[f][0] = true;\\n            visited[f][1] = true;\\n        }\\n\\n        Queue<Pair> q = new LinkedList<>();\\n        q.offer(new Pair(0, 0, true));\\n        visited[0][0] = true;\\n\\n        while (!q.isEmpty()) {\\n            Pair p = q.poll();\\n            if (p.idx == x) return p.jumps;\\n\\n            int f = p.idx + a;\\n            if (f <= max+a+b && !visited[f][0]) {\\n                Pair forw = new Pair(f, p.jumps + 1, false);\\n                visited[f][0] = true;\\n                q.offer(forw);\\n            }\\n\\n            if (p.flag) continue;\\n\\n            int back = p.idx - b;\\n            if (back > 0 && !visited[back][1]) {\\n                Pair backward = new Pair(back, p.jumps + 1, true);\\n                visited[back][1] = true;\\n                q.offer(backward);\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\nclass Pair {\\n    int idx;\\n    int jumps;\\n    boolean flag;\\n\\n    Pair(int idx, int jumps, boolean flag) {\\n        this.idx = idx;\\n        this.jumps = jumps;\\n        this.flag = flag;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755172,
                "title": "java-bfs-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    class Pair {\\n        int first;\\n        int second;\\n        Pair(int first, int second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    /** \\n    Logic:- BFS Traversing so minimum ka tension nhi h.\\n    visited set string type so that we are not visiting same node again with same forward or backward case, if we have visited\\n    it with forward then backward is allowed and vice versa.\\n    checking for both cases forward and backward.\\n    **/\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if(x == 0) return 0;\\n        Set<Integer> forbid = new HashSet<>();\\n        for(int n : forbidden) forbid.add(n);\\n\\n        Queue<Pair> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        int ans = 1;\\n        int farMost = 10000;\\n\\n        q.add(new Pair(0, 0));\\n        visited.add(0 + \" \" + 0);\\n\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                Pair curr = q.poll();\\n                // Forward a \\n                int next_a = curr.first + a;\\n                if(next_a == x) return ans;\\n                if(next_a >= 0 && next_a <= farMost && !forbid.contains(next_a) && visited.add(next_a + \" \" + 1)){\\n                    q.add(new Pair(next_a, 1));\\n                } \\n                // Backward b\\n                if(curr.second == 1){\\n                    int next_b = curr.first - b;\\n                    if(next_b == x) return ans;\\n                    if(next_b >= 0 && next_b <= farMost && !forbid.contains(next_b) && visited.add(next_b + \" \" + 0)){\\n                        q.add(new Pair(next_b, 0));\\n                    } \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int first;\\n        int second;\\n        Pair(int first, int second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    /** \\n    Logic:- BFS Traversing so minimum ka tension nhi h.\\n    visited set string type so that we are not visiting same node again with same forward or backward case, if we have visited\\n    it with forward then backward is allowed and vice versa.\\n    checking for both cases forward and backward.\\n    **/\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if(x == 0) return 0;\\n        Set<Integer> forbid = new HashSet<>();\\n        for(int n : forbidden) forbid.add(n);\\n\\n        Queue<Pair> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        int ans = 1;\\n        int farMost = 10000;\\n\\n        q.add(new Pair(0, 0));\\n        visited.add(0 + \" \" + 0);\\n\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                Pair curr = q.poll();\\n                // Forward a \\n                int next_a = curr.first + a;\\n                if(next_a == x) return ans;\\n                if(next_a >= 0 && next_a <= farMost && !forbid.contains(next_a) && visited.add(next_a + \" \" + 1)){\\n                    q.add(new Pair(next_a, 1));\\n                } \\n                // Backward b\\n                if(curr.second == 1){\\n                    int next_b = curr.first - b;\\n                    if(next_b == x) return ans;\\n                    if(next_b >= 0 && next_b <= farMost && !forbid.contains(next_b) && visited.add(next_b + \" \" + 0)){\\n                        q.add(new Pair(next_b, 0));\\n                    } \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753701,
                "title": "my-solution",
                "content": "```\\n/**\\n * normally, it\\'s unnecessary for the bug to reach a position `p`\\n * which is greater than (`x` + `b`)\\n * the reason is as following,\\n * 1. if `a` >= `b`, the bug can never reach the sweet home from the\\n *    position `p`, because the bug can only go backward once, and\\n *    then it must go forward, so the bug can reach the following\\n *    positions,\\n *    `p` - `b`\\n *    `p` - `b` + `a`\\n *    `p` - `b` + `a` - `b`\\n *    `p` - `b` + `a` - `b` + `a`\\n *    ...\\n *    because `a` >= `b`, these positions are all greater than or equal\\n *    to the position (`p` - `b`), and `p` is greater than (`x` + `b`),\\n *    so these positions are all greater than `x`\\n * 2. if `a` < `b`,\\n *    assume that the bug can reach the sweet home from the position `p`,\\n *    and the position `p` is the first position which is greather than\\n *    (`x` + `b`)\\n *    the positions on the path home are as following,\\n *    `p` - `b`\\n *    `p` - `b` + `a`\\n *    `p` - `b` + `a` - `b`\\n *    ...\\n *    `x`\\n *    assume that the position just before the position `p` is `q`,\\n *    `q` should be less than or equal to (`x` + `b`)\\n *    `p` = `q` + `a`\\n *    the above positions become the following ones,\\n *    `q` + `a` - `b`\\n *    `q` + `a` - `b` + `a`\\n *    `q` + `a` - `b` + `a` - `b`\\n *    ...\\n *    `x`\\n *    when the bug reach the position `q`, it can choose to go backward\\n *    and then go forward, the following actions follow the same schema,\\n *    so the positions become as following\\n *    `q` - `b` + `a`\\n *    `q` - `b` + `a` + `a`\\n *    `q` - `b` + `a` - `b` + `a`\\n *    ...\\n *    `x`\\n *    the above positions are always less than `q`, and `q` is less than or\\n *    equal to (`x` + `b`), so the above positions are always less than the\\n *    position (`x` + `b`)\\n *    so the bug should never reach a position which is greater than\\n *    (`x` + `b`)\\n * assume that currently the bug reaches a position `p`,\\n * and `p` + `a` > `x` + `b`,\\n * the smart bug decides to go backward,\\n * so it reaches the position (`p` - `b`),\\n * unfortunately, the position (`p` - `b`) is one of the forbidden one,\\n * so it can only go forward from `p` to reach `p` + `a`,\\n * that is the position (`p` + `a`) should be valid for the bug to reach.\\n * if `p` is in the range [`f`, `f` + `b`], both inclusive, where `f` is\\n * the maximum forbidden one, it\\'s possible that the bug can only have one\\n * option, that is stepping forward to reach to position (`p` + `a`)\\n * so it\\'s possible that the bug will reach the position (`f` + `a` + `b`)\\n * so the most right position the bug can reach should be\\n * max(`f` + `a` + `b`, `x` + `b`)\\n */\\nclass Solution {\\n public:\\n  int minimumJumps(const vector<int> &forbidden, const int a, const int b, const int x) {\\n    using q_node_t = pair<int, int>;   // {the position, the direction}\\n    constexpr int n_directions = 2;\\n    constexpr uint8_t all_visited = (1 << n_directions) - 1;\\n    constexpr int to_left = 0;\\n    constexpr int to_right = 1;\\n    const int jumps[] = {a, -b};\\n    /**\\n     * `max_reach` stands for the most right position where the bug can reach\\n     */\\n    const int max_reach = max(*max_element(forbidden.begin(), forbidden.end()) + a + b, x + b);\\n    uint8_t visited[max_reach + 1];\\n    memset(visited, 0, sizeof(visited));\\n    for (const int forbidden_position : forbidden) {\\n      visited[forbidden_position] = all_visited;\\n    }\\n    queue<q_node_t> q;\\n    q.emplace(0, to_right);\\n    q.emplace(0, to_left);\\n    visited[0] = all_visited;\\n    int steps = -1;\\n    while (!q.empty()) {\\n      ++steps;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [p, d] = q.front();\\n        if (p == x) {\\n          return steps;\\n        }\\n        q.pop();\\n\\n        for (const int dump : jumps) {\\n          const int np = p + dump;\\n          const int nd = dump > 0 ? to_right : to_left;\\n          if (np < 0 || np > max_reach || (d == to_left && nd == to_left) || ((visited[np] >> nd) & 0b1) == 0b1) {\\n            continue;\\n          }\\n          q.emplace(np, nd);\\n          visited[np] |= 1 << nd;\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * normally, it\\'s unnecessary for the bug to reach a position `p`\\n * which is greater than (`x` + `b`)\\n * the reason is as following,\\n * 1. if `a` >= `b`, the bug can never reach the sweet home from the\\n *    position `p`, because the bug can only go backward once, and\\n *    then it must go forward, so the bug can reach the following\\n *    positions,\\n *    `p` - `b`\\n *    `p` - `b` + `a`\\n *    `p` - `b` + `a` - `b`\\n *    `p` - `b` + `a` - `b` + `a`\\n *    ...\\n *    because `a` >= `b`, these positions are all greater than or equal\\n *    to the position (`p` - `b`), and `p` is greater than (`x` + `b`),\\n *    so these positions are all greater than `x`\\n * 2. if `a` < `b`,\\n *    assume that the bug can reach the sweet home from the position `p`,\\n *    and the position `p` is the first position which is greather than\\n *    (`x` + `b`)\\n *    the positions on the path home are as following,\\n *    `p` - `b`\\n *    `p` - `b` + `a`\\n *    `p` - `b` + `a` - `b`\\n *    ...\\n *    `x`\\n *    assume that the position just before the position `p` is `q`,\\n *    `q` should be less than or equal to (`x` + `b`)\\n *    `p` = `q` + `a`\\n *    the above positions become the following ones,\\n *    `q` + `a` - `b`\\n *    `q` + `a` - `b` + `a`\\n *    `q` + `a` - `b` + `a` - `b`\\n *    ...\\n *    `x`\\n *    when the bug reach the position `q`, it can choose to go backward\\n *    and then go forward, the following actions follow the same schema,\\n *    so the positions become as following\\n *    `q` - `b` + `a`\\n *    `q` - `b` + `a` + `a`\\n *    `q` - `b` + `a` - `b` + `a`\\n *    ...\\n *    `x`\\n *    the above positions are always less than `q`, and `q` is less than or\\n *    equal to (`x` + `b`), so the above positions are always less than the\\n *    position (`x` + `b`)\\n *    so the bug should never reach a position which is greater than\\n *    (`x` + `b`)\\n * assume that currently the bug reaches a position `p`,\\n * and `p` + `a` > `x` + `b`,\\n * the smart bug decides to go backward,\\n * so it reaches the position (`p` - `b`),\\n * unfortunately, the position (`p` - `b`) is one of the forbidden one,\\n * so it can only go forward from `p` to reach `p` + `a`,\\n * that is the position (`p` + `a`) should be valid for the bug to reach.\\n * if `p` is in the range [`f`, `f` + `b`], both inclusive, where `f` is\\n * the maximum forbidden one, it\\'s possible that the bug can only have one\\n * option, that is stepping forward to reach to position (`p` + `a`)\\n * so it\\'s possible that the bug will reach the position (`f` + `a` + `b`)\\n * so the most right position the bug can reach should be\\n * max(`f` + `a` + `b`, `x` + `b`)\\n */\\nclass Solution {\\n public:\\n  int minimumJumps(const vector<int> &forbidden, const int a, const int b, const int x) {\\n    using q_node_t = pair<int, int>;   // {the position, the direction}\\n    constexpr int n_directions = 2;\\n    constexpr uint8_t all_visited = (1 << n_directions) - 1;\\n    constexpr int to_left = 0;\\n    constexpr int to_right = 1;\\n    const int jumps[] = {a, -b};\\n    /**\\n     * `max_reach` stands for the most right position where the bug can reach\\n     */\\n    const int max_reach = max(*max_element(forbidden.begin(), forbidden.end()) + a + b, x + b);\\n    uint8_t visited[max_reach + 1];\\n    memset(visited, 0, sizeof(visited));\\n    for (const int forbidden_position : forbidden) {\\n      visited[forbidden_position] = all_visited;\\n    }\\n    queue<q_node_t> q;\\n    q.emplace(0, to_right);\\n    q.emplace(0, to_left);\\n    visited[0] = all_visited;\\n    int steps = -1;\\n    while (!q.empty()) {\\n      ++steps;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [p, d] = q.front();\\n        if (p == x) {\\n          return steps;\\n        }\\n        q.pop();\\n\\n        for (const int dump : jumps) {\\n          const int np = p + dump;\\n          const int nd = dump > 0 ? to_right : to_left;\\n          if (np < 0 || np > max_reach || (d == to_left && nd == to_left) || ((visited[np] >> nd) & 0b1) == 0b1) {\\n            continue;\\n          }\\n          q.emplace(np, nd);\\n          visited[np] |= 1 << nd;\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565893,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1567108,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1568547,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1576996,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1568487,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1576559,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1570397,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1733309,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1575580,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1575670,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1565893,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1567108,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1568547,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1576996,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1568487,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1576559,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1570397,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1733309,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1575580,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1575670,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            }
        ]
    }
]