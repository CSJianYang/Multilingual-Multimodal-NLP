[
    {
        "title": "Letter Combinations of a Phone Number",
        "question_content": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n&nbsp;\nExample 1:\n\nInput: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n\nExample 2:\n\nInput: digits = \"\"\nOutput: []\n\nExample 3:\n\nInput: digits = \"2\"\nOutput: [\"a\",\"b\",\"c\"]\n\n&nbsp;\nConstraints:\n\n\t0 <= digits.length <= 4\n\tdigits[i] is a digit in the range ['2', '9'].",
        "solutions": [
            {
                "id": 8064,
                "title": "my-java-solution-with-fifo-queue",
                "content": "```\\npublic List<String> letterCombinations(String digits) {\\n\\t\\tLinkedList<String> ans = new LinkedList<String>();\\n\\t\\tif(digits.isEmpty()) return ans;\\n\\t\\tString[] mapping = new String[] {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\t\\tans.add(\"\");\\n\\t\\tfor(int i =0; i<digits.length();i++){\\n\\t\\t\\tint x = Character.getNumericValue(digits.charAt(i));\\n\\t\\t\\twhile(ans.peek().length()==i){\\n\\t\\t\\t\\tString t = ans.remove();\\n\\t\\t\\t\\tfor(char s : mapping[x].toCharArray())\\n\\t\\t\\t\\t\\tans.add(t+s);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n```\\n\\nA version without first loop, but same time complexity. Both are single queue BFS solutions.:\\n```\\npublic List<String> letterCombinations(String digits) {\\n\\t\\tLinkedList<String> ans = new LinkedList<String>();\\n\\t\\tif(digits.isEmpty()) return ans;\\n\\t\\tString[] mapping = new String[] {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\t\\tans.add(\"\");\\n\\t\\twhile(ans.peek().length()!=digits.length()){\\n\\t\\t\\tString remove = ans.remove();\\n\\t\\t\\tString map = mapping[digits.charAt(remove.length())-\\'0\\'];\\n\\t\\t\\tfor(char c: map.toCharArray()){\\n\\t\\t\\t\\tans.addLast(remove+c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> letterCombinations(String digits) {\\n\\t\\tLinkedList<String> ans = new LinkedList<String>();\\n\\t\\tif(digits.isEmpty()) return ans;\\n\\t\\tString[] mapping = new String[] {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\t\\tans.add(\"\");\\n\\t\\tfor(int i =0; i<digits.length();i++){\\n\\t\\t\\tint x = Character.getNumericValue(digits.charAt(i));\\n\\t\\t\\twhile(ans.peek().length()==i){\\n\\t\\t\\t\\tString t = ans.remove();\\n\\t\\t\\t\\tfor(char s : mapping[x].toCharArray())\\n\\t\\t\\t\\t\\tans.add(t+s);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n```\n```\\npublic List<String> letterCombinations(String digits) {\\n\\t\\tLinkedList<String> ans = new LinkedList<String>();\\n\\t\\tif(digits.isEmpty()) return ans;\\n\\t\\tString[] mapping = new String[] {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\t\\tans.add(\"\");\\n\\t\\twhile(ans.peek().length()!=digits.length()){\\n\\t\\t\\tString remove = ans.remove();\\n\\t\\t\\tString map = mapping[digits.charAt(remove.length())-\\'0\\'];\\n\\t\\t\\tfor(char c: map.toCharArray()){\\n\\t\\t\\t\\tans.addLast(remove+c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8090,
                "title": "iterative-c-solution-in-0ms",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    const vector<string> pad = {\\n        \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\\n        \"mno\", \"pqrs\", \"tuv\", \"wxyz\"\\n    };\\n    \\n    vector<string> letterCombinations(string digits) {\\n        if (digits.empty()) return {};\\n\\t\\tvector<string> result;\\n        result.push_back(\"\");\\n        \\n        for(auto digit: digits) {\\n            vector<string> tmp;\\n            for(auto candidate: pad[digit - \\'0\\']) {\\n                for(auto s: result) {\\n                    tmp.push_back(s + candidate);\\n                }\\n            }\\n            result.swap(tmp);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nSimple and efficient iterative solution.\\n\\nExplanation with sample input \"123\"\\n\\nInitial state:\\n\\n- result = {\"\"}\\n\\nStage 1 for number \"1\":\\n\\n- result has {\"\"}\\n- candiate is \"abc\"\\n- generate three strings \"\" + \"a\", \"\"+\"b\", \"\"+\"c\" and put into tmp,\\n  tmp = {\"a\", \"b\",\"c\"}\\n- swap result and tmp (swap does not take memory copy)\\n- Now result has {\"a\", \"b\", \"c\"}\\n \\nStage 2 for number \"2\":\\n\\n- result has {\"a\", \"b\", \"c\"}\\n- candidate is \"def\"\\n- generate nine strings and put into tmp,\\n   \"a\" + \"d\", \"a\"+\"e\", \"a\"+\"f\", \\n   \"b\" + \"d\", \"b\"+\"e\", \"b\"+\"f\",\\n   \"c\" + \"d\", \"c\"+\"e\", \"c\"+\"f\" \\n- so tmp has {\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\" }\\n- swap result and tmp\\n- Now result has {\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\" }\\n\\nStage 3 for number \"3\":\\n\\n- result has {\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\" }\\n- candidate is \"ghi\"\\n- generate 27 strings and put into tmp,\\n-  add \"g\" for each of \"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\" \\n-  add \"h\" for each of \"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\" \\n-  add \"h\" for each of \"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\" \\n- so, tmp has\\n            {\"adg\", \"aeg\", \"afg\", \"bdg\", \"beg\", \"bfg\", \"cdg\", \"ceg\", \"cfg\"\\n             \"adh\", \"aeh\", \"afh\", \"bdh\", \"beh\", \"bfh\", \"cdh\", \"ceh\", \"cfh\" \\n             \"adi\", \"aei\", \"afi\", \"bdi\", \"bei\", \"bfi\", \"cdi\", \"cei\", \"cfi\" }\\n- swap result and tmp\\n- Now result has\\n            {\"adg\", \"aeg\", \"afg\", \"bdg\", \"beg\", \"bfg\", \"cdg\", \"ceg\", \"cfg\"\\n             \"adh\", \"aeh\", \"afh\", \"bdh\", \"beh\", \"bfh\", \"cdh\", \"ceh\", \"cfh\" \\n             \"adi\", \"aei\", \"afi\", \"bdi\", \"bei\", \"bfi\", \"cdi\", \"cei\", \"cfi\" }\\n\\n\\nFinally, return result.",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    const vector<string> pad = {\\n        \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\\n        \"mno\", \"pqrs\", \"tuv\", \"wxyz\"\\n    };\\n    \\n    vector<string> letterCombinations(string digits) {\\n        if (digits.empty()) return {};\\n\\t\\tvector<string> result;\\n        result.push_back(\"\");\\n        \\n        for(auto digit: digits) {\\n            vector<string> tmp;\\n            for(auto candidate: pad[digit - \\'0\\']) {\\n                for(auto s: result) {\\n                    tmp.push_back(s + candidate);\\n                }\\n            }\\n            result.swap(tmp);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780232,
                "title": "backtracking-python-problems-solutions-interview-prep",
                "content": "This snippet is helpful while preparing for interviews as it groups together similar python Backtracking problems and solution.  Feel free to let me know if you have found similar backtracking problems or have any suggestions, will add it to the post.\\n\\n**78. Subsets:** Runtime: 16 ms, faster than 96.05%\\n```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        res.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], path + [nums[i]], res)     \\n```\\n**90. Subsets II:**  Runtime: 20 ms, faster than 96.23% \\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path + [nums[i]], res)\\n```\\n\\n**77. Combinations**: Runtime: 676 ms, faster than 42.96%\\n```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res=[]\\n        self.dfs(range(1, n+1), k, [], res)\\n        return res\\n    \\n    def dfs(self, nums, k, path, res):\\n        if len(path) == k:\\n            res.append(path)\\n            return\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], k, path+ [nums[i]], res)\\n```\\n**39. Combination Sum**: Runtime: 124 ms, faster than 30.77%\\n```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return   #backtracking\\n        if target == 0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            self.dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)  \\n```\\n**40. Combination Sum II**: Runtime: 36 ms, faster than 91.77%\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            res.append(path)\\n        for i in range(len(candidates)):\\n            if i > 0 and candidates[i] == candidates[i-1]:\\n                continue\\n                \\n            if candidates[i]> target:\\n                break\\n                \\n            self.dfs(candidates[i+1:], target - candidates[i], path + [candidates[i]], res)\\n```\\n\\n**46. Permutations**: Runtime: 28 ms, faster than 79.64%\\n```\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if len(nums) == 0:\\n            res.append(path)\\n            return\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i] + nums[i+1:], path + [nums[i]], res)   \\n```\\n\\n**47. Permutations II**: Runtime: 40 ms, faster than 92.96%\\n```\\nclass Solution(object):\\n    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if len(nums) == 0:\\n            res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[:i] + nums[i+1:], path + [nums[i]], res)\\n```\\n**17. Letter combination of a Phone Number:**:Runtime: 24 ms, faster than 43.40%\\n```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        dic = { \"2\": \"abc\", \"3\": \"def\", \"4\":\"ghi\", \"5\":\"jkl\", \"6\":\"mno\", \"7\":\"pqrs\", \"8\":\"tuv\", \"9\":\"wxyz\"}\\n        \\n        res=[]\\n        if len(digits) ==0:\\n            return res\\n            \\n        self.dfs(digits, 0, dic, \\'\\', res)\\n        return res\\n    \\n    def dfs(self, nums, index, dic, path, res):\\n        if index >=len(nums):\\n            res.append(path)\\n            return\\n        string1 =dic[nums[index]]\\n        for i in string1:\\n            self.dfs(nums, index+1, dic, path + i, res)\\n```\\n==========================================================\\nI hope that you\\'ve found the solutions useful. Please do UPVOTE, it only motivates me to write more such posts. Thanks!\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        res.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], path + [nums[i]], res)     \\n```\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[i+1:], path + [nums[i]], res)\\n```\n```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res=[]\\n        self.dfs(range(1, n+1), k, [], res)\\n        return res\\n    \\n    def dfs(self, nums, k, path, res):\\n        if len(path) == k:\\n            res.append(path)\\n            return\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], k, path+ [nums[i]], res)\\n```\n```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return   #backtracking\\n        if target == 0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            self.dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)  \\n```\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            res.append(path)\\n        for i in range(len(candidates)):\\n            if i > 0 and candidates[i] == candidates[i-1]:\\n                continue\\n                \\n            if candidates[i]> target:\\n                break\\n                \\n            self.dfs(candidates[i+1:], target - candidates[i], path + [candidates[i]], res)\\n```\n```\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if len(nums) == 0:\\n            res.append(path)\\n            return\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i] + nums[i+1:], path + [nums[i]], res)   \\n```\n```\\nclass Solution(object):\\n    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if len(nums) == 0:\\n            res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums[:i] + nums[i+1:], path + [nums[i]], res)\\n```\n```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        dic = { \"2\": \"abc\", \"3\": \"def\", \"4\":\"ghi\", \"5\":\"jkl\", \"6\":\"mno\", \"7\":\"pqrs\", \"8\":\"tuv\", \"9\":\"wxyz\"}\\n        \\n        res=[]\\n        if len(digits) ==0:\\n            return res\\n            \\n        self.dfs(digits, 0, dic, \\'\\', res)\\n        return res\\n    \\n    def dfs(self, nums, index, dic, path, res):\\n        if index >=len(nums):\\n            res.append(path)\\n            return\\n        string1 =dic[nums[index]]\\n        for i in string1:\\n            self.dfs(nums, index+1, dic, path + i, res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8109,
                "title": "my-recursive-solution-using-java",
                "content": "\\n \\n\\n       public class Solution {\\n        \\tprivate static final String[] KEYS = { \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n        \\n        \\tpublic List<String> letterCombinations(String digits) {\\n        \\t\\tList<String> ret = new LinkedList<String>();\\n        \\t\\tcombination(\"\", digits, 0, ret);\\n        \\t\\treturn ret;\\n        \\t}\\n        \\n        \\tprivate void combination(String prefix, String digits, int offset, List<String> ret) {\\n        \\t\\tif (offset >= digits.length()) {\\n        \\t\\t\\tret.add(prefix);\\n        \\t\\t\\treturn;\\n        \\t\\t}\\n        \\t\\tString letters = KEYS[(digits.charAt(offset) - '0')];\\n        \\t\\tfor (int i = 0; i < letters.length(); i++) {\\n        \\t\\t\\tcombination(prefix + letters.charAt(i), digits, offset + 1, ret);\\n        \\t\\t}\\n        \\t}\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\tprivate static final String[] KEYS = { \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" }",
                "codeTag": "Java"
            },
            {
                "id": 8063,
                "title": "python-solution",
                "content": "    class Solution:\\n        # @param {string} digits\\n        # @return {string[]}\\n        def letterCombinations(self, digits):\\n            mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', \\n                       '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\\n            if len(digits) == 0:\\n                return []\\n            if len(digits) == 1:\\n                return list(mapping[digits[0]])\\n            prev = self.letterCombinations(digits[:-1])\\n            additional = mapping[digits[-1]]\\n            return [s + c for s in prev for c in additional]",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "class Solution:\\n        # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 8097,
                "title": "my-iterative-sollution-very-simple-under-15-lines",
                "content": "This is my solution, FYI\\n\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> res;\\n        string charmap[10] = {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        res.push_back(\"\");\\n        for (int i = 0; i < digits.size(); i++)\\n        {\\n            vector<string> tempres;\\n            string chars = charmap[digits[i] - '0'];\\n            for (int c = 0; c < chars.size();c++)\\n                for (int j = 0; j < res.size();j++)\\n                    tempres.push_back(res[j]+chars[c]);\\n            res = tempres;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "This is my solution, FYI\\n\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> res;\\n        string charmap[10] = {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        res.push_back(\"\");\\n        for (int i = 0; i < digits.size(); i++)\\n        {\\n            vector<string> tempres;\\n            string chars = charmap[digits[i] - '0'];\\n            for (int c = 0; c < chars.size();c++)\\n                for (int j = 0; j < res.size();j++)\\n                    tempres.push_back(res[j]+chars[c]);\\n            res = tempres;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 8070,
                "title": "one-line-python-solution",
                "content": "    class Solution:\\n        # @return a list of strings, [s1, s2]\\n        def letterCombinations(self, digits):\\n            if '' == digits: return []\\n            kvmaps = {\\n                '2': 'abc',\\n                '3': 'def',\\n                '4': 'ghi',\\n                '5': 'jkl',\\n                '6': 'mno',\\n                '7': 'pqrs',\\n                '8': 'tuv',\\n                '9': 'wxyz'\\n            }\\n            return reduce(lambda acc, digit: [x + y for x in acc for y in kvmaps[digit]], digits, [''])",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @return a list of strings, [s1, s2]\\n        def letterCombinations(self, digits):\\n            if '' == digits: return []\\n            kvmaps = {\\n                '2': 'abc',\\n                '3': 'def',\\n                '4': 'ghi',\\n                '5': 'jkl',\\n                '6': 'mno',\\n                '7': 'pqrs',\\n                '8': 'tuv',\\n                '9': 'wxyz'\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3222449,
                "title": "best-c-2-solution-backtracking-iterative-recursive-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Two Approaches.\\n\\n1. Solved using String + Backtracking + Hash Table. Recursive Approach.\\n2. Solved using String + Hash Table. Iterative Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(3^N \\xD7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(3^N \\xD7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(3^N \\xD7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\\n\\n    Space Complexity : O(3^N \\xD7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\\n\\n    Solved using String + Backtracking + Hash Table. Recursive Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    void letterCombinations(string digits, vector<string>& output, string &temp, vector<string>& pad, int index){\\n        if(index == digits.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        string value = pad[digits[index]-\\'0\\'];\\n        for(int i=0; i<value.size(); i++){\\n            temp.push_back(value[i]);\\n            letterCombinations(digits, output, temp, pad, index+1);\\n            temp.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.empty()){\\n            return {};\\n        }\\n        vector<string> pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        vector<string> output;\\n        string temp;\\n        letterCombinations(digits, output, temp, pad, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(3^N \\xD7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\\n\\n    Space Complexity : O(3^N \\xD7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\\n\\n    Solved using String + Hash Table. Iterative Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.empty()){\\n            return {};\\n        }\\n        vector<string> pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        vector<string> output;\\n        output.push_back(\"\");\\n        for(auto key : digits){\\n            vector<string> temp;\\n            for(auto candidate : pad[key-\\'0\\']){\\n                for(auto c : output){\\n                    temp.push_back(c + candidate);\\n                }\\n            }\\n            output.clear();\\n            output = temp;\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(3^N \\xD7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\\n\\n    Space Complexity : O(3^N \\xD7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\\n\\n    Solved using String + Backtracking + Hash Table. Recursive Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    void letterCombinations(string digits, vector<string>& output, string &temp, vector<string>& pad, int index){\\n        if(index == digits.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        string value = pad[digits[index]-\\'0\\'];\\n        for(int i=0; i<value.size(); i++){\\n            temp.push_back(value[i]);\\n            letterCombinations(digits, output, temp, pad, index+1);\\n            temp.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.empty()){\\n            return {};\\n        }\\n        vector<string> pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        vector<string> output;\\n        string temp;\\n        letterCombinations(digits, output, temp, pad, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(3^N \\xD7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\\n\\n    Space Complexity : O(3^N \\xD7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\\n\\n    Solved using String + Hash Table. Iterative Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.empty()){\\n            return {};\\n        }\\n        vector<string> pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        vector<string> output;\\n        output.push_back(\"\");\\n        for(auto key : digits){\\n            vector<string> temp;\\n            for(auto candidate : pad[key-\\'0\\']){\\n                for(auto c : output){\\n                    temp.push_back(c + candidate);\\n                }\\n            }\\n            output.clear();\\n            output = temp;\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8118,
                "title": "easy-understand-java-solution",
                "content": " method **combine** is to add new letters to old list, using 2 for-loop.\\n\\nfor example:\\n\\ngave digits = \"23\"\\n\\ni=0 -> result=combine(\"abc\", [\"\"]) ---> [a,b,c];\\n\\ni=1 -> result=combine(\"def\", [a,b,c]) ---> [ad,bd,cd, ae,be,ce, af,bf,cf];\\n\\n \\n\\n      public class Solution {\\n            public static List<String> letterCombinations(String digits) {\\n                String digitletter[] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n                List<String> result = new ArrayList<String>();\\n        \\n                if (digits.length()==0) return result;\\n                \\n                result.add(\"\");\\n                for (int i=0; i<digits.length(); i++) \\n                    result = combine(digitletter[digits.charAt(i)-'0'],result);\\n                \\n                return result;\\n            }\\n            \\n            public static List<String> combine(String digit, List<String> l) {\\n                List<String> result = new ArrayList<String>();\\n                \\n                for (int i=0; i<digit.length(); i++) \\n                    for (String x : l) \\n                        result.add(x+digit.charAt(i));\\n        \\n                return result;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public static List<String> letterCombinations(String digits) {\\n                String digitletter[] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}",
                "codeTag": "Java"
            },
            {
                "id": 3313021,
                "title": "python-simple-solution-easiest",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am Giving away my premium content videos related to computer science and data science and also will be sharing well-structured assignments and study materials to clear interviews at top companies to my first 1000 Subscribers. So, **DON\\'T FORGET** to Subscribe\\n\\nhttps://www.youtube.com/@techwired8/?sub_confirmation=1\\n```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n        \\n        phone = {\"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\", \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"}\\n        res = []\\n        \\n        def backtrack(combination, next_digits):\\n            if not next_digits:\\n                res.append(combination)\\n                return\\n            \\n            for letter in phone[next_digits[0]]:\\n                backtrack(combination + letter, next_digits[1:])\\n        \\n        backtrack(\"\", digits)\\n        return res\\n\\n```\\n**Explanation:**\\n\\n- We define a helper function \"backtrack\" that takes two arguments: the current combination and the remaining digits to process.\\n\\n- If there are no more digits to process, we append the current combination to the final list and return.\\n\\n- Otherwise, we iterate through each letter that the first remaining digit maps to, and recursively call the \"backtrack\" function with the new combination and the remaining digits.\\n\\n- We initialize the final list \"res\" to an empty list, and call the \"backtrack\" function with an empty combination and the original phone number.\\n\\n- Finally, we return the final list of combinations.\\n\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n        \\n        phone = {\"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\", \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"}\\n        res = []\\n        \\n        def backtrack(combination, next_digits):\\n            if not next_digits:\\n                res.append(combination)\\n                return\\n            \\n            for letter in phone[next_digits[0]]:\\n                backtrack(combination + letter, next_digits[1:])\\n        \\n        backtrack(\"\", digits)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8167,
                "title": "java-c-clean-code-7-solutions-backtrack-queue",
                "content": "### Java\\n\\n#### Backtrack - Key Pad as Map\\n```java\\nclass Solution {\\n\\n    static Map<Character, String> NUMS = new HashMap() {\\n        {\\n            put(\\'0\\', \"\");\\n            put(\\'1\\', \"\");\\n            put(\\'2\\', \"abc\");\\n            put(\\'3\\', \"def\");\\n            put(\\'4\\', \"ghi\");\\n            put(\\'5\\', \"jkl\");\\n            put(\\'6\\', \"mno\");\\n            put(\\'7\\', \"pqrs\");\\n            put(\\'8\\', \"tuv\");\\n            put(\\'9\\', \"wxyz\");\\n        }\\n    };\\n\\n    public List<String> letterCombinations(String digits) {\\n        if (digits.length() == 0) {\\n            return new ArrayList<String>();\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        List<String> res = new ArrayList<>();\\n        dfs(sb, 0, digits, NUMS, res);\\n\\n        return res;\\n    }\\n\\n    private void dfs(StringBuilder sb, int index, String digits, Map<Character, String> nums, List<String> res) {\\n        if (index == digits.length()) {\\n            res.add(sb.toString());\\n            return;\\n        }\\n\\n        char digit = digits.charAt(index);\\n        String options = nums.getOrDefault(digit, digit + \"\");\\n        for (char option : options.toCharArray()) {\\n            sb.append(option);\\n            dfs(sb, index + 1, digits, nums, res);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n    }\\n}\\n```\\n\\n#### Backtrack - Key Pad as Array\\n\\n```java\\nclass Solution {\\n\\n    static String[] KEYPAD = new String[]{\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        StringBuilder sb = new StringBuilder();\\n        List<String> res = new ArrayList<>();\\n        dfs(sb, 0, digits, KEYPAD, res);\\n\\n        return res;\\n    }\\n\\n    private void dfs(StringBuilder sb, int index, String digits, String[] keypad, List<String> res) {\\n        if (index == digits.length()) {\\n            res.add(sb.toString());\\n            return;\\n        }\\n\\n        String options = keypad[digits.charAt(index) - \\'0\\'];\\n        for (char option : options.toCharArray()) {\\n            sb.append(option);\\n            dfs(sb, index + 1, digits, keypad, res);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n### C++\\n\\n#### CPP - Recursion\\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if (!digits.size()) {\\n            return {};\\n        }\\n\\n        vector<string> combs;\\n        const vector<string> chars = { \"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n        string builder;\\n        build(builder, 0, digits, chars, combs);\\n        return combs;\\n    }\\n\\n    /**\\n     * start with an empty builder, for every digit, use all chars it represents to attach to the builder, when i reaches the end of digits, push builder to result;\\n     */\\n    void build(string builder, int i, const string& digits, const vector<string>& chars, vector<string>& combs) {\\n        if (i == digits.size()) {\\n            combs.push_back(builder);\\n            return;\\n        }\\n\\n        int d = digits[i] - \\'0\\';\\n        for (char ch : chars[d]) {\\n            build(builder + ch, i + 1, digits, chars, combs);\\n        }\\n    }\\n};\\n```\\n\\n#### CPP - Iterative\\n\\n###### BFS Single deque\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if (digits.empty()) {\\n            return vector<string>();\\n        }\\n        vector<string> words{ \" \", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n        deque<string> q;\\n        q.push_back(\"\");\\n\\n        for (char digit : digits) {\\n            int d = digit - \\'0\\';\\n            for (int i = q.size(); i > 0; i--) {\\n                string token = q.front();\\n                q.pop_front();\\n                for (char ch : words[d]) {\\n                    q.push_back(token + ch);\\n                }\\n            }\\n        }\\n\\n        return vector<string>(q.begin(), q.end());\\n    }\\n};\\n```\\n\\n##### BFS Double deque\\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if (digits.empty()) {\\n            return vector<string>();\\n        }\\n        vector<string> words{ \" \", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n        deque<string> q, next;\\n        q.push_back(\"\");\\n\\n        for (char digit : digits) {\\n            int d = digit - \\'0\\';\\n            while (!q.empty()) {\\n                string token = q.front();\\n                q.pop_front();\\n                for (char ch : words[d]) {\\n                    next.push_back(token + ch);\\n                }\\n            }\\n            swap(q, next);\\n        }\\n\\n        return vector<string>(q.begin(), q.end());\\n    }\\n};\\n```\\n##### BFS - rolling vector\\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if (!digits.size()) {\\n            return {};\\n        }\\n\\n        vector<string> combs{ \"\" };\\n        vector<string> chars = { \"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n        for (char digit : digits) {\\n            int d = digit - \\'0\\';\\n            vector<string> next;\\n            for (string comb : combs) {\\n                for (char ch : chars[d]) {\\n                    next.push_back(comb + ch);\\n                }\\n            }\\n            combs.swap(next);\\n        }\\n\\n        return combs;\\n    }\\n};\\n```\\n##### BFS - rolling vector - Recycle Next\\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if (!digits.size()) {\\n            return {};\\n        }\\n\\n        vector<string> combs{ \"\" }, next;\\n        vector<string> chars = { \"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n        for (char digit : digits) {\\n            int d = digit - \\'0\\';\\n            for (string comb : combs) {\\n                for (char ch : chars[d]) {\\n                    next.push_back(comb + ch);\\n                }\\n            }\\n            combs.swap(next);\\n            next.clear();\\n        }\\n\\n        return combs;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n\\n    static Map<Character, String> NUMS = new HashMap() {\\n        {\\n            put(\\'0\\', \"\");\\n            put(\\'1\\', \"\");\\n            put(\\'2\\', \"abc\");\\n            put(\\'3\\', \"def\");\\n            put(\\'4\\', \"ghi\");\\n            put(\\'5\\', \"jkl\");\\n            put(\\'6\\', \"mno\");\\n            put(\\'7\\', \"pqrs\");\\n            put(\\'8\\', \"tuv\");\\n            put(\\'9\\', \"wxyz\");\\n        }\\n    };\\n\\n    public List<String> letterCombinations(String digits) {\\n        if (digits.length() == 0) {\\n            return new ArrayList<String>();\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        List<String> res = new ArrayList<>();\\n        dfs(sb, 0, digits, NUMS, res);\\n\\n        return res;\\n    }\\n\\n    private void dfs(StringBuilder sb, int index, String digits, Map<Character, String> nums, List<String> res) {\\n        if (index == digits.length()) {\\n            res.add(sb.toString());\\n            return;\\n        }\\n\\n        char digit = digits.charAt(index);\\n        String options = nums.getOrDefault(digit, digit + \"\");\\n        for (char option : options.toCharArray()) {\\n            sb.append(option);\\n            dfs(sb, index + 1, digits, nums, res);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n\\n    static String[] KEYPAD = new String[]{\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        StringBuilder sb = new StringBuilder();\\n        List<String> res = new ArrayList<>();\\n        dfs(sb, 0, digits, KEYPAD, res);\\n\\n        return res;\\n    }\\n\\n    private void dfs(StringBuilder sb, int index, String digits, String[] keypad, List<String> res) {\\n        if (index == digits.length()) {\\n            res.add(sb.toString());\\n            return;\\n        }\\n\\n        String options = keypad[digits.charAt(index) - \\'0\\'];\\n        for (char option : options.toCharArray()) {\\n            sb.append(option);\\n            dfs(sb, index + 1, digits, keypad, res);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if (!digits.size()) {\\n            return {};\\n        }\\n\\n        vector<string> combs;\\n        const vector<string> chars = { \"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n        string builder;\\n        build(builder, 0, digits, chars, combs);\\n        return combs;\\n    }\\n\\n    /**\\n     * start with an empty builder, for every digit, use all chars it represents to attach to the builder, when i reaches the end of digits, push builder to result;\\n     */\\n    void build(string builder, int i, const string& digits, const vector<string>& chars, vector<string>& combs) {\\n        if (i == digits.size()) {\\n            combs.push_back(builder);\\n            return;\\n        }\\n\\n        int d = digits[i] - \\'0\\';\\n        for (char ch : chars[d]) {\\n            build(builder + ch, i + 1, digits, chars, combs);\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if (digits.empty()) {\\n            return vector<string>();\\n        }\\n        vector<string> words{ \" \", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n        deque<string> q;\\n        q.push_back(\"\");\\n\\n        for (char digit : digits) {\\n            int d = digit - \\'0\\';\\n            for (int i = q.size(); i > 0; i--) {\\n                string token = q.front();\\n                q.pop_front();\\n                for (char ch : words[d]) {\\n                    q.push_back(token + ch);\\n                }\\n            }\\n        }\\n\\n        return vector<string>(q.begin(), q.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if (digits.empty()) {\\n            return vector<string>();\\n        }\\n        vector<string> words{ \" \", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n        deque<string> q, next;\\n        q.push_back(\"\");\\n\\n        for (char digit : digits) {\\n            int d = digit - \\'0\\';\\n            while (!q.empty()) {\\n                string token = q.front();\\n                q.pop_front();\\n                for (char ch : words[d]) {\\n                    next.push_back(token + ch);\\n                }\\n            }\\n            swap(q, next);\\n        }\\n\\n        return vector<string>(q.begin(), q.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if (!digits.size()) {\\n            return {};\\n        }\\n\\n        vector<string> combs{ \"\" };\\n        vector<string> chars = { \"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n        for (char digit : digits) {\\n            int d = digit - \\'0\\';\\n            vector<string> next;\\n            for (string comb : combs) {\\n                for (char ch : chars[d]) {\\n                    next.push_back(comb + ch);\\n                }\\n            }\\n            combs.swap(next);\\n        }\\n\\n        return combs;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if (!digits.size()) {\\n            return {};\\n        }\\n\\n        vector<string> combs{ \"\" }, next;\\n        vector<string> chars = { \"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n        for (char digit : digits) {\\n            int d = digit - \\'0\\';\\n            for (string comb : combs) {\\n                for (char ch : chars[d]) {\\n                    next.push_back(comb + ch);\\n                }\\n            }\\n            combs.swap(next);\\n            next.clear();\\n        }\\n\\n        return combs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8067,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        if not digits:\\n            return []\\n        m = {\"2\":\"abc\", \\'3\\':\"def\", \\'4\\':\"ghi\", \\'5\\':\"jkl\", \\'6\\':\"mno\", \\'7\\':\"pqrs\", \\'8\\':\"tuv\", \\'9\\':\"wxyz\"}\\n        ret = []\\n        self.dfs(m, digits, \"\", ret)\\n        return ret\\n    \\n    def dfs(self, m, digits, path, ret):\\n        if not digits:\\n            ret.append(path)\\n            return \\n        for c in m[digits[0]]:\\n            self.dfs(m, digits[1:], path+c, ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        if not digits:\\n            return []\\n        m = {\"2\":\"abc\", \\'3\\':\"def\", \\'4\\':\"ghi\", \\'5\\':\"jkl\", \\'6\\':\"mno\", \\'7\\':\"pqrs\", \\'8\\':\"tuv\", \\'9\\':\"wxyz\"}\\n        ret = []\\n        self.dfs(m, digits, \"\", ret)\\n        return ret\\n    \\n    def dfs(self, m, digits, path, ret):\\n        if not digits:\\n            ret.append(path)\\n            return \\n        for c in m[digits[0]]:\\n            self.dfs(m, digits[1:], path+c, ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148310,
                "title": "js-python-java-c-easy-recursive-dfs-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince each digit can possibly mean one of several characters, we\\'ll need to create code that branches down the different paths as we iterate through the input digit string (**D**).\\n\\nThis quite obviously calls for a **depth-first search** (**DFS**) approach as we will check each permutation of characters and store them in our answer array (**ans**). For a DFS approach we can use one of several options, but a **recursive** solution is generally the cleanest.\\n\\nBut first, we\\'ll need to set up a lookup table (**L**) to convert a digit to its possible characters. Since the digits are actually low-indexed integers, we can actually choose between an **array** or **map**/**dictionary** here with little difference.\\n\\nFor our DFS function (**dfs**), we\\'ll have to feed it the current position (**pos**) in **D** as well as the string (**str**) being built. The function will also need to have access to **D**, **L**, and **ans**.\\n\\nThe DFS function itself is fairly simple. It will push a completed **str** onto **ans**, otherwise it will look up the characters that match the current **pos**, and then fire off new recursive functions down each of those paths.\\n\\nOnce we\\'re done, we should be ready to **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript and Python will have scoped access to **D**, **L**, and **ans** inside **dfs**, so won\\'t need to pass in references via arguments.\\n\\nJava should make sure to use a **char[][]** and a **StringBuilder** for better performance here.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.4MB** (beats 97% / 92%).\\n```javascript\\nconst L = {\\'2\\':\"abc\",\\'3\\':\"def\",\\'4\\':\"ghi\",\\'5\\':\"jkl\",\\n     \\'6\\':\"mno\",\\'7\\':\"pqrs\",\\'8\\':\"tuv\",\\'9\\':\"wxyz\"}\\n\\nvar letterCombinations = function(D) {\\n    let len = D.length, ans = []\\n    if (!len) return []\\n    const dfs = (pos, str) => {\\n        if (pos === len) ans.push(str)\\n        else {\\n            let letters = L[D[pos]]\\n            for (let i = 0; i < letters.length; i++)\\n                dfs(pos+1,str+letters[i])\\n        }\\n    }\\n    dfs(0,\"\")\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.2MB** (beats 95% / 86%).\\n```python\\nL = {\\'2\\':\"abc\",\\'3\\':\"def\",\\'4\\':\"ghi\",\\'5\\':\"jkl\",\\n     \\'6\\':\"mno\",\\'7\\':\"pqrs\",\\'8\\':\"tuv\",\\'9\\':\"wxyz\"}\\n\\nclass Solution:\\n    def letterCombinations(self, D: str) -> List[str]:\\n        lenD, ans = len(D), []\\n        if D == \"\": return []\\n        def dfs(pos: int, st: str):\\n            if pos == lenD: ans.append(st)\\n            else:\\n                letters = L[D[pos]]\\n                for letter in letters:\\n                    dfs(pos+1,st+letter)\\n        dfs(0,\"\")\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 37.5MB** (beats 100% / 94%).\\n```java\\nclass Solution {\\n    final char[][] L = {{},{},{\\'a\\',\\'b\\',\\'c\\'},{\\'d\\',\\'e\\',\\'f\\'},{\\'g\\',\\'h\\',\\'i\\'},{\\'j\\',\\'k\\',\\'l\\'},\\n\\t{\\'m\\',\\'n\\',\\'o\\'},{\\'p\\',\\'q\\',\\'r\\',\\'s\\'},{\\'t\\',\\'u\\',\\'v\\'},{\\'w\\',\\'x\\',\\'y\\',\\'z\\'}};\\n    \\n    public List<String> letterCombinations(String D) {\\n        int len = D.length();\\n        List<String> ans = new ArrayList<>();\\n        if (len == 0) return ans;\\n        dfs(0, len, new StringBuilder(), ans, D);\\n        return ans;\\n    }\\n    \\n    public void dfs(int pos, int len, StringBuilder sb, List<String> ans, String D) {\\n        if (pos == len) ans.add(sb.toString());\\n        else {\\n            char[] letters = L[Character.getNumericValue(D.charAt(pos))];\\n            for (int i = 0; i < letters.length; i++)\\n                dfs(pos+1, len, new StringBuilder(sb).append(letters[i]), ans, D);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 6.4MB** (beats 100% / 96%).\\n```c++\\nunordered_map<char, string> L({{\\'2\\',\"abc\"},{\\'3\\',\"def\"},{\\'4\\',\"ghi\"},\\n    {\\'5\\',\"jkl\"},{\\'6\\',\"mno\"},{\\'7\\',\"pqrs\"},{\\'8\\',\"tuv\"},{\\'9\\',\"wxyz\"}});\\n\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string D) {\\n        int len = D.size();\\n        vector<string> ans;\\n        if (!len) return ans;\\n        dfs(0, len, \"\", ans, D);\\n        return ans;\\n    }\\n    \\n    void dfs(int pos, int &len, string str, vector<string> &ans, string &D) {\\n        if (pos == len) ans.push_back(str);\\n        else {\\n            string letters = L[D[pos]];\\n            for (int i = 0; i < letters.size(); i++)\\n                dfs(pos+1, len, str+letters[i], ans, D);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nconst L = {\\'2\\':\"abc\",\\'3\\':\"def\",\\'4\\':\"ghi\",\\'5\\':\"jkl\",\\n     \\'6\\':\"mno\",\\'7\\':\"pqrs\",\\'8\\':\"tuv\",\\'9\\':\"wxyz\"}\\n\\nvar letterCombinations = function(D) {\\n    let len = D.length, ans = []\\n    if (!len) return []\\n    const dfs = (pos, str) => {\\n        if (pos === len) ans.push(str)\\n        else {\\n            let letters = L[D[pos]]\\n            for (let i = 0; i < letters.length; i++)\\n                dfs(pos+1,str+letters[i])\\n        }\\n    }\\n    dfs(0,\"\")\\n    return ans\\n};\\n```\n```python\\nL = {\\'2\\':\"abc\",\\'3\\':\"def\",\\'4\\':\"ghi\",\\'5\\':\"jkl\",\\n     \\'6\\':\"mno\",\\'7\\':\"pqrs\",\\'8\\':\"tuv\",\\'9\\':\"wxyz\"}\\n\\nclass Solution:\\n    def letterCombinations(self, D: str) -> List[str]:\\n        lenD, ans = len(D), []\\n        if D == \"\": return []\\n        def dfs(pos: int, st: str):\\n            if pos == lenD: ans.append(st)\\n            else:\\n                letters = L[D[pos]]\\n                for letter in letters:\\n                    dfs(pos+1,st+letter)\\n        dfs(0,\"\")\\n        return ans\\n```\n```java\\nclass Solution {\\n    final char[][] L = {{},{},{\\'a\\',\\'b\\',\\'c\\'},{\\'d\\',\\'e\\',\\'f\\'},{\\'g\\',\\'h\\',\\'i\\'},{\\'j\\',\\'k\\',\\'l\\'},\\n\\t{\\'m\\',\\'n\\',\\'o\\'},{\\'p\\',\\'q\\',\\'r\\',\\'s\\'},{\\'t\\',\\'u\\',\\'v\\'},{\\'w\\',\\'x\\',\\'y\\',\\'z\\'}};\\n    \\n    public List<String> letterCombinations(String D) {\\n        int len = D.length();\\n        List<String> ans = new ArrayList<>();\\n        if (len == 0) return ans;\\n        dfs(0, len, new StringBuilder(), ans, D);\\n        return ans;\\n    }\\n    \\n    public void dfs(int pos, int len, StringBuilder sb, List<String> ans, String D) {\\n        if (pos == len) ans.add(sb.toString());\\n        else {\\n            char[] letters = L[Character.getNumericValue(D.charAt(pos))];\\n            for (int i = 0; i < letters.length; i++)\\n                dfs(pos+1, len, new StringBuilder(sb).append(letters[i]), ans, D);\\n        }\\n    }\\n}\\n```\n```c++\\nunordered_map<char, string> L({{\\'2\\',\"abc\"},{\\'3\\',\"def\"},{\\'4\\',\"ghi\"},\\n    {\\'5\\',\"jkl\"},{\\'6\\',\"mno\"},{\\'7\\',\"pqrs\"},{\\'8\\',\"tuv\"},{\\'9\\',\"wxyz\"}});\\n\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string D) {\\n        int len = D.size();\\n        vector<string> ans;\\n        if (!len) return ans;\\n        dfs(0, len, \"\", ans, D);\\n        return ans;\\n    }\\n    \\n    void dfs(int pos, int &len, string str, vector<string> &ans, string &D) {\\n        if (pos == len) ans.push_back(str);\\n        else {\\n            string letters = L[D[pos]];\\n            for (int i = 0; i < letters.size(); i++)\\n                dfs(pos+1, len, str+letters[i], ans, D);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326604,
                "title": "my-non-recursive-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits: return []\\n        digit_map = {\\'2\\': \\'abc\\', \\'3\\': \\'def\\', \\'4\\': \\'ghi\\', \\'5\\': \\'jkl\\', \\'6\\': \\'mno\\', \\n                     \\'7\\': \\'pqrs\\', \\'8\\': \\'tuv\\', \\'9\\': \\'wxyz\\'}\\n        result = [\\'\\']\\n        for idx in range(len(digits)):\\n            result = [prev + l for prev in result for l in digit_map[digits[idx]]]\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits: return []\\n        digit_map = {\\'2\\': \\'abc\\', \\'3\\': \\'def\\', \\'4\\': \\'ghi\\', \\'5\\': \\'jkl\\', \\'6\\': \\'mno\\', \\n                     \\'7\\': \\'pqrs\\', \\'8\\': \\'tuv\\', \\'9\\': \\'wxyz\\'}\\n        result = [\\'\\']\\n        for idx in range(len(digits)):\\n            result = [prev + l for prev in result for l in digit_map[digits[idx]]]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 139447,
                "title": "clean-javascript-solution-backtracking",
                "content": "```js\\n// Time O(3^N * 4^M)\\n//   N is the number of digits in the input that maps to 3 letters (e.g. 2, 3, 4, 5, 6, 8)\\n//   M is the number of digits in the input that maps to 4 letters (e.g. 7, 9)\\n//\\n// Space O(3^N * 4^M) since one has to keep O(3^N * 4^M) solutions.\\nconst letterCombinations = (digits) => {\\n  if (digits == null || digits.length === 0) return [];\\n\\n  const map = {\\n    2: \\'abc\\',\\n    3: \\'def\\',\\n    4: \\'ghi\\',\\n    5: \\'jkl\\',\\n    6: \\'mno\\',\\n    7: \\'pqrs\\',\\n    8: \\'tuv\\',\\n    9: \\'wxyz\\',\\n  };\\n\\n  const res = [];\\n  const go = (i, s) => {\\n    if (i === digits.length) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    for (const c of map[digits[i]]) {\\n      go(i + 1, s + c);\\n    }\\n  };\\n\\n  go(0, \\'\\');\\n  return res;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```js\\n// Time O(3^N * 4^M)\\n//   N is the number of digits in the input that maps to 3 letters (e.g. 2, 3, 4, 5, 6, 8)\\n//   M is the number of digits in the input that maps to 4 letters (e.g. 7, 9)\\n//\\n// Space O(3^N * 4^M) since one has to keep O(3^N * 4^M) solutions.\\nconst letterCombinations = (digits) => {\\n  if (digits == null || digits.length === 0) return [];\\n\\n  const map = {\\n    2: \\'abc\\',\\n    3: \\'def\\',\\n    4: \\'ghi\\',\\n    5: \\'jkl\\',\\n    6: \\'mno\\',\\n    7: \\'pqrs\\',\\n    8: \\'tuv\\',\\n    9: \\'wxyz\\',\\n  };\\n\\n  const res = [];\\n  const go = (i, s) => {\\n    if (i === digits.length) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    for (const c of map[digits[i]]) {\\n      go(i + 1, s + c);\\n    }\\n  };\\n\\n  go(0, \\'\\');\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 562004,
                "title": "c-java-dfs-solution-clean-code",
                "content": "**Idea**\\n- Just backtracking to generate all possible combinations.\\n\\n<iframe src=\"https://leetcode.com/playground/PmVkRrRb/shared\" frameBorder=\"0\" width=\"100%\" height=\"440\"></iframe>\\n\\n**Complexity**\\n- Time: `O(4^N * N)`, where `N <= 4` is length of `digits` string. Here, `4` is chosen assuming the worst case where each digit will be `7` or `9`.\\n- Extra Space (without counting output as space): `O(N)`, it\\'s the depth of stack memory.",
                "solutionTags": [],
                "code": "**Idea**\\n- Just backtracking to generate all possible combinations.\\n\\n<iframe src=\"https://leetcode.com/playground/PmVkRrRb/shared\" frameBorder=\"0\" width=\"100%\" height=\"440\"></iframe>\\n\\n**Complexity**\\n- Time: `O(4^N * N)`, where `N <= 4` is length of `digits` string. Here, `4` is chosen assuming the worst case where each digit will be `7` or `9`.\\n- Extra Space (without counting output as space): `O(N)`, it\\'s the depth of stack memory.",
                "codeTag": "Unknown"
            },
            {
                "id": 3855474,
                "title": "100-backtracking-iterative-video-letter-combinations-of-a-phone-number",
                "content": "# Intuition\\nGiven a string containing digits from 2-9 inclusive, we need to return all possible letter combinations that the number could represent, just like on a telephone\\'s buttons. To accomplish this, we present two different approaches:\\n\\n1. **Backtracking Approach**: This approach leverages recursion to explore all possible combinations. We create a recursive function that takes the current combination and the next digits to explore. For each digit, we iterate through its corresponding letters and recursively explore the remaining digits. We append the combination when no more digits are left to explore.\\n\\n2. **Iterative Approach**: This approach builds the combinations iteratively without using recursion. We start with an empty combination and iteratively add letters for each digit in the input string. For each existing combination, we append each corresponding letter for the current digit, building new combinations.\\n\\n**Differences**:\\n- The backtracking approach relies on recursion to explore all possible combinations, whereas the iterative approach builds combinations step by step using loops.\\n- Both approaches have similar time complexity, but the iterative approach might save some function call overhead, leading to more efficient execution in some cases.\\n\\nDetailed explanations of both approaches, along with their corresponding code, are provided below. By presenting both methods, we offer a comprehensive view of how to tackle this problem, allowing for flexibility and understanding of different programming paradigms.\\n\\nhttps://youtu.be/Jobb9YUFUq0\\n\\n# Approach - Backtracking\\n1. **Initialize a Mapping**: Create a dictionary that maps each digit from 2 to 9 to their corresponding letters on a telephone\\'s buttons. For example, the digit \\'2\\' maps to \"abc,\" \\'3\\' maps to \"def,\" and so on.\\n\\n2. **Base Case**: Check if the input string `digits` is empty. If it is, return an empty list, as there are no combinations to generate.\\n\\n3. **Recursive Backtracking**:\\n   - **Define Recursive Function**: Create a recursive function, `backtrack`, that will be used to explore all possible combinations. It takes two parameters: `combination`, which holds the current combination of letters, and `next_digits`, which holds the remaining digits to be explored.\\n   - **Termination Condition**: If `next_digits` is empty, it means that all digits have been processed, so append the current `combination` to the result.\\n   - **Exploration**: If there are more digits to explore, take the first digit from `next_digits` and iterate over its corresponding letters in the mapping. For each letter, concatenate it to the current combination and recursively call the `backtrack` function with the new combination and the remaining digits.\\n   - **Example**: If the input is \"23\", the first recursive call explores all combinations starting with \\'a\\', \\'b\\', and \\'c\\' (from \\'2\\'), and the next level of recursive calls explores combinations starting with \\'d\\', \\'e\\', \\'f\\' (from \\'3\\'), building combinations like \"ad,\" \"ae,\" \"af,\" \"bd,\" \"be,\" etc.\\n\\n4. **Result**: Once the recursive exploration is complete, return the collected combinations as the final result. By using recursion, we ensure that all possible combinations are explored, and the result includes all valid letter combinations that the input digits can represent.\\n\\n# Complexity\\n- Time complexity: \\\\( O(4^n) \\\\), where \\\\( n \\\\) is the length of the input string. In the worst case, each digit can represent 4 letters, so there will be 4 recursive calls for each digit.\\n- Space complexity: \\\\( O(n) \\\\), where \\\\( n \\\\) is the length of the input string. This accounts for the recursion stack space.\\n\\n# Code - Backtracking\\n``` Python []\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n\\n        phone_map = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n\\n        def backtrack(combination, next_digits):\\n            if len(next_digits) == 0:\\n                output.append(combination)\\n            else:\\n                for letter in phone_map[next_digits[0]]:\\n                    backtrack(combination + letter, next_digits[1:])\\n\\n        output = []\\n        backtrack(\"\", digits)\\n        return output\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> letterCombinations(std::string digits) {\\n        if (digits.empty()) return {};\\n\\n        std::string phone_map[] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        std::vector<std::string> output;\\n        backtrack(\"\", digits, phone_map, output);\\n        return output;\\n    }\\n\\nprivate:\\n    void backtrack(std::string combination, std::string next_digits, std::string phone_map[], std::vector<std::string>& output) {\\n        if (next_digits.empty()) {\\n            output.push_back(combination);\\n        } else {\\n            std::string letters = phone_map[next_digits[0] - \\'2\\'];\\n            for (char letter : letters) {\\n                backtrack(combination + letter, next_digits.substr(1), phone_map, output);\\n            }\\n        }\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        if (digits.isEmpty()) return Collections.emptyList();\\n\\n        String[] phone_map = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        List<String> output = new ArrayList<>();\\n        backtrack(\"\", digits, phone_map, output);\\n        return output;\\n    }\\n\\n    private void backtrack(String combination, String next_digits, String[] phone_map, List<String> output) {\\n        if (next_digits.isEmpty()) {\\n            output.add(combination);\\n        } else {\\n            String letters = phone_map[next_digits.charAt(0) - \\'2\\'];\\n            for (char letter : letters.toCharArray()) {\\n                backtrack(combination + letter, next_digits.substring(1), phone_map, output);\\n            }\\n        }\\n    }\\n}\\n```\\n``` JavaSxript []\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nvar letterCombinations = function(digits) {\\n    if (digits.length === 0) return [];\\n\\n    const phone_map = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\\n    const output = [];\\n    backtrack(\"\", digits, phone_map, output);\\n    return output;\\n\\n    function backtrack(combination, next_digits, phone_map, output) {\\n        if (next_digits.length === 0) {\\n            output.push(combination);\\n        } else {\\n            const letters = phone_map[next_digits[0] - \\'2\\'];\\n            for (const letter of letters) {\\n                backtrack(combination + letter, next_digits.slice(1), phone_map, output);\\n            }\\n        }\\n    }\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<string> LetterCombinations(string digits) {\\n        if (string.IsNullOrEmpty(digits)) return new List<string>();\\n\\n        string[] phone_map = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        List<string> output = new List<string>();\\n        Backtrack(\"\", digits, phone_map, output);\\n        return output;\\n    }\\n\\n    private void Backtrack(string combination, string next_digits, string[] phone_map, List<string> output) {\\n        if (next_digits.Length == 0) {\\n            output.Add(combination);\\n        } else {\\n            string letters = phone_map[next_digits[0] - \\'2\\'];\\n            foreach (char letter in letters) {\\n                Backtrack(combination + letter, next_digits.Substring(1), phone_map, output);\\n            }\\n        }\\n    }\\n}\\n```\\n``` Go []\\nfunc letterCombinations(digits string) []string {\\n\\tif digits == \"\" {\\n\\t\\treturn []string{}\\n\\t}\\n\\n\\tphoneMap := []string{\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}\\n\\tvar output []string\\n\\n\\tvar backtrack func(combination string, nextDigits string)\\n\\tbacktrack = func(combination string, nextDigits string) {\\n\\t\\tif nextDigits == \"\" {\\n\\t\\t\\toutput = append(output, combination)\\n\\t\\t} else {\\n\\t\\t\\tletters := phoneMap[nextDigits[0]-\\'2\\']\\n\\t\\t\\tfor _, letter := range letters {\\n\\t\\t\\t\\tbacktrack(combination+string(letter), nextDigits[1:])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbacktrack(\"\", digits)\\n\\treturn output\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn letter_combinations(digits: String) -> Vec<String> {\\n        if digits.is_empty() {\\n            return vec![];\\n        }\\n\\n        let phone_map = vec![\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\\n        let mut output = Vec::new();\\n\\n        fn backtrack(combination: String, next_digits: &str, phone_map: &Vec<&str>, output: &mut Vec<String>) {\\n            if next_digits.is_empty() {\\n                output.push(combination);\\n            } else {\\n                let letters = phone_map[next_digits.chars().nth(0).unwrap() as usize - \\'2\\' as usize];\\n                for letter in letters.chars() {\\n                    let new_combination = combination.clone() + &letter.to_string();\\n                    backtrack(new_combination, &next_digits[1..], phone_map, output);\\n                }\\n            }\\n        }\\n\\n        backtrack(String::new(), &digits, &phone_map, &mut output);\\n        output\\n    }\\n}\\n```\\nThis code can handle any input string containing digits from 2 to 9 and will return the possible letter combinations in any order. The function `backtrack` is used to handle the recursive exploration of combinations, and `phone_map` contains the mapping between digits and letters.\\n\\n## Performance - Backtracking\\n\\n| Language    | Runtime (ms) | Beats (%) | Memory (MB) |\\n|-------------|--------------|-----------|-------------|\\n| C++         | 0            | 100.00    | 6.4         |\\n| Go          | 0            | 100.00    | 2.0         |\\n| Rust        | 1            | 82.50     | 2.1         |\\n| Java        | 5            | 50.30     | 41.6        |\\n| Swift       | 2            | 82.38     | 14.0        |\\n| Python3     | 34           | 96.91     | 16.3        |\\n| TypeScript  | 49           | 96.36     | 44.3        |\\n| JavaScript  | 58           | 55.17     | 42.2        |\\n| Ruby        | 58           | 97.98     | 211.1       |\\n| C#          | 136          | 89.14     | 43.9        |\\n\\n# Video Iterative\\nhttps://youtu.be/43x3sg_nND8\\n\\n# Approach - Iterative\\n1. **Initialize a Mapping**: Create a dictionary that maps each digit from 2 to 9 to their corresponding letters on a telephone\\'s buttons.\\n2. **Base Case**: If the input string `digits` is empty, return an empty list.\\n3. **Iteratively Build Combinations**: Start with an empty combination in a list and iteratively build the combinations by processing each digit in the input string.\\n   - For each existing combination, append each corresponding letter for the current digit, building new combinations.\\n4. **Result**: Return the generated combinations as the final result.\\n\\n# Complexity\\n- Time complexity: \\\\( O(4^n) \\\\), where \\\\( n \\\\) is the length of the input string. In the worst case, each digit can represent 4 letters.\\n- Space complexity: \\\\( O(n) \\\\), where \\\\( n \\\\) is the length of the input string.\\n\\n# Code - Iterative\\n``` Python []\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n\\n        phone_map = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n        combinations = [\"\"]\\n\\n        for digit in digits:\\n            new_combinations = []\\n            for combination in combinations:\\n                for letter in phone_map[digit]:\\n                    new_combinations.append(combination + letter)\\n            combinations = new_combinations\\n\\n        return combinations\\n```\\n``` JavaScript []\\nfunction letterCombinations(digits) {\\n  if (!digits) {\\n    return [];\\n  }\\n\\n  const phoneMap = {\\n    \\'2\\': \\'abc\\',\\n    \\'3\\': \\'def\\',\\n    \\'4\\': \\'ghi\\',\\n    \\'5\\': \\'jkl\\',\\n    \\'6\\': \\'mno\\',\\n    \\'7\\': \\'pqrs\\',\\n    \\'8\\': \\'tuv\\',\\n    \\'9\\': \\'wxyz\\'\\n  };\\n\\n  let combinations = [\\'\\'];\\n\\n  for (const digit of digits) {\\n    const newCombinations = [];\\n    for (const combination of combinations) {\\n      for (const letter of phoneMap[digit]) {\\n        newCombinations.push(combination + letter);\\n      }\\n    }\\n    combinations = newCombinations;\\n  }\\n\\n  return combinations;\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> letterCombinations(std::string digits) {\\n        if (digits.empty()) return {};\\n\\n        std::string phone_map[] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        std::vector<std::string> combinations = {\"\"};\\n\\n        for (char digit : digits) {\\n            std::vector<std::string> new_combinations;\\n            for (std::string combination : combinations) {\\n                for (char letter : phone_map[digit - \\'2\\']) {\\n                    new_combinations.push_back(combination + letter);\\n                }\\n            }\\n            combinations = new_combinations;\\n        }\\n\\n        return combinations;\\n    }\\n};\\n```\\n``` Go []\\nfunc letterCombinations(digits string) []string {\\n    if digits == \"\" {\\n        return []string{}\\n    }\\n\\n    phoneMap := []string{\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}\\n    combinations := []string{\"\"}\\n\\n    for _, digit := range digits {\\n        newCombinations := []string{}\\n        for _, combination := range combinations {\\n            for _, letter := range phoneMap[digit-\\'2\\'] {\\n                newCombinations = append(newCombinations, combination+string(letter))\\n            }\\n        }\\n        combinations = newCombinations\\n    }\\n\\n    return combinations\\n}\\n```\\n\\n\\nIf you find the solution understandable and helpful, don\\'t hesitate to give it an upvote. Engaging with the code across different languages might just lead you to discover new techniques and preferences! Happy coding! \\uD83D\\uDE80\\uD83E\\uDD80\\uD83D\\uDCDE\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Go"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n\\n        phone_map = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n\\n        def backtrack(combination, next_digits):\\n            if len(next_digits) == 0:\\n                output.append(combination)\\n            else:\\n                for letter in phone_map[next_digits[0]]:\\n                    backtrack(combination + letter, next_digits[1:])\\n\\n        output = []\\n        backtrack(\"\", digits)\\n        return output\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> letterCombinations(std::string digits) {\\n        if (digits.empty()) return {};\\n\\n        std::string phone_map[] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        std::vector<std::string> output;\\n        backtrack(\"\", digits, phone_map, output);\\n        return output;\\n    }\\n\\nprivate:\\n    void backtrack(std::string combination, std::string next_digits, std::string phone_map[], std::vector<std::string>& output) {\\n        if (next_digits.empty()) {\\n            output.push_back(combination);\\n        } else {\\n            std::string letters = phone_map[next_digits[0] - \\'2\\'];\\n            for (char letter : letters) {\\n                backtrack(combination + letter, next_digits.substr(1), phone_map, output);\\n            }\\n        }\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        if (digits.isEmpty()) return Collections.emptyList();\\n\\n        String[] phone_map = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        List<String> output = new ArrayList<>();\\n        backtrack(\"\", digits, phone_map, output);\\n        return output;\\n    }\\n\\n    private void backtrack(String combination, String next_digits, String[] phone_map, List<String> output) {\\n        if (next_digits.isEmpty()) {\\n            output.add(combination);\\n        } else {\\n            String letters = phone_map[next_digits.charAt(0) - \\'2\\'];\\n            for (char letter : letters.toCharArray()) {\\n                backtrack(combination + letter, next_digits.substring(1), phone_map, output);\\n            }\\n        }\\n    }\\n}\\n```\n``` JavaSxript []\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nvar letterCombinations = function(digits) {\\n    if (digits.length === 0) return [];\\n\\n    const phone_map = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\\n    const output = [];\\n    backtrack(\"\", digits, phone_map, output);\\n    return output;\\n\\n    function backtrack(combination, next_digits, phone_map, output) {\\n        if (next_digits.length === 0) {\\n            output.push(combination);\\n        } else {\\n            const letters = phone_map[next_digits[0] - \\'2\\'];\\n            for (const letter of letters) {\\n                backtrack(combination + letter, next_digits.slice(1), phone_map, output);\\n            }\\n        }\\n    }\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public IList<string> LetterCombinations(string digits) {\\n        if (string.IsNullOrEmpty(digits)) return new List<string>();\\n\\n        string[] phone_map = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        List<string> output = new List<string>();\\n        Backtrack(\"\", digits, phone_map, output);\\n        return output;\\n    }\\n\\n    private void Backtrack(string combination, string next_digits, string[] phone_map, List<string> output) {\\n        if (next_digits.Length == 0) {\\n            output.Add(combination);\\n        } else {\\n            string letters = phone_map[next_digits[0] - \\'2\\'];\\n            foreach (char letter in letters) {\\n                Backtrack(combination + letter, next_digits.Substring(1), phone_map, output);\\n            }\\n        }\\n    }\\n}\\n```\n``` Go []\\nfunc letterCombinations(digits string) []string {\\n\\tif digits == \"\" {\\n\\t\\treturn []string{}\\n\\t}\\n\\n\\tphoneMap := []string{\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}\\n\\tvar output []string\\n\\n\\tvar backtrack func(combination string, nextDigits string)\\n\\tbacktrack = func(combination string, nextDigits string) {\\n\\t\\tif nextDigits == \"\" {\\n\\t\\t\\toutput = append(output, combination)\\n\\t\\t} else {\\n\\t\\t\\tletters := phoneMap[nextDigits[0]-\\'2\\']\\n\\t\\t\\tfor _, letter := range letters {\\n\\t\\t\\t\\tbacktrack(combination+string(letter), nextDigits[1:])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbacktrack(\"\", digits)\\n\\treturn output\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn letter_combinations(digits: String) -> Vec<String> {\\n        if digits.is_empty() {\\n            return vec![];\\n        }\\n\\n        let phone_map = vec![\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\\n        let mut output = Vec::new();\\n\\n        fn backtrack(combination: String, next_digits: &str, phone_map: &Vec<&str>, output: &mut Vec<String>) {\\n            if next_digits.is_empty() {\\n                output.push(combination);\\n            } else {\\n                let letters = phone_map[next_digits.chars().nth(0).unwrap() as usize - \\'2\\' as usize];\\n                for letter in letters.chars() {\\n                    let new_combination = combination.clone() + &letter.to_string();\\n                    backtrack(new_combination, &next_digits[1..], phone_map, output);\\n                }\\n            }\\n        }\\n\\n        backtrack(String::new(), &digits, &phone_map, &mut output);\\n        output\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n\\n        phone_map = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n        combinations = [\"\"]\\n\\n        for digit in digits:\\n            new_combinations = []\\n            for combination in combinations:\\n                for letter in phone_map[digit]:\\n                    new_combinations.append(combination + letter)\\n            combinations = new_combinations\\n\\n        return combinations\\n```\n``` JavaScript []\\nfunction letterCombinations(digits) {\\n  if (!digits) {\\n    return [];\\n  }\\n\\n  const phoneMap = {\\n    \\'2\\': \\'abc\\',\\n    \\'3\\': \\'def\\',\\n    \\'4\\': \\'ghi\\',\\n    \\'5\\': \\'jkl\\',\\n    \\'6\\': \\'mno\\',\\n    \\'7\\': \\'pqrs\\',\\n    \\'8\\': \\'tuv\\',\\n    \\'9\\': \\'wxyz\\'\\n  };\\n\\n  let combinations = [\\'\\'];\\n\\n  for (const digit of digits) {\\n    const newCombinations = [];\\n    for (const combination of combinations) {\\n      for (const letter of phoneMap[digit]) {\\n        newCombinations.push(combination + letter);\\n      }\\n    }\\n    combinations = newCombinations;\\n  }\\n\\n  return combinations;\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> letterCombinations(std::string digits) {\\n        if (digits.empty()) return {};\\n\\n        std::string phone_map[] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        std::vector<std::string> combinations = {\"\"};\\n\\n        for (char digit : digits) {\\n            std::vector<std::string> new_combinations;\\n            for (std::string combination : combinations) {\\n                for (char letter : phone_map[digit - \\'2\\']) {\\n                    new_combinations.push_back(combination + letter);\\n                }\\n            }\\n            combinations = new_combinations;\\n        }\\n\\n        return combinations;\\n    }\\n};\\n```\n``` Go []\\nfunc letterCombinations(digits string) []string {\\n    if digits == \"\" {\\n        return []string{}\\n    }\\n\\n    phoneMap := []string{\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}\\n    combinations := []string{\"\"}\\n\\n    for _, digit := range digits {\\n        newCombinations := []string{}\\n        for _, combination := range combinations {\\n            for _, letter := range phoneMap[digit-\\'2\\'] {\\n                newCombinations = append(newCombinations, combination+string(letter))\\n            }\\n        }\\n        combinations = newCombinations\\n    }\\n\\n    return combinations\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022553,
                "title": "python-3-approaches-iterative-dfs-bfs-recursive-visuals-explanation",
                "content": "\\n----\\n**Idea**\\n----\\n----\\n* Problems requiring the generation of combinations/permuations can be thought of as a `N-ary tree`\\n* Once you mentally recognize the graph/tree nature behind the scences, you are basically half-way through\\n* Almost always we don\\'t have to explicitly build this tree/graph. Instead, we just need to figure out how to traverse it. \\n* We can traverse this \"implicit\" tree either iteratively or recursively\\n* The tree for this problem looks something like this:\\n![image](https://assets.leetcode.com/users/images/1073461f-851a-40ba-9659-56cde6cff9c9_1610950982.055568.png)\\n\\n\\n* Each digit maps to 3~4 letters which means we have many individual pieces/sub-trees/mappings of our tree\\n* How do we connect these sub-trees togther to make up the space-tree? See the orange arrows\\n* We have to make sure that the continuity is maintained when nodes are pushed into the stack (either implicit (as in recursive solution) or explicit (iterative solution).\\n\\t* Use an index i together with combination.\\n\\t*  when pushing to the stack, increment the index and concatenate the combination str\\n\\t*  This way, the stack knows what the next digit is going to be.\\n\\t*  Once your index reaches the last digit, we know we have combosed a str with the desired length and we append to results\\n![image](https://assets.leetcode.com/users/images/e8bcbbfe-fb2c-4225-ba25-de4dead5a5f0_1610951299.877838.png)\\n\\n**Big-O:**\\n* Time: \\n\\t* `O(E+V) where E = edges & V = verticies`, `E = 3 ~ 4` => Each letter maps to a 3 or 4 digits => `O(E)`. \\n\\t* `V = verticies in the tree (see figure below)`  \\n\\t\\t     `= all the digits + all the letters`\\n\\t\\t\\t = digits + digits*(3~4)\\n\\t\\t\\t =  `O(D)` `where D is the size of the digits string`\\n* Space:\\n\\t* `O(V)` -> result list to store the combinations\\n\\n--------\\n**[1] Iterative DFS**\\n----\\n----\\n**Code:**\\n```\\ndef letterCombinations(self, digits: str) -> List[str]:\\n\\n        if not digits:\\n            return []\\n        \\n        # bulild k:v pair dict to map digit -> letters\\n        d = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n        \\n        res = []\\n        stack = [(0, \"\")]\\n        while stack:\\n            i, combo = stack.pop() # i is an index kinda of node id\\n            if i == len(digits):\\n                res.append(combo)\\n            else:\\n                nextDigit = digits[i]\\n                children = d[nextDigit]\\n                for child in children:\\n                    stack.append((i+1, combo+child))\\n        return res\\n```\\n\\n-----\\n**[2] Iterative BFS**\\n----\\n-----\\n**Code:**\\n```\\ndef letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n        \\n        # bulild k:v pair dict to map digit -> letters\\n        d = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n        \\n        res = []\\n        from collections import deque\\n        q = deque()\\n        q.append((0, \"\"))\\n        while q:\\n            i, combo = q.popleft() # i is an index kinda of node id\\n            if i == len(digits):\\n                res.append(combo)\\n            else:\\n                nextDigit = digits[i]\\n                children = d[nextDigit]\\n                for child in children:\\n                    q.append((i+1, combo+child))\\n        return res\\n        \\n```\\n-----\\n**[3] Recursive DFS**\\n------\\n--------\\n**Code:**\\n```\\n\\ndef letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n        \\n        # bulild k:v pair dict to map digit -> letters\\n        d = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n\\n        # helper recursive\\n        def recursive(i=0, combo=\"\", res=[]):\\n            if i == len(digits):\\n                res.append(combo)\\n            else:\\n                nextDigit = digits[i]\\n                children = d[nextDigit]\\n                for child in children:\\n                    recursive(i+1, combo+child, res)\\n            \\n            return res\\n        # ---\\n        \\n        return recursive(0, \"\", [])\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef letterCombinations(self, digits: str) -> List[str]:\\n\\n        if not digits:\\n            return []\\n        \\n        # bulild k:v pair dict to map digit -> letters\\n        d = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n        \\n        res = []\\n        stack = [(0, \"\")]\\n        while stack:\\n            i, combo = stack.pop() # i is an index kinda of node id\\n            if i == len(digits):\\n                res.append(combo)\\n            else:\\n                nextDigit = digits[i]\\n                children = d[nextDigit]\\n                for child in children:\\n                    stack.append((i+1, combo+child))\\n        return res\\n```\n```\\ndef letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n        \\n        # bulild k:v pair dict to map digit -> letters\\n        d = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n        \\n        res = []\\n        from collections import deque\\n        q = deque()\\n        q.append((0, \"\"))\\n        while q:\\n            i, combo = q.popleft() # i is an index kinda of node id\\n            if i == len(digits):\\n                res.append(combo)\\n            else:\\n                nextDigit = digits[i]\\n                children = d[nextDigit]\\n                for child in children:\\n                    q.append((i+1, combo+child))\\n        return res\\n        \\n```\n```\\n\\ndef letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n        \\n        # bulild k:v pair dict to map digit -> letters\\n        d = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n\\n        # helper recursive\\n        def recursive(i=0, combo=\"\", res=[]):\\n            if i == len(digits):\\n                res.append(combo)\\n            else:\\n                nextDigit = digits[i]\\n                children = d[nextDigit]\\n                for child in children:\\n                    recursive(i+1, combo+child, res)\\n            \\n            return res\\n        # ---\\n        \\n        return recursive(0, \"\", [])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2021106,
                "title": "4-approaches-bf-4-loops-backtracking-bfs-queue-with-image-explanation",
                "content": "[Leetcode](https://leetcode.com/) [17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/).\\n\\nHere shows **4** Approaches to slove this problem: Brute Force, Backtracking, BFS and Queue.\\n\\n# Intuition\\n\\nTake the $234$ for example, look at the tree:\\n\\n![Tree](https://assets.leetcode.com/users/images/69adced7-10fe-4048-bff6-91fa1639b055_1652063610.0135918.png)\\n\\n# Brute Froce(4 Loops)\\n\\nSince the $\\\\textit{digits.length} <= 4$, we can just use the brute force approach $4$ Loops to search all the possible combinations. \\n\\nThe total states is $A(n,n)=A(4,4)=4!$. We have to **enumerate all these states** to get the answer.\\n\\n```java\\n    public static List<String> letterCombinations_4Loops(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        if (digits == null || digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        String[] letters = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        int len = digits.length();\\n        int[] digitsArr = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            digitsArr[i] = digits.charAt(i) - \\'0\\';\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < len; i++) {\\n            sb.append(\"a\");\\n        }\\n\\n        for (int i = 0; i < letters[digitsArr[0] - 2].length(); i++) {\\n            sb.replace(0, 1, letters[digitsArr[0] - 2].charAt(i) + \"\");\\n            if (len == 1) {\\n                ans.add(sb.substring(0, 1));\\n            }\\n\\n            for (int j = 0; len >= 2 && j < letters[digitsArr[1] - 2].length(); j++) {\\n                sb.replace(1, 2, letters[digitsArr[1] - 2].charAt(j) + \"\");\\n                if (len == 2) {\\n                    ans.add(sb.toString());\\n                }\\n\\n                for (int k = 0; len >= 3 && k < letters[digitsArr[2] - 2].length(); k++) {\\n                    sb.replace(2, 3, letters[digitsArr[2] - 2].charAt(k) + \"\");\\n                    if (len == 3) {\\n                        ans.add(sb.toString());\\n                    }\\n\\n                    for (int l = 0; len >= 4 && l < letters[digitsArr[3] - 2].length(); l++) {\\n                        sb.replace(3, 4, letters[digitsArr[3] - 2].charAt(l) + \"\");\\n                        ans.add(sb.toString());\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(4^N)$\\n- **Space Complexity**: $O(N)$\\n\\n\\n# Backtracking\\n\\nFor the first number, there are $3$ options, and $3$ options for the second number and so on.\\n\\nThe combinations from the first to the last will expand into a **recursive tree**. \\n\\nWhen the index reaches the end of digits, we get a combination, and add it to the result, end the current recursion. Finally we will get all the combinations.\\n\\n```java\\n    public static List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n\\n        if (digits == null || digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        String[] lettersMap = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        backtrack(ans, new StringBuilder(), digits, lettersMap, 0);\\n        return ans;\\n    }\\n\\n    public static void backtrack(List<String> res, StringBuilder sb, String digits, String[] lettersMap, int idx) {\\n        if (idx == digits.length()) {\\n            res.add(sb.toString());\\n            return;\\n        }\\n\\n        int number = digits.charAt(idx) - \\'0\\';\\n        String numStr = lettersMap[number - 2];\\n        for (int i = 0; i < numStr.length(); i++) {\\n            sb.append(numStr.charAt(i));\\n            backtrack(res, sb, digits, lettersMap, idx + 1);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(3^M \\\\times 4^N)$\\n- **Space Complexity**: $O(3^M \\\\times 4^N)$\\n\\n# BFS\\n\\n1. At the beginning, it is an empty string.\\n2. The new layer is obtained by adding characters at the end of the previous layer.\\n3. After the new layer is obtained, the previous layer is not used.\\n\\n```java\\n    public static List<String> letterCombinations_bfs(String digits) {\\n        List<String> res = new ArrayList<>();\\n        if (digits == null || digits.length() == 0) {\\n            return res;\\n        }\\n\\n        String[] letters = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        res.add(\"\");\\n        for (char digit : digits.toCharArray()) {\\n            String curLetters = letters[digit - \\'2\\'];\\n            List<String> newRes = new ArrayList<>();\\n\\n            for (String item : res) {\\n                for (char curDigit : curLetters.toCharArray()) {\\n                    newRes.add(item + curDigit);\\n                }\\n            }\\n\\n            res = newRes;\\n        }\\n\\n        return res;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(3^M \\\\times 4^N)$\\n- **Space Complexity**: $O(3^M \\\\times 4^N)$\\n\\n# Queue\\n\\nLook at the gif, it\\'s easy to understand the **queue** solution.\\n\\nFirst we enqueue each letter of the first number in the digits, and then combine the dequeued element with each letter of the second number and enqueue to the queue.\\n\\n![Queue](https://assets.leetcode.com/users/images/6bceca0e-ce2e-4276-9b03-5859eb205233_1652064181.415355.gif)\\n\\n```java\\n    public static List<String> letterCombinations_queue(String digits) {\\n        if (digits == null || digits.length() == 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        int len = digits.length();\\n        String[] letters = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        Queue<String> queue = new LinkedList<>();\\n        int[] digitsArr = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            digitsArr[i] = digits.charAt(i) - \\'0\\';\\n        }\\n\\n        queue.offer(\"\");\\n        for (int i = 0; i < len; i++) {\\n            String letter = letters[digitsArr[i] - 2];\\n            int size = queue.size();\\n            for (int j = 0; j < size; j++) {\\n                String temp = queue.poll();\\n                for (char ch : letter.toCharArray()) {\\n                    queue.offer(temp + ch);\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(queue);\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(3^M \\\\times 4^N)$\\n- **Space Complexity**: $O(3^M \\\\times 4^N)$\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```java\\n    public static List<String> letterCombinations_4Loops(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        if (digits == null || digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        String[] letters = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        int len = digits.length();\\n        int[] digitsArr = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            digitsArr[i] = digits.charAt(i) - \\'0\\';\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < len; i++) {\\n            sb.append(\"a\");\\n        }\\n\\n        for (int i = 0; i < letters[digitsArr[0] - 2].length(); i++) {\\n            sb.replace(0, 1, letters[digitsArr[0] - 2].charAt(i) + \"\");\\n            if (len == 1) {\\n                ans.add(sb.substring(0, 1));\\n            }\\n\\n            for (int j = 0; len >= 2 && j < letters[digitsArr[1] - 2].length(); j++) {\\n                sb.replace(1, 2, letters[digitsArr[1] - 2].charAt(j) + \"\");\\n                if (len == 2) {\\n                    ans.add(sb.toString());\\n                }\\n\\n                for (int k = 0; len >= 3 && k < letters[digitsArr[2] - 2].length(); k++) {\\n                    sb.replace(2, 3, letters[digitsArr[2] - 2].charAt(k) + \"\");\\n                    if (len == 3) {\\n                        ans.add(sb.toString());\\n                    }\\n\\n                    for (int l = 0; len >= 4 && l < letters[digitsArr[3] - 2].length(); l++) {\\n                        sb.replace(3, 4, letters[digitsArr[3] - 2].charAt(l) + \"\");\\n                        ans.add(sb.toString());\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\n```java\\n    public static List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n\\n        if (digits == null || digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        String[] lettersMap = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        backtrack(ans, new StringBuilder(), digits, lettersMap, 0);\\n        return ans;\\n    }\\n\\n    public static void backtrack(List<String> res, StringBuilder sb, String digits, String[] lettersMap, int idx) {\\n        if (idx == digits.length()) {\\n            res.add(sb.toString());\\n            return;\\n        }\\n\\n        int number = digits.charAt(idx) - \\'0\\';\\n        String numStr = lettersMap[number - 2];\\n        for (int i = 0; i < numStr.length(); i++) {\\n            sb.append(numStr.charAt(i));\\n            backtrack(res, sb, digits, lettersMap, idx + 1);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n    }\\n```\n```java\\n    public static List<String> letterCombinations_bfs(String digits) {\\n        List<String> res = new ArrayList<>();\\n        if (digits == null || digits.length() == 0) {\\n            return res;\\n        }\\n\\n        String[] letters = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        res.add(\"\");\\n        for (char digit : digits.toCharArray()) {\\n            String curLetters = letters[digit - \\'2\\'];\\n            List<String> newRes = new ArrayList<>();\\n\\n            for (String item : res) {\\n                for (char curDigit : curLetters.toCharArray()) {\\n                    newRes.add(item + curDigit);\\n                }\\n            }\\n\\n            res = newRes;\\n        }\\n\\n        return res;\\n    }\\n```\n```java\\n    public static List<String> letterCombinations_queue(String digits) {\\n        if (digits == null || digits.length() == 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        int len = digits.length();\\n        String[] letters = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        Queue<String> queue = new LinkedList<>();\\n        int[] digitsArr = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            digitsArr[i] = digits.charAt(i) - \\'0\\';\\n        }\\n\\n        queue.offer(\"\");\\n        for (int i = 0; i < len; i++) {\\n            String letter = letters[digitsArr[i] - 2];\\n            int size = queue.size();\\n            for (int j = 0; j < size; j++) {\\n                String temp = queue.poll();\\n                for (char ch : letter.toCharArray()) {\\n                    queue.offer(temp + ch);\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(queue);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 402087,
                "title": "backtracking-java-solution-100-runtime-98-memory",
                "content": "```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        if (digits.length() == 0) return new ArrayList<>();\\n        \\n        String[] dict = new String[] {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n        List<String> combos = new ArrayList<>();\\n        backtrack(combos, digits.toCharArray(), \"\", dict);\\n        return combos;\\n    }\\n    \\n    public void backtrack(List<String> combos, char[] digits, String s, String[] dict) {\\n        if (s.length() == digits.length) { combos.add(s); return; }\\n        int i = s.length();\\n        int digit = digits[i] - \\'0\\';\\n        for (char letter : dict[digit].toCharArray()) {\\n            backtrack(combos, digits, s + Character.toString(letter), dict);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        if (digits.length() == 0) return new ArrayList<>();\\n        \\n        String[] dict = new String[] {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n        List<String> combos = new ArrayList<>();\\n        backtrack(combos, digits.toCharArray(), \"\", dict);\\n        return combos;\\n    }\\n    \\n    public void backtrack(List<String> combos, char[] digits, String s, String[] dict) {\\n        if (s.length() == digits.length) { combos.add(s); return; }\\n        int i = s.length();\\n        int digit = digits[i] - \\'0\\';\\n        for (char letter : dict[digit].toCharArray()) {\\n            backtrack(combos, digits, s + Character.toString(letter), dict);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8418,
                "title": "java-easy-version-to-understand",
                "content": "    public static void DFS(String digits, List<String> result, StringBuffer s, int start,\\n\\t\\t\\tHashMap<Integer, String> map) {\\n\\t\\tif (start == digits.length())\\n\\t\\t\\tresult.add(s.toString());\\n\\t\\telse {\\n\\t\\t\\tString tmp = map.get(digits.charAt(start) - '0');\\n\\t\\t\\tfor (int i = 0; i < tmp.length(); i++) {\\n\\t\\t\\t\\ts.append(tmp.charAt(i));\\n\\t\\t\\t\\tDFS(digits, result, s, start + 1, map);\\n\\t\\t\\t\\ts.deleteCharAt(s.length() - 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static List<String> letterCombinations(String digits) {\\n\\t\\tif (digits == null || digits.length() == 0)\\n\\t\\t\\treturn new ArrayList<String>();\\n\\t\\tHashMap<Integer, String> map = new HashMap<Integer, String>();\\n\\t\\tmap.put(0, \"\");\\n\\t\\tmap.put(1, \"\");\\n\\t\\tmap.put(2, \"abc\");\\n\\t\\tmap.put(3, \"def\");\\n\\t\\tmap.put(4, \"ghi\");\\n\\t\\tmap.put(5, \"jkl\");\\n\\t\\tmap.put(6, \"mno\");\\n\\t\\tmap.put(7, \"pqrs\");\\n\\t\\tmap.put(8, \"tuv\");\\n\\t\\tmap.put(9, \"wxyz\");\\n\\t\\tList<String> result = new ArrayList<String>();\\n\\t\\tStringBuffer s = new StringBuffer();\\n\\t\\tDFS(digits, result, s, 0, map);\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    public static void DFS(String digits, List<String> result, StringBuffer s, int start,\\n\\t\\t\\tHashMap<Integer, String> map) {\\n\\t\\tif (start == digits.length())\\n\\t\\t\\tresult.add(s.toString());\\n\\t\\telse {\\n\\t\\t\\tString tmp = map.get(digits.charAt(start) - '0');\\n\\t\\t\\tfor (int i = 0; i < tmp.length(); i++) {\\n\\t\\t\\t\\ts.append(tmp.charAt(i));\\n\\t\\t\\t\\tDFS(digits, result, s, start + 1, map);\\n\\t\\t\\t\\ts.deleteCharAt(s.length() - 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static List<String> letterCombinations(String digits) {\\n\\t\\tif (digits == null || digits.length() == 0)\\n\\t\\t\\treturn new ArrayList<String>();\\n\\t\\tHashMap<Integer, String> map = new HashMap<Integer, String>();\\n\\t\\tmap.put(0, \"\");\\n\\t\\tmap.put(1, \"\");\\n\\t\\tmap.put(2, \"abc\");\\n\\t\\tmap.put(3, \"def\");\\n\\t\\tmap.put(4, \"ghi\");\\n\\t\\tmap.put(5, \"jkl\");\\n\\t\\tmap.put(6, \"mno\");\\n\\t\\tmap.put(7, \"pqrs\");\\n\\t\\tmap.put(8, \"tuv\");\\n\\t\\tmap.put(9, \"wxyz\");\\n\\t\\tList<String> result = new ArrayList<String>();\\n\\t\\tStringBuffer s = new StringBuffer();\\n\\t\\tDFS(digits, result, s, 0, map);\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 8153,
                "title": "8-line-backtracking-function-c-solution",
                "content": "Most concise backtracking function, no?\\n\\n    class Solution {\\n    public:\\n        vector<string> letterCombinations(string digits) \\n        {\\n            vector<string> res;\\n            if(digits.size()==0) return res;\\n            string local;\\n            vector<vector<char>> table(2,vector<char>());\\n            table.push_back(vector<char>{'a','b','c'}); // index 2\\n            table.push_back(vector<char>{'d','e','f'}); // 3\\n            table.push_back(vector<char>{'g','h','i'});\\n            table.push_back(vector<char>{'j','k','l'}); // 5\\n            table.push_back(vector<char>{'m','n','o'});\\n            table.push_back(vector<char>{'p','q','r','s'}); // 7\\n            table.push_back(vector<char>{'t','u','v'});\\n            table.push_back(vector<char>{'w','x','y','z'}); // 9\\n            \\n            backtracking(table,res,local,0,digits);\\n            return res;\\n        }\\n        \\n        void backtracking(const vector<vector<char>>& table, vector<string>& res, string& local, int index, const string& digits) {\\n            if(index==digits.size())\\n                res.push_back(local);\\n            else\\n                for(int i=0;i<table[digits[index]-'0'].size();i++) {\\n                    local.push_back(table[digits[index]-'0'][i]);\\n                    backtracking(table, res, local, index+1, digits);\\n                    local.pop_back();\\n                }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> letterCombinations(string digits) \\n        {\\n            vector<string> res;\\n            if(digits.size()==0) return res;\\n            string local;\\n            vector<vector<char>> table(2,vector<char>());\\n            table.push_back(vector<char>{'a','b','c'}",
                "codeTag": "Java"
            },
            {
                "id": 8120,
                "title": "ac-python-solution",
                "content": "    class Solution:\\n        # @return a list of strings, [s1, s2]\\n        def letterCombinations(self, digits):\\n            self.dict = {\"1\":\"\", \"2\":\"abc\", \"3\":\"def\", \"4\":\"ghi\", \"5\":\"jkl\", \"6\":\"mno\", \"7\":\"pqrs\",\"8\":\"tuv\",\"9\":\"wxyz\",\"10\":\" \"}\\n            result = [\"\"]\\n            for digit in digits:\\n                lst = self.dict[digit]\\n                newresult = []\\n                for char in lst:\\n                    for str in result:\\n                        newresult.append(str+char)\\n                result = newresult\\n            return result",
                "solutionTags": [],
                "code": "class Solution:\\n        # @return a list of strings, [s1, s2]\\n        def letterCombinations(self, digits):\\n            self.dict = {\"1\":\"\", \"2\":\"abc\", \"3\":\"def\", \"4\":\"ghi\", \"5\":\"jkl\", \"6\":\"mno\", \"7\":\"pqrs\",\"8\":\"tuv\",\"9\":\"wxyz\",\"10\":\" \"}",
                "codeTag": "Java"
            },
            {
                "id": 1382543,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    private let mat = [\"2\":[\"a\",\"b\",\"c\"],\\n                       \"3\":[\"d\",\"e\",\"f\"],\\n                       \"4\":[\"g\",\"h\",\"i\"],\\n                       \"5\":[\"j\",\"k\",\"l\"],\\n                       \"6\":[\"m\",\"n\",\"o\"],\\n                       \"7\":[\"p\",\"q\",\"r\",\"s\"],\\n                       \"8\":[\"t\",\"u\",\"v\"],\\n                       \"9\":[\"w\",\"x\",\"y\",\"z\"]]\\n    func letterCombinations(_ digits: String) -> [String] {\\n        var res = [String]()\\n        for d in digits.map({ $0.lowercased() }) {\\n            guard let keys = mat[d] else { break }\\n            if res.isEmpty {\\n                keys.forEach { res.append($0) }\\n                continue\\n            }\\n            let arr = res.map { _ in res.removeFirst() }\\n            for ch in keys { res += arr.map({$0 + ch}) }\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.027 (0.029) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.letterCombinations(\"23\")\\n        XCTAssertEqual(value, [\"ad\",\"bd\",\"cd\",\"ae\",\"be\",\"ce\",\"af\",\"bf\",\"cf\"])\\n    }\\n    func test1() {\\n        let value = solution.letterCombinations(\"\")\\n        XCTAssertEqual(value, [])\\n    }\\n    func test2() {\\n        let value = solution.letterCombinations(\"2\")\\n        XCTAssertEqual(value, [\"a\",\"b\",\"c\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    private let mat = [\"2\":[\"a\",\"b\",\"c\"],\\n                       \"3\":[\"d\",\"e\",\"f\"],\\n                       \"4\":[\"g\",\"h\",\"i\"],\\n                       \"5\":[\"j\",\"k\",\"l\"],\\n                       \"6\":[\"m\",\"n\",\"o\"],\\n                       \"7\":[\"p\",\"q\",\"r\",\"s\"],\\n                       \"8\":[\"t\",\"u\",\"v\"],\\n                       \"9\":[\"w\",\"x\",\"y\",\"z\"]]\\n    func letterCombinations(_ digits: String) -> [String] {\\n        var res = [String]()\\n        for d in digits.map({ $0.lowercased() }) {\\n            guard let keys = mat[d] else { break }\\n            if res.isEmpty {\\n                keys.forEach { res.append($0) }\\n                continue\\n            }\\n            let arr = res.map { _ in res.removeFirst() }\\n            for ch in keys { res += arr.map({$0 + ch}) }\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.letterCombinations(\"23\")\\n        XCTAssertEqual(value, [\"ad\",\"bd\",\"cd\",\"ae\",\"be\",\"ce\",\"af\",\"bf\",\"cf\"])\\n    }\\n    func test1() {\\n        let value = solution.letterCombinations(\"\")\\n        XCTAssertEqual(value, [])\\n    }\\n    func test2() {\\n        let value = solution.letterCombinations(\"2\")\\n        XCTAssertEqual(value, [\"a\",\"b\",\"c\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148213,
                "title": "letter-combinations-of-a-phone-number-short-easy-recursive-solutions-w-explanation",
                "content": "The question asks us to find every possible combination that can be formed from the given digits. The solution can be simplified a lot if we opt for a recursive solution, although with some observation, we can convert it into an iterative version as well. \\n\\n---\\n\\n***Solution - I (Recursive)***\\n\\nFor each digit, we can choose one of the 3 or 4 characters corresponding to that digit. So we start by choosing for the first digit. We choose each character one-by-one corresponding to first digit (from the **digit-character mapping**) and recursively repeat the same process for 2nd, 3rd and 4th digit (if they exists). Lastly, at the end of each recursion, we push the string formed into the final answer vector\\n\\n\\n```\\nvector<string> mappings = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}, ans;    \\nvector<string> letterCombinations(string digits) {\\n\\tif(digits == \"\") return ans;         // no combinations formed without any digits\\n\\thelper(digits, 0, \"\");              \\n\\treturn ans;\\n}\\n// recursive helper function\\nvoid helper(string &digits, int i, string combi){\\t\\n\\tif(i == size(digits)) {  // base condition - push when we have recursed for all digits\\n\\t\\tans.push_back(combi);    \\n\\t\\treturn;\\n\\t}\\n\\t// add and recurse for each character (chosen from current digit-charcter mapping)\\n\\tfor(auto &c : mappings[digits[i] - \\'2\\'])\\n\\t\\thelper(digits, i + 1, combi + c);\\n}\\n```\\n\\n***Time Complexity :*** **`O(4^N*N)`**, where `N`, is the length of input string. `4^N` for building every possible string combination and `N` to form the string by joining each character.. Here, 4 is chosen assuming the worst case where each digit will be 7 or 9 and we would have `4*4*4*4` total string combinations. \\n***Space Complexity :*** **`O(N)`**, the max recursion depth will be `N`, where `N` is the length of input string. If the space required for `ans` is considered as well, the complexity will be `O(4^N)`.\\n\\n----\\n\\n***Solution - II (Recursive + Backtracking)***\\n\\nThe above solution is very similar to some backtracking solutions mentioned in other posts. Its just that, in this solution I am passing a copy of string `combi` for each function call, while in backtracking solutions, the same string will be used all along without making any copy. \\n\\nHere, We just add a character at current position(chosen from `mappings`), recurse for further combinations at next position and then backtrack by deleting that character and adding the remaining ones for the current position.\\n\\n```\\nvector<string> mappings = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}, ans;\\nvector<string> letterCombinations(string digits) {\\n\\tif(digits == \"\") return {};        \\n\\tstring combination = \"\";\\n\\thelper(digits, 0, combination);\\n\\treturn ans; \\n}\\n//                  passing by reference \\u2B07\\uFE0F so copies are not made at each function call\\nvoid helper(string &digits, int i, string &combi){\\n\\tif(i == size(digits)) {\\n\\t\\tans.push_back(combi);    \\n\\t\\treturn;\\n\\t}\\n\\tfor(auto &c : mappings[digits[i] - \\'2\\']){\\n\\t\\tcombi.push_back(c);            // add a character from mappings for current position,\\n\\t\\thelper(digits, i + 1, combi);  // and recurse for next positions\\n\\t\\tcombi.pop_back();              // backtrack\\n\\t}   \\n}\\n```\\n\\nThe Time and Space Complexities remain the same but this solution can be considered marginally better since we don\\'t make copies of `combi` every time but since the input length (and hence the `combi` length) is at max - 4, it won\\'t matter that much anyways.\\n\\n---\\n\\n***Solution - III (Iterative)***\\n\\nWe can solve this question iteratively as well, although the an iterative solution for this question isn\\'t as intuitive and quick to implement as the recursive version. Also, we could use a stack to implement it iteratively but that won\\'t be any different logically.\\n\\nI will try to explain the solution using the following illustration -\\n\\n```\\nLets consider digits = \"253\"\\nWe would form the combinations one-by-one as follows -\\n\\n1.                                                                                   [\"\"]\\n                             ___________________________________________________________________________________________________________________\\n                            /     \\t\\t\\t\\t\\t\\t\\t\\t        \\t\\t      |    \\t\\t\\t\\t\\t\\t\\t\\t        \\t\\t        \\\\\\n2.[                        \"a\"                                                       \"b\"                                                         \"c\"  ]\\n            __________________________________                       ___________________________________                        ____________________________________\\n\\t       /      \\t        |                 \\\\                     /     \\t          |                 \\\\                      /     \\t          |                 \\\\\\n3.[     \"aj\"               \"ak\"               \"al\"                \"bj\"               \"bk\"               \"bl\"                \"cj\"                \"ck\"                \"cl\"  ]\\n     ___________        ___________        ___________         __________         __________          __________          __________          __________          __________\\n    /     |     \\\\      /     |     \\\\      /     |     \\\\       /    |     \\\\       /    |     \\\\        /    |     \\\\        /    |     \\\\        /    |     \\\\        /    |     \\\\\\n4[\"ajd\"  \"aje\"  \"ajf\" \"akd\" \"ake\" \"akf\" \"ald\"  \"ale\" \"alf\"  \"bjd\"  \"bje\"  \"bjf\" \"bjd\"  \"bje\"  \"bjf\" \"bjd\" \"bje\" \"bjf\"  \"cjd\"  \"cje\"  \"cjf\" \"cjd\"  \"cje\"  \"cjf\" \"cjd\" \"cje\" \"cjf\"  ]\\n\\n1. We are starting with empty array.\\n2. We take the first digit from \\'digits\\' and form all the possible combinations with it. \\n3. Now, the main thing you must notice is that, we are just extending the previous combination. We are taking  \"a\" from the previous combination and combining it with each letter mapped with digit 5, \\n   then we take \"b\" from previous combination and again combine it with each letter mapped with digit 5 and repeat the same process for \"c\".\\n4. Again, extend previous combination by taking from each previously formed combination and combining it with all the letters mapped with the digit under current iteration (3).\\n```\\t\\n\\nIn this way, we are able to build all the combinations by simply - \\n&emsp;&emsp;\\u2726 Taking previous combinations\\n&emsp;&emsp;\\u2726 Extend the combination by appending it with all letters corresponding to current digit\\n&emsp;&emsp;\\u2726 Repeat for all digits\\n\\n```\\nvector<string> letterCombinations(string digits) {\\n\\tif(digits == \"\") return {};\\n\\tvector<string> mappings{\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}, ans{\"\"};\\n\\tfor(auto& digit : digits){\\n\\t\\tvector<string> extendCombination;\\n\\t\\tfor(auto& currentCombination : ans)\\n\\t\\t\\tfor(auto& newChar : mappings[digit - \\'2\\'])\\n\\t\\t\\t\\textendCombination.push_back(currentCombination + newChar);                            \\n\\t\\tans = move(extendCombination); // same as ans = extendCombination, just avoids copying each value. You Can also use swap(ans,extendCombination)\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n\\nIn iterative version, although the stack space is avoided but the extra space is used in `extendCombination`. All the solutions had almost the same runtime and space complexity since the input constraints were very low.\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/f046b69d-84ee-42ed-88b9-a34a9c30ee19_1617872371.8534017.png /> </td></tr></table>\\n\\n\\n\\n----\\n\\n\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 :) \\n\\n----\\n---",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvector<string> mappings = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}, ans;    \\nvector<string> letterCombinations(string digits) {\\n\\tif(digits == \"\") return ans;         // no combinations formed without any digits\\n\\thelper(digits, 0, \"\");              \\n\\treturn ans;\\n}\\n// recursive helper function\\nvoid helper(string &digits, int i, string combi){\\t\\n\\tif(i == size(digits)) {  // base condition - push when we have recursed for all digits\\n\\t\\tans.push_back(combi);    \\n\\t\\treturn;\\n\\t}\\n\\t// add and recurse for each character (chosen from current digit-charcter mapping)\\n\\tfor(auto &c : mappings[digits[i] - \\'2\\'])\\n\\t\\thelper(digits, i + 1, combi + c);\\n}\\n```\n```\\nvector<string> mappings = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}, ans;\\nvector<string> letterCombinations(string digits) {\\n\\tif(digits == \"\") return {};        \\n\\tstring combination = \"\";\\n\\thelper(digits, 0, combination);\\n\\treturn ans; \\n}\\n//                  passing by reference \\u2B07\\uFE0F so copies are not made at each function call\\nvoid helper(string &digits, int i, string &combi){\\n\\tif(i == size(digits)) {\\n\\t\\tans.push_back(combi);    \\n\\t\\treturn;\\n\\t}\\n\\tfor(auto &c : mappings[digits[i] - \\'2\\']){\\n\\t\\tcombi.push_back(c);            // add a character from mappings for current position,\\n\\t\\thelper(digits, i + 1, combi);  // and recurse for next positions\\n\\t\\tcombi.pop_back();              // backtrack\\n\\t}   \\n}\\n```\n```\\nLets consider digits = \"253\"\\nWe would form the combinations one-by-one as follows -\\n\\n1.                                                                                   [\"\"]\\n                             ___________________________________________________________________________________________________________________\\n                            /     \\t\\t\\t\\t\\t\\t\\t\\t        \\t\\t      |    \\t\\t\\t\\t\\t\\t\\t\\t        \\t\\t        \\\\\\n2.[                        \"a\"                                                       \"b\"                                                         \"c\"  ]\\n            __________________________________                       ___________________________________                        ____________________________________\\n\\t       /      \\t        |                 \\\\                     /     \\t          |                 \\\\                      /     \\t          |                 \\\\\\n3.[     \"aj\"               \"ak\"               \"al\"                \"bj\"               \"bk\"               \"bl\"                \"cj\"                \"ck\"                \"cl\"  ]\\n     ___________        ___________        ___________         __________         __________          __________          __________          __________          __________\\n    /     |     \\\\      /     |     \\\\      /     |     \\\\       /    |     \\\\       /    |     \\\\        /    |     \\\\        /    |     \\\\        /    |     \\\\        /    |     \\\\\\n4[\"ajd\"  \"aje\"  \"ajf\" \"akd\" \"ake\" \"akf\" \"ald\"  \"ale\" \"alf\"  \"bjd\"  \"bje\"  \"bjf\" \"bjd\"  \"bje\"  \"bjf\" \"bjd\" \"bje\" \"bjf\"  \"cjd\"  \"cje\"  \"cjf\" \"cjd\"  \"cje\"  \"cjf\" \"cjd\" \"cje\" \"cjf\"  ]\\n\\n1. We are starting with empty array.\\n2. We take the first digit from \\'digits\\' and form all the possible combinations with it. \\n3. Now, the main thing you must notice is that, we are just extending the previous combination. We are taking  \"a\" from the previous combination and combining it with each letter mapped with digit 5, \\n   then we take \"b\" from previous combination and again combine it with each letter mapped with digit 5 and repeat the same process for \"c\".\\n4. Again, extend previous combination by taking from each previously formed combination and combining it with all the letters mapped with the digit under current iteration (3).\\n```\n```\\nvector<string> letterCombinations(string digits) {\\n\\tif(digits == \"\") return {};\\n\\tvector<string> mappings{\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}, ans{\"\"};\\n\\tfor(auto& digit : digits){\\n\\t\\tvector<string> extendCombination;\\n\\t\\tfor(auto& currentCombination : ans)\\n\\t\\t\\tfor(auto& newChar : mappings[digit - \\'2\\'])\\n\\t\\t\\t\\textendCombination.push_back(currentCombination + newChar);                            \\n\\t\\tans = move(extendCombination); // same as ans = extendCombination, just avoids copying each value. You Can also use swap(ans,extendCombination)\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1394918,
                "title": "c-3-solutions-recursion-iterative-queue",
                "content": "**Method - 1 :  Recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\")\\n            return {};\\n        \\n        string op=\"\";\\n        vector<string> res;\\n        solve(digits,op,res);\\n        return res;\\n    }\\n    \\n    void solve(string digits,string op,vector<string> &res)\\n    {\\n        vector<string> v={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        \\n        if(digits.size()==0) \\n        {\\n            res.push_back(op);\\n            return;\\n        }\\n        \\n        \\n        string s = v[digits[0] - \\'0\\'];   \\n        digits.erase(digits.begin()+0);\\n        \\n        for(int i=0;i<s.length();i++)\\n        { \\n            solve(digits,op+s[i],res);\\n        }\\n    }\\n};\\n```\\n\\n\\n\\n\\n**Method - 2 : Iterative**\\n\\n```\\nclass Solution {\\npublic:\\nvector<string> letterCombinations(string digits) {\\n    \\n        vector<string> v={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        \\n        \\n        vector<string> res;\\n        if(digits.size()==0)\\n       {\\n           return res;\\n       }\\n       res.push_back(\"\");\\n        \\n        \\n        for(int k=0;k<digits.length();k++)\\n        {\\n            vector<string> temp;\\n            string s = v[digits[k] - \\'0\\'];   \\n\\n\\n            for(int i=0;i<s.length();i++)\\n            {\\n                for(int j=0;j<res.size();j++)\\n                {\\n                     temp.push_back(res[j]+s[i]);\\n                }\\n            }\\n               swap(temp,res);\\n           \\n       }\\n         \\n    return res;\\n\\t}\\n};\\n```\\n\\n\\n\\n**Method - 3 : Using Queue**\\n\\n```\\nclass Solution {\\npublic:\\n\\tMethod - 3 Queue\\n    vector<string> letterCombinations(string digits) {\\n    \\n        vector<string> phone={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        \\n    if(digits.empty())\\n        return {};\\n    \\n        queue<string> q;\\n        vector<string> ans;\\n        \\n        q.push(\"\");\\n        \\n        while(!q.empty())\\n        {\\n            string curr = q.front();\\n            q.pop();\\n            \\n            if(curr.length()==digits.length())\\n                ans.push_back(curr);\\n            else{\\n                string s = phone[digits[curr.length()] - \\'0\\'];\\n                for(auto x: s)\\n                    q.push(curr + x);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\")\\n            return {};\\n        \\n        string op=\"\";\\n        vector<string> res;\\n        solve(digits,op,res);\\n        return res;\\n    }\\n    \\n    void solve(string digits,string op,vector<string> &res)\\n    {\\n        vector<string> v={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        \\n        if(digits.size()==0) \\n        {\\n            res.push_back(op);\\n            return;\\n        }\\n        \\n        \\n        string s = v[digits[0] - \\'0\\'];   \\n        digits.erase(digits.begin()+0);\\n        \\n        for(int i=0;i<s.length();i++)\\n        { \\n            solve(digits,op+s[i],res);\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<string> letterCombinations(string digits) {\\n    \\n        vector<string> v={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        \\n        \\n        vector<string> res;\\n        if(digits.size()==0)\\n       {\\n           return res;\\n       }\\n       res.push_back(\"\");\\n        \\n        \\n        for(int k=0;k<digits.length();k++)\\n        {\\n            vector<string> temp;\\n            string s = v[digits[k] - \\'0\\'];   \\n\\n\\n            for(int i=0;i<s.length();i++)\\n            {\\n                for(int j=0;j<res.size();j++)\\n                {\\n                     temp.push_back(res[j]+s[i]);\\n                }\\n            }\\n               swap(temp,res);\\n           \\n       }\\n         \\n    return res;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tMethod - 3 Queue\\n    vector<string> letterCombinations(string digits) {\\n    \\n        vector<string> phone={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        \\n    if(digits.empty())\\n        return {};\\n    \\n        queue<string> q;\\n        vector<string> ans;\\n        \\n        q.push(\"\");\\n        \\n        while(!q.empty())\\n        {\\n            string curr = q.front();\\n            q.pop();\\n            \\n            if(curr.length()==digits.length())\\n                ans.push_back(curr);\\n            else{\\n                string s = phone[digits[curr.length()] - \\'0\\'];\\n                for(auto x: s)\\n                    q.push(curr + x);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8150,
                "title": "backtracking-concise-c-0-ms-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string>res;\\n        if(digits.empty()) return res;\\n        vector<string>letter({\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"});\\n        string path = \"\";\\n        DFS(digits, 0, path, res, letter);\\n        return res;\\n    }\\n    \\n    void DFS(string digits, int pos, string& path, vector<string>& res, vector<string>& letter){\\n        if(pos == digits.size()){\\n            res.push_back(path);\\n            return;\\n        }\\n        for(auto c: letter[digits[pos] - '0']){\\n            path.push_back(c);\\n            DFS(digits, pos + 1, path, res, letter);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string>res;\\n        if(digits.empty()) return res;\\n        vector<string>letter({\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"});\\n        string path = \"\";\\n        DFS(digits, 0, path, res, letter);\\n        return res;\\n    }\\n    \\n    void DFS(string digits, int pos, string& path, vector<string>& res, vector<string>& letter){\\n        if(pos == digits.size()){\\n            res.push_back(path);\\n            return;\\n        }\\n        for(auto c: letter[digits[pos] - '0']){\\n            path.push_back(c);\\n            DFS(digits, pos + 1, path, res, letter);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900295,
                "title": "iterative-c-solution-using-queue-bfs-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> phone = {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        if(digits.empty())\\n            return {};\\n        \\n        queue<string> q;\\n        vector<string> ans;\\n        \\n        q.push(\"\");\\n\\n        while(!q.empty()){\\n            string s = q.front();\\n            q.pop();\\n            \\n            if(s.length() == digits.length())\\n                ans.push_back(s);\\n            else{\\n                string temp = phone[digits[s.length()] - \\'0\\'];\\n                for(auto i : temp)\\n                    q.push(s + i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nExample for digits = \"23\"\\nq = {\"\"}                               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                                            q.empty() = false\\nq = {\"a\", \"b\", \"c\"}\\nq = {\"b\", \"c\", \"ad\", \"ae\", \"af\"}\\nq = { \"c\", \"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\"}\\nq = { \"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"}\\nq = { \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"}   ans = {\"ad\"}\\nq = { \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"}   ans = {\"ad\", \"ae\"}\\nq = { \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"}   ans = {\"ad\", \"ae\", \"af\"}\\nq = { \"be\", \"bf\", \"cd\", \"ce\", \"cf\"}   ans = {\"ad\", \"ae\", \"af\", \"bd\"}\\nq = {\"bf\", \"cd\", \"ce\", \"cf\"}   ans = {\"ad\", \"ae\", \"af\", \"bd\", \"be\"}\\nq = {\"cd\", \"ce\", \"cf\"}   ans = {\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\"}\\nq = {\"ce\", \"cf\"}   ans = {\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\"}\\nq = {\"cf\"}   ans = {\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\"}\\nq = {}   ans = {\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"}    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.empty = true\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> phone = {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        if(digits.empty())\\n            return {};\\n        \\n        queue<string> q;\\n        vector<string> ans;\\n        \\n        q.push(\"\");\\n\\n        while(!q.empty()){\\n            string s = q.front();\\n            q.pop();\\n            \\n            if(s.length() == digits.length())\\n                ans.push_back(s);\\n            else{\\n                string temp = phone[digits[s.length()] - \\'0\\'];\\n                for(auto i : temp)\\n                    q.push(s + i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856005,
                "title": "beats-100-very-easy-c-java-pyhton3-backtracking-detailed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Mapping of Digits to Letters:** The problem is similar to generating all possible combinations of characters you can get from pressing the digits on a telephone keypad. We are given a mapping of each digit to a set of letters.\\n\\n**Backtracking:** Backtracking is a powerful technique used to explore all possible combinations of a problem space by building a solution incrementally and undoing the choices when they don\\'t lead to a valid solution. In this problem, we will use backtracking to generate all possible letter combinations.\\n\\n**Recursive Exploration:** The basic idea is to consider each digit in the input string and explore all the possible letters associated with that digit. We start with the first digit and try each letter associated with it. Then, for each of these choices, we move on to the next digit and repeat the process.\\n\\n**Base Case:** We use recursion to handle each digit in the input string one by one. The base case for our recursive function will be when we have processed all the digits in the input string. At this point, we have a valid letter combination, and we can add it to the result list.\\n\\n**Recursive Call and Backtracking:** For each digit, we loop through all its associated letters and make a recursive call to the function with the next digit. During this recursion, we maintain the current combination of letters. After the recursive call, we remove the last letter added to the combination (backtrack) and try the next letter.\\n\\n**Combination Generation:** As we go deeper into the recursion, the current combination of letters will build up until we reach the base case. At the base case, we have formed a complete letter combination for the given input. We add this combination to the result list and return to the previous level of the recursion to try other possibilities.\\n\\nBy using the backtracking approach, we can efficiently generate all possible letter combinations for the given input digits. This approach ensures that we explore all valid combinations by making choices and undoing them when needed, ultimately forming the complete set of combinations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a mapping of digits to letters(Different for different languages). For example:\\n```\\nmapping = {\\n    \\'2\\': \\'abc\\',\\n    \\'3\\': \\'def\\',\\n    \\'4\\': \\'ghi\\',\\n    \\'5\\': \\'jkl\\',\\n    \\'6\\': \\'mno\\',\\n    \\'7\\': \\'pqrs\\',\\n    \\'8\\': \\'tuv\\',\\n    \\'9\\': \\'wxyz\\'\\n}\\n```\\n2. Initialize an empty list to store the results.\\n\\n3. Implement a recursive function that takes the current index and a string representing the current combination. Start with index 0 and an empty string.\\n\\n4. In the recursive function, if the current index is equal to the length of the input digits, add the current combination to the results list and return.\\n\\n5. Otherwise, get the letters corresponding to the current digit. For each letter, append it to the current combination and make a recursive call with the next index.\\n\\n6. After the recursive call, remove the last letter added to the current combination (backtrack) and move on to the next letter.\\n\\n7. Once the recursive function is completed, return the list of results.\\n\\n# Complexity\\n- **Time complexity:** The time complexity of this approach is O(4^n) where n is the number of digits in the input string. This is because each digit can map to up to 4 letters in the worst case, and there are n digits in the input.\\n\\n- **Space complexity:** The space complexity is O(n) as we are using recursion and the maximum depth of the recursion is n. Additionally, we are using a result list to store the combinations, which can also take up to O(n) space in the worst case.\\n\\n# Code\\n## C++\\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> result;\\n        if (digits.empty()) return result;\\n        \\n        unordered_map<char, string> mapping = {\\n            {\\'2\\', \"abc\"},\\n            {\\'3\\', \"def\"},\\n            {\\'4\\', \"ghi\"},\\n            {\\'5\\', \"jkl\"},\\n            {\\'6\\', \"mno\"},\\n            {\\'7\\', \"pqrs\"},\\n            {\\'8\\', \"tuv\"},\\n            {\\'9\\', \"wxyz\"}\\n        };\\n        \\n        string currentCombination;\\n        backtrack(digits, 0, mapping, currentCombination, result);\\n        \\n        return result;\\n    }\\n    \\n    void backtrack(const string& digits, int index, const unordered_map<char, string>& mapping, string& currentCombination, vector<string>& result) {\\n        if (index == digits.length()) {\\n            result.push_back(currentCombination);\\n            return;\\n        }\\n        \\n        char digit = digits[index];\\n        string letters = mapping.at(digit);\\n        for (char letter : letters) {\\n            currentCombination.push_back(letter);\\n            backtrack(digits, index + 1, mapping, currentCombination, result);\\n            currentCombination.pop_back(); // Backtrack by removing the last letter added\\n        }\\n    }\\n};\\n```\\n## Java\\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<>();\\n        if (digits.isEmpty()) return result;\\n        \\n        Map<Character, String> mapping = new HashMap<>();\\n        mapping.put(\\'2\\', \"abc\");\\n        mapping.put(\\'3\\', \"def\");\\n        mapping.put(\\'4\\', \"ghi\");\\n        mapping.put(\\'5\\', \"jkl\");\\n        mapping.put(\\'6\\', \"mno\");\\n        mapping.put(\\'7\\', \"pqrs\");\\n        mapping.put(\\'8\\', \"tuv\");\\n        mapping.put(\\'9\\', \"wxyz\");\\n        \\n        StringBuilder currentCombination = new StringBuilder();\\n        backtrack(digits, 0, mapping, currentCombination, result);\\n        \\n        return result;\\n    }\\n    \\n    private void backtrack(String digits, int index, Map<Character, String> mapping, StringBuilder currentCombination, List<String> result) {\\n        if (index == digits.length()) {\\n            result.add(currentCombination.toString());\\n            return;\\n        }\\n        \\n        char digit = digits.charAt(index);\\n        String letters = mapping.get(digit);\\n        for (char letter : letters.toCharArray()) {\\n            currentCombination.append(letter);\\n            backtrack(digits, index + 1, mapping, currentCombination, result);\\n            currentCombination.deleteCharAt(currentCombination.length() - 1); // Backtrack by removing the last letter added\\n        }\\n    }\\n}\\n\\n```\\n## Pyhton3\\n```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        result = []\\n        if not digits:\\n            return result\\n        \\n        mapping = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n        \\n        def backtrack(index, current_combination):\\n            nonlocal result\\n            if index == len(digits):\\n                result.append(current_combination)\\n                return\\n            \\n            digit = digits[index]\\n            letters = mapping[digit]\\n            for letter in letters:\\n                backtrack(index + 1, current_combination + letter)\\n        \\n        backtrack(0, \"\")\\n        return result\\n\\n```\\n![upvote img.jpg](https://assets.leetcode.com/users/images/10806d8a-6ebe-4a6c-b66c-a0369b7642a0_1691035898.8654704.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nmapping = {\\n    \\'2\\': \\'abc\\',\\n    \\'3\\': \\'def\\',\\n    \\'4\\': \\'ghi\\',\\n    \\'5\\': \\'jkl\\',\\n    \\'6\\': \\'mno\\',\\n    \\'7\\': \\'pqrs\\',\\n    \\'8\\': \\'tuv\\',\\n    \\'9\\': \\'wxyz\\'\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> result;\\n        if (digits.empty()) return result;\\n        \\n        unordered_map<char, string> mapping = {\\n            {\\'2\\', \"abc\"},\\n            {\\'3\\', \"def\"},\\n            {\\'4\\', \"ghi\"},\\n            {\\'5\\', \"jkl\"},\\n            {\\'6\\', \"mno\"},\\n            {\\'7\\', \"pqrs\"},\\n            {\\'8\\', \"tuv\"},\\n            {\\'9\\', \"wxyz\"}\\n        };\\n        \\n        string currentCombination;\\n        backtrack(digits, 0, mapping, currentCombination, result);\\n        \\n        return result;\\n    }\\n    \\n    void backtrack(const string& digits, int index, const unordered_map<char, string>& mapping, string& currentCombination, vector<string>& result) {\\n        if (index == digits.length()) {\\n            result.push_back(currentCombination);\\n            return;\\n        }\\n        \\n        char digit = digits[index];\\n        string letters = mapping.at(digit);\\n        for (char letter : letters) {\\n            currentCombination.push_back(letter);\\n            backtrack(digits, index + 1, mapping, currentCombination, result);\\n            currentCombination.pop_back(); // Backtrack by removing the last letter added\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<>();\\n        if (digits.isEmpty()) return result;\\n        \\n        Map<Character, String> mapping = new HashMap<>();\\n        mapping.put(\\'2\\', \"abc\");\\n        mapping.put(\\'3\\', \"def\");\\n        mapping.put(\\'4\\', \"ghi\");\\n        mapping.put(\\'5\\', \"jkl\");\\n        mapping.put(\\'6\\', \"mno\");\\n        mapping.put(\\'7\\', \"pqrs\");\\n        mapping.put(\\'8\\', \"tuv\");\\n        mapping.put(\\'9\\', \"wxyz\");\\n        \\n        StringBuilder currentCombination = new StringBuilder();\\n        backtrack(digits, 0, mapping, currentCombination, result);\\n        \\n        return result;\\n    }\\n    \\n    private void backtrack(String digits, int index, Map<Character, String> mapping, StringBuilder currentCombination, List<String> result) {\\n        if (index == digits.length()) {\\n            result.add(currentCombination.toString());\\n            return;\\n        }\\n        \\n        char digit = digits.charAt(index);\\n        String letters = mapping.get(digit);\\n        for (char letter : letters.toCharArray()) {\\n            currentCombination.append(letter);\\n            backtrack(digits, index + 1, mapping, currentCombination, result);\\n            currentCombination.deleteCharAt(currentCombination.length() - 1); // Backtrack by removing the last letter added\\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        result = []\\n        if not digits:\\n            return result\\n        \\n        mapping = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n        \\n        def backtrack(index, current_combination):\\n            nonlocal result\\n            if index == len(digits):\\n                result.append(current_combination)\\n                return\\n            \\n            digit = digits[index]\\n            letters = mapping[digit]\\n            for letter in letters:\\n                backtrack(index + 1, current_combination + letter)\\n        \\n        backtrack(0, \"\")\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855692,
                "title": "100-fast-2-methods-video-recursion-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nExplore all the choices and build the answer.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/MijPYir-zxk\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach for `solve`:\\n\\n- It takes a string `digits` and an array `arr` as input.\\n- Base case: If the input `digits` is empty, return a vector containing an empty string, representing the empty combination.\\n- Get the first digit `c` from the `digits` string and its corresponding letters `a` from the `arr` array.\\n- Recursively call `solve` with the remaining digits `smallinput` (excluding the first digit) and the `arr` array.\\n- For each returned combination `x` from the recursive call, iterate through each letter `x1` in the string `a`.\\n- Append `x1` to `x`, representing the current letter combination for the first digit `c`.\\n- Add the new combination `x1 + x` to the result vector `res`.\\n- Return the vector `res` containing all generated combinations.\\n\\nApproach for `solve2`:\\n\\n- It takes a string `digits`, an array `arr`, an index `i`, and a current combination `com` as input.\\n- Base case: If the index `i` reaches the size of the `digits` string, it means all digits have been processed. In this case, add the current combination `com` to the final result vector.\\n- Get the current digit `c` from the `digits` string and its corresponding letters `a` from the `arr` array using the digit as an index.\\n- Loop through each letter `a[k]` in `a`.\\n- Append `a[k]` to the current combination `com`.\\n- Make a recursive call to `solve2` with the next index `i+1` and the updated combination `com`.\\n- This recursive process explores all possible combinations of letters for the given digits.\\n- The final result will be stored in the `ans` vector, which accumulates all valid combinations.\\n\\n\\n\\n# Complexity\\n- Time complexity:$$O(4^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string>solve(string digits,string*arr){\\n        if(digits.size()==0){\\n            vector<string>bs;\\n            bs.push_back(\"\");\\n            return bs;\\n        }\\n      \\n        char c=digits[0];\\n        string a=arr[c-\\'0\\'];\\n         string smallinput=digits.substr(1);\\n        vector<string>rest=solve(smallinput,arr);\\n        vector<string>res;\\n        for(auto x:rest){\\n           for(auto x1:a){\\n               res.push_back(x1+x);\\n           } \\n        }\\n        return res;\\n    }\\n    vector<string>ans;\\n    void solve2(string digits,string *arr,int i,string com){\\n        if(i==digits.size()){\\n         ans.push_back(com);\\n         return;\\n        }\\n         char c=digits[i];\\n        string a=arr[c-\\'0\\'];\\n        for(int k=0;k<a.size();k++){\\n            solve2(digits,arr,i+1,com+a[k]);\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string>a;\\n        if(digits.size()==0)\\n            return a;\\n        string arr[]={\"0\",\"0\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n      //  vector<string>ans=solve(digits,arr);\\n      solve2(digits,arr,0,\"\");\\n        return ans;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    private List<String> solve(String digits, String[] arr) {\\n        if (digits.length() == 0) {\\n            List<String> bs = new ArrayList<>();\\n            bs.add(\"\");\\n            return bs;\\n        }\\n\\n        char c = digits.charAt(0);\\n        String a = arr[c - \\'0\\'];\\n        String smallinput = digits.substring(1);\\n        List<String> rest = solve(smallinput, arr);\\n        List<String> res = new ArrayList<>();\\n        for (String x : rest) {\\n            for (char x1 : a.toCharArray()) {\\n                res.add(x1 + x);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private List<String> ans = new ArrayList<>();\\n\\n    private void solve2(String digits, String[] arr, int i, String com) {\\n        if (i == digits.length()) {\\n            ans.add(com);\\n            return;\\n        }\\n        char c = digits.charAt(i);\\n        String a = arr[c - \\'0\\'];\\n        for (char x1 : a.toCharArray()) {\\n            solve2(digits, arr, i + 1, com + x1);\\n        }\\n    }\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> a = new ArrayList<>();\\n        if (digits.length() == 0)\\n            return a;\\n        String[] arr = {\"0\", \"0\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        solve2(digits, arr, 0, \"\");\\n        return ans;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def solve(self, digits, arr):\\n        if not digits:\\n            return [\"\"]\\n\\n        c = digits[0]\\n        a = arr[int(c)]\\n        small_input = digits[1:]\\n        rest = self.solve(small_input, arr)\\n        res = []\\n        for x in rest:\\n            for x1 in a:\\n                res.append(x1 + x)\\n        return res\\n\\n    def __init__(self):\\n        self.ans = []\\n\\n    def solve2(self, digits, arr, i, com):\\n        if i == len(digits):\\n            self.ans.append(com)\\n            return\\n\\n        c = digits[i]\\n        a = arr[int(c)]\\n        for x1 in a:\\n            self.solve2(digits, arr, i + 1, com + x1)\\n\\n    def letterCombinations(self, digits):\\n        a = []\\n        if not digits:\\n            return a\\n        arr = [\"0\", \"0\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\\n        self.solve2(digits, arr, 0, \"\")\\n        return self.ans\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "String",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string>solve(string digits,string*arr){\\n        if(digits.size()==0){\\n            vector<string>bs;\\n            bs.push_back(\"\");\\n            return bs;\\n        }\\n      \\n        char c=digits[0];\\n        string a=arr[c-\\'0\\'];\\n         string smallinput=digits.substr(1);\\n        vector<string>rest=solve(smallinput,arr);\\n        vector<string>res;\\n        for(auto x:rest){\\n           for(auto x1:a){\\n               res.push_back(x1+x);\\n           } \\n        }\\n        return res;\\n    }\\n    vector<string>ans;\\n    void solve2(string digits,string *arr,int i,string com){\\n        if(i==digits.size()){\\n         ans.push_back(com);\\n         return;\\n        }\\n         char c=digits[i];\\n        string a=arr[c-\\'0\\'];\\n        for(int k=0;k<a.size();k++){\\n            solve2(digits,arr,i+1,com+a[k]);\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string>a;\\n        if(digits.size()==0)\\n            return a;\\n        string arr[]={\"0\",\"0\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n      //  vector<string>ans=solve(digits,arr);\\n      solve2(digits,arr,0,\"\");\\n        return ans;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    private List<String> solve(String digits, String[] arr) {\\n        if (digits.length() == 0) {\\n            List<String> bs = new ArrayList<>();\\n            bs.add(\"\");\\n            return bs;\\n        }\\n\\n        char c = digits.charAt(0);\\n        String a = arr[c - \\'0\\'];\\n        String smallinput = digits.substring(1);\\n        List<String> rest = solve(smallinput, arr);\\n        List<String> res = new ArrayList<>();\\n        for (String x : rest) {\\n            for (char x1 : a.toCharArray()) {\\n                res.add(x1 + x);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private List<String> ans = new ArrayList<>();\\n\\n    private void solve2(String digits, String[] arr, int i, String com) {\\n        if (i == digits.length()) {\\n            ans.add(com);\\n            return;\\n        }\\n        char c = digits.charAt(i);\\n        String a = arr[c - \\'0\\'];\\n        for (char x1 : a.toCharArray()) {\\n            solve2(digits, arr, i + 1, com + x1);\\n        }\\n    }\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> a = new ArrayList<>();\\n        if (digits.length() == 0)\\n            return a;\\n        String[] arr = {\"0\", \"0\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        solve2(digits, arr, 0, \"\");\\n        return ans;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def solve(self, digits, arr):\\n        if not digits:\\n            return [\"\"]\\n\\n        c = digits[0]\\n        a = arr[int(c)]\\n        small_input = digits[1:]\\n        rest = self.solve(small_input, arr)\\n        res = []\\n        for x in rest:\\n            for x1 in a:\\n                res.append(x1 + x)\\n        return res\\n\\n    def __init__(self):\\n        self.ans = []\\n\\n    def solve2(self, digits, arr, i, com):\\n        if i == len(digits):\\n            self.ans.append(com)\\n            return\\n\\n        c = digits[i]\\n        a = arr[int(c)]\\n        for x1 in a:\\n            self.solve2(digits, arr, i + 1, com + x1)\\n\\n    def letterCombinations(self, digits):\\n        a = []\\n        if not digits:\\n            return a\\n        arr = [\"0\", \"0\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\\n        self.solve2(digits, arr, 0, \"\")\\n        return self.ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600666,
                "title": "c-easiest-solution-faster-than-100-with-comments",
                "content": "**APPROACH :**\\n* The approach is kind of like a dfs traversal in DAG. \\n* For instance, for ``` digits = \"23\" ```, (2 maps to \\'a\\', \\'b\\', \\'c\\' & 3 maps to \\'d\\', \\'e\\', \\'f\\'). \\n* Start with \\'a\\', find all the possible letter combinations starting with \\'a\\' (\"ad\", \"ae\", \"af\") then come back and repeat the same for other letters that 2 maps to) (Just like we start at a source node, find all the possible paths to the destination node).\\n* So, we can solve this problem using ***Recursion & Backtracking***.\\n\\n**ALGORITHM :** \\n1. Initialize a hashmap with key as digit and value with the corresponding string. Initialize the result as an empty array.\\n2. Recursively call the function \"makeCombinations(digits, currString, i) and make a valid combination. \\n3. When i==digits.size(), add the formed combination to the result vector and start backtracking to make more combinations.\\n4. Finally, return the result vector.\\n\\n**Time Complexity :** O(4^n) - Since most numbers have 4 alphabets as options.\\n\\n**Code :**\\n```\\nclass Solution {\\nprivate:\\n    map<int, string> m;\\n    vector<string> ans;\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\") return ans;\\n        m[2] = \"abc\";\\n        m[3] = \"def\";\\n        m[4] = \"ghi\";\\n        m[5] = \"jkl\";\\n        m[6] = \"mno\";\\n        m[7] = \"pqrs\";\\n        m[8] = \"tuv\";\\n        m[9] = \"wxyz\";\\n        \\n        string currString=\"\";\\n        makeCombinations(digits, currString, 0);\\n        \\n        return ans;\\n            \\n    }\\n    \\n    void makeCombinations(string digits, string &currString, int i){\\n        if(i==digits.size()){\\n            ans.push_back(currString);\\n            return;\\n        }\\n        \\n        for(auto letter : m[digits[i]-\\'0\\']){\\n            currString.push_back(letter);\\n            makeCombinations(digits, currString, i+1);\\n            currString.pop_back();\\n        }\\n        return; \\n    }  \\n};\\n```\\n\\nIf you like my solution and explanation, please upvote! \\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` digits = \"23\" ```\n```\\nclass Solution {\\nprivate:\\n    map<int, string> m;\\n    vector<string> ans;\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\") return ans;\\n        m[2] = \"abc\";\\n        m[3] = \"def\";\\n        m[4] = \"ghi\";\\n        m[5] = \"jkl\";\\n        m[6] = \"mno\";\\n        m[7] = \"pqrs\";\\n        m[8] = \"tuv\";\\n        m[9] = \"wxyz\";\\n        \\n        string currString=\"\";\\n        makeCombinations(digits, currString, 0);\\n        \\n        return ans;\\n            \\n    }\\n    \\n    void makeCombinations(string digits, string &currString, int i){\\n        if(i==digits.size()){\\n            ans.push_back(currString);\\n            return;\\n        }\\n        \\n        for(auto letter : m[digits[i]-\\'0\\']){\\n            currString.push_back(letter);\\n            makeCombinations(digits, currString, i+1);\\n            currString.pop_back();\\n        }\\n        return; \\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504736,
                "title": "python-string-concatenation",
                "content": "```   \\n\\tdef letterCombinations(self, digits: str) -> List[str]:\\n        if digits == \"\": return []\\n        \\n        graph = {\\'2\\':[\\'a\\',\\'b\\',\\'c\\'], \\'3\\':[\\'d\\',\\'e\\',\\'f\\'], \\'4\\':[\\'g\\',\\'h\\',\\'i\\'], \\'5\\':[\\'j\\',\\'k\\',\\'l\\'], \\'6\\':[\\'m\\',\\'n\\',\\'o\\'], \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'], \\'8\\':[\\'t\\',\\'u\\',\\'v\\'], \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        \\n        \"\"\" Turn digits in to list of char list \"\"\"\\n        chars = []\\n        for c in digits:\\n            chars.append(graph[c])\\n            \\n        \"\"\" Start with \"\" to concatenate \"\"\"\\n        ans = [\"\"]\\n        for i in range(len(chars)):\\n            ans=[c+chars[i][j] for c in ans for j in range(len(chars[i]))]\\n            \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```   \\n\\tdef letterCombinations(self, digits: str) -> List[str]:\\n        if digits == \"\": return []\\n        \\n        graph = {\\'2\\':[\\'a\\',\\'b\\',\\'c\\'], \\'3\\':[\\'d\\',\\'e\\',\\'f\\'], \\'4\\':[\\'g\\',\\'h\\',\\'i\\'], \\'5\\':[\\'j\\',\\'k\\',\\'l\\'], \\'6\\':[\\'m\\',\\'n\\',\\'o\\'], \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'], \\'8\\':[\\'t\\',\\'u\\',\\'v\\'], \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        \\n        \"\"\" Turn digits in to list of char list \"\"\"\\n        chars = []\\n        for c in digits:\\n            chars.append(graph[c])\\n            \\n        \"\"\" Start with \"\" to concatenate \"\"\"\\n        ans = [\"\"]\\n        for i in range(len(chars)):\\n            ans=[c+chars[i][j] for c in ans for j in range(len(chars[i]))]\\n            \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 1545143,
                "title": "java-tc-o-4-n-sc-o-n-backtracking-iterative-solutions",
                "content": "**Backtracking Solution**\\n\\n```java\\n/**\\n * Backtracking Solution\\n *\\n * Time Complexity: O(4^N)\\n * T(n) = 4*T(n-1) + O(4)\\n *\\n * Space Complexity: \\n * O(N) -> Recursion stack space. \\n * O(4^N) for storing the result.\\n *\\n * N = Length of input digits string.\\n */\\nclass Solution {\\n    private static final Map<Character, List<Character>> digitMap = Map.of(\\n\\t\\t\\t\\'0\\', List.of(), \\n\\t\\t\\t\\'1\\', List.of(), \\n\\t\\t\\t\\'2\\', List.of(\\'a\\', \\'b\\', \\'c\\'), \\n\\t\\t\\t\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'), \\n\\t\\t\\t\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'), \\n\\t\\t\\t\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'), \\n\\t\\t\\t\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'), \\n\\t\\t\\t\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'), \\n\\t\\t\\t\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'), \\n\\t\\t\\t\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\')\\n\\t);\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<>();\\n        if (digits == null || digits.length() == 0) {\\n            return result;\\n        }\\n\\n        letterCombinationsHelper(digits, result, new StringBuilder());\\n        return result;\\n    }\\n\\n    private void letterCombinationsHelper(String digits, List<String> result, StringBuilder sb) {\\n        int len = sb.length();\\n        if (len == digits.length()) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n\\n        for (char c : digitMap.get(digits.charAt(len))) {\\n            sb.append(c);\\n            letterCombinationsHelper(digits, result, sb);\\n            sb.setLength(len);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Iterative Solution using Queue**\\n\\n```java\\n/**\\n * Iterative Solution using Queue\\n *\\n * Time Complexity: Total of below items\\n * Poll will be called -> 1 + 4^1 + 4^2 + ... + 4*(N-1) = (4^(N-1) -1) times.\\n * Time to create new string during concatenation: 1*4^1 + 2*4^2 + 3*4^3 + ... + N*4^N\\n *\\n * Space Complexity: O(N * 4^N) for storing the portion of previous level + portion of last level.\\n *\\n * N = Length of input digits string.\\n */\\nclass Solution2 {\\n    private static final Map<Character, List<Character>> digitMap = Map.of(\\n\\t\\t\\t\\'0\\', List.of(), \\n\\t\\t\\t\\'1\\', List.of(), \\n\\t\\t\\t\\'2\\', List.of(\\'a\\', \\'b\\', \\'c\\'), \\n\\t\\t\\t\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'), \\n\\t\\t\\t\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'), \\n\\t\\t\\t\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'), \\n\\t\\t\\t\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'), \\n\\t\\t\\t\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'), \\n\\t\\t\\t\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'), \\n\\t\\t\\t\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\')\\n\\t);\\n\\n    public List<String> letterCombinations(String digits) {\\n        LinkedList<String> result = new LinkedList<>();\\n        if (digits == null || digits.length() == 0) {\\n            return result;\\n        }\\n\\n        result.add(\"\");\\n\\n        while (result.peek().length() < digits.length()) {\\n            String cur = result.poll();\\n            for (char c : digitMap.get(digits.charAt(cur.length()))) {\\n                result.add(cur + c);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java\\n/**\\n * Backtracking Solution\\n *\\n * Time Complexity: O(4^N)\\n * T(n) = 4*T(n-1) + O(4)\\n *\\n * Space Complexity: \\n * O(N) -> Recursion stack space. \\n * O(4^N) for storing the result.\\n *\\n * N = Length of input digits string.\\n */\\nclass Solution {\\n    private static final Map<Character, List<Character>> digitMap = Map.of(\\n\\t\\t\\t\\'0\\', List.of(), \\n\\t\\t\\t\\'1\\', List.of(), \\n\\t\\t\\t\\'2\\', List.of(\\'a\\', \\'b\\', \\'c\\'), \\n\\t\\t\\t\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'), \\n\\t\\t\\t\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'), \\n\\t\\t\\t\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'), \\n\\t\\t\\t\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'), \\n\\t\\t\\t\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'), \\n\\t\\t\\t\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'), \\n\\t\\t\\t\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\')\\n\\t);\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<>();\\n        if (digits == null || digits.length() == 0) {\\n            return result;\\n        }\\n\\n        letterCombinationsHelper(digits, result, new StringBuilder());\\n        return result;\\n    }\\n\\n    private void letterCombinationsHelper(String digits, List<String> result, StringBuilder sb) {\\n        int len = sb.length();\\n        if (len == digits.length()) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n\\n        for (char c : digitMap.get(digits.charAt(len))) {\\n            sb.append(c);\\n            letterCombinationsHelper(digits, result, sb);\\n            sb.setLength(len);\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Solution using Queue\\n *\\n * Time Complexity: Total of below items\\n * Poll will be called -> 1 + 4^1 + 4^2 + ... + 4*(N-1) = (4^(N-1) -1) times.\\n * Time to create new string during concatenation: 1*4^1 + 2*4^2 + 3*4^3 + ... + N*4^N\\n *\\n * Space Complexity: O(N * 4^N) for storing the portion of previous level + portion of last level.\\n *\\n * N = Length of input digits string.\\n */\\nclass Solution2 {\\n    private static final Map<Character, List<Character>> digitMap = Map.of(\\n\\t\\t\\t\\'0\\', List.of(), \\n\\t\\t\\t\\'1\\', List.of(), \\n\\t\\t\\t\\'2\\', List.of(\\'a\\', \\'b\\', \\'c\\'), \\n\\t\\t\\t\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'), \\n\\t\\t\\t\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'), \\n\\t\\t\\t\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'), \\n\\t\\t\\t\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'), \\n\\t\\t\\t\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'), \\n\\t\\t\\t\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'), \\n\\t\\t\\t\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\')\\n\\t);\\n\\n    public List<String> letterCombinations(String digits) {\\n        LinkedList<String> result = new LinkedList<>();\\n        if (digits == null || digits.length() == 0) {\\n            return result;\\n        }\\n\\n        result.add(\"\");\\n\\n        while (result.peek().length() < digits.length()) {\\n            String cur = result.poll();\\n            for (char c : digitMap.get(digits.charAt(cur.length()))) {\\n                result.add(cur + c);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693167,
                "title": "very-simple-iterative-python-solution-easy-to-understand",
                "content": "Feel free to comment if you have any questions\\n```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        # STEP 1: define edge cases\\n        # return an empty list if the input is an empty string\\n        # since 0 and 1 do not map to any characters, we can return an empty list even when anyone of these two digits is present in the input\\n        if not digits or \"0\" in digits or \"1\" in digits:\\n            return\\n\\n        # STEP 2: define the mapping\\n        map = {\\n             \"2\": [\"a\",\"b\",\"c\"],\\n             \"3\": [\"d\",\"e\",\"f\"],\\n             \"4\": [\"g\",\"h\",\"i\"],\\n             \"5\": [\"j\",\"k\",\"l\"],\\n             \"6\": [\"m\",\"n\",\"o\"],\\n             \"7\": [\"p\",\"q\",\"r\",\"s\"],\\n             \"8\": [\"t\",\"u\",\"v\"],\\n             \"9\": [\"w\",\"x\",\"y\",\"z\"]\\n            }\\n\\n        # STEP 3: store mapping for the first digit in the \"output\" list, and then keep updating this output list until all the digits are covered\\n        output = map[digits[0]]\\n        index = 1\\n        while(index<len(digits)):\\n            next = list()\\n            for i in output:\\n                 for j in map[digits[index]]:\\n                    next.append(i+j)  \\n            output = next\\n            index+=1\\n\\n        return(output)\\n```\\n\\nPlease upvote if you like the solution. Thank you!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        # STEP 1: define edge cases\\n        # return an empty list if the input is an empty string\\n        # since 0 and 1 do not map to any characters, we can return an empty list even when anyone of these two digits is present in the input\\n        if not digits or \"0\" in digits or \"1\" in digits:\\n            return\\n\\n        # STEP 2: define the mapping\\n        map = {\\n             \"2\": [\"a\",\"b\",\"c\"],\\n             \"3\": [\"d\",\"e\",\"f\"],\\n             \"4\": [\"g\",\"h\",\"i\"],\\n             \"5\": [\"j\",\"k\",\"l\"],\\n             \"6\": [\"m\",\"n\",\"o\"],\\n             \"7\": [\"p\",\"q\",\"r\",\"s\"],\\n             \"8\": [\"t\",\"u\",\"v\"],\\n             \"9\": [\"w\",\"x\",\"y\",\"z\"]\\n            }\\n\\n        # STEP 3: store mapping for the first digit in the \"output\" list, and then keep updating this output list until all the digits are covered\\n        output = map[digits[0]]\\n        index = 1\\n        while(index<len(digits)):\\n            next = list()\\n            for i in output:\\n                 for j in map[digits[index]]:\\n                    next.append(i+j)  \\n            output = next\\n            index+=1\\n\\n        return(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493347,
                "title": "c-java-python-javascript-backtracking-with-easy-explanation",
                "content": "\\n# Intuition:\\nThe problem requires finding all possible letter combinations that can be formed by a given sequence of digits. For example, if the input is \"23\", then the output should contain all possible combinations of the letters \\'a\\', \\'b\\', and \\'c\\' for digit 2, and \\'d\\', \\'e\\', and \\'f\\' for digit 3. This can be solved using a backtracking approach where we start with the first digit and find all the possible letters that can be formed using that digit, and then move on to the next digit and find all the possible letters that can be formed using that digit, and so on until we have formed a combination of all digits.\\n\\n# Approach:\\n\\n1. Define a function letterCombinations which takes a string of digits as input and returns a vector of all possible letter combinations.\\n2. Check if the input string is empty, if it is, return an empty vector as there are no possible letter combinations.\\n3. Define a mapping vector which contains the letters corresponding to each digit. For example, the mapping vector for the input \"23\" would be {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}.\\n4. Define an empty string combination with the same size as the input digits string.\\n5. Call the backtrack function with the initial index as 0 and pass the result vector, mapping vector, combination string, and digits string as arguments.\\n6. In the backtrack function, check if the current index is equal to the size of the digits string. If it is, that means we have formed a complete combination of letters, so we add the current combination string to the result vector and return.\\n7. Otherwise, get the possible letters corresponding to the current digit using the mapping vector.\\n8. Iterate through all the possible letters and set the current index of the combination string to that letter.\\n9. Call the backtrack function recursively with the incremented index.\\n10. After the recursive call returns, reset the current index of the combination string to its previous value so that we can try the next letter.\\n# Complexity:\\n- Time Complexity:\\nThe time complexity of the algorithm is O(3^N \\xD7 4^M), where N is the number of digits in the input string that correspond to 3 letters (\\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'8\\'), and M is the number of digits in the input string that correspond to 4 letters (\\'7\\', \\'9\\'). The reason for this is that each digit can correspond to 3 or 4 letters, and we need to generate all possible combinations of these letters. The maximum length of the result vector can be 3^N \\xD7 4^M, as each letter can be used at most once in a combination.\\n\\n- Space Complexity:\\nThe space complexity of the algorithm is O(N), where N is the number of digits in the input string. This is because we use a combination string of size N to store the current combination of letters being formed, and a result vector to store all the possible combinations. The mapping vector is of constant size and does not contribute to the space complexity.\\n\\n---\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> result;\\n        if (digits.empty()) {\\n            return result;\\n        }\\n        vector<string> mapping = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        string combination(digits.size(), \\' \\');\\n        backtrack(result, mapping, combination, digits, 0);\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrack(vector<string>& result, const vector<string>& mapping, string& combination, const string& digits, int index) {\\n        if (index == digits.size()) {\\n            result.push_back(combination);\\n        } else {\\n            string letters = mapping[digits[index] - \\'0\\'];\\n            for (char letter : letters) {\\n                combination[index] = letter;\\n                backtrack(result, mapping, combination, digits, index + 1);\\n            }\\n        }\\n    }\\n};\\n\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<>();\\n        if (digits == null || digits.length() == 0) {\\n            return result;\\n        }\\n        String[] mapping = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        StringBuilder combination = new StringBuilder();\\n        backtrack(result, mapping, combination, digits, 0);\\n        return result;\\n    }\\n\\n    private void backtrack(List<String> result, String[] mapping, StringBuilder combination, String digits, int index) {\\n        if (index == digits.length()) {\\n            result.add(combination.toString());\\n        } else {\\n            String letters = mapping[digits.charAt(index) - \\'0\\'];\\n            for (char letter : letters.toCharArray()) {\\n                combination.append(letter);\\n                backtrack(result, mapping, combination, digits, index + 1);\\n                combination.deleteCharAt(combination.length() - 1);\\n            }\\n        }\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        result = []\\n        if not digits:\\n            return result\\n        mapping = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\\n        combination = [\"\"] * len(digits)\\n        self.backtrack(result, mapping, combination, digits, 0)\\n        return result\\n\\n    def backtrack(self, result, mapping, combination, digits, index):\\n        if index == len(digits):\\n            result.append(\"\".join(combination))\\n        else:\\n            letters = mapping[int(digits[index])]\\n            for letter in letters:\\n                combination[index] = letter\\n                self.backtrack(result, mapping, combination, digits, index + 1)\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar letterCombinations = function(digits) {\\n    const result = [];\\n    if (!digits) {\\n        return result;\\n    }\\n    const mapping = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\\n    const combination = new Array(digits.length).fill(\\'\\');\\n    backtrack(result, mapping, combination, digits, 0);\\n    return result;\\n};\\n\\nfunction backtrack(result, mapping, combination, digits, index) {\\n    if (index === digits.length) {\\n        result.push(combination.join(\\'\\'));\\n    } else {\\n        const letters = mapping[digits.charAt(index) - \\'0\\'];\\n        for (const letter of letters) {\\n            combination[index] = letter;\\n            backtrack(result, mapping, combination, digits, index + 1);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> result;\\n        if (digits.empty()) {\\n            return result;\\n        }\\n        vector<string> mapping = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        string combination(digits.size(), \\' \\');\\n        backtrack(result, mapping, combination, digits, 0);\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrack(vector<string>& result, const vector<string>& mapping, string& combination, const string& digits, int index) {\\n        if (index == digits.size()) {\\n            result.push_back(combination);\\n        } else {\\n            string letters = mapping[digits[index] - \\'0\\'];\\n            for (char letter : letters) {\\n                combination[index] = letter;\\n                backtrack(result, mapping, combination, digits, index + 1);\\n            }\\n        }\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<>();\\n        if (digits == null || digits.length() == 0) {\\n            return result;\\n        }\\n        String[] mapping = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        StringBuilder combination = new StringBuilder();\\n        backtrack(result, mapping, combination, digits, 0);\\n        return result;\\n    }\\n\\n    private void backtrack(List<String> result, String[] mapping, StringBuilder combination, String digits, int index) {\\n        if (index == digits.length()) {\\n            result.add(combination.toString());\\n        } else {\\n            String letters = mapping[digits.charAt(index) - \\'0\\'];\\n            for (char letter : letters.toCharArray()) {\\n                combination.append(letter);\\n                backtrack(result, mapping, combination, digits, index + 1);\\n                combination.deleteCharAt(combination.length() - 1);\\n            }\\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        result = []\\n        if not digits:\\n            return result\\n        mapping = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\\n        combination = [\"\"] * len(digits)\\n        self.backtrack(result, mapping, combination, digits, 0)\\n        return result\\n\\n    def backtrack(self, result, mapping, combination, digits, index):\\n        if index == len(digits):\\n            result.append(\"\".join(combination))\\n        else:\\n            letters = mapping[int(digits[index])]\\n            for letter in letters:\\n                combination[index] = letter\\n                self.backtrack(result, mapping, combination, digits, index + 1)\\n\\n```\n```\\nvar letterCombinations = function(digits) {\\n    const result = [];\\n    if (!digits) {\\n        return result;\\n    }\\n    const mapping = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\\n    const combination = new Array(digits.length).fill(\\'\\');\\n    backtrack(result, mapping, combination, digits, 0);\\n    return result;\\n};\\n\\nfunction backtrack(result, mapping, combination, digits, index) {\\n    if (index === digits.length) {\\n        result.push(combination.join(\\'\\'));\\n    } else {\\n        const letters = mapping[digits.charAt(index) - \\'0\\'];\\n        for (const letter of letters) {\\n            combination[index] = letter;\\n            backtrack(result, mapping, combination, digits, index + 1);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863478,
                "title": "javascript-solution-17",
                "content": "```\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nlet letterCombinations = function(digits) {\\n    if(!digits.length) return [];\\n    \\n    let map = {\\n        2: [\\'a\\', \\'b\\', \\'c\\'],\\n        3: [\\'d\\', \\'e\\', \\'f\\'],\\n        4: [\\'g\\', \\'h\\', \\'i\\'],\\n        5: [\\'j\\', \\'k\\', \\'l\\'],\\n        6: [\\'m\\', \\'n\\', \\'o\\'],\\n        7: [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n        8: [\\'t\\', \\'u\\', \\'v\\'],\\n        9: [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n    }\\n    \\n    let result = [];\\n    \\n    function permute(string, index) {\\n        if(index === digits.length) {\\n            result.push(string);\\n            return;\\n        }\\n        \\n        for(let x of map[digits[index]]) {\\n            permute(string+x, index+1);\\n        }\\n    }\\n    permute(\\'\\', 0);\\n    return result;\\n};\\n```\\n**Runtime: 72 ms, faster than 79.81% of JavaScript online submissions for Letter Combinations of a Phone Number.**\\n\\n**Memory Usage: 38.6 MB, less than 5.04% of JavaScript online submissions for Letter Combinations of a Phone Number.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nlet letterCombinations = function(digits) {\\n    if(!digits.length) return [];\\n    \\n    let map = {\\n        2: [\\'a\\', \\'b\\', \\'c\\'],\\n        3: [\\'d\\', \\'e\\', \\'f\\'],\\n        4: [\\'g\\', \\'h\\', \\'i\\'],\\n        5: [\\'j\\', \\'k\\', \\'l\\'],\\n        6: [\\'m\\', \\'n\\', \\'o\\'],\\n        7: [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n        8: [\\'t\\', \\'u\\', \\'v\\'],\\n        9: [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n    }\\n    \\n    let result = [];\\n    \\n    function permute(string, index) {\\n        if(index === digits.length) {\\n            result.push(string);\\n            return;\\n        }\\n        \\n        for(let x of map[digits[index]]) {\\n            permute(string+x, index+1);\\n        }\\n    }\\n    permute(\\'\\', 0);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3098110,
                "title": "c-very-simple-back-tracking-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the idea of subsets using backtracking and here we first have to match the character strings  to integers  and then take subsets of digit string size. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(4^N)$$ beacuse only 4 digit string size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(4^N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    map<int,string>mp;\\n    void backtrack(string& dig,int start,string &temp){\\n        \\n        if(start==dig.size())ans.push_back(temp);\\n\\n          for(auto x:mp[dig[start]-\\'0\\']){\\n              temp.push_back(x);\\n              backtrack(dig,start+1,temp);\\n              temp.pop_back();\\n          }\\n    }\\n    vector<string> letterCombinations(string dig) {\\n        if(dig==\"\") return ans;\\n        mp[2] = \"abc\";\\n        mp[3] = \"def\";\\n        mp[4] = \"ghi\";\\n        mp[5] = \"jkl\";\\n        mp[6] = \"mno\";\\n        mp[7] = \"pqrs\";\\n        mp[8] = \"tuv\";\\n        mp[9] = \"wxyz\";\\n        string temp;\\n        backtrack(dig,0,temp);\\n        return ans;\\n    }\\n};\\n```\\n# UPVOTE IF HELPFULL \\uD83D\\uDD3C\\uD83D\\uDD3C",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    map<int,string>mp;\\n    void backtrack(string& dig,int start,string &temp){\\n        \\n        if(start==dig.size())ans.push_back(temp);\\n\\n          for(auto x:mp[dig[start]-\\'0\\']){\\n              temp.push_back(x);\\n              backtrack(dig,start+1,temp);\\n              temp.pop_back();\\n          }\\n    }\\n    vector<string> letterCombinations(string dig) {\\n        if(dig==\"\") return ans;\\n        mp[2] = \"abc\";\\n        mp[3] = \"def\";\\n        mp[4] = \"ghi\";\\n        mp[5] = \"jkl\";\\n        mp[6] = \"mno\";\\n        mp[7] = \"pqrs\";\\n        mp[8] = \"tuv\";\\n        mp[9] = \"wxyz\";\\n        string temp;\\n        backtrack(dig,0,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031239,
                "title": "easy-c-solution-faang-interview-code",
                "content": "# ***Please Upvote if it helps \\u2764\\uFE0F***\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int ind, string &ds, vector<string> &ans, string mapping[], string digits){\\n        if(ind==digits.size()){\\n            ans.emplace_back(ds);\\n            return;\\n        }\\n        string value = mapping[digits[ind]-\\'0\\'];\\n\\n        for(int i=0; i<value.size(); i++){\\n                ds+=value[i];\\n                solve(ind+1, ds, ans, mapping, digits);\\n                ds.pop_back();\\n       }\\n\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        string ds;\\n        vector<string> ans;\\n        if(digits.size()==0)\\n            return ans;\\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        solve(0, ds, ans, mapping, digits);\\n        return ans;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int ind, string &ds, vector<string> &ans, string mapping[], string digits){\\n        if(ind==digits.size()){\\n            ans.emplace_back(ds);\\n            return;\\n        }\\n        string value = mapping[digits[ind]-\\'0\\'];\\n\\n        for(int i=0; i<value.size(); i++){\\n                ds+=value[i];\\n                solve(ind+1, ds, ans, mapping, digits);\\n                ds.pop_back();\\n       }\\n\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        string ds;\\n        vector<string> ans;\\n        if(digits.size()==0)\\n            return ans;\\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        solve(0, ds, ans, mapping, digits);\\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020893,
                "title": "python-one-liner-solution-with-explanation",
                "content": "### Introduction\\n\\nGiven a string of digits, return all possible combinations of letters the digit string can represent when the digits are mapped to the respective alphabetical characters.\\n\\nFor those who require the mapping due to accessibility issues without wanting the actual code, I paste the dictionary I used here:\\n\\n```python\\n{\\n    \\'2\\': \\'abc\\',\\n    \\'3\\': \\'def\\',\\n    \\'4\\': \\'ghi\\',\\n    \\'5\\': \\'jkl\\',\\n    \\'6\\': \\'mno\\',\\n    \\'7\\': \\'pqrs\\',\\n    \\'8\\': \\'tuv\\',\\n    \\'9\\': \\'wxyz\\'\\n}\\n```\\n\\n---\\n\\n### Explanation\\n\\nThe sequence of events to perform is simple enough:\\n\\n1. For each digit, obtain the list of characters that it maps to.\\n2. Obtain all possible combinations of characters per index.\\n3. Concatenate all characters into one string (one of the possible strings).\\n4. Add the resultant string into a list to return later.\\n\\nThe difficulty comes from step 2; how do we obtain all possible combinations? Thankfully, **Python has a built-in [iterator.product](https://docs.python.org/3/library/itertools.html#itertools.product) function that provides this exact functionality**.\\n\\n```python\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        digit_map = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n        # step 1: map digits to characters\\n        chars = [digit_map[digit] for digit in digits]\\n        # step 2: obtain all possible combinations\\n        combs = product(*chars)  # or product(chrs for chrs in chars)\\n        result = []\\n        for comb in combs:\\n            if not comb:\\n                continue\\n            # step 3: concatenate characters\\n            string = \\'\\'.join(comb)\\n            # step 4: add to result list\\n            result.append(string)\\n        return result\\n```\\n\\n---\\n\\n### One-liner Implementation\\n\\n```python\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        return list(map(\\'\\'.join, product(*({\\'2\\': \\'abc\\', \\'3\\': \\'def\\', \\'4\\': \\'ghi\\', \\'5\\': \\'jkl\\', \\'6\\': \\'mno\\', \\'7\\': \\'pqrs\\', \\'8\\': \\'tuv\\', \\'9\\': \\'wxyz\\'}[digit] for digit in digits)))) if digits else []\\n```\\n\\n**TC: O(4<sup>n</sup>)**, where `n` is the length of the digit string, since each digit maps to a maximum of 4 characters.\\n**SC: O(4<sup>n</sup>)**, for resultant list. Auxiliary space used is **O(8)**, due to `digit_map`.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n{\\n    \\'2\\': \\'abc\\',\\n    \\'3\\': \\'def\\',\\n    \\'4\\': \\'ghi\\',\\n    \\'5\\': \\'jkl\\',\\n    \\'6\\': \\'mno\\',\\n    \\'7\\': \\'pqrs\\',\\n    \\'8\\': \\'tuv\\',\\n    \\'9\\': \\'wxyz\\'\\n}\\n```\n```python\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        digit_map = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\'\\n        }\\n        # step 1: map digits to characters\\n        chars = [digit_map[digit] for digit in digits]\\n        # step 2: obtain all possible combinations\\n        combs = product(*chars)  # or product(chrs for chrs in chars)\\n        result = []\\n        for comb in combs:\\n            if not comb:\\n                continue\\n            # step 3: concatenate characters\\n            string = \\'\\'.join(comb)\\n            # step 4: add to result list\\n            result.append(string)\\n        return result\\n```\n```python\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        return list(map(\\'\\'.join, product(*({\\'2\\': \\'abc\\', \\'3\\': \\'def\\', \\'4\\': \\'ghi\\', \\'5\\': \\'jkl\\', \\'6\\': \\'mno\\', \\'7\\': \\'pqrs\\', \\'8\\': \\'tuv\\', \\'9\\': \\'wxyz\\'}[digit] for digit in digits)))) if digits else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856064,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing backtracking to create all possible combinations\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/q0RJHpE92Zk\\n\\n# Subscribe to my channel from here. I have 239 videos as of August 3rd\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n\\n# Approach\\nThis is based on Python solution. Other might be differnt a bit.\\n\\n1. Initialize an empty list `res` to store the generated combinations.\\n\\n2. Check if the `digits` string is empty. If it is, return an empty list since there are no digits to process.\\n\\n3. Create a dictionary `digit_to_letters` that maps each digit from \\'2\\' to \\'9\\' to the corresponding letters on a phone keypad.\\n\\n4. Define a recursive function `backtrack(idx, comb)` that takes two parameters:\\n   - `idx`: The current index of the digit being processed in the `digits` string.\\n   - `comb`: The current combination being formed by appending letters.\\n\\n5. Inside the `backtrack` function:\\n   - Check if `idx` is equal to the length of the `digits` string. If it is, it means a valid combination has been formed, so append the current `comb` to the `res` list.\\n   - If not, iterate through each letter corresponding to the digit at `digits[idx]` using the `digit_to_letters` dictionary.\\n   - For each letter, recursively call `backtrack` with `idx + 1` to process the next digit and `comb + letter` to add the current letter to the combination.\\n\\n6. Initialize the `res` list.\\n\\n7. Start the initial call to `backtrack` with `idx` set to 0 and an empty string as `comb`. This will start the process of generating combinations.\\n\\n8. After the recursive calls have been made, return the `res` list containing all the generated combinations.\\n\\nThe algorithm works by iteratively exploring all possible combinations of letters that can be formed from the given input digits. It uses a recursive approach to generate combinations, building them one letter at a time. The base case for the recursion is when all digits have been processed, at which point a combination is complete and added to the `res` list. The backtracking nature of the algorithm ensures that all possible combinations are explored.\\n\\n# Complexity\\n- Time complexity: O(3^n) or O(4^n)\\nn is length of input string. Each digit has 3 or 4 letters. For example, if you get \"23\"(n) as input string, we will create 9 combinations which is O(3^2) = 9\\n\\n- Space complexity: O(n)\\nn is length of input string. This is for recursive call stack.\\n\\n```python []\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n        \\n        digit_to_letters = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n\\n        def backtrack(idx, comb):\\n            if idx == len(digits):\\n                res.append(comb[:])\\n                return\\n            \\n            for letter in digit_to_letters[digits[idx]]:\\n                backtrack(idx + 1, comb + letter)\\n\\n        res = []\\n        backtrack(0, \"\")\\n\\n        return res\\n```\\n```javascript []\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nvar letterCombinations = function(digits) {\\n    if (!digits.length) {\\n        return [];\\n    }\\n    \\n    const digitToLetters = {\\n        \\'2\\': \\'abc\\',\\n        \\'3\\': \\'def\\',\\n        \\'4\\': \\'ghi\\',\\n        \\'5\\': \\'jkl\\',\\n        \\'6\\': \\'mno\\',\\n        \\'7\\': \\'pqrs\\',\\n        \\'8\\': \\'tuv\\',\\n        \\'9\\': \\'wxyz\\'\\n    };\\n    \\n    const res = [];\\n    \\n    function backtrack(idx, comb) {\\n        if (idx === digits.length) {\\n            res.push(comb);\\n            return;\\n        }\\n        \\n        for (const letter of digitToLetters[digits[idx]]) {\\n            backtrack(idx + 1, comb + letter);\\n        }\\n    }\\n    \\n    backtrack(0, \"\");\\n    \\n    return res;    \\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if (digits == null || digits.length() == 0) {\\n            return res;\\n        }\\n        \\n        Map<Character, String> digitToLetters = new HashMap<>();\\n        digitToLetters.put(\\'2\\', \"abc\");\\n        digitToLetters.put(\\'3\\', \"def\");\\n        digitToLetters.put(\\'4\\', \"ghi\");\\n        digitToLetters.put(\\'5\\', \"jkl\");\\n        digitToLetters.put(\\'6\\', \"mno\");\\n        digitToLetters.put(\\'7\\', \"pqrs\");\\n        digitToLetters.put(\\'8\\', \"tuv\");\\n        digitToLetters.put(\\'9\\', \"wxyz\");\\n        \\n        backtrack(digits, 0, new StringBuilder(), res, digitToLetters);\\n        \\n        return res;        \\n    }\\n\\n    private void backtrack(String digits, int idx, StringBuilder comb, List<String> res, Map<Character, String> digitToLetters) {\\n        if (idx == digits.length()) {\\n            res.add(comb.toString());\\n            return;\\n        }\\n        \\n        String letters = digitToLetters.get(digits.charAt(idx));\\n        for (char letter : letters.toCharArray()) {\\n            comb.append(letter);\\n            backtrack(digits, idx + 1, comb, res, digitToLetters);\\n            comb.deleteCharAt(comb.length() - 1);\\n        }\\n    }    \\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> res;\\n        \\n        if (digits.empty()) {\\n            return res;\\n        }\\n        \\n        unordered_map<char, string> digitToLetters = {\\n            {\\'2\\', \"abc\"},\\n            {\\'3\\', \"def\"},\\n            {\\'4\\', \"ghi\"},\\n            {\\'5\\', \"jkl\"},\\n            {\\'6\\', \"mno\"},\\n            {\\'7\\', \"pqrs\"},\\n            {\\'8\\', \"tuv\"},\\n            {\\'9\\', \"wxyz\"}\\n        };\\n        \\n        backtrack(digits, 0, \"\", res, digitToLetters);\\n        \\n        return res;        \\n    }\\n\\n    void backtrack(const string& digits, int idx, string comb, vector<string>& res, const unordered_map<char, string>& digitToLetters) {\\n        if (idx == digits.length()) {\\n            res.push_back(comb);\\n            return;\\n        }\\n        \\n        string letters = digitToLetters.at(digits[idx]);\\n        for (char letter : letters) {\\n            backtrack(digits, idx + 1, comb + letter, res, digitToLetters);\\n        }\\n    }    \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n        \\n        digit_to_letters = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'ghi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n\\n        def backtrack(idx, comb):\\n            if idx == len(digits):\\n                res.append(comb[:])\\n                return\\n            \\n            for letter in digit_to_letters[digits[idx]]:\\n                backtrack(idx + 1, comb + letter)\\n\\n        res = []\\n        backtrack(0, \"\")\\n\\n        return res\\n```\n```javascript []\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nvar letterCombinations = function(digits) {\\n    if (!digits.length) {\\n        return [];\\n    }\\n    \\n    const digitToLetters = {\\n        \\'2\\': \\'abc\\',\\n        \\'3\\': \\'def\\',\\n        \\'4\\': \\'ghi\\',\\n        \\'5\\': \\'jkl\\',\\n        \\'6\\': \\'mno\\',\\n        \\'7\\': \\'pqrs\\',\\n        \\'8\\': \\'tuv\\',\\n        \\'9\\': \\'wxyz\\'\\n    };\\n    \\n    const res = [];\\n    \\n    function backtrack(idx, comb) {\\n        if (idx === digits.length) {\\n            res.push(comb);\\n            return;\\n        }\\n        \\n        for (const letter of digitToLetters[digits[idx]]) {\\n            backtrack(idx + 1, comb + letter);\\n        }\\n    }\\n    \\n    backtrack(0, \"\");\\n    \\n    return res;    \\n};\\n```\n```Java []\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if (digits == null || digits.length() == 0) {\\n            return res;\\n        }\\n        \\n        Map<Character, String> digitToLetters = new HashMap<>();\\n        digitToLetters.put(\\'2\\', \"abc\");\\n        digitToLetters.put(\\'3\\', \"def\");\\n        digitToLetters.put(\\'4\\', \"ghi\");\\n        digitToLetters.put(\\'5\\', \"jkl\");\\n        digitToLetters.put(\\'6\\', \"mno\");\\n        digitToLetters.put(\\'7\\', \"pqrs\");\\n        digitToLetters.put(\\'8\\', \"tuv\");\\n        digitToLetters.put(\\'9\\', \"wxyz\");\\n        \\n        backtrack(digits, 0, new StringBuilder(), res, digitToLetters);\\n        \\n        return res;        \\n    }\\n\\n    private void backtrack(String digits, int idx, StringBuilder comb, List<String> res, Map<Character, String> digitToLetters) {\\n        if (idx == digits.length()) {\\n            res.add(comb.toString());\\n            return;\\n        }\\n        \\n        String letters = digitToLetters.get(digits.charAt(idx));\\n        for (char letter : letters.toCharArray()) {\\n            comb.append(letter);\\n            backtrack(digits, idx + 1, comb, res, digitToLetters);\\n            comb.deleteCharAt(comb.length() - 1);\\n        }\\n    }    \\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> res;\\n        \\n        if (digits.empty()) {\\n            return res;\\n        }\\n        \\n        unordered_map<char, string> digitToLetters = {\\n            {\\'2\\', \"abc\"},\\n            {\\'3\\', \"def\"},\\n            {\\'4\\', \"ghi\"},\\n            {\\'5\\', \"jkl\"},\\n            {\\'6\\', \"mno\"},\\n            {\\'7\\', \"pqrs\"},\\n            {\\'8\\', \"tuv\"},\\n            {\\'9\\', \"wxyz\"}\\n        };\\n        \\n        backtrack(digits, 0, \"\", res, digitToLetters);\\n        \\n        return res;        \\n    }\\n\\n    void backtrack(const string& digits, int idx, string comb, vector<string>& res, const unordered_map<char, string>& digitToLetters) {\\n        if (idx == digits.length()) {\\n            res.push_back(comb);\\n            return;\\n        }\\n        \\n        string letters = digitToLetters.at(digits[idx]);\\n        for (char letter : letters) {\\n            backtrack(digits, idx + 1, comb + letter, res, digitToLetters);\\n        }\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953534,
                "title": "beats-100-explanation-o-4-n-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def letterCombinations(self, n: str) -> List[str]:\\n        # Return an empty list if n is an empty string\\n        if n==\\'\\':\\n            return []\\n        \\n        # List of options for each digit on the keypad\\n        options = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\\n        \\n        # Initialize queue with an empty string\\n        queue = [\"\"]\\n        \\n        # Loop over each digit in n\\n        for digit in n:\\n            # Convert digit to integer\\n            digit = int(digit)            \\n            # Loop over the length of queue\\n            for _ in range(len(queue)):\\n                # Remove the first element in queue and store it in curr\\n                curr = queue.pop(0)\\n                # Append the concatenation of curr and each character in the set of characters corresponding to digit in options to queue\\n                for letter in options[digit]:\\n                    queue.append(curr + letter)\\n        \\n        # Return the list of combinations stored in queue\\n        return queue\\n\\n        \\n```\\n![beats.PNG](https://assets.leetcode.com/users/images/e510473f-d87d-4912-88dc-623f27cb6175_1672469113.5041747.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, n: str) -> List[str]:\\n        # Return an empty list if n is an empty string\\n        if n==\\'\\':\\n            return []\\n        \\n        # List of options for each digit on the keypad\\n        options = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\\n        \\n        # Initialize queue with an empty string\\n        queue = [\"\"]\\n        \\n        # Loop over each digit in n\\n        for digit in n:\\n            # Convert digit to integer\\n            digit = int(digit)            \\n            # Loop over the length of queue\\n            for _ in range(len(queue)):\\n                # Remove the first element in queue and store it in curr\\n                curr = queue.pop(0)\\n                # Append the concatenation of curr and each character in the set of characters corresponding to digit in options to queue\\n                for letter in options[digit]:\\n                    queue.append(curr + letter)\\n        \\n        # Return the list of combinations stored in queue\\n        return queue\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148315,
                "title": "letter-combinations-of-a-phone-number-js-python-java-c-easy-recursive-dfs-solution-w-exp",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince each digit can possibly mean one of several characters, we\\'ll need to create code that branches down the different paths as we iterate through the input digit string (**D**).\\n\\nThis quite obviously calls for a **depth-first search** (**DFS**) approach as we will check each permutation of characters and store them in our answer array (**ans**). For a DFS approach we can use one of several options, but a **recursive** solution is generally the cleanest.\\n\\nBut first, we\\'ll need to set up a lookup table (**L**) to convert a digit to its possible characters. Since the digits are actually low-indexed integers, we can actually choose between an **array** or **map**/**dictionary** here with little difference.\\n\\nFor our DFS function (**dfs**), we\\'ll have to feed it the current position (**pos**) in **D** as well as the string (**str**) being built. The function will also need to have access to **D**, **L**, and **ans**.\\n\\nThe DFS function itself is fairly simple. It will push a completed **str** onto **ans**, otherwise it will look up the characters that match the current **pos**, and then fire off new recursive functions down each of those paths.\\n\\nOnce we\\'re done, we should be ready to **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript and Python will have scoped access to **D**, **L**, and **ans** inside **dfs**, so won\\'t need to pass in references via arguments.\\n\\nJava should make sure to use a **char[][]** and a **StringBuilder** for better performance here.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.4MB** (beats 97% / 92%).\\n```javascript\\nconst L = {\\'2\\':\"abc\",\\'3\\':\"def\",\\'4\\':\"ghi\",\\'5\\':\"jkl\",\\n     \\'6\\':\"mno\",\\'7\\':\"pqrs\",\\'8\\':\"tuv\",\\'9\\':\"wxyz\"}\\n\\nvar letterCombinations = function(D) {\\n    let len = D.length, ans = []\\n    if (!len) return []\\n    const dfs = (pos, str) => {\\n        if (pos === len) ans.push(str)\\n        else {\\n            let letters = L[D[pos]]\\n            for (let i = 0; i < letters.length; i++)\\n                dfs(pos+1,str+letters[i])\\n        }\\n    }\\n    dfs(0,\"\")\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.2MB** (beats 95% / 86%).\\n```python\\nL = {\\'2\\':\"abc\",\\'3\\':\"def\",\\'4\\':\"ghi\",\\'5\\':\"jkl\",\\n     \\'6\\':\"mno\",\\'7\\':\"pqrs\",\\'8\\':\"tuv\",\\'9\\':\"wxyz\"}\\n\\nclass Solution:\\n    def letterCombinations(self, D: str) -> List[str]:\\n        lenD, ans = len(D), []\\n        if D == \"\": return []\\n        def dfs(pos: int, st: str):\\n            if pos == lenD: ans.append(st)\\n            else:\\n                letters = L[D[pos]]\\n                for letter in letters:\\n                    dfs(pos+1,st+letter)\\n        dfs(0,\"\")\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 37.5MB** (beats 100% / 94%).\\n```java\\nclass Solution {\\n    final char[][] L = {{},{},{\\'a\\',\\'b\\',\\'c\\'},{\\'d\\',\\'e\\',\\'f\\'},{\\'g\\',\\'h\\',\\'i\\'},{\\'j\\',\\'k\\',\\'l\\'},\\n\\t{\\'m\\',\\'n\\',\\'o\\'},{\\'p\\',\\'q\\',\\'r\\',\\'s\\'},{\\'t\\',\\'u\\',\\'v\\'},{\\'w\\',\\'x\\',\\'y\\',\\'z\\'}};\\n    \\n    public List<String> letterCombinations(String D) {\\n        int len = D.length();\\n        List<String> ans = new ArrayList<>();\\n        if (len == 0) return ans;\\n        dfs(0, len, new StringBuilder(), ans, D);\\n        return ans;\\n    }\\n    \\n    public void dfs(int pos, int len, StringBuilder sb, List<String> ans, String D) {\\n        if (pos == len) ans.add(sb.toString());\\n        else {\\n            char[] letters = L[Character.getNumericValue(D.charAt(pos))];\\n            for (int i = 0; i < letters.length; i++)\\n                dfs(pos+1, len, new StringBuilder(sb).append(letters[i]), ans, D);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 6.4MB** (beats 100% / 96%).\\n```c++\\nunordered_map<char, string> L({{\\'2\\',\"abc\"},{\\'3\\',\"def\"},{\\'4\\',\"ghi\"},\\n    {\\'5\\',\"jkl\"},{\\'6\\',\"mno\"},{\\'7\\',\"pqrs\"},{\\'8\\',\"tuv\"},{\\'9\\',\"wxyz\"}});\\n\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string D) {\\n        int len = D.size();\\n        vector<string> ans;\\n        if (!len) return ans;\\n        dfs(0, len, \"\", ans, D);\\n        return ans;\\n    }\\n    \\n    void dfs(int pos, int &len, string str, vector<string> &ans, string &D) {\\n        if (pos == len) ans.push_back(str);\\n        else {\\n            string letters = L[D[pos]];\\n            for (int i = 0; i < letters.size(); i++)\\n                dfs(pos+1, len, str+letters[i], ans, D);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst L = {\\'2\\':\"abc\",\\'3\\':\"def\",\\'4\\':\"ghi\",\\'5\\':\"jkl\",\\n     \\'6\\':\"mno\",\\'7\\':\"pqrs\",\\'8\\':\"tuv\",\\'9\\':\"wxyz\"}\\n\\nvar letterCombinations = function(D) {\\n    let len = D.length, ans = []\\n    if (!len) return []\\n    const dfs = (pos, str) => {\\n        if (pos === len) ans.push(str)\\n        else {\\n            let letters = L[D[pos]]\\n            for (let i = 0; i < letters.length; i++)\\n                dfs(pos+1,str+letters[i])\\n        }\\n    }\\n    dfs(0,\"\")\\n    return ans\\n};\\n```\n```python\\nL = {\\'2\\':\"abc\",\\'3\\':\"def\",\\'4\\':\"ghi\",\\'5\\':\"jkl\",\\n     \\'6\\':\"mno\",\\'7\\':\"pqrs\",\\'8\\':\"tuv\",\\'9\\':\"wxyz\"}\\n\\nclass Solution:\\n    def letterCombinations(self, D: str) -> List[str]:\\n        lenD, ans = len(D), []\\n        if D == \"\": return []\\n        def dfs(pos: int, st: str):\\n            if pos == lenD: ans.append(st)\\n            else:\\n                letters = L[D[pos]]\\n                for letter in letters:\\n                    dfs(pos+1,st+letter)\\n        dfs(0,\"\")\\n        return ans\\n```\n```java\\nclass Solution {\\n    final char[][] L = {{},{},{\\'a\\',\\'b\\',\\'c\\'},{\\'d\\',\\'e\\',\\'f\\'},{\\'g\\',\\'h\\',\\'i\\'},{\\'j\\',\\'k\\',\\'l\\'},\\n\\t{\\'m\\',\\'n\\',\\'o\\'},{\\'p\\',\\'q\\',\\'r\\',\\'s\\'},{\\'t\\',\\'u\\',\\'v\\'},{\\'w\\',\\'x\\',\\'y\\',\\'z\\'}};\\n    \\n    public List<String> letterCombinations(String D) {\\n        int len = D.length();\\n        List<String> ans = new ArrayList<>();\\n        if (len == 0) return ans;\\n        dfs(0, len, new StringBuilder(), ans, D);\\n        return ans;\\n    }\\n    \\n    public void dfs(int pos, int len, StringBuilder sb, List<String> ans, String D) {\\n        if (pos == len) ans.add(sb.toString());\\n        else {\\n            char[] letters = L[Character.getNumericValue(D.charAt(pos))];\\n            for (int i = 0; i < letters.length; i++)\\n                dfs(pos+1, len, new StringBuilder(sb).append(letters[i]), ans, D);\\n        }\\n    }\\n}\\n```\n```c++\\nunordered_map<char, string> L({{\\'2\\',\"abc\"},{\\'3\\',\"def\"},{\\'4\\',\"ghi\"},\\n    {\\'5\\',\"jkl\"},{\\'6\\',\"mno\"},{\\'7\\',\"pqrs\"},{\\'8\\',\"tuv\"},{\\'9\\',\"wxyz\"}});\\n\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string D) {\\n        int len = D.size();\\n        vector<string> ans;\\n        if (!len) return ans;\\n        dfs(0, len, \"\", ans, D);\\n        return ans;\\n    }\\n    \\n    void dfs(int pos, int &len, string str, vector<string> &ans, string &D) {\\n        if (pos == len) ans.push_back(str);\\n        else {\\n            string letters = L[D[pos]];\\n            for (int i = 0; i < letters.size(); i++)\\n                dfs(pos+1, len, str+letters[i], ans, D);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8454,
                "title": "my-c-solution-use-dfs",
                "content": "        vector<string> letterCombinations(string digits) {\\n        vector<string> str;//str for final resut\\n        string save;//save for temporary answer\\n        int convert[10] = {0, 3, 6, 9, 12, 15, 19, 22, 26};\\n        dfs(str, save, digits, 0, digits.size(), convert);\\n        return str;\\n        }\\n        void dfs(vector<string> &str, string save, \\n             string dig, int now, int size, int *convert){\\n        if(now == size){\\n            str.push_back(save);\\n            return;\\n        }\\n        int tmp = dig[now] - '0' - 2;//change '2' to 0, '3' to 1...\\n        for(int i = convert[tmp]; i < convert[tmp+1]; i++){\\n            save.push_back('a' + i);//ex: a,b,c | d,e,f\\n            dfs(str, save, dig, now + 1, size, convert);\\n            save.pop_back();\\n        }\\n        }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "        vector<string> letterCombinations(string digits) {\\n        vector<string> str;//str for final resut\\n        string save;//save for temporary answer\\n        int convert[10] = {0, 3, 6, 9, 12, 15, 19, 22, 26};\\n        dfs(str, save, digits, 0, digits.size(), convert);\\n        return str;\\n        }\\n        void dfs(vector<string> &str, string save, \\n             string dig, int now, int size, int *convert){\\n        if(now == size){\\n            str.push_back(save);\\n            return;\\n        }\\n        int tmp = dig[now] - '0' - 2;//change '2' to 0, '3' to 1...\\n        for(int i = convert[tmp]; i < convert[tmp+1]; i++){\\n            save.push_back('a' + i);//ex: a,b,c | d,e,f\\n            dfs(str, save, dig, now + 1, size, convert);\\n            save.pop_back();\\n        }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 363299,
                "title": "python3-backtracking",
                "content": "```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        if digits == \\'\\':\\n            return []\\n        self.mapping = {\\'2\\': [\\'a\\', \\'b\\', \\'c\\'],\\n                 \\'3\\': [\\'d\\', \\'e\\', \\'f\\'],\\n                 \\'4\\': [\\'g\\', \\'h\\', \\'i\\'],\\n                 \\'5\\': [\\'j\\', \\'k\\', \\'l\\'],\\n                 \\'6\\': [\\'m\\', \\'n\\', \\'o\\'],\\n                 \\'7\\': [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n                 \\'8\\': [\\'t\\', \\'u\\', \\'v\\'],\\n                 \\'9\\': [\\'w\\', \\'x\\', \\'y\\', \\'z\\']}\\n        res = []\\n        self.backtracking(res,[],0,digits)\\n        return res\\n    def backtracking(self,res,subset, index,digits):\\n        if len(digits) == index:\\n            res.append(\\'\\'.join(subset))\\n            return \\n        for i in self.mapping[digits[index]]:\\n            subset.append(i)\\n            self.backtracking(res,subset,index+1,digits)\\n            subset.pop()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        if digits == \\'\\':\\n            return []\\n        self.mapping = {\\'2\\': [\\'a\\', \\'b\\', \\'c\\'],\\n                 \\'3\\': [\\'d\\', \\'e\\', \\'f\\'],\\n                 \\'4\\': [\\'g\\', \\'h\\', \\'i\\'],\\n                 \\'5\\': [\\'j\\', \\'k\\', \\'l\\'],\\n                 \\'6\\': [\\'m\\', \\'n\\', \\'o\\'],\\n                 \\'7\\': [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n                 \\'8\\': [\\'t\\', \\'u\\', \\'v\\'],\\n                 \\'9\\': [\\'w\\', \\'x\\', \\'y\\', \\'z\\']}\\n        res = []\\n        self.backtracking(res,[],0,digits)\\n        return res\\n    def backtracking(self,res,subset, index,digits):\\n        if len(digits) == index:\\n            res.append(\\'\\'.join(subset))\\n            return \\n        for i in self.mapping[digits[index]]:\\n            subset.append(i)\\n            self.backtracking(res,subset,index+1,digits)\\n            subset.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184395,
                "title": "python-20ms-faster-than-100-00-of-other-python-submissions",
                "content": "Not sure if the 100.00% is a rounding error on LeetCode's part, but...\n\n\n```\n\nclass Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if digits == \"\":\n            return []\n        \n        nums_to_letters = {\n            2: \"abc\",\n            3: \"def\",\n            4: \"ghi\",\n            5: \"jkl\",\n            6: \"mno\",\n            7: \"pqrs\",\n            8: \"tuv\",\n            9: \"wxyz\"\n        }\n        \n        combs = [\"\"]\n        for digit in digits:\n            new_combs = []\n            for comb in combs:\n                for letter in nums_to_letters[int(digit)]:\n                    new_combs.append(comb + letter)\n            combs = new_combs\n            \n        return combs\n```",
                "solutionTags": [],
                "code": "```\n\nclass Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if digits == \"\":\n            return []\n        \n        nums_to_letters = {\n            2: \"abc\",\n            3: \"def\",\n            4: \"ghi\",\n            5: \"jkl\",\n            6: \"mno\",\n            7: \"pqrs\",\n            8: \"tuv\",\n            9: \"wxyz\"\n        }\n        \n        combs = [\"\"]\n        for digit in digits:\n            new_combs = []\n            for comb in combs:\n                for letter in nums_to_letters[int(digit)]:\n                    new_combs.append(comb + letter)\n            combs = new_combs\n            \n        return combs\n```",
                "codeTag": "Java"
            },
            {
                "id": 8434,
                "title": "my-simple-java-solution",
                "content": "     public class Solution {\\n     String[][] refer={{},{},{\"a\",\"c\",\"b\"},{\"d\",\"e\",\"f\"},{\"g\",\"h\",\"i\"},{\"j\",\"k\",\"l\"},{\"m\",\"n\",\"o\"},{\"p\",\"q\",\"r\",\"s\"},{\"t\",\"u\",\"v\"},{\"w\",\"x\",\"y\",\"z\"}};\\n\\t    \\n\\t    public List<String> letterCombinations(String digits) {\\t        \\n\\t    \\tList<String> list=new ArrayList<String>();\\n\\t    \\tif(!digits.equals(\"\")){helper(list,digits,\"\"); return list;}\\n\\t    \\t return list;\\t    \\t\\n\\t    }\\n\\t    private void helper(List<String> list,String digits,String s){\\n\\t    \\t   if(digits.length()==0){ list.add(s); return;}\\n\\t    \\t\\tint idx=Integer.parseInt(digits.substring(0, 1)); \\n\\t    \\t\\tfor(String k:refer[idx]){\\n\\t    \\t\\t  helper(list,digits.substring(1,digits.length()),s+k);\\t\\n\\t    \\t\\t}\\t\\t\\n\\t    \\treturn;\\n\\t    }\\n\\t        \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     String[][] refer={{}",
                "codeTag": "Java"
            },
            {
                "id": 2021963,
                "title": "java-simple-solution-using-queue",
                "content": "**Approach**\\n* create a queue and insert all the character of first number in the queue\\n* now dequeue the elements from the begning of queue and add that character with all the charcter of second number and start to enque them in the Queue\\n* repeat this process for all the digits given in the code and return that queue as an array \\n\\n**Here is a diagramatic representation of the approach**\\n\\n![image](https://assets.leetcode.com/users/images/d2689f2e-22d1-4268-8034-97e54453d7a6_1652085366.7490282.jpeg)\\n\\nDo upvote if you liked it :)\\n\\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> s = new ArrayList<>();\\n        \\n        if(digits == null || digits.length() == 0)\\n            return s;\\n        \\n        int len = digits.length();\\n        int arr[] = new int[len];\\n        for(int i =0 ;i< len ; i++){\\n            arr[i]  = digits.charAt(i)-\\'0\\';\\n        }\\n        \\n        String letters[] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        Queue<String> que = new LinkedList<>();\\n        que.offer(\"\"); //better then queue.add() as it does not throw run time exception\\n        \\n        for(int i =0 ; i< len; i++){\\n            String word = letters[arr[i]-2];\\n            int size = que.size();\\n            for (int j = 0; j < size; j++) {\\n                String temp = que.poll();\\n                for (char ch : word.toCharArray()) {\\n                    que.offer(temp + ch);\\n                }\\n            }\\n        }\\n        return new ArrayList<>(que);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> s = new ArrayList<>();\\n        \\n        if(digits == null || digits.length() == 0)\\n            return s;\\n        \\n        int len = digits.length();\\n        int arr[] = new int[len];\\n        for(int i =0 ;i< len ; i++){\\n            arr[i]  = digits.charAt(i)-\\'0\\';\\n        }\\n        \\n        String letters[] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        Queue<String> que = new LinkedList<>();\\n        que.offer(\"\"); //better then queue.add() as it does not throw run time exception\\n        \\n        for(int i =0 ; i< len; i++){\\n            String word = letters[arr[i]-2];\\n            int size = que.size();\\n            for (int j = 0; j < size; j++) {\\n                String temp = que.poll();\\n                for (char ch : word.toCharArray()) {\\n                    que.offer(temp + ch);\\n                }\\n            }\\n        }\\n        return new ArrayList<>(que);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148203,
                "title": "python-short-solution-using-product-explained",
                "content": "One way to solve this problem is to do backtracking. However we can use functionality of python `product` function, which will do almost everything for us. What is product? It is casterian product of two objects, for example if we have `ob1 = [a, b, c]` and `ob2 = [d, e]`, then `product(ob1, ob2) = [ad, bd, cd, ae, be, ce]`. And this is almost what we need:\\n1. In fact what will be returned are lists, so we need to join them.\\n2. We need product of not `2` but several objects, and we will use `*` notation for this.\\n\\n#### Complexity\\nBoth time and space is `O(3^m*4^n*(m+n))`, where `m` is number of digits for which we have `3` options and `n` is number of letters for which we have `4` options, because we have `3^m*4^n` options with `m+n` length each.\\n\\n```\\nclass Solution:\\n    def letterCombinations(self, digits):\\n        if not digits: return []\\n        d = {\"2\":\"abc\", \"3\":\"def\", \"4\":\"ghi\", \"5\":\"jkl\", \"6\":\"mno\", \"7\":\"pqrs\", \"8\":\"tuv\", \"9\":\"wxyz\"}\\n        return [\"\".join(num) for num in product(*[d[i] for i in digits])]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, digits):\\n        if not digits: return []\\n        d = {\"2\":\"abc\", \"3\":\"def\", \"4\":\"ghi\", \"5\":\"jkl\", \"6\":\"mno\", \"7\":\"pqrs\", \"8\":\"tuv\", \"9\":\"wxyz\"}\\n        return [\"\".join(num) for num in product(*[d[i] for i in digits])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834235,
                "title": "c-easy-solution-faster-than-100-compilers",
                "content": "**Do upvote if you find it helpful**\\nclass Solution {\\npublic:\\n\\n    void compare(string str, int i, string n, vector<string> &num, vector<string> &apt){\\n        if(i==n.size()) {\\n            apt.push_back(str);\\n            return;\\n        }\\n        for(int j=0; j<num[n[i] - \\'2\\'].size(); j++){\\n            str.push_back(num[n[i] - \\'2\\'][j]);\\n            compare(str, i+1, n, num, apt);\\n            str.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> number;\\n        number.push_back(\"abc\");\\n        number.push_back(\"def\");\\n        number.push_back(\"ghi\");\\n        number.push_back(\"jkl\");\\n        number.push_back(\"mno\");\\n        number.push_back(\"pqrs\");\\n        number.push_back(\"tuv\");\\n        number.push_back(\"wxyz\");\\n        string s;\\n        vector<string> ans;\\n        if(digits.size()==0)\\n            return ans;\\n        compare(s, 0, digits, number, ans);\\n        return ans;    \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    void compare(string str, int i, string n, vector<string> &num, vector<string> &apt){\\n        if(i==n.size()) {\\n            apt.push_back(str);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4047135,
                "title": "java-runtime-0ms-using-a-map-recursive-approach",
                "content": "# Intuition\\nMy initial thoughts on solving this problem involve using a recursive approach to generate all possible letter combinations for a given set of digits. We can associate each digit with a set of letters, similar to a phone\\'s keypad, and then combine these letters to form all possible combinations\\n\\n# Approach\\nI have implemented a solution using Java. Here\\'s a breakdown of the approach:\\n\\nWe create a Map called digitToLetters to store the mapping of each digit to the corresponding letters.\\n\\nWe initialize an empty List called resultList to store the final letter combinations.\\n\\nIn the letterCombinations method, we first check if the input digits is null or empty. If it is, we return the empty resultList.\\n\\nWe populate the digitToLetters map with the mappings for digits 2 to 9, where each digit is associated with a string of letters.\\n\\nWe call the generateCombinations method to start the recursive process of generating letter combinations.\\n\\nInside the generateCombinations method, we check if we have processed all the digits (i.e., currentIndex equals the length of digits). If so, we add the current combination to the resultList.\\n\\nIf we haven\\'t processed all the digits yet, we retrieve the letters associated with the current digit from the digitToLetters map.\\n\\nWe iterate through the available letters, appending each letter to the currentCombination, recursively generating combinations for the next digit, and then removing the last character to backtrack and explore other possibilities.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private Map<Character, String> digitToLetters = new HashMap<>();\\n    private List<String> resultList = new ArrayList<>();\\n\\n    public List<String> letterCombinations(String digits) {\\n        if (digits == null || digits.length() == 0) {\\n            return resultList;\\n        }\\n\\n        digitToLetters.put(\\'2\\', \"abc\");\\n        digitToLetters.put(\\'3\\', \"def\");\\n        digitToLetters.put(\\'4\\', \"ghi\");\\n        digitToLetters.put(\\'5\\', \"jkl\");\\n        digitToLetters.put(\\'6\\', \"mno\");\\n        digitToLetters.put(\\'7\\', \"pqrs\");\\n        digitToLetters.put(\\'8\\', \"tuv\");\\n        digitToLetters.put(\\'9\\', \"wxyz\");\\n\\n        generateCombinations(digits, 0, new StringBuilder());\\n\\n        return resultList;\\n\\n\\n    }\\n\\n\\n    private void generateCombinations(String digits, int currentIndex, StringBuilder currentCombination) {\\n        if (currentIndex == digits.length()) {\\n            resultList.add(currentCombination.toString());\\n            return;\\n        }\\n\\n        char currentDigit = digits.charAt(currentIndex);\\n        String letterOptions = digitToLetters.get(currentDigit);\\n\\n        if (letterOptions != null) {\\n            for (int i = 0; i < letterOptions.length(); i++) {\\n                char letter = letterOptions.charAt(i);\\n                currentCombination.append(letter);\\n                generateCombinations(digits, currentIndex + 1, currentCombination);\\n                currentCombination.deleteCharAt(currentCombination.length() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/de01e35a-676a-462c-a527-f34bdf441e5a_1694768724.916569.webp)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private Map<Character, String> digitToLetters = new HashMap<>();\\n    private List<String> resultList = new ArrayList<>();\\n\\n    public List<String> letterCombinations(String digits) {\\n        if (digits == null || digits.length() == 0) {\\n            return resultList;\\n        }\\n\\n        digitToLetters.put(\\'2\\', \"abc\");\\n        digitToLetters.put(\\'3\\', \"def\");\\n        digitToLetters.put(\\'4\\', \"ghi\");\\n        digitToLetters.put(\\'5\\', \"jkl\");\\n        digitToLetters.put(\\'6\\', \"mno\");\\n        digitToLetters.put(\\'7\\', \"pqrs\");\\n        digitToLetters.put(\\'8\\', \"tuv\");\\n        digitToLetters.put(\\'9\\', \"wxyz\");\\n\\n        generateCombinations(digits, 0, new StringBuilder());\\n\\n        return resultList;\\n\\n\\n    }\\n\\n\\n    private void generateCombinations(String digits, int currentIndex, StringBuilder currentCombination) {\\n        if (currentIndex == digits.length()) {\\n            resultList.add(currentCombination.toString());\\n            return;\\n        }\\n\\n        char currentDigit = digits.charAt(currentIndex);\\n        String letterOptions = digitToLetters.get(currentDigit);\\n\\n        if (letterOptions != null) {\\n            for (int i = 0; i < letterOptions.length(); i++) {\\n                char letter = letterOptions.charAt(i);\\n                currentCombination.append(letter);\\n                generateCombinations(digits, currentIndex + 1, currentCombination);\\n                currentCombination.deleteCharAt(currentCombination.length() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802198,
                "title": "python-backtracking-time-complexity",
                "content": "\\n```\\nclass Solution:\\n    MAPPING = (\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\")\\n\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        def helper(k, mnemonic):\\n\\t\\t\\t# base case\\n            if k == len(digits):\\n                result.append(\"\".join(mnemonic))\\n                return\\n\\n            for c in self.MAPPING[int(digits[k])]:\\n\\t\\t\\t\\t# make choice\\n                mnemonic.append(c)\\n\\t\\t\\t\\t# explore space\\n                helper(k + 1, mnemonic)\\n\\t\\t\\t\\t# undo choice\\n                mnemonic.pop()\\n\\n        if not digits:\\n            return []\\n\\n        result = []\\n        helper(0, [])\\n        return result\\n\\n```\\n\\nSince there are no more than 4 possible characters for each digit, the number of recursive calls, `T(n)`, satisfies `T(n) < 4T(n - 1)`, where `n` is the number of digits in the number. This solves to `T(n) = O(4^n)`.\\nEach base case entails making a copy of a string and adding it to the result. Since each such string has length `n`, each base case takes time `O(n)`. Therefore, the time complexity is `O(n * 4^n)`.\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    MAPPING = (\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\")\\n\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        def helper(k, mnemonic):\\n\\t\\t\\t# base case\\n            if k == len(digits):\\n                result.append(\"\".join(mnemonic))\\n                return\\n\\n            for c in self.MAPPING[int(digits[k])]:\\n\\t\\t\\t\\t# make choice\\n                mnemonic.append(c)\\n\\t\\t\\t\\t# explore space\\n                helper(k + 1, mnemonic)\\n\\t\\t\\t\\t# undo choice\\n                mnemonic.pop()\\n\\n        if not digits:\\n            return []\\n\\n        result = []\\n        helper(0, [])\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188125,
                "title": "python-dfs",
                "content": "    def letterCombinations(self, digits):\\n        d = {\"2\":\"abc\", \"3\":\"def\", \"4\":\"ghi\", \"5\":\"jkl\", \"6\":\"mno\", \"7\":\"pqrs\", \"8\":\"tuv\", \"9\":\"wxyz\"}\\n        if not digits:\\n            return []\\n        \\n        res = []\\n        def dfs(res, index, path):\\n            if len(path)==len(digits):\\n                res.append(path)\\n                return\\n            else:\\n                for c in d[digits[index]]:\\n                    dfs(res, index+1, path + c)\\n        dfs(res, 0, \"\")\\n        return res",
                "solutionTags": [],
                "code": "    def letterCombinations(self, digits):\\n        d = {\"2\":\"abc\", \"3\":\"def\", \"4\":\"ghi\", \"5\":\"jkl\", \"6\":\"mno\", \"7\":\"pqrs\", \"8\":\"tuv\", \"9\":\"wxyz\"}\\n        if not digits:\\n            return []\\n        \\n        res = []\\n        def dfs(res, index, path):\\n            if len(path)==len(digits):\\n                res.append(path)\\n                return\\n            else:\\n                for c in d[digits[index]]:\\n                    dfs(res, index+1, path + c)\\n        dfs(res, 0, \"\")\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 8339,
                "title": "concise-python-solution",
                "content": "Is this considered pythonic?\\n\\n     class Solution(object):\\n      def letterCombinations(self, digits):\\n        if not digits:\\n            return []\\n        results = ['']\\n        map = {'2':'abc', '3':'def', '4':'ghi', '5':'jkl', '6':'mno', '7':'pqrs', '8':'tuv', '9':'wxyz'}\\n        \\n        for digit in digits:\\n            results = [result+d for result in results for d in map[digit]]\\n            \\n        return results",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n      def letterCombinations(self, digits):\\n        if not digits:\\n            return []\\n        results = ['']\\n        map = {'2':'abc', '3':'def', '4':'ghi', '5':'jkl', '6':'mno', '7':'pqrs', '8':'tuv', '9':'wxyz'}",
                "codeTag": "Java"
            },
            {
                "id": 2654034,
                "title": "python-solution",
                "content": "![image](https://assets.leetcode.com/users/images/e84ba3c4-bba1-4c55-a382-68de245e6a03_1664778599.2224832.png)\\n```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n        letters = [\\n            None,\\n            None,\\n            \"abc\",\\n            \"def\",\\n            \"ghi\",\\n            \"jkl\",\\n            \"mno\",\\n            \"pqrs\",\\n            \"tuv\",\\n            \"wxyz\"\\n        ]\\n        iterables = list(letters[int(n)] for n in digits)\\n        return [\\'\\'.join(x) for x in product(*iterables)] \\n```\\nMore LeetCode solutions of mine at https://github.com/aurimas13/SolutionsToProblems\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n        letters = [\\n            None,\\n            None,\\n            \"abc\",\\n            \"def\",\\n            \"ghi\",\\n            \"jkl\",\\n            \"mno\",\\n            \"pqrs\",\\n            \"tuv\",\\n            \"wxyz\"\\n        ]\\n        iterables = list(letters[int(n)] for n in digits)\\n        return [\\'\\'.join(x) for x in product(*iterables)] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510997,
                "title": "javascript-98-faster-solution",
                "content": "```javascript\\nlet alphabet = {\\n  \\'2\\': \\'abc\\',\\n  \\'3\\': \\'def\\',\\n  \\'4\\': \\'ghi\\',\\n  \\'5\\': \\'jkl\\',\\n  \\'6\\': \\'mno\\',\\n  \\'7\\': \\'pqrs\\',\\n  \\'8\\': \\'tuv\\',\\n  \\'9\\': \\'wxyz\\'\\n}\\n\\nfunction permute(permutations, letters) {\\n  let result = []\\n  \\n  for (let letter of letters) {\\n    for (let permutation of permutations) {\\n      result.push(permutation + letter)\\n    }\\n  }\\n  \\n  return result\\n}\\n\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nfunction letterCombinations(digits) {\\n  if (digits.length === 0) {\\n    return []\\n  }\\n  \\n  return digits.split(\\'\\').reduce((previous, current) => {\\n    return permute(previous, alphabet[current])\\n  }, [\\'\\'])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nlet alphabet = {\\n  \\'2\\': \\'abc\\',\\n  \\'3\\': \\'def\\',\\n  \\'4\\': \\'ghi\\',\\n  \\'5\\': \\'jkl\\',\\n  \\'6\\': \\'mno\\',\\n  \\'7\\': \\'pqrs\\',\\n  \\'8\\': \\'tuv\\',\\n  \\'9\\': \\'wxyz\\'\\n}\\n\\nfunction permute(permutations, letters) {\\n  let result = []\\n  \\n  for (let letter of letters) {\\n    for (let permutation of permutations) {\\n      result.push(permutation + letter)\\n    }\\n  }\\n  \\n  return result\\n}\\n\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nfunction letterCombinations(digits) {\\n  if (digits.length === 0) {\\n    return []\\n  }\\n  \\n  return digits.split(\\'\\').reduce((previous, current) => {\\n    return permute(previous, alphabet[current])\\n  }, [\\'\\'])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2020868,
                "title": "c-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.size() == 0) return ans;\\n        else if(digits.size() == 1){\\n            if(digits[0] == \\'2\\'){\\n                return {\"a\", \"b\", \"c\"};\\n            }\\n            else if(digits[0] == \\'3\\'){\\n                return {\"d\", \"e\", \"f\"};\\n            }\\n            else if(digits[0] == \\'4\\'){\\n                return {\"g\", \"h\", \"i\"};\\n            }\\n            else if(digits[0] == \\'5\\'){\\n                return {\"j\", \"k\", \"l\"};\\n            }\\n            else if(digits[0] == \\'6\\'){\\n                return {\"m\", \"n\", \"o\"};\\n            }\\n            else if(digits[0] == \\'7\\'){\\n                return {\"p\", \"q\", \"r\", \"s\"};\\n            }\\n            else if(digits[0] == \\'8\\'){\\n                return {\"t\", \"u\", \"v\"};\\n            }\\n            else if(digits[0] == \\'9\\'){\\n                return {\"w\", \"x\", \"y\", \"z\"};\\n            }\\n        }\\n        else if(digits.size() > 1){\\n            vector<string> p1 = letterCombinations(digits.substr(0, 1));\\n            vector<string> p2 = letterCombinations(digits.substr(1, digits.size()-1));\\n            for(int i = 0; i < p1.size(); i++)\\n                for(int j = 0; j < p2.size(); j++)\\n                    ans.push_back(p1[i] + p2[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.size() == 0) return ans;\\n        else if(digits.size() == 1){\\n            if(digits[0] == \\'2\\'){\\n                return {\"a\", \"b\", \"c\"};\\n            }\\n            else if(digits[0] == \\'3\\'){\\n                return {\"d\", \"e\", \"f\"};\\n            }\\n            else if(digits[0] == \\'4\\'){\\n                return {\"g\", \"h\", \"i\"};\\n            }\\n            else if(digits[0] == \\'5\\'){\\n                return {\"j\", \"k\", \"l\"};\\n            }\\n            else if(digits[0] == \\'6\\'){\\n                return {\"m\", \"n\", \"o\"};\\n            }\\n            else if(digits[0] == \\'7\\'){\\n                return {\"p\", \"q\", \"r\", \"s\"};\\n            }\\n            else if(digits[0] == \\'8\\'){\\n                return {\"t\", \"u\", \"v\"};\\n            }\\n            else if(digits[0] == \\'9\\'){\\n                return {\"w\", \"x\", \"y\", \"z\"};\\n            }\\n        }\\n        else if(digits.size() > 1){\\n            vector<string> p1 = letterCombinations(digits.substr(0, 1));\\n            vector<string> p2 = letterCombinations(digits.substr(1, digits.size()-1));\\n            for(int i = 0; i < p1.size(); i++)\\n                for(int j = 0; j < p2.size(); j++)\\n                    ans.push_back(p1[i] + p2[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139938,
                "title": "clear-and-simple-explanation-with-intuition-100-faster",
                "content": "**Intuition:** Since we are asked to calculate all the possible combination of letters , hence we have to use backtracking\\n\\n**Concept:** In every backtracking problem , there are two things to keep in mind , which we will explore here as well :\\n*  Base Case: Every problem of backtracking has some base case which tells us at which point we have to stop with the recursion process. In our case, when we have iterated through every element of digits i.e. `index=digits.length()`  we stop with the recursion for that case (because `index` points to letter in digits and this means that we have gone through every possible combination for that letter) and hence we stop with recursion.\\n\\n*   Conditions: There is just one thing to keep in mind here:\\n   Before proceeding to the next letter in `digits`, we have to make sure that every combination generated with `digits[index]` has length equal to `digits.length()` . If we dont,  it would mean that some combination was not considered for that particular letter which would raise error i.e.\\n\\t   `letter_combination[index].length()=digits.length()`\\n\\t\\t\\nAnd thats it!!! Keeping these two things in mind here is the code: \\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string>result;\\n    void helper(string digits,int index,string current)\\n    {\\n         vector<string>v= {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};   // to generate string for that index\\n        if(index==digits.length()) //base case\\n        {\\n            result.push_back(current);\\n            return;\\n        }\\n        string s=v[digits[index]-\\'0\\'];\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\t\\t\\t // If some letter remaining to consider, consider that and generate the combination or go to base case and end recursion for that letter\\n            helper(digits,index+1,current+s[i]);\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\")  return {};\\n        helper(digits,0,\"\");\\n        return result; //return answer\\n    }\\n};\\n```\\n\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you like, please **UPVOTE**\\nHappy Coding :))",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>result;\\n    void helper(string digits,int index,string current)\\n    {\\n         vector<string>v= {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};   // to generate string for that index\\n        if(index==digits.length()) //base case\\n        {\\n            result.push_back(current);\\n            return;\\n        }\\n        string s=v[digits[index]-\\'0\\'];\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\t\\t\\t // If some letter remaining to consider, consider that and generate the combination or go to base case and end recursion for that letter\\n            helper(digits,index+1,current+s[i]);\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\")  return {};\\n        helper(digits,0,\"\");\\n        return result; //return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137366,
                "title": "c-easy-understanding-solution",
                "content": "The question is quiet easy as it needs only dfs movement in 4 dirs with some base condition & restrictions on boundary cases.\\n\\n```\\n    vector<string> ans;\\n     map<int,string> m  { {2,\"abc\"},{3,\"def\"},{4,\"ghi\"},{5,\"jkl\"},{6,\"mno\"},{7,\"pqrs\"},{8,\"tuv\"},                               {9,\"wxyz\"}\\n                     };\\n    \\n    void dfs(string d,string current){\\n        \\n        if(d.length()==0){\\n           ans.push_back(current);\\n            return;\\n        }\\n        \\n        auto id = m.find(d[0]-\\'0\\');\\n        \\n        for(int i=0;i<id->second.length();i++)\\n            dfs(d.substr(1),current+(id->second)[i]);\\n        \\n        return;\\n        \\n    }\\n    \\n    vector<string> letterCombinations(string d) {\\n        int n = d.length();\\n        \\n        if(n==0) return ans;\\n        \\n        dfs(d,\"\");\\n        \\n        return ans;\\n    }\\n```\\n\\n\\n\\n# ***HAPPY CODING. PLEASE UPVOTE***\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    vector<string> ans;\\n     map<int,string> m  { {2,\"abc\"},{3,\"def\"},{4,\"ghi\"},{5,\"jkl\"},{6,\"mno\"},{7,\"pqrs\"},{8,\"tuv\"},                               {9,\"wxyz\"}\\n                     };\\n    \\n    void dfs(string d,string current){\\n        \\n        if(d.length()==0){\\n           ans.push_back(current);\\n            return;\\n        }\\n        \\n        auto id = m.find(d[0]-\\'0\\');\\n        \\n        for(int i=0;i<id->second.length();i++)\\n            dfs(d.substr(1),current+(id->second)[i]);\\n        \\n        return;\\n        \\n    }\\n    \\n    vector<string> letterCombinations(string d) {\\n        int n = d.length();\\n        \\n        if(n==0) return ans;\\n        \\n        dfs(d,\"\");\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1899608,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func letterCombinations(_ digits: String) -> [String] {\\n        guard digits.count > 0 else { return [] }\\n        var res: [String] = []\\n        let map: [Character: [Character]] = [\\n            \"2\": [\"a\", \"b\", \"c\"],\\n            \"3\": [\"d\", \"e\", \"f\"],\\n            \"4\": [\"g\", \"h\", \"i\"],\\n            \"5\": [\"j\", \"k\", \"l\"],\\n            \"6\": [\"m\", \"n\", \"o\"],\\n            \"7\": [\"p\", \"q\", \"r\", \"s\"],\\n            \"8\": [\"t\", \"u\", \"v\"],\\n            \"9\": [\"w\", \"x\", \"y\", \"z\"]\\n        ]\\n\\n\\n        func backtrack(_ path: [Character], _ input: [Character]) {\\n            if path.count >= digits.count { res.append(String(path)); return }\\n            let index = path.count\\n            let digit = input[index]\\n            var path = path   \\n            for c in map[digit]! {\\n                path.append(c)\\n                backtrack(path, input)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n\\n        backtrack([], Array(digits))\\n\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func letterCombinations(_ digits: String) -> [String] {\\n        guard digits.count > 0 else { return [] }\\n        var res: [String] = []\\n        let map: [Character: [Character]] = [\\n            \"2\": [\"a\", \"b\", \"c\"],\\n            \"3\": [\"d\", \"e\", \"f\"],\\n            \"4\": [\"g\", \"h\", \"i\"],\\n            \"5\": [\"j\", \"k\", \"l\"],\\n            \"6\": [\"m\", \"n\", \"o\"],\\n            \"7\": [\"p\", \"q\", \"r\", \"s\"],\\n            \"8\": [\"t\", \"u\", \"v\"],\\n            \"9\": [\"w\", \"x\", \"y\", \"z\"]\\n        ]\\n\\n\\n        func backtrack(_ path: [Character], _ input: [Character]) {\\n            if path.count >= digits.count { res.append(String(path)); return }\\n            let index = path.count\\n            let digit = input[index]\\n            var path = path   \\n            for c in map[digit]! {\\n                path.append(c)\\n                backtrack(path, input)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n\\n        backtrack([], Array(digits))\\n\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931466,
                "title": "100-faster-runtime-easy-javascript-solution-with-explanation",
                "content": "Javascript solution \\n\\n```Runtime: 56 ms, faster than 100.00% of JavaScript online submissions for Letter Combinations of a Phone Number.```\\n\\nGo one character at a time. Create helper functions, (1) for getting you the alphabets list and (2) for appending characters to a list. \\n\\nIf you have a string that says, [\\'a\\', \\'b\\', \\'c\\'], can you write a function that will append [\\'d\\', \\'e\\', \\'h\\'] to this one at a time? \\n\\nIt becomes easy once we break it down. \\n1. Can you append ONE CHARACTER at the end of a string? Oh yes! \\n1. Can you append ONE CHARACTER at the end of a LIST of Strings? Oh yes! \\n1. Can you do this 4 times? Oh yes, I have a helper function just for this. \\n1. \\nLet\\'s go, source code: \\n\\n```\\nvar letterCombinations = function(digits){\\n    let result = [\"\"];\\n    if(!digits) return [];  //edge case 1: empty string input\\n    \\n\\t/*helper function for phonebook. Don\\'t waste a Set or array object to store these constants*/\\n    const getLettersForNum = function(number){\\n        switch(number){\\n          case \"2\": return [\\'a\\',\\'b\\',\\'c\\'];\\n          case \"3\": return [\\'d\\',\\'e\\',\\'f\\'];\\n          case \"4\": return [\\'g\\',\\'h\\',\\'i\\'];\\n          case \"5\": return [\\'j\\',\\'k\\',\\'l\\'];\\n          case \"6\": return [\\'m\\',\\'n\\',\\'o\\'];\\n          case \"7\": return [\\'p\\',\\'q\\',\\'r\\',\\'s\\'];\\n          case \"8\": return [\\'t\\',\\'u\\',\\'v\\'];\\n          case \"9\": return [\\'w\\',\\'x\\',\\'y\\',\\'z\\'];\\n          default : return [\\'\\']; //May be throw an error? \\n        }\\n    }\\n    /*our cute little helper function. All it does? just append one character at the end.*/\\n\\tconst getPermutations = function(permutations, letters){\\n          let result = [];\\n          letters.forEach(L => {\\n               permutations.forEach(P => {\\n                    result.push(P + L);\\n                 });\\n             });\\n             return result;\\n    }\\n    \\n    //for each digit, add to existing permutations\\n    digits.split(\"\").forEach( (d) =>{\\n          result = getPermutations(result, getLettersForNum(d) );   \\n    });\\n       \\n    return result;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```Runtime: 56 ms, faster than 100.00% of JavaScript online submissions for Letter Combinations of a Phone Number.```\n```\\nvar letterCombinations = function(digits){\\n    let result = [\"\"];\\n    if(!digits) return [];  //edge case 1: empty string input\\n    \\n\\t/*helper function for phonebook. Don\\'t waste a Set or array object to store these constants*/\\n    const getLettersForNum = function(number){\\n        switch(number){\\n          case \"2\": return [\\'a\\',\\'b\\',\\'c\\'];\\n          case \"3\": return [\\'d\\',\\'e\\',\\'f\\'];\\n          case \"4\": return [\\'g\\',\\'h\\',\\'i\\'];\\n          case \"5\": return [\\'j\\',\\'k\\',\\'l\\'];\\n          case \"6\": return [\\'m\\',\\'n\\',\\'o\\'];\\n          case \"7\": return [\\'p\\',\\'q\\',\\'r\\',\\'s\\'];\\n          case \"8\": return [\\'t\\',\\'u\\',\\'v\\'];\\n          case \"9\": return [\\'w\\',\\'x\\',\\'y\\',\\'z\\'];\\n          default : return [\\'\\']; //May be throw an error? \\n        }\\n    }\\n    /*our cute little helper function. All it does? just append one character at the end.*/\\n\\tconst getPermutations = function(permutations, letters){\\n          let result = [];\\n          letters.forEach(L => {\\n               permutations.forEach(P => {\\n                    result.push(P + L);\\n                 });\\n             });\\n             return result;\\n    }\\n    \\n    //for each digit, add to existing permutations\\n    digits.split(\"\").forEach( (d) =>{\\n          result = getPermutations(result, getLettersForNum(d) );   \\n    });\\n       \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8392,
                "title": "3-lines-in-ruby",
                "content": "    def letter_combinations(digits)\\n      map = \"- - abc def ghi jkl mno pqrs tuv wxyz\".split\\n      charsets = digits.chars.map { |d| map[d.to_i].chars }\\n      digits == \"\" ? [] : [''].product(*charsets).map(&:join)\\n    end\\n\\nOr as ugly one-liner, just for fun:\\n    \\n    def letter_combinations(digits)\\n      digits == \"\" ? [] : [''].product(*digits.chars.map { |d| \"- - abc def ghi jkl mno pqrs tuv wxyz\".split[d.to_i].chars }).map(&:join)\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "    def letter_combinations(digits)\\n      map = \"- - abc def ghi jkl mno pqrs tuv wxyz\".split\\n      charsets = digits.chars.map { |d| map[d.to_i].chars }\\n      digits == \"\" ? [] : [''].product(*charsets).map(&:join)\\n    end\\n\\nOr as ugly one-liner, just for fun:\\n    \\n    def letter_combinations(digits)\\n      digits == \"\" ? [] : [''].product(*digits.chars.map { |d| \"- - abc def ghi jkl mno pqrs tuv wxyz\".split[d.to_i].chars }).map(&:join)\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 2615698,
                "title": "easy-solution-using-recursion-backtracking-hashmap",
                "content": "**just take an example(\"23\") and make tree **\\n![image](https://assets.leetcode.com/users/images/c4360b74-4274-46d6-9a71-e6be26e1d42b_1663972016.688664.jpeg)\\nI think the above tree diagram make sense for you \\nhere is my code -->\\n\\n    public void backtrack(String s , int idx , HashMap<Character,String> map , StringBuilder sb , List<String> ans){\\n        if(idx==s.length()){ // for exmaple for \"23\" has length 2 to jaise hi 2 index complete ho jayega waise hi waise hi hm return kr jayenge.\\n            ans.add(sb.toString());\\n            return;\\n        }\\n        String str = map.get(s.charAt(idx)); // for eg for \"23\" has two index indx[0] will give the value \"abc\" which we store in str.\\n        for(int i=0;i<str.length();i++){ // then we run this loop for string \"abc\" \\n            sb.append(str.charAt(i)); // we add every char of \"abc\" in string builder for i=0 we add \"a\" in sb.\\n            backtrack(s,idx+1,map,sb,ans); // we run this funtion we have to check every other possibilities for \"a\". for eg -> \"ad\",\"ae\" and etc.\\n            sb.deleteCharAt(sb.length()-1); // when we got first ans (\"ad\") then we remove d form \"ad\" becoz we also have to check all other possibilities of a (e.g - \"ae\",\"af\" etc).\\n        }\\n    }\\n    public List<String> letterCombinations(String digits) {\\n        ArrayList<String> list = new ArrayList<>();\\n        if(digits.length()==0) return list;\\n        HashMap<Character,String> map = new HashMap<>();\\n        map.put(\\'2\\',\"abc\");\\n        map.put(\\'3\\',\"def\");\\n        map.put(\\'4\\',\"ghi\");\\n        map.put(\\'5\\',\"jkl\");\\n        map.put(\\'6\\',\"mno\");\\n        map.put(\\'7\\',\"pqrs\");\\n        map.put(\\'8\\',\"tuv\");\\n        map.put(\\'9\\',\"wxyz\");\\n        backtrack(digits,0,map,new StringBuilder(),list);\\n        return list;\\n    }\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "**just take an example(\"23\") and make tree **\\n![image](https://assets.leetcode.com/users/images/c4360b74-4274-46d6-9a71-e6be26e1d42b_1663972016.688664.jpeg)\\nI think the above tree diagram make sense for you \\nhere is my code -->\\n\\n    public void backtrack(String s , int idx , HashMap<Character,String> map , StringBuilder sb , List<String> ans){\\n        if(idx==s.length()){ // for exmaple for \"23\" has length 2 to jaise hi 2 index complete ho jayega waise hi waise hi hm return kr jayenge.\\n            ans.add(sb.toString());\\n            return;\\n        }\\n        String str = map.get(s.charAt(idx)); // for eg for \"23\" has two index indx[0] will give the value \"abc\" which we store in str.\\n        for(int i=0;i<str.length();i++){ // then we run this loop for string \"abc\" \\n            sb.append(str.charAt(i)); // we add every char of \"abc\" in string builder for i=0 we add \"a\" in sb.\\n            backtrack(s,idx+1,map,sb,ans); // we run this funtion we have to check every other possibilities for \"a\". for eg -> \"ad\",\"ae\" and etc.\\n            sb.deleteCharAt(sb.length()-1); // when we got first ans (\"ad\") then we remove d form \"ad\" becoz we also have to check all other possibilities of a (e.g - \"ae\",\"af\" etc).\\n        }\\n    }\\n    public List<String> letterCombinations(String digits) {\\n        ArrayList<String> list = new ArrayList<>();\\n        if(digits.length()==0) return list;\\n        HashMap<Character,String> map = new HashMap<>();\\n        map.put(\\'2\\',\"abc\");\\n        map.put(\\'3\\',\"def\");\\n        map.put(\\'4\\',\"ghi\");\\n        map.put(\\'5\\',\"jkl\");\\n        map.put(\\'6\\',\"mno\");\\n        map.put(\\'7\\',\"pqrs\");\\n        map.put(\\'8\\',\"tuv\");\\n        map.put(\\'9\\',\"wxyz\");\\n        backtrack(digits,0,map,new StringBuilder(),list);\\n        return list;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2045937,
                "title": "js-solution-beats-99-22",
                "content": "To understand this solution you may need to practice backtracking(much easier than it sounds).\\nIs simply itterrates over posible solutions(starts from an empty solution) if they candidate length(string length) is equal to our target(number of keys pressed) we collected it, if not we will itterate by adding more letters. \\n\\nIf you discovered something new or found this solution interesting. Please consider up voting.\\n```\\n\\nvar letterCombinations = function (digits) {\\n  if (!digits.length) return [];\\n\\n  const digitsMap = {\\n    2: [\\'a\\', \\'b\\', \\'c\\'],\\n    3: [\\'d\\', \\'e\\', \\'f\\'],\\n    4: [\\'g\\', \\'h\\', \\'i\\'],\\n    5: [\\'j\\', \\'k\\', \\'l\\'],\\n    6: [\\'m\\', \\'n\\', \\'o\\'],\\n    7: [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n    8: [\\'t\\', \\'u\\', \\'v\\'],\\n    9: [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n  };\\n\\n  let res = [];\\n\\n  function backtrack(str, index) {\\n    if (str.length == digits.length) {\\n      res.push(str);\\n    } else {\\n      const chars = digitsMap[digits[index]];\\n      for (let char of chars) {\\n        backtrack(str + char, index + 1);\\n      }\\n    }\\n  }\\n\\n  backtrack(\\'\\', 0);\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\nvar letterCombinations = function (digits) {\\n  if (!digits.length) return [];\\n\\n  const digitsMap = {\\n    2: [\\'a\\', \\'b\\', \\'c\\'],\\n    3: [\\'d\\', \\'e\\', \\'f\\'],\\n    4: [\\'g\\', \\'h\\', \\'i\\'],\\n    5: [\\'j\\', \\'k\\', \\'l\\'],\\n    6: [\\'m\\', \\'n\\', \\'o\\'],\\n    7: [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n    8: [\\'t\\', \\'u\\', \\'v\\'],\\n    9: [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n  };\\n\\n  let res = [];\\n\\n  function backtrack(str, index) {\\n    if (str.length == digits.length) {\\n      res.push(str);\\n    } else {\\n      const chars = digitsMap[digits[index]];\\n      for (let char of chars) {\\n        backtrack(str + char, index + 1);\\n      }\\n    }\\n  }\\n\\n  backtrack(\\'\\', 0);\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1193437,
                "title": "simple-python-solution-with-two-nested-for-loops",
                "content": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        ddict = {\\'2\\':\\'abc\\', \\'3\\':\\'def\\', \\'4\\':\\'ghi\\', \\'5\\':\\'jkl\\',\\n                 \\'6\\':\\'mno\\', \\'7\\':\\'pqrs\\', \\'8\\':\\'tuv\\', \\'9\\':\\'wxyz\\'}\\n        if len(digits) == 0:\\n            oldlist = []\\n        else:\\n            oldlist = [\\'\\']\\n            for d in digits:\\n                newlist = []\\n                for ss in ddict[d]:\\n                    newlist.extend([s + ss for s in oldlist])\\n                oldlist = newlist\\n        return oldlist\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        ddict = {\\'2\\':\\'abc\\', \\'3\\':\\'def\\', \\'4\\':\\'ghi\\', \\'5\\':\\'jkl\\',\\n                 \\'6\\':\\'mno\\', \\'7\\':\\'pqrs\\', \\'8\\':\\'tuv\\', \\'9\\':\\'wxyz\\'}\\n        if len(digits) == 0:\\n            oldlist = []\\n        else:\\n            oldlist = [\\'\\']\\n            for d in digits:\\n                newlist = []\\n                for ss in ddict[d]:\\n                    newlist.extend([s + ss for s in oldlist])\\n                oldlist = newlist\\n        return oldlist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798868,
                "title": "java-backtracking-with-some-comments-0ms-38-memory-usage",
                "content": "```\\n// backtrack\\n/*\\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\\nNote that 1 does not map to any letters.\\n\\nExample:\\nInput: \"23\"\\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\\n*/\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        // build up the HashMap Charater to String\\n        Map<Character, String> phone = new HashMap<Character, String>() {{\\n            put(\\'2\\', \"abc\");\\n            put(\\'3\\', \"def\");\\n            put(\\'4\\', \"ghi\");\\n            put(\\'5\\', \"jkl\");\\n            put(\\'6\\', \"mno\");\\n            put(\\'7\\', \"pqrs\");\\n            put(\\'8\\', \"tuv\");\\n            put(\\'9\\', \"wxyz\");\\n          }};\\n        List<String> ls = new ArrayList<>();\\n        // if \"digits\" is empty return empty list\\n        if(digits.length() == 0) {\\n            return ls;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        backtrack(sb, digits, ls, phone, 0);\\n        return ls;\\n    }\\n    \\n    public void backtrack(StringBuilder sb, String digits, List<String> ls, Map<Character, String> phone, int start) {\\n        if(sb.length() == digits.length()) {\\n            ls.add(sb.toString());\\n            return;\\n        }\\n        // we have to use \\'start\\' to ensure we will go to next character of digit\\n        for(int i = start; i < digits.length(); i++) {\\n            // get the character\\'s corresponding String from the map\\n            String s = phone.get(digits.charAt(i));\\n            // loop through all the character in specific String in Map\\n            for(int j = 0; j < s.length(); j++) {\\n                sb.append(s.charAt(j));\\n                backtrack(sb, digits, ls, phone, i + 1);\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\n// backtrack\\n/*\\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\\nNote that 1 does not map to any letters.\\n\\nExample:\\nInput: \"23\"\\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\\n*/\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        // build up the HashMap Charater to String\\n        Map<Character, String> phone = new HashMap<Character, String>() {{\\n            put(\\'2\\', \"abc\");\\n            put(\\'3\\', \"def\");\\n            put(\\'4\\', \"ghi\");\\n            put(\\'5\\', \"jkl\");\\n            put(\\'6\\', \"mno\");\\n            put(\\'7\\', \"pqrs\");\\n            put(\\'8\\', \"tuv\");\\n            put(\\'9\\', \"wxyz\");\\n          }};\\n        List<String> ls = new ArrayList<>();\\n        // if \"digits\" is empty return empty list\\n        if(digits.length() == 0) {\\n            return ls;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        backtrack(sb, digits, ls, phone, 0);\\n        return ls;\\n    }\\n    \\n    public void backtrack(StringBuilder sb, String digits, List<String> ls, Map<Character, String> phone, int start) {\\n        if(sb.length() == digits.length()) {\\n            ls.add(sb.toString());\\n            return;\\n        }\\n        // we have to use \\'start\\' to ensure we will go to next character of digit\\n        for(int i = start; i < digits.length(); i++) {\\n            // get the character\\'s corresponding String from the map\\n            String s = phone.get(digits.charAt(i));\\n            // loop through all the character in specific String in Map\\n            for(int j = 0; j < s.length(); j++) {\\n                sb.append(s.charAt(j));\\n                backtrack(sb, digits, ls, phone, i + 1);\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262920,
                "title": "4ms-pure-c",
                "content": "```\\nchar** letterCombinations(char* digits, int* returnSize) {\\n    int len  = strlen(digits);\\n    if ( !digits || !len ) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    char* array[9] = {\"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    int size = 1, cnt = 0, cur_size = 0, rest_size = 0;\\n    for (int i = 0; i < len; i++) {\\n        size *= strlen(array[digits[i] - \\'1\\']);\\n    }\\n    *returnSize = rest_size = size;\\n    char** ret = (char**) malloc(sizeof(char*) * (*returnSize));\\n    for (int i = 0; i < size; i++) {\\n        ret[i] = (char*) malloc (sizeof(char) * (len+1));\\n    }\\n    for (int i = 0; i < len+1; i++) {\\n        if (i < len) {\\n            cur_size = strlen(array[digits[i] - \\'1\\']);\\n            rest_size /= cur_size;\\n        }\\n        for (int j = 0; j < size; j++) {\\n            if (i == len) {\\n                ret[j][cnt] = \\'\\\\0\\'; \\n            } else {\\n                // every character need rest_size times -> j/rest_size%cur_size\\n                ret[j][cnt] = array[digits[i] - \\'1\\'][j/rest_size%cur_size];\\n            }\\n        } \\n        cnt++;\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar** letterCombinations(char* digits, int* returnSize) {\\n    int len  = strlen(digits);\\n    if ( !digits || !len ) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    char* array[9] = {\"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    int size = 1, cnt = 0, cur_size = 0, rest_size = 0;\\n    for (int i = 0; i < len; i++) {\\n        size *= strlen(array[digits[i] - \\'1\\']);\\n    }\\n    *returnSize = rest_size = size;\\n    char** ret = (char**) malloc(sizeof(char*) * (*returnSize));\\n    for (int i = 0; i < size; i++) {\\n        ret[i] = (char*) malloc (sizeof(char) * (len+1));\\n    }\\n    for (int i = 0; i < len+1; i++) {\\n        if (i < len) {\\n            cur_size = strlen(array[digits[i] - \\'1\\']);\\n            rest_size /= cur_size;\\n        }\\n        for (int j = 0; j < size; j++) {\\n            if (i == len) {\\n                ret[j][cnt] = \\'\\\\0\\'; \\n            } else {\\n                // every character need rest_size times -> j/rest_size%cur_size\\n                ret[j][cnt] = array[digits[i] - \\'1\\'][j/rest_size%cur_size];\\n            }\\n        } \\n        cnt++;\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8177,
                "title": "fast-backtracking-easy-to-understand-with-explanations",
                "content": "   \\n\\n     public class Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<String>();\\n        String[][] map={{},{},{\"a\",\"c\",\"b\"},{\"d\",\"e\",\"f\"},{\"g\",\"h\",\"i\"},{\"j\",\"k\",\"l\"},{\"m\",\"n\",\"o\"},{\"p\",\"q\",\"r\",\"s\"},,{\"t\",\"u\",\"v\"},{\"w\",\"x\",\"y\",\"z\"}};\\n        String single=\"\";\\n        if(digits == null || digits.length() == 0){                 //corner case;\\n            return result;\\n        }\\n        helper(result, single, digits, map,0);                     //go into recursive\\n        return result;\\n    }\\n    private void helper(List<String> result, String single, String digits, String[][] map,int start){\\n        if (start >= digits.length()){                                     // go out condition\\n            result.add(single);\\n            return;\\n        }\\n        int index = digits.charAt(start)-'0';\\n        String[] current = map[index];                                  //get letter collection of current digit\\n        for(int i = 0; i < current.length; i++){\\n            single = single + current[i];                                //add one letter to current prefix\\n            helper(result, single, digits, map, start + 1);    //go recursive\\n            single=single.substring(0,single.length()-1);    //remove the last digit, prepare to change to another letter\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<String>();\\n        String[][] map={{}",
                "codeTag": "Java"
            },
            {
                "id": 8207,
                "title": "concise-15-line-java-iterative-solution-very-straight-forward-with-brief-explanation",
                "content": "Assume we have current answer {x1,x2,x3,x4} in the list and there is one more digit to go. The last digit has two choices: \"a\" and \"b\"; Then what we do is to first assign \"a\" to each element in the current answer list and put we get into a new list, {x1a,x2a,x3a,x4a}. Then assign \"b\" and we get {x1a,x2a,x3a,x4a,x1b,x2b,x3b,x4b}. That's the basic operation for one digit.\\nStarting from an empty list, do the previous steps digit by digit. And your answer will finally come out.\\n\\n    public List<String> letterCombinations(String digits) {\\n\\t\\tString[] data = new String[] { \" \", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\\n\\t\\t\\t\\t\"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n\\t\\tList<String> ans = new ArrayList<String>();\\n\\t\\tfor (int i = 0; i < digits.length(); i++) {\\n\\t\\t\\tchar[] c = data[digits.charAt(i) - '0'].toCharArray();\\n\\t\\t\\tList<String> sub = new ArrayList<String>();\\n\\t\\t\\tfor (int j = 0; j < c.length; j++) {\\n\\t\\t\\t\\tif (ans.isEmpty())\\n\\t\\t\\t\\t\\tans.add(\"\");\\n\\t\\t\\t\\tfor (String s : ans) {\\n\\t\\t\\t\\t\\tsub.add(s + c[j]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans = sub;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\t}",
                "solutionTags": [],
                "code": "Assume we have current answer {x1,x2,x3,x4} in the list and there is one more digit to go. The last digit has two choices: \"a\" and \"b\"; Then what we do is to first assign \"a\" to each element in the current answer list and put we get into a new list, {x1a,x2a,x3a,x4a}. Then assign \"b\" and we get {x1a,x2a,x3a,x4a,x1b,x2b,x3b,x4b}. That's the basic operation for one digit.\\nStarting from an empty list, do the previous steps digit by digit. And your answer will finally come out.\\n\\n    public List<String> letterCombinations(String digits) {\\n\\t\\tString[] data = new String[] { \" \", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\\n\\t\\t\\t\\t\"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\\n\\t\\tList<String> ans = new ArrayList<String>();\\n\\t\\tfor (int i = 0; i < digits.length(); i++) {\\n\\t\\t\\tchar[] c = data[digits.charAt(i) - '0'].toCharArray();\\n\\t\\t\\tList<String> sub = new ArrayList<String>();\\n\\t\\t\\tfor (int j = 0; j < c.length; j++) {\\n\\t\\t\\t\\tif (ans.isEmpty())\\n\\t\\t\\t\\t\\tans.add(\"\");\\n\\t\\t\\t\\tfor (String s : ans) {\\n\\t\\t\\t\\t\\tsub.add(s + c[j]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans = sub;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3857094,
                "title": "c-recursion-day-3",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void generateCombos(int idx, string& digits, string& temp, vector<string>& sol, vector<string>& charMap){\\n        if(idx==digits.length()){\\n            if(temp.length()) sol.push_back(temp);\\n            return;\\n        }\\n        int num=digits[idx]-\\'0\\';\\n        string str=charMap[num];\\n\\n        for(int i=0;i<str.length();i++){\\n            temp.push_back(str[i]);\\n            generateCombos(idx+1, digits, temp, sol, charMap);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        string temp;\\n        vector<string> sol;\\n        vector<string> charMap={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        generateCombos(0, digits, temp, sol, charMap);\\n        return sol;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/7663a3c3-ad6b-460d-abe4-2c0f1797d8f8_1691050595.5224621.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generateCombos(int idx, string& digits, string& temp, vector<string>& sol, vector<string>& charMap){\\n        if(idx==digits.length()){\\n            if(temp.length()) sol.push_back(temp);\\n            return;\\n        }\\n        int num=digits[idx]-\\'0\\';\\n        string str=charMap[num];\\n\\n        for(int i=0;i<str.length();i++){\\n            temp.push_back(str[i]);\\n            generateCombos(idx+1, digits, temp, sol, charMap);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        string temp;\\n        vector<string> sol;\\n        vector<string> charMap={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        generateCombos(0, digits, temp, sol, charMap);\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855505,
                "title": "100-letter-combinations-of-a-phone-number",
                "content": "# Intuition\\nThe problem is to find all possible letter combinations that a given number could represent, as mapped on a telephone\\'s buttons. Big thanks to vanAmsen for interacive video agood for inspiration [17. Letter Combinations of a Phone Number](https://youtu.be/Jobb9YUFUq0) The initial thought is to create a mapping between the digits and their corresponding letters and then use recursion to explore all possible combinations. \\n\\n# Approach\\n1. **Initialize a Mapping**: Create an array mapping the digits from 2 to 9 to their corresponding letters on a telephone\\'s buttons.\\n2. **Base Case**: If the input string `digits` is empty, return an empty list.\\n3. **Define Recursive Function**: Utilize a recursive function `backtrack` that takes the current combination and the next digits to explore.\\n   - **Termination Condition**: If there are no more digits to explore, append the current combination to the result.\\n   - **Exploration**: Iterate through the corresponding letters of the next digit and recursively explore the remaining digits.\\n4. **Result**: Return the collected combinations as the final result.\\n\\n# Complexity\\n- Time complexity: \\\\(O(4^n)\\\\), where \\\\(n\\\\) is the length of the input string. In the worst case, each digit can represent 4 letters, so there will be 4 recursive calls for each digit.\\n- Space complexity: \\\\(O(n)\\\\), where \\\\(n\\\\) is the length of the input string. This accounts for the recursion stack space.\\n\\n# Code\\n``` Go []\\nfunc letterCombinations(digits string) []string {\\n\\tif digits == \"\" {\\n\\t\\treturn []string{}\\n\\t}\\n\\n\\tphoneMap := []string{\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}\\n\\tvar output []string\\n\\n\\tvar backtrack func(combination string, nextDigits string)\\n\\tbacktrack = func(combination string, nextDigits string) {\\n\\t\\tif nextDigits == \"\" {\\n\\t\\t\\toutput = append(output, combination)\\n\\t\\t} else {\\n\\t\\t\\tletters := phoneMap[nextDigits[0]-\\'2\\']\\n\\t\\t\\tfor _, letter := range letters {\\n\\t\\t\\t\\tbacktrack(combination+string(letter), nextDigits[1:])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbacktrack(\"\", digits)\\n\\treturn output\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn letter_combinations(digits: String) -> Vec<String> {\\n        if digits.is_empty() {\\n            return vec![];\\n        }\\n\\n        let phone_map = vec![\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\\n        let mut output = Vec::new();\\n\\n        fn backtrack(combination: String, next_digits: &str, phone_map: &Vec<&str>, output: &mut Vec<String>) {\\n            if next_digits.is_empty() {\\n                output.push(combination);\\n            } else {\\n                let letters = phone_map[next_digits.chars().nth(0).unwrap() as usize - \\'2\\' as usize];\\n                for letter in letters.chars() {\\n                    let new_combination = combination.clone() + &letter.to_string();\\n                    backtrack(new_combination, &next_digits[1..], phone_map, output);\\n                }\\n            }\\n        }\\n\\n        backtrack(String::new(), &digits, &phone_map, &mut output);\\n        output\\n    }\\n}\\n```\\n``` TypeScript []\\nfunction letterCombinations(digits: string): string[] {\\n    if (digits.length === 0) return [];\\n\\n    const phoneMap: string[] = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\\n    const output: string[] = [];\\n\\n    function backtrack(combination: string, nextDigits: string) {\\n        if (nextDigits.length === 0) {\\n            output.push(combination);\\n        } else {\\n            const letters: string = phoneMap[parseInt(nextDigits[0]) - 2];\\n            for (const letter of letters) {\\n                backtrack(combination + letter, nextDigits.slice(1));\\n            }\\n        }\\n    }\\n\\n    backtrack(\"\", digits);\\n    return output;\\n}\\n```\\n``` Ruby []\\n# @param {String} digits\\n# @return {String[]}\\ndef letter_combinations(digits)\\n    return [] if digits.empty?\\n\\n    phone_map = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\\n    output = []\\n\\n    def backtrack(combination, next_digits, phone_map, output)\\n        if next_digits.empty?\\n            output << combination\\n        else\\n            letters = phone_map[next_digits[0].to_i - 2]\\n            letters.each_char do |letter|\\n                backtrack(combination + letter, next_digits[1..], phone_map, output)\\n            end\\n        end\\n    end\\n\\n    backtrack(\"\", digits, phone_map, output)\\n    output\\nend\\n```\\n``` Swift []\\nclass Solution {\\n    func letterCombinations(_ digits: String) -> [String] {\\n        if digits.isEmpty {\\n            return []\\n        }\\n\\n        let phoneMap = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\\n        var output: [String] = []\\n\\n        func backtrack(_ combination: String, _ nextDigits: String) {\\n            if nextDigits.isEmpty {\\n                output.append(combination)\\n            } else {\\n                let letters = phoneMap[Int(String(nextDigits.first!))! - 2]\\n                for letter in letters {\\n                    backtrack(combination + String(letter), String(nextDigits.dropFirst()))\\n                }\\n            }\\n        }\\n\\n        backtrack(\"\", digits)\\n        return output\\n    }\\n}\\n```\\nThis code follows the recursive backtracking approach to find all possible letter combinations, similar to the previous implementations in other languages, and adapts it to Go\\'s syntax and constructs.",
                "solutionTags": [
                    "Ruby",
                    "Swift",
                    "Go",
                    "Rust",
                    "TypeScript"
                ],
                "code": "``` Go []\\nfunc letterCombinations(digits string) []string {\\n\\tif digits == \"\" {\\n\\t\\treturn []string{}\\n\\t}\\n\\n\\tphoneMap := []string{\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}\\n\\tvar output []string\\n\\n\\tvar backtrack func(combination string, nextDigits string)\\n\\tbacktrack = func(combination string, nextDigits string) {\\n\\t\\tif nextDigits == \"\" {\\n\\t\\t\\toutput = append(output, combination)\\n\\t\\t} else {\\n\\t\\t\\tletters := phoneMap[nextDigits[0]-\\'2\\']\\n\\t\\t\\tfor _, letter := range letters {\\n\\t\\t\\t\\tbacktrack(combination+string(letter), nextDigits[1:])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbacktrack(\"\", digits)\\n\\treturn output\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn letter_combinations(digits: String) -> Vec<String> {\\n        if digits.is_empty() {\\n            return vec![];\\n        }\\n\\n        let phone_map = vec![\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\\n        let mut output = Vec::new();\\n\\n        fn backtrack(combination: String, next_digits: &str, phone_map: &Vec<&str>, output: &mut Vec<String>) {\\n            if next_digits.is_empty() {\\n                output.push(combination);\\n            } else {\\n                let letters = phone_map[next_digits.chars().nth(0).unwrap() as usize - \\'2\\' as usize];\\n                for letter in letters.chars() {\\n                    let new_combination = combination.clone() + &letter.to_string();\\n                    backtrack(new_combination, &next_digits[1..], phone_map, output);\\n                }\\n            }\\n        }\\n\\n        backtrack(String::new(), &digits, &phone_map, &mut output);\\n        output\\n    }\\n}\\n```\n``` TypeScript []\\nfunction letterCombinations(digits: string): string[] {\\n    if (digits.length === 0) return [];\\n\\n    const phoneMap: string[] = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\\n    const output: string[] = [];\\n\\n    function backtrack(combination: string, nextDigits: string) {\\n        if (nextDigits.length === 0) {\\n            output.push(combination);\\n        } else {\\n            const letters: string = phoneMap[parseInt(nextDigits[0]) - 2];\\n            for (const letter of letters) {\\n                backtrack(combination + letter, nextDigits.slice(1));\\n            }\\n        }\\n    }\\n\\n    backtrack(\"\", digits);\\n    return output;\\n}\\n```\n``` Ruby []\\n# @param {String} digits\\n# @return {String[]}\\ndef letter_combinations(digits)\\n    return [] if digits.empty?\\n\\n    phone_map = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\\n    output = []\\n\\n    def backtrack(combination, next_digits, phone_map, output)\\n        if next_digits.empty?\\n            output << combination\\n        else\\n            letters = phone_map[next_digits[0].to_i - 2]\\n            letters.each_char do |letter|\\n                backtrack(combination + letter, next_digits[1..], phone_map, output)\\n            end\\n        end\\n    end\\n\\n    backtrack(\"\", digits, phone_map, output)\\n    output\\nend\\n```\n``` Swift []\\nclass Solution {\\n    func letterCombinations(_ digits: String) -> [String] {\\n        if digits.isEmpty {\\n            return []\\n        }\\n\\n        let phoneMap = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\\n        var output: [String] = []\\n\\n        func backtrack(_ combination: String, _ nextDigits: String) {\\n            if nextDigits.isEmpty {\\n                output.append(combination)\\n            } else {\\n                let letters = phoneMap[Int(String(nextDigits.first!))! - 2]\\n                for letter in letters {\\n                    backtrack(combination + String(letter), String(nextDigits.dropFirst()))\\n                }\\n            }\\n        }\\n\\n        backtrack(\"\", digits)\\n        return output\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244849,
                "title": "backtracking-java-0-ms",
                "content": "# Approach\\nBacktracking\\n\\n\\n# Code\\n```\\nclass Solution {\\n    String [] arr = new String[]{\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    public List<String> letterCombinations(String digits) {\\n        List<String> list = new ArrayList<>();\\n        if(digits.length() == 0) return list;\\n        StringBuilder sb = new StringBuilder();\\n        backtrack(list,digits,sb,0);\\n        return list;\\n    }\\n    private void backtrack(List<String> list,String str,StringBuilder sb,int index){\\n        if(sb.length() == str.length()){\\n            list.add(sb.toString());\\n            return;\\n        }\\n        else{\\n            int val = str.charAt(index)-\\'0\\';\\n            for(int i=0;i<arr[val-1].length();i++){\\n                sb.append(arr[val-1].charAt(i));\\n                backtrack(list,str,sb,index+1);\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String [] arr = new String[]{\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    public List<String> letterCombinations(String digits) {\\n        List<String> list = new ArrayList<>();\\n        if(digits.length() == 0) return list;\\n        StringBuilder sb = new StringBuilder();\\n        backtrack(list,digits,sb,0);\\n        return list;\\n    }\\n    private void backtrack(List<String> list,String str,StringBuilder sb,int index){\\n        if(sb.length() == str.length()){\\n            list.add(sb.toString());\\n            return;\\n        }\\n        else{\\n            int val = str.charAt(index)-\\'0\\';\\n            for(int i=0;i<arr[val-1].length();i++){\\n                sb.append(arr[val-1].charAt(i));\\n                backtrack(list,str,sb,index+1);\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022363,
                "title": "c-full-explanation-short-clean-daily-leetcoding-challenge-may-day-9",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    // creating the letter pattern that will help us to map the va\\n    vector<vector<int>> keys = {\\n                                { \\'a\\',\\'b\\',\\'c\\' }, { \\'d\\',\\'e\\',\\'f\\' }, { \\'g\\',\\'h\\',\\'i\\' }, { \\'j\\',\\'k\\',\\'l\\' }, \\n                                { \\'m\\',\\'n\\',\\'o\\' }, { \\'p\\',\\'q\\',\\'r\\',\\'s\\' }, { \\'t\\',\\'u\\',\\'v\\' }, { \\'w\\',\\'x\\',\\'y\\',\\'z\\' }\\n                               };\\n    \\n    // it will store the final answer\\n    vector<string> ans;\\n     \\n    void helper(string digits,vector<string> &ans,int start,int end,string tmp)\\n    {\\n        // if our start reaches to the bound\\n        if(start>=end)\\n        {\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        \\n        // check for the other associative chars with their respective integers\\n        // here we use keys[digits[i]-\\'2\\'] , because we made our keys that start with idx 0 and if we see digit pattern then \\n        // observe that it actuallt start from 2 right so for balancing that we use digits[i]-\\'2\\'\\n        for(char x : keys[digits[start]-\\'2\\'])\\n        {\\n            // call the same helper fundtion by insreasing start count by 1 because we have done woth current now go to second one\\n            // and add current char to tmp because we took the current char and check for its other associatives\\n            helper(digits,ans,start+1,digits.size(),tmp+x);\\n        }\\n    }\\n        \\n    vector<string> letterCombinations(string digits) \\n    {\\n        // if our string is initially empty\\n        if(digits==\"\")\\n            return ans;\\n        \\n        // else call the helper function that will gave all the combinations\\n        helper(digits,ans,0,digits.size(),\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // creating the letter pattern that will help us to map the va\\n    vector<vector<int>> keys = {\\n                                { \\'a\\',\\'b\\',\\'c\\' }, { \\'d\\',\\'e\\',\\'f\\' }, { \\'g\\',\\'h\\',\\'i\\' }, { \\'j\\',\\'k\\',\\'l\\' }, \\n                                { \\'m\\',\\'n\\',\\'o\\' }, { \\'p\\',\\'q\\',\\'r\\',\\'s\\' }, { \\'t\\',\\'u\\',\\'v\\' }, { \\'w\\',\\'x\\',\\'y\\',\\'z\\' }\\n                               };\\n    \\n    // it will store the final answer\\n    vector<string> ans;\\n     \\n    void helper(string digits,vector<string> &ans,int start,int end,string tmp)\\n    {\\n        // if our start reaches to the bound\\n        if(start>=end)\\n        {\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        \\n        // check for the other associative chars with their respective integers\\n        // here we use keys[digits[i]-\\'2\\'] , because we made our keys that start with idx 0 and if we see digit pattern then \\n        // observe that it actuallt start from 2 right so for balancing that we use digits[i]-\\'2\\'\\n        for(char x : keys[digits[start]-\\'2\\'])\\n        {\\n            // call the same helper fundtion by insreasing start count by 1 because we have done woth current now go to second one\\n            // and add current char to tmp because we took the current char and check for its other associatives\\n            helper(digits,ans,start+1,digits.size(),tmp+x);\\n        }\\n    }\\n        \\n    vector<string> letterCombinations(string digits) \\n    {\\n        // if our string is initially empty\\n        if(digits==\"\")\\n            return ans;\\n        \\n        // else call the helper function that will gave all the combinations\\n        helper(digits,ans,0,digits.size(),\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506995,
                "title": "bfs-by-python3",
                "content": "* Runtime: 28 ms, faster than 67.82% of Python3 online submissions for Letter Combinations of a Phone Number.\\n* Memory Usage: 12.7 MB, less than 100.00% of Python3 online submissions for Letter Combinations of a Phone Number.\\n```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        \\'\\'\\'Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\\'\\'\\'\\n        # no digit\\n        if not digits:\\n            return []\\n        key_map = {\\n            2 : [\\'a\\', \\'b\\', \\'c\\'],\\n            3 : [\\'d\\', \\'e\\', \\'f\\'],\\n            4 : [\\'g\\', \\'h\\', \\'i\\'],\\n            5 : [\\'j\\', \\'k\\', \\'l\\'],\\n            6 : [\\'m\\', \\'n\\', \\'o\\'],\\n            7 : [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n            8 : [\\'t\\', \\'u\\', \\'v\\'],\\n            9 : [\\'w\\', \\'x\\', \\'y\\', \\'z\\']\\n        }\\n        ans = [\\'\\']\\n        for d in digits:\\n            new_ans = [x+y for x in ans for y in key_map[int(d)]]\\n            ans = new_ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        \\'\\'\\'Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\\'\\'\\'\\n        # no digit\\n        if not digits:\\n            return []\\n        key_map = {\\n            2 : [\\'a\\', \\'b\\', \\'c\\'],\\n            3 : [\\'d\\', \\'e\\', \\'f\\'],\\n            4 : [\\'g\\', \\'h\\', \\'i\\'],\\n            5 : [\\'j\\', \\'k\\', \\'l\\'],\\n            6 : [\\'m\\', \\'n\\', \\'o\\'],\\n            7 : [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n            8 : [\\'t\\', \\'u\\', \\'v\\'],\\n            9 : [\\'w\\', \\'x\\', \\'y\\', \\'z\\']\\n        }\\n        ans = [\\'\\']\\n        for d in digits:\\n            new_ans = [x+y for x in ans for y in key_map[int(d)]]\\n            ans = new_ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180419,
                "title": "simple-recursive-javascript-solution-beats-100",
                "content": "\\n```\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nvar letterCombinations = function(digits) {\\n  const mappings = {\\n    \\'2\\': [\\'a\\', \\'b\\', \\'c\\'],\\n    \\'3\\': [\\'d\\', \\'e\\', \\'f\\'],\\n    \\'4\\': [\\'g\\', \\'h\\', \\'i\\'],\\n    \\'5\\': [\\'j\\', \\'k\\', \\'l\\'],\\n    \\'6\\': [\\'m\\', \\'n\\', \\'o\\'],\\n    \\'7\\': [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n    \\'8\\': [\\'t\\', \\'u\\', \\'v\\'],\\n    \\'9\\': [\\'w\\', \\'x\\', \\'y\\', \\'z\\']\\n  };\\n\\n  if (!digits || digits.length === 0) return [];\\n  if (digits.length === 1) {\\n    return mappings[digits];\\n  }\\n\\n  let result = [];\\n  let set1 = letterCombinations(digits.substr(0, 1));\\n  let set2 = letterCombinations(digits.substr(1));\\n\\n  for (let i = 0; i < set1.length; i++) {\\n    for (let j = 0; j < set2.length; j++) {\\n      result.push(set1[i] + set2[j]);\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nvar letterCombinations = function(digits) {\\n  const mappings = {\\n    \\'2\\': [\\'a\\', \\'b\\', \\'c\\'],\\n    \\'3\\': [\\'d\\', \\'e\\', \\'f\\'],\\n    \\'4\\': [\\'g\\', \\'h\\', \\'i\\'],\\n    \\'5\\': [\\'j\\', \\'k\\', \\'l\\'],\\n    \\'6\\': [\\'m\\', \\'n\\', \\'o\\'],\\n    \\'7\\': [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n    \\'8\\': [\\'t\\', \\'u\\', \\'v\\'],\\n    \\'9\\': [\\'w\\', \\'x\\', \\'y\\', \\'z\\']\\n  };\\n\\n  if (!digits || digits.length === 0) return [];\\n  if (digits.length === 1) {\\n    return mappings[digits];\\n  }\\n\\n  let result = [];\\n  let set1 = letterCombinations(digits.substr(0, 1));\\n  let set2 = letterCombinations(digits.substr(1));\\n\\n  for (let i = 0; i < set1.length; i++) {\\n    for (let j = 0; j < set2.length; j++) {\\n      result.push(set1[i] + set2[j]);\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 139818,
                "title": "backtracking-java-scala",
                "content": "Take `digits = 23` for example,\\n```\\n- we map each digit to the letters it could represent and build the letterList:\\n[\"abc\", \"def\"]\\n\\n- the recursion tree is as below:\\n   a          b         c\\n/  |  \\\\    /  |  \\\\   /  |  \\\\\\nad ae af bd  be  bf cd  ce  cf\\n```\\n\\nTime complexity: O(4 ^ n) for n is digits.length\\n\\n(Extra) Space complexity: O(n) for n is digits.length\\n****\\n> Java\\n```\\nclass Solution {\\n    private final static String[] digitsToChars = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        if (digits == null || digits.length() == 0) {\\n            return new ArrayList();\\n        }\\n        \\n        List<String> candidates = new ArrayList<>();\\n        for (char c : digits.toCharArray()) {\\n            candidates.add(digitsToChars[c - \\'0\\']);\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        letterCombinationsFrom(candidates, new StringBuilder(), result);\\n        return result;\\n    }\\n\\n    private void letterCombinationsFrom(\\n        List<String> candidates, \\n        // curRes.length() indicates current level in recursion tree\\n        StringBuilder curRes, \\n        List<String> result) {\\n        \\n        // Base case\\n        if (curRes.length() == candidates.size()) {\\n            result.add(curRes.toString());\\n            return;\\n        }\\n        \\n        // Recursive cases\\n        String candidate = candidates.get(curRes.length());\\n        for (int i = 0; i < candidate.length(); i++) {\\n            curRes.append(candidate.charAt(i));\\n            letterCombinationsFrom(candidates, curRes, result);\\n            curRes.deleteCharAt(curRes.length() - 1); // Recover\\n        }\\n    }\\n}\\n```\\n> Scala\\n```\\n    def letterCombinations(digits: String): List[String] = {\\n        // Corner case.\\n        if (digits.size == 0) {\\n            return List[String]()\\n        }\\n        \\n        // Map a digit to the letters it could represent.\\n        val numToLetters = Map(\\'2\\' -> \"abc\", \\'3\\' -> \"def\", \\'4\\' -> \"ghi\", \\'5\\' -> \"jkl\", \\n                               \\'6\\' -> \"mno\", \\'7\\' -> \"pqrs\", \\'8\\' -> \"tuv\", \\'9\\' -> \"wxyz\")\\n        \\n        // Nested method to transfer digits given to a list of corresponding letters.\\n        def getLetterList(digits: String): List[String] = {\\n            var letterArrayBuffer = new ArrayBuffer[String]()\\n            for (i <- 0 until digits.length) {\\n                letterArrayBuffer += numToLetters(digits(i))\\n            }\\n            letterArrayBuffer.toList\\n        }\\n        \\n        val letterList = getLetterList(digits)\\n        \\n        var finalResult = new ArrayBuffer[String]()\\n        letterCombinationsAfter(letterList, \"\", finalResult)\\n        \\n        finalResult.toList\\n    }\\n\\n    def letterCombinationsAfter(letterList: List[String], curComb: String, finalResult: ArrayBuffer[String]): Unit = {\\n        if (curComb.length == letterList.size) {\\n            finalResult += curComb\\n            return\\n        }\\n        \\n        var letters = letterList(curComb.length)\\n        for (i <- 0 until letters.length) {\\n            letterCombinationsAfter(letterList, curComb + letters(i), finalResult)\\n        }\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n- we map each digit to the letters it could represent and build the letterList:\\n[\"abc\", \"def\"]\\n\\n- the recursion tree is as below:\\n   a          b         c\\n/  |  \\\\    /  |  \\\\   /  |  \\\\\\nad ae af bd  be  bf cd  ce  cf\\n```\n```\\nclass Solution {\\n    private final static String[] digitsToChars = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        if (digits == null || digits.length() == 0) {\\n            return new ArrayList();\\n        }\\n        \\n        List<String> candidates = new ArrayList<>();\\n        for (char c : digits.toCharArray()) {\\n            candidates.add(digitsToChars[c - \\'0\\']);\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        letterCombinationsFrom(candidates, new StringBuilder(), result);\\n        return result;\\n    }\\n\\n    private void letterCombinationsFrom(\\n        List<String> candidates, \\n        // curRes.length() indicates current level in recursion tree\\n        StringBuilder curRes, \\n        List<String> result) {\\n        \\n        // Base case\\n        if (curRes.length() == candidates.size()) {\\n            result.add(curRes.toString());\\n            return;\\n        }\\n        \\n        // Recursive cases\\n        String candidate = candidates.get(curRes.length());\\n        for (int i = 0; i < candidate.length(); i++) {\\n            curRes.append(candidate.charAt(i));\\n            letterCombinationsFrom(candidates, curRes, result);\\n            curRes.deleteCharAt(curRes.length() - 1); // Recover\\n        }\\n    }\\n}\\n```\n```\\n    def letterCombinations(digits: String): List[String] = {\\n        // Corner case.\\n        if (digits.size == 0) {\\n            return List[String]()\\n        }\\n        \\n        // Map a digit to the letters it could represent.\\n        val numToLetters = Map(\\'2\\' -> \"abc\", \\'3\\' -> \"def\", \\'4\\' -> \"ghi\", \\'5\\' -> \"jkl\", \\n                               \\'6\\' -> \"mno\", \\'7\\' -> \"pqrs\", \\'8\\' -> \"tuv\", \\'9\\' -> \"wxyz\")\\n        \\n        // Nested method to transfer digits given to a list of corresponding letters.\\n        def getLetterList(digits: String): List[String] = {\\n            var letterArrayBuffer = new ArrayBuffer[String]()\\n            for (i <- 0 until digits.length) {\\n                letterArrayBuffer += numToLetters(digits(i))\\n            }\\n            letterArrayBuffer.toList\\n        }\\n        \\n        val letterList = getLetterList(digits)\\n        \\n        var finalResult = new ArrayBuffer[String]()\\n        letterCombinationsAfter(letterList, \"\", finalResult)\\n        \\n        finalResult.toList\\n    }\\n\\n    def letterCombinationsAfter(letterList: List[String], curComb: String, finalResult: ArrayBuffer[String]): Unit = {\\n        if (curComb.length == letterList.size) {\\n            finalResult += curComb\\n            return\\n        }\\n        \\n        var letters = letterList(curComb.length)\\n        for (i <- 0 until letters.length) {\\n            letterCombinationsAfter(letterList, curComb + letters(i), finalResult)\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8425,
                "title": "standard-java-solution",
                "content": "Standard backtracking problems. \\n\\nUse a `StringBuilder` to add a possible char at each decision point. Go back the decision chain until `index == digits.length()`.\\n\\nSurprisingly, this solution has the same running time compared to recursion one.\\n\\n    String[] chars = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<String>();\\n        if(digits == null || digits.length() == 0) return result;\\n        backtracking(result, new StringBuilder(), digits, 0);\\n        return result;\\n    }\\n    \\n    public void backtracking(List<String> result, StringBuilder sb, String digits, int index) {\\n        if(index == digits.length()) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n        \\n        String str = chars[digits.charAt(index) - '0'];\\n        for(char c : str.toCharArray()) {\\n            sb.append(c);\\n            backtracking(result, sb, digits, index + 1);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Standard backtracking problems. \\n\\nUse a `StringBuilder` to add a possible char at each decision point. Go back the decision chain until `index == digits.length()`.\\n\\nSurprisingly, this solution has the same running time compared to recursion one.\\n\\n    String[] chars = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<String>();\\n        if(digits == null || digits.length() == 0) return result;\\n        backtracking(result, new StringBuilder(), digits, 0);\\n        return result;\\n    }\\n    \\n    public void backtracking(List<String> result, StringBuilder sb, String digits, int index) {\\n        if(index == digits.length()) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n        \\n        String str = chars[digits.charAt(index) - '0'];\\n        for(char c : str.toCharArray()) {\\n            sb.append(c);\\n            backtracking(result, sb, digits, index + 1);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3436342,
                "title": "java-backtracking-no-recursion-10-lines",
                "content": "# Complexity\\n- Time complexity: $$O(4^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(4^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public List<String> letterCombinations(String digits) {\\n    var n = digits.length();\\n    if (n == 0) return new ArrayList<>();\\n\\n    var map = new ArrayList<String>(List.of(\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"));\\n    var dpPrev = new ArrayList<String>(List.of(\"\"));\\n\\n    for (var i = n-1; i >= 0; i--) {\\n      var dp = new ArrayList<String>();\\n\\n      for (var x : map.get(digits.charAt(i) - \\'2\\').toCharArray())\\n        for (var y : dpPrev)\\n          dp.add(x + y);\\n      \\n      dpPrev = dp;\\n    }\\n    return dpPrev;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n  public List<String> letterCombinations(String digits) {\\n    var n = digits.length();\\n    if (n == 0) return new ArrayList<>();\\n\\n    var map = new ArrayList<String>(List.of(\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"));\\n    var dpPrev = new ArrayList<String>(List.of(\"\"));\\n\\n    for (var i = n-1; i >= 0; i--) {\\n      var dp = new ArrayList<String>();\\n\\n      for (var x : map.get(digits.charAt(i) - \\'2\\').toCharArray())\\n        for (var y : dpPrev)\\n          dp.add(x + y);\\n      \\n      dpPrev = dp;\\n    }\\n    return dpPrev;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055702,
                "title": "99-27-javascript-fast-very-easy-to-understand-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/svf_Le0dzeY\\n\\n# Code\\n```\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nvar letterCombinations = function(digits) {\\n    if(digits.length == 0) return []\\n\\n    const map = {\\n        2: [\\'a\\', \\'b\\', \\'c\\'],\\n        3: [\\'d\\', \\'e\\', \\'f\\'],\\n        4: [\\'g\\', \\'h\\', \\'i\\'],\\n        5: [\\'j\\', \\'k\\', \\'l\\'],\\n        6: [\\'m\\', \\'n\\', \\'o\\'],\\n        7: [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n        8: [\\'t\\', \\'u\\', \\'v\\'],\\n        9: [\\'w\\', \\'x\\', \\'y\\', \\'z\\']\\n    }\\n\\n    let iterate = (nums) =>{\\n        let arr = []\\n        if(nums.length == 1) return map[nums];\\n        let first = nums.slice(0,1)\\n        let others = iterate(nums.slice(1))\\n\\n        for(let i =0; i<map[first].length;i++){\\n            for(let j =0; j<others.length;j++){\\n                arr.push(map[first][i] + others[j])\\n            }\\n        }\\n\\n        return arr;\\n    }\\n\\n    return iterate(digits)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nvar letterCombinations = function(digits) {\\n    if(digits.length == 0) return []\\n\\n    const map = {\\n        2: [\\'a\\', \\'b\\', \\'c\\'],\\n        3: [\\'d\\', \\'e\\', \\'f\\'],\\n        4: [\\'g\\', \\'h\\', \\'i\\'],\\n        5: [\\'j\\', \\'k\\', \\'l\\'],\\n        6: [\\'m\\', \\'n\\', \\'o\\'],\\n        7: [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n        8: [\\'t\\', \\'u\\', \\'v\\'],\\n        9: [\\'w\\', \\'x\\', \\'y\\', \\'z\\']\\n    }\\n\\n    let iterate = (nums) =>{\\n        let arr = []\\n        if(nums.length == 1) return map[nums];\\n        let first = nums.slice(0,1)\\n        let others = iterate(nums.slice(1))\\n\\n        for(let i =0; i<map[first].length;i++){\\n            for(let j =0; j<others.length;j++){\\n                arr.push(map[first][i] + others[j])\\n            }\\n        }\\n\\n        return arr;\\n    }\\n\\n    return iterate(digits)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2684321,
                "title": "c-recursion-simple-explained",
                "content": "This is a direct recursive implementation, where we append all the characters of this digit to the currently formed string, and call recursive function for the next digits. \\n* If, the length is zero, we return directly.\\n* Else, we form a vector representing the phone characters for this letter and call the recursive function. Go through the recursive function to understand completely.\\n\\n**Full Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void combinations(string digits, string currString, vector<string> numbers, int start, int end){\\n        if(start == end)ans.push_back(currString);\\n        else{\\n            int index = digits[start]-\\'0\\';\\n            for(int i=0; i<numbers[index].length(); i++)\\n                combinations(digits, currString+numbers[index][i], numbers, start+1, end);\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.length()==0)return ans;\\n        vector<string> numbers = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        combinations(digits,\"\", numbers, 0, digits.length());\\n        return ans;\\n    }\\n};\\n```\\n**In case you found the post useful, please give it an upvote.**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void combinations(string digits, string currString, vector<string> numbers, int start, int end){\\n        if(start == end)ans.push_back(currString);\\n        else{\\n            int index = digits[start]-\\'0\\';\\n            for(int i=0; i<numbers[index].length(); i++)\\n                combinations(digits, currString+numbers[index][i], numbers, start+1, end);\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.length()==0)return ans;\\n        vector<string> numbers = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        combinations(digits,\"\", numbers, 0, digits.length());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020934,
                "title": "c-solution-easy-step-by-step-100-time-math",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char> >&v,vector<string>&ans,string digits,int pos,string s)\\n    {\\n        if(pos==digits.size())\\n        {\\n            if(s!=\"\")\\n            ans.push_back(s);return;\\n        }\\n        int temp=digits[pos]-\\'0\\';\\n        for(int i=0;i<v[temp].size();i++)\\n        {\\n            s.push_back(v[temp][i]);\\n            solve(v,ans,digits,pos+1,s);\\n            s.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        string s;\\n        vector<vector<char> > v{{},{},{\\'a\\',\\'b\\',\\'c\\'},{\\'d\\',\\'e\\',\\'f\\'},{\\'g\\',\\'h\\',\\'i\\'},{\\'j\\',\\'k\\',\\'l\\'},\\n                               {\\'m\\',\\'n\\',\\'o\\'},{\\'p\\',\\'q\\',\\'r\\',\\'s\\'},{\\'t\\',\\'u\\',\\'v\\'},{\\'w\\',\\'x\\',\\'y\\',\\'z\\'}};\\n        vector<string> ans;\\n        solve(v,ans,digits,0,\"\");\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    void solve(vector<vector<char> >&v,vector<string>&ans,string digits,int pos,string s)\\n    {\\n        if(pos==digits.size())\\n        {\\n            if(s!=\"\")\\n            ans.push_back(s);return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1303871,
                "title": "c-iterative-backtracking-2-method-100-faster",
                "content": "**Iterative**\\n```\\nclass Solution {\\npublic:\\n\\tvector<string>v = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n\\tvector<string> letterCombinations(string digits) {\\n\\t\\tvector<string> ans;\\n\\t\\tif (digits.size() == 0)\\n\\t\\t{\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tans.push_back(\"\");\\n\\n\\t\\tfor (auto d : digits)\\n\\t\\t{\\n\\t\\t\\tvector<string>temp;\\n\\t\\t\\tfor (auto c : v[d - \\'0\\'])\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (auto s : ans)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.push_back(s + c);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tswap(temp, ans);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\n**Recursion + Backtracking**\\n```\\nclass Solution {\\npublic:\\n    vector<string>v = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    \\n    void generate(string digits,string temp,int start,vector<string> &ans)\\n    {\\n        if(temp.size()==digits.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(auto i : v[digits[start]-\\'0\\'])\\n        {\\n            temp.push_back(i);\\n            generate(digits,temp,start+1,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    \\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.size()==0)\\n        {\\n            return ans;\\n        }\\n        string temp = \"\";\\n        generate(digits,temp,0,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n***If find HelpFul then please Upvote*** **:)**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<string>v = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n\\tvector<string> letterCombinations(string digits) {\\n\\t\\tvector<string> ans;\\n\\t\\tif (digits.size() == 0)\\n\\t\\t{\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tans.push_back(\"\");\\n\\n\\t\\tfor (auto d : digits)\\n\\t\\t{\\n\\t\\t\\tvector<string>temp;\\n\\t\\t\\tfor (auto c : v[d - \\'0\\'])\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (auto s : ans)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.push_back(s + c);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tswap(temp, ans);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string>v = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    \\n    void generate(string digits,string temp,int start,vector<string> &ans)\\n    {\\n        if(temp.size()==digits.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(auto i : v[digits[start]-\\'0\\'])\\n        {\\n            temp.push_back(i);\\n            generate(digits,temp,start+1,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    \\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.size()==0)\\n        {\\n            return ans;\\n        }\\n        string temp = \"\";\\n        generate(digits,temp,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350758,
                "title": "simple-java-solution",
                "content": "I still remember that I lived in Santa Clara with two roommates years ago, and my roommate showed me how to solve this problem in java.\\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        if(digits == null || digits.length() == 0) return new ArrayList<>();\\n        \\n        Map<Character, String> map = new HashMap<>();\\n        map.put(\\'2\\', \"abc\");\\n        map.put(\\'3\\', \"def\");\\n        map.put(\\'4\\', \"ghi\");\\n        map.put(\\'5\\', \"jkl\");\\n        map.put(\\'6\\', \"mno\");\\n        map.put(\\'7\\', \"pqrs\");\\n        map.put(\\'8\\', \"tuv\");\\n        map.put(\\'9\\', \"wxyz\");\\n        \\n        List<String> res = new ArrayList<>();\\n        dfs(0, digits, new StringBuilder(), res, map);\\n        return res;\\n    }\\n    \\n    private void dfs(int st, String digits, StringBuilder sb, List<String> res, Map<Character, String> map) {\\n        if(st == digits.length()) {\\n            res.add(sb.toString());\\n            return;\\n        }\\n        \\n        String str = map.get(digits.charAt(st));\\n        for(int i = 0; i < str.length(); i++) {\\n            sb.append(str.charAt(i));\\n            dfs(st + 1, digits, sb, res, map);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        if(digits == null || digits.length() == 0) return new ArrayList<>();\\n        \\n        Map<Character, String> map = new HashMap<>();\\n        map.put(\\'2\\', \"abc\");\\n        map.put(\\'3\\', \"def\");\\n        map.put(\\'4\\', \"ghi\");\\n        map.put(\\'5\\', \"jkl\");\\n        map.put(\\'6\\', \"mno\");\\n        map.put(\\'7\\', \"pqrs\");\\n        map.put(\\'8\\', \"tuv\");\\n        map.put(\\'9\\', \"wxyz\");\\n        \\n        List<String> res = new ArrayList<>();\\n        dfs(0, digits, new StringBuilder(), res, map);\\n        return res;\\n    }\\n    \\n    private void dfs(int st, String digits, StringBuilder sb, List<String> res, Map<Character, String> map) {\\n        if(st == digits.length()) {\\n            res.add(sb.toString());\\n            return;\\n        }\\n        \\n        String str = map.get(digits.charAt(st));\\n        for(int i = 0; i < str.length(); i++) {\\n            sb.append(str.charAt(i));\\n            dfs(st + 1, digits, sb, res, map);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302666,
                "title": "go",
                "content": "```\\nfunc letterCombinations(digits string) []string {\\n    ans := []string{}\\n    if len(digits) == 0 {return ans}\\n    helper(digits, 0, \"\", &ans)\\n    return ans\\n}\\n\\nvar M = map[byte]string {\\n    \\'1\\': \"\",\\n    \\'2\\': \"abc\",\\n    \\'3\\': \"def\",\\n    \\'4\\': \"ghi\",\\n    \\'5\\': \"jkl\",\\n    \\'6\\': \"mno\",\\n    \\'7\\': \"pqrs\",\\n    \\'8\\': \"tuv\",\\n    \\'9\\': \"wxyz\",\\n    \\'0\\': \" \",\\n}\\n\\nfunc helper(digits string, pos int, s string, strs *[]string) {\\n    if pos == len(digits) {\\n        *strs = append(*strs, s)\\n        return\\n    }\\n    \\n    for _, c := range M[digits[pos]] {\\n        helper(digits, pos + 1, s + string(c), strs)\\n    }\\n    return\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc letterCombinations(digits string) []string {\\n    ans := []string{}\\n    if len(digits) == 0 {return ans}\\n    helper(digits, 0, \"\", &ans)\\n    return ans\\n}\\n\\nvar M = map[byte]string {\\n    \\'1\\': \"\",\\n    \\'2\\': \"abc\",\\n    \\'3\\': \"def\",\\n    \\'4\\': \"ghi\",\\n    \\'5\\': \"jkl\",\\n    \\'6\\': \"mno\",\\n    \\'7\\': \"pqrs\",\\n    \\'8\\': \"tuv\",\\n    \\'9\\': \"wxyz\",\\n    \\'0\\': \" \",\\n}\\n\\nfunc helper(digits string, pos int, s string, strs *[]string) {\\n    if pos == len(digits) {\\n        *strs = append(*strs, s)\\n        return\\n    }\\n    \\n    for _, c := range M[digits[pos]] {\\n        helper(digits, pos + 1, s + string(c), strs)\\n    }\\n    return\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8079,
                "title": "scala-tail-rec",
                "content": "```\\nobject Solution {\\n    val m = Map(('2' -> \"abc\"), ('3' -> \"def\"), ('4' -> \"ghi\"), ('5'-> \"jkl\"), ('6' -> \"mno\"), ('7' -> \"pqrs\"), ('8' -> \"tuv\"), ('9' -> \"wxyz\")).mapValues(_.toList)\\n    def letterCombinations(digits: String): List[String] = {\\n        def rec(digits: String, acc: List[String]): List[String] = {\\n            if (digits == \"\") acc\\n            else rec(digits.tail, acc.flatMap(x => m(digits.head).map(y => x+y)))\\n        }\\n        if (digits == \"\")\\n            List()\\n        else\\n            rec(digits, List(\"\"))\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    val m = Map(('2' -> \"abc\"), ('3' -> \"def\"), ('4' -> \"ghi\"), ('5'-> \"jkl\"), ('6' -> \"mno\"), ('7' -> \"pqrs\"), ('8' -> \"tuv\"), ('9' -> \"wxyz\")).mapValues(_.toList)\\n    def letterCombinations(digits: String): List[String] = {\\n        def rec(digits: String, acc: List[String]): List[String] = {\\n            if (digits == \"\") acc\\n            else rec(digits.tail, acc.flatMap(x => m(digits.head).map(y => x+y)))\\n        }\\n        if (digits == \"\")\\n            List()\\n        else\\n            rec(digits, List(\"\"))\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 8479,
                "title": "0ms-less-than-1ms-c-solution",
                "content": "    class Solution {\\n        static string letter[10];\\n        vector<string> res;\\n    public:\\n        vector<string> letterCombinations(string digits) {\\n            if(digits.empty())\\n                return res;\\n        \\tstring str;\\n        \\tcombine(digits, 0, str);\\n        \\treturn res;\\n        }\\n        \\n        void combine(string &digits, int i, string str) {\\n        \\tif(i>=digits.size()) {   // \\u9012\\u5f52\\u7ec8\\u6b62\\u6761\\u4ef6\\n        \\t\\tres.push_back(str);\\n        \\t\\treturn;\\n        \\t}\\n        \\tstring s = letter[digits[i]-'0'];\\n        \\tfor(int j=0; j<s.size(); ++j)\\n        \\t\\tcombine(digits, i+1, str+s[j]);\\t\\t\\n        }\\n    };\\n    \\n    string Solution::letter[] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n        static string letter[10];\\n        vector<string> res;\\n    public:\\n        vector<string> letterCombinations(string digits) {\\n            if(digits.empty())\\n                return res;\\n        \\tstring str;\\n        \\tcombine(digits, 0, str);\\n        \\treturn res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3855869,
                "title": "beats-100-backtracking-video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/bEjAupsxTUs\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    vector<string> dial = {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    vector<string> letterCombinations(string digits) {\\n        ans.clear();\\n        if (digits.length() == 0) {\\n            return ans;\\n        }\\n        helper(\"\", 0, digits);\\n        return ans;\\n    }\\n    \\n    void helper(string comb, int index, string digits) {\\n        if (index == digits.length()) {\\n            ans.push_back(comb);\\n            return;\\n        }\\n            \\n        string letters = dial[digits[index] - \\'0\\'];\\n        for (int i = 0; i < letters.length(); i++) {\\n            helper(comb + letters[i], index + 1, digits);\\n        }\\n    }\\n};\\n\\n```\\n\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    List<String> ans;\\n    String[] dial = {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    public List<String> letterCombinations(String digits) {\\n        ans = new ArrayList<>();\\n        if (digits.length() == 0) {\\n            return ans;\\n        }\\n        helper(\"\", 0, digits);\\n        return ans;\\n    }\\n    \\n    private void helper(String comb, int index, String digits) {\\n        if (index == digits.length()) {\\n            ans.add(comb);\\n            return;\\n        }\\n            \\n        String letters = dial[digits.charAt(index) - \\'0\\'];\\n        for (int i = 0; i < letters.length(); i++) {\\n            helper(comb + letters.charAt(i), index + 1, digits);\\n        }\\n    }\\n}\\n\\n```\\n\\n```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        ans = []\\n        dial = [\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\\n        \\n        def helper(comb, index, digits):\\n            nonlocal ans\\n            if index == len(digits):\\n                ans.append(comb)\\n                return\\n            \\n            letters = dial[int(digits[index])]\\n            for char in letters:\\n                helper(comb + char, index + 1, digits)\\n        \\n        if len(digits) == 0:\\n            return ans\\n        \\n        helper(\"\", 0, digits)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    vector<string> dial = {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    vector<string> letterCombinations(string digits) {\\n        ans.clear();\\n        if (digits.length() == 0) {\\n            return ans;\\n        }\\n        helper(\"\", 0, digits);\\n        return ans;\\n    }\\n    \\n    void helper(string comb, int index, string digits) {\\n        if (index == digits.length()) {\\n            ans.push_back(comb);\\n            return;\\n        }\\n            \\n        string letters = dial[digits[index] - \\'0\\'];\\n        for (int i = 0; i < letters.length(); i++) {\\n            helper(comb + letters[i], index + 1, digits);\\n        }\\n    }\\n};\\n\\n```\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    List<String> ans;\\n    String[] dial = {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    public List<String> letterCombinations(String digits) {\\n        ans = new ArrayList<>();\\n        if (digits.length() == 0) {\\n            return ans;\\n        }\\n        helper(\"\", 0, digits);\\n        return ans;\\n    }\\n    \\n    private void helper(String comb, int index, String digits) {\\n        if (index == digits.length()) {\\n            ans.add(comb);\\n            return;\\n        }\\n            \\n        String letters = dial[digits.charAt(index) - \\'0\\'];\\n        for (int i = 0; i < letters.length(); i++) {\\n            helper(comb + letters.charAt(i), index + 1, digits);\\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        ans = []\\n        dial = [\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\\n        \\n        def helper(comb, index, digits):\\n            nonlocal ans\\n            if index == len(digits):\\n                ans.append(comb)\\n                return\\n            \\n            letters = dial[int(digits[index])]\\n            for char in letters:\\n                helper(comb + char, index + 1, digits)\\n        \\n        if len(digits) == 0:\\n            return ans\\n        \\n        helper(\"\", 0, digits)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460862,
                "title": "recursive-iterative-both-approach-step-by-step-explained",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(4^n),\\n where n is the length of the input string digits. This is because each digit in the input can map to up to 4 characters (in the case of digits 7 and 9).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n\\n# RECURSIVE CODE\\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<>();\\n\\n        // If input string is empty, return empty list\\n        if (digits.length() == 0) {\\n            return result;\\n        }\\n\\n        // Mapping of digits to corresponding letters\\n        String[] digitToLetters = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        // Generate letter combinations using recursion\\n        generateCombinations(digits, 0, \"\", digitToLetters, result);\\n\\n        return result;\\n    }\\n    \\n    private void generateCombinations(String digits, int index, String combination, String[] digitToLetters, List<String> result) {\\n        // If we\\'ve processed all digits, add current combination to result list and return\\n        if (index == digits.length()) {\\n            result.add(combination);\\n            return;\\n        }\\n\\n        // Get the possible letters for the current digit\\n        String letters = digitToLetters[digits.charAt(index) - \\'0\\'];\\n\\n        // Recursively generate combinations for each possible letter of the current digit\\n        for (int i = 0; i < letters.length(); i++) {\\n            generateCombinations(digits, index + 1, combination + letters.charAt(i), digitToLetters, result);\\n        }\\n    }\\n}\\n\\n```\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/4fa1c1a6-13de-4c20-9c69-1bcfcf2c0c52_1682604662.9110665.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(4^n),\\n where n is the length of the input string digits. This is because each digit in the input can map to up to 4 characters (in the case of digits 7 and 9).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(4^n),\\n as the size of the output list will be 4^n in the worst case (when all the digits in the input string map to 4 characters).\\n\\n\\n\\n# ITERATIVE CODE\\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        \\n        List<String> result = new ArrayList<>();\\n\\n        // If digits is empty, return the empty result\\n        if(digits.length() == 0){\\n            return result;\\n        }\\n\\n        // Create a HashMap to store digit-letter mappings\\n        HashMap<String,String> digitToLetters = new HashMap<>();\\n        digitToLetters.put(\"2\",\"abc\"); digitToLetters.put(\"3\",\"def\"); digitToLetters.put(\"4\",\"ghi\");\\n        digitToLetters.put(\"5\",\"jkl\"); digitToLetters.put(\"6\",\"mno\"); digitToLetters.put(\"7\",\"pqrs\");\\n        digitToLetters.put(\"8\",\"tuv\"); digitToLetters.put(\"9\",\"wxyz\"); \\n\\n        // Create a queue to store intermediate combinations\\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(\"\");\\n\\n        // Iterate over each digit in the input string\\n        for(int i = 0; i < digits.length(); i++){\\n\\n            // Get the current digit and its corresponding letters\\n            String currentDigit = digits.substring(i,i+1);\\n            String letters = digitToLetters.get(currentDigit);\\n\\n            // Get the current size of the queue\\n            int queueSize = queue.size();\\n\\n            // For each combination in the queue, append each letter of the current digit and add it to the queue\\n            for(int j = 0; j < queueSize; j++){\\n                String currentCombination = queue.poll();\\n                for(int k = 0; k < letters.length();k++){\\n                    String newCombination = currentCombination.concat(letters.charAt(k)+\"\");\\n                    queue.add(newCombination);\\n                }\\n            }\\n        }\\n\\n        // Convert the queue to a list and return the result\\n        while(!queue.isEmpty()){\\n            result.add(queue.poll());\\n        }\\n        return result;\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<>();\\n\\n        // If input string is empty, return empty list\\n        if (digits.length() == 0) {\\n            return result;\\n        }\\n\\n        // Mapping of digits to corresponding letters\\n        String[] digitToLetters = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        // Generate letter combinations using recursion\\n        generateCombinations(digits, 0, \"\", digitToLetters, result);\\n\\n        return result;\\n    }\\n    \\n    private void generateCombinations(String digits, int index, String combination, String[] digitToLetters, List<String> result) {\\n        // If we\\'ve processed all digits, add current combination to result list and return\\n        if (index == digits.length()) {\\n            result.add(combination);\\n            return;\\n        }\\n\\n        // Get the possible letters for the current digit\\n        String letters = digitToLetters[digits.charAt(index) - \\'0\\'];\\n\\n        // Recursively generate combinations for each possible letter of the current digit\\n        for (int i = 0; i < letters.length(); i++) {\\n            generateCombinations(digits, index + 1, combination + letters.charAt(i), digitToLetters, result);\\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        \\n        List<String> result = new ArrayList<>();\\n\\n        // If digits is empty, return the empty result\\n        if(digits.length() == 0){\\n            return result;\\n        }\\n\\n        // Create a HashMap to store digit-letter mappings\\n        HashMap<String,String> digitToLetters = new HashMap<>();\\n        digitToLetters.put(\"2\",\"abc\"); digitToLetters.put(\"3\",\"def\"); digitToLetters.put(\"4\",\"ghi\");\\n        digitToLetters.put(\"5\",\"jkl\"); digitToLetters.put(\"6\",\"mno\"); digitToLetters.put(\"7\",\"pqrs\");\\n        digitToLetters.put(\"8\",\"tuv\"); digitToLetters.put(\"9\",\"wxyz\"); \\n\\n        // Create a queue to store intermediate combinations\\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(\"\");\\n\\n        // Iterate over each digit in the input string\\n        for(int i = 0; i < digits.length(); i++){\\n\\n            // Get the current digit and its corresponding letters\\n            String currentDigit = digits.substring(i,i+1);\\n            String letters = digitToLetters.get(currentDigit);\\n\\n            // Get the current size of the queue\\n            int queueSize = queue.size();\\n\\n            // For each combination in the queue, append each letter of the current digit and add it to the queue\\n            for(int j = 0; j < queueSize; j++){\\n                String currentCombination = queue.poll();\\n                for(int k = 0; k < letters.length();k++){\\n                    String newCombination = currentCombination.concat(letters.charAt(k)+\"\");\\n                    queue.add(newCombination);\\n                }\\n            }\\n        }\\n\\n        // Convert the queue to a list and return the result\\n        while(!queue.isEmpty()){\\n            result.add(queue.poll());\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373663,
                "title": "easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere again we need to make combinations of letters. So we need to use the \"Pick\"-\"Not pick\" method.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Explanation of the Base Case\\n ```\\nif(i==digits.length()){\\nans.push_back(sol);\\nreturn;\\n}\\n```\\nHere, \\'i\\' is pointing the element of the string digits. So if value of \\'i\\' becomes equal to the size of \"digits\" then it means there is no more value for which we need to make combination , So we can insert the combination (sol) into the string type vector (ans) and then return. \\n\\n```\\nif(digits.length()==0){\\n            return ans;\\n        }\\n``` \\nthis is an case if the given string is empty or we can say that the size of the given string is 0. So we can return the empty Vector(ans).\\n\\n# Need of the following string type array\\n\\n```\\n string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n```\\nThis string type array is made for storing the corresponding string(which is given in the keypad) of that index. But as we know there is no string assigned for 0 and 1. So those are empty.\\n\\n# conversion of character (digits) into integer \\n\\n```\\nint num=digits[i]-\\'0\\';\\nstring val=mapping[num];\\n```\\ndigits are given as character so by the first line of the above code it is converted into integer.\\nlet, \\n    digit[i]=\"2\";\\nASCII value of \\'0\\' is 48, and ASCII value of \\'2\\' is 50.\\nSo, 50 - 48 = 2(which has been got as an integer)\\n\\nThen in the same index of mapping[] there is the string which is stored into a string named as \\'val\\' .\\n\\n# Explanation of the loop\\n\\n```\\nfor(int j=0;j<val.length();j++){\\n            sol.push_back(val[j]);\\n            help(i+1,digits,mapping,sol,ans);\\n            sol.pop_back();\\n        }\\n``` \\nA loop is used to traverse through the current string stored in val. \\nAnd then the \"pick\" \"not pick\" method is used to generate all the possible words from the given digits.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(4^n * n)$$\\nBecause, \\n        the numbers 7 and 9 can give 4 possible letters. So in the worst case if 7 and 9 is given in digits so there might be 4^n possible combinations and then a  for loop is used.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\nBecause, \\n        n stack spaces are used.\\n# Code\\n```\\nclass Solution {    \\npublic:\\n    void help(int i,string digits,string mapping[],string sol,vector<string>&ans){\\n        if(i==digits.length()){\\n            ans.push_back(sol);\\n            return;\\n        }\\n\\n        int num=digits[i]-\\'0\\';\\n        string val=mapping[num];\\n\\n        for(int j=0;j<val.length();j++){\\n            sol.push_back(val[j]);\\n            help(i+1,digits,mapping,sol,ans);\\n            sol.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string>ans;\\n        string sol;\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        help(0,digits,mapping,sol,ans);\\n        return ans;\\n    }\\n};\\n```\\n# Please Upvote if it was helpfull for you \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(i==digits.length()){\\nans.push_back(sol);\\nreturn;\\n}\\n```\n```\\nif(digits.length()==0){\\n            return ans;\\n        }\\n```\n```\\n string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n```\n```\\nint num=digits[i]-\\'0\\';\\nstring val=mapping[num];\\n```\n```\\nfor(int j=0;j<val.length();j++){\\n            sol.push_back(val[j]);\\n            help(i+1,digits,mapping,sol,ans);\\n            sol.pop_back();\\n        }\\n```\n```\\nclass Solution {    \\npublic:\\n    void help(int i,string digits,string mapping[],string sol,vector<string>&ans){\\n        if(i==digits.length()){\\n            ans.push_back(sol);\\n            return;\\n        }\\n\\n        int num=digits[i]-\\'0\\';\\n        string val=mapping[num];\\n\\n        for(int j=0;j<val.length();j++){\\n            sol.push_back(val[j]);\\n            help(i+1,digits,mapping,sol,ans);\\n            sol.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string>ans;\\n        string sol;\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        help(0,digits,mapping,sol,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337972,
                "title": "100-beats-easy-java-solution-easy-understanding",
                "content": "\\n> # Approach\\nBacktracking solution using pick and don\\'t pick.\\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(4^N.N), 4 represents maximum length of the letters possible for corresponding number.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\nclass Solution {\\n    static String[] ref = new String[]{\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    public void backtrack(char str[],char arr[],int curr,int length,LinkedList<String> list){\\n        if(curr==length){\\n            list.add(new String(str));\\n            return;\\n        }\\n        String flag = ref[arr[curr]-50];\\n        for(int i=0;i<flag.length();i++){\\n            str[curr]=flag.charAt(i);\\n            backtrack(str,arr,1+curr,length,list);\\n        }\\n    }\\n    public List<String> letterCombinations(String digits) {\\n        LinkedList<String> output = new LinkedList<>();\\n        if(digits.length()==0) return output;\\n        char flow[] = new char[digits.length()];\\n        backtrack(flow,digits.toCharArray(),0,digits.length(),output);\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    static String[] ref = new String[]{\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    public void backtrack(char str[],char arr[],int curr,int length,LinkedList<String> list){\\n        if(curr==length){\\n            list.add(new String(str));\\n            return;\\n        }\\n        String flag = ref[arr[curr]-50];\\n        for(int i=0;i<flag.length();i++){\\n            str[curr]=flag.charAt(i);\\n            backtrack(str,arr,1+curr,length,list);\\n        }\\n    }\\n    public List<String> letterCombinations(String digits) {\\n        LinkedList<String> output = new LinkedList<>();\\n        if(digits.length()==0) return output;\\n        char flow[] = new char[digits.length()];\\n        backtrack(flow,digits.toCharArray(),0,digits.length(),output);\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696936,
                "title": "simple-solution-with-handwritten-recursive-tree-and-notes-based-on-fraz-and-neetcode-algorithm",
                "content": "Hand written Recursive tree and notes\\n\\n![image](https://assets.leetcode.com/users/images/ae674839-644e-4816-8ece-31de35ff400b_1665636853.32545.jpeg)\\n\\n\\nPlease upvote if it is helpful.\\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        \\n        List<String> answer = new ArrayList<>();\\n        \\n        if(digits.length() == 0)return answer;\\n        \\n        HashMap<Character, String> hm = new HashMap<>();\\n        hm.put(\\'2\\', \"abc\");\\n        hm.put(\\'3\\', \"def\");\\n        hm.put(\\'4\\', \"ghi\");\\n        hm.put(\\'5\\', \"jkl\");        \\n        hm.put(\\'6\\', \"mno\");\\n        hm.put(\\'7\\', \"pqrs\");\\n        hm.put(\\'8\\', \"tuv\");\\n        hm.put(\\'9\\', \"wxyz\");\\n        \\n        String temp =\"\";\\n        int index = 0;\\n        \\n        backTrack(index, temp, digits, answer, hm);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (int i, String temp, String digits, List<String> answer, HashMap<Character, String> hm )\\n    {\\n        \\n        if(i == digits.length() ){\\n            answer.add(temp);\\n            return;\\n        }\\n        char digit = digits.charAt(i);\\n        String str = hm.get(digit);\\n        \\n        for(int j=0; j< str.length(); j++){\\n            char c = str.charAt(j);\\n            \\n            //including\\n            temp += c;\\n            \\n            //recursive call\\n            backTrack(i + 1, temp, digits, answer, hm);\\n            \\n            //excluding\\n            temp = temp.substring(0,temp.length()-1);\\n        }\\n        \\n    }\\n}\\n```\\nPlease upvote if it was helpful.",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        \\n        List<String> answer = new ArrayList<>();\\n        \\n        if(digits.length() == 0)return answer;\\n        \\n        HashMap<Character, String> hm = new HashMap<>();\\n        hm.put(\\'2\\', \"abc\");\\n        hm.put(\\'3\\', \"def\");\\n        hm.put(\\'4\\', \"ghi\");\\n        hm.put(\\'5\\', \"jkl\");        \\n        hm.put(\\'6\\', \"mno\");\\n        hm.put(\\'7\\', \"pqrs\");\\n        hm.put(\\'8\\', \"tuv\");\\n        hm.put(\\'9\\', \"wxyz\");\\n        \\n        String temp =\"\";\\n        int index = 0;\\n        \\n        backTrack(index, temp, digits, answer, hm);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (int i, String temp, String digits, List<String> answer, HashMap<Character, String> hm )\\n    {\\n        \\n        if(i == digits.length() ){\\n            answer.add(temp);\\n            return;\\n        }\\n        char digit = digits.charAt(i);\\n        String str = hm.get(digit);\\n        \\n        for(int j=0; j< str.length(); j++){\\n            char c = str.charAt(j);\\n            \\n            //including\\n            temp += c;\\n            \\n            //recursive call\\n            backTrack(i + 1, temp, digits, answer, hm);\\n            \\n            //excluding\\n            temp = temp.substring(0,temp.length()-1);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022470,
                "title": "a-simple-dictionary-based-solution",
                "content": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        dispatch = { \"2\":\\'abc\\',  \"3\":\\'def\\',\\\\\\n                     \"4\":\\'ghi\\',  \"5\":\\'jkl\\',\\\\\\n                     \"6\":\\'mno\\',  \"7\":\\'pqrs\\',\\\\\\n                     \"8\":\\'tuv\\',  \"9\":\\'wxyz\\'}\\n        output = [\"\"]\\n        for d in digits:\\n            output = [i+j for i in output for j in dispatch[d]]\\n        if output == [\"\"]:\\n            output = []\\n        return output\\n```\\nIn this, we just need to handle the case of empty string separately.\\nList comprehension is your friend...",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        dispatch = { \"2\":\\'abc\\',  \"3\":\\'def\\',\\\\\\n                     \"4\":\\'ghi\\',  \"5\":\\'jkl\\',\\\\\\n                     \"6\":\\'mno\\',  \"7\":\\'pqrs\\',\\\\\\n                     \"8\":\\'tuv\\',  \"9\":\\'wxyz\\'}\\n        output = [\"\"]\\n        for d in digits:\\n            output = [i+j for i in output for j in dispatch[d]]\\n        if output == [\"\"]:\\n            output = []\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021214,
                "title": "0ms-c-recursion",
                "content": "We didn\\'t need to do backtrack explicitly , just remove the reference to the string (temp) and let recursion do the rest of the job.\\n```\\nvoid fun(string digits,vector<string> str,vector<string> &ans,int n,int i,string temp)\\n{\\n    if(i>n)\\n        return ;\\n    if(i==n)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    for(char s : str[(digits[i]-\\'0\\')])\\n        fun(digits,str,ans,n,i+1,temp+s);\\n}\\nvector<string> letterCombinations(string digits) \\n{\\n    if(digits == \"\")\\n        return {};\\n    vector<string> str,ans;\\n    str={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    int n=digits.size();\\n    fun(digits,str,ans,n,0,\"\");\\n    return ans;\\n}\\n```\\n\\n: )\\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvoid fun(string digits,vector<string> str,vector<string> &ans,int n,int i,string temp)\\n{\\n    if(i>n)\\n        return ;\\n    if(i==n)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    for(char s : str[(digits[i]-\\'0\\')])\\n        fun(digits,str,ans,n,i+1,temp+s);\\n}\\nvector<string> letterCombinations(string digits) \\n{\\n    if(digits == \"\")\\n        return {};\\n    vector<string> str,ans;\\n    str={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    int n=digits.size();\\n    fun(digits,str,ans,n,0,\"\");\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1673901,
                "title": "java-beats-100-time-backtracking-w-hashtable",
                "content": "### Letter Combinations Function\\n1. Begin by initializing the list to store the resulting strings in. Then check if the digit string contains values, if not return the empty list.\\n\\n2. Now initialize a hashtable to map the digit characters to their respective letters.\\n\\n3. Once this has been done begin recursing passing the index of digits to begin from (0), the hashtable of letters, the string of digits, a new string builder for creating the strings in, and the list of results.\\n\\n4. Once the recursion has returned all character combinations have been added so return the result.\\n```\\npublic List<String> letterCombinations(String digits) {\\n    List<String> result = new ArrayList(); // Step 1\\n    if(digits.length() == 0) return result; // Step 1\\n    String[] letters = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; // Step 2\\n    backtrack(0, letters, digits, new StringBuilder(), result); // Step 3\\n    return result; // Step 4\\n}\\n```\\n\\n### Backtrack function\\n1. Check the base case that the length of the string builder is equal to that of the digits string. If so this is a valid combination so add the resulting string to the results list.\\n\\n2. If not, calculate the index in the hashtable for the digit at the pass index. This can be done by subtracting the character value 2. Since all digits are in ascending order based on ASCII value.\\n\\n3. Now index into the hashtable to get the resulting string of possible characters and store its character array.\\n\\n4. Loop through the possible characters appending them to the string builder and recurse, passing the next index in digits to the call.\\n\\n5. Once the recursive call has backtracked remove the added character and continue until all characters for the given digit have been used.\\n\\n```\\npublic void backtrack(int idx, String[] letters, String digits, StringBuilder temp, List<String> result){\\n    if(temp.length() == digits.length()) result.add(temp.toString()); // Step 1\\n    else {\\n        char[] letterArr = letters[digits.charAt(idx) - \\'2\\'].toCharArray(); // Step 2 & 3\\n        for(int j = 0; j < letterArr.length; j++){\\n            temp.append(letterArr[j]); // Step 4\\n            backtrack(idx + 1, letters, digits, temp, result); // Step 4\\n            temp.deleteCharAt(temp.length() - 1); // Step 5\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\npublic List<String> letterCombinations(String digits) {\\n    List<String> result = new ArrayList(); // Step 1\\n    if(digits.length() == 0) return result; // Step 1\\n    String[] letters = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; // Step 2\\n    backtrack(0, letters, digits, new StringBuilder(), result); // Step 3\\n    return result; // Step 4\\n}\\n```\n```\\npublic void backtrack(int idx, String[] letters, String digits, StringBuilder temp, List<String> result){\\n    if(temp.length() == digits.length()) result.add(temp.toString()); // Step 1\\n    else {\\n        char[] letterArr = letters[digits.charAt(idx) - \\'2\\'].toCharArray(); // Step 2 & 3\\n        for(int j = 0; j < letterArr.length; j++){\\n            temp.append(letterArr[j]); // Step 4\\n            backtrack(idx + 1, letters, digits, temp, result); // Step 4\\n            temp.deleteCharAt(temp.length() - 1); // Step 5\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1540615,
                "title": "java-python-easy-approach-with-explanation-postorder-divide-and-conquer",
                "content": "```\\nJAVA\\n```\\n```\\nclass Solution {\\n    ArrayList<String> res= new ArrayList<String>();\\n    public List<String> letterCombinations(String digits) \\n    {\\n        if ( digits.length() == 0 )//Base Case when we are provided with no digit \\n            return res;\\n        \\n        HashMap<Character, Character[]> map= new HashMap<>();//digit -- character associated with it \\n        \\n        //Adding the Entry\\n        map.put(\\'2\\', new Character[]{ \\'a\\', \\'b\\', \\'c\\' });\\n        map.put(\\'3\\', new Character[]{ \\'d\\', \\'e\\', \\'f\\' });\\n        map.put(\\'4\\', new Character[]{ \\'g\\', \\'h\\', \\'i\\' });\\n        map.put(\\'5\\', new Character[]{ \\'j\\', \\'k\\', \\'l\\' });\\n        map.put(\\'6\\', new Character[]{ \\'m\\', \\'n\\', \\'o\\' });\\n        map.put(\\'7\\', new Character[]{ \\'p\\', \\'q\\', \\'r\\', \\'s\\' });\\n        map.put(\\'8\\', new Character[]{ \\'t\\', \\'u\\', \\'v\\' });\\n        map.put(\\'9\\', new Character[]{ \\'w\\', \\'x\\', \\'y\\', \\'z\\' });\\n        \\n        char no[]= digits.toCharArray();//Converting the Sring to Character Array \\n        dfs ( map, no, 0, \"\" );//Calling the DFS Function \\n        return res;\\n    }\\n    public void dfs (HashMap<Character, Character[]> map, char no[], int phNo, String stringSoFar )\\n    {//Postorder Appraoch // Divide and Conquer\\n        \\n        if ( stringSoFar.length() == no.length  ){//When we found our desired String//CONQUER \\n            res.add( stringSoFar );//Adding the new String to the \\n            \\n            return;//Returning so that we can explore other combination letters of the digit \\n        }\\n        for ( char ch: map.get(no[phNo]))//DIVIDE\\n             dfs ( map, no, phNo+1, stringSoFar+ ch);///Going in Deapth of the Recursion Tree // Like Neural Network \\n        return;\\n    }\\n}//Please do Upvote, it Helps a lot  \\n```\\n```\\nPYTHON\\n```\\n```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        if not digits:\\n            return []\\n        \\n        self.map_= {\\'2\\':\"abc\", \\'3\\':\"def\", \\'4\\':\"ghi\", \\'5\\':\"jkl\", \\'6\\':\"mno\", \\'7\\':\"pqrs\", \\'8\\':\"tuv\", \\'9\\':\"wxyz\"};\\n        \\n        self.res= [];\\n        \\n        self.dfs(self.map_, digits, \"\", self.res)\\n        \\n        return self.res\\n    \\n    def dfs(self, map_, digits, stringSoFar, res):\\n        if not digits:\\n            res.append(stringSoFar);\\n            return;\\n        \\n        for ch in map_[digits[0]]:\\n            self.dfs(map_, digits[1:], stringSoFar+ ch, res);\\n        \\n\\t\\t#Please do Upvote, it Helps a lot  \\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nJAVA\\n```\n```\\nclass Solution {\\n    ArrayList<String> res= new ArrayList<String>();\\n    public List<String> letterCombinations(String digits) \\n    {\\n        if ( digits.length() == 0 )//Base Case when we are provided with no digit \\n            return res;\\n        \\n        HashMap<Character, Character[]> map= new HashMap<>();//digit -- character associated with it \\n        \\n        //Adding the Entry\\n        map.put(\\'2\\', new Character[]{ \\'a\\', \\'b\\', \\'c\\' });\\n        map.put(\\'3\\', new Character[]{ \\'d\\', \\'e\\', \\'f\\' });\\n        map.put(\\'4\\', new Character[]{ \\'g\\', \\'h\\', \\'i\\' });\\n        map.put(\\'5\\', new Character[]{ \\'j\\', \\'k\\', \\'l\\' });\\n        map.put(\\'6\\', new Character[]{ \\'m\\', \\'n\\', \\'o\\' });\\n        map.put(\\'7\\', new Character[]{ \\'p\\', \\'q\\', \\'r\\', \\'s\\' });\\n        map.put(\\'8\\', new Character[]{ \\'t\\', \\'u\\', \\'v\\' });\\n        map.put(\\'9\\', new Character[]{ \\'w\\', \\'x\\', \\'y\\', \\'z\\' });\\n        \\n        char no[]= digits.toCharArray();//Converting the Sring to Character Array \\n        dfs ( map, no, 0, \"\" );//Calling the DFS Function \\n        return res;\\n    }\\n    public void dfs (HashMap<Character, Character[]> map, char no[], int phNo, String stringSoFar )\\n    {//Postorder Appraoch // Divide and Conquer\\n        \\n        if ( stringSoFar.length() == no.length  ){//When we found our desired String//CONQUER \\n            res.add( stringSoFar );//Adding the new String to the \\n            \\n            return;//Returning so that we can explore other combination letters of the digit \\n        }\\n        for ( char ch: map.get(no[phNo]))//DIVIDE\\n             dfs ( map, no, phNo+1, stringSoFar+ ch);///Going in Deapth of the Recursion Tree // Like Neural Network \\n        return;\\n    }\\n}//Please do Upvote, it Helps a lot  \\n```\n```\\nPYTHON\\n```\n```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        if not digits:\\n            return []\\n        \\n        self.map_= {\\'2\\':\"abc\", \\'3\\':\"def\", \\'4\\':\"ghi\", \\'5\\':\"jkl\", \\'6\\':\"mno\", \\'7\\':\"pqrs\", \\'8\\':\"tuv\", \\'9\\':\"wxyz\"};\\n        \\n        self.res= [];\\n        \\n        self.dfs(self.map_, digits, \"\", self.res)\\n        \\n        return self.res\\n    \\n    def dfs(self, map_, digits, stringSoFar, res):\\n        if not digits:\\n            res.append(stringSoFar);\\n            return;\\n        \\n        for ch in map_[digits[0]]:\\n            self.dfs(map_, digits[1:], stringSoFar+ ch, res);\\n        \\n\\t\\t#Please do Upvote, it Helps a lot  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104093,
                "title": "java-easy-and-simple-recursive-soln-using-backtracking-0-ms-faster-than-100-00-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    static String[] letters = new String[]{\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    List<String> results;\\n    public List<String> letterCombinations(String digits) {\\n        results = new ArrayList();\\n        \\n        //call this Backtracking method,\\n        //add all letter combination in list\\n        backtracking(digits, 0, new StringBuilder());\\n        \\n        return results;\\n    }\\n    \\n    private void backtracking(String digits, int index, StringBuilder sb){\\n        \\n        //base case\\n        //all dgits are covered\\n        if(index == digits.length()){\\n            \\n            //add this combination in the list\\n            if(sb.length() > 0)\\n                results.add(sb.toString());\\n            return;\\n        }\\n        \\n        //current digit\\n        int digit = digits.charAt(index) - \\'0\\';\\n        \\n        for(char letter : letters[digit].toCharArray()){\\n            //add this leeter\\n            sb.append(letter);\\n            \\n            \\n            backtracking(digits, index + 1, sb);\\n            \\n            //remove last added letter\\n            //to explore the different permuation of letters\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        \\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    static String[] letters = new String[]{\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    List<String> results;\\n    public List<String> letterCombinations(String digits) {\\n        results = new ArrayList();\\n        \\n        //call this Backtracking method,\\n        //add all letter combination in list\\n        backtracking(digits, 0, new StringBuilder());\\n        \\n        return results;\\n    }\\n    \\n    private void backtracking(String digits, int index, StringBuilder sb){\\n        \\n        //base case\\n        //all dgits are covered\\n        if(index == digits.length()){\\n            \\n            //add this combination in the list\\n            if(sb.length() > 0)\\n                results.add(sb.toString());\\n            return;\\n        }\\n        \\n        //current digit\\n        int digit = digits.charAt(index) - \\'0\\';\\n        \\n        for(char letter : letters[digit].toCharArray()){\\n            //add this leeter\\n            sb.append(letter);\\n            \\n            \\n            backtracking(digits, index + 1, sb);\\n            \\n            //remove last added letter\\n            //to explore the different permuation of letters\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        \\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472358,
                "title": "backtracking-simple-faster-easy-to-understand-javascript-submission",
                "content": "**Please do upvote, it motivates me to write more such posts\\uD83D\\uDE03**\\n\\n```\\nvar letterCombinations = function(digits) {\\n    let map = {\\n        2: \"abc\",\\n        3: \"def\",\\n        4: \"ghi\",\\n        5: \"jkl\",\\n        6: \"mno\",\\n        7: \"pqrs\",\\n        8: \"tuv\",\\n        9: \"wxyz\"\\n    }\\n    let out = comb(map, digits, [], \"\", digits.length);\\n    return out;\\n    \\n};\\n\\n\\nfunction comb(map, dig, out=[], curr=\"\", len){\\n    if(curr.length===len){\\n        out.push(curr);\\n        return [];\\n    }\\n    else{\\n        for(let i = 0; i<dig.length; i++){\\n            let ch = dig[i];\\n            let str = map[ch];\\n            let newDig = dig.slice(i+1);\\n            for(let j = 0; j<str.length; j++){\\n                comb(map, newDig, out, curr + str[j], len);\\n            }\\n            \\n        }\\n    }\\n    return out;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar letterCombinations = function(digits) {\\n    let map = {\\n        2: \"abc\",\\n        3: \"def\",\\n        4: \"ghi\",\\n        5: \"jkl\",\\n        6: \"mno\",\\n        7: \"pqrs\",\\n        8: \"tuv\",\\n        9: \"wxyz\"\\n    }\\n    let out = comb(map, digits, [], \"\", digits.length);\\n    return out;\\n    \\n};\\n\\n\\nfunction comb(map, dig, out=[], curr=\"\", len){\\n    if(curr.length===len){\\n        out.push(curr);\\n        return [];\\n    }\\n    else{\\n        for(let i = 0; i<dig.length; i++){\\n            let ch = dig[i];\\n            let str = map[ch];\\n            let newDig = dig.slice(i+1);\\n            for(let j = 0; j<str.length; j++){\\n                comb(map, newDig, out, curr + str[j], len);\\n            }\\n            \\n        }\\n    }\\n    return out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 397542,
                "title": "c-solution",
                "content": "```\\n    char **letterCombinations(char * digits, int* returnSize){\\n    char *phone[8] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    char **result = (char **)malloc(sizeof(char *) * 4000);\\n    char tmp[strlen(digits) + 1];\\n    int resLen = 0;\\n    if (strlen(digits) == 0) {\\n        *returnSize = resLen;\\n        return result;\\n    }\\n    catRes(result, phone, digits, tmp, 0, &resLen);\\n    *returnSize = resLen;\\n    return result;\\n}\\n\\nvoid catRes(char **result, char **phone, char *digits, char *tmp, int nowIndex, \\n             int *resLen) {\\n    \\n    if (nowIndex == strlen(digits)) {\\n        tmp[nowIndex] = 0;\\n        result[(*resLen)] = (char *)malloc(strlen(tmp) + 1);\\n        strcpy(result[(*resLen)], tmp);\\n        (*resLen)++;\\n        return;\\n        \\n    }\\n    char *phoneData = phone[digits[nowIndex] - \\'0\\' - 2];\\n    for (int i = 0; i < strlen(phoneData); i++) {\\n        tmp[nowIndex] = phoneData[i];\\n        catRes(result, phone, digits, tmp, nowIndex + 1, resLen);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    char **letterCombinations(char * digits, int* returnSize){\\n    char *phone[8] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    char **result = (char **)malloc(sizeof(char *) * 4000);\\n    char tmp[strlen(digits) + 1];\\n    int resLen = 0;\\n    if (strlen(digits) == 0) {\\n        *returnSize = resLen;\\n        return result;\\n    }\\n    catRes(result, phone, digits, tmp, 0, &resLen);\\n    *returnSize = resLen;\\n    return result;\\n}\\n\\nvoid catRes(char **result, char **phone, char *digits, char *tmp, int nowIndex, \\n             int *resLen) {\\n    \\n    if (nowIndex == strlen(digits)) {\\n        tmp[nowIndex] = 0;\\n        result[(*resLen)] = (char *)malloc(strlen(tmp) + 1);\\n        strcpy(result[(*resLen)], tmp);\\n        (*resLen)++;\\n        return;\\n        \\n    }\\n    char *phoneData = phone[digits[nowIndex] - \\'0\\' - 2];\\n    for (int i = 0; i < strlen(phoneData); i++) {\\n        tmp[nowIndex] = phoneData[i];\\n        catRes(result, phone, digits, tmp, nowIndex + 1, resLen);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378421,
                "title": "easy-to-understand-c-solution",
                "content": "```\\n void get_arr(vector<vector<char>>& arr){\\n        vector<char>temp{\\'a\\',\\'b\\',\\'c\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'d\\',\\'e\\',\\'f\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'g\\',\\'h\\',\\'i\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'j\\',\\'k\\',\\'l\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'m\\',\\'n\\',\\'o\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'p\\',\\'q\\',\\'r\\',\\'s\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'t\\',\\'u\\',\\'v\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'w\\',\\'x\\',\\'y\\',\\'z\\'};\\n        arr.push_back(temp); temp.clear();\\n        return;\\n    }\\n    void back(string digit,vector<vector<char>>& arr,vector<char>& temp,int index,vector<string>&ans){\\n        if(index == digit.size()){\\n            string s=\"\";\\n            for(int i=0;i<temp.size();i++) s+=temp[i];\\n            ans.push_back(s);\\n            return;\\n        }\\n        for(int i=0;i<arr[digit[index]-\\'0\\'-2].size();i++){\\n            temp.push_back(arr[digit[index]-\\'0\\'-2][i]);\\n            back(digit,arr,temp,index+1,ans);\\n            temp.pop_back();\\n        }\\n        return;\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<vector<char>> arr;\\n        vector<string>ans;\\n        if(digits == \"\") return ans;\\n        get_arr(arr);\\n        vector<char> temp;\\n        back(digits,arr,temp,0,ans);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n void get_arr(vector<vector<char>>& arr){\\n        vector<char>temp{\\'a\\',\\'b\\',\\'c\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'d\\',\\'e\\',\\'f\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'g\\',\\'h\\',\\'i\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'j\\',\\'k\\',\\'l\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'m\\',\\'n\\',\\'o\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'p\\',\\'q\\',\\'r\\',\\'s\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'t\\',\\'u\\',\\'v\\'};\\n        arr.push_back(temp); temp.clear();\\n        temp={\\'w\\',\\'x\\',\\'y\\',\\'z\\'};\\n        arr.push_back(temp); temp.clear();\\n        return;\\n    }\\n    void back(string digit,vector<vector<char>>& arr,vector<char>& temp,int index,vector<string>&ans){\\n        if(index == digit.size()){\\n            string s=\"\";\\n            for(int i=0;i<temp.size();i++) s+=temp[i];\\n            ans.push_back(s);\\n            return;\\n        }\\n        for(int i=0;i<arr[digit[index]-\\'0\\'-2].size();i++){\\n            temp.push_back(arr[digit[index]-\\'0\\'-2][i]);\\n            back(digit,arr,temp,index+1,ans);\\n            temp.pop_back();\\n        }\\n        return;\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<vector<char>> arr;\\n        vector<string>ans;\\n        if(digits == \"\") return ans;\\n        get_arr(arr);\\n        vector<char> temp;\\n        back(digits,arr,temp,0,ans);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 244128,
                "title": "c-100",
                "content": "```\\npublic class Solution {\\n    public IList<string> LetterCombinations(string digits) {\\n        var dict = new Dictionary<char, string>\\n            {\\n                {\\'2\\', \"abc\"},\\n                {\\'3\\', \"def\"},\\n                {\\'4\\', \"ghi\"},\\n                {\\'5\\', \"jkl\"},\\n                {\\'6\\', \"mno\"},\\n                {\\'7\\', \"pqrs\"},\\n                {\\'8\\', \"tuv\"},\\n                {\\'9\\', \"wxyz\"}\\n            };\\n\\n            var list = new List<string>();\\n        \\n            if(!string.IsNullOrEmpty(digits))\\n                Backtrack(list, digits, dict, new List<char>(), 0);\\n\\n            return list;\\n    }\\n    \\n    void Backtrack(List<string> list, string digits, Dictionary<char, string> dict, List<char> temp, int start)\\n        {\\n            if (temp.Count == digits.Length) list.Add(string.Join(\"\", temp));\\n\\n            for (var i = start; i < digits.Length; i++)\\n            {\\n                for (var j = 0; j < dict[digits[i]].Length; j++)\\n                {\\n                    temp.Add(dict[digits[i]][j]);\\n\\n                    Backtrack(list, digits, dict, temp, i + 1);\\n\\n                    temp.RemoveAt(temp.Count - 1);\\n                }\\n\\n            }\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> LetterCombinations(string digits) {\\n        var dict = new Dictionary<char, string>\\n            {\\n                {\\'2\\', \"abc\"},\\n                {\\'3\\', \"def\"},\\n                {\\'4\\', \"ghi\"},\\n                {\\'5\\', \"jkl\"},\\n                {\\'6\\', \"mno\"},\\n                {\\'7\\', \"pqrs\"},\\n                {\\'8\\', \"tuv\"},\\n                {\\'9\\', \"wxyz\"}\\n            };\\n\\n            var list = new List<string>();\\n        \\n            if(!string.IsNullOrEmpty(digits))\\n                Backtrack(list, digits, dict, new List<char>(), 0);\\n\\n            return list;\\n    }\\n    \\n    void Backtrack(List<string> list, string digits, Dictionary<char, string> dict, List<char> temp, int start)\\n        {\\n            if (temp.Count == digits.Length) list.Add(string.Join(\"\", temp));\\n\\n            for (var i = start; i < digits.Length; i++)\\n            {\\n                for (var j = 0; j < dict[digits[i]].Length; j++)\\n                {\\n                    temp.Add(dict[digits[i]][j]);\\n\\n                    Backtrack(list, digits, dict, temp, i + 1);\\n\\n                    temp.RemoveAt(temp.Count - 1);\\n                }\\n\\n            }\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8439,
                "title": "simple-java-solution-using-recursion",
                "content": "1. Generate the intermediate result for the string s[1..n-1] (deleting 1st character).\\n2. 1st character corresponds to a list of string. For eg. if 1st character is 2, it corresponds to {\"a\", \"b\", \"c\"}. Get this list of string, say firstList\\n3. Append every element of firstList to every element of the intermediate result obtained in step1 and add these to the final result.\\n\\nBase case: If string has just 1 character, return the corresponding list of string using map.\\n\\nBelow is the code:-\\n\\n    public class Solution {\\n        Map<Integer, List<String>> digitMap = new HashMap<Integer, List<String>>();\\n        \\n        Solution() {\\n            digitMap.put(2, Arrays.asList(new String[] {\"a\", \"b\", \"c\"}));\\n            digitMap.put(3, Arrays.asList(new String[] {\"d\", \"e\", \"f\"}));\\n            digitMap.put(4, Arrays.asList(new String[] {\"g\", \"h\", \"i\"}));\\n            digitMap.put(5, Arrays.asList(new String[] {\"j\", \"k\", \"l\"}));\\n            digitMap.put(6, Arrays.asList(new String[] {\"m\", \"n\", \"o\"}));\\n            digitMap.put(7, Arrays.asList(new String[] {\"p\", \"q\", \"r\", \"s\"}));\\n            digitMap.put(8, Arrays.asList(new String[] {\"t\", \"u\", \"v\"}));\\n            digitMap.put(9, Arrays.asList(new String[] {\"w\", \"x\", \"y\", \"z\"}));\\n        }\\n        \\n        public List<String> letterCombinations(String digits) {\\n            List<String> result = new ArrayList<String>();\\n            if(digits.length() == 0)\\n                return result;\\n            if(digits.length() == 1)\\n                return digitMap.get(digits.charAt(0) - '0');\\n            List<String> intermediate = letterCombinations(digits.substring(1, digits.length()));\\n            for(String first : digitMap.get(digits.charAt(0) - '0'))\\n                for(String rest : intermediate)\\n                    result.add(first + rest);\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        Map<Integer, List<String>> digitMap = new HashMap<Integer, List<String>>();\\n        \\n        Solution() {\\n            digitMap.put(2, Arrays.asList(new String[] {\"a\", \"b\", \"c\"}",
                "codeTag": "Java"
            },
            {
                "id": 8445,
                "title": "pure-c-recursive-solution",
                "content": "\\n\\n    char map[10][4] = {\\n        {' ', ' ', ' ', ' '}, //0\\n        {' ', ' ', ' ', ' '}, //1\\n        {'a', 'b', 'c', ' '}, //2\\n        {'d', 'e', 'f', ' '}, //3\\n        {'g', 'h', 'i', ' '}, //4\\n        {'j', 'k', 'l', ' '},\\n        {'m', 'n', 'o', ' '},\\n        {'p', 'q', 'r', 's'},\\n        {'t', 'u', 'v', ' '}, //8\\n        {'w', 'x', 'y', 'z'} //9\\n    };\\n    \\n    void letterComb(char* digits, int* returnSize, char *result, int ind, char **ans)\\n    {\\n        int i = 0;\\n        char c;\\n        char *letter = map[digits[0] - '0'];\\n    \\n        if (digits[0] == 0) {\\n            char *res = malloc(strlen(result) + 1);\\n            strcpy(res, result);\\n            ans[(*returnSize)] = res;\\n            (*returnSize)++;\\n            return;\\n        }\\n    \\n        while ((c = letter[i]) != ' ') {\\n            result[ind] = c;\\n            letterComb(digits + 1, returnSize, result, ind + 1, ans);\\n            i++;\\n            if (i == 4)\\n                break;\\n        }\\n        return;\\n    }\\n    \\n    char** letterCombinations(char* digits, int* returnSize) {\\n        \\n        int ind = 0, size = 0;\\n        int len = strlen(digits) + 1;\\n        char result[len];\\n        \\n        if (digits == NULL || strlen(digits) == 0)\\n            return NULL;\\n      \\n        char **ans = (char **) malloc(sizeof (char *) * 32768);\\n            \\n        memset(result, 0, len);\\n        \\n        letterComb(digits, &size, result, ind, ans);\\n        *returnSize = size;\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\n\\n    char map[10][4] = {\\n        {' ', ' ', ' ', ' '}, //0\\n        {' ', ' ', ' ', ' '}, //1\\n        {'a', 'b', 'c', ' '}, //2\\n        {'d', 'e', 'f', ' '}, //3\\n        {'g', 'h', 'i', ' '}, //4\\n        {'j', 'k', 'l', ' '},\\n        {'m', 'n', 'o', ' '},\\n        {'p', 'q', 'r', 's'},\\n        {'t', 'u', 'v', ' '}, //8\\n        {'w', 'x', 'y', 'z'} //9\\n    };\\n    \\n    void letterComb(char* digits, int* returnSize, char *result, int ind, char **ans)\\n    {\\n        int i = 0;\\n        char c;\\n        char *letter = map[digits[0] - '0'];\\n    \\n        if (digits[0] == 0) {\\n            char *res = malloc(strlen(result) + 1);\\n            strcpy(res, result);\\n            ans[(*returnSize)] = res;\\n            (*returnSize)++;\\n            return;\\n        }\\n    \\n        while ((c = letter[i]) != ' ') {\\n            result[ind] = c;\\n            letterComb(digits + 1, returnSize, result, ind + 1, ans);\\n            i++;\\n            if (i == 4)\\n                break;\\n        }\\n        return;\\n    }\\n    \\n    char** letterCombinations(char* digits, int* returnSize) {\\n        \\n        int ind = 0, size = 0;\\n        int len = strlen(digits) + 1;\\n        char result[len];\\n        \\n        if (digits == NULL || strlen(digits) == 0)\\n            return NULL;\\n      \\n        char **ans = (char **) malloc(sizeof (char *) * 32768);\\n            \\n        memset(result, 0, len);\\n        \\n        letterComb(digits, &size, result, ind, ans);\\n        *returnSize = size;\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3448320,
                "title": "using-hashtable",
                "content": "# Main : logic product(*chars)\\n```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        dic={\"2\":\"abc\",\"3\":\"def\",\"4\":\"ghi\",\"5\":\"jkl\",\"6\":\"mno\",\"7\":\"pqrs\",\"8\":\"tuv\",\"9\":\"wxyz\"}\\n        if digits==\"\":# edge case\\n            return []\\n        chars=[]\\n        for c in digits:\\n            chars.append(dic[c])\\n        code=product(*chars)\\n        list1=[]\\n        for k in code:\\n            list1.append(\\'\\'.join(k))\\n        return list1\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        dic={\"2\":\"abc\",\"3\":\"def\",\"4\":\"ghi\",\"5\":\"jkl\",\"6\":\"mno\",\"7\":\"pqrs\",\"8\":\"tuv\",\"9\":\"wxyz\"}\\n        if digits==\"\":# edge case\\n            return []\\n        chars=[]\\n        for c in digits:\\n            chars.append(dic[c])\\n        code=product(*chars)\\n        list1=[]\\n        for k in code:\\n            list1.append(\\'\\'.join(k))\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092673,
                "title": "c-easy-to-understand-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    map<char,string> data;\\n\\n    void fillData(){\\n        data[\\'2\\'] = \"abc\";\\n        data[\\'3\\'] = \"def\";\\n        data[\\'4\\'] = \"ghi\";\\n        data[\\'5\\'] = \"jkl\";\\n        data[\\'6\\'] = \"mno\";\\n        data[\\'7\\'] = \"pqrs\";\\n        data[\\'8\\'] = \"tuv\";\\n        data[\\'9\\'] = \"wxyz\";\\n    }\\n\\n    void helper(vector<string>&res, string temp, int i, string digits, int j){\\n        if(temp.length() == digits.length() && temp != \"\") {\\n            res.push_back(temp);\\n            return;\\n        }\\n        if(i >= digits.length()) return;\\n\\n        for(int idx = j; idx < data[digits[i]].length(); idx++){\\n            temp.push_back(data[digits[i]][idx]);\\n            helper(res,temp,i+1,digits,j);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        fillData();\\n        vector<string> res;\\n        string temp = \"\";\\n\\n        helper(res,temp,0,digits,0);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<char,string> data;\\n\\n    void fillData(){\\n        data[\\'2\\'] = \"abc\";\\n        data[\\'3\\'] = \"def\";\\n        data[\\'4\\'] = \"ghi\";\\n        data[\\'5\\'] = \"jkl\";\\n        data[\\'6\\'] = \"mno\";\\n        data[\\'7\\'] = \"pqrs\";\\n        data[\\'8\\'] = \"tuv\";\\n        data[\\'9\\'] = \"wxyz\";\\n    }\\n\\n    void helper(vector<string>&res, string temp, int i, string digits, int j){\\n        if(temp.length() == digits.length() && temp != \"\") {\\n            res.push_back(temp);\\n            return;\\n        }\\n        if(i >= digits.length()) return;\\n\\n        for(int idx = j; idx < data[digits[i]].length(); idx++){\\n            temp.push_back(data[digits[i]][idx]);\\n            helper(res,temp,i+1,digits,j);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        fillData();\\n        vector<string> res;\\n        string temp = \"\";\\n\\n        helper(res,temp,0,digits,0);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126314,
                "title": "solution-long-but-easy",
                "content": "```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n               if(digits.isEmpty()){\\n            return Collections.emptyList();\\n        }\\n         return helper(\"\",digits);\\n    }\\n    static List<String> helper(String processed, String unprocessed){\\n        if(unprocessed.isEmpty()){\\n            ArrayList<String> list = new ArrayList<>();\\n            list.add(processed);\\n            return list;\\n        }\\n\\n        int digit = unprocessed.charAt(0) -\\'0\\';\\n\\n        ArrayList<String> ans = new ArrayList<>();\\n        int start = 0;\\n        int end = 0;\\n        switch (digit){\\n            case 1 : start = 0;\\n            end = 0;\\n            break;\\n            case 2 : start = 0;\\n            end = 2;\\n            break;\\n            case 3 : start = 3;\\n            end = 5;\\n            break;\\n            case 4 : start = 6;\\n            end = 8;\\n            break;\\n            case 5 : start = 9;\\n            end = 11;\\n            break;\\n            case 6 : start = 12;\\n            end = 14;\\n            break;\\n            case 7: start = 15;\\n            end = 18;\\n            break;\\n            case 8: start = 19;\\n            end = 21;\\n            break;\\n            case 9: start = 22;\\n            end = 25;\\n            break;\\n        }\\n       while(start <= end) {\\n\\n            char ch = (char)(\\'a\\' + start);\\n\\n            ans.addAll(helper(processed+ch,unprocessed.substring(1)));\\n            start++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\nIf you liked the solution , found the solution different , so upvote.\\nThank you :)",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n               if(digits.isEmpty()){\\n            return Collections.emptyList();\\n        }\\n         return helper(\"\",digits);\\n    }\\n    static List<String> helper(String processed, String unprocessed){\\n        if(unprocessed.isEmpty()){\\n            ArrayList<String> list = new ArrayList<>();\\n            list.add(processed);\\n            return list;\\n        }\\n\\n        int digit = unprocessed.charAt(0) -\\'0\\';\\n\\n        ArrayList<String> ans = new ArrayList<>();\\n        int start = 0;\\n        int end = 0;\\n        switch (digit){\\n            case 1 : start = 0;\\n            end = 0;\\n            break;\\n            case 2 : start = 0;\\n            end = 2;\\n            break;\\n            case 3 : start = 3;\\n            end = 5;\\n            break;\\n            case 4 : start = 6;\\n            end = 8;\\n            break;\\n            case 5 : start = 9;\\n            end = 11;\\n            break;\\n            case 6 : start = 12;\\n            end = 14;\\n            break;\\n            case 7: start = 15;\\n            end = 18;\\n            break;\\n            case 8: start = 19;\\n            end = 21;\\n            break;\\n            case 9: start = 22;\\n            end = 25;\\n            break;\\n        }\\n       while(start <= end) {\\n\\n            char ch = (char)(\\'a\\' + start);\\n\\n            ans.addAll(helper(processed+ch,unprocessed.substring(1)));\\n            start++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021225,
                "title": "simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string s[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    vector<string> ans;\\n    int n;\\n    vector<string> letterCombinations(string digits) {\\n        n = digits.length();\\n        if(n==0) return ans;\\n        solve(0, digits,\"\");\\n        return ans;\\n    }\\n    \\n    void solve(int i, string digits, string res){        \\n        if(i==n){\\n            ans.push_back(res);\\n            return;\\n        }\\n        \\n        for(int j=0;j<s[ digits[i] - \\'0\\' ].length();j++){\\n            solve(i+1, digits, res + s[ digits[i] - \\'0\\' ][j]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string s[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    vector<string> ans;\\n    int n;\\n    vector<string> letterCombinations(string digits) {\\n        n = digits.length();\\n        if(n==0) return ans;\\n        solve(0, digits,\"\");\\n        return ans;\\n    }\\n    \\n    void solve(int i, string digits, string res){        \\n        if(i==n){\\n            ans.push_back(res);\\n            return;\\n        }\\n        \\n        for(int j=0;j<s[ digits[i] - \\'0\\' ].length();j++){\\n            solve(i+1, digits, res + s[ digits[i] - \\'0\\' ][j]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021072,
                "title": "backtrack-1ms-runtime",
                "content": "Try using StringBuilder instread of String for storing the temporary current string which greatly reduces the runtime. But, the catch here is that u have to remove the last character at the end of each backtrack which is not needed in case of string !\\n\\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<>();\\n        if (digits.isEmpty()) return result;\\n        Map<Character, String> map = new HashMap<>();\\n        map.put(\\'2\\', \"abc\");\\n        map.put(\\'3\\', \"def\");\\n        map.put(\\'4\\', \"ghi\");\\n        map.put(\\'5\\', \"jkl\");\\n        map.put(\\'6\\', \"mno\");\\n        map.put(\\'7\\', \"pqrs\");\\n        map.put(\\'8\\', \"tuv\");\\n        map.put(\\'9\\', \"wxyz\");\\n        backtrack(digits, map, 0, new StringBuilder(), result);\\n        return result;\\n    }\\n\\n    private void backtrack(String digits, Map<Character, String> map, int index,\\n        StringBuilder curr, List<String> result) {\\n        if (curr.length() == digits.length()) {\\n            result.add(curr.toString());\\n            return;\\n        }\\n        for (char c : map.get(digits.charAt(index)).toCharArray()) {\\n            backtrack(digits, map, index + 1, curr.append(c), result);\\n            curr.deleteCharAt(curr.length() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> result = new ArrayList<>();\\n        if (digits.isEmpty()) return result;\\n        Map<Character, String> map = new HashMap<>();\\n        map.put(\\'2\\', \"abc\");\\n        map.put(\\'3\\', \"def\");\\n        map.put(\\'4\\', \"ghi\");\\n        map.put(\\'5\\', \"jkl\");\\n        map.put(\\'6\\', \"mno\");\\n        map.put(\\'7\\', \"pqrs\");\\n        map.put(\\'8\\', \"tuv\");\\n        map.put(\\'9\\', \"wxyz\");\\n        backtrack(digits, map, 0, new StringBuilder(), result);\\n        return result;\\n    }\\n\\n    private void backtrack(String digits, Map<Character, String> map, int index,\\n        StringBuilder curr, List<String> result) {\\n        if (curr.length() == digits.length()) {\\n            result.add(curr.toString());\\n            return;\\n        }\\n        for (char c : map.get(digits.charAt(index)).toCharArray()) {\\n            backtrack(digits, map, index + 1, curr.append(c), result);\\n            curr.deleteCharAt(curr.length() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020967,
                "title": "very-very-easy-to-understand-java-explained-code",
                "content": "***APPROACH 1***\\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        if(digits.isEmpty()) return new ArrayList<>(); //empty string, return empty arraylist\\n        List<String> l1 = new ArrayList<>();\\n        solve(\"\", digits, l1);//calling the helper fuction\\n        return l1;\\n    }\\n    public void solve(String p, String up, List<String> l1){\\n        if(up.isEmpty()){\\n            l1.add(p);\\n            return;\\n        }\\n        // taking the number corresponding to the first char of string.\\n        int number = up.charAt(0) - \\'0\\';\\n        // initializing start and end as random char, here it is takesn as \\'0\\'\\n        char start = \\'0\\';\\n        char end = \\'0\\';\\n        // setting up start and end\\n        // normally until 7, it follows (char)(((number-1) * 3 - 3) + \\'a\\'), but since 7 has 4 characters,\\n        // adding extra checks to set up start and end.\\n        if(number == 8 || number == 9){\\n            start = (char)(((number-1) * 3 - 2) + \\'a\\');\\n        }else{\\n            start = (char)(((number-1) * 3 - 3) + \\'a\\');\\n        }\\n        if(number == 7 || number == 9){\\n            end = (char)(start + 4);\\n        }else{\\n            end = (char)(start + 3);\\n        }\\n        // calling all possible calls by adding each character in current number to previous p.\\n        for(char i = start; i < end; i++){\\n            solve(p + i, up.substring(1), l1);\\n        }\\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n***APPROACH 2***\\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        //If digits length is zero -> return empty array list\\n        if(digits.length()==0)    return new ArrayList<String>();\\n        //Create a dictionary to hold the mapping of phone number to digit.\\n        String[] dictionary = new String[] {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        \\n        ArrayList<String> result = new ArrayList<>();\\n        //We will go through the digits one by one.\\n        for(int i=0; i<digits.length(); i++) {\\n            //We will use a helper function called combine.\\n            result = combine(dictionary[digits.charAt(i)-\\'0\\'].toCharArray(), result);\\n            //combine will take character array of all the letters corresponding to current digit and the result up till now.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public ArrayList<String> combine(char[] toBeAdded, ArrayList<String> result) {\\n        \\n        if (result.isEmpty()) {\\n            for(char tba: toBeAdded)\\n                result.add(String.valueOf(tba));\\n            return result;\\n        }\\n        \\n        ArrayList<String> result2 = new ArrayList<String>();\\n        ////We will run 2 loops - outer loop goes through each character in the char array like \\'a\\', \\'b\\', \\'c\\'. and inner loop will go through already present strings in result like \"ad\", \"ae\", \"af\" etc.\\n        for(String res: result) {\\n            for(char tba: toBeAdded)\\n                //Will simply concatenate and store in new array list.\\n                result2.add(res+String.valueOf(tba));\\n        }\\n        //finally returing the array list\\n        return result2;\\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n***APPROACH 3***\\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        var res = new ArrayList<String>();\\n        if(digits == null || digits.isEmpty()) {\\n            return res;\\n        }\\n        var map = Map.of(\\'2\\', new Character[] { \\'a\\', \\'b\\', \\'c\\' }, \\'3\\', new Character[] { \\'d\\', \\'e\\', \\'f\\' }, \\'4\\',\\n                new Character[] { \\'g\\', \\'h\\', \\'i\\' }, \\'5\\', new Character[] { \\'j\\', \\'k\\', \\'l\\' }, \\'6\\',\\n                new Character[] { \\'m\\', \\'n\\', \\'o\\' }, \\'7\\', new Character[] { \\'p\\', \\'q\\', \\'r\\', \\'s\\' }, \\'8\\',\\n                new Character[] { \\'t\\', \\'u\\', \\'v\\' }, \\'9\\', new Character[] { \\'w\\', \\'x\\', \\'y\\', \\'z\\' });\\n\\n        util(map, res, \"\", digits, 0);\\n        return res;\\n    }\\n\\n    private void util(Map<Character, Character[]> map, List<String> res, String partial, String digits, int i) {\\n        if (partial.length() == digits.length()) {\\n            res.add(partial);\\n            return;\\n        }\\n\\n        Character[] t = map.get(digits.charAt(i));\\n        for (int p = 0; p < t.length; p++) {\\n            partial += t[p];\\n            util(map, res, partial, digits, i + 1);\\n            partial = partial.substring(0, partial.length() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        if(digits.isEmpty()) return new ArrayList<>(); //empty string, return empty arraylist\\n        List<String> l1 = new ArrayList<>();\\n        solve(\"\", digits, l1);//calling the helper fuction\\n        return l1;\\n    }\\n    public void solve(String p, String up, List<String> l1){\\n        if(up.isEmpty()){\\n            l1.add(p);\\n            return;\\n        }\\n        // taking the number corresponding to the first char of string.\\n        int number = up.charAt(0) - \\'0\\';\\n        // initializing start and end as random char, here it is takesn as \\'0\\'\\n        char start = \\'0\\';\\n        char end = \\'0\\';\\n        // setting up start and end\\n        // normally until 7, it follows (char)(((number-1) * 3 - 3) + \\'a\\'), but since 7 has 4 characters,\\n        // adding extra checks to set up start and end.\\n        if(number == 8 || number == 9){\\n            start = (char)(((number-1) * 3 - 2) + \\'a\\');\\n        }else{\\n            start = (char)(((number-1) * 3 - 3) + \\'a\\');\\n        }\\n        if(number == 7 || number == 9){\\n            end = (char)(start + 4);\\n        }else{\\n            end = (char)(start + 3);\\n        }\\n        // calling all possible calls by adding each character in current number to previous p.\\n        for(char i = start; i < end; i++){\\n            solve(p + i, up.substring(1), l1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        //If digits length is zero -> return empty array list\\n        if(digits.length()==0)    return new ArrayList<String>();\\n        //Create a dictionary to hold the mapping of phone number to digit.\\n        String[] dictionary = new String[] {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        \\n        ArrayList<String> result = new ArrayList<>();\\n        //We will go through the digits one by one.\\n        for(int i=0; i<digits.length(); i++) {\\n            //We will use a helper function called combine.\\n            result = combine(dictionary[digits.charAt(i)-\\'0\\'].toCharArray(), result);\\n            //combine will take character array of all the letters corresponding to current digit and the result up till now.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public ArrayList<String> combine(char[] toBeAdded, ArrayList<String> result) {\\n        \\n        if (result.isEmpty()) {\\n            for(char tba: toBeAdded)\\n                result.add(String.valueOf(tba));\\n            return result;\\n        }\\n        \\n        ArrayList<String> result2 = new ArrayList<String>();\\n        ////We will run 2 loops - outer loop goes through each character in the char array like \\'a\\', \\'b\\', \\'c\\'. and inner loop will go through already present strings in result like \"ad\", \"ae\", \"af\" etc.\\n        for(String res: result) {\\n            for(char tba: toBeAdded)\\n                //Will simply concatenate and store in new array list.\\n                result2.add(res+String.valueOf(tba));\\n        }\\n        //finally returing the array list\\n        return result2;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        var res = new ArrayList<String>();\\n        if(digits == null || digits.isEmpty()) {\\n            return res;\\n        }\\n        var map = Map.of(\\'2\\', new Character[] { \\'a\\', \\'b\\', \\'c\\' }, \\'3\\', new Character[] { \\'d\\', \\'e\\', \\'f\\' }, \\'4\\',\\n                new Character[] { \\'g\\', \\'h\\', \\'i\\' }, \\'5\\', new Character[] { \\'j\\', \\'k\\', \\'l\\' }, \\'6\\',\\n                new Character[] { \\'m\\', \\'n\\', \\'o\\' }, \\'7\\', new Character[] { \\'p\\', \\'q\\', \\'r\\', \\'s\\' }, \\'8\\',\\n                new Character[] { \\'t\\', \\'u\\', \\'v\\' }, \\'9\\', new Character[] { \\'w\\', \\'x\\', \\'y\\', \\'z\\' });\\n\\n        util(map, res, \"\", digits, 0);\\n        return res;\\n    }\\n\\n    private void util(Map<Character, Character[]> map, List<String> res, String partial, String digits, int i) {\\n        if (partial.length() == digits.length()) {\\n            res.add(partial);\\n            return;\\n        }\\n\\n        Character[] t = map.get(digits.charAt(i));\\n        for (int p = 0; p < t.length; p++) {\\n            partial += t[p];\\n            util(map, res, partial, digits, i + 1);\\n            partial = partial.substring(0, partial.length() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688825,
                "title": "0ms-beats-100-c-soln-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> map = {\"0\",\"1\",\"abc\" , \"def\" , \"ghi\" , \"jkl\" , \"mno\" , \"pqrs\" , \"tuv\" , \"wxyz\"};\\n\\nvector<string> getKPC(string str)\\n{\\n    if(str.length() == 0)\\n     {\\n         vector<string> base;\\n         string element;\\n         element = \"\";\\n         base.push_back(element);\\n         return base;\\n     }\\n     \\n     char prev = (str[0]);\\n     string next = str.substr(1,str.length() - 1);\\n     \\n     vector<string> res = getKPC(next);\\n     vector<string> ans;\\n     \\n     for(int index = 0 ; index < map[prev - \\'0\\'].length() ; index++)\\n     {\\n         for(int j = 0 ; j < res.size() ; j++)\\n         ans.push_back(map[prev - \\'0\\'][index] + res[j]);\\n     }\\n     \\n     return ans;\\n}\\n\\n    vector<string> letterCombinations(string str) {\\n        if(str.size() == 0)return {};\\n        return getKPC(str);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> map = {\"0\",\"1\",\"abc\" , \"def\" , \"ghi\" , \"jkl\" , \"mno\" , \"pqrs\" , \"tuv\" , \"wxyz\"};\\n\\nvector<string> getKPC(string str)\\n{\\n    if(str.length() == 0)\\n     {\\n         vector<string> base;\\n         string element;\\n         element = \"\";\\n         base.push_back(element);\\n         return base;\\n     }\\n     \\n     char prev = (str[0]);\\n     string next = str.substr(1,str.length() - 1);\\n     \\n     vector<string> res = getKPC(next);\\n     vector<string> ans;\\n     \\n     for(int index = 0 ; index < map[prev - \\'0\\'].length() ; index++)\\n     {\\n         for(int j = 0 ; j < res.size() ; j++)\\n         ans.push_back(map[prev - \\'0\\'][index] + res[j]);\\n     }\\n     \\n     return ans;\\n}\\n\\n    vector<string> letterCombinations(string str) {\\n        if(str.size() == 0)return {};\\n        return getKPC(str);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463320,
                "title": "simple-c-recursive-implementation-faster-than-100-runtime",
                "content": "```\\nclass Solution {\\n    vector<string> keypad {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    void combos(string s, string out, vector<string>& res) {\\n        if (s.empty()) {\\n            res.emplace_back(out);\\n            return;\\n        }\\n\\n        for (char ch : keypad[s[0] - \\'0\\' - 2])\\n            combos(s.substr(1), out + ch, res);\\n    }\\n    \\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> res;\\n        if(digits.size()) combos(digits, \"\", res);\\n        return res;\\n    }\\n};\\n```\\n\\nA simple recursive solution!",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> keypad {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    void combos(string s, string out, vector<string>& res) {\\n        if (s.empty()) {\\n            res.emplace_back(out);\\n            return;\\n        }\\n\\n        for (char ch : keypad[s[0] - \\'0\\' - 2])\\n            combos(s.substr(1), out + ch, res);\\n    }\\n    \\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> res;\\n        if(digits.size()) combos(digits, \"\", res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148716,
                "title": "rust-1-expression-solution",
                "content": "```rust\\nconst MAPPING: [std::ops::RangeInclusive<u8>; 8] = [\\n    (b\\'a\\'..=b\\'c\\'),\\n    (b\\'d\\'..=b\\'f\\'),\\n    (b\\'g\\'..=b\\'i\\'),\\n    (b\\'j\\'..=b\\'l\\'),\\n    (b\\'m\\'..=b\\'o\\'),\\n    (b\\'p\\'..=b\\'s\\'),\\n    (b\\'t\\'..=b\\'v\\'),\\n    (b\\'w\\'..=b\\'z\\'),\\n];\\n\\nimpl Solution {\\n    pub fn letter_combinations(digits: String) -> Vec<String> {\\n        digits.as_bytes().iter().fold(\\n            if digits.is_empty() {\\n                Vec::new()\\n            } else {\\n                vec![String::new()]\\n            },\\n            |acc, &x| {\\n                acc.iter()\\n                    .flat_map(|s| {\\n                        std::iter::repeat(s)\\n                            .zip(MAPPING[(x - b\\'2\\') as usize].clone())\\n                            .map(|(s, b)| s.chars().chain(std::iter::once(b as char)).collect())\\n                            .collect::<Vec<_>>()\\n                    })\\n                    .collect()\\n            },\\n        )\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nconst MAPPING: [std::ops::RangeInclusive<u8>; 8] = [\\n    (b\\'a\\'..=b\\'c\\'),\\n    (b\\'d\\'..=b\\'f\\'),\\n    (b\\'g\\'..=b\\'i\\'),\\n    (b\\'j\\'..=b\\'l\\'),\\n    (b\\'m\\'..=b\\'o\\'),\\n    (b\\'p\\'..=b\\'s\\'),\\n    (b\\'t\\'..=b\\'v\\'),\\n    (b\\'w\\'..=b\\'z\\'),\\n];\\n\\nimpl Solution {\\n    pub fn letter_combinations(digits: String) -> Vec<String> {\\n        digits.as_bytes().iter().fold(\\n            if digits.is_empty() {\\n                Vec::new()\\n            } else {\\n                vec![String::new()]\\n            },\\n            |acc, &x| {\\n                acc.iter()\\n                    .flat_map(|s| {\\n                        std::iter::repeat(s)\\n                            .zip(MAPPING[(x - b\\'2\\') as usize].clone())\\n                            .map(|(s, b)| s.chars().chain(std::iter::once(b as char)).collect())\\n                            .collect::<Vec<_>>()\\n                    })\\n                    .collect()\\n            },\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8203,
                "title": "golang-concise-solution-backtracking-and-maintaining-a-result-array",
                "content": "Backtracking\\n```\\nfunc letterCombinations(digits string) []string {\\n    m := map[byte][]string {\\n        '0': []string{\"0\"},\\n        '1': []string{\"1\"},\\n        '2': []string{\"a\", \"b\", \"c\"},\\n        '3': []string{\"d\", \"e\", \"f\"},\\n        '4': []string{\"g\", \"h\", \"i\"},\\n        '5': []string{\"j\", \"k\", \"l\"},\\n        '6': []string{\"m\", \"n\", \"o\"},\\n        '7': []string{\"p\", \"q\", \"r\", \"s\"},\\n        '8': []string{\"t\", \"u\", \"v\"},\\n        '9': []string{\"w\", \"x\", \"y\", \"z\"},\\n    }\\n    \\n    var res []string\\n    if digits == \"\" {\\n        return res\\n    }\\n    backtrack(\"\", &res, 0, digits, m)\\n    return res\\n}\\n\\nfunc backtrack(curStr string, res *[]string, index int, digits string, digitsMap map[byte][]string) {\\n    if index == len(digits) {\\n        *res = append(*res, curStr)\\n        return\\n    }\\n    for _, ch := range digitsMap[digits[index]] {\\n        backtrack(curStr+ch, res, index+1, digits, digitsMap)\\n    }\\n}\\n```\\n\\nMaintaining slice.\\n\\n```\\nfunc letterCombinations(digits string) []string {\\n    m := map[byte][]string {\\n        '0': []string{\"0\"},\\n        '1': []string{\"1\"},\\n        '2': []string{\"a\", \"b\", \"c\"},\\n        '3': []string{\"d\", \"e\", \"f\"},\\n        '4': []string{\"g\", \"h\", \"i\"},\\n        '5': []string{\"j\", \"k\", \"l\"},\\n        '6': []string{\"m\", \"n\", \"o\"},\\n        '7': []string{\"p\", \"q\", \"r\", \"s\"},\\n        '8': []string{\"t\", \"u\", \"v\"},\\n        '9': []string{\"w\", \"x\", \"y\", \"z\"},\\n    }\\n    \\n    var res []string\\n    for i := 0; i < len(digits); i++ {\\n        digit := digits[i]\\n        \\n        reslen := len(res)\\n        if reslen == 0 {\\n            res = m[digit]\\n            continue\\n        }\\n        \\n        for j := 0; j < reslen; j++ {\\n            for _, ch := range m[digit] {\\n                res = append(res, res[j]+ch)\\n            }\\n        }\\n        res = res[reslen:]\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc letterCombinations(digits string) []string {\\n    m := map[byte][]string {\\n        '0': []string{\"0\"},\\n        '1': []string{\"1\"},\\n        '2': []string{\"a\", \"b\", \"c\"},\\n        '3': []string{\"d\", \"e\", \"f\"},\\n        '4': []string{\"g\", \"h\", \"i\"},\\n        '5': []string{\"j\", \"k\", \"l\"},\\n        '6': []string{\"m\", \"n\", \"o\"},\\n        '7': []string{\"p\", \"q\", \"r\", \"s\"},\\n        '8': []string{\"t\", \"u\", \"v\"},\\n        '9': []string{\"w\", \"x\", \"y\", \"z\"},\\n    }\\n    \\n    var res []string\\n    if digits == \"\" {\\n        return res\\n    }\\n    backtrack(\"\", &res, 0, digits, m)\\n    return res\\n}\\n\\nfunc backtrack(curStr string, res *[]string, index int, digits string, digitsMap map[byte][]string) {\\n    if index == len(digits) {\\n        *res = append(*res, curStr)\\n        return\\n    }\\n    for _, ch := range digitsMap[digits[index]] {\\n        backtrack(curStr+ch, res, index+1, digits, digitsMap)\\n    }\\n}\\n```\n```\\nfunc letterCombinations(digits string) []string {\\n    m := map[byte][]string {\\n        '0': []string{\"0\"},\\n        '1': []string{\"1\"},\\n        '2': []string{\"a\", \"b\", \"c\"},\\n        '3': []string{\"d\", \"e\", \"f\"},\\n        '4': []string{\"g\", \"h\", \"i\"},\\n        '5': []string{\"j\", \"k\", \"l\"},\\n        '6': []string{\"m\", \"n\", \"o\"},\\n        '7': []string{\"p\", \"q\", \"r\", \"s\"},\\n        '8': []string{\"t\", \"u\", \"v\"},\\n        '9': []string{\"w\", \"x\", \"y\", \"z\"},\\n    }\\n    \\n    var res []string\\n    for i := 0; i < len(digits); i++ {\\n        digit := digits[i]\\n        \\n        reslen := len(res)\\n        if reslen == 0 {\\n            res = m[digit]\\n            continue\\n        }\\n        \\n        for j := 0; j < reslen; j++ {\\n            for _, ch := range m[digit] {\\n                res = append(res, res[j]+ch)\\n            }\\n        }\\n        res = res[reslen:]\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8077,
                "title": "short-and-easy-to-understand-iterative-java-solution",
                "content": "    public class Solution {\\n        public List<String> letterCombinations(String digits) {\\n            List<String> res = new ArrayList<String>();\\n            if (digits == null || digits.length() == 0) return res;\\n            res.add(\"\");\\n            String[] mapping = new String[] {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n            for (int i = 0; i < digits.length(); i++){\\n                List<String> newRes = new ArrayList<String>();\\n                char[] charArray= mapping[digits.charAt(i) - '0'].toCharArray();\\n                for (String str : res){\\n                    for (char c : charArray){\\n                        newRes.add(new String(str + c));\\n                    }\\n                }\\n                res = newRes;\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> letterCombinations(String digits) {\\n            List<String> res = new ArrayList<String>();\\n            if (digits == null || digits.length() == 0) return res;\\n            res.add(\"\");\\n            String[] mapping = new String[] {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}",
                "codeTag": "Java"
            },
            {
                "id": 8459,
                "title": "recursive-solution-in-c-0ms",
                "content": "\\n\\n    static const char* letters[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    void combine(char* digits, int from, int to, char* result, char** combinations, int* index) {\\n    \\tif (from <= to) {\\n    \\t\\tconst char *letter = letters[digits[from] - '0'];\\n    \\t\\tfor (int i = 0; i < strlen(letter); ++i) {\\n    \\t\\t\\tresult[from] = letter[i];\\n    \\t\\t\\tcombine(digits, from+1, to, result, combinations, index);\\n    \\t\\t}\\n    \\t} else {\\n    \\t\\tresult[from] = '\\\\0';\\n    \\t\\tcombinations[*index] = malloc(sizeof(strlen(result)));\\n    \\t\\tstrcpy(combinations[*index], result);\\n    \\t\\t(*index)++;\\n    \\t}\\n    }\\n    \\n    char** letterCombinations(char* digits, int* returnSize) {\\n        if (digits == NULL) {\\n        \\treturn NULL;\\n        }\\n        int digitsLength = strlen(digits);\\n        if (digitsLength == 0) {\\n        \\treturn NULL;\\n        }\\n        int returnStrLen = 0;\\n        *returnSize = 1;\\n        for (int i = 0; i < digitsLength; ++i) {\\n        \\tint index = (int)(digits[i] - '0');\\n        \\tif (index >= 2 && index <= 9) {\\n        \\t\\t*returnSize *= strlen(letters[index]);\\n        \\t\\treturnStrLen++;\\n        \\t}\\n        }\\n        char** combinations = malloc(sizeof(char*) * (*returnSize));\\n        char* resultStr = malloc(sizeof(returnStrLen+1));\\n        int* index = malloc(sizeof(int));\\n        *index = 0;\\n        combine(digits, 0, digitsLength-1, resultStr, combinations, index);\\n        return combinations;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "\\n\\n    static const char* letters[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    void combine(char* digits, int from, int to, char* result, char** combinations, int* index) {\\n    \\tif (from <= to) {\\n    \\t\\tconst char *letter = letters[digits[from] - '0'];\\n    \\t\\tfor (int i = 0; i < strlen(letter); ++i) {\\n    \\t\\t\\tresult[from] = letter[i];\\n    \\t\\t\\tcombine(digits, from+1, to, result, combinations, index);\\n    \\t\\t}\\n    \\t} else {\\n    \\t\\tresult[from] = '\\\\0';\\n    \\t\\tcombinations[*index] = malloc(sizeof(strlen(result)));\\n    \\t\\tstrcpy(combinations[*index], result);\\n    \\t\\t(*index)++;\\n    \\t}\\n    }\\n    \\n    char** letterCombinations(char* digits, int* returnSize) {\\n        if (digits == NULL) {\\n        \\treturn NULL;\\n        }\\n        int digitsLength = strlen(digits);\\n        if (digitsLength == 0) {\\n        \\treturn NULL;\\n        }\\n        int returnStrLen = 0;\\n        *returnSize = 1;\\n        for (int i = 0; i < digitsLength; ++i) {\\n        \\tint index = (int)(digits[i] - '0');\\n        \\tif (index >= 2 && index <= 9) {\\n        \\t\\t*returnSize *= strlen(letters[index]);\\n        \\t\\treturnStrLen++;\\n        \\t}\\n        }\\n        char** combinations = malloc(sizeof(char*) * (*returnSize));\\n        char* resultStr = malloc(sizeof(returnStrLen+1));\\n        int* index = malloc(sizeof(int));\\n        *index = 0;\\n        combine(digits, 0, digitsLength-1, resultStr, combinations, index);\\n        return combinations;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3856050,
                "title": "java-simple-solution-0-ms-backtrackingba",
                "content": "# Approach\\nSimpe bruteforce backtracking \\n\\n\\n# Code\\n```\\nclass Solution {\\n    List<String> res = null;\\n    String [] strMap = {\"0\",\"1\",\"abc\", \"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    public List<String> letterCombinations(String digits) {\\n        res = new ArrayList<>();\\n        if(digits.length() == 0){\\n            return res;\\n        }\\n        dfs(0,digits,new StringBuilder());\\n        return res;\\n    }\\n\\n    void dfs(int length ,String digits,StringBuilder temp){\\n\\n        if(length == digits.length()){\\n            res.add(temp.toString());\\n            return; \\n        }\\n\\n        char ch = digits.charAt(length);\\n        String str = strMap[ch -\\'0\\'];\\n\\n        for(char c:str.toCharArray()){\\n            temp.append(c);\\n            dfs(length+1,digits,temp);\\n            temp.deleteCharAt(temp.length()-1);\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<String> res = null;\\n    String [] strMap = {\"0\",\"1\",\"abc\", \"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    public List<String> letterCombinations(String digits) {\\n        res = new ArrayList<>();\\n        if(digits.length() == 0){\\n            return res;\\n        }\\n        dfs(0,digits,new StringBuilder());\\n        return res;\\n    }\\n\\n    void dfs(int length ,String digits,StringBuilder temp){\\n\\n        if(length == digits.length()){\\n            res.add(temp.toString());\\n            return; \\n        }\\n\\n        char ch = digits.charAt(length);\\n        String str = strMap[ch -\\'0\\'];\\n\\n        for(char c:str.toCharArray()){\\n            temp.append(c);\\n            dfs(length+1,digits,temp);\\n            temp.deleteCharAt(temp.length()-1);\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535385,
                "title": "0ms-beats-100-backtracking-tc-o-n-sc-o-1",
                "content": "![image.png](https://assets.leetcode.com/users/images/8b6301b3-98b6-47c3-a561-41c24f5ca0eb_1684341627.6432958.png)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach digit in the keypad is mapped with a set of characters that forms a string. Once a digt is pressed, we are faced with the choice of deciding which character to choose from the string it represents. This process continues for each subsequent digit that it pressed.\\n\\nUltimately, we are simply deciding which character to choose from the string represented by the digit and we keep on repeating this process, generating subcases for each choice, till we exhaust the string of digits given to us.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize a vector of strings `charMap` that stores the string of characters mapped to each digit of its index. Now, call the function `generateCombos` and pass to it `charMap` along with the starting index of `digits`, the string `digits`, a temporary string `temp` to store the strings generated and the vector of strings `sol` to store the possible combinations of strings generated.\\n\\nInitialize an integer `num` and assign to it the numerical value represented by the `idx`th index of digits. Now, initialize a string `str`, and assign to it the string represented by the digit.\\n\\nIterate `str` and push into temp each of its characters. Afterwards, recursively call `generateCombos` with the next index of digits. Once the function call has been returned, pop out the character that was pushed into `temp` and move on the next character of `str`.\\n\\nOnce `idx` becomes equal to the length of `digits`, push into `sol` the non-empty string `temp`.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$, where \\'N\\' is the length of the digits array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$, since the only extra space we are using is for `charMap` and it always occupies 28 bytes.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void generateCombos(int idx, string& digits, string& temp, vector<string>& sol, vector<string>& charMap){\\n        if(idx==digits.length()){\\n            if(temp.length()) sol.push_back(temp);\\n            return;\\n        }\\n\\n        int num=digits[idx]-\\'0\\';\\n        string str=charMap[num];\\n\\n        for(int i=0;i<str.length();i++){\\n            temp.push_back(str[i]);\\n            generateCombos(idx+1, digits, temp, sol, charMap);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        string temp;\\n        vector<string> sol;\\n        vector<string> charMap={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        generateCombos(0, digits, temp, sol, charMap);\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generateCombos(int idx, string& digits, string& temp, vector<string>& sol, vector<string>& charMap){\\n        if(idx==digits.length()){\\n            if(temp.length()) sol.push_back(temp);\\n            return;\\n        }\\n\\n        int num=digits[idx]-\\'0\\';\\n        string str=charMap[num];\\n\\n        for(int i=0;i<str.length();i++){\\n            temp.push_back(str[i]);\\n            generateCombos(idx+1, digits, temp, sol, charMap);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        string temp;\\n        vector<string> sol;\\n        vector<string> charMap={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        generateCombos(0, digits, temp, sol, charMap);\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368666,
                "title": "backtracking-easy-and-clear-python3-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if digits==\"\":\\n            return []\\n        dic={\\'2\\':[\\'a\\',\\'b\\',\\'c\\'], \\'3\\':[\\'d\\',\\'e\\',\\'f\\'], \\'4\\':[\\'g\\',\\'h\\',\\'i\\'], \\'5\\':[\\'j\\',\\'k\\',\\'l\\'], \\'6\\':[\\'m\\',\\'n\\',\\'o\\'], \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'], \\'8\\':[\\'t\\',\\'u\\',\\'v\\'], \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        res=[]\\n        n=len(digits)\\n        def backtracking(r):\\n            if len(r)==n:\\n                res.append(r)\\n            else:\\n                for i in dic[digits[len(r)]]:\\n                    backtracking(r+i)\\n        backtracking(\"\")            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if digits==\"\":\\n            return []\\n        dic={\\'2\\':[\\'a\\',\\'b\\',\\'c\\'], \\'3\\':[\\'d\\',\\'e\\',\\'f\\'], \\'4\\':[\\'g\\',\\'h\\',\\'i\\'], \\'5\\':[\\'j\\',\\'k\\',\\'l\\'], \\'6\\':[\\'m\\',\\'n\\',\\'o\\'], \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'], \\'8\\':[\\'t\\',\\'u\\',\\'v\\'], \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        res=[]\\n        n=len(digits)\\n        def backtracking(r):\\n            if len(r)==n:\\n                res.append(r)\\n            else:\\n                for i in dic[digits[len(r)]]:\\n                    backtracking(r+i)\\n        backtracking(\"\")            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774645,
                "title": "phone-keypad-java-solution-easy-to-understand-time-complexity-o-4-n",
                "content": "```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n     String[] str = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; \\n     StringBuffer store = new StringBuffer();\\n     List<String> ans = new ArrayList<>();\\n        if(digits.length()==0)\\n            return ans;\\n        \\n        helper(0,digits,ans,store,str);\\n        return ans;\\n    }\\n    \\n    void helper(int i, String digits,List<String> ans,StringBuffer store,String[] str)\\n    {\\n        if(i==digits.length())\\n        {\\n            ans.add(store.toString());\\n            return;\\n        }\\n    \\n        int tempI = digits.charAt(i) - \\'0\\';\\n        String tempS = str[tempI];\\n        \\n        for(int j=0; j<tempS.length(); j++)\\n        {\\n            char c = tempS.charAt(j);\\n            store.append(c);\\n            helper(i+1,digits,ans,store,str);\\n            store.deleteCharAt(store.length()-1);\\n        }\\n    }\\n}\\nT.C :- O(4^n), where n is the number of digits in the input number.\\n       Each digit has 3 or 4 characters and for each char there are 3 or4 option of another digit character\\n       \\n       Example :- 79\\n                  7(pqrs)9(wxyz)\\n           \\n           -p(wxyz) = pw,px,py,pz\\n           -q(wxyz) = qw,qx,qy,qz\\n           -r(wxyz) = rw,rx,ry,rz\\n           -s(wxyz) = sw,xx,sy,sz\\n           \\n           i.e. 4^2 = 16\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n     String[] str = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; \\n     StringBuffer store = new StringBuffer();\\n     List<String> ans = new ArrayList<>();\\n        if(digits.length()==0)\\n            return ans;\\n        \\n        helper(0,digits,ans,store,str);\\n        return ans;\\n    }\\n    \\n    void helper(int i, String digits,List<String> ans,StringBuffer store,String[] str)\\n    {\\n        if(i==digits.length())\\n        {\\n            ans.add(store.toString());\\n            return;\\n        }\\n    \\n        int tempI = digits.charAt(i) - \\'0\\';\\n        String tempS = str[tempI];\\n        \\n        for(int j=0; j<tempS.length(); j++)\\n        {\\n            char c = tempS.charAt(j);\\n            store.append(c);\\n            helper(i+1,digits,ans,store,str);\\n            store.deleteCharAt(store.length()-1);\\n        }\\n    }\\n}\\nT.C :- O(4^n), where n is the number of digits in the input number.\\n       Each digit has 3 or 4 characters and for each char there are 3 or4 option of another digit character\\n       \\n       Example :- 79\\n                  7(pqrs)9(wxyz)\\n           \\n           -p(wxyz) = pw,px,py,pz\\n           -q(wxyz) = qw,qx,qy,qz\\n           -r(wxyz) = rw,rx,ry,rz\\n           -s(wxyz) = sw,xx,sy,sz\\n           \\n           i.e. 4^2 = 16\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736217,
                "title": "c-4-different-easy-sol",
                "content": "* Brute force approach this will only work for `digits.size()<=4`.\\n```\\nclass Solution {\\npublic:\\n  vector<string> letterCombinations(string d){\\n      unordered_map<char, string> mp;\\n      mp[\\'2\\'] = \"abc\";\\n      mp[\\'3\\'] = \"def\";\\n      mp[\\'4\\'] = \"ghi\";\\n      mp[\\'5\\'] = \"jkl\";\\n      mp[\\'6\\'] = \"mno\";\\n      mp[\\'7\\'] = \"pqrs\";\\n      mp[\\'8\\'] = \"tuv\";\\n      mp[\\'9\\'] = \"wxyz\";\\n        \\n      int n = d.size(),i = 0; vector<string> res;\\n      string one = mp[d[i]];\\n      for (int j = 0; j < one.size(); j++){\\n          string temp1 = \"\";\\n          temp1.push_back(one[j]);\\n          if (i + 1 < n){\\n          \\n              string two = mp[d[i + 1]];\\n          \\n              for (int k = 0; k < two.size(); k++){\\n            \\n                  string temp2 = temp1;\\n            \\n                  temp2.push_back(two[k]);\\n                  if (i + 2 < n){\\n              \\n                      string three = mp[d[i + 2]];\\n\\n                      for (int l = 0; l < three.size(); l++){\\n\\n                          string temp3 = temp2;\\n\\n                          temp3.push_back(three[l]);\\n                          if (i + 3 < n){\\n\\n                              string four = mp[d[i + 3]];\\n\\n                              for (int m = 0; m < four.size(); m++){\\n                                  string temp4 = temp3;\\n                                  temp4.push_back(four[m]);\\n                                  res.push_back(temp4);\\n                              }\\n                          }else res.push_back(temp3);\\n                      }\\n                  }else res.push_back(temp2);\\n              }\\n          }else res.push_back(temp1);\\n      }\\n      return res;\\n    }\\n};\\n```\\n\\n* Recursive solution\\n```\\nconst vector<string> mp = {\\n    \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\\n    \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\nclass Solution {\\n    vector<string> res;\\n    void getCombinationsRecursively(int index,string &digits,string &temp){\\n        if(index==digits.size()) {res.push_back(temp);return;}\\n        \\n        for(auto c:mp[digits[index] -\\'0\\']){\\n            temp.push_back(c);\\n            getCombinationsRecursively(index+1,digits,temp);\\n            temp.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.length()==0)return res;\\n        string temp = \"\";\\n        getCombinationsRecursively(0,digits,temp);\\n        return res;\\n    }\\n};\\n```\\n\\n\\n* Greate approach taken idea from [https://leetcode.com/problems/letter-combinations-of-a-phone-number/discuss/2729877/C%2B%2B-Faster-Simple-Solution](http://)\\n\\n```\\n\\nclass Solution{\\n    public:\\n        vector<string> letterCombinations(string digits){\\n            \\n            vector<string> mp { \"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\" },ans;\\n    \\n            for (int i = 0; i < digits.size(); i++){\\n                int n = ans.size();\\n                for (int j = 0; j < mp[digits[i] - \\'0\\'].size(); j++) {\\n                    string str = mp[digits[i] - \\'0\\'];\\n\\n                    if (i == 0){\\n                        string s = \"\";\\n                        s += str[j];\\n                        ans.push_back(s);\\n                    }\\n                    else{\\n\\n                        for (int k = 0; k < n; k++){\\n                            if (j == 0)ans[k] += str[j];\\n                            else {\\n                                string ss = ans[k];\\n                                ss.pop_back();\\n                                ss += str[j];\\n                                ans.push_back(ss);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```\\n* Smaller version of above sol by using some extra space.\\n```\\n/*\\nsame as above but short and uses extra storage instead of storing previous value of n to repeat different characters \\nwith previous character instead of using the tmp value which is swaped here in this case. This helps in making code litle bit short \\n*/ \\n\\nuint64_t timeSinceEpochMillisec() {\\n  using namespace std::chrono;\\n  return duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();\\n}\\nclass Solution {\\npublic:\\n    const vector<string> mp = {\\n        \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\\n        \"mno\", \"pqrs\", \"tuv\", \"wxyz\"\\n    };\\n    \\n    vector<string> letterCombinations(string digits) {\\n        if (digits.empty()) return {};\\n    uint64_t t1 = timeSinceEpochMillisec();\\n      vector<string> result{\"\"};\\n      for (auto digit : digits)\\n      {\\n        vector<string> tmp;\\n        for (auto candidate : mp[digit - \\'0\\'])\\n        {\\n          for (auto s : result)\\n            tmp.push_back(s + candidate);\\n        }\\n        result.swap(tmp);\\n      }\\n\\n      // for(auto it:result) cout<<it<<\" \"; cout<<endl;\\n      uint64_t t2 = timeSinceEpochMillisec();\\n      cout<<t2-t1<<endl;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<string> letterCombinations(string d){\\n      unordered_map<char, string> mp;\\n      mp[\\'2\\'] = \"abc\";\\n      mp[\\'3\\'] = \"def\";\\n      mp[\\'4\\'] = \"ghi\";\\n      mp[\\'5\\'] = \"jkl\";\\n      mp[\\'6\\'] = \"mno\";\\n      mp[\\'7\\'] = \"pqrs\";\\n      mp[\\'8\\'] = \"tuv\";\\n      mp[\\'9\\'] = \"wxyz\";\\n        \\n      int n = d.size(),i = 0; vector<string> res;\\n      string one = mp[d[i]];\\n      for (int j = 0; j < one.size(); j++){\\n          string temp1 = \"\";\\n          temp1.push_back(one[j]);\\n          if (i + 1 < n){\\n          \\n              string two = mp[d[i + 1]];\\n          \\n              for (int k = 0; k < two.size(); k++){\\n            \\n                  string temp2 = temp1;\\n            \\n                  temp2.push_back(two[k]);\\n                  if (i + 2 < n){\\n              \\n                      string three = mp[d[i + 2]];\\n\\n                      for (int l = 0; l < three.size(); l++){\\n\\n                          string temp3 = temp2;\\n\\n                          temp3.push_back(three[l]);\\n                          if (i + 3 < n){\\n\\n                              string four = mp[d[i + 3]];\\n\\n                              for (int m = 0; m < four.size(); m++){\\n                                  string temp4 = temp3;\\n                                  temp4.push_back(four[m]);\\n                                  res.push_back(temp4);\\n                              }\\n                          }else res.push_back(temp3);\\n                      }\\n                  }else res.push_back(temp2);\\n              }\\n          }else res.push_back(temp1);\\n      }\\n      return res;\\n    }\\n};\\n```\n```\\nconst vector<string> mp = {\\n    \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\\n    \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\nclass Solution {\\n    vector<string> res;\\n    void getCombinationsRecursively(int index,string &digits,string &temp){\\n        if(index==digits.size()) {res.push_back(temp);return;}\\n        \\n        for(auto c:mp[digits[index] -\\'0\\']){\\n            temp.push_back(c);\\n            getCombinationsRecursively(index+1,digits,temp);\\n            temp.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.length()==0)return res;\\n        string temp = \"\";\\n        getCombinationsRecursively(0,digits,temp);\\n        return res;\\n    }\\n};\\n```\n```\\n\\nclass Solution{\\n    public:\\n        vector<string> letterCombinations(string digits){\\n            \\n            vector<string> mp { \"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\" },ans;\\n    \\n            for (int i = 0; i < digits.size(); i++){\\n                int n = ans.size();\\n                for (int j = 0; j < mp[digits[i] - \\'0\\'].size(); j++) {\\n                    string str = mp[digits[i] - \\'0\\'];\\n\\n                    if (i == 0){\\n                        string s = \"\";\\n                        s += str[j];\\n                        ans.push_back(s);\\n                    }\\n                    else{\\n\\n                        for (int k = 0; k < n; k++){\\n                            if (j == 0)ans[k] += str[j];\\n                            else {\\n                                string ss = ans[k];\\n                                ss.pop_back();\\n                                ss += str[j];\\n                                ans.push_back(ss);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```\n```\\n/*\\nsame as above but short and uses extra storage instead of storing previous value of n to repeat different characters \\nwith previous character instead of using the tmp value which is swaped here in this case. This helps in making code litle bit short \\n*/ \\n\\nuint64_t timeSinceEpochMillisec() {\\n  using namespace std::chrono;\\n  return duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();\\n}\\nclass Solution {\\npublic:\\n    const vector<string> mp = {\\n        \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\\n        \"mno\", \"pqrs\", \"tuv\", \"wxyz\"\\n    };\\n    \\n    vector<string> letterCombinations(string digits) {\\n        if (digits.empty()) return {};\\n    uint64_t t1 = timeSinceEpochMillisec();\\n      vector<string> result{\"\"};\\n      for (auto digit : digits)\\n      {\\n        vector<string> tmp;\\n        for (auto candidate : mp[digit - \\'0\\'])\\n        {\\n          for (auto s : result)\\n            tmp.push_back(s + candidate);\\n        }\\n        result.swap(tmp);\\n      }\\n\\n      // for(auto it:result) cout<<it<<\" \"; cout<<endl;\\n      uint64_t t2 = timeSinceEpochMillisec();\\n      cout<<t2-t1<<endl;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2579285,
                "title": "golang-0ms-branchless-2-loops",
                "content": "```\\nfunc letterCombinations(digits string) []string {\\n\\tif len(digits) == 0 {\\n\\t\\treturn []string{}\\n\\t}\\n\\talpha := map[rune]string{\\n\\t\\t\\'2\\': \"abc\",\\n\\t\\t\\'3\\': \"def\",\\n\\t\\t\\'4\\': \"ghi\",\\n\\t\\t\\'5\\': \"jkl\",\\n\\t\\t\\'6\\': \"mno\",\\n\\t\\t\\'7\\': \"pqrs\",\\n\\t\\t\\'8\\': \"tuv\",\\n\\t\\t\\'9\\': \"wxyz\",\\n\\t}\\n\\tsize := 1\\n\\tfor _, d := range digits {\\n\\t\\tsize *= len(alpha[d])\\n\\t}\\n\\tres := make([]string, size)\\n\\tfor _, d := range digits {\\n\\t\\tcurr := alpha[d]\\n\\t\\tsize /= len(curr)\\n        for i := range res {\\n\\t\\t\\tres[i] += string(curr[(i/size)%len(curr)])\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc letterCombinations(digits string) []string {\\n\\tif len(digits) == 0 {\\n\\t\\treturn []string{}\\n\\t}\\n\\talpha := map[rune]string{\\n\\t\\t\\'2\\': \"abc\",\\n\\t\\t\\'3\\': \"def\",\\n\\t\\t\\'4\\': \"ghi\",\\n\\t\\t\\'5\\': \"jkl\",\\n\\t\\t\\'6\\': \"mno\",\\n\\t\\t\\'7\\': \"pqrs\",\\n\\t\\t\\'8\\': \"tuv\",\\n\\t\\t\\'9\\': \"wxyz\",\\n\\t}\\n\\tsize := 1\\n\\tfor _, d := range digits {\\n\\t\\tsize *= len(alpha[d])\\n\\t}\\n\\tres := make([]string, size)\\n\\tfor _, d := range digits {\\n\\t\\tcurr := alpha[d]\\n\\t\\tsize /= len(curr)\\n        for i := range res {\\n\\t\\t\\tres[i] += string(curr[(i/size)%len(curr)])\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2193915,
                "title": "python-dictionary-approach",
                "content": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        m = {2:\\'abc\\', 3:\\'def\\', 4:\\'ghi\\', 5:\\'jkl\\', 6:\\'mno\\', 7:\\'pqrs\\', 8:\\'tuv\\', 9:\\'wxyz\\'}\\n        result = [\\'\\'] if len(digits)>0 else []\\n        for num in digits:\\n            temp = []\\n            for char in result:\\n                for c in m[int(num)]:\\n                    temp.append(char+c)\\n            result = temp\\n        return result\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        m = {2:\\'abc\\', 3:\\'def\\', 4:\\'ghi\\', 5:\\'jkl\\', 6:\\'mno\\', 7:\\'pqrs\\', 8:\\'tuv\\', 9:\\'wxyz\\'}\\n        result = [\\'\\'] if len(digits)>0 else []\\n        for num in digits:\\n            temp = []\\n            for char in result:\\n                for c in m[int(num)]:\\n                    temp.append(char+c)\\n            result = temp\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111339,
                "title": "17-letter-combinations-of-a-phone-number",
                "content": "First I create a map to store the string as value along a number as key i.e. if key = \\'2\\', value = \"abc\".\\n\\nArrayList list is used to store all the combination and String str in the combination method is used to store tha string that can be entered till current index.\\n\\nNow traverse the string digits for every index and then find the different character for that number that we can enter like for number 2, we can enter either a, b or c. and then call the method for next index and if we cover all the indexes, add that into the list.\\n\\nclass Solution {\\n    \\n    Map<Character, String> map;\\n    List<String> list;\\n    public List<String> letterCombinations(String digits) {\\n        \\n        list = new ArrayList<>();\\n        if(digits.length() == 0) return list;\\n        \\n        map = new HashMap<>();\\n        map.put(\\'2\\', \"abc\");\\n        map.put(\\'3\\', \"def\");\\n        map.put(\\'4\\', \"ghi\");\\n        map.put(\\'5\\', \"jkl\");\\n        map.put(\\'6\\', \"mno\");\\n        map.put(\\'7\\', \"pqrs\");\\n        map.put(\\'8\\', \"tuv\");\\n        map.put(\\'9\\', \"wxyz\");\\n        \\n        combination(digits, 0, \"\");\\n        \\n        return list;\\n    }\\n    \\n    void combination(String digits, int i, String str){\\n        \\n        if(i == digits.length()){\\n            \\n            list.add(str);\\n            return;\\n        }\\n        \\n        for(char ch: map.get(digits.charAt(i)).toCharArray()){\\n            \\n            combination(digits, i+1, str + ch);\\n        }\\n    }\\n}\\n\\nPlease upvote if you like the solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    Map<Character, String> map;\\n    List<String> list;\\n    public List<String> letterCombinations(String digits) {\\n        \\n        list = new ArrayList<>();\\n        if(digits.length() == 0) return list;\\n        \\n        map = new HashMap<>();\\n        map.put(\\'2\\', \"abc\");\\n        map.put(\\'3\\', \"def\");\\n        map.put(\\'4\\', \"ghi\");\\n        map.put(\\'5\\', \"jkl\");\\n        map.put(\\'6\\', \"mno\");\\n        map.put(\\'7\\', \"pqrs\");\\n        map.put(\\'8\\', \"tuv\");\\n        map.put(\\'9\\', \"wxyz\");\\n        \\n        combination(digits, 0, \"\");\\n        \\n        return list;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1791982,
                "title": "java-easy-solution-with-tree-explaination",
                "content": "\\n\\n**//please upvote if you find this helpful**\\n\\n![image](https://assets.leetcode.com/users/images/1bf04bb2-8ed4-42a4-a458-3b95ca38155e_1645545702.4415307.jpeg)\\n\\n\\nclass Solution {\\n\\n    public List<String> letterCombinations(String digits) {\\n        String[] words = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        List<String>ans = new ArrayList<>();\\n        letter(digits,\"\",ans,words);\\n        if(ans.size() == 1){\\n            ans = new ArrayList<>();\\n        }\\n        return ans;\\n    }\\n    public void letter(String digits,String ans,List<String>a,String[] words){\\n        if(digits.length() == 0){\\n            a.add(ans);\\n            return;\\n        }\\n        char ch = digits.charAt(0);\\n        int x = ch - \\'0\\';\\n        String word = words[x];\\n        for(int i=0; i<word.length(); i++){\\n            char ch1 = word.charAt(i);\\n            letter(digits.substring(1),ans+ch1,a,words);\\n        }\\n    }\\n}\\n\\n\\n**//please upvote if you find this helpful**",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public List<String> letterCombinations(String digits) {\\n        String[] words = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}",
                "codeTag": "Java"
            },
            {
                "id": 1683676,
                "title": "python-easy-to-understand-solution-20-ms-faster-than-99-40",
                "content": "\\tdef letterCombinations(self, digits: str) -> List[str]:\\n        \\n        hashmap = {\\n            \\'2\\':\"abc\",\\n            \\'3\\':\"def\",\\n            \\'4\\':\"ghi\",\\n            \\'5\\':\"jkl\",\\n            \\'6\\':\"mno\",\\n            \\'7\\':\"pqrs\",\\n            \\'8\\':\"tuv\",\\n            \\'9\\':\"wxyz\"\\n        }\\n        result = []\\n        \\n        if len(digits) == 0:\\n            return []\\n        \\n        def backtrack(index,path):\\n            if len(digits) == len(path):\\n                result.append(\"\".join(path))\\n                return\\n            \\n            letters = hashmap[digits[index]]\\n            \\n            for letter in letters:\\n                path.append(letter)\\n                backtrack(index+1,path)\\n                path.pop()\\n            \\n        backtrack(0,[])\\n        return result\\n\\n Please Upvote if you like the solution\\n![image](https://assets.leetcode.com/users/images/d32a9128-95dd-454b-b170-c6cb3e79a267_1641933915.5009716.png)\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "\\tdef letterCombinations(self, digits: str) -> List[str]:\\n        \\n        hashmap = {\\n            \\'2\\':\"abc\",\\n            \\'3\\':\"def\",\\n            \\'4\\':\"ghi\",\\n            \\'5\\':\"jkl\",\\n            \\'6\\':\"mno\",\\n            \\'7\\':\"pqrs\",\\n            \\'8\\':\"tuv\",\\n            \\'9\\':\"wxyz\"\\n        }\\n        result = []\\n        \\n        if len(digits) == 0:\\n            return []\\n        \\n        def backtrack(index,path):\\n            if len(digits) == len(path):\\n                result.append(\"\".join(path))\\n                return\\n            \\n            letters = hashmap[digits[index]]\\n            \\n            for letter in letters:\\n                path.append(letter)\\n                backtrack(index+1,path)\\n                path.pop()\\n            \\n        backtrack(0,[])\\n        return result\\n\\n Please Upvote if you like the solution\\n![image](https://assets.leetcode.com/users/images/d32a9128-95dd-454b-b170-c6cb3e79a267_1641933915.5009716.png)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1343036,
                "title": "easy-c-faster-than-100-simple-recursion-backtracking",
                "content": "# Approach\\n1. Here we first make an array with all possible key words when we recieve the digtis\\n2. Then by using recursion and backtracking we get all the possible combinations (Function Solve)\\n ```\\nclass Solution {\\npublic:\\n    //All letters that can be used\\n    char keypad[10][10] = {\"\", \"\" , \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    vector<string> letterCombinations(string digits) \\n    {\\n        vector<string> ans;\\n        string words = \"\" ;\\n        if(digits.size() == 0) \\n        {\\n            //No Combination will be made\\n            return ans ;\\n        }  \\n        solve(digits , ans, words, 0) ;\\n        return ans ;\\n    }\\n    \\n    void solve(string digits, vector<string> &ans, string words, int i ) \\n    {\\n\\t    // Base Case\\n        if(i >= digits.size()) \\n        {\\n            ans.push_back(words) ;\\n            words = \"\" ;\\n            return ;\\n        }\\n\\t\\t// Extracting the digit \\n        int digit = digits[i] - \\'0\\' ;\\n        if(digit == 0 || digit == 1) \\n        {\\n            //Using recursion\\n            solve(digits, ans, words, i+1) ;\\n        }\\n        for(int k=0; keypad[digit][k] != \\'\\\\0\\'; k++) \\n        {\\n            words.push_back(keypad[digit][k]);  // push back the current char from keypad codes array\\n            solve(digits, ans, words, i+1) ;   // Recursive call for next index\\n            words.pop_back() ;  // Backtracking\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //All letters that can be used\\n    char keypad[10][10] = {\"\", \"\" , \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    vector<string> letterCombinations(string digits) \\n    {\\n        vector<string> ans;\\n        string words = \"\" ;\\n        if(digits.size() == 0) \\n        {\\n            //No Combination will be made\\n            return ans ;\\n        }  \\n        solve(digits , ans, words, 0) ;\\n        return ans ;\\n    }\\n    \\n    void solve(string digits, vector<string> &ans, string words, int i ) \\n    {\\n\\t    // Base Case\\n        if(i >= digits.size()) \\n        {\\n            ans.push_back(words) ;\\n            words = \"\" ;\\n            return ;\\n        }\\n\\t\\t// Extracting the digit \\n        int digit = digits[i] - \\'0\\' ;\\n        if(digit == 0 || digit == 1) \\n        {\\n            //Using recursion\\n            solve(digits, ans, words, i+1) ;\\n        }\\n        for(int k=0; keypad[digit][k] != \\'\\\\0\\'; k++) \\n        {\\n            words.push_back(keypad[digit][k]);  // push back the current char from keypad codes array\\n            solve(digits, ans, words, i+1) ;   // Recursive call for next index\\n            words.pop_back() ;  // Backtracking\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243934,
                "title": "python-straightforward-solution-with-recursion-explained",
                "content": "1.  First of all, allocate a chunk of memory to a newly created array ans, which will be used to store all combinations of letters.\\n2.  Then use DFS (depth-first-search) to explore all possibilities for a given phone number, (DFS is an algorithm using backtracking, recursion is one approach to realize DFS).\\n3.  Recursion has three major components: (1) Definition (2) Stopping Criteria (3) Transition.  In order to solve a DFS problem, we need to first think about what parameters are during recursion and when to stop recursion and what the transition looks like. A rule of thumb for a good definition is to only focus on parameters that are relevant to our problem-solving without including irrelevant ones. Second, we need to think about the stopping criteria in which if the function meets a given crteria, it has to stop without recursively call the function forever. Once the stopping criteria is met, the call stack must pop up the top-most function and return its value, (call stack can be thought as a box of memory to store values for all variables for each recursive call). Last but not least, transition is how the function moves towards the stopping criteria. Usually it is the hardest part to figure out and captures the essence of a problem.\\n4.  Let\\'s go back to this problem. When doing recursion, a call stack is created. In each recursive call, we store the index, current combination as combinations. When index equals the length of digits, pop up the top-most function and return its value. After we exhaust all combinations, the recursion is over and return our result. It will take O(3^n * n) time, O(3^n) space since it has O(3^n) cases with each takes O(n) time. \\n\\n\\n```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        ans = []\\n        if not digits:\\n            return []\\n        \\n        self.dfs(digits, 0, \"\", ans)\\n        return ans \\n    \\n    \\n    \\n    def dfs(self, digits, index, combination, combinations):\\n        digit_mapping = {0:\"\", 1:\"\", 2:\"abc\", 3:\"def\", 4:\"ghi\", 5:\"jkl\", 6:\"mno\", 7:\"pqrs\", 8:\"tuv\", 9:\"wxyz\"}\\n        if index == len(digits):\\n            combinations.append(combination)\\n            return;\\n        \\n        digit = int(digits[index])\\n        letters = digit_mapping[digit]\\n        for i in range(len(letters)):\\n            self.dfs(digits, index+1, combination+letters[i], combinations)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        ans = []\\n        if not digits:\\n            return []\\n        \\n        self.dfs(digits, 0, \"\", ans)\\n        return ans \\n    \\n    \\n    \\n    def dfs(self, digits, index, combination, combinations):\\n        digit_mapping = {0:\"\", 1:\"\", 2:\"abc\", 3:\"def\", 4:\"ghi\", 5:\"jkl\", 6:\"mno\", 7:\"pqrs\", 8:\"tuv\", 9:\"wxyz\"}\\n        if index == len(digits):\\n            combinations.append(combination)\\n            return;\\n        \\n        digit = int(digits[index])\\n        letters = digit_mapping[digit]\\n        for i in range(len(letters)):\\n            self.dfs(digits, index+1, combination+letters[i], combinations)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047548,
                "title": "faster-than-100-c-submissions",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    void helper(string digit,string tmp,vector<string>&v,vector<string>&aux,int index)\\n    {\\n        if(index==digit.length())\\n        {\\n            v.push_back(tmp);\\n            return;\\n        }\\n        for(int i=0;i<aux[digit[index]-\\'0\\'].length();i++)\\n        {\\n            tmp.push_back(aux[digit[index]-\\'0\\'][i]);\\n            helper(digit,tmp,v,aux,index+1);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) \\n    {\\n        if(digits.length()==0)\\n        {\\n            return {};\\n        }\\n        vector<string>aux={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"prqs\",\"tuv\",\"wxyz\"},ans;\\n        helper(digits,\"\",ans,aux,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void helper(string digit,string tmp,vector<string>&v,vector<string>&aux,int index)\\n    {\\n        if(index==digit.length())\\n        {\\n            v.push_back(tmp);\\n            return;\\n        }\\n        for(int i=0;i<aux[digit[index]-\\'0\\'].length();i++)\\n        {\\n            tmp.push_back(aux[digit[index]-\\'0\\'][i]);\\n            helper(digit,tmp,v,aux,index+1);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) \\n    {\\n        if(digits.length()==0)\\n        {\\n            return {};\\n        }\\n        vector<string>aux={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"prqs\",\"tuv\",\"wxyz\"},ans;\\n        helper(digits,\"\",ans,aux,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994268,
                "title": "simple-python-runtime-99-96-memory-94-32",
                "content": "```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        if digits == \"\":\\n            return []\\n        \\n        def getChars(d):\\n            if d == \\'2\\':\\n                return [\\'a\\', \\'b\\', \\'c\\']\\n            elif d == \\'3\\':\\n                return [\\'d\\', \\'e\\', \\'f\\']\\n            elif d == \\'4\\':\\n                return [\\'g\\', \\'h\\', \\'i\\']\\n            elif d == \\'5\\':\\n                return [\\'j\\', \\'k\\', \\'l\\']\\n            elif d == \\'6\\':\\n                return [\\'m\\', \\'n\\', \\'o\\']\\n            elif d == \\'7\\':\\n                return [\\'p\\', \\'q\\', \\'r\\', \\'s\\']\\n            elif d == \\'8\\':\\n                return [\\'t\\', \\'u\\', \\'v\\']\\n            elif d == \\'9\\':\\n                return [\\'w\\', \\'x\\', \\'y\\', \\'z\\']\\n                \\n        array = getChars(digits[0])\\n        \\n        if len(digits) == 1:\\n            return array\\n        \\n        for d in digits[1:]:\\n            chars = getChars(d)\\n            newArray = []\\n            for a in array:\\n                for c in chars:\\n                    newArray.append(a+c)\\n            array = newArray\\n        return array\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        if digits == \"\":\\n            return []\\n        \\n        def getChars(d):\\n            if d == \\'2\\':\\n                return [\\'a\\', \\'b\\', \\'c\\']\\n            elif d == \\'3\\':\\n                return [\\'d\\', \\'e\\', \\'f\\']\\n            elif d == \\'4\\':\\n                return [\\'g\\', \\'h\\', \\'i\\']\\n            elif d == \\'5\\':\\n                return [\\'j\\', \\'k\\', \\'l\\']\\n            elif d == \\'6\\':\\n                return [\\'m\\', \\'n\\', \\'o\\']\\n            elif d == \\'7\\':\\n                return [\\'p\\', \\'q\\', \\'r\\', \\'s\\']\\n            elif d == \\'8\\':\\n                return [\\'t\\', \\'u\\', \\'v\\']\\n            elif d == \\'9\\':\\n                return [\\'w\\', \\'x\\', \\'y\\', \\'z\\']\\n                \\n        array = getChars(digits[0])\\n        \\n        if len(digits) == 1:\\n            return array\\n        \\n        for d in digits[1:]:\\n            chars = getChars(d)\\n            newArray = []\\n            for a in array:\\n                for c in chars:\\n                    newArray.append(a+c)\\n            array = newArray\\n        return array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852249,
                "title": "c-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<char,vector<string> > mp;\\n    vector<string> ans;\\n   void f_backtrack(int start, string curr, string digits)\\n{\\n\\tint n = digits.size();\\n\\tif(start==n)\\n\\t{\\n\\t\\tans.push_back(curr);\\n\\t\\t\\n\\t}\\n\\tvector<string> vect = mp[digits[start]];\\n\\tfor(int i=0; i<vect.size(); i++)\\n\\t{\\n\\t\\tstring s = vect[i];\\n\\t\\tcurr += s;\\n\\t\\tf_backtrack(start+1,curr,digits);\\n\\t\\tcurr.pop_back();\\n\\t}\\n}\\nvector<string> letterCombinations(string digits) {\\n\\tif(digits==\"\")\\n\\t{\\n\\t\\tvector<string> vect;\\n\\t\\treturn vect;\\n\\t}\\n\\t\\n\\tmp[\\'2\\'] = {\"a\",\"b\",\"c\"};\\n\\tmp[\\'3\\'] = {\"d\",\"e\",\"f\"};\\n\\tmp[\\'4\\'] = {\"g\",\"h\",\"i\"};\\n\\tmp[\\'5\\'] = {\"j\",\"k\",\"l\"};\\n\\tmp[\\'6\\'] = {\"m\",\"n\",\"o\"};\\n\\tmp[\\'7\\'] = {\"p\",\"q\",\"r\",\"s\"};\\n\\tmp[\\'8\\'] = {\"t\",\"u\",\"v\"};\\n\\tmp[\\'9\\'] = {\"w\",\"x\",\"y\",\"z\"};\\n\\tf_backtrack(0,\"\",digits);\\n\\treturn ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<char,vector<string> > mp;\\n    vector<string> ans;\\n   void f_backtrack(int start, string curr, string digits)\\n{\\n\\tint n = digits.size();\\n\\tif(start==n)\\n\\t{\\n\\t\\tans.push_back(curr);\\n\\t\\t\\n\\t}\\n\\tvector<string> vect = mp[digits[start]];\\n\\tfor(int i=0; i<vect.size(); i++)\\n\\t{\\n\\t\\tstring s = vect[i];\\n\\t\\tcurr += s;\\n\\t\\tf_backtrack(start+1,curr,digits);\\n\\t\\tcurr.pop_back();\\n\\t}\\n}\\nvector<string> letterCombinations(string digits) {\\n\\tif(digits==\"\")\\n\\t{\\n\\t\\tvector<string> vect;\\n\\t\\treturn vect;\\n\\t}\\n\\t\\n\\tmp[\\'2\\'] = {\"a\",\"b\",\"c\"};\\n\\tmp[\\'3\\'] = {\"d\",\"e\",\"f\"};\\n\\tmp[\\'4\\'] = {\"g\",\"h\",\"i\"};\\n\\tmp[\\'5\\'] = {\"j\",\"k\",\"l\"};\\n\\tmp[\\'6\\'] = {\"m\",\"n\",\"o\"};\\n\\tmp[\\'7\\'] = {\"p\",\"q\",\"r\",\"s\"};\\n\\tmp[\\'8\\'] = {\"t\",\"u\",\"v\"};\\n\\tmp[\\'9\\'] = {\"w\",\"x\",\"y\",\"z\"};\\n\\tf_backtrack(0,\"\",digits);\\n\\treturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745235,
                "title": "best-explanation-of-the-approach-with-code-js-and-java",
                "content": "**Observe**\\n\\nThis is a straightforward recursion question that asks to search for all combinations.\\n\\nThe idea is, for each digit, we give it 1 of the 3 or 4 matching letters.\\nThen, we recurse on the next digit, giving it a letter, and moving on until we reach the terminal condition, that is the end of the digits string.\\n\\nThe question asks to return a list of combinations, which can be tricky and unoptimized if we are not careful.\\n\\n**Insights:**\\nStay away from heavy array operations such as shallow copying. Concatenating arrays, in some languages, do it the heavy way where it shallow copies the arrays and reconstructs the merged one.\\n\\n**Algorithm**\\n\\nCreate a findCombinations recursion function that takes in index and iterates through the matching letters for the digit at index. For each letter, recursively call findCombinations for index+1.\\nTerminal condition: we reach the end of the digits string.\\nThe output array is passed by reference to findCombinations. We push any found result directly to this array, so no extra array operations are required.\\nBecause each output contains the letter replacement for all the digits, we need to pass this data along as we recurse.\\n\\n**Code**\\n\\n```\\nconst DIGIT_TO_LETTERS = {\\n  2: \\'abc\\',\\n  3: \\'def\\',\\n  4: \\'ghi\\',\\n  5: \\'jkl\\',\\n  6: \\'mno\\',\\n  7: \\'pqrs\\',\\n  8: \\'tuv\\',\\n  9: \\'wxyz\\',\\n}\\n/**\\n * @param {string} digits\\n * @return {Array<string>}\\n */\\nfunction letterCombinations(digits) {\\n  // Handles edge case.\\n  if (digits == \"\") {\\n    return [];\\n  }\\n  const output = [];\\n  findCombinations(digits, 0, \\'\\', output);\\n  return output;\\n};\\n/**\\n * @param {string} digits\\n * @param {Number} index\\n * @param {string] prefix The first part of the output string.\\n * @param {Array<string>} The output array that will be modified.\\n */\\nfunction findCombinations(digits, index, prefix, output) {\\n  // Handles terminal condition.\\n  if (index == digits.length) {\\n    output.push(prefix);\\n    return;\\n  }\\n  // Picks a letter, then recurses on the next digit.\\n  const letters = DIGIT_TO_LETTERS[digits[index]];\\n  for (let i = 0; i < letters.length; i++) {\\n    findCombinations(digits, index + 1, prefix + letters[i], output);\\n  }\\n}\\n```\\n\\n**Complexity Analysis**\\n\\nLet N be the length of the digits string.\\nEach digit can be replaced by at most 4 letters, so the total number of combinations is 4^N.\\nHence, the time complexity is O(4^N).\\nSo there contains other optimized solutions using BFS to process the earlier characters and multiply with them with the selected character and again push into the queue until all the digits of the number is processed.\\n```\\n\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n       LinkedList<String> out_arr = new LinkedList();\\n       if(digits.length() == 0){\\n           return out_arr;\\n       }\\n       out_arr.add(\"\");\\n       String[] char_map = new String[]{\\n           \"0\",\\n           \"1\",\\n           \"abc\",\\n           \"def\",\\n           \"ghi\",\\n           \"jkl\",\\n           \"mno\",\\n           \"pqrs\",\\n           \"tuv\",\\n           \"wxyz\"\\n       };\\n       for(int i = 0; i < digits.length(); i++){\\n           int index = Character.getNumericValue(digits.charAt(i));\\n           while(out_arr.peek().length() == i){\\n               String permulation = out_arr.remove();\\n               for(char c : char_map[index].toCharArray()){\\n                   out_arr.add(permulation+c);\\n               }\\n           }\\n       }\\n       return out_arr;\\n    }\\n}\\n```\\n**Link to my origin post: ** [medium blog](https://medium.com/@sarthak.acoustic/solution-letter-combinations-on-phones-keypad-17f3368b1f5d)",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nconst DIGIT_TO_LETTERS = {\\n  2: \\'abc\\',\\n  3: \\'def\\',\\n  4: \\'ghi\\',\\n  5: \\'jkl\\',\\n  6: \\'mno\\',\\n  7: \\'pqrs\\',\\n  8: \\'tuv\\',\\n  9: \\'wxyz\\',\\n}\\n/**\\n * @param {string} digits\\n * @return {Array<string>}\\n */\\nfunction letterCombinations(digits) {\\n  // Handles edge case.\\n  if (digits == \"\") {\\n    return [];\\n  }\\n  const output = [];\\n  findCombinations(digits, 0, \\'\\', output);\\n  return output;\\n};\\n/**\\n * @param {string} digits\\n * @param {Number} index\\n * @param {string] prefix The first part of the output string.\\n * @param {Array<string>} The output array that will be modified.\\n */\\nfunction findCombinations(digits, index, prefix, output) {\\n  // Handles terminal condition.\\n  if (index == digits.length) {\\n    output.push(prefix);\\n    return;\\n  }\\n  // Picks a letter, then recurses on the next digit.\\n  const letters = DIGIT_TO_LETTERS[digits[index]];\\n  for (let i = 0; i < letters.length; i++) {\\n    findCombinations(digits, index + 1, prefix + letters[i], output);\\n  }\\n}\\n```\n```\\n\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n       LinkedList<String> out_arr = new LinkedList();\\n       if(digits.length() == 0){\\n           return out_arr;\\n       }\\n       out_arr.add(\"\");\\n       String[] char_map = new String[]{\\n           \"0\",\\n           \"1\",\\n           \"abc\",\\n           \"def\",\\n           \"ghi\",\\n           \"jkl\",\\n           \"mno\",\\n           \"pqrs\",\\n           \"tuv\",\\n           \"wxyz\"\\n       };\\n       for(int i = 0; i < digits.length(); i++){\\n           int index = Character.getNumericValue(digits.charAt(i));\\n           while(out_arr.peek().length() == i){\\n               String permulation = out_arr.remove();\\n               for(char c : char_map[index].toCharArray()){\\n                   out_arr.add(permulation+c);\\n               }\\n           }\\n       }\\n       return out_arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574384,
                "title": "c-easy",
                "content": "```\\npublic class Solution {\\n    public IList<string> LetterCombinations(string digits) {\\n       IList<string> res = new List<string>();\\n            if (string.IsNullOrEmpty(digits))\\n            {\\n                return res;\\n            }\\n         \\n          // initilizing the input dictionay \\n            Dictionary<Char, char[]> lettersMap = new Dictionary<Char, char[]>();\\n            lettersMap.Add(\\'1\\', null);\\n            lettersMap.Add(\\'2\\', new[] { \\'a\\', \\'b\\', \\'c\\' });\\n            lettersMap.Add(\\'3\\', new[] { \\'d\\', \\'e\\', \\'f\\' });\\n            lettersMap.Add(\\'4\\', new[] { \\'g\\', \\'h\\', \\'i\\' });\\n            lettersMap.Add(\\'5\\', new[] { \\'j\\', \\'k\\', \\'l\\' });\\n            lettersMap.Add(\\'6\\', new[] { \\'m\\', \\'n\\', \\'o\\' });\\n            lettersMap.Add(\\'7\\', new[] { \\'p\\', \\'q\\', \\'r\\', \\'s\\' });\\n            lettersMap.Add(\\'8\\', new[] { \\'t\\', \\'u\\', \\'v\\' });\\n            lettersMap.Add(\\'9\\', new[] { \\'w\\', \\'x\\', \\'y\\', \\'z\\' });\\n            lettersMap.Add(\\'0\\', null);\\n           \\n\\n           res.Add(\"\");\\n            foreach (char d in digits)\\n            {\\n                IList<string> next = new List<string>();\\n                var letterList = lettersMap.Where(x => x.Key == d).FirstOrDefault().Value;\\n                foreach (char letter in letterList)\\n                {\\n                    foreach (string s in res)\\n                    {\\n                        next.Add(s + letter);\\n                    }\\n                }\\n                res = next;\\n            }\\n\\n            return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> LetterCombinations(string digits) {\\n       IList<string> res = new List<string>();\\n            if (string.IsNullOrEmpty(digits))\\n            {\\n                return res;\\n            }\\n         \\n          // initilizing the input dictionay \\n            Dictionary<Char, char[]> lettersMap = new Dictionary<Char, char[]>();\\n            lettersMap.Add(\\'1\\', null);\\n            lettersMap.Add(\\'2\\', new[] { \\'a\\', \\'b\\', \\'c\\' });\\n            lettersMap.Add(\\'3\\', new[] { \\'d\\', \\'e\\', \\'f\\' });\\n            lettersMap.Add(\\'4\\', new[] { \\'g\\', \\'h\\', \\'i\\' });\\n            lettersMap.Add(\\'5\\', new[] { \\'j\\', \\'k\\', \\'l\\' });\\n            lettersMap.Add(\\'6\\', new[] { \\'m\\', \\'n\\', \\'o\\' });\\n            lettersMap.Add(\\'7\\', new[] { \\'p\\', \\'q\\', \\'r\\', \\'s\\' });\\n            lettersMap.Add(\\'8\\', new[] { \\'t\\', \\'u\\', \\'v\\' });\\n            lettersMap.Add(\\'9\\', new[] { \\'w\\', \\'x\\', \\'y\\', \\'z\\' });\\n            lettersMap.Add(\\'0\\', null);\\n           \\n\\n           res.Add(\"\");\\n            foreach (char d in digits)\\n            {\\n                IList<string> next = new List<string>();\\n                var letterList = lettersMap.Where(x => x.Key == d).FirstOrDefault().Value;\\n                foreach (char letter in letterList)\\n                {\\n                    foreach (string s in res)\\n                    {\\n                        next.Add(s + letter);\\n                    }\\n                }\\n                res = next;\\n            }\\n\\n            return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481953,
                "title": "javascript",
                "content": "Runtime: 52 ms, faster than 75.11% of JavaScript online submissions for Letter Combinations of a Phone Number.\\nMemory Usage: 33.9 MB, less than 60.71% of JavaScript online submissions for Letter Combinations of a Phone Number.\\n\\n```\\nvar letterCombinations = function(digits) {\\n    if (digits.length === 0) {\\n      return [];\\n    }\\n    const digitMap = {\\n      \\'2\\': [\\'a\\', \\'b\\', \\'c\\'],\\n      \\'3\\': [\\'d\\', \\'e\\', \\'f\\'],\\n      \\'4\\': [\\'g\\', \\'h\\', \\'i\\'],\\n      \\'5\\': [\\'j\\', \\'k\\', \\'l\\'],\\n      \\'6\\': [\\'m\\', \\'n\\', \\'o\\'],\\n      \\'7\\': [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n      \\'8\\': [\\'t\\', \\'u\\', \\'v\\'],\\n      \\'9\\': [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n    };\\n    if(digits.length > 1) {\\n      const firstDigit = digits.slice(0, 1);\\n      const otherDigits = digits.slice(1);\\n      const otherLetterCombinations = letterCombinations(otherDigits);\\n      const firstDigitletters = digitMap[firstDigit];\\n      let resultArr = [];\\n      firstDigitletters.forEach(item1 => {\\n        otherLetterCombinations.forEach(item2 => {\\n          resultArr.push(item1 + item2);\\n        })\\n      })\\n      return resultArr;\\n    } else {\\n      return digitMap[digits];\\n    }\\n  };\\n```",
                "solutionTags": [],
                "code": "```\\nvar letterCombinations = function(digits) {\\n    if (digits.length === 0) {\\n      return [];\\n    }\\n    const digitMap = {\\n      \\'2\\': [\\'a\\', \\'b\\', \\'c\\'],\\n      \\'3\\': [\\'d\\', \\'e\\', \\'f\\'],\\n      \\'4\\': [\\'g\\', \\'h\\', \\'i\\'],\\n      \\'5\\': [\\'j\\', \\'k\\', \\'l\\'],\\n      \\'6\\': [\\'m\\', \\'n\\', \\'o\\'],\\n      \\'7\\': [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n      \\'8\\': [\\'t\\', \\'u\\', \\'v\\'],\\n      \\'9\\': [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n    };\\n    if(digits.length > 1) {\\n      const firstDigit = digits.slice(0, 1);\\n      const otherDigits = digits.slice(1);\\n      const otherLetterCombinations = letterCombinations(otherDigits);\\n      const firstDigitletters = digitMap[firstDigit];\\n      let resultArr = [];\\n      firstDigitletters.forEach(item1 => {\\n        otherLetterCombinations.forEach(item2 => {\\n          resultArr.push(item1 + item2);\\n        })\\n      })\\n      return resultArr;\\n    } else {\\n      return digitMap[digits];\\n    }\\n  };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181956,
                "title": "ac-2-line-c-solution",
                "content": "    public IList<string> LetterCombinations(string digits) {\n        var hash = new []{\" \", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        return digits.Aggregate(Enumerable.Empty<string>(), (sum, x) => (!sum.Any() ? new[] {\"\"} : sum).SelectMany(y => hash[x - '0'].Select(z => y + z))).ToArray();\n    }",
                "solutionTags": [],
                "code": "    public IList<string> LetterCombinations(string digits) {\n        var hash = new []{\" \", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        return digits.Aggregate(Enumerable.Empty<string>(), (sum, x) => (!sum.Any() ? new[] {\"\"} : sum).SelectMany(y => hash[x - '0'].Select(z => y + z))).ToArray();\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 8348,
                "title": "dfs-javascript-solution",
                "content": "    function letterCombinations(digits) {\\n        var map = ['0', '1', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'];\\n        var res = [];\\n        var prefix = [];\\n        \\n        if (digits.length) {\\n            traverse(0);\\n        }\\n        return res;\\n        \\n        function traverse(idx) {\\n            if (idx === digits.length) {\\n                return res.push(prefix.join(''));\\n            }\\n            \\n            var str = map[digits[idx] - '0'];\\n            \\n            for (var i = 0; i < str.length; i++) {\\n                prefix.push(str[i]);\\n                traverse(idx + 1);\\n                prefix.pop();\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "    function letterCombinations(digits) {\\n        var map = ['0', '1', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'];\\n        var res = [];\\n        var prefix = [];\\n        \\n        if (digits.length) {\\n            traverse(0);\\n        }\\n        return res;\\n        \\n        function traverse(idx) {\\n            if (idx === digits.length) {\\n                return res.push(prefix.join(''));\\n            }\\n            \\n            var str = map[digits[idx] - '0'];\\n            \\n            for (var i = 0; i < str.length; i++) {\\n                prefix.push(str[i]);\\n                traverse(idx + 1);\\n                prefix.pop();\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 8362,
                "title": "3-different-method-for-this-question-recursive-dfs-bfs-iterative-dfs",
                "content": "`dict` is defined as a map of digit to char array.\\n\\t\\n\\n    char[][] dict = { { 'a', 'b', 'c' }, { 'd', 'e', 'f' }, { 'g', 'h', 'i' }, { 'j', 'k', 'l' }, { 'm', 'n', 'o' },\\n    \\t\\t\\t{ 'p', 'q', 'r', 's' }, { 't', 'u', 'v' }, { 'w', 'x', 'y', 'z' } };\\n\\nrecursive dfs is the most easily understanding, in each recursion, we add the element with the `next recursion result`. The element , referring as character in this case, has to satisfy all conditions.  \\n\\n    /* DFS recursive */\\n    public void search(List<String> list, String str, int i, String digits, char[][] dict) {\\n    \\tif (i == digits.length()) {\\n    \\t\\tlist.add(str);\\n    \\t\\treturn;\\n    \\t}\\n    \\tchar[] candidates = dict[digits.charAt(i) - '2'];\\n    \\tfor (char c : candidates)\\n    \\t\\tsearch(list, str + \"\" + c, i + 1, digits, dict);\\n    }\\n\\nbfs solution solve iteratively by a queue. In each step, we fetch all the elements in the queue added by last step, and for each element , a new character is appended and then add back to the queue\\n \\n\\n    /* BFS */\\n    public List<String> searchFIFO(String digits, char[][] dict) {\\n    \\tQueue<String> queue = new LinkedList<String>();\\n    \\tfor (char c : dict[digits.charAt(0) - '2']) {\\n    \\t\\tqueue.add(\"\" + c);\\n    \\t}\\n    \\tfor (int step = 1; step < digits.length(); step++) {\\n    \\t\\tint size = queue.size();\\n    \\t\\twhile (size-- > 0) {\\n    \\t\\t\\tString lastLayerString = queue.poll();\\n    \\t\\t\\tfor (char c : dict[digits.charAt(step) - '2']) {\\n    \\t\\t\\t\\tqueue.add(lastLayerString + \"\" + c);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\t// System.out.println(queue);\\n    \\treturn new ArrayList<String>(queue);\\n    }\\n\\niteractive dfs is achieved by using a stack, this stack memorizes search status of each step, when `step==digists.length-1`, the search of this branch ends and we add the search result. when search of `step i` is done, which means `stack[i] ` exceeds limit value in `step i`, then trace back to `step i-1`. When seach of `step 0` is done, all search has been finished.\\n\\n    /* DFS iterative */\\n    public List<String> search(String digits, char[][] dict) {\\n    \\tList<String> list = new ArrayList<String>();\\n    \\tint[] stack = new int[digits.length()];\\n    \\tint step = 0;\\n    \\tchar[] result = new char[digits.length()];\\n    \\t// the limit number of choices in step 0\\n    \\tint limit0 = dict[digits.charAt(0) - '2'].length;\\n    \\twhile (stack[0] < limit0) {\\n    \\t\\tif (stack[step] == dict[digits.charAt(step) - '2'].length) {\\n    \\t\\t\\t// if No.step has reach its limit, then backtrack\\n    \\t\\t\\tstack[step] = 0;\\n    \\t\\t\\t// trace back to last step, and prepare to search the next\\n    \\t\\t\\t// choice\\n    \\t\\t\\tstack[--step]++;\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\tif (step == digits.length() - 1) {\\n    \\t\\t\\t// this search branch is end\\n    \\t\\t\\tfor (int i = 0; i <= step; i++) {\\n    \\t\\t\\t\\tresult[i] = dict[digits.charAt(i) - '2'][stack[i]];\\n    \\t\\t\\t}\\n    \\t\\t\\tlist.add(new String(result));\\n    \\t\\t\\tstack[step]++;\\n    \\t\\t} else {\\n    \\t\\t\\tstep++;\\n    \\t\\t}\\n    \\t}\\n    \\treturn list;\\n    }",
                "solutionTags": [],
                "code": "`dict` is defined as a map of digit to char array.\\n\\t\\n\\n    char[][] dict = { { 'a', 'b', 'c' }, { 'd', 'e', 'f' }, { 'g', 'h', 'i' }, { 'j', 'k', 'l' }, { 'm', 'n', 'o' },\\n    \\t\\t\\t{ 'p', 'q', 'r', 's' }, { 't', 'u', 'v' }, { 'w', 'x', 'y', 'z' } };\\n\\nrecursive dfs is the most easily understanding, in each recursion, we add the element with the `next recursion result`. The element , referring as character in this case, has to satisfy all conditions.  \\n\\n    /* DFS recursive */\\n    public void search(List<String> list, String str, int i, String digits, char[][] dict) {\\n    \\tif (i == digits.length()) {\\n    \\t\\tlist.add(str);\\n    \\t\\treturn;\\n    \\t}\\n    \\tchar[] candidates = dict[digits.charAt(i) - '2'];\\n    \\tfor (char c : candidates)\\n    \\t\\tsearch(list, str + \"\" + c, i + 1, digits, dict);\\n    }\\n\\nbfs solution solve iteratively by a queue. In each step, we fetch all the elements in the queue added by last step, and for each element , a new character is appended and then add back to the queue\\n \\n\\n    /* BFS */\\n    public List<String> searchFIFO(String digits, char[][] dict) {\\n    \\tQueue<String> queue = new LinkedList<String>();\\n    \\tfor (char c : dict[digits.charAt(0) - '2']) {\\n    \\t\\tqueue.add(\"\" + c);\\n    \\t}\\n    \\tfor (int step = 1; step < digits.length(); step++) {\\n    \\t\\tint size = queue.size();\\n    \\t\\twhile (size-- > 0) {\\n    \\t\\t\\tString lastLayerString = queue.poll();\\n    \\t\\t\\tfor (char c : dict[digits.charAt(step) - '2']) {\\n    \\t\\t\\t\\tqueue.add(lastLayerString + \"\" + c);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\t// System.out.println(queue);\\n    \\treturn new ArrayList<String>(queue);\\n    }\\n\\niteractive dfs is achieved by using a stack, this stack memorizes search status of each step, when `step==digists.length-1`, the search of this branch ends and we add the search result. when search of `step i` is done, which means `stack[i] ` exceeds limit value in `step i`, then trace back to `step i-1`. When seach of `step 0` is done, all search has been finished.\\n\\n    /* DFS iterative */\\n    public List<String> search(String digits, char[][] dict) {\\n    \\tList<String> list = new ArrayList<String>();\\n    \\tint[] stack = new int[digits.length()];\\n    \\tint step = 0;\\n    \\tchar[] result = new char[digits.length()];\\n    \\t// the limit number of choices in step 0\\n    \\tint limit0 = dict[digits.charAt(0) - '2'].length;\\n    \\twhile (stack[0] < limit0) {\\n    \\t\\tif (stack[step] == dict[digits.charAt(step) - '2'].length) {\\n    \\t\\t\\t// if No.step has reach its limit, then backtrack\\n    \\t\\t\\tstack[step] = 0;\\n    \\t\\t\\t// trace back to last step, and prepare to search the next\\n    \\t\\t\\t// choice\\n    \\t\\t\\tstack[--step]++;\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\tif (step == digits.length() - 1) {\\n    \\t\\t\\t// this search branch is end\\n    \\t\\t\\tfor (int i = 0; i <= step; i++) {\\n    \\t\\t\\t\\tresult[i] = dict[digits.charAt(i) - '2'][stack[i]];\\n    \\t\\t\\t}\\n    \\t\\t\\tlist.add(new String(result));\\n    \\t\\t\\tstack[step]++;\\n    \\t\\t} else {\\n    \\t\\t\\tstep++;\\n    \\t\\t}\\n    \\t}\\n    \\treturn list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 8381,
                "title": "24-lines-very-neat-javascript-solution",
                "content": "    var letterCombinations = function(digits) {\\n    \\tvar map = {\\n    \\t\\t\"2\": [\"a\", \"b\", \"c\"],\\n    \\t\\t\"3\": [\"d\", \"e\", \"f\"],\\n    \\t\\t\"4\": [\"g\", \"h\", \"i\"],\\n    \\t\\t\"5\": [\"j\", \"k\", \"l\"],\\n    \\t\\t\"6\": [\"m\", \"n\", \"o\"],\\n    \\t\\t\"7\": [\"p\", \"q\", \"r\", \"s\"],\\n    \\t\\t\"8\": [\"t\", \"u\", \"v\"],\\n    \\t\\t\"9\": [\"w\", \"x\", \"y\", \"z\"]\\n    \\t};\\n    \\tvar rtn = map[digits[0]];\\n    \\tdigits = digits.substr(1);\\n    \\tdigits.split(\"\").forEach(function(digit) {\\n    \\t\\tvar t = [];\\n    \\t\\tmap[digit].forEach(function(letter) {\\n    \\t\\t\\tt = t.concat(rtn.map(function(item) {\\n    \\t\\t\\t\\treturn item + letter;\\n    \\t\\t\\t}));\\n    \\t\\t});\\n    \\t\\trtn = t;\\n    \\t});\\n    \\treturn rtn === undefined ? [] : rtn;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var letterCombinations = function(digits) {\\n    \\tvar map = {\\n    \\t\\t\"2\": [\"a\", \"b\", \"c\"],\\n    \\t\\t\"3\": [\"d\", \"e\", \"f\"],\\n    \\t\\t\"4\": [\"g\", \"h\", \"i\"],\\n    \\t\\t\"5\": [\"j\", \"k\", \"l\"],\\n    \\t\\t\"6\": [\"m\", \"n\", \"o\"],\\n    \\t\\t\"7\": [\"p\", \"q\", \"r\", \"s\"],\\n    \\t\\t\"8\": [\"t\", \"u\", \"v\"],\\n    \\t\\t\"9\": [\"w\", \"x\", \"y\", \"z\"]\\n    \\t};\\n    \\tvar rtn = map[digits[0]];\\n    \\tdigits = digits.substr(1);\\n    \\tdigits.split(\"\").forEach(function(digit) {\\n    \\t\\tvar t = [];\\n    \\t\\tmap[digit].forEach(function(letter) {\\n    \\t\\t\\tt = t.concat(rtn.map(function(item) {\\n    \\t\\t\\t\\treturn item + letter;\\n    \\t\\t\\t}));\\n    \\t\\t});\\n    \\t\\trtn = t;\\n    \\t});\\n    \\treturn rtn === undefined ? [] : rtn;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 8396,
                "title": "simple-python-backtracking",
                "content": "class Solution(object):\\n\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        if not digits:\\n            return []\\n        dict = {\"1\":None,\"2\":[\"a\",\"b\",\"c\"],\"3\":[\"d\",\"e\",\"f\"],\"4\":[\"g\",\"h\",\"i\"],\\n                \"5\":[\"j\",\"k\",\"l\"],\"6\":[\"m\",\"n\",\"o\"],\"7\":[\"p\",\"q\",\"r\",\"s\"],\\n                \"8\":[\"t\",\"u\",\"v\"],\"9\":[\"w\",\"x\",\"y\",\"z\"]}\\n                \\n        def dfs(dict,string,index,path,res):\\n            if index ==len(string):\\n                res.append(path)\\n                return\\n            for i in dict[string[index]]:\\n                dfs(dict,string,index+1,path+i,res)\\n        res = []        \\n        dfs(dict,digits,0,\"\",res)\\n        return res",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        if not digits:\\n            return []\\n        dict = {\"1\":None,\"2\":[\"a\",\"b\",\"c\"],\"3\":[\"d\",\"e\",\"f\"],\"4\":[\"g\",\"h\",\"i\"],\\n                \"5\":[\"j\",\"k\",\"l\"],\"6\":[\"m\",\"n\",\"o\"],\"7\":[\"p\",\"q\",\"r\",\"s\"],\\n                \"8\":[\"t\",\"u\",\"v\"],\"9\":[\"w\",\"x\",\"y\",\"z\"]}",
                "codeTag": "Java"
            },
            {
                "id": 3856431,
                "title": "iterative-recursive-code-backtracking-easy-concise",
                "content": "**Please upvote :)**\\n# Complexity\\n- Time complexity:\\nO(3^N)\\n\\n- Space complexity:\\nO(N) for recursion call stack.\\n\\n# Code\\n**ITERATIVE CODE**\\n```\\nclass Solution {\\npublic:\\n    const vector<string> pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size() == 0)return {};\\n\\n        int n = digits.size();\\n        vector<string>ans;\\n        ans.push_back(\"\");\\n\\n        for(int i=0; i<n;i++){\\n            vector<string>temp;\\n            for(int j=0; j < pad[digits[i] - \\'0\\'].size(); j++){\\n                for(int k=0; k<ans.size(); k++){\\n                    temp.push_back(ans[k] + pad[digits[i]-\\'0\\'][j]);\\n                }\\n            }\\n            ans = temp;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**RECURSIVE CODE**\\n```\\nclass Solution {\\npublic:\\n    const vector<string> pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    vector<string>ans;\\n    void recur(string digits, int ind,string &curr,int n){\\n        if(ind == n){\\n            ans.push_back(curr);\\n            return;\\n        }\\n\\n        for(int i = 0; i< pad[digits[ind] - \\'0\\'].size(); i++){\\n            curr = curr + pad[digits[ind] - \\'0\\'][i];\\n            recur(digits,ind+1,curr,n);\\n            curr.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size() == 0)return {};\\n        int n = digits.size();\\n\\n        string curr = \"\";\\n        recur(digits,0,curr,n);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const vector<string> pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    \\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size() == 0)return {};\\n\\n        int n = digits.size();\\n        vector<string>ans;\\n        ans.push_back(\"\");\\n\\n        for(int i=0; i<n;i++){\\n            vector<string>temp;\\n            for(int j=0; j < pad[digits[i] - \\'0\\'].size(); j++){\\n                for(int k=0; k<ans.size(); k++){\\n                    temp.push_back(ans[k] + pad[digits[i]-\\'0\\'][j]);\\n                }\\n            }\\n            ans = temp;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    const vector<string> pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    vector<string>ans;\\n    void recur(string digits, int ind,string &curr,int n){\\n        if(ind == n){\\n            ans.push_back(curr);\\n            return;\\n        }\\n\\n        for(int i = 0; i< pad[digits[ind] - \\'0\\'].size(); i++){\\n            curr = curr + pad[digits[ind] - \\'0\\'][i];\\n            recur(digits,ind+1,curr,n);\\n            curr.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size() == 0)return {};\\n        int n = digits.size();\\n\\n        string curr = \"\";\\n        recur(digits,0,curr,n);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856085,
                "title": "beats-100-optimized-clean-code-c-backtracking",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Key observation: It\\'s easy to use vector instead of map, better extraction and same time complexity as map.\\n- Use backtracking for getting all possible permutations.\\n- If the digits is empty, return empty vector of string.\\n\\n\\n# Complexity\\n- Time complexity: O(n*4^n): In worst case for digit having 4 character.have choice of 4. n digit we have to select.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n): At most the temp can store is upto n.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void Helper(int idx, int n, string &digits, vector<string> &dict, vector<string> &ans, string temp){\\n\\n        if(idx==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        string val = dict[digits[idx]-\\'0\\'];\\n        for(int i=0; i<val.size(); i++){\\n            temp+=val[i];\\n            Helper(idx+1,n,digits,dict,ans,temp);\\n            temp.pop_back(); // backtrack\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        int n = digits.size();\\n        vector<string> dict = {\"\", \"\", \"abc\", \"def\", \"ghi\",\"jkl\", \"mno\",\"pqrs\", \"tuv\", \"wxyz\"}; // as 0 means nothing and pressing 1 results nothing here.\\n        if(n==0)return ans; // base case\\n        Helper(0,n,digits,dict,ans,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void Helper(int idx, int n, string &digits, vector<string> &dict, vector<string> &ans, string temp){\\n\\n        if(idx==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        string val = dict[digits[idx]-\\'0\\'];\\n        for(int i=0; i<val.size(); i++){\\n            temp+=val[i];\\n            Helper(idx+1,n,digits,dict,ans,temp);\\n            temp.pop_back(); // backtrack\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        int n = digits.size();\\n        vector<string> dict = {\"\", \"\", \"abc\", \"def\", \"ghi\",\"jkl\", \"mno\",\"pqrs\", \"tuv\", \"wxyz\"}; // as 0 means nothing and pressing 1 results nothing here.\\n        if(n==0)return ans; // base case\\n        Helper(0,n,digits,dict,ans,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785211,
                "title": "video-dial-in-your-skills-solving-letter-combinations-of-a-phone-number",
                "content": "# Intuition\\nWhen first reading this problem, it becomes clear that it requires generating all possible combinations of a given set of elements. My initial thoughts turned to the concept of \\'Backtracking\\' - a very efficient approach when we\\'re dealing with permutations or combinations. \\n\\nhttps://youtu.be/_bWwz_li_zA\\n\\n# Approach\\nTo solve this problem, I decided to create a mapping of digits to letters using a dictionary in Python. Then I created a recursive function, \\'backtrack\\', which takes the current combination of letters and the remaining digits. The function is designed to add the combination to the output if there are no more digits to process. If there are still digits left, it appends each corresponding letter to the current combination and makes a recursive call to itself with the updated combination and the remaining digits. \\n\\n# Complexity\\n- Time complexity: The time complexity of this algorithm is O(4^n), where \\'n\\' is the number of digits in the input. This is because, in the worst case scenario, each digit will correspond to 4 letters (like digit \\'7\\' or \\'9\\'), and we\\'re generating all possible combinations.\\n\\n- Space complexity: The space complexity is also O(4^n) as, in the worst case, that\\'s the number of combinations we will store in the output list.\\n\\n# Code\\n```Python []\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        phone = { \\n            \\'2\\': [\\'a\\', \\'b\\', \\'c\\'], \\n            \\'3\\': [\\'d\\', \\'e\\', \\'f\\'], \\n            \\'4\\': [\\'g\\', \\'h\\', \\'i\\'], \\n            \\'5\\': [\\'j\\', \\'k\\', \\'l\\'], \\n            \\'6\\': [\\'m\\', \\'n\\', \\'o\\'], \\n            \\'7\\': [\\'p\\', \\'q\\', \\'r\\', \\'s\\'], \\n            \\'8\\': [\\'t\\', \\'u\\', \\'v\\'], \\n            \\'9\\': [\\'w\\', \\'x\\', \\'y\\', \\'z\\'] \\n        } \\n        def backtrack(combination, next_digits): \\n            if len(next_digits) == 0: \\n                output.append(combination) \\n            else: \\n                for letter in phone[next_digits[0]]: \\n                    backtrack(combination + letter, next_digits[1:]) \\n        output = [] \\n        if digits: \\n            backtrack(\"\", digits) \\n        return output\\n```\\n``` JavaScript []\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nvar letterCombinations = function(digits) {\\n    const phone = { \\n    \\'2\\': [\\'a\\', \\'b\\', \\'c\\'], \\n    \\'3\\': [\\'d\\', \\'e\\', \\'f\\'], \\n    \\'4\\': [\\'g\\', \\'h\\', \\'i\\'], \\n    \\'5\\': [\\'j\\', \\'k\\', \\'l\\'], \\n    \\'6\\': [\\'m\\', \\'n\\', \\'o\\'], \\n    \\'7\\': [\\'p\\', \\'q\\', \\'r\\', \\'s\\'], \\n    \\'8\\': [\\'t\\', \\'u\\', \\'v\\'], \\n    \\'9\\': [\\'w\\', \\'x\\', \\'y\\', \\'z\\'] \\n    } \\n    function backtrack(combination, nextDigits) { \\n        if (nextDigits.length === 0) { \\n            output.push(combination); \\n        } else { \\n            for (let letter of phone[nextDigits[0]]) { \\n                backtrack(combination + letter, nextDigits.slice(1)); \\n            } \\n        } \\n    } \\n    let output = []; \\n    if (digits) { \\n        backtrack(\"\", digits); \\n    } \\n    return output;    \\n};\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        unordered_map<char, string> phone = {\\n            {\\'2\\', \"abc\"}, {\\'3\\', \"def\"}, {\\'4\\', \"ghi\"}, {\\'5\\', \"jkl\"}, \\n            {\\'6\\', \"mno\"}, {\\'7\\', \"pqrs\"}, {\\'8\\', \"tuv\"}, {\\'9\\', \"wxyz\"}};\\n\\n        vector<string> result;\\n        if (digits.empty()) return result;\\n        search(\"\", digits, 0, phone, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void search(string combination, string& digits, int index, unordered_map<char, string>& phone, vector<string>& result) {\\n        if (index == digits.size()) {\\n            result.push_back(combination);\\n            return;\\n        }\\n        string letters = phone[digits[index]];\\n        for (auto letter : letters) {\\n            search(combination + letter, digits, index + 1, phone, result);\\n        }\\n    }\\n};\\n\\n```\\n``` Java []\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        HashMap<Character, String> phone = new HashMap<Character, String>() {{\\n            put(\\'2\\', \"abc\"); put(\\'3\\', \"def\"); put(\\'4\\', \"ghi\");\\n            put(\\'5\\', \"jkl\"); put(\\'6\\', \"mno\"); put(\\'7\\', \"pqrs\");\\n            put(\\'8\\', \"tuv\"); put(\\'9\\', \"wxyz\");\\n        }};\\n        \\n        List<String> result = new ArrayList<>();\\n        if (digits.isEmpty()) return result;\\n        search(\"\", digits, 0, phone, result);\\n        return result;\\n    }\\n\\n    private void search(String combination, String digits, int index, HashMap<Character, String> phone, List<String> result) {\\n        if (index == digits.length()) {\\n            result.add(combination);\\n            return;\\n        }\\n        String letters = phone.get(digits.charAt(index));\\n        for (char letter : letters.toCharArray()) {\\n            search(combination + letter, digits, index + 1, phone, result);\\n        }\\n    }\\n}\\n\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<string> LetterCombinations(string digits) {\\n        Dictionary<char, string> phone = new Dictionary<char, string> {\\n            {\\'2\\', \"abc\"}, {\\'3\\', \"def\"}, {\\'4\\', \"ghi\"}, {\\'5\\', \"jkl\"},\\n            {\\'6\\', \"mno\"}, {\\'7\\', \"pqrs\"}, {\\'8\\', \"tuv\"}, {\\'9\\', \"wxyz\"}\\n        };\\n        \\n        List<string> result = new List<string>();\\n        if (digits.Length == 0) return result;\\n        Search(\"\", digits, 0, phone, result);\\n        return result;\\n    }\\n\\n    private void Search(string combination, string digits, int index, Dictionary<char, string> phone, List<string> result) {\\n        if (index == digits.Length) {\\n            result.Add(combination);\\n            return;\\n        }\\n        string letters = phone[digits[index]];\\n        foreach (char letter in letters) {\\n            Search(combination + letter, digits, index + 1, phone, result);\\n        }\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "```Python []\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        phone = { \\n            \\'2\\': [\\'a\\', \\'b\\', \\'c\\'], \\n            \\'3\\': [\\'d\\', \\'e\\', \\'f\\'], \\n            \\'4\\': [\\'g\\', \\'h\\', \\'i\\'], \\n            \\'5\\': [\\'j\\', \\'k\\', \\'l\\'], \\n            \\'6\\': [\\'m\\', \\'n\\', \\'o\\'], \\n            \\'7\\': [\\'p\\', \\'q\\', \\'r\\', \\'s\\'], \\n            \\'8\\': [\\'t\\', \\'u\\', \\'v\\'], \\n            \\'9\\': [\\'w\\', \\'x\\', \\'y\\', \\'z\\'] \\n        } \\n        def backtrack(combination, next_digits): \\n            if len(next_digits) == 0: \\n                output.append(combination) \\n            else: \\n                for letter in phone[next_digits[0]]: \\n                    backtrack(combination + letter, next_digits[1:]) \\n        output = [] \\n        if digits: \\n            backtrack(\"\", digits) \\n        return output\\n```\n``` JavaScript []\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nvar letterCombinations = function(digits) {\\n    const phone = { \\n    \\'2\\': [\\'a\\', \\'b\\', \\'c\\'], \\n    \\'3\\': [\\'d\\', \\'e\\', \\'f\\'], \\n    \\'4\\': [\\'g\\', \\'h\\', \\'i\\'], \\n    \\'5\\': [\\'j\\', \\'k\\', \\'l\\'], \\n    \\'6\\': [\\'m\\', \\'n\\', \\'o\\'], \\n    \\'7\\': [\\'p\\', \\'q\\', \\'r\\', \\'s\\'], \\n    \\'8\\': [\\'t\\', \\'u\\', \\'v\\'], \\n    \\'9\\': [\\'w\\', \\'x\\', \\'y\\', \\'z\\'] \\n    } \\n    function backtrack(combination, nextDigits) { \\n        if (nextDigits.length === 0) { \\n            output.push(combination); \\n        } else { \\n            for (let letter of phone[nextDigits[0]]) { \\n                backtrack(combination + letter, nextDigits.slice(1)); \\n            } \\n        } \\n    } \\n    let output = []; \\n    if (digits) { \\n        backtrack(\"\", digits); \\n    } \\n    return output;    \\n};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        unordered_map<char, string> phone = {\\n            {\\'2\\', \"abc\"}, {\\'3\\', \"def\"}, {\\'4\\', \"ghi\"}, {\\'5\\', \"jkl\"}, \\n            {\\'6\\', \"mno\"}, {\\'7\\', \"pqrs\"}, {\\'8\\', \"tuv\"}, {\\'9\\', \"wxyz\"}};\\n\\n        vector<string> result;\\n        if (digits.empty()) return result;\\n        search(\"\", digits, 0, phone, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void search(string combination, string& digits, int index, unordered_map<char, string>& phone, vector<string>& result) {\\n        if (index == digits.size()) {\\n            result.push_back(combination);\\n            return;\\n        }\\n        string letters = phone[digits[index]];\\n        for (auto letter : letters) {\\n            search(combination + letter, digits, index + 1, phone, result);\\n        }\\n    }\\n};\\n\\n```\n``` Java []\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        HashMap<Character, String> phone = new HashMap<Character, String>() {{\\n            put(\\'2\\', \"abc\"); put(\\'3\\', \"def\"); put(\\'4\\', \"ghi\");\\n            put(\\'5\\', \"jkl\"); put(\\'6\\', \"mno\"); put(\\'7\\', \"pqrs\");\\n            put(\\'8\\', \"tuv\"); put(\\'9\\', \"wxyz\");\\n        }};\\n        \\n        List<String> result = new ArrayList<>();\\n        if (digits.isEmpty()) return result;\\n        search(\"\", digits, 0, phone, result);\\n        return result;\\n    }\\n\\n    private void search(String combination, String digits, int index, HashMap<Character, String> phone, List<String> result) {\\n        if (index == digits.length()) {\\n            result.add(combination);\\n            return;\\n        }\\n        String letters = phone.get(digits.charAt(index));\\n        for (char letter : letters.toCharArray()) {\\n            search(combination + letter, digits, index + 1, phone, result);\\n        }\\n    }\\n}\\n\\n```\n``` C# []\\npublic class Solution {\\n    public IList<string> LetterCombinations(string digits) {\\n        Dictionary<char, string> phone = new Dictionary<char, string> {\\n            {\\'2\\', \"abc\"}, {\\'3\\', \"def\"}, {\\'4\\', \"ghi\"}, {\\'5\\', \"jkl\"},\\n            {\\'6\\', \"mno\"}, {\\'7\\', \"pqrs\"}, {\\'8\\', \"tuv\"}, {\\'9\\', \"wxyz\"}\\n        };\\n        \\n        List<string> result = new List<string>();\\n        if (digits.Length == 0) return result;\\n        Search(\"\", digits, 0, phone, result);\\n        return result;\\n    }\\n\\n    private void Search(string combination, string digits, int index, Dictionary<char, string> phone, List<string> result) {\\n        if (index == digits.Length) {\\n            result.Add(combination);\\n            return;\\n        }\\n        string letters = phone[digits[index]];\\n        foreach (char letter in letters) {\\n            Search(combination + letter, digits, index + 1, phone, result);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758707,
                "title": "100-easy-fast-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n![download.png](https://assets.leetcode.com/users/images/d436d5f3-8d7c-4a0f-9bb4-ba49720e0148_1689240754.6333094.png)\\n//PLEASE \\u2B06\\uFE0F UPVOTE,IF THIS WILL BE HELPFUL TO YOU!\\n```\\n\\nclass Solution {\\n    public List<String> letterCombinations(String digits) \\n    {   ArrayList<String> list=new ArrayList<>();\\n        if(digits.isEmpty()) return list;\\n\\n        return  phonePad(\"\",digits);\\n    }\\n    public List<String> phonePad(String p, String up)\\n    {\\n         if(up.isEmpty())\\n        {\\n            ArrayList<String> list=new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n        // thsi will convert like,\\'2\\' into 2\\n         int digit=up.charAt(0) - \\'0\\' ;\\n         ArrayList<String> list=new ArrayList<>();\\n         int i=(digit - 2) * 3;\\n         if( digit > 7) i+=1;\\n         int len=i + 3;\\n         if( digit == 7 || digit == 9) len+=1;\\n         for(;i< len; i++)\\n        {\\n          char ch= (char) (\\'a\\' + i);\\n          list.addAll(phonePad(p + ch, up.substring(1)));\\n        }\\n        return list;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<String> letterCombinations(String digits) \\n    {   ArrayList<String> list=new ArrayList<>();\\n        if(digits.isEmpty()) return list;\\n\\n        return  phonePad(\"\",digits);\\n    }\\n    public List<String> phonePad(String p, String up)\\n    {\\n         if(up.isEmpty())\\n        {\\n            ArrayList<String> list=new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n        // thsi will convert like,\\'2\\' into 2\\n         int digit=up.charAt(0) - \\'0\\' ;\\n         ArrayList<String> list=new ArrayList<>();\\n         int i=(digit - 2) * 3;\\n         if( digit > 7) i+=1;\\n         int len=i + 3;\\n         if( digit == 7 || digit == 9) len+=1;\\n         for(;i< len; i++)\\n        {\\n          char ch= (char) (\\'a\\' + i);\\n          list.addAll(phonePad(p + ch, up.substring(1)));\\n        }\\n        return list;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477552,
                "title": "c-using-recursion-clean-code-easy-to-understand",
                "content": "class Solution {\\npublic: \\n\\n\\n\\n      void solve(string digits , string output , int index , vector<string>& ans , string mapping[]){\\n           \\n         //base case\\n          if(index >= digits.length()){\\n              ans.push_back(output);\\n              return ;\\n          }\\n          \\n          int number = digits[index] - \\'0\\';\\n          string value = mapping[number];\\n          \\n          for(int i = 0 ; i<value.length() ; i++){\\n             output.push_back(value[i]);\\n              solve(digits , output , index+1 , ans , mapping);\\n              output.pop_back();\\n          }\\n          \\n      }\\n\\n    vector<string> letterCombinations(string digits) {\\n        \\n        vector<string> ans;\\n        if(digits.length() == 0){\\n            return ans;\\n        }\\n        \\n         string output = \"\";\\n         int index = 0;\\n         string mapping[10] = {\"\" , \"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n         \\n        solve(digits , output , index , ans , mapping);\\n            return ans;\\n    }\\n    \\n    \\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic: \\n\\n\\n\\n      void solve(string digits , string output , int index , vector<string>& ans , string mapping[]){\\n           \\n         //base case\\n          if(index >= digits.length()){\\n              ans.push_back(output);\\n              return ;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 3386950,
                "title": "straight-forward-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n        d={\"2\":\"abc\",\"3\":\"def\",\"4\":\"ghi\",\"5\":\"jkl\",\"6\":\"mno\",\"7\":\"pqrs\",\"8\":\"tuv\",\"9\":\"wxyz\"}\\n        res=[\"\"]\\n        for i in digits:\\n            x=[]\\n            for j in d[i]:\\n                for k in res:\\n                    x.append(k+j)\\n            res=x\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        if not digits:\\n            return []\\n        d={\"2\":\"abc\",\"3\":\"def\",\"4\":\"ghi\",\"5\":\"jkl\",\"6\":\"mno\",\"7\":\"pqrs\",\"8\":\"tuv\",\"9\":\"wxyz\"}\\n        res=[\"\"]\\n        for i in digits:\\n            x=[]\\n            for j in d[i]:\\n                for k in res:\\n                    x.append(k+j)\\n            res=x\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172348,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void solve(string digit,string output,int index, vector<string>& ans,string mapping[]){\\n\\n        if(index>=digit.length()){\\n            ans.push_back(output);\\n            return ;\\n\\n        }\\n        int number=digit[index]-\\'0\\';\\n        string value=mapping[number];\\n        for(int i=0;i<value.length();i++){\\n            output.push_back(value[i]); \\n            solve(digit,output,index+1,ans,mapping);\\n            output.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        string output;\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        int index=0;\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits,output,index,ans,mapping);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void solve(string digit,string output,int index, vector<string>& ans,string mapping[]){\\n\\n        if(index>=digit.length()){\\n            ans.push_back(output);\\n            return ;\\n\\n        }\\n        int number=digit[index]-\\'0\\';\\n        string value=mapping[number];\\n        for(int i=0;i<value.length();i++){\\n            output.push_back(value[i]); \\n            solve(digit,output,index+1,ans,mapping);\\n            output.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        string output;\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        int index=0;\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits,output,index,ans,mapping);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964154,
                "title": "simple-java-solution-beats-95",
                "content": "\\n```\\nclass Solution {\\npublic List<String> letterCombinations(String digits) {\\n    List<String> result = new ArrayList();\\n    if(digits.length()==0)\\n    return result;\\n\\n    HashMap<String,String> map = new HashMap();\\n    map.put(\"2\",\"abc\"); map.put(\"3\",\"def\"); map.put(\"4\",\"ghi\"); map.put(\"5\",\"jkl\");\\n    map.put(\"6\",\"mno\"); map.put(\"7\",\"pqrs\"); map.put(\"8\",\"tuv\"); map.put(\"9\",\"wxyz\");\\n\\n    Deque<String> a = new ArrayDeque();\\n    a.add(\"\");\\n\\n    for(int i=0; i<digits.length(); i++){\\n        String d = digits.substring(i,i+1);\\n        String fromMap = map.get(d);\\n        int n = a.size();\\n        for(int j =0; j<n ; j++){\\n            String pull = a.pollFirst();\\n            for(int k =0 ; k<fromMap.length();k++){\\n                String temp = pull.concat(fromMap.charAt(k)+\"\");\\n                a.add(temp);\\n            }\\n        }\\n    }\\n    while(!a.isEmpty()){\\n        result.add(a.poll());\\n    }\\n    return result;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic List<String> letterCombinations(String digits) {\\n    List<String> result = new ArrayList();\\n    if(digits.length()==0)\\n    return result;\\n\\n    HashMap<String,String> map = new HashMap();\\n    map.put(\"2\",\"abc\"); map.put(\"3\",\"def\"); map.put(\"4\",\"ghi\"); map.put(\"5\",\"jkl\");\\n    map.put(\"6\",\"mno\"); map.put(\"7\",\"pqrs\"); map.put(\"8\",\"tuv\"); map.put(\"9\",\"wxyz\");\\n\\n    Deque<String> a = new ArrayDeque();\\n    a.add(\"\");\\n\\n    for(int i=0; i<digits.length(); i++){\\n        String d = digits.substring(i,i+1);\\n        String fromMap = map.get(d);\\n        int n = a.size();\\n        for(int j =0; j<n ; j++){\\n            String pull = a.pollFirst();\\n            for(int k =0 ; k<fromMap.length();k++){\\n                String temp = pull.concat(fromMap.charAt(k)+\"\");\\n                a.add(temp);\\n            }\\n        }\\n    }\\n    while(!a.isEmpty()){\\n        result.add(a.poll());\\n    }\\n    return result;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767744,
                "title": "100-fastest-simple-cpp-solution-using-recursion",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector<string> lc(string digits, vector<string> ans, int index, unordered_map<char, string> m)\\n        {\\n            if (index >= digits.size())\\n                return ans;\\n            vector<string> temp;\\n            for (int i = 0; i < m[digits[index]].size(); i++)\\n                for (int j = 0; j < ans.size(); j++)\\n                {\\n                    temp.push_back(ans[j]);\\n                    temp.back().push_back(m[digits[index]][i]);\\n                }\\n            return lc(digits, temp, index + 1, m);\\n        }\\n    vector<string> letterCombinations(string digits)\\n    {\\n        if (digits.size() == 0)\\n            return vector<string> ();\\n        unordered_map<char, string> m;\\n        m[\\'2\\'] = \"abc\";\\n        m[\\'3\\'] = \"def\";\\n        m[\\'4\\'] = \"ghi\";\\n        m[\\'5\\'] = \"jkl\";\\n        m[\\'6\\'] = \"mno\";\\n        m[\\'7\\'] = \"pqrs\";\\n        m[\\'8\\'] = \"tuv\";\\n        m[\\'9\\'] = \"wxyz\";\\n        vector<string> ans = { \"\" };\\n        return lc(digits, ans, 0, m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<string> lc(string digits, vector<string> ans, int index, unordered_map<char, string> m)\\n        {\\n            if (index >= digits.size())\\n                return ans;\\n            vector<string> temp;\\n            for (int i = 0; i < m[digits[index]].size(); i++)\\n                for (int j = 0; j < ans.size(); j++)\\n                {\\n                    temp.push_back(ans[j]);\\n                    temp.back().push_back(m[digits[index]][i]);\\n                }\\n            return lc(digits, temp, index + 1, m);\\n        }\\n    vector<string> letterCombinations(string digits)\\n    {\\n        if (digits.size() == 0)\\n            return vector<string> ();\\n        unordered_map<char, string> m;\\n        m[\\'2\\'] = \"abc\";\\n        m[\\'3\\'] = \"def\";\\n        m[\\'4\\'] = \"ghi\";\\n        m[\\'5\\'] = \"jkl\";\\n        m[\\'6\\'] = \"mno\";\\n        m[\\'7\\'] = \"pqrs\";\\n        m[\\'8\\'] = \"tuv\";\\n        m[\\'9\\'] = \"wxyz\";\\n        vector<string> ans = { \"\" };\\n        return lc(digits, ans, 0, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428130,
                "title": "python-accurate-and-faster-solution-documented",
                "content": "```\\nclass Solution:\\n    def letterCombinations(self, digits):\\n        if not digits: return []\\n        dict = {\\'2\\':\"abc\", \\'3\\':\"def\", \\'4\\':\"ghi\", \\'5\\':\"jkl\", \\'6\\':\"mno\", \\'7\\':\"pqrs\", \\'8\\':\"tuv\", \\'9\\':\"wxyz\"}\\n        result = []\\n\\n        def dfs(seq, current):                  # given sequence of digits, generate combination\\n            if not seq:                         # if sequence become empty, \\n                result.append(current)          # - append the current combination\\n                return\\n\\n            for letter in dict[seq[0]]:         # for each letter in first-digit-letters\\n                dfs(seq[1:], current+letter)    # - merge letter with current comb, then repeat for next digits\\n\\n        dfs(digits, \"\")                         # start with full sequence and empty combination\\n        return result\\n```\\nPlease UPVOTE\\uD83D\\uDC4D if you love\\u2764\\uFE0F this solution or learned something new.\\nIf you have any question, feel free to ask.",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def letterCombinations(self, digits):\\n        if not digits: return []\\n        dict = {\\'2\\':\"abc\", \\'3\\':\"def\", \\'4\\':\"ghi\", \\'5\\':\"jkl\", \\'6\\':\"mno\", \\'7\\':\"pqrs\", \\'8\\':\"tuv\", \\'9\\':\"wxyz\"}\\n        result = []\\n\\n        def dfs(seq, current):                  # given sequence of digits, generate combination\\n            if not seq:                         # if sequence become empty, \\n                result.append(current)          # - append the current combination\\n                return\\n\\n            for letter in dict[seq[0]]:         # for each letter in first-digit-letters\\n                dfs(seq[1:], current+letter)    # - merge letter with current comb, then repeat for next digits\\n\\n        dfs(digits, \"\")                         # start with full sequence and empty combination\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368085,
                "title": "recursion-solution-with-handwritten-notes-and-recursive-tree-easy-understanding",
                "content": "**please please please upvote the solution if it helped you understand the problem**\\n\\n***--------Recursive Tree -------***\\n\\n![image](https://assets.leetcode.com/users/images/da1a76dc-594f-4ae0-aa9d-598eef44930f_1659423091.6892014.jpeg)\\n\\n\\n***---------Explanation-------------***\\n\\n![image](https://assets.leetcode.com/users/images/76530601-054e-436c-b903-7ea08a60b352_1659423185.1525292.jpeg)\\n\\n***--------------CODE IN JAVA------------***\\n```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        if (digits.isEmpty()) {\\n\\t\\t// if intial string is empty just return empty list\\n            return ans;\\n        }\\n\\t\\t//if not call the helper function with \\n\\t\\t//processed and unprocessed strings as arguments\\n        ans = helper(\"\", digits);\\n        return ans;\\n    }\\n    List<String> helper(String p, String up) {\\n\\t//create the outer list\\n        List<String> ans = new ArrayList<>();\\n        if (up.isEmpty()) {\\n\\t\\t// if up gets empty in recursive call just returning the p in the list\\n            List<String> list = new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n\\t\\t//taking digit from string\\n        int digit = up.charAt(0) - \\'0\\';\\n        if (digit >= 2 && digit <= 6) {\\n\\t\\t//loop for digits 2 to 6\\n            for (int i = (digit - 2) * 3; i <= ((digit - 1) * 3) - 1; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n\\t\\t\\t\\t//adding all the recursive answers in list\\n                ans.addAll(helper(p + ch, up.substring(1)));\\n            }\\n        } else if (digit == 7) {\\n\\t\\t//for 7\\n            for (int i = (digit - 2) * 3; i < ((digit - 1) * 3) + 1; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n\\t\\t\\t\\t\\t//adding all the recursive answers in list\\n                ans.addAll(helper(p + ch, up.substring(1)));\\n            }\\n        } else if (digit == 9) {\\n\\t\\t//for 9\\n            for (int i = (digit - 2) * 3 + 1; i <= ((digit - 1) * 3) + 1; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n\\t\\t\\t\\t\\t//adding all the recursive answers in list\\n                ans.addAll(helper(p + ch, up.substring(1)));\\n            }\\n        } else {\\n\\t\\t//for 8\\n            for (int i = (digit - 2) * 3 + 1; i < ((digit - 1) * 3) + 1; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n\\t\\t\\t\\t\\t//adding all the recursive answers in list\\n                ans.addAll(helper(p + ch, up.substring(1)));\\n            }\\n        }\\n\\t\\t//finally returning the answer!!\\n        return ans;\\n    }\\n}\\n```\\n**Please DO UPVOTE THE SOLUTION!!**\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        if (digits.isEmpty()) {\\n\\t\\t// if intial string is empty just return empty list\\n            return ans;\\n        }\\n\\t\\t//if not call the helper function with \\n\\t\\t//processed and unprocessed strings as arguments\\n        ans = helper(\"\", digits);\\n        return ans;\\n    }\\n    List<String> helper(String p, String up) {\\n\\t//create the outer list\\n        List<String> ans = new ArrayList<>();\\n        if (up.isEmpty()) {\\n\\t\\t// if up gets empty in recursive call just returning the p in the list\\n            List<String> list = new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n\\t\\t//taking digit from string\\n        int digit = up.charAt(0) - \\'0\\';\\n        if (digit >= 2 && digit <= 6) {\\n\\t\\t//loop for digits 2 to 6\\n            for (int i = (digit - 2) * 3; i <= ((digit - 1) * 3) - 1; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n\\t\\t\\t\\t//adding all the recursive answers in list\\n                ans.addAll(helper(p + ch, up.substring(1)));\\n            }\\n        } else if (digit == 7) {\\n\\t\\t//for 7\\n            for (int i = (digit - 2) * 3; i < ((digit - 1) * 3) + 1; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n\\t\\t\\t\\t\\t//adding all the recursive answers in list\\n                ans.addAll(helper(p + ch, up.substring(1)));\\n            }\\n        } else if (digit == 9) {\\n\\t\\t//for 9\\n            for (int i = (digit - 2) * 3 + 1; i <= ((digit - 1) * 3) + 1; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n\\t\\t\\t\\t\\t//adding all the recursive answers in list\\n                ans.addAll(helper(p + ch, up.substring(1)));\\n            }\\n        } else {\\n\\t\\t//for 8\\n            for (int i = (digit - 2) * 3 + 1; i < ((digit - 1) * 3) + 1; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n\\t\\t\\t\\t\\t//adding all the recursive answers in list\\n                ans.addAll(helper(p + ch, up.substring(1)));\\n            }\\n        }\\n\\t\\t//finally returning the answer!!\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023903,
                "title": "c-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(string digits,vector<string> &ans,int start,int end,string tmp, vector<vector<int>> letters)\\n    {\\n        // if start reaches to the bound\\n        if(start>=end)\\n        {\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        \\n        // check for the other associative chars with their respective integers\\n        // here we use keys[digits[i]-\\'2\\'] , because we made our keys that start with idx 0 and if we see digit pattern then \\n        // observe that it actually start from 2 right so for balancing that we use digits[i]-\\'2\\'\\n        for(char x : letters[digits[start]-\\'2\\'])\\n        {\\n            // call the same helper fundtion by insreasing start count by 1 because we have done with current now go to second one\\n            // and add current char to tmp because we took the current char and check for its other associatives\\n            helper(digits,ans,start+1,digits.size(),tmp+x, letters);\\n        }\\n    }\\n        \\n    vector<string> letterCombinations(string digits) \\n    {\\n        //store the final answer\\n        vector<string> ans;\\n        \\n        // creating the letter pattern \\n        vector<vector<int>> letters = {\\n                                        { \\'a\\',\\'b\\',\\'c\\' }, { \\'d\\',\\'e\\',\\'f\\' }, { \\'g\\',\\'h\\',\\'i\\' }, { \\'j\\',\\'k\\',\\'l\\' }, \\n                                        { \\'m\\',\\'n\\',\\'o\\' }, { \\'p\\',\\'q\\',\\'r\\',\\'s\\' }, { \\'t\\',\\'u\\',\\'v\\' }, { \\'w\\',\\'x\\',\\'y\\',\\'z\\' }\\n                                      };\\n     \\n        \\n        // if our string is initially empty\\n        if(digits==\"\")\\n            return ans;\\n        \\n        // else call the helper function that will gave all the combinations\\n        helper(digits,ans,0,digits.size(),\"\", letters);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(string digits,vector<string> &ans,int start,int end,string tmp, vector<vector<int>> letters)\\n    {\\n        // if start reaches to the bound\\n        if(start>=end)\\n        {\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        \\n        // check for the other associative chars with their respective integers\\n        // here we use keys[digits[i]-\\'2\\'] , because we made our keys that start with idx 0 and if we see digit pattern then \\n        // observe that it actually start from 2 right so for balancing that we use digits[i]-\\'2\\'\\n        for(char x : letters[digits[start]-\\'2\\'])\\n        {\\n            // call the same helper fundtion by insreasing start count by 1 because we have done with current now go to second one\\n            // and add current char to tmp because we took the current char and check for its other associatives\\n            helper(digits,ans,start+1,digits.size(),tmp+x, letters);\\n        }\\n    }\\n        \\n    vector<string> letterCombinations(string digits) \\n    {\\n        //store the final answer\\n        vector<string> ans;\\n        \\n        // creating the letter pattern \\n        vector<vector<int>> letters = {\\n                                        { \\'a\\',\\'b\\',\\'c\\' }, { \\'d\\',\\'e\\',\\'f\\' }, { \\'g\\',\\'h\\',\\'i\\' }, { \\'j\\',\\'k\\',\\'l\\' }, \\n                                        { \\'m\\',\\'n\\',\\'o\\' }, { \\'p\\',\\'q\\',\\'r\\',\\'s\\' }, { \\'t\\',\\'u\\',\\'v\\' }, { \\'w\\',\\'x\\',\\'y\\',\\'z\\' }\\n                                      };\\n     \\n        \\n        // if our string is initially empty\\n        if(digits==\"\")\\n            return ans;\\n        \\n        // else call the helper function that will gave all the combinations\\n        helper(digits,ans,0,digits.size(),\"\", letters);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021480,
                "title": "c-easy-recursion-backtracking-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(vector<string>& ans,int curInd,string& digits,int szDigits,string& temp,map<int,string>& m){\\n        \\n        //if size of the temp string is equal to the size of digits string than we will add that string into our ans vector\\n        if(curInd==szDigits){\\n            if(szDigits!=0) ans.push_back(temp);\\n            return;\\n        }\\n        \\n        //size of the string corresponding to that digit at current index\\n        int loopsize=m[digits[curInd]-\\'0\\'].size();\\n        \\n        for(int i=0;i<loopsize;i++){\\n            \\n            //will push one character of the corresponding number into string and call for next index\\n            temp.push_back(m[digits[curInd]-\\'0\\'][i]);\\n            //now we have added that character in the string so will increament our index and call function for next index\\n            helper(ans,curInd+1,digits,szDigits,temp,m);\\n            //now our function call for that character is over so will pop back that character from string and loop will add other character in next iteration.\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    vector<string> letterCombinations(string digits) {\\n        \\n        //map for string corresponding to digits\\n        map<int,string> m{{2,\"abc\"},{3,\"def\"},{4,\"ghi\"},{5,\"jkl\"},{6,\"mno\"},{7,\"pqrs\"},{8,\"tuv\"},{9,\"wxyz\"}};\\n        vector<string> ans;\\n        string temp;\\n        helper(ans,0,digits,digits.size(),temp,m);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<string>& ans,int curInd,string& digits,int szDigits,string& temp,map<int,string>& m){\\n        \\n        //if size of the temp string is equal to the size of digits string than we will add that string into our ans vector\\n        if(curInd==szDigits){\\n            if(szDigits!=0) ans.push_back(temp);\\n            return;\\n        }\\n        \\n        //size of the string corresponding to that digit at current index\\n        int loopsize=m[digits[curInd]-\\'0\\'].size();\\n        \\n        for(int i=0;i<loopsize;i++){\\n            \\n            //will push one character of the corresponding number into string and call for next index\\n            temp.push_back(m[digits[curInd]-\\'0\\'][i]);\\n            //now we have added that character in the string so will increament our index and call function for next index\\n            helper(ans,curInd+1,digits,szDigits,temp,m);\\n            //now our function call for that character is over so will pop back that character from string and loop will add other character in next iteration.\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    vector<string> letterCombinations(string digits) {\\n        \\n        //map for string corresponding to digits\\n        map<int,string> m{{2,\"abc\"},{3,\"def\"},{4,\"ghi\"},{5,\"jkl\"},{6,\"mno\"},{7,\"pqrs\"},{8,\"tuv\"},{9,\"wxyz\"}};\\n        vector<string> ans;\\n        string temp;\\n        helper(ans,0,digits,digits.size(),temp,m);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914965,
                "title": "java-backtracking-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    public final String[] dict = new String[]{\\n        \"abc\",\\n        \"def\",\\n        \"ghi\",\\n        \"jkl\",\\n        \"mno\",\\n        \"pqrs\",\\n        \"tuv\",\\n        \"wxyz\"\\n    };\\n    public List<String> letterCombinations(String digits) {\\n        List<String> results = new ArrayList<>();\\n        if(digits.length() == 0) return results;\\n        backtracking(results, new StringBuilder(), 0, digits);\\n        return results;\\n    }\\n    \\n    public void backtracking(List<String> results, StringBuilder sb, int i, String digits) {\\n        if (i >= digits.length()) {\\n            results.add(sb.toString());\\n            return;\\n        }\\n        int d = digits.charAt(i) - \\'2\\';\\n        String word = dict[d];\\n        for (char c: word.toCharArray()) {\\n            sb.append(c);\\n            backtracking(results, sb, i + 1, digits);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public final String[] dict = new String[]{\\n        \"abc\",\\n        \"def\",\\n        \"ghi\",\\n        \"jkl\",\\n        \"mno\",\\n        \"pqrs\",\\n        \"tuv\",\\n        \"wxyz\"\\n    };\\n    public List<String> letterCombinations(String digits) {\\n        List<String> results = new ArrayList<>();\\n        if(digits.length() == 0) return results;\\n        backtracking(results, new StringBuilder(), 0, digits);\\n        return results;\\n    }\\n    \\n    public void backtracking(List<String> results, StringBuilder sb, int i, String digits) {\\n        if (i >= digits.length()) {\\n            results.add(sb.toString());\\n            return;\\n        }\\n        int d = digits.charAt(i) - \\'2\\';\\n        String word = dict[d];\\n        for (char c: word.toCharArray()) {\\n            sb.append(c);\\n            backtracking(results, sb, i + 1, digits);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1879884,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1972934,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1751528,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1568006,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1572196,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1567808,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1567806,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1771793,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1566438,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1567807,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1879884,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1972934,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1751528,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1568006,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1572196,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1567808,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1567806,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1771793,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1566438,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1567807,
                "content": [
                    {
                        "username": "kirillyat",
                        "content": "keyboard = {\\n            \"2\": \"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }"
                    },
                    {
                        "username": "Abduazimxoja",
                        "content": "I think an array is better suited here: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] "
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "with list values\\n```\\n        m = {\\n            \\'0\\': None,\\n            \\'1\\': None,\\n            \"2\": [\\'a\\',\\'b\\',\\'c\\'],\\n            \"3\": [\\'d\\', \\'e\\', \\'f\\'],\\n            \"4\": [\\'g\\', \\'h\\', \\'i\\'],\\n            \"5\": [\\'j\\', \\'k\\', \\'l\\'],\\n            \"6\": [\\'m\\', \\'n\\', \\'o\\'],\\n            \\'7\\': [\"p\",\\'q\\',\\'r\\',\\'s\\'],\\n            \\'8\\': [\\'t\\',\\'u\\',\\'v\\'],\\n            \\'9\\': [\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        }\\n```"
                    },
                    {
                        "username": "Balerii",
                        "content": "Should have came here before. Spent more time creating this dict then on the problem\\uD83D\\uDE05"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "        List<List<Character>> keypad = new ArrayList<>();\\n        \\n        for(int i=0; i<=9; i++){\\n            keypad.add(new ArrayList<>());\\n        }\\n        keypad.get(2).addAll(Arrays.asList(\\'a\\',\\'b\\',\\'c\\'));\\n        keypad.get(3).addAll(Arrays.asList(\\'d\\',\\'e\\',\\'f\\'));\\n        keypad.get(4).addAll(Arrays.asList(\\'g\\',\\'h\\',\\'i\\'));\\n        keypad.get(5).addAll(Arrays.asList(\\'j\\',\\'k\\',\\'l\\'));\\n        keypad.get(6).addAll(Arrays.asList(\\'m\\',\\'n\\',\\'o\\'));\\n        keypad.get(7).addAll(Arrays.asList(\\'p\\',\\'q\\',\\'r\\',\\'s\\'));\\n        keypad.get(8).addAll(Arrays.asList(\\'t\\',\\'u\\',\\'v\\'));\\n        keypad.get(9).addAll(Arrays.asList(\\'w\\',\\'x\\',\\'y\\',\\'z\\'));"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Boss Man!!! \\n"
                    },
                    {
                        "username": "lucasan2300",
                        "content": "or if you prefer a Java String array definition:\n  String[][] keyboard = {\n        {\"0\", \"\"}\n      , {\"1\", \"\"}\n      , {\"2\", \"abc\"}\n      , {\"3\", \"def\"}\n      , {\"4\", \"ghi\"}\n      , {\"5\", \"jkl\"}\n      , {\"6\", \"mno\"}\n      , {\"7\", \"pqrs\"}\n      , {\"8\", \"tuv\"}\n      , {\"9\", \"wxyz\"}\n  };\n"
                    },
                    {
                        "username": "yudonglin",
                        "content": "Thank you, this should be part of the description."
                    },
                    {
                        "username": "bezwish",
                        "content": "Was looking for this, you rock"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "really emotional rn ,was not able to stick around with recursion even after watching tons of videos....\\nafter giving some time patiently,was able to understand the flow of recursion..\\ndid this complete problem by myself without any help. This maybe not that big thing for others but i am really really happy and satisfied rn"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "grats dude"
                    },
                    {
                        "username": "cjfritz9",
                        "content": "best feeling in the world :) getting that feeling just means you have the passion to succeed!"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Everyone starts from somewhere!!! Keep Grinding Brother!!!"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Great work, stick with it! I really struggled with these types of problems a year ago. I can tell you three things from my experience: 1) Visualizing these types of problems does not come naturally to many but you can build the intuition over time with lot of work. 2) There are many different subtleties to recursion and you will get stuck on similar problems again in the future. Don\\'t let that discourage you. 3) You eventually will be able to \"see\" the recursive pattern and visualize the tree/call stack/queue instinctually and it\\'s very satisfying!"
                    },
                    {
                        "username": "YEDLA_MUKHESH_KUMAR___",
                        "content": "mee too bro...  : )"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "Your comment gave me the motivation to try it out and solve it on my own. Thanks man\\u2570(*\\xB0\\u25BD\\xB0*)\\u256F"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@JerExplosion](/JerExplosion) Thanks man  : )"
                    },
                    {
                        "username": "Aditya_Rawat23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  Wish you best of luck for your coding journey   :D"
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Keep it up bro!"
                    },
                    {
                        "username": "howuseeit",
                        "content": "good job, proud of you. im still struggling haha"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Why people are spamming Solutions in Discussion tab? "
                    },
                    {
                        "username": "itmevic",
                        "content": "mods need to ban them"
                    },
                    {
                        "username": "sy_chen",
                        "content": "Obviously the empty character string **can** be represented by an empty digit string."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate) Bro Stop spamming.\\nYou are just ruining platform my friend. Just stop spamming your solutions everywhere.\\n"
                    },
                    {
                        "username": "ctnFenix",
                        "content": "I\\'ve encountered a test case where the input string is an empty string and the expected out put is an empty vector (representing empty set). However, I consider the set containing empty string should be a more appropriate result for this. Empty string should map to one possibility, that is empty string, instead of zero possibility, right? "
                    },
                    {
                        "username": "user5285Zn",
                        "content": "[@AssortedFantasy](/AssortedFantasy) \\n\\nI don\\'t think so. The inductions works (for me) much better if the empty digit string yields [\"\"]. "
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It works better for the recursive solution to be defined this way (base case is \"\" and everything above is using combinations."
                    },
                    {
                        "username": "suige",
                        "content": "is \"\" still considered a combination?"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "[@sk_aayush](/sk_aayush) its not working\\ntestcase is \"\" and the output is [ ]"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "make a string of 10 length, and assign the first two indices \"\", \"\"  for 0 and 1 and then do the mapping"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "yes"
                    },
                    {
                        "username": "rmn",
                        "content": "\\nThe system claims that my code produces the wrong result, but the \"Output\" and \"Expected\" are the same, except the internal ordering of each individual combination. \\nThe system should accept the solution as long as it has the right set of combinations regardless of the ordering, which in the \"Note\" section is says that it does, but apparently it doesn't.\\n\\nHere's the error message I'm seeing:\\n\\nInput:\\n\"23\"\\nOutput:\\n[\"da\",\"ea\",\"fa\",\"db\",\"eb\",\"fb\",\"dc\",\"ec\",\"fc\"]\\nExpected:\\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                    },
                    {
                        "username": "rayrogar",
                        "content": "think as a phone number, in some commercials show us the phone number like this 555-code then is not the same code= 2633 than code=6233. I hope this help you"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "**any order** mean [\"a1\",\"b2\",\"c3\"] == [\"b2\",\"a1\",\"c3\"] == [\"c3\",\"a1\",\"b2\"] ... etc \\nbut [\"a1\",\"b2\",\"c3\"] != \"1a\",\"2b\",\"3c\"]\\nbecause if enter  \"23\" the possible letter [ \"a\" or \"b\" or \"c\" ] then [ \"d\" or \"e\" or \"f\" ]"
                    },
                    {
                        "username": "lakshh_123",
                        "content": "if you have done  eg:(ch+p) then write (p+ch)\\nit will solve the prblm"
                    },
                    {
                        "username": "user1440f",
                        "content": "The output your code produces is supposed to be for \"32\"."
                    },
                    {
                        "username": "Ultron03",
                        "content": "according to your output you are pressing 3 first in keypad (acc to compiler ) but you have to write a code which acts like you have pressed 2 first.. the order defined there means you can only change  the places of elements  of the vector.."
                    },
                    {
                        "username": "KershKersh",
                        "content": "Order refers to the ordering of the elements in the result. Order does matter for the individual elements."
                    },
                    {
                        "username": "user5167j",
                        "content": "For anyone new the above answer is wrong as for 23 the digits of 2 should come first similar to that of searching for a contact name using digits"
                    },
                    {
                        "username": "PBK320",
                        "content": "The description says that digits can up to 4 digits in length. If digits is length 4  (i.e. 2345) do we want all unique combinations of two, three and four digits or just the letter combinations that are 4 characters in length? "
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "All the possible letter combinations that are 4 characters in length"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arbaz_khan_cs",
                        "content": "class Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        keyboard = {\\n            \"2\":\"abc\",\\n            \"3\": \"def\",\\n            \"4\": \"ghi\",\\n            \"5\": \"jkl\",\\n            \"6\": \"mno\",\\n            \"7\": \"pqrs\",\\n            \"8\": \"tuv\",\\n            \"9\": \"wxyz\"\\n        }\\n\\n        res = []\\n        def backtrack(i, currStr):\\n            if len(currStr) == len(digits):\\n                res.append(currStr)\\n                return\\n            \\n\\n            for c in keyboard[digits[i]]:\\n                backtrack(i+1, currStr + c)\\n        \\n        if digits:\\n            backtrack(0, \"\")\\n        \\n        return res\\n\\n"
                    },
                    {
                        "username": "Dadbod88",
                        "content": "Hi,\\n\\nWhat is expected output if input string contains 1 or 0 for example 123 or 410, as there is no alphabet on both '0' and '1'.\\n\\nRegards,\\n\\nArka"
                    },
                    {
                        "username": "shikhar0902",
                        "content": "just save empty string on 0 and 1 index in string array"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "constraints are digits[i] will only be from \\'2\\' to \\'9\\'"
                    }
                ]
            },
            {
                "id": 1997860,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "It really is a backtracking week y\\'all \\uD83E\\uDD23 3 straight & counting."
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "for real bro "
                    },
                    {
                        "username": "bigapple",
                        "content": "For \"0\" and \"1\", we need need to treat it as a letter, right? for \"0\", dose it mean it can be '0' or ' '?\\nI saw a lot of solution does not include 0 and 1 in the map, which means 0 and 1 will be discarded in the string, which I believe it is wrong. \\nFor 0, are we going to map 0 to only 0, or TWO character: '0' or ' '(space)?"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try reading the constraints as well. it helps a lot . I started doing the same n somehow after a month of practice it made the question more clear to me and got a precise idaes how to approach the ques. BEST of LUCK !"
                    },
                    {
                        "username": "AWells95",
                        "content": "Input constants say digits[i] will be a digits between 2 and 9, so 1 and 0 don\\'t need to be accounted for"
                    },
                    {
                        "username": "spookyflame",
                        "content": "C++:  ```unordered_map<char, string> mp = {{'2', \"abc\"},{'3', \"def\"},{'4', \"ghi\"},{'5', \"jkl\"},{'6', \"mno\"},{'7', \"pqrs\"},{'8', \"tuv\"},{'9', \"wxyz\"}};```\n\nTo access: ```mp[digits[indice]]```\n\nfaster version: ```vector<string> mp = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"} ;```\n\nTo access: ```mp[digits[indice]-48]```"
                    },
                    {
                        "username": "AngryDogman",
                        "content": "You could easily just write n for loops to solve the problem but that doesn\\'t really scale well when n > 4. A good way to think about this problem is how can I simulate n for loops using only one?"
                    },
                    {
                        "username": "jarc",
                        "content": "Each path of DFS is a valid combination. We can solve the problem by enumerating every path."
                    },
                    {
                        "username": "kwu30",
                        "content": "![image](https://assets.leetcode.com/users/images/49fd0d3e-048b-4b99-873c-a54d32642712_1602733607.6318882.png)\\n"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "I am so happy today, I solved a problem of recursion on my own from beginning to end.Also thanks to [@Aditya Rawat](/Aditya_Rawat23) his comment made me feel like , Instead of getting afraid I should give it a try and voila I solved it by myself. Absolutely happy. Those who are not able to solve it , give it a try guys take your copy and formulate the answer think how it would be possible by drawing a diagram , write some pseudocode, do a dry run of it and It will be done."
                    },
                    {
                        "username": "tragicallyfun",
                        "content": "Leetcode is trying its level best to teach me backtracking"
                    },
                    {
                        "username": "albert_yiyi",
                        "content": "Hi, first post here. Im coding in python3.\\n\\nAs stated in title, the output for \"\" should be [\"\"]\\n\\n**Argument1:**\\n\"2222\" has 3^4 = 81 possible strings\\n\"2\" * n has 3^n possible strings\\n\"\" should have 3^0 = 1 possible string\\n\\n**Argument2:**\\nBob open phone and press 0 button, how many possible strings there are in the chatbox?\\nans: 1\\nwhat is the only possible string?\\nans: \"\" (empty string)\\n\\nSo am i crazy or what?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again solved before. Use hash map! Resubmit"
                    }
                ]
            },
            {
                "id": 1568835,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "It really is a backtracking week y\\'all \\uD83E\\uDD23 3 straight & counting."
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "for real bro "
                    },
                    {
                        "username": "bigapple",
                        "content": "For \"0\" and \"1\", we need need to treat it as a letter, right? for \"0\", dose it mean it can be '0' or ' '?\\nI saw a lot of solution does not include 0 and 1 in the map, which means 0 and 1 will be discarded in the string, which I believe it is wrong. \\nFor 0, are we going to map 0 to only 0, or TWO character: '0' or ' '(space)?"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try reading the constraints as well. it helps a lot . I started doing the same n somehow after a month of practice it made the question more clear to me and got a precise idaes how to approach the ques. BEST of LUCK !"
                    },
                    {
                        "username": "AWells95",
                        "content": "Input constants say digits[i] will be a digits between 2 and 9, so 1 and 0 don\\'t need to be accounted for"
                    },
                    {
                        "username": "spookyflame",
                        "content": "C++:  ```unordered_map<char, string> mp = {{'2', \"abc\"},{'3', \"def\"},{'4', \"ghi\"},{'5', \"jkl\"},{'6', \"mno\"},{'7', \"pqrs\"},{'8', \"tuv\"},{'9', \"wxyz\"}};```\n\nTo access: ```mp[digits[indice]]```\n\nfaster version: ```vector<string> mp = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"} ;```\n\nTo access: ```mp[digits[indice]-48]```"
                    },
                    {
                        "username": "AngryDogman",
                        "content": "You could easily just write n for loops to solve the problem but that doesn\\'t really scale well when n > 4. A good way to think about this problem is how can I simulate n for loops using only one?"
                    },
                    {
                        "username": "jarc",
                        "content": "Each path of DFS is a valid combination. We can solve the problem by enumerating every path."
                    },
                    {
                        "username": "kwu30",
                        "content": "![image](https://assets.leetcode.com/users/images/49fd0d3e-048b-4b99-873c-a54d32642712_1602733607.6318882.png)\\n"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "I am so happy today, I solved a problem of recursion on my own from beginning to end.Also thanks to [@Aditya Rawat](/Aditya_Rawat23) his comment made me feel like , Instead of getting afraid I should give it a try and voila I solved it by myself. Absolutely happy. Those who are not able to solve it , give it a try guys take your copy and formulate the answer think how it would be possible by drawing a diagram , write some pseudocode, do a dry run of it and It will be done."
                    },
                    {
                        "username": "tragicallyfun",
                        "content": "Leetcode is trying its level best to teach me backtracking"
                    },
                    {
                        "username": "albert_yiyi",
                        "content": "Hi, first post here. Im coding in python3.\\n\\nAs stated in title, the output for \"\" should be [\"\"]\\n\\n**Argument1:**\\n\"2222\" has 3^4 = 81 possible strings\\n\"2\" * n has 3^n possible strings\\n\"\" should have 3^0 = 1 possible string\\n\\n**Argument2:**\\nBob open phone and press 0 button, how many possible strings there are in the chatbox?\\nans: 1\\nwhat is the only possible string?\\nans: \"\" (empty string)\\n\\nSo am i crazy or what?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again solved before. Use hash map! Resubmit"
                    }
                ]
            },
            {
                "id": 1940241,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "It really is a backtracking week y\\'all \\uD83E\\uDD23 3 straight & counting."
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "for real bro "
                    },
                    {
                        "username": "bigapple",
                        "content": "For \"0\" and \"1\", we need need to treat it as a letter, right? for \"0\", dose it mean it can be '0' or ' '?\\nI saw a lot of solution does not include 0 and 1 in the map, which means 0 and 1 will be discarded in the string, which I believe it is wrong. \\nFor 0, are we going to map 0 to only 0, or TWO character: '0' or ' '(space)?"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try reading the constraints as well. it helps a lot . I started doing the same n somehow after a month of practice it made the question more clear to me and got a precise idaes how to approach the ques. BEST of LUCK !"
                    },
                    {
                        "username": "AWells95",
                        "content": "Input constants say digits[i] will be a digits between 2 and 9, so 1 and 0 don\\'t need to be accounted for"
                    },
                    {
                        "username": "spookyflame",
                        "content": "C++:  ```unordered_map<char, string> mp = {{'2', \"abc\"},{'3', \"def\"},{'4', \"ghi\"},{'5', \"jkl\"},{'6', \"mno\"},{'7', \"pqrs\"},{'8', \"tuv\"},{'9', \"wxyz\"}};```\n\nTo access: ```mp[digits[indice]]```\n\nfaster version: ```vector<string> mp = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"} ;```\n\nTo access: ```mp[digits[indice]-48]```"
                    },
                    {
                        "username": "AngryDogman",
                        "content": "You could easily just write n for loops to solve the problem but that doesn\\'t really scale well when n > 4. A good way to think about this problem is how can I simulate n for loops using only one?"
                    },
                    {
                        "username": "jarc",
                        "content": "Each path of DFS is a valid combination. We can solve the problem by enumerating every path."
                    },
                    {
                        "username": "kwu30",
                        "content": "![image](https://assets.leetcode.com/users/images/49fd0d3e-048b-4b99-873c-a54d32642712_1602733607.6318882.png)\\n"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "I am so happy today, I solved a problem of recursion on my own from beginning to end.Also thanks to [@Aditya Rawat](/Aditya_Rawat23) his comment made me feel like , Instead of getting afraid I should give it a try and voila I solved it by myself. Absolutely happy. Those who are not able to solve it , give it a try guys take your copy and formulate the answer think how it would be possible by drawing a diagram , write some pseudocode, do a dry run of it and It will be done."
                    },
                    {
                        "username": "tragicallyfun",
                        "content": "Leetcode is trying its level best to teach me backtracking"
                    },
                    {
                        "username": "albert_yiyi",
                        "content": "Hi, first post here. Im coding in python3.\\n\\nAs stated in title, the output for \"\" should be [\"\"]\\n\\n**Argument1:**\\n\"2222\" has 3^4 = 81 possible strings\\n\"2\" * n has 3^n possible strings\\n\"\" should have 3^0 = 1 possible string\\n\\n**Argument2:**\\nBob open phone and press 0 button, how many possible strings there are in the chatbox?\\nans: 1\\nwhat is the only possible string?\\nans: \"\" (empty string)\\n\\nSo am i crazy or what?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again solved before. Use hash map! Resubmit"
                    }
                ]
            },
            {
                "id": 1932510,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "It really is a backtracking week y\\'all \\uD83E\\uDD23 3 straight & counting."
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "for real bro "
                    },
                    {
                        "username": "bigapple",
                        "content": "For \"0\" and \"1\", we need need to treat it as a letter, right? for \"0\", dose it mean it can be '0' or ' '?\\nI saw a lot of solution does not include 0 and 1 in the map, which means 0 and 1 will be discarded in the string, which I believe it is wrong. \\nFor 0, are we going to map 0 to only 0, or TWO character: '0' or ' '(space)?"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try reading the constraints as well. it helps a lot . I started doing the same n somehow after a month of practice it made the question more clear to me and got a precise idaes how to approach the ques. BEST of LUCK !"
                    },
                    {
                        "username": "AWells95",
                        "content": "Input constants say digits[i] will be a digits between 2 and 9, so 1 and 0 don\\'t need to be accounted for"
                    },
                    {
                        "username": "spookyflame",
                        "content": "C++:  ```unordered_map<char, string> mp = {{'2', \"abc\"},{'3', \"def\"},{'4', \"ghi\"},{'5', \"jkl\"},{'6', \"mno\"},{'7', \"pqrs\"},{'8', \"tuv\"},{'9', \"wxyz\"}};```\n\nTo access: ```mp[digits[indice]]```\n\nfaster version: ```vector<string> mp = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"} ;```\n\nTo access: ```mp[digits[indice]-48]```"
                    },
                    {
                        "username": "AngryDogman",
                        "content": "You could easily just write n for loops to solve the problem but that doesn\\'t really scale well when n > 4. A good way to think about this problem is how can I simulate n for loops using only one?"
                    },
                    {
                        "username": "jarc",
                        "content": "Each path of DFS is a valid combination. We can solve the problem by enumerating every path."
                    },
                    {
                        "username": "kwu30",
                        "content": "![image](https://assets.leetcode.com/users/images/49fd0d3e-048b-4b99-873c-a54d32642712_1602733607.6318882.png)\\n"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "I am so happy today, I solved a problem of recursion on my own from beginning to end.Also thanks to [@Aditya Rawat](/Aditya_Rawat23) his comment made me feel like , Instead of getting afraid I should give it a try and voila I solved it by myself. Absolutely happy. Those who are not able to solve it , give it a try guys take your copy and formulate the answer think how it would be possible by drawing a diagram , write some pseudocode, do a dry run of it and It will be done."
                    },
                    {
                        "username": "tragicallyfun",
                        "content": "Leetcode is trying its level best to teach me backtracking"
                    },
                    {
                        "username": "albert_yiyi",
                        "content": "Hi, first post here. Im coding in python3.\\n\\nAs stated in title, the output for \"\" should be [\"\"]\\n\\n**Argument1:**\\n\"2222\" has 3^4 = 81 possible strings\\n\"2\" * n has 3^n possible strings\\n\"\" should have 3^0 = 1 possible string\\n\\n**Argument2:**\\nBob open phone and press 0 button, how many possible strings there are in the chatbox?\\nans: 1\\nwhat is the only possible string?\\nans: \"\" (empty string)\\n\\nSo am i crazy or what?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again solved before. Use hash map! Resubmit"
                    }
                ]
            },
            {
                "id": 1567165,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "It really is a backtracking week y\\'all \\uD83E\\uDD23 3 straight & counting."
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "for real bro "
                    },
                    {
                        "username": "bigapple",
                        "content": "For \"0\" and \"1\", we need need to treat it as a letter, right? for \"0\", dose it mean it can be '0' or ' '?\\nI saw a lot of solution does not include 0 and 1 in the map, which means 0 and 1 will be discarded in the string, which I believe it is wrong. \\nFor 0, are we going to map 0 to only 0, or TWO character: '0' or ' '(space)?"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try reading the constraints as well. it helps a lot . I started doing the same n somehow after a month of practice it made the question more clear to me and got a precise idaes how to approach the ques. BEST of LUCK !"
                    },
                    {
                        "username": "AWells95",
                        "content": "Input constants say digits[i] will be a digits between 2 and 9, so 1 and 0 don\\'t need to be accounted for"
                    },
                    {
                        "username": "spookyflame",
                        "content": "C++:  ```unordered_map<char, string> mp = {{'2', \"abc\"},{'3', \"def\"},{'4', \"ghi\"},{'5', \"jkl\"},{'6', \"mno\"},{'7', \"pqrs\"},{'8', \"tuv\"},{'9', \"wxyz\"}};```\n\nTo access: ```mp[digits[indice]]```\n\nfaster version: ```vector<string> mp = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"} ;```\n\nTo access: ```mp[digits[indice]-48]```"
                    },
                    {
                        "username": "AngryDogman",
                        "content": "You could easily just write n for loops to solve the problem but that doesn\\'t really scale well when n > 4. A good way to think about this problem is how can I simulate n for loops using only one?"
                    },
                    {
                        "username": "jarc",
                        "content": "Each path of DFS is a valid combination. We can solve the problem by enumerating every path."
                    },
                    {
                        "username": "kwu30",
                        "content": "![image](https://assets.leetcode.com/users/images/49fd0d3e-048b-4b99-873c-a54d32642712_1602733607.6318882.png)\\n"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "I am so happy today, I solved a problem of recursion on my own from beginning to end.Also thanks to [@Aditya Rawat](/Aditya_Rawat23) his comment made me feel like , Instead of getting afraid I should give it a try and voila I solved it by myself. Absolutely happy. Those who are not able to solve it , give it a try guys take your copy and formulate the answer think how it would be possible by drawing a diagram , write some pseudocode, do a dry run of it and It will be done."
                    },
                    {
                        "username": "tragicallyfun",
                        "content": "Leetcode is trying its level best to teach me backtracking"
                    },
                    {
                        "username": "albert_yiyi",
                        "content": "Hi, first post here. Im coding in python3.\\n\\nAs stated in title, the output for \"\" should be [\"\"]\\n\\n**Argument1:**\\n\"2222\" has 3^4 = 81 possible strings\\n\"2\" * n has 3^n possible strings\\n\"\" should have 3^0 = 1 possible string\\n\\n**Argument2:**\\nBob open phone and press 0 button, how many possible strings there are in the chatbox?\\nans: 1\\nwhat is the only possible string?\\nans: \"\" (empty string)\\n\\nSo am i crazy or what?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again solved before. Use hash map! Resubmit"
                    }
                ]
            },
            {
                "id": 1574485,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "It really is a backtracking week y\\'all \\uD83E\\uDD23 3 straight & counting."
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "for real bro "
                    },
                    {
                        "username": "bigapple",
                        "content": "For \"0\" and \"1\", we need need to treat it as a letter, right? for \"0\", dose it mean it can be '0' or ' '?\\nI saw a lot of solution does not include 0 and 1 in the map, which means 0 and 1 will be discarded in the string, which I believe it is wrong. \\nFor 0, are we going to map 0 to only 0, or TWO character: '0' or ' '(space)?"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try reading the constraints as well. it helps a lot . I started doing the same n somehow after a month of practice it made the question more clear to me and got a precise idaes how to approach the ques. BEST of LUCK !"
                    },
                    {
                        "username": "AWells95",
                        "content": "Input constants say digits[i] will be a digits between 2 and 9, so 1 and 0 don\\'t need to be accounted for"
                    },
                    {
                        "username": "spookyflame",
                        "content": "C++:  ```unordered_map<char, string> mp = {{'2', \"abc\"},{'3', \"def\"},{'4', \"ghi\"},{'5', \"jkl\"},{'6', \"mno\"},{'7', \"pqrs\"},{'8', \"tuv\"},{'9', \"wxyz\"}};```\n\nTo access: ```mp[digits[indice]]```\n\nfaster version: ```vector<string> mp = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"} ;```\n\nTo access: ```mp[digits[indice]-48]```"
                    },
                    {
                        "username": "AngryDogman",
                        "content": "You could easily just write n for loops to solve the problem but that doesn\\'t really scale well when n > 4. A good way to think about this problem is how can I simulate n for loops using only one?"
                    },
                    {
                        "username": "jarc",
                        "content": "Each path of DFS is a valid combination. We can solve the problem by enumerating every path."
                    },
                    {
                        "username": "kwu30",
                        "content": "![image](https://assets.leetcode.com/users/images/49fd0d3e-048b-4b99-873c-a54d32642712_1602733607.6318882.png)\\n"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "I am so happy today, I solved a problem of recursion on my own from beginning to end.Also thanks to [@Aditya Rawat](/Aditya_Rawat23) his comment made me feel like , Instead of getting afraid I should give it a try and voila I solved it by myself. Absolutely happy. Those who are not able to solve it , give it a try guys take your copy and formulate the answer think how it would be possible by drawing a diagram , write some pseudocode, do a dry run of it and It will be done."
                    },
                    {
                        "username": "tragicallyfun",
                        "content": "Leetcode is trying its level best to teach me backtracking"
                    },
                    {
                        "username": "albert_yiyi",
                        "content": "Hi, first post here. Im coding in python3.\\n\\nAs stated in title, the output for \"\" should be [\"\"]\\n\\n**Argument1:**\\n\"2222\" has 3^4 = 81 possible strings\\n\"2\" * n has 3^n possible strings\\n\"\" should have 3^0 = 1 possible string\\n\\n**Argument2:**\\nBob open phone and press 0 button, how many possible strings there are in the chatbox?\\nans: 1\\nwhat is the only possible string?\\nans: \"\" (empty string)\\n\\nSo am i crazy or what?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again solved before. Use hash map! Resubmit"
                    }
                ]
            },
            {
                "id": 1998390,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "It really is a backtracking week y\\'all \\uD83E\\uDD23 3 straight & counting."
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "for real bro "
                    },
                    {
                        "username": "bigapple",
                        "content": "For \"0\" and \"1\", we need need to treat it as a letter, right? for \"0\", dose it mean it can be '0' or ' '?\\nI saw a lot of solution does not include 0 and 1 in the map, which means 0 and 1 will be discarded in the string, which I believe it is wrong. \\nFor 0, are we going to map 0 to only 0, or TWO character: '0' or ' '(space)?"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try reading the constraints as well. it helps a lot . I started doing the same n somehow after a month of practice it made the question more clear to me and got a precise idaes how to approach the ques. BEST of LUCK !"
                    },
                    {
                        "username": "AWells95",
                        "content": "Input constants say digits[i] will be a digits between 2 and 9, so 1 and 0 don\\'t need to be accounted for"
                    },
                    {
                        "username": "spookyflame",
                        "content": "C++:  ```unordered_map<char, string> mp = {{'2', \"abc\"},{'3', \"def\"},{'4', \"ghi\"},{'5', \"jkl\"},{'6', \"mno\"},{'7', \"pqrs\"},{'8', \"tuv\"},{'9', \"wxyz\"}};```\n\nTo access: ```mp[digits[indice]]```\n\nfaster version: ```vector<string> mp = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"} ;```\n\nTo access: ```mp[digits[indice]-48]```"
                    },
                    {
                        "username": "AngryDogman",
                        "content": "You could easily just write n for loops to solve the problem but that doesn\\'t really scale well when n > 4. A good way to think about this problem is how can I simulate n for loops using only one?"
                    },
                    {
                        "username": "jarc",
                        "content": "Each path of DFS is a valid combination. We can solve the problem by enumerating every path."
                    },
                    {
                        "username": "kwu30",
                        "content": "![image](https://assets.leetcode.com/users/images/49fd0d3e-048b-4b99-873c-a54d32642712_1602733607.6318882.png)\\n"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "I am so happy today, I solved a problem of recursion on my own from beginning to end.Also thanks to [@Aditya Rawat](/Aditya_Rawat23) his comment made me feel like , Instead of getting afraid I should give it a try and voila I solved it by myself. Absolutely happy. Those who are not able to solve it , give it a try guys take your copy and formulate the answer think how it would be possible by drawing a diagram , write some pseudocode, do a dry run of it and It will be done."
                    },
                    {
                        "username": "tragicallyfun",
                        "content": "Leetcode is trying its level best to teach me backtracking"
                    },
                    {
                        "username": "albert_yiyi",
                        "content": "Hi, first post here. Im coding in python3.\\n\\nAs stated in title, the output for \"\" should be [\"\"]\\n\\n**Argument1:**\\n\"2222\" has 3^4 = 81 possible strings\\n\"2\" * n has 3^n possible strings\\n\"\" should have 3^0 = 1 possible string\\n\\n**Argument2:**\\nBob open phone and press 0 button, how many possible strings there are in the chatbox?\\nans: 1\\nwhat is the only possible string?\\nans: \"\" (empty string)\\n\\nSo am i crazy or what?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again solved before. Use hash map! Resubmit"
                    }
                ]
            },
            {
                "id": 1998106,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "It really is a backtracking week y\\'all \\uD83E\\uDD23 3 straight & counting."
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "for real bro "
                    },
                    {
                        "username": "bigapple",
                        "content": "For \"0\" and \"1\", we need need to treat it as a letter, right? for \"0\", dose it mean it can be '0' or ' '?\\nI saw a lot of solution does not include 0 and 1 in the map, which means 0 and 1 will be discarded in the string, which I believe it is wrong. \\nFor 0, are we going to map 0 to only 0, or TWO character: '0' or ' '(space)?"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try reading the constraints as well. it helps a lot . I started doing the same n somehow after a month of practice it made the question more clear to me and got a precise idaes how to approach the ques. BEST of LUCK !"
                    },
                    {
                        "username": "AWells95",
                        "content": "Input constants say digits[i] will be a digits between 2 and 9, so 1 and 0 don\\'t need to be accounted for"
                    },
                    {
                        "username": "spookyflame",
                        "content": "C++:  ```unordered_map<char, string> mp = {{'2', \"abc\"},{'3', \"def\"},{'4', \"ghi\"},{'5', \"jkl\"},{'6', \"mno\"},{'7', \"pqrs\"},{'8', \"tuv\"},{'9', \"wxyz\"}};```\n\nTo access: ```mp[digits[indice]]```\n\nfaster version: ```vector<string> mp = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"} ;```\n\nTo access: ```mp[digits[indice]-48]```"
                    },
                    {
                        "username": "AngryDogman",
                        "content": "You could easily just write n for loops to solve the problem but that doesn\\'t really scale well when n > 4. A good way to think about this problem is how can I simulate n for loops using only one?"
                    },
                    {
                        "username": "jarc",
                        "content": "Each path of DFS is a valid combination. We can solve the problem by enumerating every path."
                    },
                    {
                        "username": "kwu30",
                        "content": "![image](https://assets.leetcode.com/users/images/49fd0d3e-048b-4b99-873c-a54d32642712_1602733607.6318882.png)\\n"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "I am so happy today, I solved a problem of recursion on my own from beginning to end.Also thanks to [@Aditya Rawat](/Aditya_Rawat23) his comment made me feel like , Instead of getting afraid I should give it a try and voila I solved it by myself. Absolutely happy. Those who are not able to solve it , give it a try guys take your copy and formulate the answer think how it would be possible by drawing a diagram , write some pseudocode, do a dry run of it and It will be done."
                    },
                    {
                        "username": "tragicallyfun",
                        "content": "Leetcode is trying its level best to teach me backtracking"
                    },
                    {
                        "username": "albert_yiyi",
                        "content": "Hi, first post here. Im coding in python3.\\n\\nAs stated in title, the output for \"\" should be [\"\"]\\n\\n**Argument1:**\\n\"2222\" has 3^4 = 81 possible strings\\n\"2\" * n has 3^n possible strings\\n\"\" should have 3^0 = 1 possible string\\n\\n**Argument2:**\\nBob open phone and press 0 button, how many possible strings there are in the chatbox?\\nans: 1\\nwhat is the only possible string?\\nans: \"\" (empty string)\\n\\nSo am i crazy or what?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again solved before. Use hash map! Resubmit"
                    }
                ]
            },
            {
                "id": 1573506,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "It really is a backtracking week y\\'all \\uD83E\\uDD23 3 straight & counting."
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "for real bro "
                    },
                    {
                        "username": "bigapple",
                        "content": "For \"0\" and \"1\", we need need to treat it as a letter, right? for \"0\", dose it mean it can be '0' or ' '?\\nI saw a lot of solution does not include 0 and 1 in the map, which means 0 and 1 will be discarded in the string, which I believe it is wrong. \\nFor 0, are we going to map 0 to only 0, or TWO character: '0' or ' '(space)?"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try reading the constraints as well. it helps a lot . I started doing the same n somehow after a month of practice it made the question more clear to me and got a precise idaes how to approach the ques. BEST of LUCK !"
                    },
                    {
                        "username": "AWells95",
                        "content": "Input constants say digits[i] will be a digits between 2 and 9, so 1 and 0 don\\'t need to be accounted for"
                    },
                    {
                        "username": "spookyflame",
                        "content": "C++:  ```unordered_map<char, string> mp = {{'2', \"abc\"},{'3', \"def\"},{'4', \"ghi\"},{'5', \"jkl\"},{'6', \"mno\"},{'7', \"pqrs\"},{'8', \"tuv\"},{'9', \"wxyz\"}};```\n\nTo access: ```mp[digits[indice]]```\n\nfaster version: ```vector<string> mp = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"} ;```\n\nTo access: ```mp[digits[indice]-48]```"
                    },
                    {
                        "username": "AngryDogman",
                        "content": "You could easily just write n for loops to solve the problem but that doesn\\'t really scale well when n > 4. A good way to think about this problem is how can I simulate n for loops using only one?"
                    },
                    {
                        "username": "jarc",
                        "content": "Each path of DFS is a valid combination. We can solve the problem by enumerating every path."
                    },
                    {
                        "username": "kwu30",
                        "content": "![image](https://assets.leetcode.com/users/images/49fd0d3e-048b-4b99-873c-a54d32642712_1602733607.6318882.png)\\n"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "I am so happy today, I solved a problem of recursion on my own from beginning to end.Also thanks to [@Aditya Rawat](/Aditya_Rawat23) his comment made me feel like , Instead of getting afraid I should give it a try and voila I solved it by myself. Absolutely happy. Those who are not able to solve it , give it a try guys take your copy and formulate the answer think how it would be possible by drawing a diagram , write some pseudocode, do a dry run of it and It will be done."
                    },
                    {
                        "username": "tragicallyfun",
                        "content": "Leetcode is trying its level best to teach me backtracking"
                    },
                    {
                        "username": "albert_yiyi",
                        "content": "Hi, first post here. Im coding in python3.\\n\\nAs stated in title, the output for \"\" should be [\"\"]\\n\\n**Argument1:**\\n\"2222\" has 3^4 = 81 possible strings\\n\"2\" * n has 3^n possible strings\\n\"\" should have 3^0 = 1 possible string\\n\\n**Argument2:**\\nBob open phone and press 0 button, how many possible strings there are in the chatbox?\\nans: 1\\nwhat is the only possible string?\\nans: \"\" (empty string)\\n\\nSo am i crazy or what?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again solved before. Use hash map! Resubmit"
                    }
                ]
            },
            {
                "id": 1997837,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "It really is a backtracking week y\\'all \\uD83E\\uDD23 3 straight & counting."
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "for real bro "
                    },
                    {
                        "username": "bigapple",
                        "content": "For \"0\" and \"1\", we need need to treat it as a letter, right? for \"0\", dose it mean it can be '0' or ' '?\\nI saw a lot of solution does not include 0 and 1 in the map, which means 0 and 1 will be discarded in the string, which I believe it is wrong. \\nFor 0, are we going to map 0 to only 0, or TWO character: '0' or ' '(space)?"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try reading the constraints as well. it helps a lot . I started doing the same n somehow after a month of practice it made the question more clear to me and got a precise idaes how to approach the ques. BEST of LUCK !"
                    },
                    {
                        "username": "AWells95",
                        "content": "Input constants say digits[i] will be a digits between 2 and 9, so 1 and 0 don\\'t need to be accounted for"
                    },
                    {
                        "username": "spookyflame",
                        "content": "C++:  ```unordered_map<char, string> mp = {{'2', \"abc\"},{'3', \"def\"},{'4', \"ghi\"},{'5', \"jkl\"},{'6', \"mno\"},{'7', \"pqrs\"},{'8', \"tuv\"},{'9', \"wxyz\"}};```\n\nTo access: ```mp[digits[indice]]```\n\nfaster version: ```vector<string> mp = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"} ;```\n\nTo access: ```mp[digits[indice]-48]```"
                    },
                    {
                        "username": "AngryDogman",
                        "content": "You could easily just write n for loops to solve the problem but that doesn\\'t really scale well when n > 4. A good way to think about this problem is how can I simulate n for loops using only one?"
                    },
                    {
                        "username": "jarc",
                        "content": "Each path of DFS is a valid combination. We can solve the problem by enumerating every path."
                    },
                    {
                        "username": "kwu30",
                        "content": "![image](https://assets.leetcode.com/users/images/49fd0d3e-048b-4b99-873c-a54d32642712_1602733607.6318882.png)\\n"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "I am so happy today, I solved a problem of recursion on my own from beginning to end.Also thanks to [@Aditya Rawat](/Aditya_Rawat23) his comment made me feel like , Instead of getting afraid I should give it a try and voila I solved it by myself. Absolutely happy. Those who are not able to solve it , give it a try guys take your copy and formulate the answer think how it would be possible by drawing a diagram , write some pseudocode, do a dry run of it and It will be done."
                    },
                    {
                        "username": "tragicallyfun",
                        "content": "Leetcode is trying its level best to teach me backtracking"
                    },
                    {
                        "username": "albert_yiyi",
                        "content": "Hi, first post here. Im coding in python3.\\n\\nAs stated in title, the output for \"\" should be [\"\"]\\n\\n**Argument1:**\\n\"2222\" has 3^4 = 81 possible strings\\n\"2\" * n has 3^n possible strings\\n\"\" should have 3^0 = 1 possible string\\n\\n**Argument2:**\\nBob open phone and press 0 button, how many possible strings there are in the chatbox?\\nans: 1\\nwhat is the only possible string?\\nans: \"\" (empty string)\\n\\nSo am i crazy or what?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again solved before. Use hash map! Resubmit"
                    }
                ]
            },
            {
                "id": 1751382,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5 Easy C++ Solution\\uD83D\\uDE2C || FAANG INTERVIEW CODE\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3031239/easy-c-solution-faang-interview-code/?orderBy=most_votes"
                    },
                    {
                        "username": "mochiball",
                        "content": "Trash. Stop this spam "
                    },
                    {
                        "username": "prakhar432",
                        "content": "Hey, please upload your solution under the solutions tab once. You do not need to spam the same answer in all discussion tabs. This is not a youtube comment section. Thanks"
                    },
                    {
                        "username": "Under_developed",
                        "content": "Dont do they unlock the editorial for the daily challenges ?\\nIn the previous month i saw there was editorial for each daily question."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Step1: if given digits size is 0. return NULL.\\nStep2: store the phone numbers character in vector of string.\\nStep3: call the recursion and pass index =0 which will go upto n (size of digits string Given).\\nStep4: check if ind equals to n . store the temp in answer.\\nStep5: get the find number from digits string, by digits[ind]-\\'0\\'.\\nStep6: run a loop to traverse all the character of that number.\\nStep7: Store the character in temp. of number character.\\nStep8: call the recursion on next index+1.\\nbecause at first place we already store the index of first number.so on second index we have to store character of second number.\\nStep9: remove the last number characte which was inserted.\\n  Step(7 to 9) is backtracking. \\n\\n- Time complexity:\\nT.C=O(n*4^n) In worst case for digit having 4 character.have choice of 4. n digit we have to select. \\n\\n- Space complexity:\\nS.C=O(n). at most the temp can store is upto n.\\n\\n----------------------------\\nPlease hit the Upvote button. If you Understand the concept.\\nSolution Link:\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3637710/c-recursion-backtracking-most-of-the-people-done-wrong-time-and-space-complexity/"
                    },
                    {
                        "username": "kun22",
                        "content": "Where N is the length of the phone number, and K is the number of possible letters for each number.  "
                    },
                    {
                        "username": "yangjufo",
                        "content": "So there is no duplicate condition such as \"22\"?"
                    },
                    {
                        "username": "palindrome88",
                        "content": "What is the space complexity for DFS approach?"
                    },
                    {
                        "username": "navgupta14",
                        "content": "For an input like \"213\" - \\nthe output should be \\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"].\\nIt returns empty vector as the result.\\n\\nNote that 1 has an empty string associated with it."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "@administrators :\\nIs \"12\" a valid test case ? Because, I was considering combinations for 1 which is 1 itself and generating the output. I get the submission as \"Accepted\" even though my answer does not match the \"Expected answer\" . PFA screenshot .\\n\\n![0_1477514483405_Telephone number combination.JPG](/uploads/files/1477514485474-telephone-number-combination.jpg)"
                    },
                    {
                        "username": "ujp17",
                        "content": "When I give test case as \"3\" and click on \"Run Code\" , I am getting correct solution of [\"d\",\"e\",\"f\"] , but when I run \"Submit Solution\" , it breaks at test case input \"3\" with my output as [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]."
                    },
                    {
                        "username": "faye231019",
                        "content": "Case 1\\nEdit\\n\\'23\\'   is not a valid value of type string\\nupdated your editor its not versatile !!"
                    }
                ]
            },
            {
                "id": 1998196,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5 Easy C++ Solution\\uD83D\\uDE2C || FAANG INTERVIEW CODE\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3031239/easy-c-solution-faang-interview-code/?orderBy=most_votes"
                    },
                    {
                        "username": "mochiball",
                        "content": "Trash. Stop this spam "
                    },
                    {
                        "username": "prakhar432",
                        "content": "Hey, please upload your solution under the solutions tab once. You do not need to spam the same answer in all discussion tabs. This is not a youtube comment section. Thanks"
                    },
                    {
                        "username": "Under_developed",
                        "content": "Dont do they unlock the editorial for the daily challenges ?\\nIn the previous month i saw there was editorial for each daily question."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Step1: if given digits size is 0. return NULL.\\nStep2: store the phone numbers character in vector of string.\\nStep3: call the recursion and pass index =0 which will go upto n (size of digits string Given).\\nStep4: check if ind equals to n . store the temp in answer.\\nStep5: get the find number from digits string, by digits[ind]-\\'0\\'.\\nStep6: run a loop to traverse all the character of that number.\\nStep7: Store the character in temp. of number character.\\nStep8: call the recursion on next index+1.\\nbecause at first place we already store the index of first number.so on second index we have to store character of second number.\\nStep9: remove the last number characte which was inserted.\\n  Step(7 to 9) is backtracking. \\n\\n- Time complexity:\\nT.C=O(n*4^n) In worst case for digit having 4 character.have choice of 4. n digit we have to select. \\n\\n- Space complexity:\\nS.C=O(n). at most the temp can store is upto n.\\n\\n----------------------------\\nPlease hit the Upvote button. If you Understand the concept.\\nSolution Link:\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3637710/c-recursion-backtracking-most-of-the-people-done-wrong-time-and-space-complexity/"
                    },
                    {
                        "username": "kun22",
                        "content": "Where N is the length of the phone number, and K is the number of possible letters for each number.  "
                    },
                    {
                        "username": "yangjufo",
                        "content": "So there is no duplicate condition such as \"22\"?"
                    },
                    {
                        "username": "palindrome88",
                        "content": "What is the space complexity for DFS approach?"
                    },
                    {
                        "username": "navgupta14",
                        "content": "For an input like \"213\" - \\nthe output should be \\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"].\\nIt returns empty vector as the result.\\n\\nNote that 1 has an empty string associated with it."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "@administrators :\\nIs \"12\" a valid test case ? Because, I was considering combinations for 1 which is 1 itself and generating the output. I get the submission as \"Accepted\" even though my answer does not match the \"Expected answer\" . PFA screenshot .\\n\\n![0_1477514483405_Telephone number combination.JPG](/uploads/files/1477514485474-telephone-number-combination.jpg)"
                    },
                    {
                        "username": "ujp17",
                        "content": "When I give test case as \"3\" and click on \"Run Code\" , I am getting correct solution of [\"d\",\"e\",\"f\"] , but when I run \"Submit Solution\" , it breaks at test case input \"3\" with my output as [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]."
                    },
                    {
                        "username": "faye231019",
                        "content": "Case 1\\nEdit\\n\\'23\\'   is not a valid value of type string\\nupdated your editor its not versatile !!"
                    }
                ]
            },
            {
                "id": 1929331,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5 Easy C++ Solution\\uD83D\\uDE2C || FAANG INTERVIEW CODE\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3031239/easy-c-solution-faang-interview-code/?orderBy=most_votes"
                    },
                    {
                        "username": "mochiball",
                        "content": "Trash. Stop this spam "
                    },
                    {
                        "username": "prakhar432",
                        "content": "Hey, please upload your solution under the solutions tab once. You do not need to spam the same answer in all discussion tabs. This is not a youtube comment section. Thanks"
                    },
                    {
                        "username": "Under_developed",
                        "content": "Dont do they unlock the editorial for the daily challenges ?\\nIn the previous month i saw there was editorial for each daily question."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Step1: if given digits size is 0. return NULL.\\nStep2: store the phone numbers character in vector of string.\\nStep3: call the recursion and pass index =0 which will go upto n (size of digits string Given).\\nStep4: check if ind equals to n . store the temp in answer.\\nStep5: get the find number from digits string, by digits[ind]-\\'0\\'.\\nStep6: run a loop to traverse all the character of that number.\\nStep7: Store the character in temp. of number character.\\nStep8: call the recursion on next index+1.\\nbecause at first place we already store the index of first number.so on second index we have to store character of second number.\\nStep9: remove the last number characte which was inserted.\\n  Step(7 to 9) is backtracking. \\n\\n- Time complexity:\\nT.C=O(n*4^n) In worst case for digit having 4 character.have choice of 4. n digit we have to select. \\n\\n- Space complexity:\\nS.C=O(n). at most the temp can store is upto n.\\n\\n----------------------------\\nPlease hit the Upvote button. If you Understand the concept.\\nSolution Link:\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3637710/c-recursion-backtracking-most-of-the-people-done-wrong-time-and-space-complexity/"
                    },
                    {
                        "username": "kun22",
                        "content": "Where N is the length of the phone number, and K is the number of possible letters for each number.  "
                    },
                    {
                        "username": "yangjufo",
                        "content": "So there is no duplicate condition such as \"22\"?"
                    },
                    {
                        "username": "palindrome88",
                        "content": "What is the space complexity for DFS approach?"
                    },
                    {
                        "username": "navgupta14",
                        "content": "For an input like \"213\" - \\nthe output should be \\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"].\\nIt returns empty vector as the result.\\n\\nNote that 1 has an empty string associated with it."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "@administrators :\\nIs \"12\" a valid test case ? Because, I was considering combinations for 1 which is 1 itself and generating the output. I get the submission as \"Accepted\" even though my answer does not match the \"Expected answer\" . PFA screenshot .\\n\\n![0_1477514483405_Telephone number combination.JPG](/uploads/files/1477514485474-telephone-number-combination.jpg)"
                    },
                    {
                        "username": "ujp17",
                        "content": "When I give test case as \"3\" and click on \"Run Code\" , I am getting correct solution of [\"d\",\"e\",\"f\"] , but when I run \"Submit Solution\" , it breaks at test case input \"3\" with my output as [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]."
                    },
                    {
                        "username": "faye231019",
                        "content": "Case 1\\nEdit\\n\\'23\\'   is not a valid value of type string\\nupdated your editor its not versatile !!"
                    }
                ]
            },
            {
                "id": 1572091,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5 Easy C++ Solution\\uD83D\\uDE2C || FAANG INTERVIEW CODE\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3031239/easy-c-solution-faang-interview-code/?orderBy=most_votes"
                    },
                    {
                        "username": "mochiball",
                        "content": "Trash. Stop this spam "
                    },
                    {
                        "username": "prakhar432",
                        "content": "Hey, please upload your solution under the solutions tab once. You do not need to spam the same answer in all discussion tabs. This is not a youtube comment section. Thanks"
                    },
                    {
                        "username": "Under_developed",
                        "content": "Dont do they unlock the editorial for the daily challenges ?\\nIn the previous month i saw there was editorial for each daily question."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Step1: if given digits size is 0. return NULL.\\nStep2: store the phone numbers character in vector of string.\\nStep3: call the recursion and pass index =0 which will go upto n (size of digits string Given).\\nStep4: check if ind equals to n . store the temp in answer.\\nStep5: get the find number from digits string, by digits[ind]-\\'0\\'.\\nStep6: run a loop to traverse all the character of that number.\\nStep7: Store the character in temp. of number character.\\nStep8: call the recursion on next index+1.\\nbecause at first place we already store the index of first number.so on second index we have to store character of second number.\\nStep9: remove the last number characte which was inserted.\\n  Step(7 to 9) is backtracking. \\n\\n- Time complexity:\\nT.C=O(n*4^n) In worst case for digit having 4 character.have choice of 4. n digit we have to select. \\n\\n- Space complexity:\\nS.C=O(n). at most the temp can store is upto n.\\n\\n----------------------------\\nPlease hit the Upvote button. If you Understand the concept.\\nSolution Link:\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3637710/c-recursion-backtracking-most-of-the-people-done-wrong-time-and-space-complexity/"
                    },
                    {
                        "username": "kun22",
                        "content": "Where N is the length of the phone number, and K is the number of possible letters for each number.  "
                    },
                    {
                        "username": "yangjufo",
                        "content": "So there is no duplicate condition such as \"22\"?"
                    },
                    {
                        "username": "palindrome88",
                        "content": "What is the space complexity for DFS approach?"
                    },
                    {
                        "username": "navgupta14",
                        "content": "For an input like \"213\" - \\nthe output should be \\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"].\\nIt returns empty vector as the result.\\n\\nNote that 1 has an empty string associated with it."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "@administrators :\\nIs \"12\" a valid test case ? Because, I was considering combinations for 1 which is 1 itself and generating the output. I get the submission as \"Accepted\" even though my answer does not match the \"Expected answer\" . PFA screenshot .\\n\\n![0_1477514483405_Telephone number combination.JPG](/uploads/files/1477514485474-telephone-number-combination.jpg)"
                    },
                    {
                        "username": "ujp17",
                        "content": "When I give test case as \"3\" and click on \"Run Code\" , I am getting correct solution of [\"d\",\"e\",\"f\"] , but when I run \"Submit Solution\" , it breaks at test case input \"3\" with my output as [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]."
                    },
                    {
                        "username": "faye231019",
                        "content": "Case 1\\nEdit\\n\\'23\\'   is not a valid value of type string\\nupdated your editor its not versatile !!"
                    }
                ]
            },
            {
                "id": 1571907,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5 Easy C++ Solution\\uD83D\\uDE2C || FAANG INTERVIEW CODE\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3031239/easy-c-solution-faang-interview-code/?orderBy=most_votes"
                    },
                    {
                        "username": "mochiball",
                        "content": "Trash. Stop this spam "
                    },
                    {
                        "username": "prakhar432",
                        "content": "Hey, please upload your solution under the solutions tab once. You do not need to spam the same answer in all discussion tabs. This is not a youtube comment section. Thanks"
                    },
                    {
                        "username": "Under_developed",
                        "content": "Dont do they unlock the editorial for the daily challenges ?\\nIn the previous month i saw there was editorial for each daily question."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Step1: if given digits size is 0. return NULL.\\nStep2: store the phone numbers character in vector of string.\\nStep3: call the recursion and pass index =0 which will go upto n (size of digits string Given).\\nStep4: check if ind equals to n . store the temp in answer.\\nStep5: get the find number from digits string, by digits[ind]-\\'0\\'.\\nStep6: run a loop to traverse all the character of that number.\\nStep7: Store the character in temp. of number character.\\nStep8: call the recursion on next index+1.\\nbecause at first place we already store the index of first number.so on second index we have to store character of second number.\\nStep9: remove the last number characte which was inserted.\\n  Step(7 to 9) is backtracking. \\n\\n- Time complexity:\\nT.C=O(n*4^n) In worst case for digit having 4 character.have choice of 4. n digit we have to select. \\n\\n- Space complexity:\\nS.C=O(n). at most the temp can store is upto n.\\n\\n----------------------------\\nPlease hit the Upvote button. If you Understand the concept.\\nSolution Link:\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3637710/c-recursion-backtracking-most-of-the-people-done-wrong-time-and-space-complexity/"
                    },
                    {
                        "username": "kun22",
                        "content": "Where N is the length of the phone number, and K is the number of possible letters for each number.  "
                    },
                    {
                        "username": "yangjufo",
                        "content": "So there is no duplicate condition such as \"22\"?"
                    },
                    {
                        "username": "palindrome88",
                        "content": "What is the space complexity for DFS approach?"
                    },
                    {
                        "username": "navgupta14",
                        "content": "For an input like \"213\" - \\nthe output should be \\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"].\\nIt returns empty vector as the result.\\n\\nNote that 1 has an empty string associated with it."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "@administrators :\\nIs \"12\" a valid test case ? Because, I was considering combinations for 1 which is 1 itself and generating the output. I get the submission as \"Accepted\" even though my answer does not match the \"Expected answer\" . PFA screenshot .\\n\\n![0_1477514483405_Telephone number combination.JPG](/uploads/files/1477514485474-telephone-number-combination.jpg)"
                    },
                    {
                        "username": "ujp17",
                        "content": "When I give test case as \"3\" and click on \"Run Code\" , I am getting correct solution of [\"d\",\"e\",\"f\"] , but when I run \"Submit Solution\" , it breaks at test case input \"3\" with my output as [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]."
                    },
                    {
                        "username": "faye231019",
                        "content": "Case 1\\nEdit\\n\\'23\\'   is not a valid value of type string\\nupdated your editor its not versatile !!"
                    }
                ]
            },
            {
                "id": 1571851,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5 Easy C++ Solution\\uD83D\\uDE2C || FAANG INTERVIEW CODE\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3031239/easy-c-solution-faang-interview-code/?orderBy=most_votes"
                    },
                    {
                        "username": "mochiball",
                        "content": "Trash. Stop this spam "
                    },
                    {
                        "username": "prakhar432",
                        "content": "Hey, please upload your solution under the solutions tab once. You do not need to spam the same answer in all discussion tabs. This is not a youtube comment section. Thanks"
                    },
                    {
                        "username": "Under_developed",
                        "content": "Dont do they unlock the editorial for the daily challenges ?\\nIn the previous month i saw there was editorial for each daily question."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Step1: if given digits size is 0. return NULL.\\nStep2: store the phone numbers character in vector of string.\\nStep3: call the recursion and pass index =0 which will go upto n (size of digits string Given).\\nStep4: check if ind equals to n . store the temp in answer.\\nStep5: get the find number from digits string, by digits[ind]-\\'0\\'.\\nStep6: run a loop to traverse all the character of that number.\\nStep7: Store the character in temp. of number character.\\nStep8: call the recursion on next index+1.\\nbecause at first place we already store the index of first number.so on second index we have to store character of second number.\\nStep9: remove the last number characte which was inserted.\\n  Step(7 to 9) is backtracking. \\n\\n- Time complexity:\\nT.C=O(n*4^n) In worst case for digit having 4 character.have choice of 4. n digit we have to select. \\n\\n- Space complexity:\\nS.C=O(n). at most the temp can store is upto n.\\n\\n----------------------------\\nPlease hit the Upvote button. If you Understand the concept.\\nSolution Link:\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3637710/c-recursion-backtracking-most-of-the-people-done-wrong-time-and-space-complexity/"
                    },
                    {
                        "username": "kun22",
                        "content": "Where N is the length of the phone number, and K is the number of possible letters for each number.  "
                    },
                    {
                        "username": "yangjufo",
                        "content": "So there is no duplicate condition such as \"22\"?"
                    },
                    {
                        "username": "palindrome88",
                        "content": "What is the space complexity for DFS approach?"
                    },
                    {
                        "username": "navgupta14",
                        "content": "For an input like \"213\" - \\nthe output should be \\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"].\\nIt returns empty vector as the result.\\n\\nNote that 1 has an empty string associated with it."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "@administrators :\\nIs \"12\" a valid test case ? Because, I was considering combinations for 1 which is 1 itself and generating the output. I get the submission as \"Accepted\" even though my answer does not match the \"Expected answer\" . PFA screenshot .\\n\\n![0_1477514483405_Telephone number combination.JPG](/uploads/files/1477514485474-telephone-number-combination.jpg)"
                    },
                    {
                        "username": "ujp17",
                        "content": "When I give test case as \"3\" and click on \"Run Code\" , I am getting correct solution of [\"d\",\"e\",\"f\"] , but when I run \"Submit Solution\" , it breaks at test case input \"3\" with my output as [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]."
                    },
                    {
                        "username": "faye231019",
                        "content": "Case 1\\nEdit\\n\\'23\\'   is not a valid value of type string\\nupdated your editor its not versatile !!"
                    }
                ]
            },
            {
                "id": 1571045,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5 Easy C++ Solution\\uD83D\\uDE2C || FAANG INTERVIEW CODE\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3031239/easy-c-solution-faang-interview-code/?orderBy=most_votes"
                    },
                    {
                        "username": "mochiball",
                        "content": "Trash. Stop this spam "
                    },
                    {
                        "username": "prakhar432",
                        "content": "Hey, please upload your solution under the solutions tab once. You do not need to spam the same answer in all discussion tabs. This is not a youtube comment section. Thanks"
                    },
                    {
                        "username": "Under_developed",
                        "content": "Dont do they unlock the editorial for the daily challenges ?\\nIn the previous month i saw there was editorial for each daily question."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Step1: if given digits size is 0. return NULL.\\nStep2: store the phone numbers character in vector of string.\\nStep3: call the recursion and pass index =0 which will go upto n (size of digits string Given).\\nStep4: check if ind equals to n . store the temp in answer.\\nStep5: get the find number from digits string, by digits[ind]-\\'0\\'.\\nStep6: run a loop to traverse all the character of that number.\\nStep7: Store the character in temp. of number character.\\nStep8: call the recursion on next index+1.\\nbecause at first place we already store the index of first number.so on second index we have to store character of second number.\\nStep9: remove the last number characte which was inserted.\\n  Step(7 to 9) is backtracking. \\n\\n- Time complexity:\\nT.C=O(n*4^n) In worst case for digit having 4 character.have choice of 4. n digit we have to select. \\n\\n- Space complexity:\\nS.C=O(n). at most the temp can store is upto n.\\n\\n----------------------------\\nPlease hit the Upvote button. If you Understand the concept.\\nSolution Link:\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3637710/c-recursion-backtracking-most-of-the-people-done-wrong-time-and-space-complexity/"
                    },
                    {
                        "username": "kun22",
                        "content": "Where N is the length of the phone number, and K is the number of possible letters for each number.  "
                    },
                    {
                        "username": "yangjufo",
                        "content": "So there is no duplicate condition such as \"22\"?"
                    },
                    {
                        "username": "palindrome88",
                        "content": "What is the space complexity for DFS approach?"
                    },
                    {
                        "username": "navgupta14",
                        "content": "For an input like \"213\" - \\nthe output should be \\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"].\\nIt returns empty vector as the result.\\n\\nNote that 1 has an empty string associated with it."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "@administrators :\\nIs \"12\" a valid test case ? Because, I was considering combinations for 1 which is 1 itself and generating the output. I get the submission as \"Accepted\" even though my answer does not match the \"Expected answer\" . PFA screenshot .\\n\\n![0_1477514483405_Telephone number combination.JPG](/uploads/files/1477514485474-telephone-number-combination.jpg)"
                    },
                    {
                        "username": "ujp17",
                        "content": "When I give test case as \"3\" and click on \"Run Code\" , I am getting correct solution of [\"d\",\"e\",\"f\"] , but when I run \"Submit Solution\" , it breaks at test case input \"3\" with my output as [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]."
                    },
                    {
                        "username": "faye231019",
                        "content": "Case 1\\nEdit\\n\\'23\\'   is not a valid value of type string\\nupdated your editor its not versatile !!"
                    }
                ]
            },
            {
                "id": 1571046,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5 Easy C++ Solution\\uD83D\\uDE2C || FAANG INTERVIEW CODE\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3031239/easy-c-solution-faang-interview-code/?orderBy=most_votes"
                    },
                    {
                        "username": "mochiball",
                        "content": "Trash. Stop this spam "
                    },
                    {
                        "username": "prakhar432",
                        "content": "Hey, please upload your solution under the solutions tab once. You do not need to spam the same answer in all discussion tabs. This is not a youtube comment section. Thanks"
                    },
                    {
                        "username": "Under_developed",
                        "content": "Dont do they unlock the editorial for the daily challenges ?\\nIn the previous month i saw there was editorial for each daily question."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Step1: if given digits size is 0. return NULL.\\nStep2: store the phone numbers character in vector of string.\\nStep3: call the recursion and pass index =0 which will go upto n (size of digits string Given).\\nStep4: check if ind equals to n . store the temp in answer.\\nStep5: get the find number from digits string, by digits[ind]-\\'0\\'.\\nStep6: run a loop to traverse all the character of that number.\\nStep7: Store the character in temp. of number character.\\nStep8: call the recursion on next index+1.\\nbecause at first place we already store the index of first number.so on second index we have to store character of second number.\\nStep9: remove the last number characte which was inserted.\\n  Step(7 to 9) is backtracking. \\n\\n- Time complexity:\\nT.C=O(n*4^n) In worst case for digit having 4 character.have choice of 4. n digit we have to select. \\n\\n- Space complexity:\\nS.C=O(n). at most the temp can store is upto n.\\n\\n----------------------------\\nPlease hit the Upvote button. If you Understand the concept.\\nSolution Link:\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3637710/c-recursion-backtracking-most-of-the-people-done-wrong-time-and-space-complexity/"
                    },
                    {
                        "username": "kun22",
                        "content": "Where N is the length of the phone number, and K is the number of possible letters for each number.  "
                    },
                    {
                        "username": "yangjufo",
                        "content": "So there is no duplicate condition such as \"22\"?"
                    },
                    {
                        "username": "palindrome88",
                        "content": "What is the space complexity for DFS approach?"
                    },
                    {
                        "username": "navgupta14",
                        "content": "For an input like \"213\" - \\nthe output should be \\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"].\\nIt returns empty vector as the result.\\n\\nNote that 1 has an empty string associated with it."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "@administrators :\\nIs \"12\" a valid test case ? Because, I was considering combinations for 1 which is 1 itself and generating the output. I get the submission as \"Accepted\" even though my answer does not match the \"Expected answer\" . PFA screenshot .\\n\\n![0_1477514483405_Telephone number combination.JPG](/uploads/files/1477514485474-telephone-number-combination.jpg)"
                    },
                    {
                        "username": "ujp17",
                        "content": "When I give test case as \"3\" and click on \"Run Code\" , I am getting correct solution of [\"d\",\"e\",\"f\"] , but when I run \"Submit Solution\" , it breaks at test case input \"3\" with my output as [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]."
                    },
                    {
                        "username": "faye231019",
                        "content": "Case 1\\nEdit\\n\\'23\\'   is not a valid value of type string\\nupdated your editor its not versatile !!"
                    }
                ]
            },
            {
                "id": 1568834,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5 Easy C++ Solution\\uD83D\\uDE2C || FAANG INTERVIEW CODE\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3031239/easy-c-solution-faang-interview-code/?orderBy=most_votes"
                    },
                    {
                        "username": "mochiball",
                        "content": "Trash. Stop this spam "
                    },
                    {
                        "username": "prakhar432",
                        "content": "Hey, please upload your solution under the solutions tab once. You do not need to spam the same answer in all discussion tabs. This is not a youtube comment section. Thanks"
                    },
                    {
                        "username": "Under_developed",
                        "content": "Dont do they unlock the editorial for the daily challenges ?\\nIn the previous month i saw there was editorial for each daily question."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Step1: if given digits size is 0. return NULL.\\nStep2: store the phone numbers character in vector of string.\\nStep3: call the recursion and pass index =0 which will go upto n (size of digits string Given).\\nStep4: check if ind equals to n . store the temp in answer.\\nStep5: get the find number from digits string, by digits[ind]-\\'0\\'.\\nStep6: run a loop to traverse all the character of that number.\\nStep7: Store the character in temp. of number character.\\nStep8: call the recursion on next index+1.\\nbecause at first place we already store the index of first number.so on second index we have to store character of second number.\\nStep9: remove the last number characte which was inserted.\\n  Step(7 to 9) is backtracking. \\n\\n- Time complexity:\\nT.C=O(n*4^n) In worst case for digit having 4 character.have choice of 4. n digit we have to select. \\n\\n- Space complexity:\\nS.C=O(n). at most the temp can store is upto n.\\n\\n----------------------------\\nPlease hit the Upvote button. If you Understand the concept.\\nSolution Link:\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3637710/c-recursion-backtracking-most-of-the-people-done-wrong-time-and-space-complexity/"
                    },
                    {
                        "username": "kun22",
                        "content": "Where N is the length of the phone number, and K is the number of possible letters for each number.  "
                    },
                    {
                        "username": "yangjufo",
                        "content": "So there is no duplicate condition such as \"22\"?"
                    },
                    {
                        "username": "palindrome88",
                        "content": "What is the space complexity for DFS approach?"
                    },
                    {
                        "username": "navgupta14",
                        "content": "For an input like \"213\" - \\nthe output should be \\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"].\\nIt returns empty vector as the result.\\n\\nNote that 1 has an empty string associated with it."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "@administrators :\\nIs \"12\" a valid test case ? Because, I was considering combinations for 1 which is 1 itself and generating the output. I get the submission as \"Accepted\" even though my answer does not match the \"Expected answer\" . PFA screenshot .\\n\\n![0_1477514483405_Telephone number combination.JPG](/uploads/files/1477514485474-telephone-number-combination.jpg)"
                    },
                    {
                        "username": "ujp17",
                        "content": "When I give test case as \"3\" and click on \"Run Code\" , I am getting correct solution of [\"d\",\"e\",\"f\"] , but when I run \"Submit Solution\" , it breaks at test case input \"3\" with my output as [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]."
                    },
                    {
                        "username": "faye231019",
                        "content": "Case 1\\nEdit\\n\\'23\\'   is not a valid value of type string\\nupdated your editor its not versatile !!"
                    }
                ]
            },
            {
                "id": 2070802,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5 Easy C++ Solution\\uD83D\\uDE2C || FAANG INTERVIEW CODE\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3031239/easy-c-solution-faang-interview-code/?orderBy=most_votes"
                    },
                    {
                        "username": "mochiball",
                        "content": "Trash. Stop this spam "
                    },
                    {
                        "username": "prakhar432",
                        "content": "Hey, please upload your solution under the solutions tab once. You do not need to spam the same answer in all discussion tabs. This is not a youtube comment section. Thanks"
                    },
                    {
                        "username": "Under_developed",
                        "content": "Dont do they unlock the editorial for the daily challenges ?\\nIn the previous month i saw there was editorial for each daily question."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Step1: if given digits size is 0. return NULL.\\nStep2: store the phone numbers character in vector of string.\\nStep3: call the recursion and pass index =0 which will go upto n (size of digits string Given).\\nStep4: check if ind equals to n . store the temp in answer.\\nStep5: get the find number from digits string, by digits[ind]-\\'0\\'.\\nStep6: run a loop to traverse all the character of that number.\\nStep7: Store the character in temp. of number character.\\nStep8: call the recursion on next index+1.\\nbecause at first place we already store the index of first number.so on second index we have to store character of second number.\\nStep9: remove the last number characte which was inserted.\\n  Step(7 to 9) is backtracking. \\n\\n- Time complexity:\\nT.C=O(n*4^n) In worst case for digit having 4 character.have choice of 4. n digit we have to select. \\n\\n- Space complexity:\\nS.C=O(n). at most the temp can store is upto n.\\n\\n----------------------------\\nPlease hit the Upvote button. If you Understand the concept.\\nSolution Link:\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3637710/c-recursion-backtracking-most-of-the-people-done-wrong-time-and-space-complexity/"
                    },
                    {
                        "username": "kun22",
                        "content": "Where N is the length of the phone number, and K is the number of possible letters for each number.  "
                    },
                    {
                        "username": "yangjufo",
                        "content": "So there is no duplicate condition such as \"22\"?"
                    },
                    {
                        "username": "palindrome88",
                        "content": "What is the space complexity for DFS approach?"
                    },
                    {
                        "username": "navgupta14",
                        "content": "For an input like \"213\" - \\nthe output should be \\n[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"].\\nIt returns empty vector as the result.\\n\\nNote that 1 has an empty string associated with it."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "@administrators :\\nIs \"12\" a valid test case ? Because, I was considering combinations for 1 which is 1 itself and generating the output. I get the submission as \"Accepted\" even though my answer does not match the \"Expected answer\" . PFA screenshot .\\n\\n![0_1477514483405_Telephone number combination.JPG](/uploads/files/1477514485474-telephone-number-combination.jpg)"
                    },
                    {
                        "username": "ujp17",
                        "content": "When I give test case as \"3\" and click on \"Run Code\" , I am getting correct solution of [\"d\",\"e\",\"f\"] , but when I run \"Submit Solution\" , it breaks at test case input \"3\" with my output as [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]."
                    },
                    {
                        "username": "faye231019",
                        "content": "Case 1\\nEdit\\n\\'23\\'   is not a valid value of type string\\nupdated your editor its not versatile !!"
                    }
                ]
            },
            {
                "id": 2070797,
                "content": [
                    {
                        "username": "faye231019",
                        "content": "its weird how this editor consieder this \" \" instead of this \\' \\'!!!!!!!!!\\n\\nmy output : [\\'a\\', \\'b\\', \\'c\\']\\n\\nExpected\\n[\"a\",\"b\",\"c\"]   crazy!"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "      public static Map<Character, String> digitToLetters = new HashMap<Character, String>();\\n  static {\\n    digitToLetters.put(\\'2\\', \"abc\");\\n    digitToLetters.put(\\'3\\', \"def\");\\n    digitToLetters.put(\\'4\\', \"ghi\");\\n    digitToLetters.put(\\'5\\', \"jkl\");\\n    digitToLetters.put(\\'6\\', \"mno\");\\n    digitToLetters.put(\\'7\\', \"pqrs\");\\n    digitToLetters.put(\\'8\\', \"tuv\");\\n    digitToLetters.put(\\'9\\', \"wxyz\");\\n  }"
                    },
                    {
                        "username": "penny789",
                        "content": "\\nWe are getting this error :(\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\nhttps://tubidy.press/\\n"
                    },
                    {
                        "username": "antey13",
                        "content": "Java Map for digits - letters  \\n``` java\\n        Map<Character, List<Character>> digit2Letters = new HashMap<>();\\n        digit2Letters.put(\\'2\\', List.of(\\'a\\',\\'b\\',\\'c\\'));\\n        digit2Letters.put(\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'));\\n        digit2Letters.put(\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'));\\n        digit2Letters.put(\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'));\\n        digit2Letters.put(\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'));\\n        digit2Letters.put(\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'));\\n        digit2Letters.put(\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'));\\n        digit2Letters.put(\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\'));\\n```"
                    },
                    {
                        "username": "layyy",
                        "content": "hash the digits and then use a for loop in the recursion function for each digit"
                    },
                    {
                        "username": "user1924Ut",
                        "content": "Is there any constraint like we should take only one letter from the each number."
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i am not able to findout the possible soln exhausted  really !!"
                    },
                    {
                        "username": "sh1n0b1n0m0n0",
                        "content": "letterCombinations(\"234\") \\nWrong:\\n[\\'ad\\', \\'ae\\', \\'af\\', \\'ag\\', \\'ah\\', \\'ai\\', \\'bd\\', \\'be\\', \\'bf\\', \\'bg\\', \\'bh\\', \\'bi\\', \\'cd\\', \\'ce\\', \\'cf\\', \\'cg\\', \\'ch\\', \\'ci\\', \\'dg\\', \\'dh\\', \\'di\\', \\'eg\\', \\'eh\\', \\'ei\\', \\'fg\\', \\'fh\\', \\'fi\\']\\n\\nRight:\\n[\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": " ` class Solution {\\n    String[] arr = {\"00\", \"00\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        // Base case\\n        if (digits.length() == 0) {\\n            ArrayList<String> word = new ArrayList<>();\\n            word.add(\"\");\\n            return word;\\n        }\\n\\n\\n        char ch1 = digits.charAt(0);\\n        String restCh = digits.substring(1);\\n\\n        List<String> allnext = letterCombinations(restCh);\\n        List<String> thatlist = new ArrayList<>();\\n\\n        String str = arr[ch1 - \\'0\\'];\\n        for (int i = 0; i < str.length(); i++) {\\n            char fstL = str.charAt(i);\\n            for (String lastL : allnext) { \\n                thatlist.add(fstL + lastL);\\n            }\\n        }\\n        return thatlist;\\n    }\\n} `\\n\\ncan\\'t pass only one text case {\"\"} .isEmpty test case so, can any one correct this code to run all test case easily ...\\n\\n\\n@"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@subhankar_rout](/subhankar_rout) make another helper function have exactly same code in it. On the first function check the base case if it is empty  return from there otherwise go to helper function and return. "
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "[@sammy-timalsina](/sammy-timalsina)  if I am writing simple return then the answer is simple like this [] because this is a base case so all test case output will be [] .empty() .so ?\\n"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "If digit length is 0 don\\u2019t add word.Add(\\u201C\\u201D) just return List<string > without adding anything into it."
                    },
                    {
                        "username": "weinavera917",
                        "content": "The statement never mentioned that the input digits are treated as ascending order even if in descending order"
                    }
                ]
            },
            {
                "id": 2064185,
                "content": [
                    {
                        "username": "faye231019",
                        "content": "its weird how this editor consieder this \" \" instead of this \\' \\'!!!!!!!!!\\n\\nmy output : [\\'a\\', \\'b\\', \\'c\\']\\n\\nExpected\\n[\"a\",\"b\",\"c\"]   crazy!"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "      public static Map<Character, String> digitToLetters = new HashMap<Character, String>();\\n  static {\\n    digitToLetters.put(\\'2\\', \"abc\");\\n    digitToLetters.put(\\'3\\', \"def\");\\n    digitToLetters.put(\\'4\\', \"ghi\");\\n    digitToLetters.put(\\'5\\', \"jkl\");\\n    digitToLetters.put(\\'6\\', \"mno\");\\n    digitToLetters.put(\\'7\\', \"pqrs\");\\n    digitToLetters.put(\\'8\\', \"tuv\");\\n    digitToLetters.put(\\'9\\', \"wxyz\");\\n  }"
                    },
                    {
                        "username": "penny789",
                        "content": "\\nWe are getting this error :(\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\nhttps://tubidy.press/\\n"
                    },
                    {
                        "username": "antey13",
                        "content": "Java Map for digits - letters  \\n``` java\\n        Map<Character, List<Character>> digit2Letters = new HashMap<>();\\n        digit2Letters.put(\\'2\\', List.of(\\'a\\',\\'b\\',\\'c\\'));\\n        digit2Letters.put(\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'));\\n        digit2Letters.put(\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'));\\n        digit2Letters.put(\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'));\\n        digit2Letters.put(\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'));\\n        digit2Letters.put(\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'));\\n        digit2Letters.put(\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'));\\n        digit2Letters.put(\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\'));\\n```"
                    },
                    {
                        "username": "layyy",
                        "content": "hash the digits and then use a for loop in the recursion function for each digit"
                    },
                    {
                        "username": "user1924Ut",
                        "content": "Is there any constraint like we should take only one letter from the each number."
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i am not able to findout the possible soln exhausted  really !!"
                    },
                    {
                        "username": "sh1n0b1n0m0n0",
                        "content": "letterCombinations(\"234\") \\nWrong:\\n[\\'ad\\', \\'ae\\', \\'af\\', \\'ag\\', \\'ah\\', \\'ai\\', \\'bd\\', \\'be\\', \\'bf\\', \\'bg\\', \\'bh\\', \\'bi\\', \\'cd\\', \\'ce\\', \\'cf\\', \\'cg\\', \\'ch\\', \\'ci\\', \\'dg\\', \\'dh\\', \\'di\\', \\'eg\\', \\'eh\\', \\'ei\\', \\'fg\\', \\'fh\\', \\'fi\\']\\n\\nRight:\\n[\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": " ` class Solution {\\n    String[] arr = {\"00\", \"00\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        // Base case\\n        if (digits.length() == 0) {\\n            ArrayList<String> word = new ArrayList<>();\\n            word.add(\"\");\\n            return word;\\n        }\\n\\n\\n        char ch1 = digits.charAt(0);\\n        String restCh = digits.substring(1);\\n\\n        List<String> allnext = letterCombinations(restCh);\\n        List<String> thatlist = new ArrayList<>();\\n\\n        String str = arr[ch1 - \\'0\\'];\\n        for (int i = 0; i < str.length(); i++) {\\n            char fstL = str.charAt(i);\\n            for (String lastL : allnext) { \\n                thatlist.add(fstL + lastL);\\n            }\\n        }\\n        return thatlist;\\n    }\\n} `\\n\\ncan\\'t pass only one text case {\"\"} .isEmpty test case so, can any one correct this code to run all test case easily ...\\n\\n\\n@"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@subhankar_rout](/subhankar_rout) make another helper function have exactly same code in it. On the first function check the base case if it is empty  return from there otherwise go to helper function and return. "
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "[@sammy-timalsina](/sammy-timalsina)  if I am writing simple return then the answer is simple like this [] because this is a base case so all test case output will be [] .empty() .so ?\\n"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "If digit length is 0 don\\u2019t add word.Add(\\u201C\\u201D) just return List<string > without adding anything into it."
                    },
                    {
                        "username": "weinavera917",
                        "content": "The statement never mentioned that the input digits are treated as ascending order even if in descending order"
                    }
                ]
            },
            {
                "id": 2043590,
                "content": [
                    {
                        "username": "faye231019",
                        "content": "its weird how this editor consieder this \" \" instead of this \\' \\'!!!!!!!!!\\n\\nmy output : [\\'a\\', \\'b\\', \\'c\\']\\n\\nExpected\\n[\"a\",\"b\",\"c\"]   crazy!"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "      public static Map<Character, String> digitToLetters = new HashMap<Character, String>();\\n  static {\\n    digitToLetters.put(\\'2\\', \"abc\");\\n    digitToLetters.put(\\'3\\', \"def\");\\n    digitToLetters.put(\\'4\\', \"ghi\");\\n    digitToLetters.put(\\'5\\', \"jkl\");\\n    digitToLetters.put(\\'6\\', \"mno\");\\n    digitToLetters.put(\\'7\\', \"pqrs\");\\n    digitToLetters.put(\\'8\\', \"tuv\");\\n    digitToLetters.put(\\'9\\', \"wxyz\");\\n  }"
                    },
                    {
                        "username": "penny789",
                        "content": "\\nWe are getting this error :(\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\nhttps://tubidy.press/\\n"
                    },
                    {
                        "username": "antey13",
                        "content": "Java Map for digits - letters  \\n``` java\\n        Map<Character, List<Character>> digit2Letters = new HashMap<>();\\n        digit2Letters.put(\\'2\\', List.of(\\'a\\',\\'b\\',\\'c\\'));\\n        digit2Letters.put(\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'));\\n        digit2Letters.put(\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'));\\n        digit2Letters.put(\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'));\\n        digit2Letters.put(\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'));\\n        digit2Letters.put(\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'));\\n        digit2Letters.put(\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'));\\n        digit2Letters.put(\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\'));\\n```"
                    },
                    {
                        "username": "layyy",
                        "content": "hash the digits and then use a for loop in the recursion function for each digit"
                    },
                    {
                        "username": "user1924Ut",
                        "content": "Is there any constraint like we should take only one letter from the each number."
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i am not able to findout the possible soln exhausted  really !!"
                    },
                    {
                        "username": "sh1n0b1n0m0n0",
                        "content": "letterCombinations(\"234\") \\nWrong:\\n[\\'ad\\', \\'ae\\', \\'af\\', \\'ag\\', \\'ah\\', \\'ai\\', \\'bd\\', \\'be\\', \\'bf\\', \\'bg\\', \\'bh\\', \\'bi\\', \\'cd\\', \\'ce\\', \\'cf\\', \\'cg\\', \\'ch\\', \\'ci\\', \\'dg\\', \\'dh\\', \\'di\\', \\'eg\\', \\'eh\\', \\'ei\\', \\'fg\\', \\'fh\\', \\'fi\\']\\n\\nRight:\\n[\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": " ` class Solution {\\n    String[] arr = {\"00\", \"00\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        // Base case\\n        if (digits.length() == 0) {\\n            ArrayList<String> word = new ArrayList<>();\\n            word.add(\"\");\\n            return word;\\n        }\\n\\n\\n        char ch1 = digits.charAt(0);\\n        String restCh = digits.substring(1);\\n\\n        List<String> allnext = letterCombinations(restCh);\\n        List<String> thatlist = new ArrayList<>();\\n\\n        String str = arr[ch1 - \\'0\\'];\\n        for (int i = 0; i < str.length(); i++) {\\n            char fstL = str.charAt(i);\\n            for (String lastL : allnext) { \\n                thatlist.add(fstL + lastL);\\n            }\\n        }\\n        return thatlist;\\n    }\\n} `\\n\\ncan\\'t pass only one text case {\"\"} .isEmpty test case so, can any one correct this code to run all test case easily ...\\n\\n\\n@"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@subhankar_rout](/subhankar_rout) make another helper function have exactly same code in it. On the first function check the base case if it is empty  return from there otherwise go to helper function and return. "
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "[@sammy-timalsina](/sammy-timalsina)  if I am writing simple return then the answer is simple like this [] because this is a base case so all test case output will be [] .empty() .so ?\\n"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "If digit length is 0 don\\u2019t add word.Add(\\u201C\\u201D) just return List<string > without adding anything into it."
                    },
                    {
                        "username": "weinavera917",
                        "content": "The statement never mentioned that the input digits are treated as ascending order even if in descending order"
                    }
                ]
            },
            {
                "id": 2036145,
                "content": [
                    {
                        "username": "faye231019",
                        "content": "its weird how this editor consieder this \" \" instead of this \\' \\'!!!!!!!!!\\n\\nmy output : [\\'a\\', \\'b\\', \\'c\\']\\n\\nExpected\\n[\"a\",\"b\",\"c\"]   crazy!"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "      public static Map<Character, String> digitToLetters = new HashMap<Character, String>();\\n  static {\\n    digitToLetters.put(\\'2\\', \"abc\");\\n    digitToLetters.put(\\'3\\', \"def\");\\n    digitToLetters.put(\\'4\\', \"ghi\");\\n    digitToLetters.put(\\'5\\', \"jkl\");\\n    digitToLetters.put(\\'6\\', \"mno\");\\n    digitToLetters.put(\\'7\\', \"pqrs\");\\n    digitToLetters.put(\\'8\\', \"tuv\");\\n    digitToLetters.put(\\'9\\', \"wxyz\");\\n  }"
                    },
                    {
                        "username": "penny789",
                        "content": "\\nWe are getting this error :(\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\nhttps://tubidy.press/\\n"
                    },
                    {
                        "username": "antey13",
                        "content": "Java Map for digits - letters  \\n``` java\\n        Map<Character, List<Character>> digit2Letters = new HashMap<>();\\n        digit2Letters.put(\\'2\\', List.of(\\'a\\',\\'b\\',\\'c\\'));\\n        digit2Letters.put(\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'));\\n        digit2Letters.put(\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'));\\n        digit2Letters.put(\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'));\\n        digit2Letters.put(\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'));\\n        digit2Letters.put(\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'));\\n        digit2Letters.put(\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'));\\n        digit2Letters.put(\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\'));\\n```"
                    },
                    {
                        "username": "layyy",
                        "content": "hash the digits and then use a for loop in the recursion function for each digit"
                    },
                    {
                        "username": "user1924Ut",
                        "content": "Is there any constraint like we should take only one letter from the each number."
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i am not able to findout the possible soln exhausted  really !!"
                    },
                    {
                        "username": "sh1n0b1n0m0n0",
                        "content": "letterCombinations(\"234\") \\nWrong:\\n[\\'ad\\', \\'ae\\', \\'af\\', \\'ag\\', \\'ah\\', \\'ai\\', \\'bd\\', \\'be\\', \\'bf\\', \\'bg\\', \\'bh\\', \\'bi\\', \\'cd\\', \\'ce\\', \\'cf\\', \\'cg\\', \\'ch\\', \\'ci\\', \\'dg\\', \\'dh\\', \\'di\\', \\'eg\\', \\'eh\\', \\'ei\\', \\'fg\\', \\'fh\\', \\'fi\\']\\n\\nRight:\\n[\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": " ` class Solution {\\n    String[] arr = {\"00\", \"00\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        // Base case\\n        if (digits.length() == 0) {\\n            ArrayList<String> word = new ArrayList<>();\\n            word.add(\"\");\\n            return word;\\n        }\\n\\n\\n        char ch1 = digits.charAt(0);\\n        String restCh = digits.substring(1);\\n\\n        List<String> allnext = letterCombinations(restCh);\\n        List<String> thatlist = new ArrayList<>();\\n\\n        String str = arr[ch1 - \\'0\\'];\\n        for (int i = 0; i < str.length(); i++) {\\n            char fstL = str.charAt(i);\\n            for (String lastL : allnext) { \\n                thatlist.add(fstL + lastL);\\n            }\\n        }\\n        return thatlist;\\n    }\\n} `\\n\\ncan\\'t pass only one text case {\"\"} .isEmpty test case so, can any one correct this code to run all test case easily ...\\n\\n\\n@"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@subhankar_rout](/subhankar_rout) make another helper function have exactly same code in it. On the first function check the base case if it is empty  return from there otherwise go to helper function and return. "
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "[@sammy-timalsina](/sammy-timalsina)  if I am writing simple return then the answer is simple like this [] because this is a base case so all test case output will be [] .empty() .so ?\\n"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "If digit length is 0 don\\u2019t add word.Add(\\u201C\\u201D) just return List<string > without adding anything into it."
                    },
                    {
                        "username": "weinavera917",
                        "content": "The statement never mentioned that the input digits are treated as ascending order even if in descending order"
                    }
                ]
            },
            {
                "id": 2026026,
                "content": [
                    {
                        "username": "faye231019",
                        "content": "its weird how this editor consieder this \" \" instead of this \\' \\'!!!!!!!!!\\n\\nmy output : [\\'a\\', \\'b\\', \\'c\\']\\n\\nExpected\\n[\"a\",\"b\",\"c\"]   crazy!"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "      public static Map<Character, String> digitToLetters = new HashMap<Character, String>();\\n  static {\\n    digitToLetters.put(\\'2\\', \"abc\");\\n    digitToLetters.put(\\'3\\', \"def\");\\n    digitToLetters.put(\\'4\\', \"ghi\");\\n    digitToLetters.put(\\'5\\', \"jkl\");\\n    digitToLetters.put(\\'6\\', \"mno\");\\n    digitToLetters.put(\\'7\\', \"pqrs\");\\n    digitToLetters.put(\\'8\\', \"tuv\");\\n    digitToLetters.put(\\'9\\', \"wxyz\");\\n  }"
                    },
                    {
                        "username": "penny789",
                        "content": "\\nWe are getting this error :(\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\nhttps://tubidy.press/\\n"
                    },
                    {
                        "username": "antey13",
                        "content": "Java Map for digits - letters  \\n``` java\\n        Map<Character, List<Character>> digit2Letters = new HashMap<>();\\n        digit2Letters.put(\\'2\\', List.of(\\'a\\',\\'b\\',\\'c\\'));\\n        digit2Letters.put(\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'));\\n        digit2Letters.put(\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'));\\n        digit2Letters.put(\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'));\\n        digit2Letters.put(\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'));\\n        digit2Letters.put(\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'));\\n        digit2Letters.put(\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'));\\n        digit2Letters.put(\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\'));\\n```"
                    },
                    {
                        "username": "layyy",
                        "content": "hash the digits and then use a for loop in the recursion function for each digit"
                    },
                    {
                        "username": "user1924Ut",
                        "content": "Is there any constraint like we should take only one letter from the each number."
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i am not able to findout the possible soln exhausted  really !!"
                    },
                    {
                        "username": "sh1n0b1n0m0n0",
                        "content": "letterCombinations(\"234\") \\nWrong:\\n[\\'ad\\', \\'ae\\', \\'af\\', \\'ag\\', \\'ah\\', \\'ai\\', \\'bd\\', \\'be\\', \\'bf\\', \\'bg\\', \\'bh\\', \\'bi\\', \\'cd\\', \\'ce\\', \\'cf\\', \\'cg\\', \\'ch\\', \\'ci\\', \\'dg\\', \\'dh\\', \\'di\\', \\'eg\\', \\'eh\\', \\'ei\\', \\'fg\\', \\'fh\\', \\'fi\\']\\n\\nRight:\\n[\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": " ` class Solution {\\n    String[] arr = {\"00\", \"00\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        // Base case\\n        if (digits.length() == 0) {\\n            ArrayList<String> word = new ArrayList<>();\\n            word.add(\"\");\\n            return word;\\n        }\\n\\n\\n        char ch1 = digits.charAt(0);\\n        String restCh = digits.substring(1);\\n\\n        List<String> allnext = letterCombinations(restCh);\\n        List<String> thatlist = new ArrayList<>();\\n\\n        String str = arr[ch1 - \\'0\\'];\\n        for (int i = 0; i < str.length(); i++) {\\n            char fstL = str.charAt(i);\\n            for (String lastL : allnext) { \\n                thatlist.add(fstL + lastL);\\n            }\\n        }\\n        return thatlist;\\n    }\\n} `\\n\\ncan\\'t pass only one text case {\"\"} .isEmpty test case so, can any one correct this code to run all test case easily ...\\n\\n\\n@"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@subhankar_rout](/subhankar_rout) make another helper function have exactly same code in it. On the first function check the base case if it is empty  return from there otherwise go to helper function and return. "
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "[@sammy-timalsina](/sammy-timalsina)  if I am writing simple return then the answer is simple like this [] because this is a base case so all test case output will be [] .empty() .so ?\\n"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "If digit length is 0 don\\u2019t add word.Add(\\u201C\\u201D) just return List<string > without adding anything into it."
                    },
                    {
                        "username": "weinavera917",
                        "content": "The statement never mentioned that the input digits are treated as ascending order even if in descending order"
                    }
                ]
            },
            {
                "id": 2015594,
                "content": [
                    {
                        "username": "faye231019",
                        "content": "its weird how this editor consieder this \" \" instead of this \\' \\'!!!!!!!!!\\n\\nmy output : [\\'a\\', \\'b\\', \\'c\\']\\n\\nExpected\\n[\"a\",\"b\",\"c\"]   crazy!"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "      public static Map<Character, String> digitToLetters = new HashMap<Character, String>();\\n  static {\\n    digitToLetters.put(\\'2\\', \"abc\");\\n    digitToLetters.put(\\'3\\', \"def\");\\n    digitToLetters.put(\\'4\\', \"ghi\");\\n    digitToLetters.put(\\'5\\', \"jkl\");\\n    digitToLetters.put(\\'6\\', \"mno\");\\n    digitToLetters.put(\\'7\\', \"pqrs\");\\n    digitToLetters.put(\\'8\\', \"tuv\");\\n    digitToLetters.put(\\'9\\', \"wxyz\");\\n  }"
                    },
                    {
                        "username": "penny789",
                        "content": "\\nWe are getting this error :(\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\nhttps://tubidy.press/\\n"
                    },
                    {
                        "username": "antey13",
                        "content": "Java Map for digits - letters  \\n``` java\\n        Map<Character, List<Character>> digit2Letters = new HashMap<>();\\n        digit2Letters.put(\\'2\\', List.of(\\'a\\',\\'b\\',\\'c\\'));\\n        digit2Letters.put(\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'));\\n        digit2Letters.put(\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'));\\n        digit2Letters.put(\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'));\\n        digit2Letters.put(\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'));\\n        digit2Letters.put(\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'));\\n        digit2Letters.put(\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'));\\n        digit2Letters.put(\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\'));\\n```"
                    },
                    {
                        "username": "layyy",
                        "content": "hash the digits and then use a for loop in the recursion function for each digit"
                    },
                    {
                        "username": "user1924Ut",
                        "content": "Is there any constraint like we should take only one letter from the each number."
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i am not able to findout the possible soln exhausted  really !!"
                    },
                    {
                        "username": "sh1n0b1n0m0n0",
                        "content": "letterCombinations(\"234\") \\nWrong:\\n[\\'ad\\', \\'ae\\', \\'af\\', \\'ag\\', \\'ah\\', \\'ai\\', \\'bd\\', \\'be\\', \\'bf\\', \\'bg\\', \\'bh\\', \\'bi\\', \\'cd\\', \\'ce\\', \\'cf\\', \\'cg\\', \\'ch\\', \\'ci\\', \\'dg\\', \\'dh\\', \\'di\\', \\'eg\\', \\'eh\\', \\'ei\\', \\'fg\\', \\'fh\\', \\'fi\\']\\n\\nRight:\\n[\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": " ` class Solution {\\n    String[] arr = {\"00\", \"00\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        // Base case\\n        if (digits.length() == 0) {\\n            ArrayList<String> word = new ArrayList<>();\\n            word.add(\"\");\\n            return word;\\n        }\\n\\n\\n        char ch1 = digits.charAt(0);\\n        String restCh = digits.substring(1);\\n\\n        List<String> allnext = letterCombinations(restCh);\\n        List<String> thatlist = new ArrayList<>();\\n\\n        String str = arr[ch1 - \\'0\\'];\\n        for (int i = 0; i < str.length(); i++) {\\n            char fstL = str.charAt(i);\\n            for (String lastL : allnext) { \\n                thatlist.add(fstL + lastL);\\n            }\\n        }\\n        return thatlist;\\n    }\\n} `\\n\\ncan\\'t pass only one text case {\"\"} .isEmpty test case so, can any one correct this code to run all test case easily ...\\n\\n\\n@"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@subhankar_rout](/subhankar_rout) make another helper function have exactly same code in it. On the first function check the base case if it is empty  return from there otherwise go to helper function and return. "
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "[@sammy-timalsina](/sammy-timalsina)  if I am writing simple return then the answer is simple like this [] because this is a base case so all test case output will be [] .empty() .so ?\\n"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "If digit length is 0 don\\u2019t add word.Add(\\u201C\\u201D) just return List<string > without adding anything into it."
                    },
                    {
                        "username": "weinavera917",
                        "content": "The statement never mentioned that the input digits are treated as ascending order even if in descending order"
                    }
                ]
            },
            {
                "id": 2009089,
                "content": [
                    {
                        "username": "faye231019",
                        "content": "its weird how this editor consieder this \" \" instead of this \\' \\'!!!!!!!!!\\n\\nmy output : [\\'a\\', \\'b\\', \\'c\\']\\n\\nExpected\\n[\"a\",\"b\",\"c\"]   crazy!"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "      public static Map<Character, String> digitToLetters = new HashMap<Character, String>();\\n  static {\\n    digitToLetters.put(\\'2\\', \"abc\");\\n    digitToLetters.put(\\'3\\', \"def\");\\n    digitToLetters.put(\\'4\\', \"ghi\");\\n    digitToLetters.put(\\'5\\', \"jkl\");\\n    digitToLetters.put(\\'6\\', \"mno\");\\n    digitToLetters.put(\\'7\\', \"pqrs\");\\n    digitToLetters.put(\\'8\\', \"tuv\");\\n    digitToLetters.put(\\'9\\', \"wxyz\");\\n  }"
                    },
                    {
                        "username": "penny789",
                        "content": "\\nWe are getting this error :(\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\nhttps://tubidy.press/\\n"
                    },
                    {
                        "username": "antey13",
                        "content": "Java Map for digits - letters  \\n``` java\\n        Map<Character, List<Character>> digit2Letters = new HashMap<>();\\n        digit2Letters.put(\\'2\\', List.of(\\'a\\',\\'b\\',\\'c\\'));\\n        digit2Letters.put(\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'));\\n        digit2Letters.put(\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'));\\n        digit2Letters.put(\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'));\\n        digit2Letters.put(\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'));\\n        digit2Letters.put(\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'));\\n        digit2Letters.put(\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'));\\n        digit2Letters.put(\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\'));\\n```"
                    },
                    {
                        "username": "layyy",
                        "content": "hash the digits and then use a for loop in the recursion function for each digit"
                    },
                    {
                        "username": "user1924Ut",
                        "content": "Is there any constraint like we should take only one letter from the each number."
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i am not able to findout the possible soln exhausted  really !!"
                    },
                    {
                        "username": "sh1n0b1n0m0n0",
                        "content": "letterCombinations(\"234\") \\nWrong:\\n[\\'ad\\', \\'ae\\', \\'af\\', \\'ag\\', \\'ah\\', \\'ai\\', \\'bd\\', \\'be\\', \\'bf\\', \\'bg\\', \\'bh\\', \\'bi\\', \\'cd\\', \\'ce\\', \\'cf\\', \\'cg\\', \\'ch\\', \\'ci\\', \\'dg\\', \\'dh\\', \\'di\\', \\'eg\\', \\'eh\\', \\'ei\\', \\'fg\\', \\'fh\\', \\'fi\\']\\n\\nRight:\\n[\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": " ` class Solution {\\n    String[] arr = {\"00\", \"00\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        // Base case\\n        if (digits.length() == 0) {\\n            ArrayList<String> word = new ArrayList<>();\\n            word.add(\"\");\\n            return word;\\n        }\\n\\n\\n        char ch1 = digits.charAt(0);\\n        String restCh = digits.substring(1);\\n\\n        List<String> allnext = letterCombinations(restCh);\\n        List<String> thatlist = new ArrayList<>();\\n\\n        String str = arr[ch1 - \\'0\\'];\\n        for (int i = 0; i < str.length(); i++) {\\n            char fstL = str.charAt(i);\\n            for (String lastL : allnext) { \\n                thatlist.add(fstL + lastL);\\n            }\\n        }\\n        return thatlist;\\n    }\\n} `\\n\\ncan\\'t pass only one text case {\"\"} .isEmpty test case so, can any one correct this code to run all test case easily ...\\n\\n\\n@"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@subhankar_rout](/subhankar_rout) make another helper function have exactly same code in it. On the first function check the base case if it is empty  return from there otherwise go to helper function and return. "
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "[@sammy-timalsina](/sammy-timalsina)  if I am writing simple return then the answer is simple like this [] because this is a base case so all test case output will be [] .empty() .so ?\\n"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "If digit length is 0 don\\u2019t add word.Add(\\u201C\\u201D) just return List<string > without adding anything into it."
                    },
                    {
                        "username": "weinavera917",
                        "content": "The statement never mentioned that the input digits are treated as ascending order even if in descending order"
                    }
                ]
            },
            {
                "id": 2000953,
                "content": [
                    {
                        "username": "faye231019",
                        "content": "its weird how this editor consieder this \" \" instead of this \\' \\'!!!!!!!!!\\n\\nmy output : [\\'a\\', \\'b\\', \\'c\\']\\n\\nExpected\\n[\"a\",\"b\",\"c\"]   crazy!"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "      public static Map<Character, String> digitToLetters = new HashMap<Character, String>();\\n  static {\\n    digitToLetters.put(\\'2\\', \"abc\");\\n    digitToLetters.put(\\'3\\', \"def\");\\n    digitToLetters.put(\\'4\\', \"ghi\");\\n    digitToLetters.put(\\'5\\', \"jkl\");\\n    digitToLetters.put(\\'6\\', \"mno\");\\n    digitToLetters.put(\\'7\\', \"pqrs\");\\n    digitToLetters.put(\\'8\\', \"tuv\");\\n    digitToLetters.put(\\'9\\', \"wxyz\");\\n  }"
                    },
                    {
                        "username": "penny789",
                        "content": "\\nWe are getting this error :(\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\nhttps://tubidy.press/\\n"
                    },
                    {
                        "username": "antey13",
                        "content": "Java Map for digits - letters  \\n``` java\\n        Map<Character, List<Character>> digit2Letters = new HashMap<>();\\n        digit2Letters.put(\\'2\\', List.of(\\'a\\',\\'b\\',\\'c\\'));\\n        digit2Letters.put(\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'));\\n        digit2Letters.put(\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'));\\n        digit2Letters.put(\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'));\\n        digit2Letters.put(\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'));\\n        digit2Letters.put(\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'));\\n        digit2Letters.put(\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'));\\n        digit2Letters.put(\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\'));\\n```"
                    },
                    {
                        "username": "layyy",
                        "content": "hash the digits and then use a for loop in the recursion function for each digit"
                    },
                    {
                        "username": "user1924Ut",
                        "content": "Is there any constraint like we should take only one letter from the each number."
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i am not able to findout the possible soln exhausted  really !!"
                    },
                    {
                        "username": "sh1n0b1n0m0n0",
                        "content": "letterCombinations(\"234\") \\nWrong:\\n[\\'ad\\', \\'ae\\', \\'af\\', \\'ag\\', \\'ah\\', \\'ai\\', \\'bd\\', \\'be\\', \\'bf\\', \\'bg\\', \\'bh\\', \\'bi\\', \\'cd\\', \\'ce\\', \\'cf\\', \\'cg\\', \\'ch\\', \\'ci\\', \\'dg\\', \\'dh\\', \\'di\\', \\'eg\\', \\'eh\\', \\'ei\\', \\'fg\\', \\'fh\\', \\'fi\\']\\n\\nRight:\\n[\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": " ` class Solution {\\n    String[] arr = {\"00\", \"00\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        // Base case\\n        if (digits.length() == 0) {\\n            ArrayList<String> word = new ArrayList<>();\\n            word.add(\"\");\\n            return word;\\n        }\\n\\n\\n        char ch1 = digits.charAt(0);\\n        String restCh = digits.substring(1);\\n\\n        List<String> allnext = letterCombinations(restCh);\\n        List<String> thatlist = new ArrayList<>();\\n\\n        String str = arr[ch1 - \\'0\\'];\\n        for (int i = 0; i < str.length(); i++) {\\n            char fstL = str.charAt(i);\\n            for (String lastL : allnext) { \\n                thatlist.add(fstL + lastL);\\n            }\\n        }\\n        return thatlist;\\n    }\\n} `\\n\\ncan\\'t pass only one text case {\"\"} .isEmpty test case so, can any one correct this code to run all test case easily ...\\n\\n\\n@"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@subhankar_rout](/subhankar_rout) make another helper function have exactly same code in it. On the first function check the base case if it is empty  return from there otherwise go to helper function and return. "
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "[@sammy-timalsina](/sammy-timalsina)  if I am writing simple return then the answer is simple like this [] because this is a base case so all test case output will be [] .empty() .so ?\\n"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "If digit length is 0 don\\u2019t add word.Add(\\u201C\\u201D) just return List<string > without adding anything into it."
                    },
                    {
                        "username": "weinavera917",
                        "content": "The statement never mentioned that the input digits are treated as ascending order even if in descending order"
                    }
                ]
            },
            {
                "id": 1999744,
                "content": [
                    {
                        "username": "faye231019",
                        "content": "its weird how this editor consieder this \" \" instead of this \\' \\'!!!!!!!!!\\n\\nmy output : [\\'a\\', \\'b\\', \\'c\\']\\n\\nExpected\\n[\"a\",\"b\",\"c\"]   crazy!"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "      public static Map<Character, String> digitToLetters = new HashMap<Character, String>();\\n  static {\\n    digitToLetters.put(\\'2\\', \"abc\");\\n    digitToLetters.put(\\'3\\', \"def\");\\n    digitToLetters.put(\\'4\\', \"ghi\");\\n    digitToLetters.put(\\'5\\', \"jkl\");\\n    digitToLetters.put(\\'6\\', \"mno\");\\n    digitToLetters.put(\\'7\\', \"pqrs\");\\n    digitToLetters.put(\\'8\\', \"tuv\");\\n    digitToLetters.put(\\'9\\', \"wxyz\");\\n  }"
                    },
                    {
                        "username": "penny789",
                        "content": "\\nWe are getting this error :(\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\nhttps://tubidy.press/\\n"
                    },
                    {
                        "username": "antey13",
                        "content": "Java Map for digits - letters  \\n``` java\\n        Map<Character, List<Character>> digit2Letters = new HashMap<>();\\n        digit2Letters.put(\\'2\\', List.of(\\'a\\',\\'b\\',\\'c\\'));\\n        digit2Letters.put(\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'));\\n        digit2Letters.put(\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'));\\n        digit2Letters.put(\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'));\\n        digit2Letters.put(\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'));\\n        digit2Letters.put(\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'));\\n        digit2Letters.put(\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'));\\n        digit2Letters.put(\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\'));\\n```"
                    },
                    {
                        "username": "layyy",
                        "content": "hash the digits and then use a for loop in the recursion function for each digit"
                    },
                    {
                        "username": "user1924Ut",
                        "content": "Is there any constraint like we should take only one letter from the each number."
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i am not able to findout the possible soln exhausted  really !!"
                    },
                    {
                        "username": "sh1n0b1n0m0n0",
                        "content": "letterCombinations(\"234\") \\nWrong:\\n[\\'ad\\', \\'ae\\', \\'af\\', \\'ag\\', \\'ah\\', \\'ai\\', \\'bd\\', \\'be\\', \\'bf\\', \\'bg\\', \\'bh\\', \\'bi\\', \\'cd\\', \\'ce\\', \\'cf\\', \\'cg\\', \\'ch\\', \\'ci\\', \\'dg\\', \\'dh\\', \\'di\\', \\'eg\\', \\'eh\\', \\'ei\\', \\'fg\\', \\'fh\\', \\'fi\\']\\n\\nRight:\\n[\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": " ` class Solution {\\n    String[] arr = {\"00\", \"00\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        // Base case\\n        if (digits.length() == 0) {\\n            ArrayList<String> word = new ArrayList<>();\\n            word.add(\"\");\\n            return word;\\n        }\\n\\n\\n        char ch1 = digits.charAt(0);\\n        String restCh = digits.substring(1);\\n\\n        List<String> allnext = letterCombinations(restCh);\\n        List<String> thatlist = new ArrayList<>();\\n\\n        String str = arr[ch1 - \\'0\\'];\\n        for (int i = 0; i < str.length(); i++) {\\n            char fstL = str.charAt(i);\\n            for (String lastL : allnext) { \\n                thatlist.add(fstL + lastL);\\n            }\\n        }\\n        return thatlist;\\n    }\\n} `\\n\\ncan\\'t pass only one text case {\"\"} .isEmpty test case so, can any one correct this code to run all test case easily ...\\n\\n\\n@"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@subhankar_rout](/subhankar_rout) make another helper function have exactly same code in it. On the first function check the base case if it is empty  return from there otherwise go to helper function and return. "
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "[@sammy-timalsina](/sammy-timalsina)  if I am writing simple return then the answer is simple like this [] because this is a base case so all test case output will be [] .empty() .so ?\\n"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "If digit length is 0 don\\u2019t add word.Add(\\u201C\\u201D) just return List<string > without adding anything into it."
                    },
                    {
                        "username": "weinavera917",
                        "content": "The statement never mentioned that the input digits are treated as ascending order even if in descending order"
                    }
                ]
            },
            {
                "id": 1999204,
                "content": [
                    {
                        "username": "faye231019",
                        "content": "its weird how this editor consieder this \" \" instead of this \\' \\'!!!!!!!!!\\n\\nmy output : [\\'a\\', \\'b\\', \\'c\\']\\n\\nExpected\\n[\"a\",\"b\",\"c\"]   crazy!"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "      public static Map<Character, String> digitToLetters = new HashMap<Character, String>();\\n  static {\\n    digitToLetters.put(\\'2\\', \"abc\");\\n    digitToLetters.put(\\'3\\', \"def\");\\n    digitToLetters.put(\\'4\\', \"ghi\");\\n    digitToLetters.put(\\'5\\', \"jkl\");\\n    digitToLetters.put(\\'6\\', \"mno\");\\n    digitToLetters.put(\\'7\\', \"pqrs\");\\n    digitToLetters.put(\\'8\\', \"tuv\");\\n    digitToLetters.put(\\'9\\', \"wxyz\");\\n  }"
                    },
                    {
                        "username": "penny789",
                        "content": "\\nWe are getting this error :(\\nLine 5: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\nhttps://tubidy.press/\\n"
                    },
                    {
                        "username": "antey13",
                        "content": "Java Map for digits - letters  \\n``` java\\n        Map<Character, List<Character>> digit2Letters = new HashMap<>();\\n        digit2Letters.put(\\'2\\', List.of(\\'a\\',\\'b\\',\\'c\\'));\\n        digit2Letters.put(\\'3\\', List.of(\\'d\\', \\'e\\', \\'f\\'));\\n        digit2Letters.put(\\'4\\', List.of(\\'g\\', \\'h\\', \\'i\\'));\\n        digit2Letters.put(\\'5\\', List.of(\\'j\\', \\'k\\', \\'l\\'));\\n        digit2Letters.put(\\'6\\', List.of(\\'m\\', \\'n\\', \\'o\\'));\\n        digit2Letters.put(\\'7\\', List.of(\\'p\\', \\'q\\', \\'r\\', \\'s\\'));\\n        digit2Letters.put(\\'8\\', List.of(\\'t\\', \\'u\\', \\'v\\'));\\n        digit2Letters.put(\\'9\\', List.of(\\'w\\', \\'x\\', \\'y\\', \\'z\\'));\\n```"
                    },
                    {
                        "username": "layyy",
                        "content": "hash the digits and then use a for loop in the recursion function for each digit"
                    },
                    {
                        "username": "user1924Ut",
                        "content": "Is there any constraint like we should take only one letter from the each number."
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i am not able to findout the possible soln exhausted  really !!"
                    },
                    {
                        "username": "sh1n0b1n0m0n0",
                        "content": "letterCombinations(\"234\") \\nWrong:\\n[\\'ad\\', \\'ae\\', \\'af\\', \\'ag\\', \\'ah\\', \\'ai\\', \\'bd\\', \\'be\\', \\'bf\\', \\'bg\\', \\'bh\\', \\'bi\\', \\'cd\\', \\'ce\\', \\'cf\\', \\'cg\\', \\'ch\\', \\'ci\\', \\'dg\\', \\'dh\\', \\'di\\', \\'eg\\', \\'eh\\', \\'ei\\', \\'fg\\', \\'fh\\', \\'fi\\']\\n\\nRight:\\n[\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": " ` class Solution {\\n    String[] arr = {\"00\", \"00\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n    public List<String> letterCombinations(String digits) {\\n        // Base case\\n        if (digits.length() == 0) {\\n            ArrayList<String> word = new ArrayList<>();\\n            word.add(\"\");\\n            return word;\\n        }\\n\\n\\n        char ch1 = digits.charAt(0);\\n        String restCh = digits.substring(1);\\n\\n        List<String> allnext = letterCombinations(restCh);\\n        List<String> thatlist = new ArrayList<>();\\n\\n        String str = arr[ch1 - \\'0\\'];\\n        for (int i = 0; i < str.length(); i++) {\\n            char fstL = str.charAt(i);\\n            for (String lastL : allnext) { \\n                thatlist.add(fstL + lastL);\\n            }\\n        }\\n        return thatlist;\\n    }\\n} `\\n\\ncan\\'t pass only one text case {\"\"} .isEmpty test case so, can any one correct this code to run all test case easily ...\\n\\n\\n@"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@subhankar_rout](/subhankar_rout) make another helper function have exactly same code in it. On the first function check the base case if it is empty  return from there otherwise go to helper function and return. "
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "[@sammy-timalsina](/sammy-timalsina)  if I am writing simple return then the answer is simple like this [] because this is a base case so all test case output will be [] .empty() .so ?\\n"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "If digit length is 0 don\\u2019t add word.Add(\\u201C\\u201D) just return List<string > without adding anything into it."
                    },
                    {
                        "username": "weinavera917",
                        "content": "The statement never mentioned that the input digits are treated as ascending order even if in descending order"
                    }
                ]
            },
            {
                "id": 1999005,
                "content": [
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "I am getting a strange output result: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\",\"\",\"a\",\"b\",\"c\"]\\n expected a b c\\nbut my string list does contain a b c and it does not contain the other values the output shows\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "for gophers:\\n\\n    keyboard := []string{\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}\\n"
                    },
                    {
                        "username": "surelax",
                        "content": "is this kind of question solvable in sql or linear algebra?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "This question is like uncovering a treasure trove of possible combinations! Let\\'s take the number sequence 23 as an example. The number 2 has the letters \\'a\\', \\'b\\', and \\'c\\', while the number 3 has \\'d\\', \\'e\\', and \\'f\\'. Can you guess what combinations we can create from these? That\\'s right! We have ad, ae, af, bd, be, bf,cd,ce,cf. \\uD83C\\uDF89\\n\\n\\uD83C\\uDF1F You pick one letter from the options given by the first number (let\\'s say \\'a\\' from 2), and then you combine it with each letter from the second number (like \\'d\\', \\'e\\', and \\'f\\' from 3). It\\'s like walking down different paths and uncovering hidden words at each turn. \\uD83D\\uDE80\\n\\nWait, can you think of a strategy to make sure we don\\'t miss any possible combinations? \\uD83E\\uDD14 That\\'s where recursion comes into play! Think of it as a magical mirror that reflects the same quest for every letter you pick. You start with one letter, explore all its possible pairings, and then go deeper by repeating the same process with the next letters.\\n\\nAll the best for the back[tracking] ! \\uD83D\\uDDFA\\uFE0F\\uD83D\\uDD0D\\uD83C\\uDF08\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this question is everywhere .\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "LoL! \\uD83D\\uDE00 I have Android Phone ."
                    },
                    {
                        "username": "gd4niele",
                        "content": "I think this problem should be marked as easy"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "C++\\nvector<string> help={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\nIndex of vector represents digits."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Reminded me of the time we had to push buttons 100 times to type hello :)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "hint for Python: `from itertools import product`"
                    }
                ]
            },
            {
                "id": 1998807,
                "content": [
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "I am getting a strange output result: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\",\"\",\"a\",\"b\",\"c\"]\\n expected a b c\\nbut my string list does contain a b c and it does not contain the other values the output shows\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "for gophers:\\n\\n    keyboard := []string{\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}\\n"
                    },
                    {
                        "username": "surelax",
                        "content": "is this kind of question solvable in sql or linear algebra?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "This question is like uncovering a treasure trove of possible combinations! Let\\'s take the number sequence 23 as an example. The number 2 has the letters \\'a\\', \\'b\\', and \\'c\\', while the number 3 has \\'d\\', \\'e\\', and \\'f\\'. Can you guess what combinations we can create from these? That\\'s right! We have ad, ae, af, bd, be, bf,cd,ce,cf. \\uD83C\\uDF89\\n\\n\\uD83C\\uDF1F You pick one letter from the options given by the first number (let\\'s say \\'a\\' from 2), and then you combine it with each letter from the second number (like \\'d\\', \\'e\\', and \\'f\\' from 3). It\\'s like walking down different paths and uncovering hidden words at each turn. \\uD83D\\uDE80\\n\\nWait, can you think of a strategy to make sure we don\\'t miss any possible combinations? \\uD83E\\uDD14 That\\'s where recursion comes into play! Think of it as a magical mirror that reflects the same quest for every letter you pick. You start with one letter, explore all its possible pairings, and then go deeper by repeating the same process with the next letters.\\n\\nAll the best for the back[tracking] ! \\uD83D\\uDDFA\\uFE0F\\uD83D\\uDD0D\\uD83C\\uDF08\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this question is everywhere .\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "LoL! \\uD83D\\uDE00 I have Android Phone ."
                    },
                    {
                        "username": "gd4niele",
                        "content": "I think this problem should be marked as easy"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "C++\\nvector<string> help={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\nIndex of vector represents digits."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Reminded me of the time we had to push buttons 100 times to type hello :)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "hint for Python: `from itertools import product`"
                    }
                ]
            },
            {
                "id": 1998639,
                "content": [
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "I am getting a strange output result: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\",\"\",\"a\",\"b\",\"c\"]\\n expected a b c\\nbut my string list does contain a b c and it does not contain the other values the output shows\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "for gophers:\\n\\n    keyboard := []string{\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}\\n"
                    },
                    {
                        "username": "surelax",
                        "content": "is this kind of question solvable in sql or linear algebra?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "This question is like uncovering a treasure trove of possible combinations! Let\\'s take the number sequence 23 as an example. The number 2 has the letters \\'a\\', \\'b\\', and \\'c\\', while the number 3 has \\'d\\', \\'e\\', and \\'f\\'. Can you guess what combinations we can create from these? That\\'s right! We have ad, ae, af, bd, be, bf,cd,ce,cf. \\uD83C\\uDF89\\n\\n\\uD83C\\uDF1F You pick one letter from the options given by the first number (let\\'s say \\'a\\' from 2), and then you combine it with each letter from the second number (like \\'d\\', \\'e\\', and \\'f\\' from 3). It\\'s like walking down different paths and uncovering hidden words at each turn. \\uD83D\\uDE80\\n\\nWait, can you think of a strategy to make sure we don\\'t miss any possible combinations? \\uD83E\\uDD14 That\\'s where recursion comes into play! Think of it as a magical mirror that reflects the same quest for every letter you pick. You start with one letter, explore all its possible pairings, and then go deeper by repeating the same process with the next letters.\\n\\nAll the best for the back[tracking] ! \\uD83D\\uDDFA\\uFE0F\\uD83D\\uDD0D\\uD83C\\uDF08\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this question is everywhere .\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "LoL! \\uD83D\\uDE00 I have Android Phone ."
                    },
                    {
                        "username": "gd4niele",
                        "content": "I think this problem should be marked as easy"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "C++\\nvector<string> help={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\nIndex of vector represents digits."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Reminded me of the time we had to push buttons 100 times to type hello :)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "hint for Python: `from itertools import product`"
                    }
                ]
            },
            {
                "id": 1998560,
                "content": [
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "I am getting a strange output result: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\",\"\",\"a\",\"b\",\"c\"]\\n expected a b c\\nbut my string list does contain a b c and it does not contain the other values the output shows\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "for gophers:\\n\\n    keyboard := []string{\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}\\n"
                    },
                    {
                        "username": "surelax",
                        "content": "is this kind of question solvable in sql or linear algebra?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "This question is like uncovering a treasure trove of possible combinations! Let\\'s take the number sequence 23 as an example. The number 2 has the letters \\'a\\', \\'b\\', and \\'c\\', while the number 3 has \\'d\\', \\'e\\', and \\'f\\'. Can you guess what combinations we can create from these? That\\'s right! We have ad, ae, af, bd, be, bf,cd,ce,cf. \\uD83C\\uDF89\\n\\n\\uD83C\\uDF1F You pick one letter from the options given by the first number (let\\'s say \\'a\\' from 2), and then you combine it with each letter from the second number (like \\'d\\', \\'e\\', and \\'f\\' from 3). It\\'s like walking down different paths and uncovering hidden words at each turn. \\uD83D\\uDE80\\n\\nWait, can you think of a strategy to make sure we don\\'t miss any possible combinations? \\uD83E\\uDD14 That\\'s where recursion comes into play! Think of it as a magical mirror that reflects the same quest for every letter you pick. You start with one letter, explore all its possible pairings, and then go deeper by repeating the same process with the next letters.\\n\\nAll the best for the back[tracking] ! \\uD83D\\uDDFA\\uFE0F\\uD83D\\uDD0D\\uD83C\\uDF08\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this question is everywhere .\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "LoL! \\uD83D\\uDE00 I have Android Phone ."
                    },
                    {
                        "username": "gd4niele",
                        "content": "I think this problem should be marked as easy"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "C++\\nvector<string> help={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\nIndex of vector represents digits."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Reminded me of the time we had to push buttons 100 times to type hello :)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "hint for Python: `from itertools import product`"
                    }
                ]
            },
            {
                "id": 1998549,
                "content": [
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "I am getting a strange output result: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\",\"\",\"a\",\"b\",\"c\"]\\n expected a b c\\nbut my string list does contain a b c and it does not contain the other values the output shows\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "for gophers:\\n\\n    keyboard := []string{\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}\\n"
                    },
                    {
                        "username": "surelax",
                        "content": "is this kind of question solvable in sql or linear algebra?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "This question is like uncovering a treasure trove of possible combinations! Let\\'s take the number sequence 23 as an example. The number 2 has the letters \\'a\\', \\'b\\', and \\'c\\', while the number 3 has \\'d\\', \\'e\\', and \\'f\\'. Can you guess what combinations we can create from these? That\\'s right! We have ad, ae, af, bd, be, bf,cd,ce,cf. \\uD83C\\uDF89\\n\\n\\uD83C\\uDF1F You pick one letter from the options given by the first number (let\\'s say \\'a\\' from 2), and then you combine it with each letter from the second number (like \\'d\\', \\'e\\', and \\'f\\' from 3). It\\'s like walking down different paths and uncovering hidden words at each turn. \\uD83D\\uDE80\\n\\nWait, can you think of a strategy to make sure we don\\'t miss any possible combinations? \\uD83E\\uDD14 That\\'s where recursion comes into play! Think of it as a magical mirror that reflects the same quest for every letter you pick. You start with one letter, explore all its possible pairings, and then go deeper by repeating the same process with the next letters.\\n\\nAll the best for the back[tracking] ! \\uD83D\\uDDFA\\uFE0F\\uD83D\\uDD0D\\uD83C\\uDF08\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this question is everywhere .\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "LoL! \\uD83D\\uDE00 I have Android Phone ."
                    },
                    {
                        "username": "gd4niele",
                        "content": "I think this problem should be marked as easy"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "C++\\nvector<string> help={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\nIndex of vector represents digits."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Reminded me of the time we had to push buttons 100 times to type hello :)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "hint for Python: `from itertools import product`"
                    }
                ]
            },
            {
                "id": 1998438,
                "content": [
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "I am getting a strange output result: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\",\"\",\"a\",\"b\",\"c\"]\\n expected a b c\\nbut my string list does contain a b c and it does not contain the other values the output shows\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "for gophers:\\n\\n    keyboard := []string{\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}\\n"
                    },
                    {
                        "username": "surelax",
                        "content": "is this kind of question solvable in sql or linear algebra?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "This question is like uncovering a treasure trove of possible combinations! Let\\'s take the number sequence 23 as an example. The number 2 has the letters \\'a\\', \\'b\\', and \\'c\\', while the number 3 has \\'d\\', \\'e\\', and \\'f\\'. Can you guess what combinations we can create from these? That\\'s right! We have ad, ae, af, bd, be, bf,cd,ce,cf. \\uD83C\\uDF89\\n\\n\\uD83C\\uDF1F You pick one letter from the options given by the first number (let\\'s say \\'a\\' from 2), and then you combine it with each letter from the second number (like \\'d\\', \\'e\\', and \\'f\\' from 3). It\\'s like walking down different paths and uncovering hidden words at each turn. \\uD83D\\uDE80\\n\\nWait, can you think of a strategy to make sure we don\\'t miss any possible combinations? \\uD83E\\uDD14 That\\'s where recursion comes into play! Think of it as a magical mirror that reflects the same quest for every letter you pick. You start with one letter, explore all its possible pairings, and then go deeper by repeating the same process with the next letters.\\n\\nAll the best for the back[tracking] ! \\uD83D\\uDDFA\\uFE0F\\uD83D\\uDD0D\\uD83C\\uDF08\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this question is everywhere .\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "LoL! \\uD83D\\uDE00 I have Android Phone ."
                    },
                    {
                        "username": "gd4niele",
                        "content": "I think this problem should be marked as easy"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "C++\\nvector<string> help={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\nIndex of vector represents digits."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Reminded me of the time we had to push buttons 100 times to type hello :)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "hint for Python: `from itertools import product`"
                    }
                ]
            },
            {
                "id": 1998386,
                "content": [
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "I am getting a strange output result: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\",\"\",\"a\",\"b\",\"c\"]\\n expected a b c\\nbut my string list does contain a b c and it does not contain the other values the output shows\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "for gophers:\\n\\n    keyboard := []string{\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}\\n"
                    },
                    {
                        "username": "surelax",
                        "content": "is this kind of question solvable in sql or linear algebra?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "This question is like uncovering a treasure trove of possible combinations! Let\\'s take the number sequence 23 as an example. The number 2 has the letters \\'a\\', \\'b\\', and \\'c\\', while the number 3 has \\'d\\', \\'e\\', and \\'f\\'. Can you guess what combinations we can create from these? That\\'s right! We have ad, ae, af, bd, be, bf,cd,ce,cf. \\uD83C\\uDF89\\n\\n\\uD83C\\uDF1F You pick one letter from the options given by the first number (let\\'s say \\'a\\' from 2), and then you combine it with each letter from the second number (like \\'d\\', \\'e\\', and \\'f\\' from 3). It\\'s like walking down different paths and uncovering hidden words at each turn. \\uD83D\\uDE80\\n\\nWait, can you think of a strategy to make sure we don\\'t miss any possible combinations? \\uD83E\\uDD14 That\\'s where recursion comes into play! Think of it as a magical mirror that reflects the same quest for every letter you pick. You start with one letter, explore all its possible pairings, and then go deeper by repeating the same process with the next letters.\\n\\nAll the best for the back[tracking] ! \\uD83D\\uDDFA\\uFE0F\\uD83D\\uDD0D\\uD83C\\uDF08\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this question is everywhere .\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "LoL! \\uD83D\\uDE00 I have Android Phone ."
                    },
                    {
                        "username": "gd4niele",
                        "content": "I think this problem should be marked as easy"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "C++\\nvector<string> help={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\nIndex of vector represents digits."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Reminded me of the time we had to push buttons 100 times to type hello :)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "hint for Python: `from itertools import product`"
                    }
                ]
            },
            {
                "id": 1998325,
                "content": [
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "I am getting a strange output result: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\",\"\",\"a\",\"b\",\"c\"]\\n expected a b c\\nbut my string list does contain a b c and it does not contain the other values the output shows\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "for gophers:\\n\\n    keyboard := []string{\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}\\n"
                    },
                    {
                        "username": "surelax",
                        "content": "is this kind of question solvable in sql or linear algebra?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "This question is like uncovering a treasure trove of possible combinations! Let\\'s take the number sequence 23 as an example. The number 2 has the letters \\'a\\', \\'b\\', and \\'c\\', while the number 3 has \\'d\\', \\'e\\', and \\'f\\'. Can you guess what combinations we can create from these? That\\'s right! We have ad, ae, af, bd, be, bf,cd,ce,cf. \\uD83C\\uDF89\\n\\n\\uD83C\\uDF1F You pick one letter from the options given by the first number (let\\'s say \\'a\\' from 2), and then you combine it with each letter from the second number (like \\'d\\', \\'e\\', and \\'f\\' from 3). It\\'s like walking down different paths and uncovering hidden words at each turn. \\uD83D\\uDE80\\n\\nWait, can you think of a strategy to make sure we don\\'t miss any possible combinations? \\uD83E\\uDD14 That\\'s where recursion comes into play! Think of it as a magical mirror that reflects the same quest for every letter you pick. You start with one letter, explore all its possible pairings, and then go deeper by repeating the same process with the next letters.\\n\\nAll the best for the back[tracking] ! \\uD83D\\uDDFA\\uFE0F\\uD83D\\uDD0D\\uD83C\\uDF08\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this question is everywhere .\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "LoL! \\uD83D\\uDE00 I have Android Phone ."
                    },
                    {
                        "username": "gd4niele",
                        "content": "I think this problem should be marked as easy"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "C++\\nvector<string> help={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\nIndex of vector represents digits."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Reminded me of the time we had to push buttons 100 times to type hello :)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "hint for Python: `from itertools import product`"
                    }
                ]
            },
            {
                "id": 1998291,
                "content": [
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "I am getting a strange output result: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\",\"\",\"a\",\"b\",\"c\"]\\n expected a b c\\nbut my string list does contain a b c and it does not contain the other values the output shows\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "for gophers:\\n\\n    keyboard := []string{\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}\\n"
                    },
                    {
                        "username": "surelax",
                        "content": "is this kind of question solvable in sql or linear algebra?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "This question is like uncovering a treasure trove of possible combinations! Let\\'s take the number sequence 23 as an example. The number 2 has the letters \\'a\\', \\'b\\', and \\'c\\', while the number 3 has \\'d\\', \\'e\\', and \\'f\\'. Can you guess what combinations we can create from these? That\\'s right! We have ad, ae, af, bd, be, bf,cd,ce,cf. \\uD83C\\uDF89\\n\\n\\uD83C\\uDF1F You pick one letter from the options given by the first number (let\\'s say \\'a\\' from 2), and then you combine it with each letter from the second number (like \\'d\\', \\'e\\', and \\'f\\' from 3). It\\'s like walking down different paths and uncovering hidden words at each turn. \\uD83D\\uDE80\\n\\nWait, can you think of a strategy to make sure we don\\'t miss any possible combinations? \\uD83E\\uDD14 That\\'s where recursion comes into play! Think of it as a magical mirror that reflects the same quest for every letter you pick. You start with one letter, explore all its possible pairings, and then go deeper by repeating the same process with the next letters.\\n\\nAll the best for the back[tracking] ! \\uD83D\\uDDFA\\uFE0F\\uD83D\\uDD0D\\uD83C\\uDF08\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this question is everywhere .\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "LoL! \\uD83D\\uDE00 I have Android Phone ."
                    },
                    {
                        "username": "gd4niele",
                        "content": "I think this problem should be marked as easy"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "C++\\nvector<string> help={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\nIndex of vector represents digits."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Reminded me of the time we had to push buttons 100 times to type hello :)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "hint for Python: `from itertools import product`"
                    }
                ]
            },
            {
                "id": 1998264,
                "content": [
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "I am getting a strange output result: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\",\"\",\"a\",\"b\",\"c\"]\\n expected a b c\\nbut my string list does contain a b c and it does not contain the other values the output shows\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "for gophers:\\n\\n    keyboard := []string{\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}\\n"
                    },
                    {
                        "username": "surelax",
                        "content": "is this kind of question solvable in sql or linear algebra?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "This question is like uncovering a treasure trove of possible combinations! Let\\'s take the number sequence 23 as an example. The number 2 has the letters \\'a\\', \\'b\\', and \\'c\\', while the number 3 has \\'d\\', \\'e\\', and \\'f\\'. Can you guess what combinations we can create from these? That\\'s right! We have ad, ae, af, bd, be, bf,cd,ce,cf. \\uD83C\\uDF89\\n\\n\\uD83C\\uDF1F You pick one letter from the options given by the first number (let\\'s say \\'a\\' from 2), and then you combine it with each letter from the second number (like \\'d\\', \\'e\\', and \\'f\\' from 3). It\\'s like walking down different paths and uncovering hidden words at each turn. \\uD83D\\uDE80\\n\\nWait, can you think of a strategy to make sure we don\\'t miss any possible combinations? \\uD83E\\uDD14 That\\'s where recursion comes into play! Think of it as a magical mirror that reflects the same quest for every letter you pick. You start with one letter, explore all its possible pairings, and then go deeper by repeating the same process with the next letters.\\n\\nAll the best for the back[tracking] ! \\uD83D\\uDDFA\\uFE0F\\uD83D\\uDD0D\\uD83C\\uDF08\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this question is everywhere .\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "LoL! \\uD83D\\uDE00 I have Android Phone ."
                    },
                    {
                        "username": "gd4niele",
                        "content": "I think this problem should be marked as easy"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "C++\\nvector<string> help={\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\nIndex of vector represents digits."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Reminded me of the time we had to push buttons 100 times to type hello :)"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "hint for Python: `from itertools import product`"
                    }
                ]
            },
            {
                "id": 1998240,
                "content": [
                    {
                        "username": "KarAnSiNghhh",
                        "content": "i just wanted to ask the top coders as i am a begineer that i am doing right i just think for the approach for 40 mins and then i look to the solution or yt videos for the ques am i doing right and please provide me any tips it would be very helpful "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "[@KarAnSiNghhh](/KarAnSiNghhh) Anytime, my friend! Good luck! Consistency is key. Many questions will be difficult at first, but if you stay consistent and do at least one problem a day, you will improve drastically. Don\\'t get discouraged along the way if you are unable to solve a lot of problems. It is very hard to find the solution to many of these questions without having already seen a similar solution in the past. It\\'s all about immersion and exposure. The more problems you see and the more solutions you uncover, the easier all other problems become! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@NoMansGhost](/NoMansGhost)  thanks bro "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "I also recommend using a spaced repetition app like AnkiApp and saving a screenshot of the question on a digital flashcard, writing the answer out in your own words on the back of the flashcard + a screenshot of the solution, and then continually testing yourself daily, so you don\\'t forget the solution and slowly incorporate it into your programmer tool belt."
                    },
                    {
                        "username": "psionl0",
                        "content": "That is a good strategy but an important aspect is follow up. Once you have got the answer up and running, click on the Similar Questions tab and see if you can solve some of them without looking up hints or videos."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-)**\\n- Create a mapping: Initialize a data structure, such as a list or dictionary, that maps each digit to the corresponding letters on the phone keypad. For example, in the case of a standard telephone keypad, the digit \\'2\\' maps to the letters \\'a\\', \\'b\\', and \\'c\\', the digit \\'3\\' maps to \\'d\\', \\'e\\', and \\'f\\', and so on.\\n\\n- Initialize a list to store the results: Create an empty list to store the final letter combinations.\\n\\n- Implement a backtracking function: This function will be responsible for generating all possible combinations. It should take the following parameters:\\n\\n  - digits: The original input string of digits.\\n  - currentIndex: The index indicating which digit we are processing from the digits string.\\n  - currentCombination: A string representing the current combination being built.\\n- Base case: If the length of currentCombination is equal to the length of the digits string, it means we have formed a complete combination. So, add the current combination to the results list and return from the current recursive call.\\n\\n- Recursive case: For the current digit at currentIndex, iterate through the characters corresponding to that digit from the mapping created in step 1. For each character, append it to the currentCombination, and then make a recursive call to the backtracking function with the next index (currentIndex + 1). This step allows us to explore all possible combinations that can be formed by considering different characters for each digit.\\n\\n- Backtrack: After the recursive call, remove the last character from the currentCombination to explore other possibilities. This is essential for backtracking and exploring different combinations.\\n\\n- The backtracking function continues recursively until all possible combinations are generated.\\n\\n- Finally, after the backtracking function completes, the results list will contain all the valid letter combinations that can be formed from the given input string of digits."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " Thank you [@KarAnSiNghhh](/KarAnSiNghhh) ! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) thank u so much for helping a noob like me \\uD83D\\uDE0C"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***here is the code link for reference:-)***\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/2816695/easiest-solution-java-only-lists/"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Indeed a PnC  week"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this is the first backtracking that I can solve all on my own within a reasonable timeframe! "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "perfect backtrack week : )"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s a backracking week then**"
                    },
                    {
                        "username": "Linpham21",
                        "content": "LC trying to tell me something with a backtracking week"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "Time complexity : for worst case scenario max length of characters is 4, and if N is digits.Legnth then, it is,\n\nTC : approx. O(4^N), if digits length is greater than 10 it TC increases exponentially, but for this problem digits length is max 4.\n\nSay N = 4, \n\nS4 = 4 + 4^2 + 4 ^3 + 4^ 4\n\nS4 = 4(1+4 +4^2+4^3)\n\nSay N =3,\nthen,\nS3 = 4 + 4^2 + 4^3\n\nS4 = 4 * S3\n\nS4 = S3 + 4^4\nS4 = (S3/4) + 4^4\n\n3S4 = 4^5\n\nTherefore, for any digits.Length = n, we can have,\n\nTime complexity = (4^(n+1))/3"
                    },
                    {
                        "username": "pradeepmaheshwaram",
                        "content": "what is the complexity of the code? someone reply\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "should be 3^n or at worst case 4^n (for 7 and 9)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is the question where backtracking finally clicked for me (I spent a long time on this on and off). Suddenly I can do permutations and combinations with my eyes closed. Since I have already done the last 3 problems, I guess that I will have a relatively easy week."
                    }
                ]
            },
            {
                "id": 1998229,
                "content": [
                    {
                        "username": "KarAnSiNghhh",
                        "content": "i just wanted to ask the top coders as i am a begineer that i am doing right i just think for the approach for 40 mins and then i look to the solution or yt videos for the ques am i doing right and please provide me any tips it would be very helpful "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "[@KarAnSiNghhh](/KarAnSiNghhh) Anytime, my friend! Good luck! Consistency is key. Many questions will be difficult at first, but if you stay consistent and do at least one problem a day, you will improve drastically. Don\\'t get discouraged along the way if you are unable to solve a lot of problems. It is very hard to find the solution to many of these questions without having already seen a similar solution in the past. It\\'s all about immersion and exposure. The more problems you see and the more solutions you uncover, the easier all other problems become! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@NoMansGhost](/NoMansGhost)  thanks bro "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "I also recommend using a spaced repetition app like AnkiApp and saving a screenshot of the question on a digital flashcard, writing the answer out in your own words on the back of the flashcard + a screenshot of the solution, and then continually testing yourself daily, so you don\\'t forget the solution and slowly incorporate it into your programmer tool belt."
                    },
                    {
                        "username": "psionl0",
                        "content": "That is a good strategy but an important aspect is follow up. Once you have got the answer up and running, click on the Similar Questions tab and see if you can solve some of them without looking up hints or videos."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-)**\\n- Create a mapping: Initialize a data structure, such as a list or dictionary, that maps each digit to the corresponding letters on the phone keypad. For example, in the case of a standard telephone keypad, the digit \\'2\\' maps to the letters \\'a\\', \\'b\\', and \\'c\\', the digit \\'3\\' maps to \\'d\\', \\'e\\', and \\'f\\', and so on.\\n\\n- Initialize a list to store the results: Create an empty list to store the final letter combinations.\\n\\n- Implement a backtracking function: This function will be responsible for generating all possible combinations. It should take the following parameters:\\n\\n  - digits: The original input string of digits.\\n  - currentIndex: The index indicating which digit we are processing from the digits string.\\n  - currentCombination: A string representing the current combination being built.\\n- Base case: If the length of currentCombination is equal to the length of the digits string, it means we have formed a complete combination. So, add the current combination to the results list and return from the current recursive call.\\n\\n- Recursive case: For the current digit at currentIndex, iterate through the characters corresponding to that digit from the mapping created in step 1. For each character, append it to the currentCombination, and then make a recursive call to the backtracking function with the next index (currentIndex + 1). This step allows us to explore all possible combinations that can be formed by considering different characters for each digit.\\n\\n- Backtrack: After the recursive call, remove the last character from the currentCombination to explore other possibilities. This is essential for backtracking and exploring different combinations.\\n\\n- The backtracking function continues recursively until all possible combinations are generated.\\n\\n- Finally, after the backtracking function completes, the results list will contain all the valid letter combinations that can be formed from the given input string of digits."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " Thank you [@KarAnSiNghhh](/KarAnSiNghhh) ! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) thank u so much for helping a noob like me \\uD83D\\uDE0C"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***here is the code link for reference:-)***\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/2816695/easiest-solution-java-only-lists/"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Indeed a PnC  week"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this is the first backtracking that I can solve all on my own within a reasonable timeframe! "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "perfect backtrack week : )"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s a backracking week then**"
                    },
                    {
                        "username": "Linpham21",
                        "content": "LC trying to tell me something with a backtracking week"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "Time complexity : for worst case scenario max length of characters is 4, and if N is digits.Legnth then, it is,\n\nTC : approx. O(4^N), if digits length is greater than 10 it TC increases exponentially, but for this problem digits length is max 4.\n\nSay N = 4, \n\nS4 = 4 + 4^2 + 4 ^3 + 4^ 4\n\nS4 = 4(1+4 +4^2+4^3)\n\nSay N =3,\nthen,\nS3 = 4 + 4^2 + 4^3\n\nS4 = 4 * S3\n\nS4 = S3 + 4^4\nS4 = (S3/4) + 4^4\n\n3S4 = 4^5\n\nTherefore, for any digits.Length = n, we can have,\n\nTime complexity = (4^(n+1))/3"
                    },
                    {
                        "username": "pradeepmaheshwaram",
                        "content": "what is the complexity of the code? someone reply\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "should be 3^n or at worst case 4^n (for 7 and 9)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is the question where backtracking finally clicked for me (I spent a long time on this on and off). Suddenly I can do permutations and combinations with my eyes closed. Since I have already done the last 3 problems, I guess that I will have a relatively easy week."
                    }
                ]
            },
            {
                "id": 1998065,
                "content": [
                    {
                        "username": "KarAnSiNghhh",
                        "content": "i just wanted to ask the top coders as i am a begineer that i am doing right i just think for the approach for 40 mins and then i look to the solution or yt videos for the ques am i doing right and please provide me any tips it would be very helpful "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "[@KarAnSiNghhh](/KarAnSiNghhh) Anytime, my friend! Good luck! Consistency is key. Many questions will be difficult at first, but if you stay consistent and do at least one problem a day, you will improve drastically. Don\\'t get discouraged along the way if you are unable to solve a lot of problems. It is very hard to find the solution to many of these questions without having already seen a similar solution in the past. It\\'s all about immersion and exposure. The more problems you see and the more solutions you uncover, the easier all other problems become! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@NoMansGhost](/NoMansGhost)  thanks bro "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "I also recommend using a spaced repetition app like AnkiApp and saving a screenshot of the question on a digital flashcard, writing the answer out in your own words on the back of the flashcard + a screenshot of the solution, and then continually testing yourself daily, so you don\\'t forget the solution and slowly incorporate it into your programmer tool belt."
                    },
                    {
                        "username": "psionl0",
                        "content": "That is a good strategy but an important aspect is follow up. Once you have got the answer up and running, click on the Similar Questions tab and see if you can solve some of them without looking up hints or videos."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-)**\\n- Create a mapping: Initialize a data structure, such as a list or dictionary, that maps each digit to the corresponding letters on the phone keypad. For example, in the case of a standard telephone keypad, the digit \\'2\\' maps to the letters \\'a\\', \\'b\\', and \\'c\\', the digit \\'3\\' maps to \\'d\\', \\'e\\', and \\'f\\', and so on.\\n\\n- Initialize a list to store the results: Create an empty list to store the final letter combinations.\\n\\n- Implement a backtracking function: This function will be responsible for generating all possible combinations. It should take the following parameters:\\n\\n  - digits: The original input string of digits.\\n  - currentIndex: The index indicating which digit we are processing from the digits string.\\n  - currentCombination: A string representing the current combination being built.\\n- Base case: If the length of currentCombination is equal to the length of the digits string, it means we have formed a complete combination. So, add the current combination to the results list and return from the current recursive call.\\n\\n- Recursive case: For the current digit at currentIndex, iterate through the characters corresponding to that digit from the mapping created in step 1. For each character, append it to the currentCombination, and then make a recursive call to the backtracking function with the next index (currentIndex + 1). This step allows us to explore all possible combinations that can be formed by considering different characters for each digit.\\n\\n- Backtrack: After the recursive call, remove the last character from the currentCombination to explore other possibilities. This is essential for backtracking and exploring different combinations.\\n\\n- The backtracking function continues recursively until all possible combinations are generated.\\n\\n- Finally, after the backtracking function completes, the results list will contain all the valid letter combinations that can be formed from the given input string of digits."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " Thank you [@KarAnSiNghhh](/KarAnSiNghhh) ! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) thank u so much for helping a noob like me \\uD83D\\uDE0C"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***here is the code link for reference:-)***\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/2816695/easiest-solution-java-only-lists/"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Indeed a PnC  week"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this is the first backtracking that I can solve all on my own within a reasonable timeframe! "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "perfect backtrack week : )"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s a backracking week then**"
                    },
                    {
                        "username": "Linpham21",
                        "content": "LC trying to tell me something with a backtracking week"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "Time complexity : for worst case scenario max length of characters is 4, and if N is digits.Legnth then, it is,\n\nTC : approx. O(4^N), if digits length is greater than 10 it TC increases exponentially, but for this problem digits length is max 4.\n\nSay N = 4, \n\nS4 = 4 + 4^2 + 4 ^3 + 4^ 4\n\nS4 = 4(1+4 +4^2+4^3)\n\nSay N =3,\nthen,\nS3 = 4 + 4^2 + 4^3\n\nS4 = 4 * S3\n\nS4 = S3 + 4^4\nS4 = (S3/4) + 4^4\n\n3S4 = 4^5\n\nTherefore, for any digits.Length = n, we can have,\n\nTime complexity = (4^(n+1))/3"
                    },
                    {
                        "username": "pradeepmaheshwaram",
                        "content": "what is the complexity of the code? someone reply\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "should be 3^n or at worst case 4^n (for 7 and 9)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is the question where backtracking finally clicked for me (I spent a long time on this on and off). Suddenly I can do permutations and combinations with my eyes closed. Since I have already done the last 3 problems, I guess that I will have a relatively easy week."
                    }
                ]
            },
            {
                "id": 1998041,
                "content": [
                    {
                        "username": "KarAnSiNghhh",
                        "content": "i just wanted to ask the top coders as i am a begineer that i am doing right i just think for the approach for 40 mins and then i look to the solution or yt videos for the ques am i doing right and please provide me any tips it would be very helpful "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "[@KarAnSiNghhh](/KarAnSiNghhh) Anytime, my friend! Good luck! Consistency is key. Many questions will be difficult at first, but if you stay consistent and do at least one problem a day, you will improve drastically. Don\\'t get discouraged along the way if you are unable to solve a lot of problems. It is very hard to find the solution to many of these questions without having already seen a similar solution in the past. It\\'s all about immersion and exposure. The more problems you see and the more solutions you uncover, the easier all other problems become! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@NoMansGhost](/NoMansGhost)  thanks bro "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "I also recommend using a spaced repetition app like AnkiApp and saving a screenshot of the question on a digital flashcard, writing the answer out in your own words on the back of the flashcard + a screenshot of the solution, and then continually testing yourself daily, so you don\\'t forget the solution and slowly incorporate it into your programmer tool belt."
                    },
                    {
                        "username": "psionl0",
                        "content": "That is a good strategy but an important aspect is follow up. Once you have got the answer up and running, click on the Similar Questions tab and see if you can solve some of them without looking up hints or videos."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-)**\\n- Create a mapping: Initialize a data structure, such as a list or dictionary, that maps each digit to the corresponding letters on the phone keypad. For example, in the case of a standard telephone keypad, the digit \\'2\\' maps to the letters \\'a\\', \\'b\\', and \\'c\\', the digit \\'3\\' maps to \\'d\\', \\'e\\', and \\'f\\', and so on.\\n\\n- Initialize a list to store the results: Create an empty list to store the final letter combinations.\\n\\n- Implement a backtracking function: This function will be responsible for generating all possible combinations. It should take the following parameters:\\n\\n  - digits: The original input string of digits.\\n  - currentIndex: The index indicating which digit we are processing from the digits string.\\n  - currentCombination: A string representing the current combination being built.\\n- Base case: If the length of currentCombination is equal to the length of the digits string, it means we have formed a complete combination. So, add the current combination to the results list and return from the current recursive call.\\n\\n- Recursive case: For the current digit at currentIndex, iterate through the characters corresponding to that digit from the mapping created in step 1. For each character, append it to the currentCombination, and then make a recursive call to the backtracking function with the next index (currentIndex + 1). This step allows us to explore all possible combinations that can be formed by considering different characters for each digit.\\n\\n- Backtrack: After the recursive call, remove the last character from the currentCombination to explore other possibilities. This is essential for backtracking and exploring different combinations.\\n\\n- The backtracking function continues recursively until all possible combinations are generated.\\n\\n- Finally, after the backtracking function completes, the results list will contain all the valid letter combinations that can be formed from the given input string of digits."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " Thank you [@KarAnSiNghhh](/KarAnSiNghhh) ! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) thank u so much for helping a noob like me \\uD83D\\uDE0C"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***here is the code link for reference:-)***\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/2816695/easiest-solution-java-only-lists/"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Indeed a PnC  week"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this is the first backtracking that I can solve all on my own within a reasonable timeframe! "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "perfect backtrack week : )"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s a backracking week then**"
                    },
                    {
                        "username": "Linpham21",
                        "content": "LC trying to tell me something with a backtracking week"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "Time complexity : for worst case scenario max length of characters is 4, and if N is digits.Legnth then, it is,\n\nTC : approx. O(4^N), if digits length is greater than 10 it TC increases exponentially, but for this problem digits length is max 4.\n\nSay N = 4, \n\nS4 = 4 + 4^2 + 4 ^3 + 4^ 4\n\nS4 = 4(1+4 +4^2+4^3)\n\nSay N =3,\nthen,\nS3 = 4 + 4^2 + 4^3\n\nS4 = 4 * S3\n\nS4 = S3 + 4^4\nS4 = (S3/4) + 4^4\n\n3S4 = 4^5\n\nTherefore, for any digits.Length = n, we can have,\n\nTime complexity = (4^(n+1))/3"
                    },
                    {
                        "username": "pradeepmaheshwaram",
                        "content": "what is the complexity of the code? someone reply\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "should be 3^n or at worst case 4^n (for 7 and 9)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is the question where backtracking finally clicked for me (I spent a long time on this on and off). Suddenly I can do permutations and combinations with my eyes closed. Since I have already done the last 3 problems, I guess that I will have a relatively easy week."
                    }
                ]
            },
            {
                "id": 1997972,
                "content": [
                    {
                        "username": "KarAnSiNghhh",
                        "content": "i just wanted to ask the top coders as i am a begineer that i am doing right i just think for the approach for 40 mins and then i look to the solution or yt videos for the ques am i doing right and please provide me any tips it would be very helpful "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "[@KarAnSiNghhh](/KarAnSiNghhh) Anytime, my friend! Good luck! Consistency is key. Many questions will be difficult at first, but if you stay consistent and do at least one problem a day, you will improve drastically. Don\\'t get discouraged along the way if you are unable to solve a lot of problems. It is very hard to find the solution to many of these questions without having already seen a similar solution in the past. It\\'s all about immersion and exposure. The more problems you see and the more solutions you uncover, the easier all other problems become! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@NoMansGhost](/NoMansGhost)  thanks bro "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "I also recommend using a spaced repetition app like AnkiApp and saving a screenshot of the question on a digital flashcard, writing the answer out in your own words on the back of the flashcard + a screenshot of the solution, and then continually testing yourself daily, so you don\\'t forget the solution and slowly incorporate it into your programmer tool belt."
                    },
                    {
                        "username": "psionl0",
                        "content": "That is a good strategy but an important aspect is follow up. Once you have got the answer up and running, click on the Similar Questions tab and see if you can solve some of them without looking up hints or videos."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-)**\\n- Create a mapping: Initialize a data structure, such as a list or dictionary, that maps each digit to the corresponding letters on the phone keypad. For example, in the case of a standard telephone keypad, the digit \\'2\\' maps to the letters \\'a\\', \\'b\\', and \\'c\\', the digit \\'3\\' maps to \\'d\\', \\'e\\', and \\'f\\', and so on.\\n\\n- Initialize a list to store the results: Create an empty list to store the final letter combinations.\\n\\n- Implement a backtracking function: This function will be responsible for generating all possible combinations. It should take the following parameters:\\n\\n  - digits: The original input string of digits.\\n  - currentIndex: The index indicating which digit we are processing from the digits string.\\n  - currentCombination: A string representing the current combination being built.\\n- Base case: If the length of currentCombination is equal to the length of the digits string, it means we have formed a complete combination. So, add the current combination to the results list and return from the current recursive call.\\n\\n- Recursive case: For the current digit at currentIndex, iterate through the characters corresponding to that digit from the mapping created in step 1. For each character, append it to the currentCombination, and then make a recursive call to the backtracking function with the next index (currentIndex + 1). This step allows us to explore all possible combinations that can be formed by considering different characters for each digit.\\n\\n- Backtrack: After the recursive call, remove the last character from the currentCombination to explore other possibilities. This is essential for backtracking and exploring different combinations.\\n\\n- The backtracking function continues recursively until all possible combinations are generated.\\n\\n- Finally, after the backtracking function completes, the results list will contain all the valid letter combinations that can be formed from the given input string of digits."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " Thank you [@KarAnSiNghhh](/KarAnSiNghhh) ! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) thank u so much for helping a noob like me \\uD83D\\uDE0C"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***here is the code link for reference:-)***\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/2816695/easiest-solution-java-only-lists/"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Indeed a PnC  week"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this is the first backtracking that I can solve all on my own within a reasonable timeframe! "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "perfect backtrack week : )"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s a backracking week then**"
                    },
                    {
                        "username": "Linpham21",
                        "content": "LC trying to tell me something with a backtracking week"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "Time complexity : for worst case scenario max length of characters is 4, and if N is digits.Legnth then, it is,\n\nTC : approx. O(4^N), if digits length is greater than 10 it TC increases exponentially, but for this problem digits length is max 4.\n\nSay N = 4, \n\nS4 = 4 + 4^2 + 4 ^3 + 4^ 4\n\nS4 = 4(1+4 +4^2+4^3)\n\nSay N =3,\nthen,\nS3 = 4 + 4^2 + 4^3\n\nS4 = 4 * S3\n\nS4 = S3 + 4^4\nS4 = (S3/4) + 4^4\n\n3S4 = 4^5\n\nTherefore, for any digits.Length = n, we can have,\n\nTime complexity = (4^(n+1))/3"
                    },
                    {
                        "username": "pradeepmaheshwaram",
                        "content": "what is the complexity of the code? someone reply\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "should be 3^n or at worst case 4^n (for 7 and 9)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is the question where backtracking finally clicked for me (I spent a long time on this on and off). Suddenly I can do permutations and combinations with my eyes closed. Since I have already done the last 3 problems, I guess that I will have a relatively easy week."
                    }
                ]
            },
            {
                "id": 1997955,
                "content": [
                    {
                        "username": "KarAnSiNghhh",
                        "content": "i just wanted to ask the top coders as i am a begineer that i am doing right i just think for the approach for 40 mins and then i look to the solution or yt videos for the ques am i doing right and please provide me any tips it would be very helpful "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "[@KarAnSiNghhh](/KarAnSiNghhh) Anytime, my friend! Good luck! Consistency is key. Many questions will be difficult at first, but if you stay consistent and do at least one problem a day, you will improve drastically. Don\\'t get discouraged along the way if you are unable to solve a lot of problems. It is very hard to find the solution to many of these questions without having already seen a similar solution in the past. It\\'s all about immersion and exposure. The more problems you see and the more solutions you uncover, the easier all other problems become! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@NoMansGhost](/NoMansGhost)  thanks bro "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "I also recommend using a spaced repetition app like AnkiApp and saving a screenshot of the question on a digital flashcard, writing the answer out in your own words on the back of the flashcard + a screenshot of the solution, and then continually testing yourself daily, so you don\\'t forget the solution and slowly incorporate it into your programmer tool belt."
                    },
                    {
                        "username": "psionl0",
                        "content": "That is a good strategy but an important aspect is follow up. Once you have got the answer up and running, click on the Similar Questions tab and see if you can solve some of them without looking up hints or videos."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-)**\\n- Create a mapping: Initialize a data structure, such as a list or dictionary, that maps each digit to the corresponding letters on the phone keypad. For example, in the case of a standard telephone keypad, the digit \\'2\\' maps to the letters \\'a\\', \\'b\\', and \\'c\\', the digit \\'3\\' maps to \\'d\\', \\'e\\', and \\'f\\', and so on.\\n\\n- Initialize a list to store the results: Create an empty list to store the final letter combinations.\\n\\n- Implement a backtracking function: This function will be responsible for generating all possible combinations. It should take the following parameters:\\n\\n  - digits: The original input string of digits.\\n  - currentIndex: The index indicating which digit we are processing from the digits string.\\n  - currentCombination: A string representing the current combination being built.\\n- Base case: If the length of currentCombination is equal to the length of the digits string, it means we have formed a complete combination. So, add the current combination to the results list and return from the current recursive call.\\n\\n- Recursive case: For the current digit at currentIndex, iterate through the characters corresponding to that digit from the mapping created in step 1. For each character, append it to the currentCombination, and then make a recursive call to the backtracking function with the next index (currentIndex + 1). This step allows us to explore all possible combinations that can be formed by considering different characters for each digit.\\n\\n- Backtrack: After the recursive call, remove the last character from the currentCombination to explore other possibilities. This is essential for backtracking and exploring different combinations.\\n\\n- The backtracking function continues recursively until all possible combinations are generated.\\n\\n- Finally, after the backtracking function completes, the results list will contain all the valid letter combinations that can be formed from the given input string of digits."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " Thank you [@KarAnSiNghhh](/KarAnSiNghhh) ! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) thank u so much for helping a noob like me \\uD83D\\uDE0C"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***here is the code link for reference:-)***\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/2816695/easiest-solution-java-only-lists/"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Indeed a PnC  week"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this is the first backtracking that I can solve all on my own within a reasonable timeframe! "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "perfect backtrack week : )"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s a backracking week then**"
                    },
                    {
                        "username": "Linpham21",
                        "content": "LC trying to tell me something with a backtracking week"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "Time complexity : for worst case scenario max length of characters is 4, and if N is digits.Legnth then, it is,\n\nTC : approx. O(4^N), if digits length is greater than 10 it TC increases exponentially, but for this problem digits length is max 4.\n\nSay N = 4, \n\nS4 = 4 + 4^2 + 4 ^3 + 4^ 4\n\nS4 = 4(1+4 +4^2+4^3)\n\nSay N =3,\nthen,\nS3 = 4 + 4^2 + 4^3\n\nS4 = 4 * S3\n\nS4 = S3 + 4^4\nS4 = (S3/4) + 4^4\n\n3S4 = 4^5\n\nTherefore, for any digits.Length = n, we can have,\n\nTime complexity = (4^(n+1))/3"
                    },
                    {
                        "username": "pradeepmaheshwaram",
                        "content": "what is the complexity of the code? someone reply\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "should be 3^n or at worst case 4^n (for 7 and 9)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is the question where backtracking finally clicked for me (I spent a long time on this on and off). Suddenly I can do permutations and combinations with my eyes closed. Since I have already done the last 3 problems, I guess that I will have a relatively easy week."
                    }
                ]
            },
            {
                "id": 1997952,
                "content": [
                    {
                        "username": "KarAnSiNghhh",
                        "content": "i just wanted to ask the top coders as i am a begineer that i am doing right i just think for the approach for 40 mins and then i look to the solution or yt videos for the ques am i doing right and please provide me any tips it would be very helpful "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "[@KarAnSiNghhh](/KarAnSiNghhh) Anytime, my friend! Good luck! Consistency is key. Many questions will be difficult at first, but if you stay consistent and do at least one problem a day, you will improve drastically. Don\\'t get discouraged along the way if you are unable to solve a lot of problems. It is very hard to find the solution to many of these questions without having already seen a similar solution in the past. It\\'s all about immersion and exposure. The more problems you see and the more solutions you uncover, the easier all other problems become! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@NoMansGhost](/NoMansGhost)  thanks bro "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "I also recommend using a spaced repetition app like AnkiApp and saving a screenshot of the question on a digital flashcard, writing the answer out in your own words on the back of the flashcard + a screenshot of the solution, and then continually testing yourself daily, so you don\\'t forget the solution and slowly incorporate it into your programmer tool belt."
                    },
                    {
                        "username": "psionl0",
                        "content": "That is a good strategy but an important aspect is follow up. Once you have got the answer up and running, click on the Similar Questions tab and see if you can solve some of them without looking up hints or videos."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-)**\\n- Create a mapping: Initialize a data structure, such as a list or dictionary, that maps each digit to the corresponding letters on the phone keypad. For example, in the case of a standard telephone keypad, the digit \\'2\\' maps to the letters \\'a\\', \\'b\\', and \\'c\\', the digit \\'3\\' maps to \\'d\\', \\'e\\', and \\'f\\', and so on.\\n\\n- Initialize a list to store the results: Create an empty list to store the final letter combinations.\\n\\n- Implement a backtracking function: This function will be responsible for generating all possible combinations. It should take the following parameters:\\n\\n  - digits: The original input string of digits.\\n  - currentIndex: The index indicating which digit we are processing from the digits string.\\n  - currentCombination: A string representing the current combination being built.\\n- Base case: If the length of currentCombination is equal to the length of the digits string, it means we have formed a complete combination. So, add the current combination to the results list and return from the current recursive call.\\n\\n- Recursive case: For the current digit at currentIndex, iterate through the characters corresponding to that digit from the mapping created in step 1. For each character, append it to the currentCombination, and then make a recursive call to the backtracking function with the next index (currentIndex + 1). This step allows us to explore all possible combinations that can be formed by considering different characters for each digit.\\n\\n- Backtrack: After the recursive call, remove the last character from the currentCombination to explore other possibilities. This is essential for backtracking and exploring different combinations.\\n\\n- The backtracking function continues recursively until all possible combinations are generated.\\n\\n- Finally, after the backtracking function completes, the results list will contain all the valid letter combinations that can be formed from the given input string of digits."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " Thank you [@KarAnSiNghhh](/KarAnSiNghhh) ! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) thank u so much for helping a noob like me \\uD83D\\uDE0C"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***here is the code link for reference:-)***\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/2816695/easiest-solution-java-only-lists/"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Indeed a PnC  week"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this is the first backtracking that I can solve all on my own within a reasonable timeframe! "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "perfect backtrack week : )"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s a backracking week then**"
                    },
                    {
                        "username": "Linpham21",
                        "content": "LC trying to tell me something with a backtracking week"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "Time complexity : for worst case scenario max length of characters is 4, and if N is digits.Legnth then, it is,\n\nTC : approx. O(4^N), if digits length is greater than 10 it TC increases exponentially, but for this problem digits length is max 4.\n\nSay N = 4, \n\nS4 = 4 + 4^2 + 4 ^3 + 4^ 4\n\nS4 = 4(1+4 +4^2+4^3)\n\nSay N =3,\nthen,\nS3 = 4 + 4^2 + 4^3\n\nS4 = 4 * S3\n\nS4 = S3 + 4^4\nS4 = (S3/4) + 4^4\n\n3S4 = 4^5\n\nTherefore, for any digits.Length = n, we can have,\n\nTime complexity = (4^(n+1))/3"
                    },
                    {
                        "username": "pradeepmaheshwaram",
                        "content": "what is the complexity of the code? someone reply\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "should be 3^n or at worst case 4^n (for 7 and 9)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is the question where backtracking finally clicked for me (I spent a long time on this on and off). Suddenly I can do permutations and combinations with my eyes closed. Since I have already done the last 3 problems, I guess that I will have a relatively easy week."
                    }
                ]
            },
            {
                "id": 1997919,
                "content": [
                    {
                        "username": "KarAnSiNghhh",
                        "content": "i just wanted to ask the top coders as i am a begineer that i am doing right i just think for the approach for 40 mins and then i look to the solution or yt videos for the ques am i doing right and please provide me any tips it would be very helpful "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "[@KarAnSiNghhh](/KarAnSiNghhh) Anytime, my friend! Good luck! Consistency is key. Many questions will be difficult at first, but if you stay consistent and do at least one problem a day, you will improve drastically. Don\\'t get discouraged along the way if you are unable to solve a lot of problems. It is very hard to find the solution to many of these questions without having already seen a similar solution in the past. It\\'s all about immersion and exposure. The more problems you see and the more solutions you uncover, the easier all other problems become! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@NoMansGhost](/NoMansGhost)  thanks bro "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "I also recommend using a spaced repetition app like AnkiApp and saving a screenshot of the question on a digital flashcard, writing the answer out in your own words on the back of the flashcard + a screenshot of the solution, and then continually testing yourself daily, so you don\\'t forget the solution and slowly incorporate it into your programmer tool belt."
                    },
                    {
                        "username": "psionl0",
                        "content": "That is a good strategy but an important aspect is follow up. Once you have got the answer up and running, click on the Similar Questions tab and see if you can solve some of them without looking up hints or videos."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-)**\\n- Create a mapping: Initialize a data structure, such as a list or dictionary, that maps each digit to the corresponding letters on the phone keypad. For example, in the case of a standard telephone keypad, the digit \\'2\\' maps to the letters \\'a\\', \\'b\\', and \\'c\\', the digit \\'3\\' maps to \\'d\\', \\'e\\', and \\'f\\', and so on.\\n\\n- Initialize a list to store the results: Create an empty list to store the final letter combinations.\\n\\n- Implement a backtracking function: This function will be responsible for generating all possible combinations. It should take the following parameters:\\n\\n  - digits: The original input string of digits.\\n  - currentIndex: The index indicating which digit we are processing from the digits string.\\n  - currentCombination: A string representing the current combination being built.\\n- Base case: If the length of currentCombination is equal to the length of the digits string, it means we have formed a complete combination. So, add the current combination to the results list and return from the current recursive call.\\n\\n- Recursive case: For the current digit at currentIndex, iterate through the characters corresponding to that digit from the mapping created in step 1. For each character, append it to the currentCombination, and then make a recursive call to the backtracking function with the next index (currentIndex + 1). This step allows us to explore all possible combinations that can be formed by considering different characters for each digit.\\n\\n- Backtrack: After the recursive call, remove the last character from the currentCombination to explore other possibilities. This is essential for backtracking and exploring different combinations.\\n\\n- The backtracking function continues recursively until all possible combinations are generated.\\n\\n- Finally, after the backtracking function completes, the results list will contain all the valid letter combinations that can be formed from the given input string of digits."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " Thank you [@KarAnSiNghhh](/KarAnSiNghhh) ! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) thank u so much for helping a noob like me \\uD83D\\uDE0C"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***here is the code link for reference:-)***\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/2816695/easiest-solution-java-only-lists/"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Indeed a PnC  week"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this is the first backtracking that I can solve all on my own within a reasonable timeframe! "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "perfect backtrack week : )"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s a backracking week then**"
                    },
                    {
                        "username": "Linpham21",
                        "content": "LC trying to tell me something with a backtracking week"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "Time complexity : for worst case scenario max length of characters is 4, and if N is digits.Legnth then, it is,\n\nTC : approx. O(4^N), if digits length is greater than 10 it TC increases exponentially, but for this problem digits length is max 4.\n\nSay N = 4, \n\nS4 = 4 + 4^2 + 4 ^3 + 4^ 4\n\nS4 = 4(1+4 +4^2+4^3)\n\nSay N =3,\nthen,\nS3 = 4 + 4^2 + 4^3\n\nS4 = 4 * S3\n\nS4 = S3 + 4^4\nS4 = (S3/4) + 4^4\n\n3S4 = 4^5\n\nTherefore, for any digits.Length = n, we can have,\n\nTime complexity = (4^(n+1))/3"
                    },
                    {
                        "username": "pradeepmaheshwaram",
                        "content": "what is the complexity of the code? someone reply\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "should be 3^n or at worst case 4^n (for 7 and 9)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is the question where backtracking finally clicked for me (I spent a long time on this on and off). Suddenly I can do permutations and combinations with my eyes closed. Since I have already done the last 3 problems, I guess that I will have a relatively easy week."
                    }
                ]
            },
            {
                "id": 1997915,
                "content": [
                    {
                        "username": "KarAnSiNghhh",
                        "content": "i just wanted to ask the top coders as i am a begineer that i am doing right i just think for the approach for 40 mins and then i look to the solution or yt videos for the ques am i doing right and please provide me any tips it would be very helpful "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "[@KarAnSiNghhh](/KarAnSiNghhh) Anytime, my friend! Good luck! Consistency is key. Many questions will be difficult at first, but if you stay consistent and do at least one problem a day, you will improve drastically. Don\\'t get discouraged along the way if you are unable to solve a lot of problems. It is very hard to find the solution to many of these questions without having already seen a similar solution in the past. It\\'s all about immersion and exposure. The more problems you see and the more solutions you uncover, the easier all other problems become! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@NoMansGhost](/NoMansGhost)  thanks bro "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "I also recommend using a spaced repetition app like AnkiApp and saving a screenshot of the question on a digital flashcard, writing the answer out in your own words on the back of the flashcard + a screenshot of the solution, and then continually testing yourself daily, so you don\\'t forget the solution and slowly incorporate it into your programmer tool belt."
                    },
                    {
                        "username": "psionl0",
                        "content": "That is a good strategy but an important aspect is follow up. Once you have got the answer up and running, click on the Similar Questions tab and see if you can solve some of them without looking up hints or videos."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-)**\\n- Create a mapping: Initialize a data structure, such as a list or dictionary, that maps each digit to the corresponding letters on the phone keypad. For example, in the case of a standard telephone keypad, the digit \\'2\\' maps to the letters \\'a\\', \\'b\\', and \\'c\\', the digit \\'3\\' maps to \\'d\\', \\'e\\', and \\'f\\', and so on.\\n\\n- Initialize a list to store the results: Create an empty list to store the final letter combinations.\\n\\n- Implement a backtracking function: This function will be responsible for generating all possible combinations. It should take the following parameters:\\n\\n  - digits: The original input string of digits.\\n  - currentIndex: The index indicating which digit we are processing from the digits string.\\n  - currentCombination: A string representing the current combination being built.\\n- Base case: If the length of currentCombination is equal to the length of the digits string, it means we have formed a complete combination. So, add the current combination to the results list and return from the current recursive call.\\n\\n- Recursive case: For the current digit at currentIndex, iterate through the characters corresponding to that digit from the mapping created in step 1. For each character, append it to the currentCombination, and then make a recursive call to the backtracking function with the next index (currentIndex + 1). This step allows us to explore all possible combinations that can be formed by considering different characters for each digit.\\n\\n- Backtrack: After the recursive call, remove the last character from the currentCombination to explore other possibilities. This is essential for backtracking and exploring different combinations.\\n\\n- The backtracking function continues recursively until all possible combinations are generated.\\n\\n- Finally, after the backtracking function completes, the results list will contain all the valid letter combinations that can be formed from the given input string of digits."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " Thank you [@KarAnSiNghhh](/KarAnSiNghhh) ! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) thank u so much for helping a noob like me \\uD83D\\uDE0C"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***here is the code link for reference:-)***\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/2816695/easiest-solution-java-only-lists/"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Indeed a PnC  week"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this is the first backtracking that I can solve all on my own within a reasonable timeframe! "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "perfect backtrack week : )"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s a backracking week then**"
                    },
                    {
                        "username": "Linpham21",
                        "content": "LC trying to tell me something with a backtracking week"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "Time complexity : for worst case scenario max length of characters is 4, and if N is digits.Legnth then, it is,\n\nTC : approx. O(4^N), if digits length is greater than 10 it TC increases exponentially, but for this problem digits length is max 4.\n\nSay N = 4, \n\nS4 = 4 + 4^2 + 4 ^3 + 4^ 4\n\nS4 = 4(1+4 +4^2+4^3)\n\nSay N =3,\nthen,\nS3 = 4 + 4^2 + 4^3\n\nS4 = 4 * S3\n\nS4 = S3 + 4^4\nS4 = (S3/4) + 4^4\n\n3S4 = 4^5\n\nTherefore, for any digits.Length = n, we can have,\n\nTime complexity = (4^(n+1))/3"
                    },
                    {
                        "username": "pradeepmaheshwaram",
                        "content": "what is the complexity of the code? someone reply\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "should be 3^n or at worst case 4^n (for 7 and 9)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is the question where backtracking finally clicked for me (I spent a long time on this on and off). Suddenly I can do permutations and combinations with my eyes closed. Since I have already done the last 3 problems, I guess that I will have a relatively easy week."
                    }
                ]
            },
            {
                "id": 1997898,
                "content": [
                    {
                        "username": "KarAnSiNghhh",
                        "content": "i just wanted to ask the top coders as i am a begineer that i am doing right i just think for the approach for 40 mins and then i look to the solution or yt videos for the ques am i doing right and please provide me any tips it would be very helpful "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "[@KarAnSiNghhh](/KarAnSiNghhh) Anytime, my friend! Good luck! Consistency is key. Many questions will be difficult at first, but if you stay consistent and do at least one problem a day, you will improve drastically. Don\\'t get discouraged along the way if you are unable to solve a lot of problems. It is very hard to find the solution to many of these questions without having already seen a similar solution in the past. It\\'s all about immersion and exposure. The more problems you see and the more solutions you uncover, the easier all other problems become! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@NoMansGhost](/NoMansGhost)  thanks bro "
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "I also recommend using a spaced repetition app like AnkiApp and saving a screenshot of the question on a digital flashcard, writing the answer out in your own words on the back of the flashcard + a screenshot of the solution, and then continually testing yourself daily, so you don\\'t forget the solution and slowly incorporate it into your programmer tool belt."
                    },
                    {
                        "username": "psionl0",
                        "content": "That is a good strategy but an important aspect is follow up. Once you have got the answer up and running, click on the Similar Questions tab and see if you can solve some of them without looking up hints or videos."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-)**\\n- Create a mapping: Initialize a data structure, such as a list or dictionary, that maps each digit to the corresponding letters on the phone keypad. For example, in the case of a standard telephone keypad, the digit \\'2\\' maps to the letters \\'a\\', \\'b\\', and \\'c\\', the digit \\'3\\' maps to \\'d\\', \\'e\\', and \\'f\\', and so on.\\n\\n- Initialize a list to store the results: Create an empty list to store the final letter combinations.\\n\\n- Implement a backtracking function: This function will be responsible for generating all possible combinations. It should take the following parameters:\\n\\n  - digits: The original input string of digits.\\n  - currentIndex: The index indicating which digit we are processing from the digits string.\\n  - currentCombination: A string representing the current combination being built.\\n- Base case: If the length of currentCombination is equal to the length of the digits string, it means we have formed a complete combination. So, add the current combination to the results list and return from the current recursive call.\\n\\n- Recursive case: For the current digit at currentIndex, iterate through the characters corresponding to that digit from the mapping created in step 1. For each character, append it to the currentCombination, and then make a recursive call to the backtracking function with the next index (currentIndex + 1). This step allows us to explore all possible combinations that can be formed by considering different characters for each digit.\\n\\n- Backtrack: After the recursive call, remove the last character from the currentCombination to explore other possibilities. This is essential for backtracking and exploring different combinations.\\n\\n- The backtracking function continues recursively until all possible combinations are generated.\\n\\n- Finally, after the backtracking function completes, the results list will contain all the valid letter combinations that can be formed from the given input string of digits."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " Thank you [@KarAnSiNghhh](/KarAnSiNghhh) ! "
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) thank u so much for helping a noob like me \\uD83D\\uDE0C"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***here is the code link for reference:-)***\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/2816695/easiest-solution-java-only-lists/"
                    },
                    {
                        "username": "Sameeksha1304",
                        "content": "Indeed a PnC  week"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this is the first backtracking that I can solve all on my own within a reasonable timeframe! "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "perfect backtrack week : )"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**it\\'s a backracking week then**"
                    },
                    {
                        "username": "Linpham21",
                        "content": "LC trying to tell me something with a backtracking week"
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "Time complexity : for worst case scenario max length of characters is 4, and if N is digits.Legnth then, it is,\n\nTC : approx. O(4^N), if digits length is greater than 10 it TC increases exponentially, but for this problem digits length is max 4.\n\nSay N = 4, \n\nS4 = 4 + 4^2 + 4 ^3 + 4^ 4\n\nS4 = 4(1+4 +4^2+4^3)\n\nSay N =3,\nthen,\nS3 = 4 + 4^2 + 4^3\n\nS4 = 4 * S3\n\nS4 = S3 + 4^4\nS4 = (S3/4) + 4^4\n\n3S4 = 4^5\n\nTherefore, for any digits.Length = n, we can have,\n\nTime complexity = (4^(n+1))/3"
                    },
                    {
                        "username": "pradeepmaheshwaram",
                        "content": "what is the complexity of the code? someone reply\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "should be 3^n or at worst case 4^n (for 7 and 9)"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is the question where backtracking finally clicked for me (I spent a long time on this on and off). Suddenly I can do permutations and combinations with my eyes closed. Since I have already done the last 3 problems, I guess that I will have a relatively easy week."
                    }
                ]
            },
            {
                "id": 1997861,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Create a data structure that maps 2-9 to the corresponding letter-sets. Try using recursion to build the combinations. End point can be when you've gone through all the indexes of digits for the current combination / string."
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "Just make sure not to add void/empty strings(\"\") in the vector of strings / List of strings.\\nHence for this keep a CHECK in the Base Condition of Recursion."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back-to-back backtracking "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Curious, would one also consider this to be a combinatorics problem?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this question is tedious... not difficult just annoying. if i got asked this in an interview i would walk out  "
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why the question bothers you. This looks like a pretty straightforward question to me. Bread and butter programming?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "digits =\\n\"\"\\nOutput\\n[\"\"]\\nExpected\\n[] if someone faced the same  problem can u please guide me through.\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  that i got solved\\n ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        } this was the mistake \\ni got like 17 correct test cases but \\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        }\\n        String p = \"\";\\n        return helper(p, digits);\\n    }\\n\\n    public static List<String> helper(String p, String digits) {\\n        if (digits.isEmpty()) {\\n            ArrayList<String> list = new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n        ArrayList<String> list = new ArrayList<>();\\n        int digit = digits.charAt(0) - \\'0\\';\\n        if (digit >= 7) {\\n            for (int i = (digit - 2) * 3; i <= (digit - 1) * 3 ; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        } else {\\n            for (int i = (digit - 2) * 3; i < (digit - 1) * 3; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "howuseeit",
                        "content": "looks like it wants an empty list instead of a list containing a single empty string"
                    },
                    {
                        "username": "norainsingh",
                        "content": "\"999\" failing for anyone else?"
                    },
                    {
                        "username": "Harishdhu",
                        "content": "```hi```"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "can anyone help me why I am getting run time error \\npublic:\\nvector<string> keys = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    vector<string> ans;\\n    \\n    void helper(string a,string temp,int n,int i){\\n        if(i==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int j=0;j<keys[a[i]].size();j++){\\n            temp.push_back(keys[a[i]][j]);\\n            helper(a,temp,n,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    //Function to find list of all words possible by pressing given numbers.\\n    vector<string> letterCombinations(string digits)\\n    {\\n        //Your code here\\n        int N = digits.length();\\n        helper(digits,\"\",N,0);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "myself, you forgot to convert the char type digits to int , you are welcome "
                    },
                    {
                        "username": "runspoon",
                        "content": "why is the time complexity o(n*4^n) instead of o(4^n)? thanks!"
                    }
                ]
            },
            {
                "id": 1997850,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Create a data structure that maps 2-9 to the corresponding letter-sets. Try using recursion to build the combinations. End point can be when you've gone through all the indexes of digits for the current combination / string."
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "Just make sure not to add void/empty strings(\"\") in the vector of strings / List of strings.\\nHence for this keep a CHECK in the Base Condition of Recursion."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back-to-back backtracking "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Curious, would one also consider this to be a combinatorics problem?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this question is tedious... not difficult just annoying. if i got asked this in an interview i would walk out  "
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why the question bothers you. This looks like a pretty straightforward question to me. Bread and butter programming?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "digits =\\n\"\"\\nOutput\\n[\"\"]\\nExpected\\n[] if someone faced the same  problem can u please guide me through.\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  that i got solved\\n ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        } this was the mistake \\ni got like 17 correct test cases but \\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        }\\n        String p = \"\";\\n        return helper(p, digits);\\n    }\\n\\n    public static List<String> helper(String p, String digits) {\\n        if (digits.isEmpty()) {\\n            ArrayList<String> list = new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n        ArrayList<String> list = new ArrayList<>();\\n        int digit = digits.charAt(0) - \\'0\\';\\n        if (digit >= 7) {\\n            for (int i = (digit - 2) * 3; i <= (digit - 1) * 3 ; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        } else {\\n            for (int i = (digit - 2) * 3; i < (digit - 1) * 3; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "howuseeit",
                        "content": "looks like it wants an empty list instead of a list containing a single empty string"
                    },
                    {
                        "username": "norainsingh",
                        "content": "\"999\" failing for anyone else?"
                    },
                    {
                        "username": "Harishdhu",
                        "content": "```hi```"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "can anyone help me why I am getting run time error \\npublic:\\nvector<string> keys = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    vector<string> ans;\\n    \\n    void helper(string a,string temp,int n,int i){\\n        if(i==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int j=0;j<keys[a[i]].size();j++){\\n            temp.push_back(keys[a[i]][j]);\\n            helper(a,temp,n,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    //Function to find list of all words possible by pressing given numbers.\\n    vector<string> letterCombinations(string digits)\\n    {\\n        //Your code here\\n        int N = digits.length();\\n        helper(digits,\"\",N,0);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "myself, you forgot to convert the char type digits to int , you are welcome "
                    },
                    {
                        "username": "runspoon",
                        "content": "why is the time complexity o(n*4^n) instead of o(4^n)? thanks!"
                    }
                ]
            },
            {
                "id": 1997847,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Create a data structure that maps 2-9 to the corresponding letter-sets. Try using recursion to build the combinations. End point can be when you've gone through all the indexes of digits for the current combination / string."
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "Just make sure not to add void/empty strings(\"\") in the vector of strings / List of strings.\\nHence for this keep a CHECK in the Base Condition of Recursion."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back-to-back backtracking "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Curious, would one also consider this to be a combinatorics problem?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this question is tedious... not difficult just annoying. if i got asked this in an interview i would walk out  "
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why the question bothers you. This looks like a pretty straightforward question to me. Bread and butter programming?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "digits =\\n\"\"\\nOutput\\n[\"\"]\\nExpected\\n[] if someone faced the same  problem can u please guide me through.\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  that i got solved\\n ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        } this was the mistake \\ni got like 17 correct test cases but \\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        }\\n        String p = \"\";\\n        return helper(p, digits);\\n    }\\n\\n    public static List<String> helper(String p, String digits) {\\n        if (digits.isEmpty()) {\\n            ArrayList<String> list = new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n        ArrayList<String> list = new ArrayList<>();\\n        int digit = digits.charAt(0) - \\'0\\';\\n        if (digit >= 7) {\\n            for (int i = (digit - 2) * 3; i <= (digit - 1) * 3 ; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        } else {\\n            for (int i = (digit - 2) * 3; i < (digit - 1) * 3; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "howuseeit",
                        "content": "looks like it wants an empty list instead of a list containing a single empty string"
                    },
                    {
                        "username": "norainsingh",
                        "content": "\"999\" failing for anyone else?"
                    },
                    {
                        "username": "Harishdhu",
                        "content": "```hi```"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "can anyone help me why I am getting run time error \\npublic:\\nvector<string> keys = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    vector<string> ans;\\n    \\n    void helper(string a,string temp,int n,int i){\\n        if(i==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int j=0;j<keys[a[i]].size();j++){\\n            temp.push_back(keys[a[i]][j]);\\n            helper(a,temp,n,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    //Function to find list of all words possible by pressing given numbers.\\n    vector<string> letterCombinations(string digits)\\n    {\\n        //Your code here\\n        int N = digits.length();\\n        helper(digits,\"\",N,0);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "myself, you forgot to convert the char type digits to int , you are welcome "
                    },
                    {
                        "username": "runspoon",
                        "content": "why is the time complexity o(n*4^n) instead of o(4^n)? thanks!"
                    }
                ]
            },
            {
                "id": 1997840,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Create a data structure that maps 2-9 to the corresponding letter-sets. Try using recursion to build the combinations. End point can be when you've gone through all the indexes of digits for the current combination / string."
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "Just make sure not to add void/empty strings(\"\") in the vector of strings / List of strings.\\nHence for this keep a CHECK in the Base Condition of Recursion."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back-to-back backtracking "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Curious, would one also consider this to be a combinatorics problem?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this question is tedious... not difficult just annoying. if i got asked this in an interview i would walk out  "
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why the question bothers you. This looks like a pretty straightforward question to me. Bread and butter programming?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "digits =\\n\"\"\\nOutput\\n[\"\"]\\nExpected\\n[] if someone faced the same  problem can u please guide me through.\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  that i got solved\\n ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        } this was the mistake \\ni got like 17 correct test cases but \\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        }\\n        String p = \"\";\\n        return helper(p, digits);\\n    }\\n\\n    public static List<String> helper(String p, String digits) {\\n        if (digits.isEmpty()) {\\n            ArrayList<String> list = new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n        ArrayList<String> list = new ArrayList<>();\\n        int digit = digits.charAt(0) - \\'0\\';\\n        if (digit >= 7) {\\n            for (int i = (digit - 2) * 3; i <= (digit - 1) * 3 ; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        } else {\\n            for (int i = (digit - 2) * 3; i < (digit - 1) * 3; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "howuseeit",
                        "content": "looks like it wants an empty list instead of a list containing a single empty string"
                    },
                    {
                        "username": "norainsingh",
                        "content": "\"999\" failing for anyone else?"
                    },
                    {
                        "username": "Harishdhu",
                        "content": "```hi```"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "can anyone help me why I am getting run time error \\npublic:\\nvector<string> keys = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    vector<string> ans;\\n    \\n    void helper(string a,string temp,int n,int i){\\n        if(i==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int j=0;j<keys[a[i]].size();j++){\\n            temp.push_back(keys[a[i]][j]);\\n            helper(a,temp,n,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    //Function to find list of all words possible by pressing given numbers.\\n    vector<string> letterCombinations(string digits)\\n    {\\n        //Your code here\\n        int N = digits.length();\\n        helper(digits,\"\",N,0);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "myself, you forgot to convert the char type digits to int , you are welcome "
                    },
                    {
                        "username": "runspoon",
                        "content": "why is the time complexity o(n*4^n) instead of o(4^n)? thanks!"
                    }
                ]
            },
            {
                "id": 1997838,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Create a data structure that maps 2-9 to the corresponding letter-sets. Try using recursion to build the combinations. End point can be when you've gone through all the indexes of digits for the current combination / string."
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "Just make sure not to add void/empty strings(\"\") in the vector of strings / List of strings.\\nHence for this keep a CHECK in the Base Condition of Recursion."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back-to-back backtracking "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Curious, would one also consider this to be a combinatorics problem?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this question is tedious... not difficult just annoying. if i got asked this in an interview i would walk out  "
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why the question bothers you. This looks like a pretty straightforward question to me. Bread and butter programming?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "digits =\\n\"\"\\nOutput\\n[\"\"]\\nExpected\\n[] if someone faced the same  problem can u please guide me through.\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  that i got solved\\n ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        } this was the mistake \\ni got like 17 correct test cases but \\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        }\\n        String p = \"\";\\n        return helper(p, digits);\\n    }\\n\\n    public static List<String> helper(String p, String digits) {\\n        if (digits.isEmpty()) {\\n            ArrayList<String> list = new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n        ArrayList<String> list = new ArrayList<>();\\n        int digit = digits.charAt(0) - \\'0\\';\\n        if (digit >= 7) {\\n            for (int i = (digit - 2) * 3; i <= (digit - 1) * 3 ; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        } else {\\n            for (int i = (digit - 2) * 3; i < (digit - 1) * 3; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "howuseeit",
                        "content": "looks like it wants an empty list instead of a list containing a single empty string"
                    },
                    {
                        "username": "norainsingh",
                        "content": "\"999\" failing for anyone else?"
                    },
                    {
                        "username": "Harishdhu",
                        "content": "```hi```"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "can anyone help me why I am getting run time error \\npublic:\\nvector<string> keys = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    vector<string> ans;\\n    \\n    void helper(string a,string temp,int n,int i){\\n        if(i==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int j=0;j<keys[a[i]].size();j++){\\n            temp.push_back(keys[a[i]][j]);\\n            helper(a,temp,n,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    //Function to find list of all words possible by pressing given numbers.\\n    vector<string> letterCombinations(string digits)\\n    {\\n        //Your code here\\n        int N = digits.length();\\n        helper(digits,\"\",N,0);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "myself, you forgot to convert the char type digits to int , you are welcome "
                    },
                    {
                        "username": "runspoon",
                        "content": "why is the time complexity o(n*4^n) instead of o(4^n)? thanks!"
                    }
                ]
            },
            {
                "id": 1994902,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Create a data structure that maps 2-9 to the corresponding letter-sets. Try using recursion to build the combinations. End point can be when you've gone through all the indexes of digits for the current combination / string."
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "Just make sure not to add void/empty strings(\"\") in the vector of strings / List of strings.\\nHence for this keep a CHECK in the Base Condition of Recursion."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back-to-back backtracking "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Curious, would one also consider this to be a combinatorics problem?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this question is tedious... not difficult just annoying. if i got asked this in an interview i would walk out  "
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why the question bothers you. This looks like a pretty straightforward question to me. Bread and butter programming?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "digits =\\n\"\"\\nOutput\\n[\"\"]\\nExpected\\n[] if someone faced the same  problem can u please guide me through.\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  that i got solved\\n ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        } this was the mistake \\ni got like 17 correct test cases but \\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        }\\n        String p = \"\";\\n        return helper(p, digits);\\n    }\\n\\n    public static List<String> helper(String p, String digits) {\\n        if (digits.isEmpty()) {\\n            ArrayList<String> list = new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n        ArrayList<String> list = new ArrayList<>();\\n        int digit = digits.charAt(0) - \\'0\\';\\n        if (digit >= 7) {\\n            for (int i = (digit - 2) * 3; i <= (digit - 1) * 3 ; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        } else {\\n            for (int i = (digit - 2) * 3; i < (digit - 1) * 3; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "howuseeit",
                        "content": "looks like it wants an empty list instead of a list containing a single empty string"
                    },
                    {
                        "username": "norainsingh",
                        "content": "\"999\" failing for anyone else?"
                    },
                    {
                        "username": "Harishdhu",
                        "content": "```hi```"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "can anyone help me why I am getting run time error \\npublic:\\nvector<string> keys = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    vector<string> ans;\\n    \\n    void helper(string a,string temp,int n,int i){\\n        if(i==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int j=0;j<keys[a[i]].size();j++){\\n            temp.push_back(keys[a[i]][j]);\\n            helper(a,temp,n,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    //Function to find list of all words possible by pressing given numbers.\\n    vector<string> letterCombinations(string digits)\\n    {\\n        //Your code here\\n        int N = digits.length();\\n        helper(digits,\"\",N,0);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "myself, you forgot to convert the char type digits to int , you are welcome "
                    },
                    {
                        "username": "runspoon",
                        "content": "why is the time complexity o(n*4^n) instead of o(4^n)? thanks!"
                    }
                ]
            },
            {
                "id": 1983503,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Create a data structure that maps 2-9 to the corresponding letter-sets. Try using recursion to build the combinations. End point can be when you've gone through all the indexes of digits for the current combination / string."
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "Just make sure not to add void/empty strings(\"\") in the vector of strings / List of strings.\\nHence for this keep a CHECK in the Base Condition of Recursion."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back-to-back backtracking "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Curious, would one also consider this to be a combinatorics problem?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this question is tedious... not difficult just annoying. if i got asked this in an interview i would walk out  "
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why the question bothers you. This looks like a pretty straightforward question to me. Bread and butter programming?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "digits =\\n\"\"\\nOutput\\n[\"\"]\\nExpected\\n[] if someone faced the same  problem can u please guide me through.\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  that i got solved\\n ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        } this was the mistake \\ni got like 17 correct test cases but \\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        }\\n        String p = \"\";\\n        return helper(p, digits);\\n    }\\n\\n    public static List<String> helper(String p, String digits) {\\n        if (digits.isEmpty()) {\\n            ArrayList<String> list = new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n        ArrayList<String> list = new ArrayList<>();\\n        int digit = digits.charAt(0) - \\'0\\';\\n        if (digit >= 7) {\\n            for (int i = (digit - 2) * 3; i <= (digit - 1) * 3 ; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        } else {\\n            for (int i = (digit - 2) * 3; i < (digit - 1) * 3; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "howuseeit",
                        "content": "looks like it wants an empty list instead of a list containing a single empty string"
                    },
                    {
                        "username": "norainsingh",
                        "content": "\"999\" failing for anyone else?"
                    },
                    {
                        "username": "Harishdhu",
                        "content": "```hi```"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "can anyone help me why I am getting run time error \\npublic:\\nvector<string> keys = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    vector<string> ans;\\n    \\n    void helper(string a,string temp,int n,int i){\\n        if(i==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int j=0;j<keys[a[i]].size();j++){\\n            temp.push_back(keys[a[i]][j]);\\n            helper(a,temp,n,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    //Function to find list of all words possible by pressing given numbers.\\n    vector<string> letterCombinations(string digits)\\n    {\\n        //Your code here\\n        int N = digits.length();\\n        helper(digits,\"\",N,0);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "myself, you forgot to convert the char type digits to int , you are welcome "
                    },
                    {
                        "username": "runspoon",
                        "content": "why is the time complexity o(n*4^n) instead of o(4^n)? thanks!"
                    }
                ]
            },
            {
                "id": 1975621,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Create a data structure that maps 2-9 to the corresponding letter-sets. Try using recursion to build the combinations. End point can be when you've gone through all the indexes of digits for the current combination / string."
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "Just make sure not to add void/empty strings(\"\") in the vector of strings / List of strings.\\nHence for this keep a CHECK in the Base Condition of Recursion."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back-to-back backtracking "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Curious, would one also consider this to be a combinatorics problem?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this question is tedious... not difficult just annoying. if i got asked this in an interview i would walk out  "
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why the question bothers you. This looks like a pretty straightforward question to me. Bread and butter programming?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "digits =\\n\"\"\\nOutput\\n[\"\"]\\nExpected\\n[] if someone faced the same  problem can u please guide me through.\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  that i got solved\\n ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        } this was the mistake \\ni got like 17 correct test cases but \\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        }\\n        String p = \"\";\\n        return helper(p, digits);\\n    }\\n\\n    public static List<String> helper(String p, String digits) {\\n        if (digits.isEmpty()) {\\n            ArrayList<String> list = new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n        ArrayList<String> list = new ArrayList<>();\\n        int digit = digits.charAt(0) - \\'0\\';\\n        if (digit >= 7) {\\n            for (int i = (digit - 2) * 3; i <= (digit - 1) * 3 ; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        } else {\\n            for (int i = (digit - 2) * 3; i < (digit - 1) * 3; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "howuseeit",
                        "content": "looks like it wants an empty list instead of a list containing a single empty string"
                    },
                    {
                        "username": "norainsingh",
                        "content": "\"999\" failing for anyone else?"
                    },
                    {
                        "username": "Harishdhu",
                        "content": "```hi```"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "can anyone help me why I am getting run time error \\npublic:\\nvector<string> keys = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    vector<string> ans;\\n    \\n    void helper(string a,string temp,int n,int i){\\n        if(i==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int j=0;j<keys[a[i]].size();j++){\\n            temp.push_back(keys[a[i]][j]);\\n            helper(a,temp,n,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    //Function to find list of all words possible by pressing given numbers.\\n    vector<string> letterCombinations(string digits)\\n    {\\n        //Your code here\\n        int N = digits.length();\\n        helper(digits,\"\",N,0);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "myself, you forgot to convert the char type digits to int , you are welcome "
                    },
                    {
                        "username": "runspoon",
                        "content": "why is the time complexity o(n*4^n) instead of o(4^n)? thanks!"
                    }
                ]
            },
            {
                "id": 1970978,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Create a data structure that maps 2-9 to the corresponding letter-sets. Try using recursion to build the combinations. End point can be when you've gone through all the indexes of digits for the current combination / string."
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "Just make sure not to add void/empty strings(\"\") in the vector of strings / List of strings.\\nHence for this keep a CHECK in the Base Condition of Recursion."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back-to-back backtracking "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Curious, would one also consider this to be a combinatorics problem?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this question is tedious... not difficult just annoying. if i got asked this in an interview i would walk out  "
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why the question bothers you. This looks like a pretty straightforward question to me. Bread and butter programming?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "digits =\\n\"\"\\nOutput\\n[\"\"]\\nExpected\\n[] if someone faced the same  problem can u please guide me through.\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  that i got solved\\n ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        } this was the mistake \\ni got like 17 correct test cases but \\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        }\\n        String p = \"\";\\n        return helper(p, digits);\\n    }\\n\\n    public static List<String> helper(String p, String digits) {\\n        if (digits.isEmpty()) {\\n            ArrayList<String> list = new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n        ArrayList<String> list = new ArrayList<>();\\n        int digit = digits.charAt(0) - \\'0\\';\\n        if (digit >= 7) {\\n            for (int i = (digit - 2) * 3; i <= (digit - 1) * 3 ; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        } else {\\n            for (int i = (digit - 2) * 3; i < (digit - 1) * 3; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "howuseeit",
                        "content": "looks like it wants an empty list instead of a list containing a single empty string"
                    },
                    {
                        "username": "norainsingh",
                        "content": "\"999\" failing for anyone else?"
                    },
                    {
                        "username": "Harishdhu",
                        "content": "```hi```"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "can anyone help me why I am getting run time error \\npublic:\\nvector<string> keys = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    vector<string> ans;\\n    \\n    void helper(string a,string temp,int n,int i){\\n        if(i==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int j=0;j<keys[a[i]].size();j++){\\n            temp.push_back(keys[a[i]][j]);\\n            helper(a,temp,n,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    //Function to find list of all words possible by pressing given numbers.\\n    vector<string> letterCombinations(string digits)\\n    {\\n        //Your code here\\n        int N = digits.length();\\n        helper(digits,\"\",N,0);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "myself, you forgot to convert the char type digits to int , you are welcome "
                    },
                    {
                        "username": "runspoon",
                        "content": "why is the time complexity o(n*4^n) instead of o(4^n)? thanks!"
                    }
                ]
            },
            {
                "id": 1969918,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "Create a data structure that maps 2-9 to the corresponding letter-sets. Try using recursion to build the combinations. End point can be when you've gone through all the indexes of digits for the current combination / string."
                    },
                    {
                        "username": "Sharma1Aaryan",
                        "content": "Just make sure not to add void/empty strings(\"\") in the vector of strings / List of strings.\\nHence for this keep a CHECK in the Base Condition of Recursion."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back-to-back backtracking "
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Curious, would one also consider this to be a combinatorics problem?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this question is tedious... not difficult just annoying. if i got asked this in an interview i would walk out  "
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why the question bothers you. This looks like a pretty straightforward question to me. Bread and butter programming?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "digits =\\n\"\"\\nOutput\\n[\"\"]\\nExpected\\n[] if someone faced the same  problem can u please guide me through.\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "[@olliebakhtiari](/olliebakhtiari)  that i got solved\\n ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        } this was the mistake \\ni got like 17 correct test cases but \\nclass Solution {\\n    public List<String> letterCombinations(String digits) {\\n        ArrayList<String> land = new ArrayList<>();\\n        if (digits == null || digits.isEmpty()) {\\n            return land;\\n        }\\n        String p = \"\";\\n        return helper(p, digits);\\n    }\\n\\n    public static List<String> helper(String p, String digits) {\\n        if (digits.isEmpty()) {\\n            ArrayList<String> list = new ArrayList<>();\\n            list.add(p);\\n            return list;\\n        }\\n        ArrayList<String> list = new ArrayList<>();\\n        int digit = digits.charAt(0) - \\'0\\';\\n        if (digit >= 7) {\\n            for (int i = (digit - 2) * 3; i <= (digit - 1) * 3 ; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        } else {\\n            for (int i = (digit - 2) * 3; i < (digit - 1) * 3; i++) {\\n                char ch = (char) (\\'a\\' + i);\\n                list.addAll(helper(p + ch, digits.substring(1)));\\n            }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "howuseeit",
                        "content": "looks like it wants an empty list instead of a list containing a single empty string"
                    },
                    {
                        "username": "norainsingh",
                        "content": "\"999\" failing for anyone else?"
                    },
                    {
                        "username": "Harishdhu",
                        "content": "```hi```"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "can anyone help me why I am getting run time error \\npublic:\\nvector<string> keys = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    vector<string> ans;\\n    \\n    void helper(string a,string temp,int n,int i){\\n        if(i==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int j=0;j<keys[a[i]].size();j++){\\n            temp.push_back(keys[a[i]][j]);\\n            helper(a,temp,n,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    //Function to find list of all words possible by pressing given numbers.\\n    vector<string> letterCombinations(string digits)\\n    {\\n        //Your code here\\n        int N = digits.length();\\n        helper(digits,\"\",N,0);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "manishchikoti",
                        "content": "myself, you forgot to convert the char type digits to int , you are welcome "
                    },
                    {
                        "username": "runspoon",
                        "content": "why is the time complexity o(n*4^n) instead of o(4^n)? thanks!"
                    }
                ]
            },
            {
                "id": 1956518,
                "content": [
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};"
                    },
                    {
                        "username": "samyck",
                        "content": "if(digits[index] == '2'){\n            alp= \"abc\";\n        }\n        else if(digits[index] == '3'){\n            alp= \"def\";\n        }\n        else if(digits[index] == '4'){\n            alp= \"ghi\";\n        }\n        else if(digits[index] == '5'){\n            alp= \"jkl\";\n        }\n        else if(digits[index] == '6'){\n            alp= \"mno\";\n        }\n        else if(digits[index] == '7'){\n            alp= \"pqrs\";\n        }\n        else if(digits[index] == '8'){\n            alp= \"tuv\";\n        }\n        else if(digits[index] == '9'){\n            alp= \"wxyz\";\n        }"
                    },
                    {
                        "username": "amirovjasur17041996",
                        "content": "var dic: [String: [String]] = [\\n    \"2\": [\"a\",\"b\",\"c\"],\\n    \"3\": [\"d\",\"e\",\"f\"],\\n    \"4\": [\"g\",\"h\",\"i\"],\\n    \"5\": [\"j\",\"k\",\"l\"],\\n    \"6\": [\"m\",\"n\",\"o\"],\\n    \"7\": [\"p\",\"q\",\"r\",\"s\"],\\n    \"8\": [\"t\",\"u\",\"v\"],\\n    \"9\": [\"w\",\"x\",\"y\",\"z\"]\\n]"
                    },
                    {
                        "username": "phamkhien2309",
                        "content": "           $map = [\\n                2 => [\\'a\\', \\'b\\', \\'c\\'],\\n                3 => [\\'d\\', \\'e\\', \\'f\\'],\\n                4 => [\\'g\\', \\'h\\', \\'i\\'],\\n                5 => [\\'j\\', \\'k\\', \\'l\\'],\\n                6 => [\\'m\\', \\'n\\', \\'o\\'],\\n                7 => [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n                8 => [\\'t\\', \\'u\\', \\'v\\'],\\n                9 => [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n            ];"
                    },
                    {
                        "username": "psing9968",
                        "content": "This seems to be only recursion problem. Can anyone please help how backtracking is present in this ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "For each digit, you need to select a letter then encode the rest of the string. After you have finished encoding, you return to the digit in question (the backtracking step) and select the next letter. Rinse and repeat."
                    },
                    {
                        "username": "Blatogh",
                        "content": "Time complexity: O(3^n + 4^m), n numbers with 3 letters, m numbers with 4 letters \\nSpace complexity: O(# of digits) due to DFS"
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "This was a difficult problem ngl\\n"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "my best solution I ever mad  --\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3370814/with-best-funny-comment-recursive-using-backtracking-solution-my-best-solution-ever/\\n"
                    },
                    {
                        "username": "user2949uL",
                        "content": "I tried to use exec() command to dynamically build the argument for itertools.product() function but it seems to be not working... Can we use python exec() or eval() on LeetCode? "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% fast running code with quick catch-up code .\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nfind words -> no. and create different combination with that\\n\\nApproach\\ncreate different combination from that\\n\\nComplexity\\nTime complexity:\\n0(n2) n -> words get across combination\\n\\nSpace complexity:\\nO(n2)\\n\\nCode\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n string dataset( char val)\\n {\\n      if( val ==\\'2\\')\\n      {\\n           return \"abc\";\\n      }\\n\\n       if( val ==\\'3\\')\\n      {\\n           return \"def\";\\n      }\\n\\n       if( val ==\\'4\\')\\n      {\\n           return \"ghi\";\\n      }\\n\\n       if( val ==\\'5\\')\\n      {\\n           return \"jkl\";\\n      }\\n\\n       if( val ==\\'6\\')\\n      {\\n           return \"mno\";\\n      }\\n\\n       if( val ==\\'7\\')\\n      {\\n           return \"pqrs\";\\n      }\\n       if( val ==\\'8\\')\\n      {\\n           return \"tuv\";\\n      }\\n     \\n     if( val ==\\'9\\')\\n      {\\n           return \"wxyz\";\\n      }\\n\\n      return \"\" ;\\n }\\n\\n    vector<string> letterCombinations(string digits) {\\n\\n         if( digits.size()==0)\\n         {\\n               return {};\\n         }    \\n\\n         vector<string> answer { \"\" };\\n\\n\\n  for( auto it :digits)\\n  {\\n      string name = dataset(it);\\n\\n int size =answer.size();\\n      vector<string> temp = answer;\\n      answer.clear();\\n\\n      for( int i = 0 ; i<name.size() ;i++)\\n      {\\n      for( int j = 0 ; j< size ;j++)\\n      {\\n         \\n           answer.push_back(temp[j] + name[i]);\\n      }\\n      \\n      }\\n       \\n  }\\n        return answer;   \\n    }\\n};\\n0\\n"
                    }
                ]
            },
            {
                "id": 1941161,
                "content": [
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};"
                    },
                    {
                        "username": "samyck",
                        "content": "if(digits[index] == '2'){\n            alp= \"abc\";\n        }\n        else if(digits[index] == '3'){\n            alp= \"def\";\n        }\n        else if(digits[index] == '4'){\n            alp= \"ghi\";\n        }\n        else if(digits[index] == '5'){\n            alp= \"jkl\";\n        }\n        else if(digits[index] == '6'){\n            alp= \"mno\";\n        }\n        else if(digits[index] == '7'){\n            alp= \"pqrs\";\n        }\n        else if(digits[index] == '8'){\n            alp= \"tuv\";\n        }\n        else if(digits[index] == '9'){\n            alp= \"wxyz\";\n        }"
                    },
                    {
                        "username": "amirovjasur17041996",
                        "content": "var dic: [String: [String]] = [\\n    \"2\": [\"a\",\"b\",\"c\"],\\n    \"3\": [\"d\",\"e\",\"f\"],\\n    \"4\": [\"g\",\"h\",\"i\"],\\n    \"5\": [\"j\",\"k\",\"l\"],\\n    \"6\": [\"m\",\"n\",\"o\"],\\n    \"7\": [\"p\",\"q\",\"r\",\"s\"],\\n    \"8\": [\"t\",\"u\",\"v\"],\\n    \"9\": [\"w\",\"x\",\"y\",\"z\"]\\n]"
                    },
                    {
                        "username": "phamkhien2309",
                        "content": "           $map = [\\n                2 => [\\'a\\', \\'b\\', \\'c\\'],\\n                3 => [\\'d\\', \\'e\\', \\'f\\'],\\n                4 => [\\'g\\', \\'h\\', \\'i\\'],\\n                5 => [\\'j\\', \\'k\\', \\'l\\'],\\n                6 => [\\'m\\', \\'n\\', \\'o\\'],\\n                7 => [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n                8 => [\\'t\\', \\'u\\', \\'v\\'],\\n                9 => [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n            ];"
                    },
                    {
                        "username": "psing9968",
                        "content": "This seems to be only recursion problem. Can anyone please help how backtracking is present in this ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "For each digit, you need to select a letter then encode the rest of the string. After you have finished encoding, you return to the digit in question (the backtracking step) and select the next letter. Rinse and repeat."
                    },
                    {
                        "username": "Blatogh",
                        "content": "Time complexity: O(3^n + 4^m), n numbers with 3 letters, m numbers with 4 letters \\nSpace complexity: O(# of digits) due to DFS"
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "This was a difficult problem ngl\\n"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "my best solution I ever mad  --\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3370814/with-best-funny-comment-recursive-using-backtracking-solution-my-best-solution-ever/\\n"
                    },
                    {
                        "username": "user2949uL",
                        "content": "I tried to use exec() command to dynamically build the argument for itertools.product() function but it seems to be not working... Can we use python exec() or eval() on LeetCode? "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% fast running code with quick catch-up code .\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nfind words -> no. and create different combination with that\\n\\nApproach\\ncreate different combination from that\\n\\nComplexity\\nTime complexity:\\n0(n2) n -> words get across combination\\n\\nSpace complexity:\\nO(n2)\\n\\nCode\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n string dataset( char val)\\n {\\n      if( val ==\\'2\\')\\n      {\\n           return \"abc\";\\n      }\\n\\n       if( val ==\\'3\\')\\n      {\\n           return \"def\";\\n      }\\n\\n       if( val ==\\'4\\')\\n      {\\n           return \"ghi\";\\n      }\\n\\n       if( val ==\\'5\\')\\n      {\\n           return \"jkl\";\\n      }\\n\\n       if( val ==\\'6\\')\\n      {\\n           return \"mno\";\\n      }\\n\\n       if( val ==\\'7\\')\\n      {\\n           return \"pqrs\";\\n      }\\n       if( val ==\\'8\\')\\n      {\\n           return \"tuv\";\\n      }\\n     \\n     if( val ==\\'9\\')\\n      {\\n           return \"wxyz\";\\n      }\\n\\n      return \"\" ;\\n }\\n\\n    vector<string> letterCombinations(string digits) {\\n\\n         if( digits.size()==0)\\n         {\\n               return {};\\n         }    \\n\\n         vector<string> answer { \"\" };\\n\\n\\n  for( auto it :digits)\\n  {\\n      string name = dataset(it);\\n\\n int size =answer.size();\\n      vector<string> temp = answer;\\n      answer.clear();\\n\\n      for( int i = 0 ; i<name.size() ;i++)\\n      {\\n      for( int j = 0 ; j< size ;j++)\\n      {\\n         \\n           answer.push_back(temp[j] + name[i]);\\n      }\\n      \\n      }\\n       \\n  }\\n        return answer;   \\n    }\\n};\\n0\\n"
                    }
                ]
            },
            {
                "id": 1940664,
                "content": [
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};"
                    },
                    {
                        "username": "samyck",
                        "content": "if(digits[index] == '2'){\n            alp= \"abc\";\n        }\n        else if(digits[index] == '3'){\n            alp= \"def\";\n        }\n        else if(digits[index] == '4'){\n            alp= \"ghi\";\n        }\n        else if(digits[index] == '5'){\n            alp= \"jkl\";\n        }\n        else if(digits[index] == '6'){\n            alp= \"mno\";\n        }\n        else if(digits[index] == '7'){\n            alp= \"pqrs\";\n        }\n        else if(digits[index] == '8'){\n            alp= \"tuv\";\n        }\n        else if(digits[index] == '9'){\n            alp= \"wxyz\";\n        }"
                    },
                    {
                        "username": "amirovjasur17041996",
                        "content": "var dic: [String: [String]] = [\\n    \"2\": [\"a\",\"b\",\"c\"],\\n    \"3\": [\"d\",\"e\",\"f\"],\\n    \"4\": [\"g\",\"h\",\"i\"],\\n    \"5\": [\"j\",\"k\",\"l\"],\\n    \"6\": [\"m\",\"n\",\"o\"],\\n    \"7\": [\"p\",\"q\",\"r\",\"s\"],\\n    \"8\": [\"t\",\"u\",\"v\"],\\n    \"9\": [\"w\",\"x\",\"y\",\"z\"]\\n]"
                    },
                    {
                        "username": "phamkhien2309",
                        "content": "           $map = [\\n                2 => [\\'a\\', \\'b\\', \\'c\\'],\\n                3 => [\\'d\\', \\'e\\', \\'f\\'],\\n                4 => [\\'g\\', \\'h\\', \\'i\\'],\\n                5 => [\\'j\\', \\'k\\', \\'l\\'],\\n                6 => [\\'m\\', \\'n\\', \\'o\\'],\\n                7 => [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n                8 => [\\'t\\', \\'u\\', \\'v\\'],\\n                9 => [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n            ];"
                    },
                    {
                        "username": "psing9968",
                        "content": "This seems to be only recursion problem. Can anyone please help how backtracking is present in this ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "For each digit, you need to select a letter then encode the rest of the string. After you have finished encoding, you return to the digit in question (the backtracking step) and select the next letter. Rinse and repeat."
                    },
                    {
                        "username": "Blatogh",
                        "content": "Time complexity: O(3^n + 4^m), n numbers with 3 letters, m numbers with 4 letters \\nSpace complexity: O(# of digits) due to DFS"
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "This was a difficult problem ngl\\n"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "my best solution I ever mad  --\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3370814/with-best-funny-comment-recursive-using-backtracking-solution-my-best-solution-ever/\\n"
                    },
                    {
                        "username": "user2949uL",
                        "content": "I tried to use exec() command to dynamically build the argument for itertools.product() function but it seems to be not working... Can we use python exec() or eval() on LeetCode? "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% fast running code with quick catch-up code .\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nfind words -> no. and create different combination with that\\n\\nApproach\\ncreate different combination from that\\n\\nComplexity\\nTime complexity:\\n0(n2) n -> words get across combination\\n\\nSpace complexity:\\nO(n2)\\n\\nCode\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n string dataset( char val)\\n {\\n      if( val ==\\'2\\')\\n      {\\n           return \"abc\";\\n      }\\n\\n       if( val ==\\'3\\')\\n      {\\n           return \"def\";\\n      }\\n\\n       if( val ==\\'4\\')\\n      {\\n           return \"ghi\";\\n      }\\n\\n       if( val ==\\'5\\')\\n      {\\n           return \"jkl\";\\n      }\\n\\n       if( val ==\\'6\\')\\n      {\\n           return \"mno\";\\n      }\\n\\n       if( val ==\\'7\\')\\n      {\\n           return \"pqrs\";\\n      }\\n       if( val ==\\'8\\')\\n      {\\n           return \"tuv\";\\n      }\\n     \\n     if( val ==\\'9\\')\\n      {\\n           return \"wxyz\";\\n      }\\n\\n      return \"\" ;\\n }\\n\\n    vector<string> letterCombinations(string digits) {\\n\\n         if( digits.size()==0)\\n         {\\n               return {};\\n         }    \\n\\n         vector<string> answer { \"\" };\\n\\n\\n  for( auto it :digits)\\n  {\\n      string name = dataset(it);\\n\\n int size =answer.size();\\n      vector<string> temp = answer;\\n      answer.clear();\\n\\n      for( int i = 0 ; i<name.size() ;i++)\\n      {\\n      for( int j = 0 ; j< size ;j++)\\n      {\\n         \\n           answer.push_back(temp[j] + name[i]);\\n      }\\n      \\n      }\\n       \\n  }\\n        return answer;   \\n    }\\n};\\n0\\n"
                    }
                ]
            },
            {
                "id": 1939933,
                "content": [
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};"
                    },
                    {
                        "username": "samyck",
                        "content": "if(digits[index] == '2'){\n            alp= \"abc\";\n        }\n        else if(digits[index] == '3'){\n            alp= \"def\";\n        }\n        else if(digits[index] == '4'){\n            alp= \"ghi\";\n        }\n        else if(digits[index] == '5'){\n            alp= \"jkl\";\n        }\n        else if(digits[index] == '6'){\n            alp= \"mno\";\n        }\n        else if(digits[index] == '7'){\n            alp= \"pqrs\";\n        }\n        else if(digits[index] == '8'){\n            alp= \"tuv\";\n        }\n        else if(digits[index] == '9'){\n            alp= \"wxyz\";\n        }"
                    },
                    {
                        "username": "amirovjasur17041996",
                        "content": "var dic: [String: [String]] = [\\n    \"2\": [\"a\",\"b\",\"c\"],\\n    \"3\": [\"d\",\"e\",\"f\"],\\n    \"4\": [\"g\",\"h\",\"i\"],\\n    \"5\": [\"j\",\"k\",\"l\"],\\n    \"6\": [\"m\",\"n\",\"o\"],\\n    \"7\": [\"p\",\"q\",\"r\",\"s\"],\\n    \"8\": [\"t\",\"u\",\"v\"],\\n    \"9\": [\"w\",\"x\",\"y\",\"z\"]\\n]"
                    },
                    {
                        "username": "phamkhien2309",
                        "content": "           $map = [\\n                2 => [\\'a\\', \\'b\\', \\'c\\'],\\n                3 => [\\'d\\', \\'e\\', \\'f\\'],\\n                4 => [\\'g\\', \\'h\\', \\'i\\'],\\n                5 => [\\'j\\', \\'k\\', \\'l\\'],\\n                6 => [\\'m\\', \\'n\\', \\'o\\'],\\n                7 => [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n                8 => [\\'t\\', \\'u\\', \\'v\\'],\\n                9 => [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n            ];"
                    },
                    {
                        "username": "psing9968",
                        "content": "This seems to be only recursion problem. Can anyone please help how backtracking is present in this ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "For each digit, you need to select a letter then encode the rest of the string. After you have finished encoding, you return to the digit in question (the backtracking step) and select the next letter. Rinse and repeat."
                    },
                    {
                        "username": "Blatogh",
                        "content": "Time complexity: O(3^n + 4^m), n numbers with 3 letters, m numbers with 4 letters \\nSpace complexity: O(# of digits) due to DFS"
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "This was a difficult problem ngl\\n"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "my best solution I ever mad  --\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3370814/with-best-funny-comment-recursive-using-backtracking-solution-my-best-solution-ever/\\n"
                    },
                    {
                        "username": "user2949uL",
                        "content": "I tried to use exec() command to dynamically build the argument for itertools.product() function but it seems to be not working... Can we use python exec() or eval() on LeetCode? "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% fast running code with quick catch-up code .\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nfind words -> no. and create different combination with that\\n\\nApproach\\ncreate different combination from that\\n\\nComplexity\\nTime complexity:\\n0(n2) n -> words get across combination\\n\\nSpace complexity:\\nO(n2)\\n\\nCode\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n string dataset( char val)\\n {\\n      if( val ==\\'2\\')\\n      {\\n           return \"abc\";\\n      }\\n\\n       if( val ==\\'3\\')\\n      {\\n           return \"def\";\\n      }\\n\\n       if( val ==\\'4\\')\\n      {\\n           return \"ghi\";\\n      }\\n\\n       if( val ==\\'5\\')\\n      {\\n           return \"jkl\";\\n      }\\n\\n       if( val ==\\'6\\')\\n      {\\n           return \"mno\";\\n      }\\n\\n       if( val ==\\'7\\')\\n      {\\n           return \"pqrs\";\\n      }\\n       if( val ==\\'8\\')\\n      {\\n           return \"tuv\";\\n      }\\n     \\n     if( val ==\\'9\\')\\n      {\\n           return \"wxyz\";\\n      }\\n\\n      return \"\" ;\\n }\\n\\n    vector<string> letterCombinations(string digits) {\\n\\n         if( digits.size()==0)\\n         {\\n               return {};\\n         }    \\n\\n         vector<string> answer { \"\" };\\n\\n\\n  for( auto it :digits)\\n  {\\n      string name = dataset(it);\\n\\n int size =answer.size();\\n      vector<string> temp = answer;\\n      answer.clear();\\n\\n      for( int i = 0 ; i<name.size() ;i++)\\n      {\\n      for( int j = 0 ; j< size ;j++)\\n      {\\n         \\n           answer.push_back(temp[j] + name[i]);\\n      }\\n      \\n      }\\n       \\n  }\\n        return answer;   \\n    }\\n};\\n0\\n"
                    }
                ]
            },
            {
                "id": 1932182,
                "content": [
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};"
                    },
                    {
                        "username": "samyck",
                        "content": "if(digits[index] == '2'){\n            alp= \"abc\";\n        }\n        else if(digits[index] == '3'){\n            alp= \"def\";\n        }\n        else if(digits[index] == '4'){\n            alp= \"ghi\";\n        }\n        else if(digits[index] == '5'){\n            alp= \"jkl\";\n        }\n        else if(digits[index] == '6'){\n            alp= \"mno\";\n        }\n        else if(digits[index] == '7'){\n            alp= \"pqrs\";\n        }\n        else if(digits[index] == '8'){\n            alp= \"tuv\";\n        }\n        else if(digits[index] == '9'){\n            alp= \"wxyz\";\n        }"
                    },
                    {
                        "username": "amirovjasur17041996",
                        "content": "var dic: [String: [String]] = [\\n    \"2\": [\"a\",\"b\",\"c\"],\\n    \"3\": [\"d\",\"e\",\"f\"],\\n    \"4\": [\"g\",\"h\",\"i\"],\\n    \"5\": [\"j\",\"k\",\"l\"],\\n    \"6\": [\"m\",\"n\",\"o\"],\\n    \"7\": [\"p\",\"q\",\"r\",\"s\"],\\n    \"8\": [\"t\",\"u\",\"v\"],\\n    \"9\": [\"w\",\"x\",\"y\",\"z\"]\\n]"
                    },
                    {
                        "username": "phamkhien2309",
                        "content": "           $map = [\\n                2 => [\\'a\\', \\'b\\', \\'c\\'],\\n                3 => [\\'d\\', \\'e\\', \\'f\\'],\\n                4 => [\\'g\\', \\'h\\', \\'i\\'],\\n                5 => [\\'j\\', \\'k\\', \\'l\\'],\\n                6 => [\\'m\\', \\'n\\', \\'o\\'],\\n                7 => [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n                8 => [\\'t\\', \\'u\\', \\'v\\'],\\n                9 => [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n            ];"
                    },
                    {
                        "username": "psing9968",
                        "content": "This seems to be only recursion problem. Can anyone please help how backtracking is present in this ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "For each digit, you need to select a letter then encode the rest of the string. After you have finished encoding, you return to the digit in question (the backtracking step) and select the next letter. Rinse and repeat."
                    },
                    {
                        "username": "Blatogh",
                        "content": "Time complexity: O(3^n + 4^m), n numbers with 3 letters, m numbers with 4 letters \\nSpace complexity: O(# of digits) due to DFS"
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "This was a difficult problem ngl\\n"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "my best solution I ever mad  --\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3370814/with-best-funny-comment-recursive-using-backtracking-solution-my-best-solution-ever/\\n"
                    },
                    {
                        "username": "user2949uL",
                        "content": "I tried to use exec() command to dynamically build the argument for itertools.product() function but it seems to be not working... Can we use python exec() or eval() on LeetCode? "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% fast running code with quick catch-up code .\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nfind words -> no. and create different combination with that\\n\\nApproach\\ncreate different combination from that\\n\\nComplexity\\nTime complexity:\\n0(n2) n -> words get across combination\\n\\nSpace complexity:\\nO(n2)\\n\\nCode\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n string dataset( char val)\\n {\\n      if( val ==\\'2\\')\\n      {\\n           return \"abc\";\\n      }\\n\\n       if( val ==\\'3\\')\\n      {\\n           return \"def\";\\n      }\\n\\n       if( val ==\\'4\\')\\n      {\\n           return \"ghi\";\\n      }\\n\\n       if( val ==\\'5\\')\\n      {\\n           return \"jkl\";\\n      }\\n\\n       if( val ==\\'6\\')\\n      {\\n           return \"mno\";\\n      }\\n\\n       if( val ==\\'7\\')\\n      {\\n           return \"pqrs\";\\n      }\\n       if( val ==\\'8\\')\\n      {\\n           return \"tuv\";\\n      }\\n     \\n     if( val ==\\'9\\')\\n      {\\n           return \"wxyz\";\\n      }\\n\\n      return \"\" ;\\n }\\n\\n    vector<string> letterCombinations(string digits) {\\n\\n         if( digits.size()==0)\\n         {\\n               return {};\\n         }    \\n\\n         vector<string> answer { \"\" };\\n\\n\\n  for( auto it :digits)\\n  {\\n      string name = dataset(it);\\n\\n int size =answer.size();\\n      vector<string> temp = answer;\\n      answer.clear();\\n\\n      for( int i = 0 ; i<name.size() ;i++)\\n      {\\n      for( int j = 0 ; j< size ;j++)\\n      {\\n         \\n           answer.push_back(temp[j] + name[i]);\\n      }\\n      \\n      }\\n       \\n  }\\n        return answer;   \\n    }\\n};\\n0\\n"
                    }
                ]
            },
            {
                "id": 1898667,
                "content": [
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};"
                    },
                    {
                        "username": "samyck",
                        "content": "if(digits[index] == '2'){\n            alp= \"abc\";\n        }\n        else if(digits[index] == '3'){\n            alp= \"def\";\n        }\n        else if(digits[index] == '4'){\n            alp= \"ghi\";\n        }\n        else if(digits[index] == '5'){\n            alp= \"jkl\";\n        }\n        else if(digits[index] == '6'){\n            alp= \"mno\";\n        }\n        else if(digits[index] == '7'){\n            alp= \"pqrs\";\n        }\n        else if(digits[index] == '8'){\n            alp= \"tuv\";\n        }\n        else if(digits[index] == '9'){\n            alp= \"wxyz\";\n        }"
                    },
                    {
                        "username": "amirovjasur17041996",
                        "content": "var dic: [String: [String]] = [\\n    \"2\": [\"a\",\"b\",\"c\"],\\n    \"3\": [\"d\",\"e\",\"f\"],\\n    \"4\": [\"g\",\"h\",\"i\"],\\n    \"5\": [\"j\",\"k\",\"l\"],\\n    \"6\": [\"m\",\"n\",\"o\"],\\n    \"7\": [\"p\",\"q\",\"r\",\"s\"],\\n    \"8\": [\"t\",\"u\",\"v\"],\\n    \"9\": [\"w\",\"x\",\"y\",\"z\"]\\n]"
                    },
                    {
                        "username": "phamkhien2309",
                        "content": "           $map = [\\n                2 => [\\'a\\', \\'b\\', \\'c\\'],\\n                3 => [\\'d\\', \\'e\\', \\'f\\'],\\n                4 => [\\'g\\', \\'h\\', \\'i\\'],\\n                5 => [\\'j\\', \\'k\\', \\'l\\'],\\n                6 => [\\'m\\', \\'n\\', \\'o\\'],\\n                7 => [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n                8 => [\\'t\\', \\'u\\', \\'v\\'],\\n                9 => [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n            ];"
                    },
                    {
                        "username": "psing9968",
                        "content": "This seems to be only recursion problem. Can anyone please help how backtracking is present in this ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "For each digit, you need to select a letter then encode the rest of the string. After you have finished encoding, you return to the digit in question (the backtracking step) and select the next letter. Rinse and repeat."
                    },
                    {
                        "username": "Blatogh",
                        "content": "Time complexity: O(3^n + 4^m), n numbers with 3 letters, m numbers with 4 letters \\nSpace complexity: O(# of digits) due to DFS"
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "This was a difficult problem ngl\\n"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "my best solution I ever mad  --\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3370814/with-best-funny-comment-recursive-using-backtracking-solution-my-best-solution-ever/\\n"
                    },
                    {
                        "username": "user2949uL",
                        "content": "I tried to use exec() command to dynamically build the argument for itertools.product() function but it seems to be not working... Can we use python exec() or eval() on LeetCode? "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% fast running code with quick catch-up code .\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nfind words -> no. and create different combination with that\\n\\nApproach\\ncreate different combination from that\\n\\nComplexity\\nTime complexity:\\n0(n2) n -> words get across combination\\n\\nSpace complexity:\\nO(n2)\\n\\nCode\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n string dataset( char val)\\n {\\n      if( val ==\\'2\\')\\n      {\\n           return \"abc\";\\n      }\\n\\n       if( val ==\\'3\\')\\n      {\\n           return \"def\";\\n      }\\n\\n       if( val ==\\'4\\')\\n      {\\n           return \"ghi\";\\n      }\\n\\n       if( val ==\\'5\\')\\n      {\\n           return \"jkl\";\\n      }\\n\\n       if( val ==\\'6\\')\\n      {\\n           return \"mno\";\\n      }\\n\\n       if( val ==\\'7\\')\\n      {\\n           return \"pqrs\";\\n      }\\n       if( val ==\\'8\\')\\n      {\\n           return \"tuv\";\\n      }\\n     \\n     if( val ==\\'9\\')\\n      {\\n           return \"wxyz\";\\n      }\\n\\n      return \"\" ;\\n }\\n\\n    vector<string> letterCombinations(string digits) {\\n\\n         if( digits.size()==0)\\n         {\\n               return {};\\n         }    \\n\\n         vector<string> answer { \"\" };\\n\\n\\n  for( auto it :digits)\\n  {\\n      string name = dataset(it);\\n\\n int size =answer.size();\\n      vector<string> temp = answer;\\n      answer.clear();\\n\\n      for( int i = 0 ; i<name.size() ;i++)\\n      {\\n      for( int j = 0 ; j< size ;j++)\\n      {\\n         \\n           answer.push_back(temp[j] + name[i]);\\n      }\\n      \\n      }\\n       \\n  }\\n        return answer;   \\n    }\\n};\\n0\\n"
                    }
                ]
            },
            {
                "id": 1873207,
                "content": [
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};"
                    },
                    {
                        "username": "samyck",
                        "content": "if(digits[index] == '2'){\n            alp= \"abc\";\n        }\n        else if(digits[index] == '3'){\n            alp= \"def\";\n        }\n        else if(digits[index] == '4'){\n            alp= \"ghi\";\n        }\n        else if(digits[index] == '5'){\n            alp= \"jkl\";\n        }\n        else if(digits[index] == '6'){\n            alp= \"mno\";\n        }\n        else if(digits[index] == '7'){\n            alp= \"pqrs\";\n        }\n        else if(digits[index] == '8'){\n            alp= \"tuv\";\n        }\n        else if(digits[index] == '9'){\n            alp= \"wxyz\";\n        }"
                    },
                    {
                        "username": "amirovjasur17041996",
                        "content": "var dic: [String: [String]] = [\\n    \"2\": [\"a\",\"b\",\"c\"],\\n    \"3\": [\"d\",\"e\",\"f\"],\\n    \"4\": [\"g\",\"h\",\"i\"],\\n    \"5\": [\"j\",\"k\",\"l\"],\\n    \"6\": [\"m\",\"n\",\"o\"],\\n    \"7\": [\"p\",\"q\",\"r\",\"s\"],\\n    \"8\": [\"t\",\"u\",\"v\"],\\n    \"9\": [\"w\",\"x\",\"y\",\"z\"]\\n]"
                    },
                    {
                        "username": "phamkhien2309",
                        "content": "           $map = [\\n                2 => [\\'a\\', \\'b\\', \\'c\\'],\\n                3 => [\\'d\\', \\'e\\', \\'f\\'],\\n                4 => [\\'g\\', \\'h\\', \\'i\\'],\\n                5 => [\\'j\\', \\'k\\', \\'l\\'],\\n                6 => [\\'m\\', \\'n\\', \\'o\\'],\\n                7 => [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n                8 => [\\'t\\', \\'u\\', \\'v\\'],\\n                9 => [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n            ];"
                    },
                    {
                        "username": "psing9968",
                        "content": "This seems to be only recursion problem. Can anyone please help how backtracking is present in this ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "For each digit, you need to select a letter then encode the rest of the string. After you have finished encoding, you return to the digit in question (the backtracking step) and select the next letter. Rinse and repeat."
                    },
                    {
                        "username": "Blatogh",
                        "content": "Time complexity: O(3^n + 4^m), n numbers with 3 letters, m numbers with 4 letters \\nSpace complexity: O(# of digits) due to DFS"
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "This was a difficult problem ngl\\n"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "my best solution I ever mad  --\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3370814/with-best-funny-comment-recursive-using-backtracking-solution-my-best-solution-ever/\\n"
                    },
                    {
                        "username": "user2949uL",
                        "content": "I tried to use exec() command to dynamically build the argument for itertools.product() function but it seems to be not working... Can we use python exec() or eval() on LeetCode? "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% fast running code with quick catch-up code .\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nfind words -> no. and create different combination with that\\n\\nApproach\\ncreate different combination from that\\n\\nComplexity\\nTime complexity:\\n0(n2) n -> words get across combination\\n\\nSpace complexity:\\nO(n2)\\n\\nCode\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n string dataset( char val)\\n {\\n      if( val ==\\'2\\')\\n      {\\n           return \"abc\";\\n      }\\n\\n       if( val ==\\'3\\')\\n      {\\n           return \"def\";\\n      }\\n\\n       if( val ==\\'4\\')\\n      {\\n           return \"ghi\";\\n      }\\n\\n       if( val ==\\'5\\')\\n      {\\n           return \"jkl\";\\n      }\\n\\n       if( val ==\\'6\\')\\n      {\\n           return \"mno\";\\n      }\\n\\n       if( val ==\\'7\\')\\n      {\\n           return \"pqrs\";\\n      }\\n       if( val ==\\'8\\')\\n      {\\n           return \"tuv\";\\n      }\\n     \\n     if( val ==\\'9\\')\\n      {\\n           return \"wxyz\";\\n      }\\n\\n      return \"\" ;\\n }\\n\\n    vector<string> letterCombinations(string digits) {\\n\\n         if( digits.size()==0)\\n         {\\n               return {};\\n         }    \\n\\n         vector<string> answer { \"\" };\\n\\n\\n  for( auto it :digits)\\n  {\\n      string name = dataset(it);\\n\\n int size =answer.size();\\n      vector<string> temp = answer;\\n      answer.clear();\\n\\n      for( int i = 0 ; i<name.size() ;i++)\\n      {\\n      for( int j = 0 ; j< size ;j++)\\n      {\\n         \\n           answer.push_back(temp[j] + name[i]);\\n      }\\n      \\n      }\\n       \\n  }\\n        return answer;   \\n    }\\n};\\n0\\n"
                    }
                ]
            },
            {
                "id": 1851708,
                "content": [
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};"
                    },
                    {
                        "username": "samyck",
                        "content": "if(digits[index] == '2'){\n            alp= \"abc\";\n        }\n        else if(digits[index] == '3'){\n            alp= \"def\";\n        }\n        else if(digits[index] == '4'){\n            alp= \"ghi\";\n        }\n        else if(digits[index] == '5'){\n            alp= \"jkl\";\n        }\n        else if(digits[index] == '6'){\n            alp= \"mno\";\n        }\n        else if(digits[index] == '7'){\n            alp= \"pqrs\";\n        }\n        else if(digits[index] == '8'){\n            alp= \"tuv\";\n        }\n        else if(digits[index] == '9'){\n            alp= \"wxyz\";\n        }"
                    },
                    {
                        "username": "amirovjasur17041996",
                        "content": "var dic: [String: [String]] = [\\n    \"2\": [\"a\",\"b\",\"c\"],\\n    \"3\": [\"d\",\"e\",\"f\"],\\n    \"4\": [\"g\",\"h\",\"i\"],\\n    \"5\": [\"j\",\"k\",\"l\"],\\n    \"6\": [\"m\",\"n\",\"o\"],\\n    \"7\": [\"p\",\"q\",\"r\",\"s\"],\\n    \"8\": [\"t\",\"u\",\"v\"],\\n    \"9\": [\"w\",\"x\",\"y\",\"z\"]\\n]"
                    },
                    {
                        "username": "phamkhien2309",
                        "content": "           $map = [\\n                2 => [\\'a\\', \\'b\\', \\'c\\'],\\n                3 => [\\'d\\', \\'e\\', \\'f\\'],\\n                4 => [\\'g\\', \\'h\\', \\'i\\'],\\n                5 => [\\'j\\', \\'k\\', \\'l\\'],\\n                6 => [\\'m\\', \\'n\\', \\'o\\'],\\n                7 => [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n                8 => [\\'t\\', \\'u\\', \\'v\\'],\\n                9 => [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n            ];"
                    },
                    {
                        "username": "psing9968",
                        "content": "This seems to be only recursion problem. Can anyone please help how backtracking is present in this ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "For each digit, you need to select a letter then encode the rest of the string. After you have finished encoding, you return to the digit in question (the backtracking step) and select the next letter. Rinse and repeat."
                    },
                    {
                        "username": "Blatogh",
                        "content": "Time complexity: O(3^n + 4^m), n numbers with 3 letters, m numbers with 4 letters \\nSpace complexity: O(# of digits) due to DFS"
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "This was a difficult problem ngl\\n"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "my best solution I ever mad  --\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3370814/with-best-funny-comment-recursive-using-backtracking-solution-my-best-solution-ever/\\n"
                    },
                    {
                        "username": "user2949uL",
                        "content": "I tried to use exec() command to dynamically build the argument for itertools.product() function but it seems to be not working... Can we use python exec() or eval() on LeetCode? "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% fast running code with quick catch-up code .\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nfind words -> no. and create different combination with that\\n\\nApproach\\ncreate different combination from that\\n\\nComplexity\\nTime complexity:\\n0(n2) n -> words get across combination\\n\\nSpace complexity:\\nO(n2)\\n\\nCode\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n string dataset( char val)\\n {\\n      if( val ==\\'2\\')\\n      {\\n           return \"abc\";\\n      }\\n\\n       if( val ==\\'3\\')\\n      {\\n           return \"def\";\\n      }\\n\\n       if( val ==\\'4\\')\\n      {\\n           return \"ghi\";\\n      }\\n\\n       if( val ==\\'5\\')\\n      {\\n           return \"jkl\";\\n      }\\n\\n       if( val ==\\'6\\')\\n      {\\n           return \"mno\";\\n      }\\n\\n       if( val ==\\'7\\')\\n      {\\n           return \"pqrs\";\\n      }\\n       if( val ==\\'8\\')\\n      {\\n           return \"tuv\";\\n      }\\n     \\n     if( val ==\\'9\\')\\n      {\\n           return \"wxyz\";\\n      }\\n\\n      return \"\" ;\\n }\\n\\n    vector<string> letterCombinations(string digits) {\\n\\n         if( digits.size()==0)\\n         {\\n               return {};\\n         }    \\n\\n         vector<string> answer { \"\" };\\n\\n\\n  for( auto it :digits)\\n  {\\n      string name = dataset(it);\\n\\n int size =answer.size();\\n      vector<string> temp = answer;\\n      answer.clear();\\n\\n      for( int i = 0 ; i<name.size() ;i++)\\n      {\\n      for( int j = 0 ; j< size ;j++)\\n      {\\n         \\n           answer.push_back(temp[j] + name[i]);\\n      }\\n      \\n      }\\n       \\n  }\\n        return answer;   \\n    }\\n};\\n0\\n"
                    }
                ]
            },
            {
                "id": 1844641,
                "content": [
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};"
                    },
                    {
                        "username": "samyck",
                        "content": "if(digits[index] == '2'){\n            alp= \"abc\";\n        }\n        else if(digits[index] == '3'){\n            alp= \"def\";\n        }\n        else if(digits[index] == '4'){\n            alp= \"ghi\";\n        }\n        else if(digits[index] == '5'){\n            alp= \"jkl\";\n        }\n        else if(digits[index] == '6'){\n            alp= \"mno\";\n        }\n        else if(digits[index] == '7'){\n            alp= \"pqrs\";\n        }\n        else if(digits[index] == '8'){\n            alp= \"tuv\";\n        }\n        else if(digits[index] == '9'){\n            alp= \"wxyz\";\n        }"
                    },
                    {
                        "username": "amirovjasur17041996",
                        "content": "var dic: [String: [String]] = [\\n    \"2\": [\"a\",\"b\",\"c\"],\\n    \"3\": [\"d\",\"e\",\"f\"],\\n    \"4\": [\"g\",\"h\",\"i\"],\\n    \"5\": [\"j\",\"k\",\"l\"],\\n    \"6\": [\"m\",\"n\",\"o\"],\\n    \"7\": [\"p\",\"q\",\"r\",\"s\"],\\n    \"8\": [\"t\",\"u\",\"v\"],\\n    \"9\": [\"w\",\"x\",\"y\",\"z\"]\\n]"
                    },
                    {
                        "username": "phamkhien2309",
                        "content": "           $map = [\\n                2 => [\\'a\\', \\'b\\', \\'c\\'],\\n                3 => [\\'d\\', \\'e\\', \\'f\\'],\\n                4 => [\\'g\\', \\'h\\', \\'i\\'],\\n                5 => [\\'j\\', \\'k\\', \\'l\\'],\\n                6 => [\\'m\\', \\'n\\', \\'o\\'],\\n                7 => [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n                8 => [\\'t\\', \\'u\\', \\'v\\'],\\n                9 => [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n            ];"
                    },
                    {
                        "username": "psing9968",
                        "content": "This seems to be only recursion problem. Can anyone please help how backtracking is present in this ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "For each digit, you need to select a letter then encode the rest of the string. After you have finished encoding, you return to the digit in question (the backtracking step) and select the next letter. Rinse and repeat."
                    },
                    {
                        "username": "Blatogh",
                        "content": "Time complexity: O(3^n + 4^m), n numbers with 3 letters, m numbers with 4 letters \\nSpace complexity: O(# of digits) due to DFS"
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "This was a difficult problem ngl\\n"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "my best solution I ever mad  --\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3370814/with-best-funny-comment-recursive-using-backtracking-solution-my-best-solution-ever/\\n"
                    },
                    {
                        "username": "user2949uL",
                        "content": "I tried to use exec() command to dynamically build the argument for itertools.product() function but it seems to be not working... Can we use python exec() or eval() on LeetCode? "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% fast running code with quick catch-up code .\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nfind words -> no. and create different combination with that\\n\\nApproach\\ncreate different combination from that\\n\\nComplexity\\nTime complexity:\\n0(n2) n -> words get across combination\\n\\nSpace complexity:\\nO(n2)\\n\\nCode\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n string dataset( char val)\\n {\\n      if( val ==\\'2\\')\\n      {\\n           return \"abc\";\\n      }\\n\\n       if( val ==\\'3\\')\\n      {\\n           return \"def\";\\n      }\\n\\n       if( val ==\\'4\\')\\n      {\\n           return \"ghi\";\\n      }\\n\\n       if( val ==\\'5\\')\\n      {\\n           return \"jkl\";\\n      }\\n\\n       if( val ==\\'6\\')\\n      {\\n           return \"mno\";\\n      }\\n\\n       if( val ==\\'7\\')\\n      {\\n           return \"pqrs\";\\n      }\\n       if( val ==\\'8\\')\\n      {\\n           return \"tuv\";\\n      }\\n     \\n     if( val ==\\'9\\')\\n      {\\n           return \"wxyz\";\\n      }\\n\\n      return \"\" ;\\n }\\n\\n    vector<string> letterCombinations(string digits) {\\n\\n         if( digits.size()==0)\\n         {\\n               return {};\\n         }    \\n\\n         vector<string> answer { \"\" };\\n\\n\\n  for( auto it :digits)\\n  {\\n      string name = dataset(it);\\n\\n int size =answer.size();\\n      vector<string> temp = answer;\\n      answer.clear();\\n\\n      for( int i = 0 ; i<name.size() ;i++)\\n      {\\n      for( int j = 0 ; j< size ;j++)\\n      {\\n         \\n           answer.push_back(temp[j] + name[i]);\\n      }\\n      \\n      }\\n       \\n  }\\n        return answer;   \\n    }\\n};\\n0\\n"
                    }
                ]
            },
            {
                "id": 1839739,
                "content": [
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};"
                    },
                    {
                        "username": "samyck",
                        "content": "if(digits[index] == '2'){\n            alp= \"abc\";\n        }\n        else if(digits[index] == '3'){\n            alp= \"def\";\n        }\n        else if(digits[index] == '4'){\n            alp= \"ghi\";\n        }\n        else if(digits[index] == '5'){\n            alp= \"jkl\";\n        }\n        else if(digits[index] == '6'){\n            alp= \"mno\";\n        }\n        else if(digits[index] == '7'){\n            alp= \"pqrs\";\n        }\n        else if(digits[index] == '8'){\n            alp= \"tuv\";\n        }\n        else if(digits[index] == '9'){\n            alp= \"wxyz\";\n        }"
                    },
                    {
                        "username": "amirovjasur17041996",
                        "content": "var dic: [String: [String]] = [\\n    \"2\": [\"a\",\"b\",\"c\"],\\n    \"3\": [\"d\",\"e\",\"f\"],\\n    \"4\": [\"g\",\"h\",\"i\"],\\n    \"5\": [\"j\",\"k\",\"l\"],\\n    \"6\": [\"m\",\"n\",\"o\"],\\n    \"7\": [\"p\",\"q\",\"r\",\"s\"],\\n    \"8\": [\"t\",\"u\",\"v\"],\\n    \"9\": [\"w\",\"x\",\"y\",\"z\"]\\n]"
                    },
                    {
                        "username": "phamkhien2309",
                        "content": "           $map = [\\n                2 => [\\'a\\', \\'b\\', \\'c\\'],\\n                3 => [\\'d\\', \\'e\\', \\'f\\'],\\n                4 => [\\'g\\', \\'h\\', \\'i\\'],\\n                5 => [\\'j\\', \\'k\\', \\'l\\'],\\n                6 => [\\'m\\', \\'n\\', \\'o\\'],\\n                7 => [\\'p\\', \\'q\\', \\'r\\', \\'s\\'],\\n                8 => [\\'t\\', \\'u\\', \\'v\\'],\\n                9 => [\\'w\\', \\'x\\', \\'y\\', \\'z\\'],\\n            ];"
                    },
                    {
                        "username": "psing9968",
                        "content": "This seems to be only recursion problem. Can anyone please help how backtracking is present in this ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "For each digit, you need to select a letter then encode the rest of the string. After you have finished encoding, you return to the digit in question (the backtracking step) and select the next letter. Rinse and repeat."
                    },
                    {
                        "username": "Blatogh",
                        "content": "Time complexity: O(3^n + 4^m), n numbers with 3 letters, m numbers with 4 letters \\nSpace complexity: O(# of digits) due to DFS"
                    },
                    {
                        "username": "bernardoolisan",
                        "content": "This was a difficult problem ngl\\n"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "my best solution I ever mad  --\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3370814/with-best-funny-comment-recursive-using-backtracking-solution-my-best-solution-ever/\\n"
                    },
                    {
                        "username": "user2949uL",
                        "content": "I tried to use exec() command to dynamically build the argument for itertools.product() function but it seems to be not working... Can we use python exec() or eval() on LeetCode? "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% fast running code with quick catch-up code .\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nfind words -> no. and create different combination with that\\n\\nApproach\\ncreate different combination from that\\n\\nComplexity\\nTime complexity:\\n0(n2) n -> words get across combination\\n\\nSpace complexity:\\nO(n2)\\n\\nCode\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n string dataset( char val)\\n {\\n      if( val ==\\'2\\')\\n      {\\n           return \"abc\";\\n      }\\n\\n       if( val ==\\'3\\')\\n      {\\n           return \"def\";\\n      }\\n\\n       if( val ==\\'4\\')\\n      {\\n           return \"ghi\";\\n      }\\n\\n       if( val ==\\'5\\')\\n      {\\n           return \"jkl\";\\n      }\\n\\n       if( val ==\\'6\\')\\n      {\\n           return \"mno\";\\n      }\\n\\n       if( val ==\\'7\\')\\n      {\\n           return \"pqrs\";\\n      }\\n       if( val ==\\'8\\')\\n      {\\n           return \"tuv\";\\n      }\\n     \\n     if( val ==\\'9\\')\\n      {\\n           return \"wxyz\";\\n      }\\n\\n      return \"\" ;\\n }\\n\\n    vector<string> letterCombinations(string digits) {\\n\\n         if( digits.size()==0)\\n         {\\n               return {};\\n         }    \\n\\n         vector<string> answer { \"\" };\\n\\n\\n  for( auto it :digits)\\n  {\\n      string name = dataset(it);\\n\\n int size =answer.size();\\n      vector<string> temp = answer;\\n      answer.clear();\\n\\n      for( int i = 0 ; i<name.size() ;i++)\\n      {\\n      for( int j = 0 ; j< size ;j++)\\n      {\\n         \\n           answer.push_back(temp[j] + name[i]);\\n      }\\n      \\n      }\\n       \\n  }\\n        return answer;   \\n    }\\n};\\n0\\n"
                    }
                ]
            },
            {
                "id": 1830619,
                "content": [
                    {
                        "username": "sk_aayush",
                        "content": "C++ SOLUTION | BEATS 100% | RECURSION USED\\n\\n\\nclass Solution {\\n    private:\\n    void solve(string digit, int index, string output, vector<string> &ans, string mapping[])\\n    {\\n        if(index>=digit.size())\\n        {\\n            ans.push_back(output);\\n            return;  \\n        }\\n\\n        int num = digit[index] - \\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0; i<value.length();i++)\\n       {\\n        output.push_back(value[i]);\\n        solve(digit, index+1, output, ans, mapping);\\n        output.pop_back();\\n        \\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.length()==0)\\n        return ans;\\n\\n        int index=0;\\n        string output=\"\";\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits, index, output, ans, mapping);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we use memoization for this problem?  I understand the backtracking approach (DFS or BFS). Can someone point me to a good explanation of using hash tables for memoization? I couldn\\'t find a good one in the solutions tab. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You have to store every letter combination string in a returnable array so I don't see how memoization can help - especially since no repeat calculations are being made."
                    },
                    {
                        "username": "msoni1369",
                        "content": "hashmap = { \"2\" : [\\'a\\', \\'b\\',\\'c\\'],\\n               \"3\" : [\\'d\\', \\'e\\', \\'f\\'],\\n               \"4\" : [\\'g\\', \\'h\\', \\'i\\'],\\n               \"5\" : [\"j\", \"k\", \"l\"],\\n               \"6\" : [\"m\", \"n\", \"o\"],\\n               \"7\" : [\"p\", \"q\", \"r\", \"s\"],\\n               \"8\" : [\"t\", \"u\", \"v\"],\\n               \"9\" : [\"w\", \"x\", \"y\", \"z\"] }\\n        temp = []\\n        for i in range(len(digits)):\\n            temp = digits[i]\\n        print(temp)\\n        temp = hashmap[str(temp)]\\n        print(temp)\\n        ans = []\\n        for i in range(len(digits)-2, -1, -1):\\n            temp2 = hashmap[digits[i]]\\n            ans = []\\n            for k in temp2:\\n                for j in temp:\\n                    st = k+j\\n                    ans.append(st)\\n            temp = ans\\n        return ans\\n\\nRuntime Error:\\nKeyError: \\'[]\\'\\n    temp = hashmap[str(temp)]\\nLine 15 in letterCombinations (Solution.py)\\n    ret = Solution().letterCombinations(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 58 in <module> (Solution.py)\\n\\nstdout:\\n3\\n[\\'d\\', \\'e\\', \\'f\\']\\n[]\\n\\nplease ignore the ans\\nfor this line \"print(temp)\" i am getting ans in stdout but why i am getting runtime error i am not able to get. even when i am using \"print(digits[0])\" i am getting same error but output is getting printed on screen. Can anyone help me figure what i am doing wrong\\n"
                    },
                    {
                        "username": "MohammadAliMiyan",
                        "content": "for any confusion, just search for \"Dsa love Babbar keypad problem\" , that\\'ll be enough if you are a beginner .\\n\\n`class Solution {\\n    private void solve(String digits,String output,int index,List<String> ans,String mapping[]){\\n        if(index>=digits.length()){\\n            ans.add(output);\\n            return;\\n        }\\n        // to check data type of a variable.;\\n        // ((Object)variableName).getClass().getSimpleName());\\n        int element = digits.charAt(index)-\\'0\\';\\n        String value = mapping[element];\\n        for(int i=0;i<value.length();i++){\\n            solve(digits,output+value.charAt(i),index+1,ans,mapping);\\n        }\\n\\n    }\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        String output = \"\";\\n        int index = 0;\\n        String mapping[] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        solve(digits,output,index,ans,mapping);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "meergato247",
                        "content": "I wish that the test cases ranged in difficulty from what to do with a simple input (empty string) to having multiple numbers, i.e. 234 because the problem statement isn\\'t too descriptive. "
                    },
                    {
                        "username": "princesingh01",
                        "content": "Hello has anyone  encountered this problem before.\nI am trying to add empty string into the empty Arraylist , Except leetcode everywhere the output is\nempty Arraylist (  [ ] )  but here Leetcode is providing arraylist with an empty string ( [ \"\" ] ) like this.\n\n public List<String> letterCombinations(String digits) {\n        String[] codes = {\"\",\"\", \"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        if(digits.isEmpty()){\n            List<String> base_array = new ArrayList<>();\n            base_array.add(\"\");  // it should return an empty Arraylist, ( [ ] ) \n            return base_array; // but returning ( [ \"\" ] ) \n        }"
                    },
                    {
                        "username": "deepu14d",
                        "content": "have you found some solution for this ?"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone expalin why I am getting this error for below code\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n`\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};\\n`\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone help me with whats wrong in the code below\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n `#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "BEATS 100% || C++ || Hash Map\n\n\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> res;\n        if(digits.empty()) return res;\n        unordered_map<char,string> hash{{'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},{'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"}};\n        string s;\n        dfs(digits,0,s,hash,res);\n        return res;\n    }\n    void dfs(string &digits,int idx,string s,unordered_map<char,string> &hash,vector<string> &res){\n        if(idx==digits.size()){\n            res.push_back(s);\n            return;\n        }\n        for(auto c:hash[digits[idx]]){\n            dfs(digits,idx+1,s+c,hash,res);\n        }\n    }\n};"
                    }
                ]
            },
            {
                "id": 1801779,
                "content": [
                    {
                        "username": "sk_aayush",
                        "content": "C++ SOLUTION | BEATS 100% | RECURSION USED\\n\\n\\nclass Solution {\\n    private:\\n    void solve(string digit, int index, string output, vector<string> &ans, string mapping[])\\n    {\\n        if(index>=digit.size())\\n        {\\n            ans.push_back(output);\\n            return;  \\n        }\\n\\n        int num = digit[index] - \\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0; i<value.length();i++)\\n       {\\n        output.push_back(value[i]);\\n        solve(digit, index+1, output, ans, mapping);\\n        output.pop_back();\\n        \\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.length()==0)\\n        return ans;\\n\\n        int index=0;\\n        string output=\"\";\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits, index, output, ans, mapping);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we use memoization for this problem?  I understand the backtracking approach (DFS or BFS). Can someone point me to a good explanation of using hash tables for memoization? I couldn\\'t find a good one in the solutions tab. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You have to store every letter combination string in a returnable array so I don't see how memoization can help - especially since no repeat calculations are being made."
                    },
                    {
                        "username": "msoni1369",
                        "content": "hashmap = { \"2\" : [\\'a\\', \\'b\\',\\'c\\'],\\n               \"3\" : [\\'d\\', \\'e\\', \\'f\\'],\\n               \"4\" : [\\'g\\', \\'h\\', \\'i\\'],\\n               \"5\" : [\"j\", \"k\", \"l\"],\\n               \"6\" : [\"m\", \"n\", \"o\"],\\n               \"7\" : [\"p\", \"q\", \"r\", \"s\"],\\n               \"8\" : [\"t\", \"u\", \"v\"],\\n               \"9\" : [\"w\", \"x\", \"y\", \"z\"] }\\n        temp = []\\n        for i in range(len(digits)):\\n            temp = digits[i]\\n        print(temp)\\n        temp = hashmap[str(temp)]\\n        print(temp)\\n        ans = []\\n        for i in range(len(digits)-2, -1, -1):\\n            temp2 = hashmap[digits[i]]\\n            ans = []\\n            for k in temp2:\\n                for j in temp:\\n                    st = k+j\\n                    ans.append(st)\\n            temp = ans\\n        return ans\\n\\nRuntime Error:\\nKeyError: \\'[]\\'\\n    temp = hashmap[str(temp)]\\nLine 15 in letterCombinations (Solution.py)\\n    ret = Solution().letterCombinations(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 58 in <module> (Solution.py)\\n\\nstdout:\\n3\\n[\\'d\\', \\'e\\', \\'f\\']\\n[]\\n\\nplease ignore the ans\\nfor this line \"print(temp)\" i am getting ans in stdout but why i am getting runtime error i am not able to get. even when i am using \"print(digits[0])\" i am getting same error but output is getting printed on screen. Can anyone help me figure what i am doing wrong\\n"
                    },
                    {
                        "username": "MohammadAliMiyan",
                        "content": "for any confusion, just search for \"Dsa love Babbar keypad problem\" , that\\'ll be enough if you are a beginner .\\n\\n`class Solution {\\n    private void solve(String digits,String output,int index,List<String> ans,String mapping[]){\\n        if(index>=digits.length()){\\n            ans.add(output);\\n            return;\\n        }\\n        // to check data type of a variable.;\\n        // ((Object)variableName).getClass().getSimpleName());\\n        int element = digits.charAt(index)-\\'0\\';\\n        String value = mapping[element];\\n        for(int i=0;i<value.length();i++){\\n            solve(digits,output+value.charAt(i),index+1,ans,mapping);\\n        }\\n\\n    }\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        String output = \"\";\\n        int index = 0;\\n        String mapping[] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        solve(digits,output,index,ans,mapping);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "meergato247",
                        "content": "I wish that the test cases ranged in difficulty from what to do with a simple input (empty string) to having multiple numbers, i.e. 234 because the problem statement isn\\'t too descriptive. "
                    },
                    {
                        "username": "princesingh01",
                        "content": "Hello has anyone  encountered this problem before.\nI am trying to add empty string into the empty Arraylist , Except leetcode everywhere the output is\nempty Arraylist (  [ ] )  but here Leetcode is providing arraylist with an empty string ( [ \"\" ] ) like this.\n\n public List<String> letterCombinations(String digits) {\n        String[] codes = {\"\",\"\", \"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        if(digits.isEmpty()){\n            List<String> base_array = new ArrayList<>();\n            base_array.add(\"\");  // it should return an empty Arraylist, ( [ ] ) \n            return base_array; // but returning ( [ \"\" ] ) \n        }"
                    },
                    {
                        "username": "deepu14d",
                        "content": "have you found some solution for this ?"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone expalin why I am getting this error for below code\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n`\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};\\n`\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone help me with whats wrong in the code below\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n `#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "BEATS 100% || C++ || Hash Map\n\n\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> res;\n        if(digits.empty()) return res;\n        unordered_map<char,string> hash{{'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},{'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"}};\n        string s;\n        dfs(digits,0,s,hash,res);\n        return res;\n    }\n    void dfs(string &digits,int idx,string s,unordered_map<char,string> &hash,vector<string> &res){\n        if(idx==digits.size()){\n            res.push_back(s);\n            return;\n        }\n        for(auto c:hash[digits[idx]]){\n            dfs(digits,idx+1,s+c,hash,res);\n        }\n    }\n};"
                    }
                ]
            },
            {
                "id": 1798030,
                "content": [
                    {
                        "username": "sk_aayush",
                        "content": "C++ SOLUTION | BEATS 100% | RECURSION USED\\n\\n\\nclass Solution {\\n    private:\\n    void solve(string digit, int index, string output, vector<string> &ans, string mapping[])\\n    {\\n        if(index>=digit.size())\\n        {\\n            ans.push_back(output);\\n            return;  \\n        }\\n\\n        int num = digit[index] - \\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0; i<value.length();i++)\\n       {\\n        output.push_back(value[i]);\\n        solve(digit, index+1, output, ans, mapping);\\n        output.pop_back();\\n        \\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.length()==0)\\n        return ans;\\n\\n        int index=0;\\n        string output=\"\";\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits, index, output, ans, mapping);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we use memoization for this problem?  I understand the backtracking approach (DFS or BFS). Can someone point me to a good explanation of using hash tables for memoization? I couldn\\'t find a good one in the solutions tab. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You have to store every letter combination string in a returnable array so I don't see how memoization can help - especially since no repeat calculations are being made."
                    },
                    {
                        "username": "msoni1369",
                        "content": "hashmap = { \"2\" : [\\'a\\', \\'b\\',\\'c\\'],\\n               \"3\" : [\\'d\\', \\'e\\', \\'f\\'],\\n               \"4\" : [\\'g\\', \\'h\\', \\'i\\'],\\n               \"5\" : [\"j\", \"k\", \"l\"],\\n               \"6\" : [\"m\", \"n\", \"o\"],\\n               \"7\" : [\"p\", \"q\", \"r\", \"s\"],\\n               \"8\" : [\"t\", \"u\", \"v\"],\\n               \"9\" : [\"w\", \"x\", \"y\", \"z\"] }\\n        temp = []\\n        for i in range(len(digits)):\\n            temp = digits[i]\\n        print(temp)\\n        temp = hashmap[str(temp)]\\n        print(temp)\\n        ans = []\\n        for i in range(len(digits)-2, -1, -1):\\n            temp2 = hashmap[digits[i]]\\n            ans = []\\n            for k in temp2:\\n                for j in temp:\\n                    st = k+j\\n                    ans.append(st)\\n            temp = ans\\n        return ans\\n\\nRuntime Error:\\nKeyError: \\'[]\\'\\n    temp = hashmap[str(temp)]\\nLine 15 in letterCombinations (Solution.py)\\n    ret = Solution().letterCombinations(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 58 in <module> (Solution.py)\\n\\nstdout:\\n3\\n[\\'d\\', \\'e\\', \\'f\\']\\n[]\\n\\nplease ignore the ans\\nfor this line \"print(temp)\" i am getting ans in stdout but why i am getting runtime error i am not able to get. even when i am using \"print(digits[0])\" i am getting same error but output is getting printed on screen. Can anyone help me figure what i am doing wrong\\n"
                    },
                    {
                        "username": "MohammadAliMiyan",
                        "content": "for any confusion, just search for \"Dsa love Babbar keypad problem\" , that\\'ll be enough if you are a beginner .\\n\\n`class Solution {\\n    private void solve(String digits,String output,int index,List<String> ans,String mapping[]){\\n        if(index>=digits.length()){\\n            ans.add(output);\\n            return;\\n        }\\n        // to check data type of a variable.;\\n        // ((Object)variableName).getClass().getSimpleName());\\n        int element = digits.charAt(index)-\\'0\\';\\n        String value = mapping[element];\\n        for(int i=0;i<value.length();i++){\\n            solve(digits,output+value.charAt(i),index+1,ans,mapping);\\n        }\\n\\n    }\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        String output = \"\";\\n        int index = 0;\\n        String mapping[] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        solve(digits,output,index,ans,mapping);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "meergato247",
                        "content": "I wish that the test cases ranged in difficulty from what to do with a simple input (empty string) to having multiple numbers, i.e. 234 because the problem statement isn\\'t too descriptive. "
                    },
                    {
                        "username": "princesingh01",
                        "content": "Hello has anyone  encountered this problem before.\nI am trying to add empty string into the empty Arraylist , Except leetcode everywhere the output is\nempty Arraylist (  [ ] )  but here Leetcode is providing arraylist with an empty string ( [ \"\" ] ) like this.\n\n public List<String> letterCombinations(String digits) {\n        String[] codes = {\"\",\"\", \"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        if(digits.isEmpty()){\n            List<String> base_array = new ArrayList<>();\n            base_array.add(\"\");  // it should return an empty Arraylist, ( [ ] ) \n            return base_array; // but returning ( [ \"\" ] ) \n        }"
                    },
                    {
                        "username": "deepu14d",
                        "content": "have you found some solution for this ?"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone expalin why I am getting this error for below code\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n`\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};\\n`\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone help me with whats wrong in the code below\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n `#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "BEATS 100% || C++ || Hash Map\n\n\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> res;\n        if(digits.empty()) return res;\n        unordered_map<char,string> hash{{'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},{'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"}};\n        string s;\n        dfs(digits,0,s,hash,res);\n        return res;\n    }\n    void dfs(string &digits,int idx,string s,unordered_map<char,string> &hash,vector<string> &res){\n        if(idx==digits.size()){\n            res.push_back(s);\n            return;\n        }\n        for(auto c:hash[digits[idx]]){\n            dfs(digits,idx+1,s+c,hash,res);\n        }\n    }\n};"
                    }
                ]
            },
            {
                "id": 1786108,
                "content": [
                    {
                        "username": "sk_aayush",
                        "content": "C++ SOLUTION | BEATS 100% | RECURSION USED\\n\\n\\nclass Solution {\\n    private:\\n    void solve(string digit, int index, string output, vector<string> &ans, string mapping[])\\n    {\\n        if(index>=digit.size())\\n        {\\n            ans.push_back(output);\\n            return;  \\n        }\\n\\n        int num = digit[index] - \\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0; i<value.length();i++)\\n       {\\n        output.push_back(value[i]);\\n        solve(digit, index+1, output, ans, mapping);\\n        output.pop_back();\\n        \\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.length()==0)\\n        return ans;\\n\\n        int index=0;\\n        string output=\"\";\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits, index, output, ans, mapping);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we use memoization for this problem?  I understand the backtracking approach (DFS or BFS). Can someone point me to a good explanation of using hash tables for memoization? I couldn\\'t find a good one in the solutions tab. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You have to store every letter combination string in a returnable array so I don't see how memoization can help - especially since no repeat calculations are being made."
                    },
                    {
                        "username": "msoni1369",
                        "content": "hashmap = { \"2\" : [\\'a\\', \\'b\\',\\'c\\'],\\n               \"3\" : [\\'d\\', \\'e\\', \\'f\\'],\\n               \"4\" : [\\'g\\', \\'h\\', \\'i\\'],\\n               \"5\" : [\"j\", \"k\", \"l\"],\\n               \"6\" : [\"m\", \"n\", \"o\"],\\n               \"7\" : [\"p\", \"q\", \"r\", \"s\"],\\n               \"8\" : [\"t\", \"u\", \"v\"],\\n               \"9\" : [\"w\", \"x\", \"y\", \"z\"] }\\n        temp = []\\n        for i in range(len(digits)):\\n            temp = digits[i]\\n        print(temp)\\n        temp = hashmap[str(temp)]\\n        print(temp)\\n        ans = []\\n        for i in range(len(digits)-2, -1, -1):\\n            temp2 = hashmap[digits[i]]\\n            ans = []\\n            for k in temp2:\\n                for j in temp:\\n                    st = k+j\\n                    ans.append(st)\\n            temp = ans\\n        return ans\\n\\nRuntime Error:\\nKeyError: \\'[]\\'\\n    temp = hashmap[str(temp)]\\nLine 15 in letterCombinations (Solution.py)\\n    ret = Solution().letterCombinations(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 58 in <module> (Solution.py)\\n\\nstdout:\\n3\\n[\\'d\\', \\'e\\', \\'f\\']\\n[]\\n\\nplease ignore the ans\\nfor this line \"print(temp)\" i am getting ans in stdout but why i am getting runtime error i am not able to get. even when i am using \"print(digits[0])\" i am getting same error but output is getting printed on screen. Can anyone help me figure what i am doing wrong\\n"
                    },
                    {
                        "username": "MohammadAliMiyan",
                        "content": "for any confusion, just search for \"Dsa love Babbar keypad problem\" , that\\'ll be enough if you are a beginner .\\n\\n`class Solution {\\n    private void solve(String digits,String output,int index,List<String> ans,String mapping[]){\\n        if(index>=digits.length()){\\n            ans.add(output);\\n            return;\\n        }\\n        // to check data type of a variable.;\\n        // ((Object)variableName).getClass().getSimpleName());\\n        int element = digits.charAt(index)-\\'0\\';\\n        String value = mapping[element];\\n        for(int i=0;i<value.length();i++){\\n            solve(digits,output+value.charAt(i),index+1,ans,mapping);\\n        }\\n\\n    }\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        String output = \"\";\\n        int index = 0;\\n        String mapping[] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        solve(digits,output,index,ans,mapping);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "meergato247",
                        "content": "I wish that the test cases ranged in difficulty from what to do with a simple input (empty string) to having multiple numbers, i.e. 234 because the problem statement isn\\'t too descriptive. "
                    },
                    {
                        "username": "princesingh01",
                        "content": "Hello has anyone  encountered this problem before.\nI am trying to add empty string into the empty Arraylist , Except leetcode everywhere the output is\nempty Arraylist (  [ ] )  but here Leetcode is providing arraylist with an empty string ( [ \"\" ] ) like this.\n\n public List<String> letterCombinations(String digits) {\n        String[] codes = {\"\",\"\", \"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        if(digits.isEmpty()){\n            List<String> base_array = new ArrayList<>();\n            base_array.add(\"\");  // it should return an empty Arraylist, ( [ ] ) \n            return base_array; // but returning ( [ \"\" ] ) \n        }"
                    },
                    {
                        "username": "deepu14d",
                        "content": "have you found some solution for this ?"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone expalin why I am getting this error for below code\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n`\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};\\n`\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone help me with whats wrong in the code below\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n `#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "BEATS 100% || C++ || Hash Map\n\n\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> res;\n        if(digits.empty()) return res;\n        unordered_map<char,string> hash{{'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},{'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"}};\n        string s;\n        dfs(digits,0,s,hash,res);\n        return res;\n    }\n    void dfs(string &digits,int idx,string s,unordered_map<char,string> &hash,vector<string> &res){\n        if(idx==digits.size()){\n            res.push_back(s);\n            return;\n        }\n        for(auto c:hash[digits[idx]]){\n            dfs(digits,idx+1,s+c,hash,res);\n        }\n    }\n};"
                    }
                ]
            },
            {
                "id": 1782442,
                "content": [
                    {
                        "username": "sk_aayush",
                        "content": "C++ SOLUTION | BEATS 100% | RECURSION USED\\n\\n\\nclass Solution {\\n    private:\\n    void solve(string digit, int index, string output, vector<string> &ans, string mapping[])\\n    {\\n        if(index>=digit.size())\\n        {\\n            ans.push_back(output);\\n            return;  \\n        }\\n\\n        int num = digit[index] - \\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0; i<value.length();i++)\\n       {\\n        output.push_back(value[i]);\\n        solve(digit, index+1, output, ans, mapping);\\n        output.pop_back();\\n        \\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.length()==0)\\n        return ans;\\n\\n        int index=0;\\n        string output=\"\";\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits, index, output, ans, mapping);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we use memoization for this problem?  I understand the backtracking approach (DFS or BFS). Can someone point me to a good explanation of using hash tables for memoization? I couldn\\'t find a good one in the solutions tab. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You have to store every letter combination string in a returnable array so I don't see how memoization can help - especially since no repeat calculations are being made."
                    },
                    {
                        "username": "msoni1369",
                        "content": "hashmap = { \"2\" : [\\'a\\', \\'b\\',\\'c\\'],\\n               \"3\" : [\\'d\\', \\'e\\', \\'f\\'],\\n               \"4\" : [\\'g\\', \\'h\\', \\'i\\'],\\n               \"5\" : [\"j\", \"k\", \"l\"],\\n               \"6\" : [\"m\", \"n\", \"o\"],\\n               \"7\" : [\"p\", \"q\", \"r\", \"s\"],\\n               \"8\" : [\"t\", \"u\", \"v\"],\\n               \"9\" : [\"w\", \"x\", \"y\", \"z\"] }\\n        temp = []\\n        for i in range(len(digits)):\\n            temp = digits[i]\\n        print(temp)\\n        temp = hashmap[str(temp)]\\n        print(temp)\\n        ans = []\\n        for i in range(len(digits)-2, -1, -1):\\n            temp2 = hashmap[digits[i]]\\n            ans = []\\n            for k in temp2:\\n                for j in temp:\\n                    st = k+j\\n                    ans.append(st)\\n            temp = ans\\n        return ans\\n\\nRuntime Error:\\nKeyError: \\'[]\\'\\n    temp = hashmap[str(temp)]\\nLine 15 in letterCombinations (Solution.py)\\n    ret = Solution().letterCombinations(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 58 in <module> (Solution.py)\\n\\nstdout:\\n3\\n[\\'d\\', \\'e\\', \\'f\\']\\n[]\\n\\nplease ignore the ans\\nfor this line \"print(temp)\" i am getting ans in stdout but why i am getting runtime error i am not able to get. even when i am using \"print(digits[0])\" i am getting same error but output is getting printed on screen. Can anyone help me figure what i am doing wrong\\n"
                    },
                    {
                        "username": "MohammadAliMiyan",
                        "content": "for any confusion, just search for \"Dsa love Babbar keypad problem\" , that\\'ll be enough if you are a beginner .\\n\\n`class Solution {\\n    private void solve(String digits,String output,int index,List<String> ans,String mapping[]){\\n        if(index>=digits.length()){\\n            ans.add(output);\\n            return;\\n        }\\n        // to check data type of a variable.;\\n        // ((Object)variableName).getClass().getSimpleName());\\n        int element = digits.charAt(index)-\\'0\\';\\n        String value = mapping[element];\\n        for(int i=0;i<value.length();i++){\\n            solve(digits,output+value.charAt(i),index+1,ans,mapping);\\n        }\\n\\n    }\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        String output = \"\";\\n        int index = 0;\\n        String mapping[] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        solve(digits,output,index,ans,mapping);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "meergato247",
                        "content": "I wish that the test cases ranged in difficulty from what to do with a simple input (empty string) to having multiple numbers, i.e. 234 because the problem statement isn\\'t too descriptive. "
                    },
                    {
                        "username": "princesingh01",
                        "content": "Hello has anyone  encountered this problem before.\nI am trying to add empty string into the empty Arraylist , Except leetcode everywhere the output is\nempty Arraylist (  [ ] )  but here Leetcode is providing arraylist with an empty string ( [ \"\" ] ) like this.\n\n public List<String> letterCombinations(String digits) {\n        String[] codes = {\"\",\"\", \"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        if(digits.isEmpty()){\n            List<String> base_array = new ArrayList<>();\n            base_array.add(\"\");  // it should return an empty Arraylist, ( [ ] ) \n            return base_array; // but returning ( [ \"\" ] ) \n        }"
                    },
                    {
                        "username": "deepu14d",
                        "content": "have you found some solution for this ?"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone expalin why I am getting this error for below code\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n`\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};\\n`\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone help me with whats wrong in the code below\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n `#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "BEATS 100% || C++ || Hash Map\n\n\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> res;\n        if(digits.empty()) return res;\n        unordered_map<char,string> hash{{'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},{'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"}};\n        string s;\n        dfs(digits,0,s,hash,res);\n        return res;\n    }\n    void dfs(string &digits,int idx,string s,unordered_map<char,string> &hash,vector<string> &res){\n        if(idx==digits.size()){\n            res.push_back(s);\n            return;\n        }\n        for(auto c:hash[digits[idx]]){\n            dfs(digits,idx+1,s+c,hash,res);\n        }\n    }\n};"
                    }
                ]
            },
            {
                "id": 1781146,
                "content": [
                    {
                        "username": "sk_aayush",
                        "content": "C++ SOLUTION | BEATS 100% | RECURSION USED\\n\\n\\nclass Solution {\\n    private:\\n    void solve(string digit, int index, string output, vector<string> &ans, string mapping[])\\n    {\\n        if(index>=digit.size())\\n        {\\n            ans.push_back(output);\\n            return;  \\n        }\\n\\n        int num = digit[index] - \\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0; i<value.length();i++)\\n       {\\n        output.push_back(value[i]);\\n        solve(digit, index+1, output, ans, mapping);\\n        output.pop_back();\\n        \\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.length()==0)\\n        return ans;\\n\\n        int index=0;\\n        string output=\"\";\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits, index, output, ans, mapping);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we use memoization for this problem?  I understand the backtracking approach (DFS or BFS). Can someone point me to a good explanation of using hash tables for memoization? I couldn\\'t find a good one in the solutions tab. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You have to store every letter combination string in a returnable array so I don't see how memoization can help - especially since no repeat calculations are being made."
                    },
                    {
                        "username": "msoni1369",
                        "content": "hashmap = { \"2\" : [\\'a\\', \\'b\\',\\'c\\'],\\n               \"3\" : [\\'d\\', \\'e\\', \\'f\\'],\\n               \"4\" : [\\'g\\', \\'h\\', \\'i\\'],\\n               \"5\" : [\"j\", \"k\", \"l\"],\\n               \"6\" : [\"m\", \"n\", \"o\"],\\n               \"7\" : [\"p\", \"q\", \"r\", \"s\"],\\n               \"8\" : [\"t\", \"u\", \"v\"],\\n               \"9\" : [\"w\", \"x\", \"y\", \"z\"] }\\n        temp = []\\n        for i in range(len(digits)):\\n            temp = digits[i]\\n        print(temp)\\n        temp = hashmap[str(temp)]\\n        print(temp)\\n        ans = []\\n        for i in range(len(digits)-2, -1, -1):\\n            temp2 = hashmap[digits[i]]\\n            ans = []\\n            for k in temp2:\\n                for j in temp:\\n                    st = k+j\\n                    ans.append(st)\\n            temp = ans\\n        return ans\\n\\nRuntime Error:\\nKeyError: \\'[]\\'\\n    temp = hashmap[str(temp)]\\nLine 15 in letterCombinations (Solution.py)\\n    ret = Solution().letterCombinations(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 58 in <module> (Solution.py)\\n\\nstdout:\\n3\\n[\\'d\\', \\'e\\', \\'f\\']\\n[]\\n\\nplease ignore the ans\\nfor this line \"print(temp)\" i am getting ans in stdout but why i am getting runtime error i am not able to get. even when i am using \"print(digits[0])\" i am getting same error but output is getting printed on screen. Can anyone help me figure what i am doing wrong\\n"
                    },
                    {
                        "username": "MohammadAliMiyan",
                        "content": "for any confusion, just search for \"Dsa love Babbar keypad problem\" , that\\'ll be enough if you are a beginner .\\n\\n`class Solution {\\n    private void solve(String digits,String output,int index,List<String> ans,String mapping[]){\\n        if(index>=digits.length()){\\n            ans.add(output);\\n            return;\\n        }\\n        // to check data type of a variable.;\\n        // ((Object)variableName).getClass().getSimpleName());\\n        int element = digits.charAt(index)-\\'0\\';\\n        String value = mapping[element];\\n        for(int i=0;i<value.length();i++){\\n            solve(digits,output+value.charAt(i),index+1,ans,mapping);\\n        }\\n\\n    }\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        String output = \"\";\\n        int index = 0;\\n        String mapping[] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        solve(digits,output,index,ans,mapping);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "meergato247",
                        "content": "I wish that the test cases ranged in difficulty from what to do with a simple input (empty string) to having multiple numbers, i.e. 234 because the problem statement isn\\'t too descriptive. "
                    },
                    {
                        "username": "princesingh01",
                        "content": "Hello has anyone  encountered this problem before.\nI am trying to add empty string into the empty Arraylist , Except leetcode everywhere the output is\nempty Arraylist (  [ ] )  but here Leetcode is providing arraylist with an empty string ( [ \"\" ] ) like this.\n\n public List<String> letterCombinations(String digits) {\n        String[] codes = {\"\",\"\", \"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        if(digits.isEmpty()){\n            List<String> base_array = new ArrayList<>();\n            base_array.add(\"\");  // it should return an empty Arraylist, ( [ ] ) \n            return base_array; // but returning ( [ \"\" ] ) \n        }"
                    },
                    {
                        "username": "deepu14d",
                        "content": "have you found some solution for this ?"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone expalin why I am getting this error for below code\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n`\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};\\n`\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone help me with whats wrong in the code below\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n `#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "BEATS 100% || C++ || Hash Map\n\n\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> res;\n        if(digits.empty()) return res;\n        unordered_map<char,string> hash{{'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},{'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"}};\n        string s;\n        dfs(digits,0,s,hash,res);\n        return res;\n    }\n    void dfs(string &digits,int idx,string s,unordered_map<char,string> &hash,vector<string> &res){\n        if(idx==digits.size()){\n            res.push_back(s);\n            return;\n        }\n        for(auto c:hash[digits[idx]]){\n            dfs(digits,idx+1,s+c,hash,res);\n        }\n    }\n};"
                    }
                ]
            },
            {
                "id": 1771697,
                "content": [
                    {
                        "username": "sk_aayush",
                        "content": "C++ SOLUTION | BEATS 100% | RECURSION USED\\n\\n\\nclass Solution {\\n    private:\\n    void solve(string digit, int index, string output, vector<string> &ans, string mapping[])\\n    {\\n        if(index>=digit.size())\\n        {\\n            ans.push_back(output);\\n            return;  \\n        }\\n\\n        int num = digit[index] - \\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0; i<value.length();i++)\\n       {\\n        output.push_back(value[i]);\\n        solve(digit, index+1, output, ans, mapping);\\n        output.pop_back();\\n        \\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.length()==0)\\n        return ans;\\n\\n        int index=0;\\n        string output=\"\";\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits, index, output, ans, mapping);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we use memoization for this problem?  I understand the backtracking approach (DFS or BFS). Can someone point me to a good explanation of using hash tables for memoization? I couldn\\'t find a good one in the solutions tab. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You have to store every letter combination string in a returnable array so I don't see how memoization can help - especially since no repeat calculations are being made."
                    },
                    {
                        "username": "msoni1369",
                        "content": "hashmap = { \"2\" : [\\'a\\', \\'b\\',\\'c\\'],\\n               \"3\" : [\\'d\\', \\'e\\', \\'f\\'],\\n               \"4\" : [\\'g\\', \\'h\\', \\'i\\'],\\n               \"5\" : [\"j\", \"k\", \"l\"],\\n               \"6\" : [\"m\", \"n\", \"o\"],\\n               \"7\" : [\"p\", \"q\", \"r\", \"s\"],\\n               \"8\" : [\"t\", \"u\", \"v\"],\\n               \"9\" : [\"w\", \"x\", \"y\", \"z\"] }\\n        temp = []\\n        for i in range(len(digits)):\\n            temp = digits[i]\\n        print(temp)\\n        temp = hashmap[str(temp)]\\n        print(temp)\\n        ans = []\\n        for i in range(len(digits)-2, -1, -1):\\n            temp2 = hashmap[digits[i]]\\n            ans = []\\n            for k in temp2:\\n                for j in temp:\\n                    st = k+j\\n                    ans.append(st)\\n            temp = ans\\n        return ans\\n\\nRuntime Error:\\nKeyError: \\'[]\\'\\n    temp = hashmap[str(temp)]\\nLine 15 in letterCombinations (Solution.py)\\n    ret = Solution().letterCombinations(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 58 in <module> (Solution.py)\\n\\nstdout:\\n3\\n[\\'d\\', \\'e\\', \\'f\\']\\n[]\\n\\nplease ignore the ans\\nfor this line \"print(temp)\" i am getting ans in stdout but why i am getting runtime error i am not able to get. even when i am using \"print(digits[0])\" i am getting same error but output is getting printed on screen. Can anyone help me figure what i am doing wrong\\n"
                    },
                    {
                        "username": "MohammadAliMiyan",
                        "content": "for any confusion, just search for \"Dsa love Babbar keypad problem\" , that\\'ll be enough if you are a beginner .\\n\\n`class Solution {\\n    private void solve(String digits,String output,int index,List<String> ans,String mapping[]){\\n        if(index>=digits.length()){\\n            ans.add(output);\\n            return;\\n        }\\n        // to check data type of a variable.;\\n        // ((Object)variableName).getClass().getSimpleName());\\n        int element = digits.charAt(index)-\\'0\\';\\n        String value = mapping[element];\\n        for(int i=0;i<value.length();i++){\\n            solve(digits,output+value.charAt(i),index+1,ans,mapping);\\n        }\\n\\n    }\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        String output = \"\";\\n        int index = 0;\\n        String mapping[] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        solve(digits,output,index,ans,mapping);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "meergato247",
                        "content": "I wish that the test cases ranged in difficulty from what to do with a simple input (empty string) to having multiple numbers, i.e. 234 because the problem statement isn\\'t too descriptive. "
                    },
                    {
                        "username": "princesingh01",
                        "content": "Hello has anyone  encountered this problem before.\nI am trying to add empty string into the empty Arraylist , Except leetcode everywhere the output is\nempty Arraylist (  [ ] )  but here Leetcode is providing arraylist with an empty string ( [ \"\" ] ) like this.\n\n public List<String> letterCombinations(String digits) {\n        String[] codes = {\"\",\"\", \"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        if(digits.isEmpty()){\n            List<String> base_array = new ArrayList<>();\n            base_array.add(\"\");  // it should return an empty Arraylist, ( [ ] ) \n            return base_array; // but returning ( [ \"\" ] ) \n        }"
                    },
                    {
                        "username": "deepu14d",
                        "content": "have you found some solution for this ?"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone expalin why I am getting this error for below code\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n`\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};\\n`\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone help me with whats wrong in the code below\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n `#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "BEATS 100% || C++ || Hash Map\n\n\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> res;\n        if(digits.empty()) return res;\n        unordered_map<char,string> hash{{'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},{'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"}};\n        string s;\n        dfs(digits,0,s,hash,res);\n        return res;\n    }\n    void dfs(string &digits,int idx,string s,unordered_map<char,string> &hash,vector<string> &res){\n        if(idx==digits.size()){\n            res.push_back(s);\n            return;\n        }\n        for(auto c:hash[digits[idx]]){\n            dfs(digits,idx+1,s+c,hash,res);\n        }\n    }\n};"
                    }
                ]
            },
            {
                "id": 1771690,
                "content": [
                    {
                        "username": "sk_aayush",
                        "content": "C++ SOLUTION | BEATS 100% | RECURSION USED\\n\\n\\nclass Solution {\\n    private:\\n    void solve(string digit, int index, string output, vector<string> &ans, string mapping[])\\n    {\\n        if(index>=digit.size())\\n        {\\n            ans.push_back(output);\\n            return;  \\n        }\\n\\n        int num = digit[index] - \\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0; i<value.length();i++)\\n       {\\n        output.push_back(value[i]);\\n        solve(digit, index+1, output, ans, mapping);\\n        output.pop_back();\\n        \\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.length()==0)\\n        return ans;\\n\\n        int index=0;\\n        string output=\"\";\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits, index, output, ans, mapping);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we use memoization for this problem?  I understand the backtracking approach (DFS or BFS). Can someone point me to a good explanation of using hash tables for memoization? I couldn\\'t find a good one in the solutions tab. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You have to store every letter combination string in a returnable array so I don't see how memoization can help - especially since no repeat calculations are being made."
                    },
                    {
                        "username": "msoni1369",
                        "content": "hashmap = { \"2\" : [\\'a\\', \\'b\\',\\'c\\'],\\n               \"3\" : [\\'d\\', \\'e\\', \\'f\\'],\\n               \"4\" : [\\'g\\', \\'h\\', \\'i\\'],\\n               \"5\" : [\"j\", \"k\", \"l\"],\\n               \"6\" : [\"m\", \"n\", \"o\"],\\n               \"7\" : [\"p\", \"q\", \"r\", \"s\"],\\n               \"8\" : [\"t\", \"u\", \"v\"],\\n               \"9\" : [\"w\", \"x\", \"y\", \"z\"] }\\n        temp = []\\n        for i in range(len(digits)):\\n            temp = digits[i]\\n        print(temp)\\n        temp = hashmap[str(temp)]\\n        print(temp)\\n        ans = []\\n        for i in range(len(digits)-2, -1, -1):\\n            temp2 = hashmap[digits[i]]\\n            ans = []\\n            for k in temp2:\\n                for j in temp:\\n                    st = k+j\\n                    ans.append(st)\\n            temp = ans\\n        return ans\\n\\nRuntime Error:\\nKeyError: \\'[]\\'\\n    temp = hashmap[str(temp)]\\nLine 15 in letterCombinations (Solution.py)\\n    ret = Solution().letterCombinations(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 58 in <module> (Solution.py)\\n\\nstdout:\\n3\\n[\\'d\\', \\'e\\', \\'f\\']\\n[]\\n\\nplease ignore the ans\\nfor this line \"print(temp)\" i am getting ans in stdout but why i am getting runtime error i am not able to get. even when i am using \"print(digits[0])\" i am getting same error but output is getting printed on screen. Can anyone help me figure what i am doing wrong\\n"
                    },
                    {
                        "username": "MohammadAliMiyan",
                        "content": "for any confusion, just search for \"Dsa love Babbar keypad problem\" , that\\'ll be enough if you are a beginner .\\n\\n`class Solution {\\n    private void solve(String digits,String output,int index,List<String> ans,String mapping[]){\\n        if(index>=digits.length()){\\n            ans.add(output);\\n            return;\\n        }\\n        // to check data type of a variable.;\\n        // ((Object)variableName).getClass().getSimpleName());\\n        int element = digits.charAt(index)-\\'0\\';\\n        String value = mapping[element];\\n        for(int i=0;i<value.length();i++){\\n            solve(digits,output+value.charAt(i),index+1,ans,mapping);\\n        }\\n\\n    }\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        String output = \"\";\\n        int index = 0;\\n        String mapping[] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        solve(digits,output,index,ans,mapping);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "meergato247",
                        "content": "I wish that the test cases ranged in difficulty from what to do with a simple input (empty string) to having multiple numbers, i.e. 234 because the problem statement isn\\'t too descriptive. "
                    },
                    {
                        "username": "princesingh01",
                        "content": "Hello has anyone  encountered this problem before.\nI am trying to add empty string into the empty Arraylist , Except leetcode everywhere the output is\nempty Arraylist (  [ ] )  but here Leetcode is providing arraylist with an empty string ( [ \"\" ] ) like this.\n\n public List<String> letterCombinations(String digits) {\n        String[] codes = {\"\",\"\", \"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        if(digits.isEmpty()){\n            List<String> base_array = new ArrayList<>();\n            base_array.add(\"\");  // it should return an empty Arraylist, ( [ ] ) \n            return base_array; // but returning ( [ \"\" ] ) \n        }"
                    },
                    {
                        "username": "deepu14d",
                        "content": "have you found some solution for this ?"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone expalin why I am getting this error for below code\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n`\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};\\n`\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone help me with whats wrong in the code below\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n `#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "BEATS 100% || C++ || Hash Map\n\n\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> res;\n        if(digits.empty()) return res;\n        unordered_map<char,string> hash{{'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},{'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"}};\n        string s;\n        dfs(digits,0,s,hash,res);\n        return res;\n    }\n    void dfs(string &digits,int idx,string s,unordered_map<char,string> &hash,vector<string> &res){\n        if(idx==digits.size()){\n            res.push_back(s);\n            return;\n        }\n        for(auto c:hash[digits[idx]]){\n            dfs(digits,idx+1,s+c,hash,res);\n        }\n    }\n};"
                    }
                ]
            },
            {
                "id": 1768438,
                "content": [
                    {
                        "username": "sk_aayush",
                        "content": "C++ SOLUTION | BEATS 100% | RECURSION USED\\n\\n\\nclass Solution {\\n    private:\\n    void solve(string digit, int index, string output, vector<string> &ans, string mapping[])\\n    {\\n        if(index>=digit.size())\\n        {\\n            ans.push_back(output);\\n            return;  \\n        }\\n\\n        int num = digit[index] - \\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0; i<value.length();i++)\\n       {\\n        output.push_back(value[i]);\\n        solve(digit, index+1, output, ans, mapping);\\n        output.pop_back();\\n        \\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.length()==0)\\n        return ans;\\n\\n        int index=0;\\n        string output=\"\";\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits, index, output, ans, mapping);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we use memoization for this problem?  I understand the backtracking approach (DFS or BFS). Can someone point me to a good explanation of using hash tables for memoization? I couldn\\'t find a good one in the solutions tab. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You have to store every letter combination string in a returnable array so I don't see how memoization can help - especially since no repeat calculations are being made."
                    },
                    {
                        "username": "msoni1369",
                        "content": "hashmap = { \"2\" : [\\'a\\', \\'b\\',\\'c\\'],\\n               \"3\" : [\\'d\\', \\'e\\', \\'f\\'],\\n               \"4\" : [\\'g\\', \\'h\\', \\'i\\'],\\n               \"5\" : [\"j\", \"k\", \"l\"],\\n               \"6\" : [\"m\", \"n\", \"o\"],\\n               \"7\" : [\"p\", \"q\", \"r\", \"s\"],\\n               \"8\" : [\"t\", \"u\", \"v\"],\\n               \"9\" : [\"w\", \"x\", \"y\", \"z\"] }\\n        temp = []\\n        for i in range(len(digits)):\\n            temp = digits[i]\\n        print(temp)\\n        temp = hashmap[str(temp)]\\n        print(temp)\\n        ans = []\\n        for i in range(len(digits)-2, -1, -1):\\n            temp2 = hashmap[digits[i]]\\n            ans = []\\n            for k in temp2:\\n                for j in temp:\\n                    st = k+j\\n                    ans.append(st)\\n            temp = ans\\n        return ans\\n\\nRuntime Error:\\nKeyError: \\'[]\\'\\n    temp = hashmap[str(temp)]\\nLine 15 in letterCombinations (Solution.py)\\n    ret = Solution().letterCombinations(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 58 in <module> (Solution.py)\\n\\nstdout:\\n3\\n[\\'d\\', \\'e\\', \\'f\\']\\n[]\\n\\nplease ignore the ans\\nfor this line \"print(temp)\" i am getting ans in stdout but why i am getting runtime error i am not able to get. even when i am using \"print(digits[0])\" i am getting same error but output is getting printed on screen. Can anyone help me figure what i am doing wrong\\n"
                    },
                    {
                        "username": "MohammadAliMiyan",
                        "content": "for any confusion, just search for \"Dsa love Babbar keypad problem\" , that\\'ll be enough if you are a beginner .\\n\\n`class Solution {\\n    private void solve(String digits,String output,int index,List<String> ans,String mapping[]){\\n        if(index>=digits.length()){\\n            ans.add(output);\\n            return;\\n        }\\n        // to check data type of a variable.;\\n        // ((Object)variableName).getClass().getSimpleName());\\n        int element = digits.charAt(index)-\\'0\\';\\n        String value = mapping[element];\\n        for(int i=0;i<value.length();i++){\\n            solve(digits,output+value.charAt(i),index+1,ans,mapping);\\n        }\\n\\n    }\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        String output = \"\";\\n        int index = 0;\\n        String mapping[] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        solve(digits,output,index,ans,mapping);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "meergato247",
                        "content": "I wish that the test cases ranged in difficulty from what to do with a simple input (empty string) to having multiple numbers, i.e. 234 because the problem statement isn\\'t too descriptive. "
                    },
                    {
                        "username": "princesingh01",
                        "content": "Hello has anyone  encountered this problem before.\nI am trying to add empty string into the empty Arraylist , Except leetcode everywhere the output is\nempty Arraylist (  [ ] )  but here Leetcode is providing arraylist with an empty string ( [ \"\" ] ) like this.\n\n public List<String> letterCombinations(String digits) {\n        String[] codes = {\"\",\"\", \"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        if(digits.isEmpty()){\n            List<String> base_array = new ArrayList<>();\n            base_array.add(\"\");  // it should return an empty Arraylist, ( [ ] ) \n            return base_array; // but returning ( [ \"\" ] ) \n        }"
                    },
                    {
                        "username": "deepu14d",
                        "content": "have you found some solution for this ?"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone expalin why I am getting this error for below code\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n`\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};\\n`\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone help me with whats wrong in the code below\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n `#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "BEATS 100% || C++ || Hash Map\n\n\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> res;\n        if(digits.empty()) return res;\n        unordered_map<char,string> hash{{'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},{'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"}};\n        string s;\n        dfs(digits,0,s,hash,res);\n        return res;\n    }\n    void dfs(string &digits,int idx,string s,unordered_map<char,string> &hash,vector<string> &res){\n        if(idx==digits.size()){\n            res.push_back(s);\n            return;\n        }\n        for(auto c:hash[digits[idx]]){\n            dfs(digits,idx+1,s+c,hash,res);\n        }\n    }\n};"
                    }
                ]
            },
            {
                "id": 1767670,
                "content": [
                    {
                        "username": "sk_aayush",
                        "content": "C++ SOLUTION | BEATS 100% | RECURSION USED\\n\\n\\nclass Solution {\\n    private:\\n    void solve(string digit, int index, string output, vector<string> &ans, string mapping[])\\n    {\\n        if(index>=digit.size())\\n        {\\n            ans.push_back(output);\\n            return;  \\n        }\\n\\n        int num = digit[index] - \\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0; i<value.length();i++)\\n       {\\n        output.push_back(value[i]);\\n        solve(digit, index+1, output, ans, mapping);\\n        output.pop_back();\\n        \\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if(digits.length()==0)\\n        return ans;\\n\\n        int index=0;\\n        string output=\"\";\\n        string mapping[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits, index, output, ans, mapping);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we use memoization for this problem?  I understand the backtracking approach (DFS or BFS). Can someone point me to a good explanation of using hash tables for memoization? I couldn\\'t find a good one in the solutions tab. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You have to store every letter combination string in a returnable array so I don't see how memoization can help - especially since no repeat calculations are being made."
                    },
                    {
                        "username": "msoni1369",
                        "content": "hashmap = { \"2\" : [\\'a\\', \\'b\\',\\'c\\'],\\n               \"3\" : [\\'d\\', \\'e\\', \\'f\\'],\\n               \"4\" : [\\'g\\', \\'h\\', \\'i\\'],\\n               \"5\" : [\"j\", \"k\", \"l\"],\\n               \"6\" : [\"m\", \"n\", \"o\"],\\n               \"7\" : [\"p\", \"q\", \"r\", \"s\"],\\n               \"8\" : [\"t\", \"u\", \"v\"],\\n               \"9\" : [\"w\", \"x\", \"y\", \"z\"] }\\n        temp = []\\n        for i in range(len(digits)):\\n            temp = digits[i]\\n        print(temp)\\n        temp = hashmap[str(temp)]\\n        print(temp)\\n        ans = []\\n        for i in range(len(digits)-2, -1, -1):\\n            temp2 = hashmap[digits[i]]\\n            ans = []\\n            for k in temp2:\\n                for j in temp:\\n                    st = k+j\\n                    ans.append(st)\\n            temp = ans\\n        return ans\\n\\nRuntime Error:\\nKeyError: \\'[]\\'\\n    temp = hashmap[str(temp)]\\nLine 15 in letterCombinations (Solution.py)\\n    ret = Solution().letterCombinations(param_1)\\nLine 47 in _driver (Solution.py)\\n    _driver()\\nLine 58 in <module> (Solution.py)\\n\\nstdout:\\n3\\n[\\'d\\', \\'e\\', \\'f\\']\\n[]\\n\\nplease ignore the ans\\nfor this line \"print(temp)\" i am getting ans in stdout but why i am getting runtime error i am not able to get. even when i am using \"print(digits[0])\" i am getting same error but output is getting printed on screen. Can anyone help me figure what i am doing wrong\\n"
                    },
                    {
                        "username": "MohammadAliMiyan",
                        "content": "for any confusion, just search for \"Dsa love Babbar keypad problem\" , that\\'ll be enough if you are a beginner .\\n\\n`class Solution {\\n    private void solve(String digits,String output,int index,List<String> ans,String mapping[]){\\n        if(index>=digits.length()){\\n            ans.add(output);\\n            return;\\n        }\\n        // to check data type of a variable.;\\n        // ((Object)variableName).getClass().getSimpleName());\\n        int element = digits.charAt(index)-\\'0\\';\\n        String value = mapping[element];\\n        for(int i=0;i<value.length();i++){\\n            solve(digits,output+value.charAt(i),index+1,ans,mapping);\\n        }\\n\\n    }\\n\\n    public List<String> letterCombinations(String digits) {\\n        List<String> ans = new ArrayList<>();\\n        String output = \"\";\\n        int index = 0;\\n        String mapping[] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digits.length()==0){\\n            return ans;\\n        }\\n        solve(digits,output,index,ans,mapping);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "meergato247",
                        "content": "I wish that the test cases ranged in difficulty from what to do with a simple input (empty string) to having multiple numbers, i.e. 234 because the problem statement isn\\'t too descriptive. "
                    },
                    {
                        "username": "princesingh01",
                        "content": "Hello has anyone  encountered this problem before.\nI am trying to add empty string into the empty Arraylist , Except leetcode everywhere the output is\nempty Arraylist (  [ ] )  but here Leetcode is providing arraylist with an empty string ( [ \"\" ] ) like this.\n\n public List<String> letterCombinations(String digits) {\n        String[] codes = {\"\",\"\", \"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        if(digits.isEmpty()){\n            List<String> base_array = new ArrayList<>();\n            base_array.add(\"\");  // it should return an empty Arraylist, ( [ ] ) \n            return base_array; // but returning ( [ \"\" ] ) \n        }"
                    },
                    {
                        "username": "deepu14d",
                        "content": "have you found some solution for this ?"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone expalin why I am getting this error for below code\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n`\\n#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};\\n`\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "Can anyone help me with whats wrong in the code below\\n\\nERROR IS\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::__cxx11::basic_string<char>\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\n\\n `#include<bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<string> map_number_to_string(string phonedigits){\\n        map<char, string> phonestring;\\n        phonestring[\\'2\\']=\"abc\";\\n        phonestring[\\'3\\']=\"def\";\\n        phonestring[\\'4\\']=\"ghi\";\\n        phonestring[\\'5\\']=\"jkl\";\\n        phonestring[\\'6\\']=\"mno\";\\n        phonestring[\\'7\\']=\"pqrs\";\\n        phonestring[\\'8\\']=\"tuv\";\\n        phonestring[\\'9\\']=\"wxyz\";\\n        \\n        vector<string> allcombo;\\n        for(auto eachdigit : phonedigits){ //2  3 4\\n\\n\\n\\n            string c; //  for converting char to string\\n            //cout<< \"strings are \" << phonestring[string(1, eachdigit)]<< endl; //// it will convert all the phone digits to string,\\n            allcombo.push_back(phonestring[eachdigit]); // always remember it should be push_back not push\\n        }\\n        return allcombo;\\n    }\\n\\n    vector<string> print_allpossible(vector<string> allcombo){\\n        string s1;\\n        string s2;\\n        s1=allcombo[0];\\n        s2=allcombo[1];\\n        \\n        vector<string> ansarray;\\n        \\n        for(auto i : s1){\\n            for(auto j: s2){\\n                string c;\\n                string d;\\n                c=i+c;\\n                d=j+d;\\n                ansarray.push_back(c+d);\\n            }\\n        }\\n        \\n        for(auto eachelementofans : ansarray){\\n            cout<< eachelementofans << \" \";\\n        }\\n        \\n        return ansarray;\\n    }\\n\\n    vector<string> letterCombinations(string digits) {   \\n        vector<string> arrayofallcombosstring;\\n        vector<string> finalansarray;\\n        arrayofallcombosstring = map_number_to_string(digits);\\n        finalansarray = print_allpossible(arrayofallcombosstring);\\n        return finalansarray;\\n    };\\n};`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "BEATS 100% || C++ || Hash Map\n\n\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> res;\n        if(digits.empty()) return res;\n        unordered_map<char,string> hash{{'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},{'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"}};\n        string s;\n        dfs(digits,0,s,hash,res);\n        return res;\n    }\n    void dfs(string &digits,int idx,string s,unordered_map<char,string> &hash,vector<string> &res){\n        if(idx==digits.size()){\n            res.push_back(s);\n            return;\n        }\n        for(auto c:hash[digits[idx]]){\n            dfs(digits,idx+1,s+c,hash,res);\n        }\n    }\n};"
                    }
                ]
            },
            {
                "id": 1765150,
                "content": [
                    {
                        "username": "easonteong",
                        "content": "Debug Code for C programmers\\n```\\nint main(int argc, const char * argv[]) {\\n    int* returnSize = (int*)malloc(1*sizeof(int));\\n    char** answer = letterCombinations(\"7\", returnSize);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        for(int j = 0; answer[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            printf(\"%c\",answer[i][j]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\n```"
                    },
                    {
                        "username": "boluodueke2020",
                        "content": "Why am I getting an error for using a formatted string? \\nRunning the same code on jupyter notebook gives the correct outputs, but running here its hanging on the point where the formatted string is.\\nAnd whenever I remove that, it reverses the order of the individual entries of the output......"
                    },
                    {
                        "username": "user7740h",
                        "content": "class Solution {\\npublic:\\n    void GP(vector<string> &g,vector<string> v,string str,string digits,int index){\\n        if(index==digits.length()) {\\n            g.push_back(str);\\n            cout<<str<<\" \";\\n        }else{\\n            for(char temp:v[int(digits[index] - \\'0\\')]){\\n                GP(g,v,str+temp,digits,index+1);\\n            }\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> v{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        vector<string> g;\\n        string str=\"\";\\n        for(char temp:v[int(digits[0] - \\'0\\')]){\\n            cout<<temp<<\":\";\\n            GP(g,v,str+temp,digits,1);\\n        }\\n        // for(string temp:g)\\n        //     cout<<temp<<\" \";  \\n    return g;        \\n    }\\n};\\n\\nWhy this code is giving this run time error\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6120000013c0 overflowed to 0x612000000dc0 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "class Solution {\\n    private:\\n    void solve(string digit ,string output , int index , vector<string>& ans, string mapping[])\\n    {\\n        //base case\\n        if(index>=digit.length())\\n        {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        int number = digit[index] - \\'0\\';\\n        string value = mapping[number];\\n        for(int i = 0 ; i<value.length() ; i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digit , output , index + 1 , ans , mapping);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans ;\\n        if(digits.length()==0)\\n        return ans;\\n        string output =\"\";\\n        int index = 0 ;\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits , output , index , ans , mapping);\\n        return ans ; \\n    }\\n};\\nBest C++ solution "
                    },
                    {
                        "username": "harshkumar123",
                        "content": "100% beats\\nclass Solution {\\npublic:\\nvector<string> helper(int b){\\n if(b==2){\\n     vector<string>a;\\n     a.push_back(\"a\");\\n     a.push_back(\"b\");\\n     a.push_back(\"c\");\\n     return a;\\n }\\n if(b==3){\\n      vector<string>a;\\n     a.push_back(\"d\");\\n     a.push_back(\"e\");\\n     a.push_back(\"f\");\\n     return a;\\n } \\nif(b==4){\\n      vector<string>a;\\n     a.push_back(\"g\");\\n     a.push_back(\"h\");\\n     a.push_back(\"i\");\\n     return a;\\n } \\n if(b==5){\\n      vector<string>a;\\n     a.push_back(\"j\");\\n     a.push_back(\"k\");\\n     a.push_back(\"l\");\\n     return a;\\n } \\n if(b==6){\\n      vector<string>a;\\n     a.push_back(\"m\");\\n     a.push_back(\"n\");\\n     a.push_back(\"o\");\\n     return a;\\n } \\n if(b==7){\\n      vector<string>a;\\n     a.push_back(\"p\");\\n     a.push_back(\"q\");\\n     a.push_back(\"r\");\\n     a.push_back(\"s\");\\n     return a;\\n } \\n if(b==8){\\n      vector<string>a;\\n     a.push_back(\"t\");\\n     a.push_back(\"u\");\\n     a.push_back(\"v\");\\n     return a;\\n } \\nif(b==9){\\n      vector<string>a;\\n     a.push_back(\"w\");\\n     a.push_back(\"x\");\\n     a.push_back(\"y\");\\n     a.push_back(\"z\");\\n     return a;\\n }\\n vector<string>a;\\n return a;\\n}\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size()==0){\\n            vector<string>ans;\\n            return ans;\\n        }\\n        if(digits.size()==1){\\n        \\n        int a=digits[0]-48;\\n           \\n            return helper(a);\\n        }\\n        vector<string>ans=letterCombinations(digits.substr(1));\\n        int z=digits[0]-48;\\n        vector<string> a=helper(z);\\n        vector<string>answer;\\n        for(int i=0;i<a.size();i++){\\n    \\n            for(int j=0;j<ans.size();j++){\\n              string s=a[i]+ans[j];\\n              answer.push_back(s);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\ncomment for any doubts"
                    },
                    {
                        "username": "samikshhh",
                        "content": "no viable conversion from \\'std::string\\' (aka \\'basic_string<char>\\') to \\'char\\'\\n\\nI am geting this error i dont know why.\\n\\nMy code is 100 % right i have cross checked it many time."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution(object):\\n    \\n    def main(self, digits):\\n        h={\\'2\\':[\\'a\\',\\'b\\',\\'c\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'4\\':[\\'g\\',\\'h\\',\\'i\\'],\\n           \\'5\\':[\\'j\\',\\'k\\',\\'l\\'],\\n           \\'6\\':[\\'m\\',\\'n\\',\\'o\\'],\\n           \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'],\\n           \\'8\\':[\\'t\\',\\'u\\',\\'v\\'],\\n           \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        l=[]\\n        return self.answer(h,digits,l,\"\",0)\\n\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.main(digits)\\n        \\n    \\n    def answer(self,h,digit,l,state,count):\\n        # print(l)\\n        n=len(digit)\\n        if len(state)==n:\\n            print(\"base\")\\n            l.append(copy.copy(state))\\n            count=0\\n            state=\"\"\\n            return \\n        # for i in range(count,len(digit)):\\n        else:\\n            print(\"count=\",count)\\n            k=h[digit[count]]\\n            for j in k:\\n                # print(k)\\n                state=state+j\\n            \\n                count=count+1\\n                print(\"count add=\",count)\\n                self.answer(h,digit,l,state,count)\\n                print(\"stateb=\",state)\\n                state=state[:-1]\\n                count=count-1\\n                print(\"count sub=\",count)\\n                print(\"statea=\",state)\\n            return l\\n\\n"
                    },
                    {
                        "username": "neo9729",
                        "content": "Can someone explain how does the time complexity is 4^n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each digit maps into as many as 4 letters so that is 4^n letter combinations - each of which must be stored."
                    },
                    {
                        "username": "h4o4",
                        "content": "recursion is the most elegant solution imo\\n\\n```python\\nfor partialResult in self.letterCombinations(digits[:-1]):\\n    for c in digitToLetters[digits[-1]]:\\n        result.append(partialResult + c)\\n```"
                    },
                    {
                        "username": "Harshi26",
                        "content": "```class Solution {\\npublic:\\n    void solve(string digits, string output, int index, vector<string>& ans, string mapping[]){\\n        //base case\\n        if(index>=digits.length()){\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int num = digits[index]-\\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0;i<value.length();i++){\\n            output.push_back(value[i]);\\n            solve(digits,output,index+1,ans,mapping);\\n            output.pop_back();\\n        }\\n\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        \\n        if(digits.length()==0)\\n            return ans;\\n\\n        string output = \"\";\\n        int index = 0;\\n        \\n        //mapping\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n\\n        solve(digits, output, index, ans, mapping);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 1763532,
                "content": [
                    {
                        "username": "easonteong",
                        "content": "Debug Code for C programmers\\n```\\nint main(int argc, const char * argv[]) {\\n    int* returnSize = (int*)malloc(1*sizeof(int));\\n    char** answer = letterCombinations(\"7\", returnSize);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        for(int j = 0; answer[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            printf(\"%c\",answer[i][j]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\n```"
                    },
                    {
                        "username": "boluodueke2020",
                        "content": "Why am I getting an error for using a formatted string? \\nRunning the same code on jupyter notebook gives the correct outputs, but running here its hanging on the point where the formatted string is.\\nAnd whenever I remove that, it reverses the order of the individual entries of the output......"
                    },
                    {
                        "username": "user7740h",
                        "content": "class Solution {\\npublic:\\n    void GP(vector<string> &g,vector<string> v,string str,string digits,int index){\\n        if(index==digits.length()) {\\n            g.push_back(str);\\n            cout<<str<<\" \";\\n        }else{\\n            for(char temp:v[int(digits[index] - \\'0\\')]){\\n                GP(g,v,str+temp,digits,index+1);\\n            }\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> v{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        vector<string> g;\\n        string str=\"\";\\n        for(char temp:v[int(digits[0] - \\'0\\')]){\\n            cout<<temp<<\":\";\\n            GP(g,v,str+temp,digits,1);\\n        }\\n        // for(string temp:g)\\n        //     cout<<temp<<\" \";  \\n    return g;        \\n    }\\n};\\n\\nWhy this code is giving this run time error\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6120000013c0 overflowed to 0x612000000dc0 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "class Solution {\\n    private:\\n    void solve(string digit ,string output , int index , vector<string>& ans, string mapping[])\\n    {\\n        //base case\\n        if(index>=digit.length())\\n        {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        int number = digit[index] - \\'0\\';\\n        string value = mapping[number];\\n        for(int i = 0 ; i<value.length() ; i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digit , output , index + 1 , ans , mapping);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans ;\\n        if(digits.length()==0)\\n        return ans;\\n        string output =\"\";\\n        int index = 0 ;\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits , output , index , ans , mapping);\\n        return ans ; \\n    }\\n};\\nBest C++ solution "
                    },
                    {
                        "username": "harshkumar123",
                        "content": "100% beats\\nclass Solution {\\npublic:\\nvector<string> helper(int b){\\n if(b==2){\\n     vector<string>a;\\n     a.push_back(\"a\");\\n     a.push_back(\"b\");\\n     a.push_back(\"c\");\\n     return a;\\n }\\n if(b==3){\\n      vector<string>a;\\n     a.push_back(\"d\");\\n     a.push_back(\"e\");\\n     a.push_back(\"f\");\\n     return a;\\n } \\nif(b==4){\\n      vector<string>a;\\n     a.push_back(\"g\");\\n     a.push_back(\"h\");\\n     a.push_back(\"i\");\\n     return a;\\n } \\n if(b==5){\\n      vector<string>a;\\n     a.push_back(\"j\");\\n     a.push_back(\"k\");\\n     a.push_back(\"l\");\\n     return a;\\n } \\n if(b==6){\\n      vector<string>a;\\n     a.push_back(\"m\");\\n     a.push_back(\"n\");\\n     a.push_back(\"o\");\\n     return a;\\n } \\n if(b==7){\\n      vector<string>a;\\n     a.push_back(\"p\");\\n     a.push_back(\"q\");\\n     a.push_back(\"r\");\\n     a.push_back(\"s\");\\n     return a;\\n } \\n if(b==8){\\n      vector<string>a;\\n     a.push_back(\"t\");\\n     a.push_back(\"u\");\\n     a.push_back(\"v\");\\n     return a;\\n } \\nif(b==9){\\n      vector<string>a;\\n     a.push_back(\"w\");\\n     a.push_back(\"x\");\\n     a.push_back(\"y\");\\n     a.push_back(\"z\");\\n     return a;\\n }\\n vector<string>a;\\n return a;\\n}\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size()==0){\\n            vector<string>ans;\\n            return ans;\\n        }\\n        if(digits.size()==1){\\n        \\n        int a=digits[0]-48;\\n           \\n            return helper(a);\\n        }\\n        vector<string>ans=letterCombinations(digits.substr(1));\\n        int z=digits[0]-48;\\n        vector<string> a=helper(z);\\n        vector<string>answer;\\n        for(int i=0;i<a.size();i++){\\n    \\n            for(int j=0;j<ans.size();j++){\\n              string s=a[i]+ans[j];\\n              answer.push_back(s);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\ncomment for any doubts"
                    },
                    {
                        "username": "samikshhh",
                        "content": "no viable conversion from \\'std::string\\' (aka \\'basic_string<char>\\') to \\'char\\'\\n\\nI am geting this error i dont know why.\\n\\nMy code is 100 % right i have cross checked it many time."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution(object):\\n    \\n    def main(self, digits):\\n        h={\\'2\\':[\\'a\\',\\'b\\',\\'c\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'4\\':[\\'g\\',\\'h\\',\\'i\\'],\\n           \\'5\\':[\\'j\\',\\'k\\',\\'l\\'],\\n           \\'6\\':[\\'m\\',\\'n\\',\\'o\\'],\\n           \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'],\\n           \\'8\\':[\\'t\\',\\'u\\',\\'v\\'],\\n           \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        l=[]\\n        return self.answer(h,digits,l,\"\",0)\\n\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.main(digits)\\n        \\n    \\n    def answer(self,h,digit,l,state,count):\\n        # print(l)\\n        n=len(digit)\\n        if len(state)==n:\\n            print(\"base\")\\n            l.append(copy.copy(state))\\n            count=0\\n            state=\"\"\\n            return \\n        # for i in range(count,len(digit)):\\n        else:\\n            print(\"count=\",count)\\n            k=h[digit[count]]\\n            for j in k:\\n                # print(k)\\n                state=state+j\\n            \\n                count=count+1\\n                print(\"count add=\",count)\\n                self.answer(h,digit,l,state,count)\\n                print(\"stateb=\",state)\\n                state=state[:-1]\\n                count=count-1\\n                print(\"count sub=\",count)\\n                print(\"statea=\",state)\\n            return l\\n\\n"
                    },
                    {
                        "username": "neo9729",
                        "content": "Can someone explain how does the time complexity is 4^n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each digit maps into as many as 4 letters so that is 4^n letter combinations - each of which must be stored."
                    },
                    {
                        "username": "h4o4",
                        "content": "recursion is the most elegant solution imo\\n\\n```python\\nfor partialResult in self.letterCombinations(digits[:-1]):\\n    for c in digitToLetters[digits[-1]]:\\n        result.append(partialResult + c)\\n```"
                    },
                    {
                        "username": "Harshi26",
                        "content": "```class Solution {\\npublic:\\n    void solve(string digits, string output, int index, vector<string>& ans, string mapping[]){\\n        //base case\\n        if(index>=digits.length()){\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int num = digits[index]-\\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0;i<value.length();i++){\\n            output.push_back(value[i]);\\n            solve(digits,output,index+1,ans,mapping);\\n            output.pop_back();\\n        }\\n\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        \\n        if(digits.length()==0)\\n            return ans;\\n\\n        string output = \"\";\\n        int index = 0;\\n        \\n        //mapping\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n\\n        solve(digits, output, index, ans, mapping);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 1757483,
                "content": [
                    {
                        "username": "easonteong",
                        "content": "Debug Code for C programmers\\n```\\nint main(int argc, const char * argv[]) {\\n    int* returnSize = (int*)malloc(1*sizeof(int));\\n    char** answer = letterCombinations(\"7\", returnSize);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        for(int j = 0; answer[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            printf(\"%c\",answer[i][j]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\n```"
                    },
                    {
                        "username": "boluodueke2020",
                        "content": "Why am I getting an error for using a formatted string? \\nRunning the same code on jupyter notebook gives the correct outputs, but running here its hanging on the point where the formatted string is.\\nAnd whenever I remove that, it reverses the order of the individual entries of the output......"
                    },
                    {
                        "username": "user7740h",
                        "content": "class Solution {\\npublic:\\n    void GP(vector<string> &g,vector<string> v,string str,string digits,int index){\\n        if(index==digits.length()) {\\n            g.push_back(str);\\n            cout<<str<<\" \";\\n        }else{\\n            for(char temp:v[int(digits[index] - \\'0\\')]){\\n                GP(g,v,str+temp,digits,index+1);\\n            }\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> v{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        vector<string> g;\\n        string str=\"\";\\n        for(char temp:v[int(digits[0] - \\'0\\')]){\\n            cout<<temp<<\":\";\\n            GP(g,v,str+temp,digits,1);\\n        }\\n        // for(string temp:g)\\n        //     cout<<temp<<\" \";  \\n    return g;        \\n    }\\n};\\n\\nWhy this code is giving this run time error\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6120000013c0 overflowed to 0x612000000dc0 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "class Solution {\\n    private:\\n    void solve(string digit ,string output , int index , vector<string>& ans, string mapping[])\\n    {\\n        //base case\\n        if(index>=digit.length())\\n        {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        int number = digit[index] - \\'0\\';\\n        string value = mapping[number];\\n        for(int i = 0 ; i<value.length() ; i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digit , output , index + 1 , ans , mapping);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans ;\\n        if(digits.length()==0)\\n        return ans;\\n        string output =\"\";\\n        int index = 0 ;\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits , output , index , ans , mapping);\\n        return ans ; \\n    }\\n};\\nBest C++ solution "
                    },
                    {
                        "username": "harshkumar123",
                        "content": "100% beats\\nclass Solution {\\npublic:\\nvector<string> helper(int b){\\n if(b==2){\\n     vector<string>a;\\n     a.push_back(\"a\");\\n     a.push_back(\"b\");\\n     a.push_back(\"c\");\\n     return a;\\n }\\n if(b==3){\\n      vector<string>a;\\n     a.push_back(\"d\");\\n     a.push_back(\"e\");\\n     a.push_back(\"f\");\\n     return a;\\n } \\nif(b==4){\\n      vector<string>a;\\n     a.push_back(\"g\");\\n     a.push_back(\"h\");\\n     a.push_back(\"i\");\\n     return a;\\n } \\n if(b==5){\\n      vector<string>a;\\n     a.push_back(\"j\");\\n     a.push_back(\"k\");\\n     a.push_back(\"l\");\\n     return a;\\n } \\n if(b==6){\\n      vector<string>a;\\n     a.push_back(\"m\");\\n     a.push_back(\"n\");\\n     a.push_back(\"o\");\\n     return a;\\n } \\n if(b==7){\\n      vector<string>a;\\n     a.push_back(\"p\");\\n     a.push_back(\"q\");\\n     a.push_back(\"r\");\\n     a.push_back(\"s\");\\n     return a;\\n } \\n if(b==8){\\n      vector<string>a;\\n     a.push_back(\"t\");\\n     a.push_back(\"u\");\\n     a.push_back(\"v\");\\n     return a;\\n } \\nif(b==9){\\n      vector<string>a;\\n     a.push_back(\"w\");\\n     a.push_back(\"x\");\\n     a.push_back(\"y\");\\n     a.push_back(\"z\");\\n     return a;\\n }\\n vector<string>a;\\n return a;\\n}\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size()==0){\\n            vector<string>ans;\\n            return ans;\\n        }\\n        if(digits.size()==1){\\n        \\n        int a=digits[0]-48;\\n           \\n            return helper(a);\\n        }\\n        vector<string>ans=letterCombinations(digits.substr(1));\\n        int z=digits[0]-48;\\n        vector<string> a=helper(z);\\n        vector<string>answer;\\n        for(int i=0;i<a.size();i++){\\n    \\n            for(int j=0;j<ans.size();j++){\\n              string s=a[i]+ans[j];\\n              answer.push_back(s);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\ncomment for any doubts"
                    },
                    {
                        "username": "samikshhh",
                        "content": "no viable conversion from \\'std::string\\' (aka \\'basic_string<char>\\') to \\'char\\'\\n\\nI am geting this error i dont know why.\\n\\nMy code is 100 % right i have cross checked it many time."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution(object):\\n    \\n    def main(self, digits):\\n        h={\\'2\\':[\\'a\\',\\'b\\',\\'c\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'4\\':[\\'g\\',\\'h\\',\\'i\\'],\\n           \\'5\\':[\\'j\\',\\'k\\',\\'l\\'],\\n           \\'6\\':[\\'m\\',\\'n\\',\\'o\\'],\\n           \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'],\\n           \\'8\\':[\\'t\\',\\'u\\',\\'v\\'],\\n           \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        l=[]\\n        return self.answer(h,digits,l,\"\",0)\\n\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.main(digits)\\n        \\n    \\n    def answer(self,h,digit,l,state,count):\\n        # print(l)\\n        n=len(digit)\\n        if len(state)==n:\\n            print(\"base\")\\n            l.append(copy.copy(state))\\n            count=0\\n            state=\"\"\\n            return \\n        # for i in range(count,len(digit)):\\n        else:\\n            print(\"count=\",count)\\n            k=h[digit[count]]\\n            for j in k:\\n                # print(k)\\n                state=state+j\\n            \\n                count=count+1\\n                print(\"count add=\",count)\\n                self.answer(h,digit,l,state,count)\\n                print(\"stateb=\",state)\\n                state=state[:-1]\\n                count=count-1\\n                print(\"count sub=\",count)\\n                print(\"statea=\",state)\\n            return l\\n\\n"
                    },
                    {
                        "username": "neo9729",
                        "content": "Can someone explain how does the time complexity is 4^n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each digit maps into as many as 4 letters so that is 4^n letter combinations - each of which must be stored."
                    },
                    {
                        "username": "h4o4",
                        "content": "recursion is the most elegant solution imo\\n\\n```python\\nfor partialResult in self.letterCombinations(digits[:-1]):\\n    for c in digitToLetters[digits[-1]]:\\n        result.append(partialResult + c)\\n```"
                    },
                    {
                        "username": "Harshi26",
                        "content": "```class Solution {\\npublic:\\n    void solve(string digits, string output, int index, vector<string>& ans, string mapping[]){\\n        //base case\\n        if(index>=digits.length()){\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int num = digits[index]-\\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0;i<value.length();i++){\\n            output.push_back(value[i]);\\n            solve(digits,output,index+1,ans,mapping);\\n            output.pop_back();\\n        }\\n\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        \\n        if(digits.length()==0)\\n            return ans;\\n\\n        string output = \"\";\\n        int index = 0;\\n        \\n        //mapping\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n\\n        solve(digits, output, index, ans, mapping);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 1729209,
                "content": [
                    {
                        "username": "easonteong",
                        "content": "Debug Code for C programmers\\n```\\nint main(int argc, const char * argv[]) {\\n    int* returnSize = (int*)malloc(1*sizeof(int));\\n    char** answer = letterCombinations(\"7\", returnSize);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        for(int j = 0; answer[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            printf(\"%c\",answer[i][j]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\n```"
                    },
                    {
                        "username": "boluodueke2020",
                        "content": "Why am I getting an error for using a formatted string? \\nRunning the same code on jupyter notebook gives the correct outputs, but running here its hanging on the point where the formatted string is.\\nAnd whenever I remove that, it reverses the order of the individual entries of the output......"
                    },
                    {
                        "username": "user7740h",
                        "content": "class Solution {\\npublic:\\n    void GP(vector<string> &g,vector<string> v,string str,string digits,int index){\\n        if(index==digits.length()) {\\n            g.push_back(str);\\n            cout<<str<<\" \";\\n        }else{\\n            for(char temp:v[int(digits[index] - \\'0\\')]){\\n                GP(g,v,str+temp,digits,index+1);\\n            }\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> v{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        vector<string> g;\\n        string str=\"\";\\n        for(char temp:v[int(digits[0] - \\'0\\')]){\\n            cout<<temp<<\":\";\\n            GP(g,v,str+temp,digits,1);\\n        }\\n        // for(string temp:g)\\n        //     cout<<temp<<\" \";  \\n    return g;        \\n    }\\n};\\n\\nWhy this code is giving this run time error\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6120000013c0 overflowed to 0x612000000dc0 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "class Solution {\\n    private:\\n    void solve(string digit ,string output , int index , vector<string>& ans, string mapping[])\\n    {\\n        //base case\\n        if(index>=digit.length())\\n        {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        int number = digit[index] - \\'0\\';\\n        string value = mapping[number];\\n        for(int i = 0 ; i<value.length() ; i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digit , output , index + 1 , ans , mapping);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans ;\\n        if(digits.length()==0)\\n        return ans;\\n        string output =\"\";\\n        int index = 0 ;\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits , output , index , ans , mapping);\\n        return ans ; \\n    }\\n};\\nBest C++ solution "
                    },
                    {
                        "username": "harshkumar123",
                        "content": "100% beats\\nclass Solution {\\npublic:\\nvector<string> helper(int b){\\n if(b==2){\\n     vector<string>a;\\n     a.push_back(\"a\");\\n     a.push_back(\"b\");\\n     a.push_back(\"c\");\\n     return a;\\n }\\n if(b==3){\\n      vector<string>a;\\n     a.push_back(\"d\");\\n     a.push_back(\"e\");\\n     a.push_back(\"f\");\\n     return a;\\n } \\nif(b==4){\\n      vector<string>a;\\n     a.push_back(\"g\");\\n     a.push_back(\"h\");\\n     a.push_back(\"i\");\\n     return a;\\n } \\n if(b==5){\\n      vector<string>a;\\n     a.push_back(\"j\");\\n     a.push_back(\"k\");\\n     a.push_back(\"l\");\\n     return a;\\n } \\n if(b==6){\\n      vector<string>a;\\n     a.push_back(\"m\");\\n     a.push_back(\"n\");\\n     a.push_back(\"o\");\\n     return a;\\n } \\n if(b==7){\\n      vector<string>a;\\n     a.push_back(\"p\");\\n     a.push_back(\"q\");\\n     a.push_back(\"r\");\\n     a.push_back(\"s\");\\n     return a;\\n } \\n if(b==8){\\n      vector<string>a;\\n     a.push_back(\"t\");\\n     a.push_back(\"u\");\\n     a.push_back(\"v\");\\n     return a;\\n } \\nif(b==9){\\n      vector<string>a;\\n     a.push_back(\"w\");\\n     a.push_back(\"x\");\\n     a.push_back(\"y\");\\n     a.push_back(\"z\");\\n     return a;\\n }\\n vector<string>a;\\n return a;\\n}\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size()==0){\\n            vector<string>ans;\\n            return ans;\\n        }\\n        if(digits.size()==1){\\n        \\n        int a=digits[0]-48;\\n           \\n            return helper(a);\\n        }\\n        vector<string>ans=letterCombinations(digits.substr(1));\\n        int z=digits[0]-48;\\n        vector<string> a=helper(z);\\n        vector<string>answer;\\n        for(int i=0;i<a.size();i++){\\n    \\n            for(int j=0;j<ans.size();j++){\\n              string s=a[i]+ans[j];\\n              answer.push_back(s);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\ncomment for any doubts"
                    },
                    {
                        "username": "samikshhh",
                        "content": "no viable conversion from \\'std::string\\' (aka \\'basic_string<char>\\') to \\'char\\'\\n\\nI am geting this error i dont know why.\\n\\nMy code is 100 % right i have cross checked it many time."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution(object):\\n    \\n    def main(self, digits):\\n        h={\\'2\\':[\\'a\\',\\'b\\',\\'c\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'4\\':[\\'g\\',\\'h\\',\\'i\\'],\\n           \\'5\\':[\\'j\\',\\'k\\',\\'l\\'],\\n           \\'6\\':[\\'m\\',\\'n\\',\\'o\\'],\\n           \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'],\\n           \\'8\\':[\\'t\\',\\'u\\',\\'v\\'],\\n           \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        l=[]\\n        return self.answer(h,digits,l,\"\",0)\\n\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.main(digits)\\n        \\n    \\n    def answer(self,h,digit,l,state,count):\\n        # print(l)\\n        n=len(digit)\\n        if len(state)==n:\\n            print(\"base\")\\n            l.append(copy.copy(state))\\n            count=0\\n            state=\"\"\\n            return \\n        # for i in range(count,len(digit)):\\n        else:\\n            print(\"count=\",count)\\n            k=h[digit[count]]\\n            for j in k:\\n                # print(k)\\n                state=state+j\\n            \\n                count=count+1\\n                print(\"count add=\",count)\\n                self.answer(h,digit,l,state,count)\\n                print(\"stateb=\",state)\\n                state=state[:-1]\\n                count=count-1\\n                print(\"count sub=\",count)\\n                print(\"statea=\",state)\\n            return l\\n\\n"
                    },
                    {
                        "username": "neo9729",
                        "content": "Can someone explain how does the time complexity is 4^n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each digit maps into as many as 4 letters so that is 4^n letter combinations - each of which must be stored."
                    },
                    {
                        "username": "h4o4",
                        "content": "recursion is the most elegant solution imo\\n\\n```python\\nfor partialResult in self.letterCombinations(digits[:-1]):\\n    for c in digitToLetters[digits[-1]]:\\n        result.append(partialResult + c)\\n```"
                    },
                    {
                        "username": "Harshi26",
                        "content": "```class Solution {\\npublic:\\n    void solve(string digits, string output, int index, vector<string>& ans, string mapping[]){\\n        //base case\\n        if(index>=digits.length()){\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int num = digits[index]-\\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0;i<value.length();i++){\\n            output.push_back(value[i]);\\n            solve(digits,output,index+1,ans,mapping);\\n            output.pop_back();\\n        }\\n\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        \\n        if(digits.length()==0)\\n            return ans;\\n\\n        string output = \"\";\\n        int index = 0;\\n        \\n        //mapping\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n\\n        solve(digits, output, index, ans, mapping);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 1726971,
                "content": [
                    {
                        "username": "easonteong",
                        "content": "Debug Code for C programmers\\n```\\nint main(int argc, const char * argv[]) {\\n    int* returnSize = (int*)malloc(1*sizeof(int));\\n    char** answer = letterCombinations(\"7\", returnSize);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        for(int j = 0; answer[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            printf(\"%c\",answer[i][j]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\n```"
                    },
                    {
                        "username": "boluodueke2020",
                        "content": "Why am I getting an error for using a formatted string? \\nRunning the same code on jupyter notebook gives the correct outputs, but running here its hanging on the point where the formatted string is.\\nAnd whenever I remove that, it reverses the order of the individual entries of the output......"
                    },
                    {
                        "username": "user7740h",
                        "content": "class Solution {\\npublic:\\n    void GP(vector<string> &g,vector<string> v,string str,string digits,int index){\\n        if(index==digits.length()) {\\n            g.push_back(str);\\n            cout<<str<<\" \";\\n        }else{\\n            for(char temp:v[int(digits[index] - \\'0\\')]){\\n                GP(g,v,str+temp,digits,index+1);\\n            }\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> v{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        vector<string> g;\\n        string str=\"\";\\n        for(char temp:v[int(digits[0] - \\'0\\')]){\\n            cout<<temp<<\":\";\\n            GP(g,v,str+temp,digits,1);\\n        }\\n        // for(string temp:g)\\n        //     cout<<temp<<\" \";  \\n    return g;        \\n    }\\n};\\n\\nWhy this code is giving this run time error\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6120000013c0 overflowed to 0x612000000dc0 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "class Solution {\\n    private:\\n    void solve(string digit ,string output , int index , vector<string>& ans, string mapping[])\\n    {\\n        //base case\\n        if(index>=digit.length())\\n        {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        int number = digit[index] - \\'0\\';\\n        string value = mapping[number];\\n        for(int i = 0 ; i<value.length() ; i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digit , output , index + 1 , ans , mapping);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans ;\\n        if(digits.length()==0)\\n        return ans;\\n        string output =\"\";\\n        int index = 0 ;\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits , output , index , ans , mapping);\\n        return ans ; \\n    }\\n};\\nBest C++ solution "
                    },
                    {
                        "username": "harshkumar123",
                        "content": "100% beats\\nclass Solution {\\npublic:\\nvector<string> helper(int b){\\n if(b==2){\\n     vector<string>a;\\n     a.push_back(\"a\");\\n     a.push_back(\"b\");\\n     a.push_back(\"c\");\\n     return a;\\n }\\n if(b==3){\\n      vector<string>a;\\n     a.push_back(\"d\");\\n     a.push_back(\"e\");\\n     a.push_back(\"f\");\\n     return a;\\n } \\nif(b==4){\\n      vector<string>a;\\n     a.push_back(\"g\");\\n     a.push_back(\"h\");\\n     a.push_back(\"i\");\\n     return a;\\n } \\n if(b==5){\\n      vector<string>a;\\n     a.push_back(\"j\");\\n     a.push_back(\"k\");\\n     a.push_back(\"l\");\\n     return a;\\n } \\n if(b==6){\\n      vector<string>a;\\n     a.push_back(\"m\");\\n     a.push_back(\"n\");\\n     a.push_back(\"o\");\\n     return a;\\n } \\n if(b==7){\\n      vector<string>a;\\n     a.push_back(\"p\");\\n     a.push_back(\"q\");\\n     a.push_back(\"r\");\\n     a.push_back(\"s\");\\n     return a;\\n } \\n if(b==8){\\n      vector<string>a;\\n     a.push_back(\"t\");\\n     a.push_back(\"u\");\\n     a.push_back(\"v\");\\n     return a;\\n } \\nif(b==9){\\n      vector<string>a;\\n     a.push_back(\"w\");\\n     a.push_back(\"x\");\\n     a.push_back(\"y\");\\n     a.push_back(\"z\");\\n     return a;\\n }\\n vector<string>a;\\n return a;\\n}\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size()==0){\\n            vector<string>ans;\\n            return ans;\\n        }\\n        if(digits.size()==1){\\n        \\n        int a=digits[0]-48;\\n           \\n            return helper(a);\\n        }\\n        vector<string>ans=letterCombinations(digits.substr(1));\\n        int z=digits[0]-48;\\n        vector<string> a=helper(z);\\n        vector<string>answer;\\n        for(int i=0;i<a.size();i++){\\n    \\n            for(int j=0;j<ans.size();j++){\\n              string s=a[i]+ans[j];\\n              answer.push_back(s);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\ncomment for any doubts"
                    },
                    {
                        "username": "samikshhh",
                        "content": "no viable conversion from \\'std::string\\' (aka \\'basic_string<char>\\') to \\'char\\'\\n\\nI am geting this error i dont know why.\\n\\nMy code is 100 % right i have cross checked it many time."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution(object):\\n    \\n    def main(self, digits):\\n        h={\\'2\\':[\\'a\\',\\'b\\',\\'c\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'4\\':[\\'g\\',\\'h\\',\\'i\\'],\\n           \\'5\\':[\\'j\\',\\'k\\',\\'l\\'],\\n           \\'6\\':[\\'m\\',\\'n\\',\\'o\\'],\\n           \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'],\\n           \\'8\\':[\\'t\\',\\'u\\',\\'v\\'],\\n           \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        l=[]\\n        return self.answer(h,digits,l,\"\",0)\\n\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.main(digits)\\n        \\n    \\n    def answer(self,h,digit,l,state,count):\\n        # print(l)\\n        n=len(digit)\\n        if len(state)==n:\\n            print(\"base\")\\n            l.append(copy.copy(state))\\n            count=0\\n            state=\"\"\\n            return \\n        # for i in range(count,len(digit)):\\n        else:\\n            print(\"count=\",count)\\n            k=h[digit[count]]\\n            for j in k:\\n                # print(k)\\n                state=state+j\\n            \\n                count=count+1\\n                print(\"count add=\",count)\\n                self.answer(h,digit,l,state,count)\\n                print(\"stateb=\",state)\\n                state=state[:-1]\\n                count=count-1\\n                print(\"count sub=\",count)\\n                print(\"statea=\",state)\\n            return l\\n\\n"
                    },
                    {
                        "username": "neo9729",
                        "content": "Can someone explain how does the time complexity is 4^n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each digit maps into as many as 4 letters so that is 4^n letter combinations - each of which must be stored."
                    },
                    {
                        "username": "h4o4",
                        "content": "recursion is the most elegant solution imo\\n\\n```python\\nfor partialResult in self.letterCombinations(digits[:-1]):\\n    for c in digitToLetters[digits[-1]]:\\n        result.append(partialResult + c)\\n```"
                    },
                    {
                        "username": "Harshi26",
                        "content": "```class Solution {\\npublic:\\n    void solve(string digits, string output, int index, vector<string>& ans, string mapping[]){\\n        //base case\\n        if(index>=digits.length()){\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int num = digits[index]-\\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0;i<value.length();i++){\\n            output.push_back(value[i]);\\n            solve(digits,output,index+1,ans,mapping);\\n            output.pop_back();\\n        }\\n\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        \\n        if(digits.length()==0)\\n            return ans;\\n\\n        string output = \"\";\\n        int index = 0;\\n        \\n        //mapping\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n\\n        solve(digits, output, index, ans, mapping);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 1724771,
                "content": [
                    {
                        "username": "easonteong",
                        "content": "Debug Code for C programmers\\n```\\nint main(int argc, const char * argv[]) {\\n    int* returnSize = (int*)malloc(1*sizeof(int));\\n    char** answer = letterCombinations(\"7\", returnSize);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        for(int j = 0; answer[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            printf(\"%c\",answer[i][j]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\n```"
                    },
                    {
                        "username": "boluodueke2020",
                        "content": "Why am I getting an error for using a formatted string? \\nRunning the same code on jupyter notebook gives the correct outputs, but running here its hanging on the point where the formatted string is.\\nAnd whenever I remove that, it reverses the order of the individual entries of the output......"
                    },
                    {
                        "username": "user7740h",
                        "content": "class Solution {\\npublic:\\n    void GP(vector<string> &g,vector<string> v,string str,string digits,int index){\\n        if(index==digits.length()) {\\n            g.push_back(str);\\n            cout<<str<<\" \";\\n        }else{\\n            for(char temp:v[int(digits[index] - \\'0\\')]){\\n                GP(g,v,str+temp,digits,index+1);\\n            }\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> v{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        vector<string> g;\\n        string str=\"\";\\n        for(char temp:v[int(digits[0] - \\'0\\')]){\\n            cout<<temp<<\":\";\\n            GP(g,v,str+temp,digits,1);\\n        }\\n        // for(string temp:g)\\n        //     cout<<temp<<\" \";  \\n    return g;        \\n    }\\n};\\n\\nWhy this code is giving this run time error\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6120000013c0 overflowed to 0x612000000dc0 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "class Solution {\\n    private:\\n    void solve(string digit ,string output , int index , vector<string>& ans, string mapping[])\\n    {\\n        //base case\\n        if(index>=digit.length())\\n        {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        int number = digit[index] - \\'0\\';\\n        string value = mapping[number];\\n        for(int i = 0 ; i<value.length() ; i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digit , output , index + 1 , ans , mapping);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans ;\\n        if(digits.length()==0)\\n        return ans;\\n        string output =\"\";\\n        int index = 0 ;\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits , output , index , ans , mapping);\\n        return ans ; \\n    }\\n};\\nBest C++ solution "
                    },
                    {
                        "username": "harshkumar123",
                        "content": "100% beats\\nclass Solution {\\npublic:\\nvector<string> helper(int b){\\n if(b==2){\\n     vector<string>a;\\n     a.push_back(\"a\");\\n     a.push_back(\"b\");\\n     a.push_back(\"c\");\\n     return a;\\n }\\n if(b==3){\\n      vector<string>a;\\n     a.push_back(\"d\");\\n     a.push_back(\"e\");\\n     a.push_back(\"f\");\\n     return a;\\n } \\nif(b==4){\\n      vector<string>a;\\n     a.push_back(\"g\");\\n     a.push_back(\"h\");\\n     a.push_back(\"i\");\\n     return a;\\n } \\n if(b==5){\\n      vector<string>a;\\n     a.push_back(\"j\");\\n     a.push_back(\"k\");\\n     a.push_back(\"l\");\\n     return a;\\n } \\n if(b==6){\\n      vector<string>a;\\n     a.push_back(\"m\");\\n     a.push_back(\"n\");\\n     a.push_back(\"o\");\\n     return a;\\n } \\n if(b==7){\\n      vector<string>a;\\n     a.push_back(\"p\");\\n     a.push_back(\"q\");\\n     a.push_back(\"r\");\\n     a.push_back(\"s\");\\n     return a;\\n } \\n if(b==8){\\n      vector<string>a;\\n     a.push_back(\"t\");\\n     a.push_back(\"u\");\\n     a.push_back(\"v\");\\n     return a;\\n } \\nif(b==9){\\n      vector<string>a;\\n     a.push_back(\"w\");\\n     a.push_back(\"x\");\\n     a.push_back(\"y\");\\n     a.push_back(\"z\");\\n     return a;\\n }\\n vector<string>a;\\n return a;\\n}\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size()==0){\\n            vector<string>ans;\\n            return ans;\\n        }\\n        if(digits.size()==1){\\n        \\n        int a=digits[0]-48;\\n           \\n            return helper(a);\\n        }\\n        vector<string>ans=letterCombinations(digits.substr(1));\\n        int z=digits[0]-48;\\n        vector<string> a=helper(z);\\n        vector<string>answer;\\n        for(int i=0;i<a.size();i++){\\n    \\n            for(int j=0;j<ans.size();j++){\\n              string s=a[i]+ans[j];\\n              answer.push_back(s);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\ncomment for any doubts"
                    },
                    {
                        "username": "samikshhh",
                        "content": "no viable conversion from \\'std::string\\' (aka \\'basic_string<char>\\') to \\'char\\'\\n\\nI am geting this error i dont know why.\\n\\nMy code is 100 % right i have cross checked it many time."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution(object):\\n    \\n    def main(self, digits):\\n        h={\\'2\\':[\\'a\\',\\'b\\',\\'c\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'4\\':[\\'g\\',\\'h\\',\\'i\\'],\\n           \\'5\\':[\\'j\\',\\'k\\',\\'l\\'],\\n           \\'6\\':[\\'m\\',\\'n\\',\\'o\\'],\\n           \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'],\\n           \\'8\\':[\\'t\\',\\'u\\',\\'v\\'],\\n           \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        l=[]\\n        return self.answer(h,digits,l,\"\",0)\\n\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.main(digits)\\n        \\n    \\n    def answer(self,h,digit,l,state,count):\\n        # print(l)\\n        n=len(digit)\\n        if len(state)==n:\\n            print(\"base\")\\n            l.append(copy.copy(state))\\n            count=0\\n            state=\"\"\\n            return \\n        # for i in range(count,len(digit)):\\n        else:\\n            print(\"count=\",count)\\n            k=h[digit[count]]\\n            for j in k:\\n                # print(k)\\n                state=state+j\\n            \\n                count=count+1\\n                print(\"count add=\",count)\\n                self.answer(h,digit,l,state,count)\\n                print(\"stateb=\",state)\\n                state=state[:-1]\\n                count=count-1\\n                print(\"count sub=\",count)\\n                print(\"statea=\",state)\\n            return l\\n\\n"
                    },
                    {
                        "username": "neo9729",
                        "content": "Can someone explain how does the time complexity is 4^n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each digit maps into as many as 4 letters so that is 4^n letter combinations - each of which must be stored."
                    },
                    {
                        "username": "h4o4",
                        "content": "recursion is the most elegant solution imo\\n\\n```python\\nfor partialResult in self.letterCombinations(digits[:-1]):\\n    for c in digitToLetters[digits[-1]]:\\n        result.append(partialResult + c)\\n```"
                    },
                    {
                        "username": "Harshi26",
                        "content": "```class Solution {\\npublic:\\n    void solve(string digits, string output, int index, vector<string>& ans, string mapping[]){\\n        //base case\\n        if(index>=digits.length()){\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int num = digits[index]-\\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0;i<value.length();i++){\\n            output.push_back(value[i]);\\n            solve(digits,output,index+1,ans,mapping);\\n            output.pop_back();\\n        }\\n\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        \\n        if(digits.length()==0)\\n            return ans;\\n\\n        string output = \"\";\\n        int index = 0;\\n        \\n        //mapping\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n\\n        solve(digits, output, index, ans, mapping);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 1721543,
                "content": [
                    {
                        "username": "easonteong",
                        "content": "Debug Code for C programmers\\n```\\nint main(int argc, const char * argv[]) {\\n    int* returnSize = (int*)malloc(1*sizeof(int));\\n    char** answer = letterCombinations(\"7\", returnSize);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        for(int j = 0; answer[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            printf(\"%c\",answer[i][j]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\n```"
                    },
                    {
                        "username": "boluodueke2020",
                        "content": "Why am I getting an error for using a formatted string? \\nRunning the same code on jupyter notebook gives the correct outputs, but running here its hanging on the point where the formatted string is.\\nAnd whenever I remove that, it reverses the order of the individual entries of the output......"
                    },
                    {
                        "username": "user7740h",
                        "content": "class Solution {\\npublic:\\n    void GP(vector<string> &g,vector<string> v,string str,string digits,int index){\\n        if(index==digits.length()) {\\n            g.push_back(str);\\n            cout<<str<<\" \";\\n        }else{\\n            for(char temp:v[int(digits[index] - \\'0\\')]){\\n                GP(g,v,str+temp,digits,index+1);\\n            }\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> v{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        vector<string> g;\\n        string str=\"\";\\n        for(char temp:v[int(digits[0] - \\'0\\')]){\\n            cout<<temp<<\":\";\\n            GP(g,v,str+temp,digits,1);\\n        }\\n        // for(string temp:g)\\n        //     cout<<temp<<\" \";  \\n    return g;        \\n    }\\n};\\n\\nWhy this code is giving this run time error\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6120000013c0 overflowed to 0x612000000dc0 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "class Solution {\\n    private:\\n    void solve(string digit ,string output , int index , vector<string>& ans, string mapping[])\\n    {\\n        //base case\\n        if(index>=digit.length())\\n        {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        int number = digit[index] - \\'0\\';\\n        string value = mapping[number];\\n        for(int i = 0 ; i<value.length() ; i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digit , output , index + 1 , ans , mapping);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans ;\\n        if(digits.length()==0)\\n        return ans;\\n        string output =\"\";\\n        int index = 0 ;\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits , output , index , ans , mapping);\\n        return ans ; \\n    }\\n};\\nBest C++ solution "
                    },
                    {
                        "username": "harshkumar123",
                        "content": "100% beats\\nclass Solution {\\npublic:\\nvector<string> helper(int b){\\n if(b==2){\\n     vector<string>a;\\n     a.push_back(\"a\");\\n     a.push_back(\"b\");\\n     a.push_back(\"c\");\\n     return a;\\n }\\n if(b==3){\\n      vector<string>a;\\n     a.push_back(\"d\");\\n     a.push_back(\"e\");\\n     a.push_back(\"f\");\\n     return a;\\n } \\nif(b==4){\\n      vector<string>a;\\n     a.push_back(\"g\");\\n     a.push_back(\"h\");\\n     a.push_back(\"i\");\\n     return a;\\n } \\n if(b==5){\\n      vector<string>a;\\n     a.push_back(\"j\");\\n     a.push_back(\"k\");\\n     a.push_back(\"l\");\\n     return a;\\n } \\n if(b==6){\\n      vector<string>a;\\n     a.push_back(\"m\");\\n     a.push_back(\"n\");\\n     a.push_back(\"o\");\\n     return a;\\n } \\n if(b==7){\\n      vector<string>a;\\n     a.push_back(\"p\");\\n     a.push_back(\"q\");\\n     a.push_back(\"r\");\\n     a.push_back(\"s\");\\n     return a;\\n } \\n if(b==8){\\n      vector<string>a;\\n     a.push_back(\"t\");\\n     a.push_back(\"u\");\\n     a.push_back(\"v\");\\n     return a;\\n } \\nif(b==9){\\n      vector<string>a;\\n     a.push_back(\"w\");\\n     a.push_back(\"x\");\\n     a.push_back(\"y\");\\n     a.push_back(\"z\");\\n     return a;\\n }\\n vector<string>a;\\n return a;\\n}\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size()==0){\\n            vector<string>ans;\\n            return ans;\\n        }\\n        if(digits.size()==1){\\n        \\n        int a=digits[0]-48;\\n           \\n            return helper(a);\\n        }\\n        vector<string>ans=letterCombinations(digits.substr(1));\\n        int z=digits[0]-48;\\n        vector<string> a=helper(z);\\n        vector<string>answer;\\n        for(int i=0;i<a.size();i++){\\n    \\n            for(int j=0;j<ans.size();j++){\\n              string s=a[i]+ans[j];\\n              answer.push_back(s);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\ncomment for any doubts"
                    },
                    {
                        "username": "samikshhh",
                        "content": "no viable conversion from \\'std::string\\' (aka \\'basic_string<char>\\') to \\'char\\'\\n\\nI am geting this error i dont know why.\\n\\nMy code is 100 % right i have cross checked it many time."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution(object):\\n    \\n    def main(self, digits):\\n        h={\\'2\\':[\\'a\\',\\'b\\',\\'c\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'4\\':[\\'g\\',\\'h\\',\\'i\\'],\\n           \\'5\\':[\\'j\\',\\'k\\',\\'l\\'],\\n           \\'6\\':[\\'m\\',\\'n\\',\\'o\\'],\\n           \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'],\\n           \\'8\\':[\\'t\\',\\'u\\',\\'v\\'],\\n           \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        l=[]\\n        return self.answer(h,digits,l,\"\",0)\\n\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.main(digits)\\n        \\n    \\n    def answer(self,h,digit,l,state,count):\\n        # print(l)\\n        n=len(digit)\\n        if len(state)==n:\\n            print(\"base\")\\n            l.append(copy.copy(state))\\n            count=0\\n            state=\"\"\\n            return \\n        # for i in range(count,len(digit)):\\n        else:\\n            print(\"count=\",count)\\n            k=h[digit[count]]\\n            for j in k:\\n                # print(k)\\n                state=state+j\\n            \\n                count=count+1\\n                print(\"count add=\",count)\\n                self.answer(h,digit,l,state,count)\\n                print(\"stateb=\",state)\\n                state=state[:-1]\\n                count=count-1\\n                print(\"count sub=\",count)\\n                print(\"statea=\",state)\\n            return l\\n\\n"
                    },
                    {
                        "username": "neo9729",
                        "content": "Can someone explain how does the time complexity is 4^n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each digit maps into as many as 4 letters so that is 4^n letter combinations - each of which must be stored."
                    },
                    {
                        "username": "h4o4",
                        "content": "recursion is the most elegant solution imo\\n\\n```python\\nfor partialResult in self.letterCombinations(digits[:-1]):\\n    for c in digitToLetters[digits[-1]]:\\n        result.append(partialResult + c)\\n```"
                    },
                    {
                        "username": "Harshi26",
                        "content": "```class Solution {\\npublic:\\n    void solve(string digits, string output, int index, vector<string>& ans, string mapping[]){\\n        //base case\\n        if(index>=digits.length()){\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int num = digits[index]-\\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0;i<value.length();i++){\\n            output.push_back(value[i]);\\n            solve(digits,output,index+1,ans,mapping);\\n            output.pop_back();\\n        }\\n\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        \\n        if(digits.length()==0)\\n            return ans;\\n\\n        string output = \"\";\\n        int index = 0;\\n        \\n        //mapping\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n\\n        solve(digits, output, index, ans, mapping);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 1719875,
                "content": [
                    {
                        "username": "easonteong",
                        "content": "Debug Code for C programmers\\n```\\nint main(int argc, const char * argv[]) {\\n    int* returnSize = (int*)malloc(1*sizeof(int));\\n    char** answer = letterCombinations(\"7\", returnSize);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        for(int j = 0; answer[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            printf(\"%c\",answer[i][j]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\n```"
                    },
                    {
                        "username": "boluodueke2020",
                        "content": "Why am I getting an error for using a formatted string? \\nRunning the same code on jupyter notebook gives the correct outputs, but running here its hanging on the point where the formatted string is.\\nAnd whenever I remove that, it reverses the order of the individual entries of the output......"
                    },
                    {
                        "username": "user7740h",
                        "content": "class Solution {\\npublic:\\n    void GP(vector<string> &g,vector<string> v,string str,string digits,int index){\\n        if(index==digits.length()) {\\n            g.push_back(str);\\n            cout<<str<<\" \";\\n        }else{\\n            for(char temp:v[int(digits[index] - \\'0\\')]){\\n                GP(g,v,str+temp,digits,index+1);\\n            }\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> v{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        vector<string> g;\\n        string str=\"\";\\n        for(char temp:v[int(digits[0] - \\'0\\')]){\\n            cout<<temp<<\":\";\\n            GP(g,v,str+temp,digits,1);\\n        }\\n        // for(string temp:g)\\n        //     cout<<temp<<\" \";  \\n    return g;        \\n    }\\n};\\n\\nWhy this code is giving this run time error\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6120000013c0 overflowed to 0x612000000dc0 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "class Solution {\\n    private:\\n    void solve(string digit ,string output , int index , vector<string>& ans, string mapping[])\\n    {\\n        //base case\\n        if(index>=digit.length())\\n        {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        int number = digit[index] - \\'0\\';\\n        string value = mapping[number];\\n        for(int i = 0 ; i<value.length() ; i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digit , output , index + 1 , ans , mapping);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans ;\\n        if(digits.length()==0)\\n        return ans;\\n        string output =\"\";\\n        int index = 0 ;\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits , output , index , ans , mapping);\\n        return ans ; \\n    }\\n};\\nBest C++ solution "
                    },
                    {
                        "username": "harshkumar123",
                        "content": "100% beats\\nclass Solution {\\npublic:\\nvector<string> helper(int b){\\n if(b==2){\\n     vector<string>a;\\n     a.push_back(\"a\");\\n     a.push_back(\"b\");\\n     a.push_back(\"c\");\\n     return a;\\n }\\n if(b==3){\\n      vector<string>a;\\n     a.push_back(\"d\");\\n     a.push_back(\"e\");\\n     a.push_back(\"f\");\\n     return a;\\n } \\nif(b==4){\\n      vector<string>a;\\n     a.push_back(\"g\");\\n     a.push_back(\"h\");\\n     a.push_back(\"i\");\\n     return a;\\n } \\n if(b==5){\\n      vector<string>a;\\n     a.push_back(\"j\");\\n     a.push_back(\"k\");\\n     a.push_back(\"l\");\\n     return a;\\n } \\n if(b==6){\\n      vector<string>a;\\n     a.push_back(\"m\");\\n     a.push_back(\"n\");\\n     a.push_back(\"o\");\\n     return a;\\n } \\n if(b==7){\\n      vector<string>a;\\n     a.push_back(\"p\");\\n     a.push_back(\"q\");\\n     a.push_back(\"r\");\\n     a.push_back(\"s\");\\n     return a;\\n } \\n if(b==8){\\n      vector<string>a;\\n     a.push_back(\"t\");\\n     a.push_back(\"u\");\\n     a.push_back(\"v\");\\n     return a;\\n } \\nif(b==9){\\n      vector<string>a;\\n     a.push_back(\"w\");\\n     a.push_back(\"x\");\\n     a.push_back(\"y\");\\n     a.push_back(\"z\");\\n     return a;\\n }\\n vector<string>a;\\n return a;\\n}\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size()==0){\\n            vector<string>ans;\\n            return ans;\\n        }\\n        if(digits.size()==1){\\n        \\n        int a=digits[0]-48;\\n           \\n            return helper(a);\\n        }\\n        vector<string>ans=letterCombinations(digits.substr(1));\\n        int z=digits[0]-48;\\n        vector<string> a=helper(z);\\n        vector<string>answer;\\n        for(int i=0;i<a.size();i++){\\n    \\n            for(int j=0;j<ans.size();j++){\\n              string s=a[i]+ans[j];\\n              answer.push_back(s);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\ncomment for any doubts"
                    },
                    {
                        "username": "samikshhh",
                        "content": "no viable conversion from \\'std::string\\' (aka \\'basic_string<char>\\') to \\'char\\'\\n\\nI am geting this error i dont know why.\\n\\nMy code is 100 % right i have cross checked it many time."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution(object):\\n    \\n    def main(self, digits):\\n        h={\\'2\\':[\\'a\\',\\'b\\',\\'c\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'4\\':[\\'g\\',\\'h\\',\\'i\\'],\\n           \\'5\\':[\\'j\\',\\'k\\',\\'l\\'],\\n           \\'6\\':[\\'m\\',\\'n\\',\\'o\\'],\\n           \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'],\\n           \\'8\\':[\\'t\\',\\'u\\',\\'v\\'],\\n           \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        l=[]\\n        return self.answer(h,digits,l,\"\",0)\\n\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.main(digits)\\n        \\n    \\n    def answer(self,h,digit,l,state,count):\\n        # print(l)\\n        n=len(digit)\\n        if len(state)==n:\\n            print(\"base\")\\n            l.append(copy.copy(state))\\n            count=0\\n            state=\"\"\\n            return \\n        # for i in range(count,len(digit)):\\n        else:\\n            print(\"count=\",count)\\n            k=h[digit[count]]\\n            for j in k:\\n                # print(k)\\n                state=state+j\\n            \\n                count=count+1\\n                print(\"count add=\",count)\\n                self.answer(h,digit,l,state,count)\\n                print(\"stateb=\",state)\\n                state=state[:-1]\\n                count=count-1\\n                print(\"count sub=\",count)\\n                print(\"statea=\",state)\\n            return l\\n\\n"
                    },
                    {
                        "username": "neo9729",
                        "content": "Can someone explain how does the time complexity is 4^n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each digit maps into as many as 4 letters so that is 4^n letter combinations - each of which must be stored."
                    },
                    {
                        "username": "h4o4",
                        "content": "recursion is the most elegant solution imo\\n\\n```python\\nfor partialResult in self.letterCombinations(digits[:-1]):\\n    for c in digitToLetters[digits[-1]]:\\n        result.append(partialResult + c)\\n```"
                    },
                    {
                        "username": "Harshi26",
                        "content": "```class Solution {\\npublic:\\n    void solve(string digits, string output, int index, vector<string>& ans, string mapping[]){\\n        //base case\\n        if(index>=digits.length()){\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int num = digits[index]-\\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0;i<value.length();i++){\\n            output.push_back(value[i]);\\n            solve(digits,output,index+1,ans,mapping);\\n            output.pop_back();\\n        }\\n\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        \\n        if(digits.length()==0)\\n            return ans;\\n\\n        string output = \"\";\\n        int index = 0;\\n        \\n        //mapping\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n\\n        solve(digits, output, index, ans, mapping);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 1714618,
                "content": [
                    {
                        "username": "easonteong",
                        "content": "Debug Code for C programmers\\n```\\nint main(int argc, const char * argv[]) {\\n    int* returnSize = (int*)malloc(1*sizeof(int));\\n    char** answer = letterCombinations(\"7\", returnSize);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        for(int j = 0; answer[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            printf(\"%c\",answer[i][j]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\n```"
                    },
                    {
                        "username": "boluodueke2020",
                        "content": "Why am I getting an error for using a formatted string? \\nRunning the same code on jupyter notebook gives the correct outputs, but running here its hanging on the point where the formatted string is.\\nAnd whenever I remove that, it reverses the order of the individual entries of the output......"
                    },
                    {
                        "username": "user7740h",
                        "content": "class Solution {\\npublic:\\n    void GP(vector<string> &g,vector<string> v,string str,string digits,int index){\\n        if(index==digits.length()) {\\n            g.push_back(str);\\n            cout<<str<<\" \";\\n        }else{\\n            for(char temp:v[int(digits[index] - \\'0\\')]){\\n                GP(g,v,str+temp,digits,index+1);\\n            }\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> v{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        vector<string> g;\\n        string str=\"\";\\n        for(char temp:v[int(digits[0] - \\'0\\')]){\\n            cout<<temp<<\":\";\\n            GP(g,v,str+temp,digits,1);\\n        }\\n        // for(string temp:g)\\n        //     cout<<temp<<\" \";  \\n    return g;        \\n    }\\n};\\n\\nWhy this code is giving this run time error\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6120000013c0 overflowed to 0x612000000dc0 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "class Solution {\\n    private:\\n    void solve(string digit ,string output , int index , vector<string>& ans, string mapping[])\\n    {\\n        //base case\\n        if(index>=digit.length())\\n        {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        int number = digit[index] - \\'0\\';\\n        string value = mapping[number];\\n        for(int i = 0 ; i<value.length() ; i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digit , output , index + 1 , ans , mapping);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans ;\\n        if(digits.length()==0)\\n        return ans;\\n        string output =\"\";\\n        int index = 0 ;\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits , output , index , ans , mapping);\\n        return ans ; \\n    }\\n};\\nBest C++ solution "
                    },
                    {
                        "username": "harshkumar123",
                        "content": "100% beats\\nclass Solution {\\npublic:\\nvector<string> helper(int b){\\n if(b==2){\\n     vector<string>a;\\n     a.push_back(\"a\");\\n     a.push_back(\"b\");\\n     a.push_back(\"c\");\\n     return a;\\n }\\n if(b==3){\\n      vector<string>a;\\n     a.push_back(\"d\");\\n     a.push_back(\"e\");\\n     a.push_back(\"f\");\\n     return a;\\n } \\nif(b==4){\\n      vector<string>a;\\n     a.push_back(\"g\");\\n     a.push_back(\"h\");\\n     a.push_back(\"i\");\\n     return a;\\n } \\n if(b==5){\\n      vector<string>a;\\n     a.push_back(\"j\");\\n     a.push_back(\"k\");\\n     a.push_back(\"l\");\\n     return a;\\n } \\n if(b==6){\\n      vector<string>a;\\n     a.push_back(\"m\");\\n     a.push_back(\"n\");\\n     a.push_back(\"o\");\\n     return a;\\n } \\n if(b==7){\\n      vector<string>a;\\n     a.push_back(\"p\");\\n     a.push_back(\"q\");\\n     a.push_back(\"r\");\\n     a.push_back(\"s\");\\n     return a;\\n } \\n if(b==8){\\n      vector<string>a;\\n     a.push_back(\"t\");\\n     a.push_back(\"u\");\\n     a.push_back(\"v\");\\n     return a;\\n } \\nif(b==9){\\n      vector<string>a;\\n     a.push_back(\"w\");\\n     a.push_back(\"x\");\\n     a.push_back(\"y\");\\n     a.push_back(\"z\");\\n     return a;\\n }\\n vector<string>a;\\n return a;\\n}\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size()==0){\\n            vector<string>ans;\\n            return ans;\\n        }\\n        if(digits.size()==1){\\n        \\n        int a=digits[0]-48;\\n           \\n            return helper(a);\\n        }\\n        vector<string>ans=letterCombinations(digits.substr(1));\\n        int z=digits[0]-48;\\n        vector<string> a=helper(z);\\n        vector<string>answer;\\n        for(int i=0;i<a.size();i++){\\n    \\n            for(int j=0;j<ans.size();j++){\\n              string s=a[i]+ans[j];\\n              answer.push_back(s);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\ncomment for any doubts"
                    },
                    {
                        "username": "samikshhh",
                        "content": "no viable conversion from \\'std::string\\' (aka \\'basic_string<char>\\') to \\'char\\'\\n\\nI am geting this error i dont know why.\\n\\nMy code is 100 % right i have cross checked it many time."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution(object):\\n    \\n    def main(self, digits):\\n        h={\\'2\\':[\\'a\\',\\'b\\',\\'c\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'4\\':[\\'g\\',\\'h\\',\\'i\\'],\\n           \\'5\\':[\\'j\\',\\'k\\',\\'l\\'],\\n           \\'6\\':[\\'m\\',\\'n\\',\\'o\\'],\\n           \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'],\\n           \\'8\\':[\\'t\\',\\'u\\',\\'v\\'],\\n           \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        l=[]\\n        return self.answer(h,digits,l,\"\",0)\\n\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.main(digits)\\n        \\n    \\n    def answer(self,h,digit,l,state,count):\\n        # print(l)\\n        n=len(digit)\\n        if len(state)==n:\\n            print(\"base\")\\n            l.append(copy.copy(state))\\n            count=0\\n            state=\"\"\\n            return \\n        # for i in range(count,len(digit)):\\n        else:\\n            print(\"count=\",count)\\n            k=h[digit[count]]\\n            for j in k:\\n                # print(k)\\n                state=state+j\\n            \\n                count=count+1\\n                print(\"count add=\",count)\\n                self.answer(h,digit,l,state,count)\\n                print(\"stateb=\",state)\\n                state=state[:-1]\\n                count=count-1\\n                print(\"count sub=\",count)\\n                print(\"statea=\",state)\\n            return l\\n\\n"
                    },
                    {
                        "username": "neo9729",
                        "content": "Can someone explain how does the time complexity is 4^n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each digit maps into as many as 4 letters so that is 4^n letter combinations - each of which must be stored."
                    },
                    {
                        "username": "h4o4",
                        "content": "recursion is the most elegant solution imo\\n\\n```python\\nfor partialResult in self.letterCombinations(digits[:-1]):\\n    for c in digitToLetters[digits[-1]]:\\n        result.append(partialResult + c)\\n```"
                    },
                    {
                        "username": "Harshi26",
                        "content": "```class Solution {\\npublic:\\n    void solve(string digits, string output, int index, vector<string>& ans, string mapping[]){\\n        //base case\\n        if(index>=digits.length()){\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int num = digits[index]-\\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0;i<value.length();i++){\\n            output.push_back(value[i]);\\n            solve(digits,output,index+1,ans,mapping);\\n            output.pop_back();\\n        }\\n\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        \\n        if(digits.length()==0)\\n            return ans;\\n\\n        string output = \"\";\\n        int index = 0;\\n        \\n        //mapping\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n\\n        solve(digits, output, index, ans, mapping);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 1711770,
                "content": [
                    {
                        "username": "easonteong",
                        "content": "Debug Code for C programmers\\n```\\nint main(int argc, const char * argv[]) {\\n    int* returnSize = (int*)malloc(1*sizeof(int));\\n    char** answer = letterCombinations(\"7\", returnSize);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        for(int j = 0; answer[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            printf(\"%c\",answer[i][j]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\n```"
                    },
                    {
                        "username": "boluodueke2020",
                        "content": "Why am I getting an error for using a formatted string? \\nRunning the same code on jupyter notebook gives the correct outputs, but running here its hanging on the point where the formatted string is.\\nAnd whenever I remove that, it reverses the order of the individual entries of the output......"
                    },
                    {
                        "username": "user7740h",
                        "content": "class Solution {\\npublic:\\n    void GP(vector<string> &g,vector<string> v,string str,string digits,int index){\\n        if(index==digits.length()) {\\n            g.push_back(str);\\n            cout<<str<<\" \";\\n        }else{\\n            for(char temp:v[int(digits[index] - \\'0\\')]){\\n                GP(g,v,str+temp,digits,index+1);\\n            }\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> v{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        vector<string> g;\\n        string str=\"\";\\n        for(char temp:v[int(digits[0] - \\'0\\')]){\\n            cout<<temp<<\":\";\\n            GP(g,v,str+temp,digits,1);\\n        }\\n        // for(string temp:g)\\n        //     cout<<temp<<\" \";  \\n    return g;        \\n    }\\n};\\n\\nWhy this code is giving this run time error\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6120000013c0 overflowed to 0x612000000dc0 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Yashdahiya295",
                        "content": "class Solution {\\n    private:\\n    void solve(string digit ,string output , int index , vector<string>& ans, string mapping[])\\n    {\\n        //base case\\n        if(index>=digit.length())\\n        {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        int number = digit[index] - \\'0\\';\\n        string value = mapping[number];\\n        for(int i = 0 ; i<value.length() ; i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digit , output , index + 1 , ans , mapping);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans ;\\n        if(digits.length()==0)\\n        return ans;\\n        string output =\"\";\\n        int index = 0 ;\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        solve(digits , output , index , ans , mapping);\\n        return ans ; \\n    }\\n};\\nBest C++ solution "
                    },
                    {
                        "username": "harshkumar123",
                        "content": "100% beats\\nclass Solution {\\npublic:\\nvector<string> helper(int b){\\n if(b==2){\\n     vector<string>a;\\n     a.push_back(\"a\");\\n     a.push_back(\"b\");\\n     a.push_back(\"c\");\\n     return a;\\n }\\n if(b==3){\\n      vector<string>a;\\n     a.push_back(\"d\");\\n     a.push_back(\"e\");\\n     a.push_back(\"f\");\\n     return a;\\n } \\nif(b==4){\\n      vector<string>a;\\n     a.push_back(\"g\");\\n     a.push_back(\"h\");\\n     a.push_back(\"i\");\\n     return a;\\n } \\n if(b==5){\\n      vector<string>a;\\n     a.push_back(\"j\");\\n     a.push_back(\"k\");\\n     a.push_back(\"l\");\\n     return a;\\n } \\n if(b==6){\\n      vector<string>a;\\n     a.push_back(\"m\");\\n     a.push_back(\"n\");\\n     a.push_back(\"o\");\\n     return a;\\n } \\n if(b==7){\\n      vector<string>a;\\n     a.push_back(\"p\");\\n     a.push_back(\"q\");\\n     a.push_back(\"r\");\\n     a.push_back(\"s\");\\n     return a;\\n } \\n if(b==8){\\n      vector<string>a;\\n     a.push_back(\"t\");\\n     a.push_back(\"u\");\\n     a.push_back(\"v\");\\n     return a;\\n } \\nif(b==9){\\n      vector<string>a;\\n     a.push_back(\"w\");\\n     a.push_back(\"x\");\\n     a.push_back(\"y\");\\n     a.push_back(\"z\");\\n     return a;\\n }\\n vector<string>a;\\n return a;\\n}\\n    vector<string> letterCombinations(string digits) {\\n        if(digits.size()==0){\\n            vector<string>ans;\\n            return ans;\\n        }\\n        if(digits.size()==1){\\n        \\n        int a=digits[0]-48;\\n           \\n            return helper(a);\\n        }\\n        vector<string>ans=letterCombinations(digits.substr(1));\\n        int z=digits[0]-48;\\n        vector<string> a=helper(z);\\n        vector<string>answer;\\n        for(int i=0;i<a.size();i++){\\n    \\n            for(int j=0;j<ans.size();j++){\\n              string s=a[i]+ans[j];\\n              answer.push_back(s);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\ncomment for any doubts"
                    },
                    {
                        "username": "samikshhh",
                        "content": "no viable conversion from \\'std::string\\' (aka \\'basic_string<char>\\') to \\'char\\'\\n\\nI am geting this error i dont know why.\\n\\nMy code is 100 % right i have cross checked it many time."
                    },
                    {
                        "username": "edupuganti_tarun_venkata_sai",
                        "content": "class Solution(object):\\n    \\n    def main(self, digits):\\n        h={\\'2\\':[\\'a\\',\\'b\\',\\'c\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'3\\':[\\'d\\',\\'e\\',\\'f\\'],\\n           \\'4\\':[\\'g\\',\\'h\\',\\'i\\'],\\n           \\'5\\':[\\'j\\',\\'k\\',\\'l\\'],\\n           \\'6\\':[\\'m\\',\\'n\\',\\'o\\'],\\n           \\'7\\':[\\'p\\',\\'q\\',\\'r\\',\\'s\\'],\\n           \\'8\\':[\\'t\\',\\'u\\',\\'v\\'],\\n           \\'9\\':[\\'w\\',\\'x\\',\\'y\\',\\'z\\']}\\n        l=[]\\n        return self.answer(h,digits,l,\"\",0)\\n\\n    def letterCombinations(self, digits):\\n        \"\"\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.main(digits)\\n        \\n    \\n    def answer(self,h,digit,l,state,count):\\n        # print(l)\\n        n=len(digit)\\n        if len(state)==n:\\n            print(\"base\")\\n            l.append(copy.copy(state))\\n            count=0\\n            state=\"\"\\n            return \\n        # for i in range(count,len(digit)):\\n        else:\\n            print(\"count=\",count)\\n            k=h[digit[count]]\\n            for j in k:\\n                # print(k)\\n                state=state+j\\n            \\n                count=count+1\\n                print(\"count add=\",count)\\n                self.answer(h,digit,l,state,count)\\n                print(\"stateb=\",state)\\n                state=state[:-1]\\n                count=count-1\\n                print(\"count sub=\",count)\\n                print(\"statea=\",state)\\n            return l\\n\\n"
                    },
                    {
                        "username": "neo9729",
                        "content": "Can someone explain how does the time complexity is 4^n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each digit maps into as many as 4 letters so that is 4^n letter combinations - each of which must be stored."
                    },
                    {
                        "username": "h4o4",
                        "content": "recursion is the most elegant solution imo\\n\\n```python\\nfor partialResult in self.letterCombinations(digits[:-1]):\\n    for c in digitToLetters[digits[-1]]:\\n        result.append(partialResult + c)\\n```"
                    },
                    {
                        "username": "Harshi26",
                        "content": "```class Solution {\\npublic:\\n    void solve(string digits, string output, int index, vector<string>& ans, string mapping[]){\\n        //base case\\n        if(index>=digits.length()){\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int num = digits[index]-\\'0\\';\\n        string value = mapping[num];\\n\\n        for(int i=0;i<value.length();i++){\\n            output.push_back(value[i]);\\n            solve(digits,output,index+1,ans,mapping);\\n            output.pop_back();\\n        }\\n\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        \\n        if(digits.length()==0)\\n            return ans;\\n\\n        string output = \"\";\\n        int index = 0;\\n        \\n        //mapping\\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n\\n        solve(digits, output, index, ans, mapping);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 1708239,
                "content": [
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple approach to sole this question through iteration \\n#include<bits/stdc++.h>\\n#include <cstdlib>\\n#include <iostream>\\nusing namespace std ;\\n\\nclass Solution {\\n   \\n    private:\\n   \\n    int length(int digit,string str[]){\\n        string track[]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digit==0){\\n            str[0]=\"\";\\n            return 1 ;\\n        }\\n\\n        int num=digit%10;\\n        int l=length(digit/10,str);\\n        if(num!=7 && num!=9){\\n           \\n            for(int i=0;i<l;i++){\\n                 int n=2;\\n                for(int j=0;j<track[num].length();j++){\\n                    str[i+n*l]=str[i]+track[num][j];\\n                    n--;\\n                }\\n            \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]= str[i]+track[num][0];\\n\\n            // }\\n            return 3*l;\\n        }\\n        else{\\n             for(int i=0;i<l;i++){\\n                    int n=3;\\n                 for(int j=0;j<track[num].length();j++){\\n                     str[i+n*l]= str[i]+track[num][j];\\n                     n--;\\n\\n                 }\\n                \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+2*l]=str[i]+track[num][2];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]=str[i]+track[num][0];\\n\\n            // }\\n            return 4*l ;\\n\\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\"){\\n            vector<string>s1;\\n            return s1 ;\\n\\n        }\\n\\n\\n        string out[100000];\\n        int d=stoi(digits);\\n        int l=length(d,out);\\n        \\n        vector<string> v(out, out + l);\\n        return v ;\\n        \\n    }\\n};\\n\\n\\nif you like my solution and want me to help u in dsa then connect to me via linkedn:\\nhttps://www.linkedin.com/in/garima-jain-98a776217/\\n\\n  "
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript based simple solution | 99 %\n\nvar letterCombinations = function(digits) {\n    let tel = {\n        2:['a','b','c'],\n        3:['d','e','f'],\n        4:['g','h','i'],\n        5:['j','k','l'],\n        6:['m','n','o'],\n        7:['p','q','r','s'],\n        8:['t','u','v'],\n        9:['w','x','y','z']\n    }, arr1=tel[digits[0]],arr2=tel[digits[1]],array=[];\n    if(!digits.trim().length){\n        return [];\n    }\n    if(digits.length == 1){\n        return tel[digits];\n    }\n    for(let d=0;d<digits.length-1;d++) {\n        arr1 = array.length ? array : tel[digits[d]];\n        arr2 = tel[digits[d+1]];\n        if(array.length){\n            array =[];\n        }\n        if(digits[d+1]) {\n            for(let i=0;i<arr1.length;i++) {\n                for(let j=0;j<arr2.length;j++) {\n                    array.push(arr1[i]+arr2[j])\n                }\n            }\n        } else {\n            return array;\n        }\n\n    }\n    return array;\n    \n};"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(string& digits, vector<string>& ans, string output, int index, string mapping[]) {\\n\\n        if(index >= digits.length()) {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i=0; i<value.length(); i++) {\\n            output.push_back(value[i]);\\n            solve(digits, ans, output, index+1, mapping);\\n            output.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        \\n        vector<string> ans;\\n\\n        if(digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        string output = \"\";\\n        int index = 0;\\n        string mapping[10]= {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        solve(digits, ans, output, index, mapping);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshal31",
                        "content": "Why my code is giving error while submission. \n`\nlet keypad = [\n\t\"\", // 0\n\t\"\", // 1\n\t[\"a\", \"b\", \"c\"], // 2\n\t[\"d\", \"e\", \"f\"], // 3\n\t[\"g\", \"h\", \"i\"], // 4\n\t[\"j\", \"k\", \"l\"], // 5\n\t[\"m\", \"n\", \"o\"], // 6\n\t[\"p\", \"q\", \"r\", \"s\"], // 7\n\t[\"t\", \"u\", \"v\"], // 8\n\t[\"w\", \"x\", \"y\", \"z\"], // 9\n];\n\nfunction letterCombination(numStr, final, digitArr, res) {\n\tif (numStr.length === 0) {\n\t\tres.push(final);\n\t\treturn res;\n\t}\n\n\tlet num = numStr[0];\n\tdigitArr = keypad[num];\n\n\tfor (let i = 0; i < digitArr.length; i++) {\n\t\t// let ch = digitArr[i];\n\t\tletterCombination(\n\t\t\tnumStr.substring(1),\n\t\t\tfinal + digitArr[i],\n\t\t\tdigitArr[num + 1],\n\t\t\tres\n\t\t);\n\t}\n\n\treturn res;\n}\n\nlet num = \"77\";\nif (num !== \"\"){\n console.log(letterCombination(num, \"\", keypad[num[0]], []));\n}\nelse{ console.log(\"\");\n}\n`"
                    },
                    {
                        "username": "alqory",
                        "content": "i spend 1 hour to resolve excercise :)\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\n \\nvar pattern = {\\n         2 : [\"a\",\"b\",\"c\"],\\n         3 : [\"d\",\"e\",\"f\"],\\n         4 : [\"g\",\"h\",\"i\"],\\n         5 : [\"j\",\"k\",\"l\"],\\n         6 : [\"m\",\"n\",\"o\"],\\n         7 : [\"p\",\"q\",\"r\",\"s\"],\\n         8 : [\"t\",\"u\",\"v\"],\\n         9 : [\"w\",\"x\",\"y\",\"z\"]\\n     }\\n\\nvar result = []\\n\\n var letterCombinations = function(digits) {\\n    var iterate = 0\\n\\n    if(!digits) return [];\\n    else if(digits.length === 1) return pattern[digits]\\n\\n    while(iterate !== pattern[digits[0]].length) {\\n        for(let i = 0; i < pattern[digits[1]].length ; i++) {\\n            const combined = pattern[digits[0]][iterate] + pattern[digits[1]][i]\\n            result.push(combined)    \\n            }\\n        iterate++\\n    }\\n    return result;\\n }"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "class Solution {\\n    private:\\n    void solve(string digits, string output, int index, string mapping[], vector<string> &ans)\\n    {\\n        if(index >= digits.length())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i = 0; i < value.length(); i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digits, output, index + 1, mapping, ans);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n\\n        vector<string> ans;\\n        string output;\\n        if(digits.length() == 0)\\n            return ans;\\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        int index = 0;\\n        solve(digits, output, index, mapping, ans);\\n        return ans; \\n    "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html)"
                    },
                    {
                        "username": "Alban18",
                        "content": "My solution didn\\'t pass one of the test cases but my output and the expected output is the exact same except that some of my strings are ordered different s.t. \\nmy output: <wxy> \\nexpected output: <xyw>\\n\\nHow do I report this to Leetcode to fix?"
                    },
                    {
                        "username": "abenovakz",
                        "content": "Why does the synthetic error always indicate in this line   -    def threeSumClosest(self, nums: List[int], target: int) -> int:"
                    },
                    {
                        "username": "Manish_kumar2",
                        "content": "best is take call by reference value in means &ans in user defined function\n\nclass Solution {\nprivate:\n    void solve(string digits, int index, string output, vector<string> & ans, string mapping[]){\n        if(index >= digits.length()){\n            ans.push_back(output);\n            return;\n        }\n        int num = digits[index] - '0';\n        string value = mapping[num];\n        for(int i = 0; i < value.length(); i++){\n            output.push_back(value[i]);\n            solve(digits, index + 1, output, ans, mapping);\n            output.pop_back();\n        }\n    }\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> ans;\n        if(digits.length() == 0){\n            return ans;\n        }\n        string output;\n        int index = 0;\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        solve(digits, index, output, ans, mapping);\n        return ans;\n    }\n};"
                    }
                ]
            },
            {
                "id": 1704029,
                "content": [
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple approach to sole this question through iteration \\n#include<bits/stdc++.h>\\n#include <cstdlib>\\n#include <iostream>\\nusing namespace std ;\\n\\nclass Solution {\\n   \\n    private:\\n   \\n    int length(int digit,string str[]){\\n        string track[]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digit==0){\\n            str[0]=\"\";\\n            return 1 ;\\n        }\\n\\n        int num=digit%10;\\n        int l=length(digit/10,str);\\n        if(num!=7 && num!=9){\\n           \\n            for(int i=0;i<l;i++){\\n                 int n=2;\\n                for(int j=0;j<track[num].length();j++){\\n                    str[i+n*l]=str[i]+track[num][j];\\n                    n--;\\n                }\\n            \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]= str[i]+track[num][0];\\n\\n            // }\\n            return 3*l;\\n        }\\n        else{\\n             for(int i=0;i<l;i++){\\n                    int n=3;\\n                 for(int j=0;j<track[num].length();j++){\\n                     str[i+n*l]= str[i]+track[num][j];\\n                     n--;\\n\\n                 }\\n                \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+2*l]=str[i]+track[num][2];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]=str[i]+track[num][0];\\n\\n            // }\\n            return 4*l ;\\n\\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\"){\\n            vector<string>s1;\\n            return s1 ;\\n\\n        }\\n\\n\\n        string out[100000];\\n        int d=stoi(digits);\\n        int l=length(d,out);\\n        \\n        vector<string> v(out, out + l);\\n        return v ;\\n        \\n    }\\n};\\n\\n\\nif you like my solution and want me to help u in dsa then connect to me via linkedn:\\nhttps://www.linkedin.com/in/garima-jain-98a776217/\\n\\n  "
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript based simple solution | 99 %\n\nvar letterCombinations = function(digits) {\n    let tel = {\n        2:['a','b','c'],\n        3:['d','e','f'],\n        4:['g','h','i'],\n        5:['j','k','l'],\n        6:['m','n','o'],\n        7:['p','q','r','s'],\n        8:['t','u','v'],\n        9:['w','x','y','z']\n    }, arr1=tel[digits[0]],arr2=tel[digits[1]],array=[];\n    if(!digits.trim().length){\n        return [];\n    }\n    if(digits.length == 1){\n        return tel[digits];\n    }\n    for(let d=0;d<digits.length-1;d++) {\n        arr1 = array.length ? array : tel[digits[d]];\n        arr2 = tel[digits[d+1]];\n        if(array.length){\n            array =[];\n        }\n        if(digits[d+1]) {\n            for(let i=0;i<arr1.length;i++) {\n                for(let j=0;j<arr2.length;j++) {\n                    array.push(arr1[i]+arr2[j])\n                }\n            }\n        } else {\n            return array;\n        }\n\n    }\n    return array;\n    \n};"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(string& digits, vector<string>& ans, string output, int index, string mapping[]) {\\n\\n        if(index >= digits.length()) {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i=0; i<value.length(); i++) {\\n            output.push_back(value[i]);\\n            solve(digits, ans, output, index+1, mapping);\\n            output.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        \\n        vector<string> ans;\\n\\n        if(digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        string output = \"\";\\n        int index = 0;\\n        string mapping[10]= {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        solve(digits, ans, output, index, mapping);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshal31",
                        "content": "Why my code is giving error while submission. \n`\nlet keypad = [\n\t\"\", // 0\n\t\"\", // 1\n\t[\"a\", \"b\", \"c\"], // 2\n\t[\"d\", \"e\", \"f\"], // 3\n\t[\"g\", \"h\", \"i\"], // 4\n\t[\"j\", \"k\", \"l\"], // 5\n\t[\"m\", \"n\", \"o\"], // 6\n\t[\"p\", \"q\", \"r\", \"s\"], // 7\n\t[\"t\", \"u\", \"v\"], // 8\n\t[\"w\", \"x\", \"y\", \"z\"], // 9\n];\n\nfunction letterCombination(numStr, final, digitArr, res) {\n\tif (numStr.length === 0) {\n\t\tres.push(final);\n\t\treturn res;\n\t}\n\n\tlet num = numStr[0];\n\tdigitArr = keypad[num];\n\n\tfor (let i = 0; i < digitArr.length; i++) {\n\t\t// let ch = digitArr[i];\n\t\tletterCombination(\n\t\t\tnumStr.substring(1),\n\t\t\tfinal + digitArr[i],\n\t\t\tdigitArr[num + 1],\n\t\t\tres\n\t\t);\n\t}\n\n\treturn res;\n}\n\nlet num = \"77\";\nif (num !== \"\"){\n console.log(letterCombination(num, \"\", keypad[num[0]], []));\n}\nelse{ console.log(\"\");\n}\n`"
                    },
                    {
                        "username": "alqory",
                        "content": "i spend 1 hour to resolve excercise :)\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\n \\nvar pattern = {\\n         2 : [\"a\",\"b\",\"c\"],\\n         3 : [\"d\",\"e\",\"f\"],\\n         4 : [\"g\",\"h\",\"i\"],\\n         5 : [\"j\",\"k\",\"l\"],\\n         6 : [\"m\",\"n\",\"o\"],\\n         7 : [\"p\",\"q\",\"r\",\"s\"],\\n         8 : [\"t\",\"u\",\"v\"],\\n         9 : [\"w\",\"x\",\"y\",\"z\"]\\n     }\\n\\nvar result = []\\n\\n var letterCombinations = function(digits) {\\n    var iterate = 0\\n\\n    if(!digits) return [];\\n    else if(digits.length === 1) return pattern[digits]\\n\\n    while(iterate !== pattern[digits[0]].length) {\\n        for(let i = 0; i < pattern[digits[1]].length ; i++) {\\n            const combined = pattern[digits[0]][iterate] + pattern[digits[1]][i]\\n            result.push(combined)    \\n            }\\n        iterate++\\n    }\\n    return result;\\n }"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "class Solution {\\n    private:\\n    void solve(string digits, string output, int index, string mapping[], vector<string> &ans)\\n    {\\n        if(index >= digits.length())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i = 0; i < value.length(); i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digits, output, index + 1, mapping, ans);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n\\n        vector<string> ans;\\n        string output;\\n        if(digits.length() == 0)\\n            return ans;\\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        int index = 0;\\n        solve(digits, output, index, mapping, ans);\\n        return ans; \\n    "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html)"
                    },
                    {
                        "username": "Alban18",
                        "content": "My solution didn\\'t pass one of the test cases but my output and the expected output is the exact same except that some of my strings are ordered different s.t. \\nmy output: <wxy> \\nexpected output: <xyw>\\n\\nHow do I report this to Leetcode to fix?"
                    },
                    {
                        "username": "abenovakz",
                        "content": "Why does the synthetic error always indicate in this line   -    def threeSumClosest(self, nums: List[int], target: int) -> int:"
                    },
                    {
                        "username": "Manish_kumar2",
                        "content": "best is take call by reference value in means &ans in user defined function\n\nclass Solution {\nprivate:\n    void solve(string digits, int index, string output, vector<string> & ans, string mapping[]){\n        if(index >= digits.length()){\n            ans.push_back(output);\n            return;\n        }\n        int num = digits[index] - '0';\n        string value = mapping[num];\n        for(int i = 0; i < value.length(); i++){\n            output.push_back(value[i]);\n            solve(digits, index + 1, output, ans, mapping);\n            output.pop_back();\n        }\n    }\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> ans;\n        if(digits.length() == 0){\n            return ans;\n        }\n        string output;\n        int index = 0;\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        solve(digits, index, output, ans, mapping);\n        return ans;\n    }\n};"
                    }
                ]
            },
            {
                "id": 1694564,
                "content": [
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple approach to sole this question through iteration \\n#include<bits/stdc++.h>\\n#include <cstdlib>\\n#include <iostream>\\nusing namespace std ;\\n\\nclass Solution {\\n   \\n    private:\\n   \\n    int length(int digit,string str[]){\\n        string track[]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digit==0){\\n            str[0]=\"\";\\n            return 1 ;\\n        }\\n\\n        int num=digit%10;\\n        int l=length(digit/10,str);\\n        if(num!=7 && num!=9){\\n           \\n            for(int i=0;i<l;i++){\\n                 int n=2;\\n                for(int j=0;j<track[num].length();j++){\\n                    str[i+n*l]=str[i]+track[num][j];\\n                    n--;\\n                }\\n            \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]= str[i]+track[num][0];\\n\\n            // }\\n            return 3*l;\\n        }\\n        else{\\n             for(int i=0;i<l;i++){\\n                    int n=3;\\n                 for(int j=0;j<track[num].length();j++){\\n                     str[i+n*l]= str[i]+track[num][j];\\n                     n--;\\n\\n                 }\\n                \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+2*l]=str[i]+track[num][2];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]=str[i]+track[num][0];\\n\\n            // }\\n            return 4*l ;\\n\\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\"){\\n            vector<string>s1;\\n            return s1 ;\\n\\n        }\\n\\n\\n        string out[100000];\\n        int d=stoi(digits);\\n        int l=length(d,out);\\n        \\n        vector<string> v(out, out + l);\\n        return v ;\\n        \\n    }\\n};\\n\\n\\nif you like my solution and want me to help u in dsa then connect to me via linkedn:\\nhttps://www.linkedin.com/in/garima-jain-98a776217/\\n\\n  "
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript based simple solution | 99 %\n\nvar letterCombinations = function(digits) {\n    let tel = {\n        2:['a','b','c'],\n        3:['d','e','f'],\n        4:['g','h','i'],\n        5:['j','k','l'],\n        6:['m','n','o'],\n        7:['p','q','r','s'],\n        8:['t','u','v'],\n        9:['w','x','y','z']\n    }, arr1=tel[digits[0]],arr2=tel[digits[1]],array=[];\n    if(!digits.trim().length){\n        return [];\n    }\n    if(digits.length == 1){\n        return tel[digits];\n    }\n    for(let d=0;d<digits.length-1;d++) {\n        arr1 = array.length ? array : tel[digits[d]];\n        arr2 = tel[digits[d+1]];\n        if(array.length){\n            array =[];\n        }\n        if(digits[d+1]) {\n            for(let i=0;i<arr1.length;i++) {\n                for(let j=0;j<arr2.length;j++) {\n                    array.push(arr1[i]+arr2[j])\n                }\n            }\n        } else {\n            return array;\n        }\n\n    }\n    return array;\n    \n};"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(string& digits, vector<string>& ans, string output, int index, string mapping[]) {\\n\\n        if(index >= digits.length()) {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i=0; i<value.length(); i++) {\\n            output.push_back(value[i]);\\n            solve(digits, ans, output, index+1, mapping);\\n            output.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        \\n        vector<string> ans;\\n\\n        if(digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        string output = \"\";\\n        int index = 0;\\n        string mapping[10]= {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        solve(digits, ans, output, index, mapping);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshal31",
                        "content": "Why my code is giving error while submission. \n`\nlet keypad = [\n\t\"\", // 0\n\t\"\", // 1\n\t[\"a\", \"b\", \"c\"], // 2\n\t[\"d\", \"e\", \"f\"], // 3\n\t[\"g\", \"h\", \"i\"], // 4\n\t[\"j\", \"k\", \"l\"], // 5\n\t[\"m\", \"n\", \"o\"], // 6\n\t[\"p\", \"q\", \"r\", \"s\"], // 7\n\t[\"t\", \"u\", \"v\"], // 8\n\t[\"w\", \"x\", \"y\", \"z\"], // 9\n];\n\nfunction letterCombination(numStr, final, digitArr, res) {\n\tif (numStr.length === 0) {\n\t\tres.push(final);\n\t\treturn res;\n\t}\n\n\tlet num = numStr[0];\n\tdigitArr = keypad[num];\n\n\tfor (let i = 0; i < digitArr.length; i++) {\n\t\t// let ch = digitArr[i];\n\t\tletterCombination(\n\t\t\tnumStr.substring(1),\n\t\t\tfinal + digitArr[i],\n\t\t\tdigitArr[num + 1],\n\t\t\tres\n\t\t);\n\t}\n\n\treturn res;\n}\n\nlet num = \"77\";\nif (num !== \"\"){\n console.log(letterCombination(num, \"\", keypad[num[0]], []));\n}\nelse{ console.log(\"\");\n}\n`"
                    },
                    {
                        "username": "alqory",
                        "content": "i spend 1 hour to resolve excercise :)\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\n \\nvar pattern = {\\n         2 : [\"a\",\"b\",\"c\"],\\n         3 : [\"d\",\"e\",\"f\"],\\n         4 : [\"g\",\"h\",\"i\"],\\n         5 : [\"j\",\"k\",\"l\"],\\n         6 : [\"m\",\"n\",\"o\"],\\n         7 : [\"p\",\"q\",\"r\",\"s\"],\\n         8 : [\"t\",\"u\",\"v\"],\\n         9 : [\"w\",\"x\",\"y\",\"z\"]\\n     }\\n\\nvar result = []\\n\\n var letterCombinations = function(digits) {\\n    var iterate = 0\\n\\n    if(!digits) return [];\\n    else if(digits.length === 1) return pattern[digits]\\n\\n    while(iterate !== pattern[digits[0]].length) {\\n        for(let i = 0; i < pattern[digits[1]].length ; i++) {\\n            const combined = pattern[digits[0]][iterate] + pattern[digits[1]][i]\\n            result.push(combined)    \\n            }\\n        iterate++\\n    }\\n    return result;\\n }"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "class Solution {\\n    private:\\n    void solve(string digits, string output, int index, string mapping[], vector<string> &ans)\\n    {\\n        if(index >= digits.length())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i = 0; i < value.length(); i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digits, output, index + 1, mapping, ans);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n\\n        vector<string> ans;\\n        string output;\\n        if(digits.length() == 0)\\n            return ans;\\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        int index = 0;\\n        solve(digits, output, index, mapping, ans);\\n        return ans; \\n    "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html)"
                    },
                    {
                        "username": "Alban18",
                        "content": "My solution didn\\'t pass one of the test cases but my output and the expected output is the exact same except that some of my strings are ordered different s.t. \\nmy output: <wxy> \\nexpected output: <xyw>\\n\\nHow do I report this to Leetcode to fix?"
                    },
                    {
                        "username": "abenovakz",
                        "content": "Why does the synthetic error always indicate in this line   -    def threeSumClosest(self, nums: List[int], target: int) -> int:"
                    },
                    {
                        "username": "Manish_kumar2",
                        "content": "best is take call by reference value in means &ans in user defined function\n\nclass Solution {\nprivate:\n    void solve(string digits, int index, string output, vector<string> & ans, string mapping[]){\n        if(index >= digits.length()){\n            ans.push_back(output);\n            return;\n        }\n        int num = digits[index] - '0';\n        string value = mapping[num];\n        for(int i = 0; i < value.length(); i++){\n            output.push_back(value[i]);\n            solve(digits, index + 1, output, ans, mapping);\n            output.pop_back();\n        }\n    }\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> ans;\n        if(digits.length() == 0){\n            return ans;\n        }\n        string output;\n        int index = 0;\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        solve(digits, index, output, ans, mapping);\n        return ans;\n    }\n};"
                    }
                ]
            },
            {
                "id": 1683268,
                "content": [
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple approach to sole this question through iteration \\n#include<bits/stdc++.h>\\n#include <cstdlib>\\n#include <iostream>\\nusing namespace std ;\\n\\nclass Solution {\\n   \\n    private:\\n   \\n    int length(int digit,string str[]){\\n        string track[]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digit==0){\\n            str[0]=\"\";\\n            return 1 ;\\n        }\\n\\n        int num=digit%10;\\n        int l=length(digit/10,str);\\n        if(num!=7 && num!=9){\\n           \\n            for(int i=0;i<l;i++){\\n                 int n=2;\\n                for(int j=0;j<track[num].length();j++){\\n                    str[i+n*l]=str[i]+track[num][j];\\n                    n--;\\n                }\\n            \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]= str[i]+track[num][0];\\n\\n            // }\\n            return 3*l;\\n        }\\n        else{\\n             for(int i=0;i<l;i++){\\n                    int n=3;\\n                 for(int j=0;j<track[num].length();j++){\\n                     str[i+n*l]= str[i]+track[num][j];\\n                     n--;\\n\\n                 }\\n                \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+2*l]=str[i]+track[num][2];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]=str[i]+track[num][0];\\n\\n            // }\\n            return 4*l ;\\n\\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\"){\\n            vector<string>s1;\\n            return s1 ;\\n\\n        }\\n\\n\\n        string out[100000];\\n        int d=stoi(digits);\\n        int l=length(d,out);\\n        \\n        vector<string> v(out, out + l);\\n        return v ;\\n        \\n    }\\n};\\n\\n\\nif you like my solution and want me to help u in dsa then connect to me via linkedn:\\nhttps://www.linkedin.com/in/garima-jain-98a776217/\\n\\n  "
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript based simple solution | 99 %\n\nvar letterCombinations = function(digits) {\n    let tel = {\n        2:['a','b','c'],\n        3:['d','e','f'],\n        4:['g','h','i'],\n        5:['j','k','l'],\n        6:['m','n','o'],\n        7:['p','q','r','s'],\n        8:['t','u','v'],\n        9:['w','x','y','z']\n    }, arr1=tel[digits[0]],arr2=tel[digits[1]],array=[];\n    if(!digits.trim().length){\n        return [];\n    }\n    if(digits.length == 1){\n        return tel[digits];\n    }\n    for(let d=0;d<digits.length-1;d++) {\n        arr1 = array.length ? array : tel[digits[d]];\n        arr2 = tel[digits[d+1]];\n        if(array.length){\n            array =[];\n        }\n        if(digits[d+1]) {\n            for(let i=0;i<arr1.length;i++) {\n                for(let j=0;j<arr2.length;j++) {\n                    array.push(arr1[i]+arr2[j])\n                }\n            }\n        } else {\n            return array;\n        }\n\n    }\n    return array;\n    \n};"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(string& digits, vector<string>& ans, string output, int index, string mapping[]) {\\n\\n        if(index >= digits.length()) {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i=0; i<value.length(); i++) {\\n            output.push_back(value[i]);\\n            solve(digits, ans, output, index+1, mapping);\\n            output.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        \\n        vector<string> ans;\\n\\n        if(digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        string output = \"\";\\n        int index = 0;\\n        string mapping[10]= {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        solve(digits, ans, output, index, mapping);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshal31",
                        "content": "Why my code is giving error while submission. \n`\nlet keypad = [\n\t\"\", // 0\n\t\"\", // 1\n\t[\"a\", \"b\", \"c\"], // 2\n\t[\"d\", \"e\", \"f\"], // 3\n\t[\"g\", \"h\", \"i\"], // 4\n\t[\"j\", \"k\", \"l\"], // 5\n\t[\"m\", \"n\", \"o\"], // 6\n\t[\"p\", \"q\", \"r\", \"s\"], // 7\n\t[\"t\", \"u\", \"v\"], // 8\n\t[\"w\", \"x\", \"y\", \"z\"], // 9\n];\n\nfunction letterCombination(numStr, final, digitArr, res) {\n\tif (numStr.length === 0) {\n\t\tres.push(final);\n\t\treturn res;\n\t}\n\n\tlet num = numStr[0];\n\tdigitArr = keypad[num];\n\n\tfor (let i = 0; i < digitArr.length; i++) {\n\t\t// let ch = digitArr[i];\n\t\tletterCombination(\n\t\t\tnumStr.substring(1),\n\t\t\tfinal + digitArr[i],\n\t\t\tdigitArr[num + 1],\n\t\t\tres\n\t\t);\n\t}\n\n\treturn res;\n}\n\nlet num = \"77\";\nif (num !== \"\"){\n console.log(letterCombination(num, \"\", keypad[num[0]], []));\n}\nelse{ console.log(\"\");\n}\n`"
                    },
                    {
                        "username": "alqory",
                        "content": "i spend 1 hour to resolve excercise :)\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\n \\nvar pattern = {\\n         2 : [\"a\",\"b\",\"c\"],\\n         3 : [\"d\",\"e\",\"f\"],\\n         4 : [\"g\",\"h\",\"i\"],\\n         5 : [\"j\",\"k\",\"l\"],\\n         6 : [\"m\",\"n\",\"o\"],\\n         7 : [\"p\",\"q\",\"r\",\"s\"],\\n         8 : [\"t\",\"u\",\"v\"],\\n         9 : [\"w\",\"x\",\"y\",\"z\"]\\n     }\\n\\nvar result = []\\n\\n var letterCombinations = function(digits) {\\n    var iterate = 0\\n\\n    if(!digits) return [];\\n    else if(digits.length === 1) return pattern[digits]\\n\\n    while(iterate !== pattern[digits[0]].length) {\\n        for(let i = 0; i < pattern[digits[1]].length ; i++) {\\n            const combined = pattern[digits[0]][iterate] + pattern[digits[1]][i]\\n            result.push(combined)    \\n            }\\n        iterate++\\n    }\\n    return result;\\n }"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "class Solution {\\n    private:\\n    void solve(string digits, string output, int index, string mapping[], vector<string> &ans)\\n    {\\n        if(index >= digits.length())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i = 0; i < value.length(); i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digits, output, index + 1, mapping, ans);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n\\n        vector<string> ans;\\n        string output;\\n        if(digits.length() == 0)\\n            return ans;\\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        int index = 0;\\n        solve(digits, output, index, mapping, ans);\\n        return ans; \\n    "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html)"
                    },
                    {
                        "username": "Alban18",
                        "content": "My solution didn\\'t pass one of the test cases but my output and the expected output is the exact same except that some of my strings are ordered different s.t. \\nmy output: <wxy> \\nexpected output: <xyw>\\n\\nHow do I report this to Leetcode to fix?"
                    },
                    {
                        "username": "abenovakz",
                        "content": "Why does the synthetic error always indicate in this line   -    def threeSumClosest(self, nums: List[int], target: int) -> int:"
                    },
                    {
                        "username": "Manish_kumar2",
                        "content": "best is take call by reference value in means &ans in user defined function\n\nclass Solution {\nprivate:\n    void solve(string digits, int index, string output, vector<string> & ans, string mapping[]){\n        if(index >= digits.length()){\n            ans.push_back(output);\n            return;\n        }\n        int num = digits[index] - '0';\n        string value = mapping[num];\n        for(int i = 0; i < value.length(); i++){\n            output.push_back(value[i]);\n            solve(digits, index + 1, output, ans, mapping);\n            output.pop_back();\n        }\n    }\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> ans;\n        if(digits.length() == 0){\n            return ans;\n        }\n        string output;\n        int index = 0;\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        solve(digits, index, output, ans, mapping);\n        return ans;\n    }\n};"
                    }
                ]
            },
            {
                "id": 1680591,
                "content": [
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple approach to sole this question through iteration \\n#include<bits/stdc++.h>\\n#include <cstdlib>\\n#include <iostream>\\nusing namespace std ;\\n\\nclass Solution {\\n   \\n    private:\\n   \\n    int length(int digit,string str[]){\\n        string track[]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digit==0){\\n            str[0]=\"\";\\n            return 1 ;\\n        }\\n\\n        int num=digit%10;\\n        int l=length(digit/10,str);\\n        if(num!=7 && num!=9){\\n           \\n            for(int i=0;i<l;i++){\\n                 int n=2;\\n                for(int j=0;j<track[num].length();j++){\\n                    str[i+n*l]=str[i]+track[num][j];\\n                    n--;\\n                }\\n            \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]= str[i]+track[num][0];\\n\\n            // }\\n            return 3*l;\\n        }\\n        else{\\n             for(int i=0;i<l;i++){\\n                    int n=3;\\n                 for(int j=0;j<track[num].length();j++){\\n                     str[i+n*l]= str[i]+track[num][j];\\n                     n--;\\n\\n                 }\\n                \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+2*l]=str[i]+track[num][2];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]=str[i]+track[num][0];\\n\\n            // }\\n            return 4*l ;\\n\\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\"){\\n            vector<string>s1;\\n            return s1 ;\\n\\n        }\\n\\n\\n        string out[100000];\\n        int d=stoi(digits);\\n        int l=length(d,out);\\n        \\n        vector<string> v(out, out + l);\\n        return v ;\\n        \\n    }\\n};\\n\\n\\nif you like my solution and want me to help u in dsa then connect to me via linkedn:\\nhttps://www.linkedin.com/in/garima-jain-98a776217/\\n\\n  "
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript based simple solution | 99 %\n\nvar letterCombinations = function(digits) {\n    let tel = {\n        2:['a','b','c'],\n        3:['d','e','f'],\n        4:['g','h','i'],\n        5:['j','k','l'],\n        6:['m','n','o'],\n        7:['p','q','r','s'],\n        8:['t','u','v'],\n        9:['w','x','y','z']\n    }, arr1=tel[digits[0]],arr2=tel[digits[1]],array=[];\n    if(!digits.trim().length){\n        return [];\n    }\n    if(digits.length == 1){\n        return tel[digits];\n    }\n    for(let d=0;d<digits.length-1;d++) {\n        arr1 = array.length ? array : tel[digits[d]];\n        arr2 = tel[digits[d+1]];\n        if(array.length){\n            array =[];\n        }\n        if(digits[d+1]) {\n            for(let i=0;i<arr1.length;i++) {\n                for(let j=0;j<arr2.length;j++) {\n                    array.push(arr1[i]+arr2[j])\n                }\n            }\n        } else {\n            return array;\n        }\n\n    }\n    return array;\n    \n};"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(string& digits, vector<string>& ans, string output, int index, string mapping[]) {\\n\\n        if(index >= digits.length()) {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i=0; i<value.length(); i++) {\\n            output.push_back(value[i]);\\n            solve(digits, ans, output, index+1, mapping);\\n            output.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        \\n        vector<string> ans;\\n\\n        if(digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        string output = \"\";\\n        int index = 0;\\n        string mapping[10]= {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        solve(digits, ans, output, index, mapping);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshal31",
                        "content": "Why my code is giving error while submission. \n`\nlet keypad = [\n\t\"\", // 0\n\t\"\", // 1\n\t[\"a\", \"b\", \"c\"], // 2\n\t[\"d\", \"e\", \"f\"], // 3\n\t[\"g\", \"h\", \"i\"], // 4\n\t[\"j\", \"k\", \"l\"], // 5\n\t[\"m\", \"n\", \"o\"], // 6\n\t[\"p\", \"q\", \"r\", \"s\"], // 7\n\t[\"t\", \"u\", \"v\"], // 8\n\t[\"w\", \"x\", \"y\", \"z\"], // 9\n];\n\nfunction letterCombination(numStr, final, digitArr, res) {\n\tif (numStr.length === 0) {\n\t\tres.push(final);\n\t\treturn res;\n\t}\n\n\tlet num = numStr[0];\n\tdigitArr = keypad[num];\n\n\tfor (let i = 0; i < digitArr.length; i++) {\n\t\t// let ch = digitArr[i];\n\t\tletterCombination(\n\t\t\tnumStr.substring(1),\n\t\t\tfinal + digitArr[i],\n\t\t\tdigitArr[num + 1],\n\t\t\tres\n\t\t);\n\t}\n\n\treturn res;\n}\n\nlet num = \"77\";\nif (num !== \"\"){\n console.log(letterCombination(num, \"\", keypad[num[0]], []));\n}\nelse{ console.log(\"\");\n}\n`"
                    },
                    {
                        "username": "alqory",
                        "content": "i spend 1 hour to resolve excercise :)\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\n \\nvar pattern = {\\n         2 : [\"a\",\"b\",\"c\"],\\n         3 : [\"d\",\"e\",\"f\"],\\n         4 : [\"g\",\"h\",\"i\"],\\n         5 : [\"j\",\"k\",\"l\"],\\n         6 : [\"m\",\"n\",\"o\"],\\n         7 : [\"p\",\"q\",\"r\",\"s\"],\\n         8 : [\"t\",\"u\",\"v\"],\\n         9 : [\"w\",\"x\",\"y\",\"z\"]\\n     }\\n\\nvar result = []\\n\\n var letterCombinations = function(digits) {\\n    var iterate = 0\\n\\n    if(!digits) return [];\\n    else if(digits.length === 1) return pattern[digits]\\n\\n    while(iterate !== pattern[digits[0]].length) {\\n        for(let i = 0; i < pattern[digits[1]].length ; i++) {\\n            const combined = pattern[digits[0]][iterate] + pattern[digits[1]][i]\\n            result.push(combined)    \\n            }\\n        iterate++\\n    }\\n    return result;\\n }"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "class Solution {\\n    private:\\n    void solve(string digits, string output, int index, string mapping[], vector<string> &ans)\\n    {\\n        if(index >= digits.length())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i = 0; i < value.length(); i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digits, output, index + 1, mapping, ans);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n\\n        vector<string> ans;\\n        string output;\\n        if(digits.length() == 0)\\n            return ans;\\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        int index = 0;\\n        solve(digits, output, index, mapping, ans);\\n        return ans; \\n    "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html)"
                    },
                    {
                        "username": "Alban18",
                        "content": "My solution didn\\'t pass one of the test cases but my output and the expected output is the exact same except that some of my strings are ordered different s.t. \\nmy output: <wxy> \\nexpected output: <xyw>\\n\\nHow do I report this to Leetcode to fix?"
                    },
                    {
                        "username": "abenovakz",
                        "content": "Why does the synthetic error always indicate in this line   -    def threeSumClosest(self, nums: List[int], target: int) -> int:"
                    },
                    {
                        "username": "Manish_kumar2",
                        "content": "best is take call by reference value in means &ans in user defined function\n\nclass Solution {\nprivate:\n    void solve(string digits, int index, string output, vector<string> & ans, string mapping[]){\n        if(index >= digits.length()){\n            ans.push_back(output);\n            return;\n        }\n        int num = digits[index] - '0';\n        string value = mapping[num];\n        for(int i = 0; i < value.length(); i++){\n            output.push_back(value[i]);\n            solve(digits, index + 1, output, ans, mapping);\n            output.pop_back();\n        }\n    }\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> ans;\n        if(digits.length() == 0){\n            return ans;\n        }\n        string output;\n        int index = 0;\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        solve(digits, index, output, ans, mapping);\n        return ans;\n    }\n};"
                    }
                ]
            },
            {
                "id": 1680100,
                "content": [
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple approach to sole this question through iteration \\n#include<bits/stdc++.h>\\n#include <cstdlib>\\n#include <iostream>\\nusing namespace std ;\\n\\nclass Solution {\\n   \\n    private:\\n   \\n    int length(int digit,string str[]){\\n        string track[]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digit==0){\\n            str[0]=\"\";\\n            return 1 ;\\n        }\\n\\n        int num=digit%10;\\n        int l=length(digit/10,str);\\n        if(num!=7 && num!=9){\\n           \\n            for(int i=0;i<l;i++){\\n                 int n=2;\\n                for(int j=0;j<track[num].length();j++){\\n                    str[i+n*l]=str[i]+track[num][j];\\n                    n--;\\n                }\\n            \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]= str[i]+track[num][0];\\n\\n            // }\\n            return 3*l;\\n        }\\n        else{\\n             for(int i=0;i<l;i++){\\n                    int n=3;\\n                 for(int j=0;j<track[num].length();j++){\\n                     str[i+n*l]= str[i]+track[num][j];\\n                     n--;\\n\\n                 }\\n                \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+2*l]=str[i]+track[num][2];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]=str[i]+track[num][0];\\n\\n            // }\\n            return 4*l ;\\n\\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\"){\\n            vector<string>s1;\\n            return s1 ;\\n\\n        }\\n\\n\\n        string out[100000];\\n        int d=stoi(digits);\\n        int l=length(d,out);\\n        \\n        vector<string> v(out, out + l);\\n        return v ;\\n        \\n    }\\n};\\n\\n\\nif you like my solution and want me to help u in dsa then connect to me via linkedn:\\nhttps://www.linkedin.com/in/garima-jain-98a776217/\\n\\n  "
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript based simple solution | 99 %\n\nvar letterCombinations = function(digits) {\n    let tel = {\n        2:['a','b','c'],\n        3:['d','e','f'],\n        4:['g','h','i'],\n        5:['j','k','l'],\n        6:['m','n','o'],\n        7:['p','q','r','s'],\n        8:['t','u','v'],\n        9:['w','x','y','z']\n    }, arr1=tel[digits[0]],arr2=tel[digits[1]],array=[];\n    if(!digits.trim().length){\n        return [];\n    }\n    if(digits.length == 1){\n        return tel[digits];\n    }\n    for(let d=0;d<digits.length-1;d++) {\n        arr1 = array.length ? array : tel[digits[d]];\n        arr2 = tel[digits[d+1]];\n        if(array.length){\n            array =[];\n        }\n        if(digits[d+1]) {\n            for(let i=0;i<arr1.length;i++) {\n                for(let j=0;j<arr2.length;j++) {\n                    array.push(arr1[i]+arr2[j])\n                }\n            }\n        } else {\n            return array;\n        }\n\n    }\n    return array;\n    \n};"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(string& digits, vector<string>& ans, string output, int index, string mapping[]) {\\n\\n        if(index >= digits.length()) {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i=0; i<value.length(); i++) {\\n            output.push_back(value[i]);\\n            solve(digits, ans, output, index+1, mapping);\\n            output.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        \\n        vector<string> ans;\\n\\n        if(digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        string output = \"\";\\n        int index = 0;\\n        string mapping[10]= {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        solve(digits, ans, output, index, mapping);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshal31",
                        "content": "Why my code is giving error while submission. \n`\nlet keypad = [\n\t\"\", // 0\n\t\"\", // 1\n\t[\"a\", \"b\", \"c\"], // 2\n\t[\"d\", \"e\", \"f\"], // 3\n\t[\"g\", \"h\", \"i\"], // 4\n\t[\"j\", \"k\", \"l\"], // 5\n\t[\"m\", \"n\", \"o\"], // 6\n\t[\"p\", \"q\", \"r\", \"s\"], // 7\n\t[\"t\", \"u\", \"v\"], // 8\n\t[\"w\", \"x\", \"y\", \"z\"], // 9\n];\n\nfunction letterCombination(numStr, final, digitArr, res) {\n\tif (numStr.length === 0) {\n\t\tres.push(final);\n\t\treturn res;\n\t}\n\n\tlet num = numStr[0];\n\tdigitArr = keypad[num];\n\n\tfor (let i = 0; i < digitArr.length; i++) {\n\t\t// let ch = digitArr[i];\n\t\tletterCombination(\n\t\t\tnumStr.substring(1),\n\t\t\tfinal + digitArr[i],\n\t\t\tdigitArr[num + 1],\n\t\t\tres\n\t\t);\n\t}\n\n\treturn res;\n}\n\nlet num = \"77\";\nif (num !== \"\"){\n console.log(letterCombination(num, \"\", keypad[num[0]], []));\n}\nelse{ console.log(\"\");\n}\n`"
                    },
                    {
                        "username": "alqory",
                        "content": "i spend 1 hour to resolve excercise :)\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\n \\nvar pattern = {\\n         2 : [\"a\",\"b\",\"c\"],\\n         3 : [\"d\",\"e\",\"f\"],\\n         4 : [\"g\",\"h\",\"i\"],\\n         5 : [\"j\",\"k\",\"l\"],\\n         6 : [\"m\",\"n\",\"o\"],\\n         7 : [\"p\",\"q\",\"r\",\"s\"],\\n         8 : [\"t\",\"u\",\"v\"],\\n         9 : [\"w\",\"x\",\"y\",\"z\"]\\n     }\\n\\nvar result = []\\n\\n var letterCombinations = function(digits) {\\n    var iterate = 0\\n\\n    if(!digits) return [];\\n    else if(digits.length === 1) return pattern[digits]\\n\\n    while(iterate !== pattern[digits[0]].length) {\\n        for(let i = 0; i < pattern[digits[1]].length ; i++) {\\n            const combined = pattern[digits[0]][iterate] + pattern[digits[1]][i]\\n            result.push(combined)    \\n            }\\n        iterate++\\n    }\\n    return result;\\n }"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "class Solution {\\n    private:\\n    void solve(string digits, string output, int index, string mapping[], vector<string> &ans)\\n    {\\n        if(index >= digits.length())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i = 0; i < value.length(); i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digits, output, index + 1, mapping, ans);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n\\n        vector<string> ans;\\n        string output;\\n        if(digits.length() == 0)\\n            return ans;\\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        int index = 0;\\n        solve(digits, output, index, mapping, ans);\\n        return ans; \\n    "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html)"
                    },
                    {
                        "username": "Alban18",
                        "content": "My solution didn\\'t pass one of the test cases but my output and the expected output is the exact same except that some of my strings are ordered different s.t. \\nmy output: <wxy> \\nexpected output: <xyw>\\n\\nHow do I report this to Leetcode to fix?"
                    },
                    {
                        "username": "abenovakz",
                        "content": "Why does the synthetic error always indicate in this line   -    def threeSumClosest(self, nums: List[int], target: int) -> int:"
                    },
                    {
                        "username": "Manish_kumar2",
                        "content": "best is take call by reference value in means &ans in user defined function\n\nclass Solution {\nprivate:\n    void solve(string digits, int index, string output, vector<string> & ans, string mapping[]){\n        if(index >= digits.length()){\n            ans.push_back(output);\n            return;\n        }\n        int num = digits[index] - '0';\n        string value = mapping[num];\n        for(int i = 0; i < value.length(); i++){\n            output.push_back(value[i]);\n            solve(digits, index + 1, output, ans, mapping);\n            output.pop_back();\n        }\n    }\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> ans;\n        if(digits.length() == 0){\n            return ans;\n        }\n        string output;\n        int index = 0;\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        solve(digits, index, output, ans, mapping);\n        return ans;\n    }\n};"
                    }
                ]
            },
            {
                "id": 1671257,
                "content": [
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple approach to sole this question through iteration \\n#include<bits/stdc++.h>\\n#include <cstdlib>\\n#include <iostream>\\nusing namespace std ;\\n\\nclass Solution {\\n   \\n    private:\\n   \\n    int length(int digit,string str[]){\\n        string track[]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digit==0){\\n            str[0]=\"\";\\n            return 1 ;\\n        }\\n\\n        int num=digit%10;\\n        int l=length(digit/10,str);\\n        if(num!=7 && num!=9){\\n           \\n            for(int i=0;i<l;i++){\\n                 int n=2;\\n                for(int j=0;j<track[num].length();j++){\\n                    str[i+n*l]=str[i]+track[num][j];\\n                    n--;\\n                }\\n            \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]= str[i]+track[num][0];\\n\\n            // }\\n            return 3*l;\\n        }\\n        else{\\n             for(int i=0;i<l;i++){\\n                    int n=3;\\n                 for(int j=0;j<track[num].length();j++){\\n                     str[i+n*l]= str[i]+track[num][j];\\n                     n--;\\n\\n                 }\\n                \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+2*l]=str[i]+track[num][2];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]=str[i]+track[num][0];\\n\\n            // }\\n            return 4*l ;\\n\\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\"){\\n            vector<string>s1;\\n            return s1 ;\\n\\n        }\\n\\n\\n        string out[100000];\\n        int d=stoi(digits);\\n        int l=length(d,out);\\n        \\n        vector<string> v(out, out + l);\\n        return v ;\\n        \\n    }\\n};\\n\\n\\nif you like my solution and want me to help u in dsa then connect to me via linkedn:\\nhttps://www.linkedin.com/in/garima-jain-98a776217/\\n\\n  "
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript based simple solution | 99 %\n\nvar letterCombinations = function(digits) {\n    let tel = {\n        2:['a','b','c'],\n        3:['d','e','f'],\n        4:['g','h','i'],\n        5:['j','k','l'],\n        6:['m','n','o'],\n        7:['p','q','r','s'],\n        8:['t','u','v'],\n        9:['w','x','y','z']\n    }, arr1=tel[digits[0]],arr2=tel[digits[1]],array=[];\n    if(!digits.trim().length){\n        return [];\n    }\n    if(digits.length == 1){\n        return tel[digits];\n    }\n    for(let d=0;d<digits.length-1;d++) {\n        arr1 = array.length ? array : tel[digits[d]];\n        arr2 = tel[digits[d+1]];\n        if(array.length){\n            array =[];\n        }\n        if(digits[d+1]) {\n            for(let i=0;i<arr1.length;i++) {\n                for(let j=0;j<arr2.length;j++) {\n                    array.push(arr1[i]+arr2[j])\n                }\n            }\n        } else {\n            return array;\n        }\n\n    }\n    return array;\n    \n};"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(string& digits, vector<string>& ans, string output, int index, string mapping[]) {\\n\\n        if(index >= digits.length()) {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i=0; i<value.length(); i++) {\\n            output.push_back(value[i]);\\n            solve(digits, ans, output, index+1, mapping);\\n            output.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        \\n        vector<string> ans;\\n\\n        if(digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        string output = \"\";\\n        int index = 0;\\n        string mapping[10]= {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        solve(digits, ans, output, index, mapping);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshal31",
                        "content": "Why my code is giving error while submission. \n`\nlet keypad = [\n\t\"\", // 0\n\t\"\", // 1\n\t[\"a\", \"b\", \"c\"], // 2\n\t[\"d\", \"e\", \"f\"], // 3\n\t[\"g\", \"h\", \"i\"], // 4\n\t[\"j\", \"k\", \"l\"], // 5\n\t[\"m\", \"n\", \"o\"], // 6\n\t[\"p\", \"q\", \"r\", \"s\"], // 7\n\t[\"t\", \"u\", \"v\"], // 8\n\t[\"w\", \"x\", \"y\", \"z\"], // 9\n];\n\nfunction letterCombination(numStr, final, digitArr, res) {\n\tif (numStr.length === 0) {\n\t\tres.push(final);\n\t\treturn res;\n\t}\n\n\tlet num = numStr[0];\n\tdigitArr = keypad[num];\n\n\tfor (let i = 0; i < digitArr.length; i++) {\n\t\t// let ch = digitArr[i];\n\t\tletterCombination(\n\t\t\tnumStr.substring(1),\n\t\t\tfinal + digitArr[i],\n\t\t\tdigitArr[num + 1],\n\t\t\tres\n\t\t);\n\t}\n\n\treturn res;\n}\n\nlet num = \"77\";\nif (num !== \"\"){\n console.log(letterCombination(num, \"\", keypad[num[0]], []));\n}\nelse{ console.log(\"\");\n}\n`"
                    },
                    {
                        "username": "alqory",
                        "content": "i spend 1 hour to resolve excercise :)\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\n \\nvar pattern = {\\n         2 : [\"a\",\"b\",\"c\"],\\n         3 : [\"d\",\"e\",\"f\"],\\n         4 : [\"g\",\"h\",\"i\"],\\n         5 : [\"j\",\"k\",\"l\"],\\n         6 : [\"m\",\"n\",\"o\"],\\n         7 : [\"p\",\"q\",\"r\",\"s\"],\\n         8 : [\"t\",\"u\",\"v\"],\\n         9 : [\"w\",\"x\",\"y\",\"z\"]\\n     }\\n\\nvar result = []\\n\\n var letterCombinations = function(digits) {\\n    var iterate = 0\\n\\n    if(!digits) return [];\\n    else if(digits.length === 1) return pattern[digits]\\n\\n    while(iterate !== pattern[digits[0]].length) {\\n        for(let i = 0; i < pattern[digits[1]].length ; i++) {\\n            const combined = pattern[digits[0]][iterate] + pattern[digits[1]][i]\\n            result.push(combined)    \\n            }\\n        iterate++\\n    }\\n    return result;\\n }"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "class Solution {\\n    private:\\n    void solve(string digits, string output, int index, string mapping[], vector<string> &ans)\\n    {\\n        if(index >= digits.length())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i = 0; i < value.length(); i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digits, output, index + 1, mapping, ans);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n\\n        vector<string> ans;\\n        string output;\\n        if(digits.length() == 0)\\n            return ans;\\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        int index = 0;\\n        solve(digits, output, index, mapping, ans);\\n        return ans; \\n    "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html)"
                    },
                    {
                        "username": "Alban18",
                        "content": "My solution didn\\'t pass one of the test cases but my output and the expected output is the exact same except that some of my strings are ordered different s.t. \\nmy output: <wxy> \\nexpected output: <xyw>\\n\\nHow do I report this to Leetcode to fix?"
                    },
                    {
                        "username": "abenovakz",
                        "content": "Why does the synthetic error always indicate in this line   -    def threeSumClosest(self, nums: List[int], target: int) -> int:"
                    },
                    {
                        "username": "Manish_kumar2",
                        "content": "best is take call by reference value in means &ans in user defined function\n\nclass Solution {\nprivate:\n    void solve(string digits, int index, string output, vector<string> & ans, string mapping[]){\n        if(index >= digits.length()){\n            ans.push_back(output);\n            return;\n        }\n        int num = digits[index] - '0';\n        string value = mapping[num];\n        for(int i = 0; i < value.length(); i++){\n            output.push_back(value[i]);\n            solve(digits, index + 1, output, ans, mapping);\n            output.pop_back();\n        }\n    }\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> ans;\n        if(digits.length() == 0){\n            return ans;\n        }\n        string output;\n        int index = 0;\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        solve(digits, index, output, ans, mapping);\n        return ans;\n    }\n};"
                    }
                ]
            },
            {
                "id": 1654057,
                "content": [
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple approach to sole this question through iteration \\n#include<bits/stdc++.h>\\n#include <cstdlib>\\n#include <iostream>\\nusing namespace std ;\\n\\nclass Solution {\\n   \\n    private:\\n   \\n    int length(int digit,string str[]){\\n        string track[]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digit==0){\\n            str[0]=\"\";\\n            return 1 ;\\n        }\\n\\n        int num=digit%10;\\n        int l=length(digit/10,str);\\n        if(num!=7 && num!=9){\\n           \\n            for(int i=0;i<l;i++){\\n                 int n=2;\\n                for(int j=0;j<track[num].length();j++){\\n                    str[i+n*l]=str[i]+track[num][j];\\n                    n--;\\n                }\\n            \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]= str[i]+track[num][0];\\n\\n            // }\\n            return 3*l;\\n        }\\n        else{\\n             for(int i=0;i<l;i++){\\n                    int n=3;\\n                 for(int j=0;j<track[num].length();j++){\\n                     str[i+n*l]= str[i]+track[num][j];\\n                     n--;\\n\\n                 }\\n                \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+2*l]=str[i]+track[num][2];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]=str[i]+track[num][0];\\n\\n            // }\\n            return 4*l ;\\n\\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\"){\\n            vector<string>s1;\\n            return s1 ;\\n\\n        }\\n\\n\\n        string out[100000];\\n        int d=stoi(digits);\\n        int l=length(d,out);\\n        \\n        vector<string> v(out, out + l);\\n        return v ;\\n        \\n    }\\n};\\n\\n\\nif you like my solution and want me to help u in dsa then connect to me via linkedn:\\nhttps://www.linkedin.com/in/garima-jain-98a776217/\\n\\n  "
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript based simple solution | 99 %\n\nvar letterCombinations = function(digits) {\n    let tel = {\n        2:['a','b','c'],\n        3:['d','e','f'],\n        4:['g','h','i'],\n        5:['j','k','l'],\n        6:['m','n','o'],\n        7:['p','q','r','s'],\n        8:['t','u','v'],\n        9:['w','x','y','z']\n    }, arr1=tel[digits[0]],arr2=tel[digits[1]],array=[];\n    if(!digits.trim().length){\n        return [];\n    }\n    if(digits.length == 1){\n        return tel[digits];\n    }\n    for(let d=0;d<digits.length-1;d++) {\n        arr1 = array.length ? array : tel[digits[d]];\n        arr2 = tel[digits[d+1]];\n        if(array.length){\n            array =[];\n        }\n        if(digits[d+1]) {\n            for(let i=0;i<arr1.length;i++) {\n                for(let j=0;j<arr2.length;j++) {\n                    array.push(arr1[i]+arr2[j])\n                }\n            }\n        } else {\n            return array;\n        }\n\n    }\n    return array;\n    \n};"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(string& digits, vector<string>& ans, string output, int index, string mapping[]) {\\n\\n        if(index >= digits.length()) {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i=0; i<value.length(); i++) {\\n            output.push_back(value[i]);\\n            solve(digits, ans, output, index+1, mapping);\\n            output.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        \\n        vector<string> ans;\\n\\n        if(digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        string output = \"\";\\n        int index = 0;\\n        string mapping[10]= {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        solve(digits, ans, output, index, mapping);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshal31",
                        "content": "Why my code is giving error while submission. \n`\nlet keypad = [\n\t\"\", // 0\n\t\"\", // 1\n\t[\"a\", \"b\", \"c\"], // 2\n\t[\"d\", \"e\", \"f\"], // 3\n\t[\"g\", \"h\", \"i\"], // 4\n\t[\"j\", \"k\", \"l\"], // 5\n\t[\"m\", \"n\", \"o\"], // 6\n\t[\"p\", \"q\", \"r\", \"s\"], // 7\n\t[\"t\", \"u\", \"v\"], // 8\n\t[\"w\", \"x\", \"y\", \"z\"], // 9\n];\n\nfunction letterCombination(numStr, final, digitArr, res) {\n\tif (numStr.length === 0) {\n\t\tres.push(final);\n\t\treturn res;\n\t}\n\n\tlet num = numStr[0];\n\tdigitArr = keypad[num];\n\n\tfor (let i = 0; i < digitArr.length; i++) {\n\t\t// let ch = digitArr[i];\n\t\tletterCombination(\n\t\t\tnumStr.substring(1),\n\t\t\tfinal + digitArr[i],\n\t\t\tdigitArr[num + 1],\n\t\t\tres\n\t\t);\n\t}\n\n\treturn res;\n}\n\nlet num = \"77\";\nif (num !== \"\"){\n console.log(letterCombination(num, \"\", keypad[num[0]], []));\n}\nelse{ console.log(\"\");\n}\n`"
                    },
                    {
                        "username": "alqory",
                        "content": "i spend 1 hour to resolve excercise :)\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\n \\nvar pattern = {\\n         2 : [\"a\",\"b\",\"c\"],\\n         3 : [\"d\",\"e\",\"f\"],\\n         4 : [\"g\",\"h\",\"i\"],\\n         5 : [\"j\",\"k\",\"l\"],\\n         6 : [\"m\",\"n\",\"o\"],\\n         7 : [\"p\",\"q\",\"r\",\"s\"],\\n         8 : [\"t\",\"u\",\"v\"],\\n         9 : [\"w\",\"x\",\"y\",\"z\"]\\n     }\\n\\nvar result = []\\n\\n var letterCombinations = function(digits) {\\n    var iterate = 0\\n\\n    if(!digits) return [];\\n    else if(digits.length === 1) return pattern[digits]\\n\\n    while(iterate !== pattern[digits[0]].length) {\\n        for(let i = 0; i < pattern[digits[1]].length ; i++) {\\n            const combined = pattern[digits[0]][iterate] + pattern[digits[1]][i]\\n            result.push(combined)    \\n            }\\n        iterate++\\n    }\\n    return result;\\n }"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "class Solution {\\n    private:\\n    void solve(string digits, string output, int index, string mapping[], vector<string> &ans)\\n    {\\n        if(index >= digits.length())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i = 0; i < value.length(); i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digits, output, index + 1, mapping, ans);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n\\n        vector<string> ans;\\n        string output;\\n        if(digits.length() == 0)\\n            return ans;\\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        int index = 0;\\n        solve(digits, output, index, mapping, ans);\\n        return ans; \\n    "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html)"
                    },
                    {
                        "username": "Alban18",
                        "content": "My solution didn\\'t pass one of the test cases but my output and the expected output is the exact same except that some of my strings are ordered different s.t. \\nmy output: <wxy> \\nexpected output: <xyw>\\n\\nHow do I report this to Leetcode to fix?"
                    },
                    {
                        "username": "abenovakz",
                        "content": "Why does the synthetic error always indicate in this line   -    def threeSumClosest(self, nums: List[int], target: int) -> int:"
                    },
                    {
                        "username": "Manish_kumar2",
                        "content": "best is take call by reference value in means &ans in user defined function\n\nclass Solution {\nprivate:\n    void solve(string digits, int index, string output, vector<string> & ans, string mapping[]){\n        if(index >= digits.length()){\n            ans.push_back(output);\n            return;\n        }\n        int num = digits[index] - '0';\n        string value = mapping[num];\n        for(int i = 0; i < value.length(); i++){\n            output.push_back(value[i]);\n            solve(digits, index + 1, output, ans, mapping);\n            output.pop_back();\n        }\n    }\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> ans;\n        if(digits.length() == 0){\n            return ans;\n        }\n        string output;\n        int index = 0;\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        solve(digits, index, output, ans, mapping);\n        return ans;\n    }\n};"
                    }
                ]
            },
            {
                "id": 1641822,
                "content": [
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple approach to sole this question through iteration \\n#include<bits/stdc++.h>\\n#include <cstdlib>\\n#include <iostream>\\nusing namespace std ;\\n\\nclass Solution {\\n   \\n    private:\\n   \\n    int length(int digit,string str[]){\\n        string track[]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digit==0){\\n            str[0]=\"\";\\n            return 1 ;\\n        }\\n\\n        int num=digit%10;\\n        int l=length(digit/10,str);\\n        if(num!=7 && num!=9){\\n           \\n            for(int i=0;i<l;i++){\\n                 int n=2;\\n                for(int j=0;j<track[num].length();j++){\\n                    str[i+n*l]=str[i]+track[num][j];\\n                    n--;\\n                }\\n            \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]= str[i]+track[num][0];\\n\\n            // }\\n            return 3*l;\\n        }\\n        else{\\n             for(int i=0;i<l;i++){\\n                    int n=3;\\n                 for(int j=0;j<track[num].length();j++){\\n                     str[i+n*l]= str[i]+track[num][j];\\n                     n--;\\n\\n                 }\\n                \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+2*l]=str[i]+track[num][2];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]=str[i]+track[num][0];\\n\\n            // }\\n            return 4*l ;\\n\\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\"){\\n            vector<string>s1;\\n            return s1 ;\\n\\n        }\\n\\n\\n        string out[100000];\\n        int d=stoi(digits);\\n        int l=length(d,out);\\n        \\n        vector<string> v(out, out + l);\\n        return v ;\\n        \\n    }\\n};\\n\\n\\nif you like my solution and want me to help u in dsa then connect to me via linkedn:\\nhttps://www.linkedin.com/in/garima-jain-98a776217/\\n\\n  "
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript based simple solution | 99 %\n\nvar letterCombinations = function(digits) {\n    let tel = {\n        2:['a','b','c'],\n        3:['d','e','f'],\n        4:['g','h','i'],\n        5:['j','k','l'],\n        6:['m','n','o'],\n        7:['p','q','r','s'],\n        8:['t','u','v'],\n        9:['w','x','y','z']\n    }, arr1=tel[digits[0]],arr2=tel[digits[1]],array=[];\n    if(!digits.trim().length){\n        return [];\n    }\n    if(digits.length == 1){\n        return tel[digits];\n    }\n    for(let d=0;d<digits.length-1;d++) {\n        arr1 = array.length ? array : tel[digits[d]];\n        arr2 = tel[digits[d+1]];\n        if(array.length){\n            array =[];\n        }\n        if(digits[d+1]) {\n            for(let i=0;i<arr1.length;i++) {\n                for(let j=0;j<arr2.length;j++) {\n                    array.push(arr1[i]+arr2[j])\n                }\n            }\n        } else {\n            return array;\n        }\n\n    }\n    return array;\n    \n};"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(string& digits, vector<string>& ans, string output, int index, string mapping[]) {\\n\\n        if(index >= digits.length()) {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i=0; i<value.length(); i++) {\\n            output.push_back(value[i]);\\n            solve(digits, ans, output, index+1, mapping);\\n            output.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        \\n        vector<string> ans;\\n\\n        if(digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        string output = \"\";\\n        int index = 0;\\n        string mapping[10]= {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        solve(digits, ans, output, index, mapping);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshal31",
                        "content": "Why my code is giving error while submission. \n`\nlet keypad = [\n\t\"\", // 0\n\t\"\", // 1\n\t[\"a\", \"b\", \"c\"], // 2\n\t[\"d\", \"e\", \"f\"], // 3\n\t[\"g\", \"h\", \"i\"], // 4\n\t[\"j\", \"k\", \"l\"], // 5\n\t[\"m\", \"n\", \"o\"], // 6\n\t[\"p\", \"q\", \"r\", \"s\"], // 7\n\t[\"t\", \"u\", \"v\"], // 8\n\t[\"w\", \"x\", \"y\", \"z\"], // 9\n];\n\nfunction letterCombination(numStr, final, digitArr, res) {\n\tif (numStr.length === 0) {\n\t\tres.push(final);\n\t\treturn res;\n\t}\n\n\tlet num = numStr[0];\n\tdigitArr = keypad[num];\n\n\tfor (let i = 0; i < digitArr.length; i++) {\n\t\t// let ch = digitArr[i];\n\t\tletterCombination(\n\t\t\tnumStr.substring(1),\n\t\t\tfinal + digitArr[i],\n\t\t\tdigitArr[num + 1],\n\t\t\tres\n\t\t);\n\t}\n\n\treturn res;\n}\n\nlet num = \"77\";\nif (num !== \"\"){\n console.log(letterCombination(num, \"\", keypad[num[0]], []));\n}\nelse{ console.log(\"\");\n}\n`"
                    },
                    {
                        "username": "alqory",
                        "content": "i spend 1 hour to resolve excercise :)\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\n \\nvar pattern = {\\n         2 : [\"a\",\"b\",\"c\"],\\n         3 : [\"d\",\"e\",\"f\"],\\n         4 : [\"g\",\"h\",\"i\"],\\n         5 : [\"j\",\"k\",\"l\"],\\n         6 : [\"m\",\"n\",\"o\"],\\n         7 : [\"p\",\"q\",\"r\",\"s\"],\\n         8 : [\"t\",\"u\",\"v\"],\\n         9 : [\"w\",\"x\",\"y\",\"z\"]\\n     }\\n\\nvar result = []\\n\\n var letterCombinations = function(digits) {\\n    var iterate = 0\\n\\n    if(!digits) return [];\\n    else if(digits.length === 1) return pattern[digits]\\n\\n    while(iterate !== pattern[digits[0]].length) {\\n        for(let i = 0; i < pattern[digits[1]].length ; i++) {\\n            const combined = pattern[digits[0]][iterate] + pattern[digits[1]][i]\\n            result.push(combined)    \\n            }\\n        iterate++\\n    }\\n    return result;\\n }"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "class Solution {\\n    private:\\n    void solve(string digits, string output, int index, string mapping[], vector<string> &ans)\\n    {\\n        if(index >= digits.length())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i = 0; i < value.length(); i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digits, output, index + 1, mapping, ans);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n\\n        vector<string> ans;\\n        string output;\\n        if(digits.length() == 0)\\n            return ans;\\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        int index = 0;\\n        solve(digits, output, index, mapping, ans);\\n        return ans; \\n    "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html)"
                    },
                    {
                        "username": "Alban18",
                        "content": "My solution didn\\'t pass one of the test cases but my output and the expected output is the exact same except that some of my strings are ordered different s.t. \\nmy output: <wxy> \\nexpected output: <xyw>\\n\\nHow do I report this to Leetcode to fix?"
                    },
                    {
                        "username": "abenovakz",
                        "content": "Why does the synthetic error always indicate in this line   -    def threeSumClosest(self, nums: List[int], target: int) -> int:"
                    },
                    {
                        "username": "Manish_kumar2",
                        "content": "best is take call by reference value in means &ans in user defined function\n\nclass Solution {\nprivate:\n    void solve(string digits, int index, string output, vector<string> & ans, string mapping[]){\n        if(index >= digits.length()){\n            ans.push_back(output);\n            return;\n        }\n        int num = digits[index] - '0';\n        string value = mapping[num];\n        for(int i = 0; i < value.length(); i++){\n            output.push_back(value[i]);\n            solve(digits, index + 1, output, ans, mapping);\n            output.pop_back();\n        }\n    }\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> ans;\n        if(digits.length() == 0){\n            return ans;\n        }\n        string output;\n        int index = 0;\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        solve(digits, index, output, ans, mapping);\n        return ans;\n    }\n};"
                    }
                ]
            },
            {
                "id": 1633399,
                "content": [
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple approach to sole this question through iteration \\n#include<bits/stdc++.h>\\n#include <cstdlib>\\n#include <iostream>\\nusing namespace std ;\\n\\nclass Solution {\\n   \\n    private:\\n   \\n    int length(int digit,string str[]){\\n        string track[]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        if(digit==0){\\n            str[0]=\"\";\\n            return 1 ;\\n        }\\n\\n        int num=digit%10;\\n        int l=length(digit/10,str);\\n        if(num!=7 && num!=9){\\n           \\n            for(int i=0;i<l;i++){\\n                 int n=2;\\n                for(int j=0;j<track[num].length();j++){\\n                    str[i+n*l]=str[i]+track[num][j];\\n                    n--;\\n                }\\n            \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]= str[i]+track[num][0];\\n\\n            // }\\n            return 3*l;\\n        }\\n        else{\\n             for(int i=0;i<l;i++){\\n                    int n=3;\\n                 for(int j=0;j<track[num].length();j++){\\n                     str[i+n*l]= str[i]+track[num][j];\\n                     n--;\\n\\n                 }\\n                \\n            }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+2*l]=str[i]+track[num][2];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i+l]=str[i]+track[num][1];\\n\\n            // }\\n            // for(int i=0;i<l;i++){\\n            //      str[i]=str[i]+track[num][0];\\n\\n            // }\\n            return 4*l ;\\n\\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if(digits==\"\"){\\n            vector<string>s1;\\n            return s1 ;\\n\\n        }\\n\\n\\n        string out[100000];\\n        int d=stoi(digits);\\n        int l=length(d,out);\\n        \\n        vector<string> v(out, out + l);\\n        return v ;\\n        \\n    }\\n};\\n\\n\\nif you like my solution and want me to help u in dsa then connect to me via linkedn:\\nhttps://www.linkedin.com/in/garima-jain-98a776217/\\n\\n  "
                    },
                    {
                        "username": "ashish_ak",
                        "content": "JavaScript based simple solution | 99 %\n\nvar letterCombinations = function(digits) {\n    let tel = {\n        2:['a','b','c'],\n        3:['d','e','f'],\n        4:['g','h','i'],\n        5:['j','k','l'],\n        6:['m','n','o'],\n        7:['p','q','r','s'],\n        8:['t','u','v'],\n        9:['w','x','y','z']\n    }, arr1=tel[digits[0]],arr2=tel[digits[1]],array=[];\n    if(!digits.trim().length){\n        return [];\n    }\n    if(digits.length == 1){\n        return tel[digits];\n    }\n    for(let d=0;d<digits.length-1;d++) {\n        arr1 = array.length ? array : tel[digits[d]];\n        arr2 = tel[digits[d+1]];\n        if(array.length){\n            array =[];\n        }\n        if(digits[d+1]) {\n            for(let i=0;i<arr1.length;i++) {\n                for(let j=0;j<arr2.length;j++) {\n                    array.push(arr1[i]+arr2[j])\n                }\n            }\n        } else {\n            return array;\n        }\n\n    }\n    return array;\n    \n};"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(string& digits, vector<string>& ans, string output, int index, string mapping[]) {\\n\\n        if(index >= digits.length()) {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i=0; i<value.length(); i++) {\\n            output.push_back(value[i]);\\n            solve(digits, ans, output, index+1, mapping);\\n            output.pop_back();\\n        }\\n    }\\n\\n    vector<string> letterCombinations(string digits) {\\n        \\n        vector<string> ans;\\n\\n        if(digits.length() == 0) {\\n            return ans;\\n        }\\n\\n        string output = \"\";\\n        int index = 0;\\n        string mapping[10]= {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n\\n        solve(digits, ans, output, index, mapping);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshal31",
                        "content": "Why my code is giving error while submission. \n`\nlet keypad = [\n\t\"\", // 0\n\t\"\", // 1\n\t[\"a\", \"b\", \"c\"], // 2\n\t[\"d\", \"e\", \"f\"], // 3\n\t[\"g\", \"h\", \"i\"], // 4\n\t[\"j\", \"k\", \"l\"], // 5\n\t[\"m\", \"n\", \"o\"], // 6\n\t[\"p\", \"q\", \"r\", \"s\"], // 7\n\t[\"t\", \"u\", \"v\"], // 8\n\t[\"w\", \"x\", \"y\", \"z\"], // 9\n];\n\nfunction letterCombination(numStr, final, digitArr, res) {\n\tif (numStr.length === 0) {\n\t\tres.push(final);\n\t\treturn res;\n\t}\n\n\tlet num = numStr[0];\n\tdigitArr = keypad[num];\n\n\tfor (let i = 0; i < digitArr.length; i++) {\n\t\t// let ch = digitArr[i];\n\t\tletterCombination(\n\t\t\tnumStr.substring(1),\n\t\t\tfinal + digitArr[i],\n\t\t\tdigitArr[num + 1],\n\t\t\tres\n\t\t);\n\t}\n\n\treturn res;\n}\n\nlet num = \"77\";\nif (num !== \"\"){\n console.log(letterCombination(num, \"\", keypad[num[0]], []));\n}\nelse{ console.log(\"\");\n}\n`"
                    },
                    {
                        "username": "alqory",
                        "content": "i spend 1 hour to resolve excercise :)\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\n \\nvar pattern = {\\n         2 : [\"a\",\"b\",\"c\"],\\n         3 : [\"d\",\"e\",\"f\"],\\n         4 : [\"g\",\"h\",\"i\"],\\n         5 : [\"j\",\"k\",\"l\"],\\n         6 : [\"m\",\"n\",\"o\"],\\n         7 : [\"p\",\"q\",\"r\",\"s\"],\\n         8 : [\"t\",\"u\",\"v\"],\\n         9 : [\"w\",\"x\",\"y\",\"z\"]\\n     }\\n\\nvar result = []\\n\\n var letterCombinations = function(digits) {\\n    var iterate = 0\\n\\n    if(!digits) return [];\\n    else if(digits.length === 1) return pattern[digits]\\n\\n    while(iterate !== pattern[digits[0]].length) {\\n        for(let i = 0; i < pattern[digits[1]].length ; i++) {\\n            const combined = pattern[digits[0]][iterate] + pattern[digits[1]][i]\\n            result.push(combined)    \\n            }\\n        iterate++\\n    }\\n    return result;\\n }"
                    },
                    {
                        "username": "sakilahmed19202122",
                        "content": "class Solution {\\n    private:\\n    void solve(string digits, string output, int index, string mapping[], vector<string> &ans)\\n    {\\n        if(index >= digits.length())\\n        {\\n            ans.push_back(output);\\n            return;\\n        }\\n\\n        int number = digits[index] - \\'0\\';\\n        string value = mapping[number];\\n\\n        for(int i = 0; i < value.length(); i++)\\n        {\\n            output.push_back(value[i]);\\n            solve(digits, output, index + 1, mapping, ans);\\n            output.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n\\n        vector<string> ans;\\n        string output;\\n        if(digits.length() == 0)\\n            return ans;\\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        int index = 0;\\n        solve(digits, output, index, mapping, ans);\\n        return ans; \\n    "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-letter-combinations-of-phone-number-problem-solution.html)"
                    },
                    {
                        "username": "Alban18",
                        "content": "My solution didn\\'t pass one of the test cases but my output and the expected output is the exact same except that some of my strings are ordered different s.t. \\nmy output: <wxy> \\nexpected output: <xyw>\\n\\nHow do I report this to Leetcode to fix?"
                    },
                    {
                        "username": "abenovakz",
                        "content": "Why does the synthetic error always indicate in this line   -    def threeSumClosest(self, nums: List[int], target: int) -> int:"
                    },
                    {
                        "username": "Manish_kumar2",
                        "content": "best is take call by reference value in means &ans in user defined function\n\nclass Solution {\nprivate:\n    void solve(string digits, int index, string output, vector<string> & ans, string mapping[]){\n        if(index >= digits.length()){\n            ans.push_back(output);\n            return;\n        }\n        int num = digits[index] - '0';\n        string value = mapping[num];\n        for(int i = 0; i < value.length(); i++){\n            output.push_back(value[i]);\n            solve(digits, index + 1, output, ans, mapping);\n            output.pop_back();\n        }\n    }\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> ans;\n        if(digits.length() == 0){\n            return ans;\n        }\n        string output;\n        int index = 0;\n        string mapping[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        solve(digits, index, output, ans, mapping);\n        return ans;\n    }\n};"
                    }
                ]
            }
        ]
    }
]