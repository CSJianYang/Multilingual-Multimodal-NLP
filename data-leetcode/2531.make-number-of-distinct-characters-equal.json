[
    {
        "title": "Make Number of Distinct Characters Equal",
        "question_content": "You are given two 0-indexed strings word1 and word2.\nA move consists of choosing two indices i and j such that 0 <= i < word1.length and 0 <= j < word2.length and swapping word1[i] with word2[j].\nReturn true if it is possible to get the number of distinct characters in word1 and word2 to be equal with exactly one move. Return false otherwise.\n&nbsp;\nExample 1:\n\nInput: word1 = \"ac\", word2 = \"b\"\nOutput: false\nExplanation: Any pair of swaps would yield two distinct characters in the first string, and one in the second string.\n\nExample 2:\n\nInput: word1 = \"abcc\", word2 = \"aab\"\nOutput: true\nExplanation: We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = \"abac\" and word2 = \"cab\", which both have 3 distinct characters.\n\nExample 3:\n\nInput: word1 = \"abcde\", word2 = \"fghij\"\nOutput: true\nExplanation: Both resulting strings will have 5 distinct characters, regardless of which indices we swap.\n\n&nbsp;\nConstraints:\n\n\t1 <= word1.length, word2.length <= 105\n\tword1 and word2 consist of only lowercase English letters.",
        "solutions": [
            {
                "id": 3016751,
                "title": "java-c-python-detailed-explanation-fully-commented-try-all-combs-o-n-m-time",
                "content": "**Intution:**\\nSince we can choose **any** indices from both strings to swap and at the end we just need both to have same number of distinct characters. The only thing that matters is which alphabet (\\'a\\',\\'b\\', \\'c\\',...) we choose from word1 and which alphabet (\\'a\\',\\'b\\', \\'c\\',...) we choose from word2 to swap. Since, only lowercase(26 alphabets) are there. We can try swapping all possible alphabet pairs between the two. \\n\\n**Method:**\\n\\n1. Create two maps to store frequency of characters of the strings.\\n2. Try swapping all possible pairs of alphabets between word1 and word2.\\n\\n\\n\\tHow do we try swapping all possible pairs of alphabets between word1 and word2?\\n\\t\\t2.1 Create two for loops iterating c1: \\'a\\' to \\'z\\', c2: \\'a\\' to \\'z\\'\\n\\t\\t2.2 When char c1 is in word1 and char c2 is in word2\\n\\t\\t2.3 Remove c1 and put c2 in word1\\'s map\\n\\t\\t2.4 Remove c2 and put c1 in word2\\'s map\\n\\t\\t   \\n3. Now check the sizes of maps. If the maps\\' sizes are same means both words now have equal distinct characters. So, return true \\n4. If map sizes are not same then reset the maps back.\\n\\n\\tHow do we reset the maps?\\n\\t\\t4.1 Remove c2 and put back c1 in word1\\'s map  (opposite of 2.3)\\n\\t\\t4.2 Remove c1 and put back c2 in word2\\'s map  (opposite of 2.4)\\n\\n<br>\\n\\nSince we have are doing frequent insertion and removal from map. A helper function has been made to make the code simpler and concise. \\n\\n\\n```\\nvoid insertAndRemove(unordered_map<char,int>&mp, char toInsert, char toRemove){\\n```\\nIt takes 3 arguments. First is the map (unordered_map, HashMap, dictionary) which stores the char frequency of the word  . Second is the character to insert and Third is the character to remove.\\n\\n**IMP to Note:**\\nWhenever a character is removed from word i.e. when we substract map value by 1. In that case, if map value reaches 0 then we have to remove that key too from map\\n```\\nmp[c]--;                         // After we have done this\\nif(mp[c]==0) mp.erase(c);        // Need to do this too\\n```\\n\\n<br>\\n\\n**C++:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void insertAndRemove(unordered_map<char,int>&mp, char toInsert, char toRemove){   // made this helper fxn for easy insert/ removal from map\\n        mp[toInsert]++;     // increment freq for char to be inserted\\n        mp[toRemove]--;     // decrement freq for char to be removed\\n        if(mp[toRemove]==0) mp.erase(toRemove);  // if freq of that char reaches zero, then remove the key from map\\n    }\\n\\t\\n\\t// Remember to pass map as address in C++   \" & mp \"\\n    \\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> mp1, mp2;\\n        \\n        for(char w1: word1) mp1[w1]++;   // store freq of chars in word1 in mp1\\n        for(char w2: word2) mp2[w2]++;   // store freq of chars in word2 in mp2\\n\\n        for(char c1=\\'a\\'; c1<=\\'z\\'; c1++){\\n            for(char c2=\\'a\\'; c2<=\\'z\\'; c2++){\\n                if(mp1.count(c1)==0 || mp2.count(c2)==0) continue; // if any of the char is not present then skip\\n\\t\\t\\t\\t\\n                insertAndRemove(mp1, c2, c1); // insert c2 to word1 and remove c1 from word1\\n                insertAndRemove(mp2, c1, c2); // insert c1 to word2 and remove c2 from word2\\n                \\n                if(mp1.size()==mp2.size()) return true;  // if size of both maps are equal then possible return true\\n\\t\\t\\t\\t\\n                // reset back the maps\\n                insertAndRemove(mp1, c1, c2); // insert c1 back to word1 and remove c2 from word1             \\n                insertAndRemove(mp2, c2, c1); // insert c2 back to word2 and remove c1 from word2\\n                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n\\n**Java:**\\n\\n```\\nclass Solution {\\n    \\n    public void insertAndRemove(Map<Character, Integer> mp, char toInsert, char toRemove){  // made this helper fxn for easy removal from hashmap\\n        mp.put(toInsert, mp.getOrDefault(toInsert, 0) + 1); // increment freq for char to be inserted\\n        mp.put(toRemove, mp.getOrDefault(toRemove, 0) - 1); // decrement freq for char to be removed\\n        if(mp.get(toRemove)==0) mp.remove(toRemove); // if freq of that char reaches zero, then remove the key from hashmap\\n\\n    }\\n    \\n    public boolean isItPossible(String word1, String word2) {\\n        Map<Character, Integer> mp1 = new HashMap<>();\\n        Map<Character, Integer> mp2 = new HashMap<>();\\n        \\n        for (char w1: word1.toCharArray()) {   // store freq of chars in word1 in mp1\\n            mp1.put(w1, mp1.getOrDefault(w1, 0) + 1);\\n        }\\n        for (char w2: word2.toCharArray()) {   // store freq of chars in word2 in mp2\\n            mp2.put(w2, mp2.getOrDefault(w2, 0) + 1);\\n        }\\n\\n        \\n        for(char c1=\\'a\\'; c1<=\\'z\\'; c1++){\\n            for(char c2=\\'a\\'; c2<=\\'z\\'; c2++){\\n\\n                if(!mp1.containsKey(c1) || !mp2.containsKey(c2)) continue;  // if any of the char is not present then skip\\n\\t\\t\\t\\t\\n                insertAndRemove(mp1, c2, c1); // insert c2 to word1 and remove c1 from word1\\n                insertAndRemove(mp2, c1, c2); // insert c1 to word2 and remove c2 from word2\\n                \\n                if(mp1.size()==mp2.size()) return true;  // if size of both maps are equal then possible return true\\n\\t\\t\\t\\t\\n                // reset back the maps\\n                insertAndRemove(mp1, c1, c2); // insert c1 back to word1 and remove c2 from word1              \\n                insertAndRemove(mp2, c2, c1); // insert c2 back to word2 and remove c1 from word2\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\n\\n**Python:**\\n```\\nclass Solution:\\n    \\n    def insertAndRemove(self, mp, toInsert, toRemove): \\n        mp[toInsert]+=1\\n        mp[toRemove]-=1\\n        \\n        if(mp[toRemove]==0):\\n            del mp[toRemove]     # if freq of that char reaches zero, then remove the key from dict\\n        \\n        \\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        \\n        mp1, mp2 = Counter(word1), Counter(word2)  # Get freq of chars using Counter\\n\\t\\n        \"\"\"\\n        # If you are not familiar with Counters, you can simply do this:\\n        mp1=defaultdict(int)\\n        mp2=defaultdict(int)\\n\\n        for w1 in word1:\\n            mp1[w1]+=1;   #store freq of chars in word1 in mp1\\n\\n        for w2 in word2:\\n            mp2[w2]+=1;  #store freq of chars in word2 in mp2\\n        \"\"\"\\n\\t\\t\\n        for c1 in string.ascii_lowercase:         # this for loop iterates through c1=\\'a\\' to c1=\\'z\\'\\n            for c2 in string.ascii_lowercase:     # this for loop iterates through c2=\\'a\\' to c2=\\'z\\'\\n                \\n                if c1 not in mp1 or c2 not in mp2:  # if any of the char is not present then skip\\n                    continue\\n\\n                self.insertAndRemove(mp1, c2, c1); # insert c2 to word1 and remove c1 from word1\\n                self.insertAndRemove(mp2, c1, c2); # insert c1 to word2 and remove c2 from word2\\n                \\n                if len(mp1)== len(mp2):  # if size of both dicts are equal then possible return true\\n                    return True\\n\\t\\t\\t\\t\\n                # reset back the maps\\n                self.insertAndRemove(mp1, c1, c2); # insert c1 back to word1 and remove c2 from word1         \\n                self.insertAndRemove(mp2, c2, c1); # insert c2 back to word2 and remove c1 from word2                \\n        return False\\n```\\n\\n**Complexity Analysis:**\\nTime: O(N+M+26\\\\*26) i.e. O(N+M) : where N is the size of word1 and M is the size of word2 . We iterated both strings once, and a fixed 26\\\\*26 for loop (This 26*26 is constant, doesn\\'t depend on input variables i.e. string sizes N or M)\\nSpace: O(26) i.e O(1) : Since word1 and word2 consist of only lowercase English letters, so both map can have 26 elements only at max\\n\\n**Please upvote if you liked it.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nvoid insertAndRemove(unordered_map<char,int>&mp, char toInsert, char toRemove){\\n```\n```\\nmp[c]--;                         // After we have done this\\nif(mp[c]==0) mp.erase(c);        // Need to do this too\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void insertAndRemove(unordered_map<char,int>&mp, char toInsert, char toRemove){   // made this helper fxn for easy insert/ removal from map\\n        mp[toInsert]++;     // increment freq for char to be inserted\\n        mp[toRemove]--;     // decrement freq for char to be removed\\n        if(mp[toRemove]==0) mp.erase(toRemove);  // if freq of that char reaches zero, then remove the key from map\\n    }\\n\\t\\n\\t// Remember to pass map as address in C++   \" & mp \"\\n    \\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> mp1, mp2;\\n        \\n        for(char w1: word1) mp1[w1]++;   // store freq of chars in word1 in mp1\\n        for(char w2: word2) mp2[w2]++;   // store freq of chars in word2 in mp2\\n\\n        for(char c1=\\'a\\'; c1<=\\'z\\'; c1++){\\n            for(char c2=\\'a\\'; c2<=\\'z\\'; c2++){\\n                if(mp1.count(c1)==0 || mp2.count(c2)==0) continue; // if any of the char is not present then skip\\n\\t\\t\\t\\t\\n                insertAndRemove(mp1, c2, c1); // insert c2 to word1 and remove c1 from word1\\n                insertAndRemove(mp2, c1, c2); // insert c1 to word2 and remove c2 from word2\\n                \\n                if(mp1.size()==mp2.size()) return true;  // if size of both maps are equal then possible return true\\n\\t\\t\\t\\t\\n                // reset back the maps\\n                insertAndRemove(mp1, c1, c2); // insert c1 back to word1 and remove c2 from word1             \\n                insertAndRemove(mp2, c2, c1); // insert c2 back to word2 and remove c1 from word2\\n                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\n    public void insertAndRemove(Map<Character, Integer> mp, char toInsert, char toRemove){  // made this helper fxn for easy removal from hashmap\\n        mp.put(toInsert, mp.getOrDefault(toInsert, 0) + 1); // increment freq for char to be inserted\\n        mp.put(toRemove, mp.getOrDefault(toRemove, 0) - 1); // decrement freq for char to be removed\\n        if(mp.get(toRemove)==0) mp.remove(toRemove); // if freq of that char reaches zero, then remove the key from hashmap\\n\\n    }\\n    \\n    public boolean isItPossible(String word1, String word2) {\\n        Map<Character, Integer> mp1 = new HashMap<>();\\n        Map<Character, Integer> mp2 = new HashMap<>();\\n        \\n        for (char w1: word1.toCharArray()) {   // store freq of chars in word1 in mp1\\n            mp1.put(w1, mp1.getOrDefault(w1, 0) + 1);\\n        }\\n        for (char w2: word2.toCharArray()) {   // store freq of chars in word2 in mp2\\n            mp2.put(w2, mp2.getOrDefault(w2, 0) + 1);\\n        }\\n\\n        \\n        for(char c1=\\'a\\'; c1<=\\'z\\'; c1++){\\n            for(char c2=\\'a\\'; c2<=\\'z\\'; c2++){\\n\\n                if(!mp1.containsKey(c1) || !mp2.containsKey(c2)) continue;  // if any of the char is not present then skip\\n\\t\\t\\t\\t\\n                insertAndRemove(mp1, c2, c1); // insert c2 to word1 and remove c1 from word1\\n                insertAndRemove(mp2, c1, c2); // insert c1 to word2 and remove c2 from word2\\n                \\n                if(mp1.size()==mp2.size()) return true;  // if size of both maps are equal then possible return true\\n\\t\\t\\t\\t\\n                // reset back the maps\\n                insertAndRemove(mp1, c1, c2); // insert c1 back to word1 and remove c2 from word1              \\n                insertAndRemove(mp2, c2, c1); // insert c2 back to word2 and remove c1 from word2\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    \\n    def insertAndRemove(self, mp, toInsert, toRemove): \\n        mp[toInsert]+=1\\n        mp[toRemove]-=1\\n        \\n        if(mp[toRemove]==0):\\n            del mp[toRemove]     # if freq of that char reaches zero, then remove the key from dict\\n        \\n        \\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        \\n        mp1, mp2 = Counter(word1), Counter(word2)  # Get freq of chars using Counter\\n\\t\\n        \"\"\"\\n        # If you are not familiar with Counters, you can simply do this:\\n        mp1=defaultdict(int)\\n        mp2=defaultdict(int)\\n\\n        for w1 in word1:\\n            mp1[w1]+=1;   #store freq of chars in word1 in mp1\\n\\n        for w2 in word2:\\n            mp2[w2]+=1;  #store freq of chars in word2 in mp2\\n        \"\"\"\\n\\t\\t\\n        for c1 in string.ascii_lowercase:         # this for loop iterates through c1=\\'a\\' to c1=\\'z\\'\\n            for c2 in string.ascii_lowercase:     # this for loop iterates through c2=\\'a\\' to c2=\\'z\\'\\n                \\n                if c1 not in mp1 or c2 not in mp2:  # if any of the char is not present then skip\\n                    continue\\n\\n                self.insertAndRemove(mp1, c2, c1); # insert c2 to word1 and remove c1 from word1\\n                self.insertAndRemove(mp2, c1, c2); # insert c1 to word2 and remove c2 from word2\\n                \\n                if len(mp1)== len(mp2):  # if size of both dicts are equal then possible return true\\n                    return True\\n\\t\\t\\t\\t\\n                # reset back the maps\\n                self.insertAndRemove(mp1, c1, c2); # insert c1 back to word1 and remove c2 from word1         \\n                self.insertAndRemove(mp2, c2, c1); # insert c2 back to word2 and remove c1 from word2                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016762,
                "title": "my-accepted-o-26-26-m-n-solution",
                "content": "**Intuition:**\\n*Simple brute force for every pair of characters in both strings.*\\n\\n**Steps with explanation:** \\n1. Store frequency of characters of both strings.\\n2. Count no of unique characters in each string.\\n3. If no of unique characters in both strings are equal and both the string lengths are equal, then it is always possible to get equal no of unique characters after one swap.\\n\\n\\tLets understand this step by step with few examples:\\n\\n\\t* Example 1:\\n\\t\\tword1 = `\"abc\"`\\n\\t\\tword2 = `\"def\"`\\n\\n\\t\\tLets say, we take `\"a\"` and `\"d\"`. After swapping, word1 = `\"dbc\"` and word2 = `\"aef\"`\\n\\t\\tHence, no of unique characters are same after swapping.\\n\\n\\t* Example 2:\\n\\t\\tword1 = `\"aaa\"`\\n\\t\\tword2 = `\"bbb\"`\\n\\n\\t\\tLets say, we take any `\"a\"` and any `\"b\"`. After swapping, word1 = `\"aab\"` and word2 = `\"bba\"`\\n\\t\\tHence, no of unique characters are same after swapping.\\n\\n\\t* Example 3:\\n\\t\\tword1 = `\"aab\"`\\n\\t\\tword2 = `\"bba\"`\\n\\n\\t\\tLets say, we take `\"a\"` from word1 and `\"b\"` from word2. After swapping, word1 = `\"bab\"` and word2 = `\"aba\"`\\n\\t\\tHence, no of unique characters are same after swapping.\\n\\n\\t* Example 4:\\n\\t\\tword1 = `\"aab\"`\\n\\t\\tword2 = `\"bbc\"`\\n\\n\\t\\tLets say, we take `\"b\"` from word1 and `\"b\"` from word3. After swapping, word1 = `\"aab\"` and word2 = `\"bbc\"`.\\n\\t\\tHence, no of unique characters are same after swapping.\\n\\n4. Now if the two string lengths are not equal, we need to check for each pair of different characters from both strings.\\n\\n\\tHere, we do not need to actually swap the characters. We can simply simulate this swapping just by changing the frequency of characters in our frequency map. Lets understand this with an example.\\n\\n\\tExample:\\n\\tword1 = `\"aaabb\"`\\n\\tword2 = `\"ccdd\"`\\n\\n\\tFrequency map of word1, map1 = `[\\'a\\' = 3, \\'b\\' = 2]` and count of unique characters = `2`\\n\\tFrequency map of word2, map2 = `[\\'c\\' = 2, \\'d\\' = 2]` and count of unique characters = `2`\\n\\n\\tLets say, we need to swap \\'a\\' with \\'c\\'. So after swapping, map1 = `[\\'a\\' = 2, \\'b\\' = 2, \\'c\\' = 1]`, and map2 = `[\\'a\\' = 1, \\'c\\' = 1, \\'d\\' = 2]`.\\n\\n\\tSo for any char `i` from word1 and char `j` from word2, we are increasing freq of `j` in map1 and decreasing freq of `i` in map1. In the same way, we are also increasing freq of `i` in map2 and decreasing freq of `j` in map2. Now this change of freq may change the no of unique characters as we saw in the example.\\n\\n\\tWhile doing this process, we can also keep track of change of unique chars by changing count1 and count2.\\n\\n\\tLets say, characters are `[\\'a\\', \\'b\\', \\'c\\']` and we want to decrease freq of `\\'a\\'`. The count of unique chars will only change (decrease in this case) if count of `\\'a\\'` is `1` initially.\\n\\n\\tLets say, characters are `[\\'a\\', \\'b\\']` and we want to increase freq of `\\'c\\'`. The count of unique chars will only change (increase in this case) if `\\'c\\'` is not present in characters initially.\\n\\n5. Check if the count of unique chars becomes equal in any situation. If so, return true.\\n\\n6. We need to revert all changes done to frequency maps while simulating the swappping process.\\n\\n\\n**Java Code:**\\n```java\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] map1 = new int[26];\\n        int[] map2 = new int[26];\\n        \\n\\t\\t// store frequency of characters\\n        for (int i = 0; i < word1.length(); i++) map1[word1.charAt(i)-\\'a\\']++;\\n        for (int i = 0; i < word2.length(); i++) map2[word2.charAt(i)-\\'a\\']++;\\n\\t\\t\\n\\t\\tint count1 = 0, count2 = 0;\\n\\t\\t// count no of distinct characters in each string\\n        for (int i = 0; i < 26; i++) {\\n            if (map1[i] > 0) count1++;\\n            if (map2[i] > 0) count2++;\\n        }\\n        \\n\\t\\t// as explained in step 3\\n        if (count1 == count2 && word1.length() == word2.length()) return true;\\n        \\n        for (int i = 0; i < 26; i++) {\\n        \\tfor (int j = 0; j < 26; j++) {\\n                if (map1[i] == 0 || map2[j] == 0) continue;\\n                \\n                int uniqueCharInMap1 = count1, uniqueCharInMap2 = count2;\\n                \\n\\t\\t\\t\\t// changing char count for map1\\n                if (map1[j] == 0) uniqueCharInMap1++;\\n                map1[j]++;\\n                \\n                if (map1[i] == 1) uniqueCharInMap1--;\\n                map1[i]--;\\n                \\n\\t\\t\\t\\t// changing char count for map2\\n                if (map2[i] == 0) uniqueCharInMap2++;\\n                map2[i]++;\\n                \\n                if (map2[j] == 1) uniqueCharInMap2--;\\n                map2[j]--;\\n                \\n\\t\\t\\t\\t// if count of unique chars are same, return true\\n                if (uniqueCharInMap1 == uniqueCharInMap2) return true;\\n                \\n                map1[j]--;\\n                map1[i]++;\\n                map2[i]--;\\n                map2[j]++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\n**C++ Code:**\\n```cpp\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> map1(26, 0);\\n        vector<int> map2(26, 0);\\n        \\n        // store frequency of characters\\n        for (int i = 0; i < word1.length(); i++) map1[word1[i]-\\'a\\']++;\\n        for (int i = 0; i < word2.length(); i++) map2[word2[i]-\\'a\\']++;\\n\\n        int count1 = 0, count2 = 0;\\n\\t\\t// count no of distinct characters in each string\\n        for (int i = 0; i < 26; i++) {\\n            if (map1[i] > 0) count1++;\\n            if (map2[i] > 0) count2++;\\n        }\\n        \\n        // as explained in step 3\\n        if (count1 == count2 && word1.length() == word2.length()) return true;\\n        \\n        for (int i = 0; i < 26; i++) {\\n        \\tfor (int j = 0; j < 26; j++) {\\n                if (map1[i] == 0 || map2[j] == 0) continue;\\n                \\n                int uniqueCharInMap1 = count1, uniqueCharInMap2 = count2;\\n                \\n\\t\\t\\t\\t// changing char count for map1\\n                if (map1[j] == 0) uniqueCharInMap1++;\\n                map1[j]++;\\n                \\n                if (map1[i] == 1) uniqueCharInMap1--;\\n                map1[i]--;\\n                \\n\\t\\t\\t\\t// changing char count for map2\\n                if (map2[i] == 0) uniqueCharInMap2++;\\n                map2[i]++;\\n                \\n                if (map2[j] == 1) uniqueCharInMap2--;\\n                map2[j]--;\\n                \\n\\t\\t\\t\\t// if count of unique chars are same, return true\\n                if (uniqueCharInMap1 == uniqueCharInMap2) return true;\\n                \\n                map1[j]--;\\n                map1[i]++;\\n                map2[i]--;\\n                map2[j]++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n**Complexity Analysis:**\\n*Time Complexity:* **O(26 * 26  + (m+n)) --> O(m+n) --> O(max(m,n))**\\n*Space Complexity:* **O(26+26) --> O(1)**",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] map1 = new int[26];\\n        int[] map2 = new int[26];\\n        \\n\\t\\t// store frequency of characters\\n        for (int i = 0; i < word1.length(); i++) map1[word1.charAt(i)-\\'a\\']++;\\n        for (int i = 0; i < word2.length(); i++) map2[word2.charAt(i)-\\'a\\']++;\\n\\t\\t\\n\\t\\tint count1 = 0, count2 = 0;\\n\\t\\t// count no of distinct characters in each string\\n        for (int i = 0; i < 26; i++) {\\n            if (map1[i] > 0) count1++;\\n            if (map2[i] > 0) count2++;\\n        }\\n        \\n\\t\\t// as explained in step 3\\n        if (count1 == count2 && word1.length() == word2.length()) return true;\\n        \\n        for (int i = 0; i < 26; i++) {\\n        \\tfor (int j = 0; j < 26; j++) {\\n                if (map1[i] == 0 || map2[j] == 0) continue;\\n                \\n                int uniqueCharInMap1 = count1, uniqueCharInMap2 = count2;\\n                \\n\\t\\t\\t\\t// changing char count for map1\\n                if (map1[j] == 0) uniqueCharInMap1++;\\n                map1[j]++;\\n                \\n                if (map1[i] == 1) uniqueCharInMap1--;\\n                map1[i]--;\\n                \\n\\t\\t\\t\\t// changing char count for map2\\n                if (map2[i] == 0) uniqueCharInMap2++;\\n                map2[i]++;\\n                \\n                if (map2[j] == 1) uniqueCharInMap2--;\\n                map2[j]--;\\n                \\n\\t\\t\\t\\t// if count of unique chars are same, return true\\n                if (uniqueCharInMap1 == uniqueCharInMap2) return true;\\n                \\n                map1[j]--;\\n                map1[i]++;\\n                map2[i]--;\\n                map2[j]++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> map1(26, 0);\\n        vector<int> map2(26, 0);\\n        \\n        // store frequency of characters\\n        for (int i = 0; i < word1.length(); i++) map1[word1[i]-\\'a\\']++;\\n        for (int i = 0; i < word2.length(); i++) map2[word2[i]-\\'a\\']++;\\n\\n        int count1 = 0, count2 = 0;\\n\\t\\t// count no of distinct characters in each string\\n        for (int i = 0; i < 26; i++) {\\n            if (map1[i] > 0) count1++;\\n            if (map2[i] > 0) count2++;\\n        }\\n        \\n        // as explained in step 3\\n        if (count1 == count2 && word1.length() == word2.length()) return true;\\n        \\n        for (int i = 0; i < 26; i++) {\\n        \\tfor (int j = 0; j < 26; j++) {\\n                if (map1[i] == 0 || map2[j] == 0) continue;\\n                \\n                int uniqueCharInMap1 = count1, uniqueCharInMap2 = count2;\\n                \\n\\t\\t\\t\\t// changing char count for map1\\n                if (map1[j] == 0) uniqueCharInMap1++;\\n                map1[j]++;\\n                \\n                if (map1[i] == 1) uniqueCharInMap1--;\\n                map1[i]--;\\n                \\n\\t\\t\\t\\t// changing char count for map2\\n                if (map2[i] == 0) uniqueCharInMap2++;\\n                map2[i]++;\\n                \\n                if (map2[j] == 1) uniqueCharInMap2--;\\n                map2[j]--;\\n                \\n\\t\\t\\t\\t// if count of unique chars are same, return true\\n                if (uniqueCharInMap1 == uniqueCharInMap2) return true;\\n                \\n                map1[j]--;\\n                map1[i]++;\\n                map2[i]--;\\n                map2[j]++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016886,
                "title": "c-o-26-26-just-use-map-swap-learn-thought-process",
                "content": "**Thought process**:\\n\\nBrute force - As the max `word.length` is `10^5`, doing a `word1 x word2` for each `i,j` would cost us `O(N^2`) which is very less likely to get accepted.\\n\\nHow can we improve this?\\n* Since we are talking about swapping, From previous problems we have learned that if we had unlimited swaps - we could do big things with the whole `word1 + word2` together as a word and apply some `greedy` logic.\\n* Tried few examples and it did not make much sense.\\n* But wait.. we are **swapping only once**, we could try something easy with `map`.\\n\\nThinking of using map?\\nMmm well yes, since we have only `26 chars` and we could reduce it to `O(26 x 26)` complexity, and swap and check each time - which is well good to get accepted.\\n\\n**Code**\\n```cpp\\nbool isItPossible(string word1, string word2) {\\n    unordered_map<char, int> mp1, mp2;\\n    //add all chars to the map\\n    for(char ch: word1) mp1[ch]++;\\n    for(char ch: word2) mp2[ch]++;\\n\\n    for(int i=0; i < 26; i++){\\n        for(int j=0; j < 26; j++){\\n            char ch1 = i + \\'a\\', ch2 = j + \\'a\\';\\n            if(mp1.count(ch1) && mp2.count(ch2)){\\n                //remove one char from both to swap\\n                if(--mp1[ch1] == 0) mp1.erase(ch1);\\n                if(--mp2[ch2] == 0) mp2.erase(ch2);\\n\\n                //add the new char\\n                mp1[ch2]++;\\n                mp2[ch1]++;\\n\\n                //if distinct chars in both, return true\\n                if(mp1.size() == mp2.size())\\n                    return true;\\n\\n                //add back the removed chars, also remove the new added chars\\n                if(--mp1[ch2] == 0) mp1.erase(ch2);\\n                if(--mp2[ch1] == 0) mp2.erase(ch1);\\n                mp1[ch1]++;\\n                mp2[ch2]++;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\\n**Upvote and lets learn together :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool isItPossible(string word1, string word2) {\\n    unordered_map<char, int> mp1, mp2;\\n    //add all chars to the map\\n    for(char ch: word1) mp1[ch]++;\\n    for(char ch: word2) mp2[ch]++;\\n\\n    for(int i=0; i < 26; i++){\\n        for(int j=0; j < 26; j++){\\n            char ch1 = i + \\'a\\', ch2 = j + \\'a\\';\\n            if(mp1.count(ch1) && mp2.count(ch2)){\\n                //remove one char from both to swap\\n                if(--mp1[ch1] == 0) mp1.erase(ch1);\\n                if(--mp2[ch2] == 0) mp2.erase(ch2);\\n\\n                //add the new char\\n                mp1[ch2]++;\\n                mp2[ch1]++;\\n\\n                //if distinct chars in both, return true\\n                if(mp1.size() == mp2.size())\\n                    return true;\\n\\n                //add back the removed chars, also remove the new added chars\\n                if(--mp1[ch2] == 0) mp1.erase(ch2);\\n                if(--mp2[ch1] == 0) mp2.erase(ch1);\\n                mp1[ch1]++;\\n                mp2[ch2]++;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3016728,
                "title": "self-explanatory-o-26-26-c",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool isItPossible(string word1, string word2) {\\n       unordered_map<char,int>mp1,mp2;\\n        \\n        for(auto it:word1)\\n            mp1[it]++;\\n        \\n        for(auto it:word2)\\n            mp2[it]++;\\n        \\n        for(auto it1:mp1)\\n        {\\n            char c=it1.first;\\n            for(auto it:mp2)\\n            {\\n                unordered_map<char,int>d1=mp1,d2=mp2;\\n                d2[c]++;  //adding new char to mp2\\n                d1[it.first]++; //adding new char to mp1\\n                \\n                //swaping two char result\\n                d2[it.first]--; \\n                d1[c]--;\\n                \\n                \\n                if(d2[it.first]==0)\\n                    d2.erase(it.first);\\n                \\n                if(d1[c]==0)\\n                    d1.erase(c);\\n                \\n                if(d1.size()==d2.size())\\n                    return true;\\n                \\n                \\n            }\\n        }\\n        return false;\\n        \\n\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool isItPossible(string word1, string word2) {\\n       unordered_map<char,int>mp1,mp2;\\n        \\n        for(auto it:word1)\\n            mp1[it]++;\\n        \\n        for(auto it:word2)\\n            mp2[it]++;\\n        \\n        for(auto it1:mp1)\\n        {\\n            char c=it1.first;\\n            for(auto it:mp2)\\n            {\\n                unordered_map<char,int>d1=mp1,d2=mp2;\\n                d2[c]++;  //adding new char to mp2\\n                d1[it.first]++; //adding new char to mp1\\n                \\n                //swaping two char result\\n                d2[it.first]--; \\n                d1[c]--;\\n                \\n                \\n                if(d2[it.first]==0)\\n                    d2.erase(it.first);\\n                \\n                if(d1[c]==0)\\n                    d1.erase(c);\\n                \\n                if(d1.size()==d2.size())\\n                    return true;\\n                \\n                \\n            }\\n        }\\n        return false;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016989,
                "title": "c-java-python3-freq-table",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/cd738c7122f758231c4f575936d09271343de490) for solutions of weekly 327. \\n\\n**Intuition**\\nWe attempt each character pair (`a`, `a`), (`a`, `b`), ..., (`z`, `z`) and see if any swap can result in equal number of unique characters. \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<int, int> freq1, freq2; \\n        for (auto& ch : word1) ++freq1[ch]; \\n        for (auto& ch : word2) ++freq2[ch]; \\n        int sz1 = freq1.size(), sz2 = freq2.size(); \\n        for (char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1) \\n            for (char c2 = \\'a\\'; c2 <= \\'z\\'; ++c2) \\n                if (freq1[c1] && freq2[c2]) \\n                    if (c1 == c2) {\\n                        if (sz1 == sz2) return true; \\n                    } else {\\n                        int cnt1 = sz1, cnt2 = sz2; \\n                        if (freq1[c1] == 1) --cnt1; \\n                        if (freq1[c2] == 0) ++cnt1; \\n                        if (freq2[c1] == 0) ++cnt2; \\n                        if (freq2[c2] == 1) --cnt2; \\n                        if (cnt1 == cnt2) return true; \\n                    }\\n        return false; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        HashMap<Character, Integer> freq1 = new HashMap(), freq2 = new HashMap(); \\n        for (var ch : word1.toCharArray()) freq1.merge(ch, 1, Integer::sum); \\n        for (var ch : word2.toCharArray()) freq2.merge(ch, 1, Integer::sum); \\n        int sz1 = freq1.size(), sz2 = freq2.size(); \\n        for (char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1) \\n            for (char c2 = \\'a\\'; c2 <= \\'z\\'; ++c2) \\n                if (freq1.getOrDefault(c1, 0) > 0 && freq2.getOrDefault(c2, 0) > 0) \\n                    if (c1 == c2) {\\n                        if (sz1 == sz2) return true; \\n                    } else {\\n                        int cnt1 = sz1, cnt2 = sz2; \\n                        if (freq1.getOrDefault(c1, 0) == 1) --cnt1; \\n                        if (freq1.getOrDefault(c2, 0) == 0) ++cnt1; \\n                        if (freq2.getOrDefault(c1, 0) == 0) ++cnt2; \\n                        if (freq2.getOrDefault(c2, 0) == 1) --cnt2; \\n                        if (cnt1 == cnt2) return true; \\n                    }\\n        return false; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        freq1 = Counter(word1)\\n        freq2 = Counter(word2)\\n        sz1, sz2 = len(freq1), len(freq2)\\n        for c1 in ascii_lowercase: \\n            for c2 in ascii_lowercase: \\n                if freq1[c1] and freq2[c2]: \\n                    if c1 == c2: \\n                        if sz1 == sz2: return True \\n                    else: \\n                        cnt1, cnt2 = sz1, sz2 \\n                        if freq1[c1] == 1: cnt1 -= 1\\n                        if freq1[c2] == 0: cnt1 += 1\\n                        if freq2[c1] == 0: cnt2 += 1\\n                        if freq2[c2] == 1: cnt2 -= 1\\n                        if cnt1 == cnt2: return True \\n        return False \\n```\\n**Complexity**\\nTime `O(M+N)`\\nSpace `O(1)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<int, int> freq1, freq2; \\n        for (auto& ch : word1) ++freq1[ch]; \\n        for (auto& ch : word2) ++freq2[ch]; \\n        int sz1 = freq1.size(), sz2 = freq2.size(); \\n        for (char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1) \\n            for (char c2 = \\'a\\'; c2 <= \\'z\\'; ++c2) \\n                if (freq1[c1] && freq2[c2]) \\n                    if (c1 == c2) {\\n                        if (sz1 == sz2) return true; \\n                    } else {\\n                        int cnt1 = sz1, cnt2 = sz2; \\n                        if (freq1[c1] == 1) --cnt1; \\n                        if (freq1[c2] == 0) ++cnt1; \\n                        if (freq2[c1] == 0) ++cnt2; \\n                        if (freq2[c2] == 1) --cnt2; \\n                        if (cnt1 == cnt2) return true; \\n                    }\\n        return false; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        HashMap<Character, Integer> freq1 = new HashMap(), freq2 = new HashMap(); \\n        for (var ch : word1.toCharArray()) freq1.merge(ch, 1, Integer::sum); \\n        for (var ch : word2.toCharArray()) freq2.merge(ch, 1, Integer::sum); \\n        int sz1 = freq1.size(), sz2 = freq2.size(); \\n        for (char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1) \\n            for (char c2 = \\'a\\'; c2 <= \\'z\\'; ++c2) \\n                if (freq1.getOrDefault(c1, 0) > 0 && freq2.getOrDefault(c2, 0) > 0) \\n                    if (c1 == c2) {\\n                        if (sz1 == sz2) return true; \\n                    } else {\\n                        int cnt1 = sz1, cnt2 = sz2; \\n                        if (freq1.getOrDefault(c1, 0) == 1) --cnt1; \\n                        if (freq1.getOrDefault(c2, 0) == 0) ++cnt1; \\n                        if (freq2.getOrDefault(c1, 0) == 0) ++cnt2; \\n                        if (freq2.getOrDefault(c2, 0) == 1) --cnt2; \\n                        if (cnt1 == cnt2) return true; \\n                    }\\n        return false; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        freq1 = Counter(word1)\\n        freq2 = Counter(word2)\\n        sz1, sz2 = len(freq1), len(freq2)\\n        for c1 in ascii_lowercase: \\n            for c2 in ascii_lowercase: \\n                if freq1[c1] and freq2[c2]: \\n                    if c1 == c2: \\n                        if sz1 == sz2: return True \\n                    else: \\n                        cnt1, cnt2 = sz1, sz2 \\n                        if freq1[c1] == 1: cnt1 -= 1\\n                        if freq1[c2] == 0: cnt1 += 1\\n                        if freq2[c1] == 0: cnt2 += 1\\n                        if freq2[c2] == 1: cnt2 -= 1\\n                        if cnt1 == cnt2: return True \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017248,
                "title": "26-25",
                "content": "For both strings, count each character (`cnt1` and `cnt2`), and distinct characters (`dist1` and `dist2`).\\n\\nThen, we try 26 * 25 combinations to swap letter `i` and `j`. \\n\\n> There is a tricky edge case when we swap the same letter.\\n> We return true if `dist1 == dist2`, and there is a common letter.\\n> We take care of it first, and we only check 25 letters (`i != j`) in the second loop.\\n\\n**C++**\\n```cpp\\nbool isItPossible(string word1, string word2) {\\n    int cnt1[26] = {}, cnt2[26] = {}, dist1 = 0, dist2 = 0;\\n    for (auto ch : word1)\\n        dist1 += ++cnt1[ch - \\'a\\'] == 1;\\n    for (auto ch : word2)\\n        dist2 += ++cnt2[ch - \\'a\\'] == 1;\\n    if (dist1 == dist2 && inner_product(begin(cnt1), end(cnt1), begin(cnt2), 0LL, plus<>(), multiplies<long long>()))\\n        return true;\\n    for (int i = 0; i < 26; ++i)\\n        if (cnt1[i])\\n            for (int j = 0; j < 26; ++j)\\n                if (cnt2[j])\\n                    if (i != j && dist1 - (cnt1[i] == 1) + (cnt1[j] == 0) ==\\n                       dist2 - (cnt2[j] == 1) + (cnt2[i] == 0))\\n                        return true;\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool isItPossible(string word1, string word2) {\\n    int cnt1[26] = {}, cnt2[26] = {}, dist1 = 0, dist2 = 0;\\n    for (auto ch : word1)\\n        dist1 += ++cnt1[ch - \\'a\\'] == 1;\\n    for (auto ch : word2)\\n        dist2 += ++cnt2[ch - \\'a\\'] == 1;\\n    if (dist1 == dist2 && inner_product(begin(cnt1), end(cnt1), begin(cnt2), 0LL, plus<>(), multiplies<long long>()))\\n        return true;\\n    for (int i = 0; i < 26; ++i)\\n        if (cnt1[i])\\n            for (int j = 0; j < 26; ++j)\\n                if (cnt2[j])\\n                    if (i != j && dist1 - (cnt1[i] == 1) + (cnt1[j] == 0) ==\\n                       dist2 - (cnt2[j] == 1) + (cnt2[i] == 0))\\n                        return true;\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3020489,
                "title": "java-clear-explanations-efficient-simulation-8ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Let\\'s count unique chars from w1  (word1) and w2 (word2) as c1 and c2\\n- Let\\'s say we swap char a from w1 with char b from w2 (word2), few scenarios:\\n    - if a is unique in w1, c1--\\n        - else do nothing\\n    - if a do not exist in w2, c2++\\n        - else do nothing\\n    - Similarly, if b is unique in w2, c2--\\n        - else do nothing\\n    - if b do not existing in w1, c1++\\n        - else do nothing\\n    - One corner case, if a and b is the same char:\\n        - Check if a was unique in w1, we increase back c1 where it was decreased while moved out of w1. (so c1++)\\n- Of course, we iterative 26*26 instead of len(w1) * len(w2) as an optimization\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(26*26+m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public boolean isItPossible(String w1, String w2) {\\n        int[] m1 = new int[26], m2 = new int[26]; // freq map\\n        int c1 = 0, c2 = 0; // unique chars count for w1 and w2\\n        for (char c : w1.toCharArray()) if (m1[c-\\'a\\']++ == 0) c1++;\\n        for (char c : w2.toCharArray()) if (m2[c-\\'a\\']++ == 0) c2++;\\n\\n        if (Math.abs(c1 - c2) > 2) return false; // early termination\\n\\n        for (int i = 0; i < 26; i++) {\\n            if (m1[i] == 0) continue; // select only a char exist in w1\\n            int a1 = c1, a2 = c2; // if this one doesn\\'t work, we need to put it back (recover c1 and c2), so easier way is to make a copy\\n            if (m1[i] == 1) a1--; // We took somethign unique from w1\\n            if (m2[i] == 0) a2++; // And this char do not exist in w2\\n            for (int j = 0; j < 26; j++) {\\n                if (m2[j] == 0) continue; // select only what exists in w2\\n\\n                int b1 = a1, b2 = a2; // again, make a copy to avoid recover the counts later\\n                if (i == j) {if (m1[i] == 1) b1++;} // if we swap same char between w1 and w2, and if count was decreased from w1, add it back\\n                else if (m2[j] == 1) b2--; // otherwirse decrease unique count of w2\\n\\n                if (m1[j] == 0) b1++; // if this char do not exist in w1, add unique count to w1\\n                if (b1 == b2) return true; // if unique counts are the same after swap, we acheived whats been asked\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n# A simpler but slightly inefficient way\\nCalucate unique counts on the fly, avoid corner cases\\nTC: O(26^3+m+n), space is same as before\\n```java\\nclass Solution {\\n    public boolean isItPossible(String w1, String w2) {\\n        int[] m1 = new int[26], m2 = new int[26]; // freq map\\n        int c1 = 0, c2 = 0; // unique chars count for w1 and w2\\n        for (char c : w1.toCharArray()) if (m1[c-\\'a\\']++ == 0) c1++;\\n        for (char c : w2.toCharArray()) if (m2[c-\\'a\\']++ == 0) c2++;\\n\\n        if (Math.abs(c1 - c2) > 2) return false; // early termination\\n\\n        for (int i = 0; i < 26; i++) {\\n            if (m1[i] == 0) continue; // select only a char exist in w1\\n            for (int j = 0; j < 26; j++) {\\n                if (m2[j] == 0) continue; // select only what exists in w2\\n                m1[i]--;m2[i]++;m1[j]++;m2[j]--;\\n                if (equals(m1, m2)) return true; // if unique counts are the same after swap, we acheived whats been asked\\n                m1[i]++;m2[i]--;m1[j]--;m2[j]++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean equals(int[] m1, int[] m2) {\\n        int c1 = 0, c2 = 0; // unique chars count for w1 and w2\\n        for (int i = 0; i < 26; i++) if (m1[i] > 0) c1++;\\n        for (int i = 0; i < 26; i++) if (m2[i] > 0) c2++;\\n        return c1 == c2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean isItPossible(String w1, String w2) {\\n        int[] m1 = new int[26], m2 = new int[26]; // freq map\\n        int c1 = 0, c2 = 0; // unique chars count for w1 and w2\\n        for (char c : w1.toCharArray()) if (m1[c-\\'a\\']++ == 0) c1++;\\n        for (char c : w2.toCharArray()) if (m2[c-\\'a\\']++ == 0) c2++;\\n\\n        if (Math.abs(c1 - c2) > 2) return false; // early termination\\n\\n        for (int i = 0; i < 26; i++) {\\n            if (m1[i] == 0) continue; // select only a char exist in w1\\n            int a1 = c1, a2 = c2; // if this one doesn\\'t work, we need to put it back (recover c1 and c2), so easier way is to make a copy\\n            if (m1[i] == 1) a1--; // We took somethign unique from w1\\n            if (m2[i] == 0) a2++; // And this char do not exist in w2\\n            for (int j = 0; j < 26; j++) {\\n                if (m2[j] == 0) continue; // select only what exists in w2\\n\\n                int b1 = a1, b2 = a2; // again, make a copy to avoid recover the counts later\\n                if (i == j) {if (m1[i] == 1) b1++;} // if we swap same char between w1 and w2, and if count was decreased from w1, add it back\\n                else if (m2[j] == 1) b2--; // otherwirse decrease unique count of w2\\n\\n                if (m1[j] == 0) b1++; // if this char do not exist in w1, add unique count to w1\\n                if (b1 == b2) return true; // if unique counts are the same after swap, we acheived whats been asked\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public boolean isItPossible(String w1, String w2) {\\n        int[] m1 = new int[26], m2 = new int[26]; // freq map\\n        int c1 = 0, c2 = 0; // unique chars count for w1 and w2\\n        for (char c : w1.toCharArray()) if (m1[c-\\'a\\']++ == 0) c1++;\\n        for (char c : w2.toCharArray()) if (m2[c-\\'a\\']++ == 0) c2++;\\n\\n        if (Math.abs(c1 - c2) > 2) return false; // early termination\\n\\n        for (int i = 0; i < 26; i++) {\\n            if (m1[i] == 0) continue; // select only a char exist in w1\\n            for (int j = 0; j < 26; j++) {\\n                if (m2[j] == 0) continue; // select only what exists in w2\\n                m1[i]--;m2[i]++;m1[j]++;m2[j]--;\\n                if (equals(m1, m2)) return true; // if unique counts are the same after swap, we acheived whats been asked\\n                m1[i]++;m2[i]--;m1[j]--;m2[j]++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean equals(int[] m1, int[] m2) {\\n        int c1 = 0, c2 = 0; // unique chars count for w1 and w2\\n        for (int i = 0; i < 26; i++) if (m1[i] > 0) c1++;\\n        for (int i = 0; i < 26; i++) if (m2[i] > 0) c2++;\\n        return c1 == c2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017698,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/channel/@leetcodethehardway) if you are interested.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char, int> m1, m2;\\n        // count the frequency of each character in word1\\n        for (char c : word1) m1[c]++;\\n        // count the frequency of each character in word2\\n        for (char c : word2) m2[c]++;\\n        // simulate the swap\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                char x = i + \\'a\\';\\n                char y = j + \\'a\\';\\n                // if we need to swap x and y, \\n                // we need to make sure x is in word1 and y is in word2\\n                if (m1[x] > 0 && m2[y] > 0) {\\n                    // swap x in word1 and y in word2\\n                    m1[x]--; m2[x]++;\\n                    m1[y]++; m2[y]--;\\n                    // check if the number of distinct characters are equal\\n                    int cnt1 = 0, cnt2 = 0;\\n                    for (int k = 0; k < 26; k++) {\\n                        cnt1 += m1[k + \\'a\\'] > 0;\\n                        cnt2 += m2[k + \\'a\\'] > 0;\\n                    }\\n                    // if so, then return true\\n                    if (cnt1 == cnt2) return true;\\n                    // undo the swap so that we can perform a new swap\\n                    m1[x]++; m2[x]--;\\n                    m1[y]--; m2[y]++;   \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char, int> m1, m2;\\n        // count the frequency of each character in word1\\n        for (char c : word1) m1[c]++;\\n        // count the frequency of each character in word2\\n        for (char c : word2) m2[c]++;\\n        // simulate the swap\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                char x = i + \\'a\\';\\n                char y = j + \\'a\\';\\n                // if we need to swap x and y, \\n                // we need to make sure x is in word1 and y is in word2\\n                if (m1[x] > 0 && m2[y] > 0) {\\n                    // swap x in word1 and y in word2\\n                    m1[x]--; m2[x]++;\\n                    m1[y]++; m2[y]--;\\n                    // check if the number of distinct characters are equal\\n                    int cnt1 = 0, cnt2 = 0;\\n                    for (int k = 0; k < 26; k++) {\\n                        cnt1 += m1[k + \\'a\\'] > 0;\\n                        cnt2 += m2[k + \\'a\\'] > 0;\\n                    }\\n                    // if so, then return true\\n                    if (cnt1 == cnt2) return true;\\n                    // undo the swap so that we can perform a new swap\\n                    m1[x]++; m2[x]--;\\n                    m1[y]--; m2[y]++;   \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017409,
                "title": "c-easiest-way-detailed-explanation-beginner-friendly-o-26-26",
                "content": "\\n# Explanation:\\n    I have applied simple brute force here\\n- Stored frequencies of all the alphabets in `vect1` vector for `word1` string and in `vect2` vector for `word2` string.\\n- Stored the total unique count in `count1` for `vect1` and in `count2` for `vect2`.\\n- In the current iteration of the double loop, I have swapped the values and adjusted the `counts` appropriately. if they become equal, return `true`, otherwise, return `false`.\\n- Since we can only do this operation `once`, if they are not equal, we must swap those alphabets once more to restore the original strings.\\n\\n\\n### Go through code once you will understand it easily \\uD83D\\uDC47\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        \\n        vector<int> vect1(26,0), vect2(26,0);//mapping vectors for word1 and word2 respectively\\n        int count1=0,count2=0;\\n        \\n        for(int i=0;i<word1.length();i++){\\n            if(vect1[word1[i]-\\'a\\']++ == 0)\\n                count1++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            if(vect2[word2[i]-\\'a\\']++ == 0)\\n                count2++;\\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            //if value is zero means word1 does not consist that alphabet how we will swap then\\uD83E\\uDD37\\u200D\\u2642\\uFE0F. So continue for next iteration\\n            if(vect1[i] == 0)\\n                continue;\\n\\n            for(int j=0;j<26;j++){\\n                if(vect2[j]==0)\\n                    continue;\\n\\n                //swapped ith character of word1 with jth character of word2\\n                if(--vect1[i] == 0)\\n                    count1--;\\n                if(++vect2[i] == 1)\\n                    count2++;\\n                if(--vect2[j] == 0)\\n                    count2--;\\n                if(++vect1[j] == 1)\\n                    count1++;\\n\\n                if(count1 == count2)\\n                    return true;//function returned if condition satisfied\\n\\n                //swap again to get original form as the last swap was invalid.\\n                if(++vect2[j] == 1)\\n                    count2++;\\n                if(--vect1[j] == 0)\\n                    count1--;\\n                if(++vect1[i] == 1)\\n                    count1++;\\n                if(--vect2[i] == 0)\\n                    count2--;\\n            }\\n            \\n        }\\n        return false; //returned false if not condition satisfied till last iteration\\n    }\\n};\\n```\\n\\n\\n# Please do upvote, if you find this helpful\\uD83D\\uDE4F\\n#### Thankyou in advance :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        \\n        vector<int> vect1(26,0), vect2(26,0);//mapping vectors for word1 and word2 respectively\\n        int count1=0,count2=0;\\n        \\n        for(int i=0;i<word1.length();i++){\\n            if(vect1[word1[i]-\\'a\\']++ == 0)\\n                count1++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            if(vect2[word2[i]-\\'a\\']++ == 0)\\n                count2++;\\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            //if value is zero means word1 does not consist that alphabet how we will swap then\\uD83E\\uDD37\\u200D\\u2642\\uFE0F. So continue for next iteration\\n            if(vect1[i] == 0)\\n                continue;\\n\\n            for(int j=0;j<26;j++){\\n                if(vect2[j]==0)\\n                    continue;\\n\\n                //swapped ith character of word1 with jth character of word2\\n                if(--vect1[i] == 0)\\n                    count1--;\\n                if(++vect2[i] == 1)\\n                    count2++;\\n                if(--vect2[j] == 0)\\n                    count2--;\\n                if(++vect1[j] == 1)\\n                    count1++;\\n\\n                if(count1 == count2)\\n                    return true;//function returned if condition satisfied\\n\\n                //swap again to get original form as the last swap was invalid.\\n                if(++vect2[j] == 1)\\n                    count2++;\\n                if(--vect1[j] == 0)\\n                    count1--;\\n                if(++vect1[i] == 1)\\n                    count1++;\\n                if(--vect2[i] == 0)\\n                    count2--;\\n            }\\n            \\n        }\\n        return false; //returned false if not condition satisfied till last iteration\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016763,
                "title": "remove-add-restore-easiest-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n         unordered_map<char,int> mp1,mp2;\\n         for(int i=0; i<word1.size(); i++) mp1[word1[i]]++;\\n         for(int i=0; i<word2.size(); i++) mp2[word2[i]]++;\\n         for(char i = \\'a\\'; i<=\\'z\\'; i++) {\\n             for(char j = \\'a\\'; j<=\\'z\\'; j++) {\\n                   if(mp1.count(i) && mp2.count(j)) {\\n                         // swap i and j by removing and adding letters from both maps\\n                         mp1[i]--;   // remove i from mp1\\n                         if(mp1[i]==0) mp1.erase(i);   \\n                         \\n                         mp1[j]++;  // add j to mp1\\n                         \\n                         mp2[j]--;  // remove j from mp2\\n                         if(mp2[j]==0) mp2.erase(j);\\n                         \\n                         mp2[i]++;  // add i to mp2\\n                         \\n                         if(mp1.size() == mp2.size()) return true;  // check if number of distinct chars is same\\n                         \\n                         // restore the original state of the maps\\n                         mp1[j]--;\\n                         if(mp1[j]==0) mp1.erase(j);\\n                         \\n                         mp2[i]--;\\n                         if(mp2[i]==0) mp2.erase(i);\\n                         \\n                         \\n                         mp1[i]++;\\n                         mp2[j]++;\\n                   }\\n             }\\n         }\\n         return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n         unordered_map<char,int> mp1,mp2;\\n         for(int i=0; i<word1.size(); i++) mp1[word1[i]]++;\\n         for(int i=0; i<word2.size(); i++) mp2[word2[i]]++;\\n         for(char i = \\'a\\'; i<=\\'z\\'; i++) {\\n             for(char j = \\'a\\'; j<=\\'z\\'; j++) {\\n                   if(mp1.count(i) && mp2.count(j)) {\\n                         // swap i and j by removing and adding letters from both maps\\n                         mp1[i]--;   // remove i from mp1\\n                         if(mp1[i]==0) mp1.erase(i);   \\n                         \\n                         mp1[j]++;  // add j to mp1\\n                         \\n                         mp2[j]--;  // remove j from mp2\\n                         if(mp2[j]==0) mp2.erase(j);\\n                         \\n                         mp2[i]++;  // add i to mp2\\n                         \\n                         if(mp1.size() == mp2.size()) return true;  // check if number of distinct chars is same\\n                         \\n                         // restore the original state of the maps\\n                         mp1[j]--;\\n                         if(mp1[j]==0) mp1.erase(j);\\n                         \\n                         mp2[i]--;\\n                         if(mp2[i]==0) mp2.erase(i);\\n                         \\n                         \\n                         mp1[i]++;\\n                         mp2[j]++;\\n                   }\\n             }\\n         }\\n         return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016764,
                "title": "python-counter",
                "content": "\\n        \\n        # Note:  exactly one move \\n        a,b = Counter(word1),Counter(word2) \\n        c,d = a.copy(),b.copy()\\n        for i in a: \\n            for j in b: \\n                c[i], c[j], d[j], d[i] = c[i]-1, c[j]+1, d[j]-1, d[i]+1\\n                if not c[i]: del c[i] \\n                if not d[j]: del d[j] \\n                if len(c)==len(d): return True #after swap \\n                c,d = a.copy(),b.copy() \\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n        \\n        # Note:  exactly one move \\n        a,b = Counter(word1),Counter(word2) \\n        c,d = a.copy(),b.copy()\\n        for i in a: \\n            for j in b: \\n                c[i], c[j], d[j], d[i] = c[i]-1, c[j]+1, d[j]-1, d[i]+1\\n                if not c[i]: del c[i] \\n                if not d[j]: del d[j] \\n                if len(c)==len(d): return True #after swap \\n                c,d = a.copy(),b.copy() \\n        return False",
                "codeTag": "Unknown"
            },
            {
                "id": 3017207,
                "title": "video-explanation-with-intuition",
                "content": "## Explanation\\n\\nhttps://youtu.be/eAAuqdJOm9s\\n\\n[Click here if the preview doesn\\'t works](https://youtu.be/eAAuqdJOm9s)\\n\\n## Code\\n```\\nclass Solution {\\n    bool IsConstant (char in, char out, map<char, int>& frq) {\\n        if (in == out) return true;\\n        \\n        if (frq[out] == 1) return (frq[in] == 0);\\n        // frq[out] > 1\\n        return (frq[in] != 0);\\n    }\\n    \\n    bool IsIncreased (char in, char out, map<char, int>& frq) {\\n        if (in == out) return false;\\n        \\n         if (frq[out] == 1) return false;\\n        // frq[out] > 1\\n        return (frq[in] == 0);\\n    }\\n    \\n    bool IsDecreased (char in, char out, map<char, int>& frq) {\\n        if (in == out) return false;\\n        \\n         if (frq[out] == 1) return (frq[in] != 0);\\n        // frq[out] > 1\\n        return false;\\n    }\\n    \\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int n1 = word1.length();\\n        int n2 = word2.length();\\n        \\n        map<char, int> char_frq1;\\n        map<char, int> char_frq2;\\n        for (auto ch : word1) char_frq1[ch] ++;\\n        for (auto ch : word2) char_frq2[ch] ++;\\n        \\n        int distinct1 = char_frq1.size();\\n        int distinct2 = char_frq2.size();\\n        \\n        if (abs(distinct1 - distinct2) > 2) return false;\\n        if (distinct1 > distinct2) {\\n            swap (distinct1, distinct2);\\n            swap (char_frq1, char_frq2);\\n        }\\n        \\n        if (distinct1 == distinct2) {\\n            for (char ch1 = \\'a\\'; ch1 <= \\'z\\'; ch1 ++) {\\n                for (char ch2 = \\'a\\'; ch2 <= \\'z\\'; ch2 ++) {\\n                    if (char_frq1[ch1] == 0 || char_frq2[ch2] == 0) continue;\\n                    \\n                    if (IsIncreased (ch2, ch1, char_frq1) && IsIncreased (ch1, ch2, char_frq2)) return true;\\n                    if (IsDecreased (ch2, ch1, char_frq1) && IsDecreased (ch1, ch2, char_frq2)) return true;\\n                    if (IsConstant  (ch2, ch1, char_frq1) && IsConstant  (ch1, ch2, char_frq2)) return true;\\n                }\\n            } \\n            return false;\\n        }\\n        \\n        if (distinct1 == distinct2 - 1) {\\n            for (char ch1 = \\'a\\'; ch1 <= \\'z\\'; ch1 ++) {\\n                for (char ch2 = \\'a\\'; ch2 <= \\'z\\'; ch2 ++) {\\n                    if (char_frq1[ch1] == 0 || char_frq2[ch2] == 0) continue;\\n                    \\n                    if (IsIncreased (ch2, ch1, char_frq1) && IsConstant  (ch1, ch2, char_frq2)) return true;\\n                    if (IsConstant  (ch2, ch1, char_frq1) && IsDecreased (ch1, ch2, char_frq2)) return true;\\n                }\\n            } \\n            return false;\\n        }\\n        \\n        // distinct1 == distinct2 - 2\\n        for (char ch1 = \\'a\\'; ch1 <= \\'z\\'; ch1 ++) {\\n            for (char ch2 = \\'a\\'; ch2 <= \\'z\\'; ch2 ++) {\\n                if (char_frq1[ch1] == 0 || char_frq2[ch2] == 0) continue;\\n                \\n                if (IsIncreased (ch2, ch1, char_frq1) && IsDecreased (ch1, ch2, char_frq2)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool IsConstant (char in, char out, map<char, int>& frq) {\\n        if (in == out) return true;\\n        \\n        if (frq[out] == 1) return (frq[in] == 0);\\n        // frq[out] > 1\\n        return (frq[in] != 0);\\n    }\\n    \\n    bool IsIncreased (char in, char out, map<char, int>& frq) {\\n        if (in == out) return false;\\n        \\n         if (frq[out] == 1) return false;\\n        // frq[out] > 1\\n        return (frq[in] == 0);\\n    }\\n    \\n    bool IsDecreased (char in, char out, map<char, int>& frq) {\\n        if (in == out) return false;\\n        \\n         if (frq[out] == 1) return (frq[in] != 0);\\n        // frq[out] > 1\\n        return false;\\n    }\\n    \\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int n1 = word1.length();\\n        int n2 = word2.length();\\n        \\n        map<char, int> char_frq1;\\n        map<char, int> char_frq2;\\n        for (auto ch : word1) char_frq1[ch] ++;\\n        for (auto ch : word2) char_frq2[ch] ++;\\n        \\n        int distinct1 = char_frq1.size();\\n        int distinct2 = char_frq2.size();\\n        \\n        if (abs(distinct1 - distinct2) > 2) return false;\\n        if (distinct1 > distinct2) {\\n            swap (distinct1, distinct2);\\n            swap (char_frq1, char_frq2);\\n        }\\n        \\n        if (distinct1 == distinct2) {\\n            for (char ch1 = \\'a\\'; ch1 <= \\'z\\'; ch1 ++) {\\n                for (char ch2 = \\'a\\'; ch2 <= \\'z\\'; ch2 ++) {\\n                    if (char_frq1[ch1] == 0 || char_frq2[ch2] == 0) continue;\\n                    \\n                    if (IsIncreased (ch2, ch1, char_frq1) && IsIncreased (ch1, ch2, char_frq2)) return true;\\n                    if (IsDecreased (ch2, ch1, char_frq1) && IsDecreased (ch1, ch2, char_frq2)) return true;\\n                    if (IsConstant  (ch2, ch1, char_frq1) && IsConstant  (ch1, ch2, char_frq2)) return true;\\n                }\\n            } \\n            return false;\\n        }\\n        \\n        if (distinct1 == distinct2 - 1) {\\n            for (char ch1 = \\'a\\'; ch1 <= \\'z\\'; ch1 ++) {\\n                for (char ch2 = \\'a\\'; ch2 <= \\'z\\'; ch2 ++) {\\n                    if (char_frq1[ch1] == 0 || char_frq2[ch2] == 0) continue;\\n                    \\n                    if (IsIncreased (ch2, ch1, char_frq1) && IsConstant  (ch1, ch2, char_frq2)) return true;\\n                    if (IsConstant  (ch2, ch1, char_frq1) && IsDecreased (ch1, ch2, char_frq2)) return true;\\n                }\\n            } \\n            return false;\\n        }\\n        \\n        // distinct1 == distinct2 - 2\\n        for (char ch1 = \\'a\\'; ch1 <= \\'z\\'; ch1 ++) {\\n            for (char ch2 = \\'a\\'; ch2 <= \\'z\\'; ch2 ++) {\\n                if (char_frq1[ch1] == 0 || char_frq2[ch2] == 0) continue;\\n                \\n                if (IsIncreased (ch2, ch1, char_frq1) && IsDecreased (ch1, ch2, char_frq2)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017191,
                "title": "python-using-set-operation-beats-100-time",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI try to discuss how the number of character changes after the operation.\\nThe time beats 100%, but it take me about an hour to cover all the cases.... So my ranking in the contest is bad :(\\n\\nThis might be not that efficient to cover all the cases, advices are welcome!\\n\\nLet x be the final equivalent number:\\n#### Case 1: len(big) = len(small)\\nThe only way to be `True` is that (x, x) -> (x-1+1, x+1-1)\\n\\n#### Case 2: len(big) - len(small) = 1\\nType 2-1: (x+1, x) -> (x, x),  means the bigger set decrease one element\\nType 2-2: (x, x-1) -> (x, x), means the smaller set increase one element\\n\\n\\n#### Case 3: len(big) - len(small) = 2\\nType 3-1: (x+1, x-1) -> (x, x)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n \\n        count1 = collections.Counter(word1)\\n        count2 = collections.Counter(word2)\\n\\n        word1 = set(word1)\\n        word2 = set(word2)\\n        d1 = len(word1)\\n        d2 = len(word2)\\n        \\n        \\n        if d1 == d2:\\n            \\n            a_diff_one = set()\\n            b_diff_one = set()\\n            a_diff_b = word1.difference(word2)\\n            b_diff_a = word2.difference(word1)\\n            \\n            \\n            for ch in list(a_diff_b):\\n                if count1[ch] == 1:\\n                    a_diff_one.add(ch)\\n            \\n            for ch in list(b_diff_a):\\n                if count2[ch] == 1:\\n                    b_diff_one.add(ch)\\n            \\n            if a_diff_one and b_diff_one:\\n                \\n                return True\\n            elif not a_diff_one and not b_diff_one:\\n                return True\\n            else:\\n                return False\\n        \\n        \\n        \\n        if abs(d1 - d2) > 2:\\n            return False\\n        \\n        intersec = word1.intersection(word2)\\n    \\n        if d1 > d2:\\n            big, small = word1, word2\\n            bigCount, smallCount = count1, count2\\n        else:\\n            big, small = word2, word1\\n            bigCount, smallCount = count2, count1\\n        \\n        diff = big.difference(small)\\n        \\n        big_intersecOnlyOne = set()\\n        big_intersecBigger  = set()\\n        small_intersecBigger = set()\\n        small_intersecOnlyOne = set()\\n        big_diffOnlyOne = set()\\n        big_diffBigger = set()\\n        \\n        for ch in list(intersec):\\n            if smallCount[ch] > 1:\\n                small_intersecBigger.add(ch)\\n            elif smallCount[ch] == 1:\\n                small_intersecOnlyOne.add(ch)\\n\\n \\n        for ch in list(diff):\\n            if bigCount[ch] > 1:\\n                big_diffBigger.add(ch)\\n            elif bigCount[ch] == 1:\\n                big_diffOnlyOne.add(ch)\\n            \\n\\n        if abs(d1 - d2) == 1:\\n\\n            #type 1\\n            for ch in list(intersec):\\n                if bigCount[ch] == 1:\\n                    big_intersecOnlyOne.add(ch)\\n            if big_intersecOnlyOne and small_intersecBigger and len(big_intersecOnlyOne.difference(small_intersecBigger)) != 0:\\n                \\n                return True\\n            if small_intersecOnlyOne and big_diffOnlyOne and len(big_diffOnlyOne.difference(small_intersecOnlyOne)) != 0:\\n                return True\\n            \\n            #type 2\\n            if big_diffBigger and small_intersecBigger and len(big_diffBigger.difference(small_intersecBigger)) != 0:\\n                return True\\n            \\n\\n\\n        \\n        elif abs(d1 - d2) == 2:\\n            \\n            if big_diffOnlyOne and small_intersecBigger and len(big_diffOnlyOne.difference(small_intersecBigger)) != 0:\\n                return True\\n        \\n        \\n        \\n        return False\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n \\n        count1 = collections.Counter(word1)\\n        count2 = collections.Counter(word2)\\n\\n        word1 = set(word1)\\n        word2 = set(word2)\\n        d1 = len(word1)\\n        d2 = len(word2)\\n        \\n        \\n        if d1 == d2:\\n            \\n            a_diff_one = set()\\n            b_diff_one = set()\\n            a_diff_b = word1.difference(word2)\\n            b_diff_a = word2.difference(word1)\\n            \\n            \\n            for ch in list(a_diff_b):\\n                if count1[ch] == 1:\\n                    a_diff_one.add(ch)\\n            \\n            for ch in list(b_diff_a):\\n                if count2[ch] == 1:\\n                    b_diff_one.add(ch)\\n            \\n            if a_diff_one and b_diff_one:\\n                \\n                return True\\n            elif not a_diff_one and not b_diff_one:\\n                return True\\n            else:\\n                return False\\n        \\n        \\n        \\n        if abs(d1 - d2) > 2:\\n            return False\\n        \\n        intersec = word1.intersection(word2)\\n    \\n        if d1 > d2:\\n            big, small = word1, word2\\n            bigCount, smallCount = count1, count2\\n        else:\\n            big, small = word2, word1\\n            bigCount, smallCount = count2, count1\\n        \\n        diff = big.difference(small)\\n        \\n        big_intersecOnlyOne = set()\\n        big_intersecBigger  = set()\\n        small_intersecBigger = set()\\n        small_intersecOnlyOne = set()\\n        big_diffOnlyOne = set()\\n        big_diffBigger = set()\\n        \\n        for ch in list(intersec):\\n            if smallCount[ch] > 1:\\n                small_intersecBigger.add(ch)\\n            elif smallCount[ch] == 1:\\n                small_intersecOnlyOne.add(ch)\\n\\n \\n        for ch in list(diff):\\n            if bigCount[ch] > 1:\\n                big_diffBigger.add(ch)\\n            elif bigCount[ch] == 1:\\n                big_diffOnlyOne.add(ch)\\n            \\n\\n        if abs(d1 - d2) == 1:\\n\\n            #type 1\\n            for ch in list(intersec):\\n                if bigCount[ch] == 1:\\n                    big_intersecOnlyOne.add(ch)\\n            if big_intersecOnlyOne and small_intersecBigger and len(big_intersecOnlyOne.difference(small_intersecBigger)) != 0:\\n                \\n                return True\\n            if small_intersecOnlyOne and big_diffOnlyOne and len(big_diffOnlyOne.difference(small_intersecOnlyOne)) != 0:\\n                return True\\n            \\n            #type 2\\n            if big_diffBigger and small_intersecBigger and len(big_diffBigger.difference(small_intersecBigger)) != 0:\\n                return True\\n            \\n\\n\\n        \\n        elif abs(d1 - d2) == 2:\\n            \\n            if big_diffOnlyOne and small_intersecBigger and len(big_diffOnlyOne.difference(small_intersecBigger)) != 0:\\n                return True\\n        \\n        \\n        \\n        return False\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018861,
                "title": "simple-c-maps-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust compare all the possible combinations since we can do only one move that is one swap opeartion therfore total combinations can become 26*26, so we can check for all combinations if that move results in same distinct elements in the strings then return true else false if all cominations  can\\'t provide ...\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo take two maps or frequncy arrays and check 26*26 combinations by simple doing ++,++ and --,-- for swapping in both the maps .. if mp1.size == mp2.size then return true .\\n**Note:** Also do mp.erase when check size of map beacuse if any elements occurence has become zero map will count that also so erase first then check....\\n# Complexity\\n- Time complexity:O(26*26+max(m,n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> mp1, mp2;\\n        int n1=word1.size(),n2=word2.size();\\n        for (char c : word1) mp1[c-\\'a\\']++;\\n        for (char c : word2) mp2[c-\\'a\\']++;\\n        int ns1=mp1.size(),ns2=mp2.size();\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(mp1.count(i) and mp2.count(j)){\\n                mp1[j]++;\\n                mp2[i]++;\\n                if(--mp1[i]==0)mp1.erase(i);\\n                if(--mp2[j]==0)mp2.erase(j);\\n                if(mp1.size()==mp2.size())return true;\\n                mp1[i]++;\\n                mp2[j]++;\\n                if(--mp1[j]==0)mp1.erase(j);\\n                if(--mp2[i]==0)mp2.erase(i);\\n                }   \\n            }\\n        }\\n        return false;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> mp1, mp2;\\n        int n1=word1.size(),n2=word2.size();\\n        for (char c : word1) mp1[c-\\'a\\']++;\\n        for (char c : word2) mp2[c-\\'a\\']++;\\n        int ns1=mp1.size(),ns2=mp2.size();\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(mp1.count(i) and mp2.count(j)){\\n                mp1[j]++;\\n                mp2[i]++;\\n                if(--mp1[i]==0)mp1.erase(i);\\n                if(--mp2[j]==0)mp2.erase(j);\\n                if(mp1.size()==mp2.size())return true;\\n                mp1[i]++;\\n                mp2[j]++;\\n                if(--mp1[j]==0)mp1.erase(j);\\n                if(--mp2[i]==0)mp2.erase(i);\\n                }   \\n            }\\n        }\\n        return false;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017542,
                "title": "easiest-java-solutions",
                "content": "\\n# AppApproachroach\\nbrute force \\n\\n# Complexity\\n- Time complexity:\\n- 26x26x26\\n\\n- Space complexity:\\n 2x26\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2){\\n        char aa[] = new char[26];\\n        char bb[] = new char[26];\\n        for(char x : word1.toCharArray()) {\\n            aa[x-\\'a\\']++;\\n        }\\n        for(char x : word2.toCharArray()) {\\n            bb[x-\\'a\\']++;\\n        }\\n        for(int i = 0;i<26;i++) {\\n            if(aa[i] == 0) {\\n                continue;\\n            }\\n            for(int j = 0;j<26;j++) {\\n                if(bb[j] == 0)\\n                    continue;\\n                aa[j]++;\\n                aa[i]--;\\n                bb[i]++;\\n                bb[j]--;\\n                if(size(aa) == size(bb)) {\\n                    return true;\\n                }\\n                aa[j]--;\\n                aa[i]++;\\n                bb[i]--;\\n                bb[j]++;\\n            }\\n        }\\n        return false;\\n    }\\n    public int size(char aa[]) {\\n        int c = 0;\\n        for(int i = 0;i<26;i++) {\\n            if(aa[i] > 0) {\\n                c++;\\n            }\\n        }\\n        return c;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2){\\n        char aa[] = new char[26];\\n        char bb[] = new char[26];\\n        for(char x : word1.toCharArray()) {\\n            aa[x-\\'a\\']++;\\n        }\\n        for(char x : word2.toCharArray()) {\\n            bb[x-\\'a\\']++;\\n        }\\n        for(int i = 0;i<26;i++) {\\n            if(aa[i] == 0) {\\n                continue;\\n            }\\n            for(int j = 0;j<26;j++) {\\n                if(bb[j] == 0)\\n                    continue;\\n                aa[j]++;\\n                aa[i]--;\\n                bb[i]++;\\n                bb[j]--;\\n                if(size(aa) == size(bb)) {\\n                    return true;\\n                }\\n                aa[j]--;\\n                aa[i]++;\\n                bb[i]--;\\n                bb[j]++;\\n            }\\n        }\\n        return false;\\n    }\\n    public int size(char aa[]) {\\n        int c = 0;\\n        for(int i = 0;i<26;i++) {\\n            if(aa[i] > 0) {\\n                c++;\\n            }\\n        }\\n        return c;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017590,
                "title": "java-o-n-m-fully-explained",
                "content": "# Intuition\\nThe brute force solution would be to iterate over all pairs of indexes `(i, j)`, emulating a swap, and after swapping we would count the new frequencies of the words. **The thing we need to observe from that brute force is that all we care about is the characters that are being swapped, and nothing specific to order or index position.**\\n\\nAfter making a swap, we count the new frequencies, so we don\\'t really care about the indexes but the character. This can lead us to figure out that we just need to iterate over all the possible search space of the characters.\\n\\nBecause we are bound to lowercase English letters, we know the search space is 26 letters. We will try all possible combinations of swaps which is 26*26.\\n\\nSo with that intuition, we have the following procedure:\\n* Count the initial frequencies of the strings\\n* Try all possible letter swaps\\n* After every letter swap, check if we have the same amount of distinct characters\\n\\nWe can implement the third bullet with a brute force iteration, which will accumulate to O(26^3) because we would iterate with another loop over all characters. But instead of doing this, we can simply update the frequency of the characters from the first time we counted, compare, and revert to the initial state.\\n\\nNote: `O(26^3)` Algorithm is AC too.\\n\\n# Complexity\\n- Time complexity:\\nLet N be |word1| and M be |word2|\\n`O(N)` to count character frequencies for word1\\n`O(M)` to count character frequencies for word2\\n`O(26*26)` ~ O(1) for iterations\\n\\nTherefore total time complexity: `O(N+M+26^2) ~ O(N + M)`\\n\\n# Code\\n```\\nclass Problem3 {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] word1Freq = new int[26];\\n        int[] word2Freq = new int[26];\\n        int w1Distincts = 0;\\n        int w2Distincts = 0;\\n        for (char chr : word1.toCharArray()) {\\n            word1Freq[chr - \\'a\\']++;\\n            if (word1Freq[chr - \\'a\\'] == 1) w1Distincts++;\\n        }\\n        for (char chr : word2.toCharArray()) {\\n            word2Freq[chr - \\'a\\']++;\\n            if (word2Freq[chr - \\'a\\'] == 1) w2Distincts++;\\n        }\\n\\n        // Try all potential character swaps\\n        for (int i = 0; i < 26; i++) {\\n            char word1ChrToSwap = (char) (\\'a\\' + i);\\n            if (word1Freq[word1ChrToSwap - \\'a\\'] == 0) continue;\\n            for (int j = 0; j < 26; j++) {\\n                char word2ChrToSwap = (char) (\\'a\\' + j);\\n                if (word2Freq[word2ChrToSwap - \\'a\\'] == 0) continue;\\n\\n                int w1DistinctsTmp = w1Distincts;\\n                int w2DistinctsTmp = w2Distincts;\\n\\n                // Make move\\n                word1Freq[word1ChrToSwap - \\'a\\']--;\\n                word1Freq[word2ChrToSwap - \\'a\\']++;\\n                word2Freq[word2ChrToSwap - \\'a\\']--;\\n                word2Freq[word1ChrToSwap - \\'a\\']++;\\n\\n                // Update frequencies\\n                if (word1Freq[word1ChrToSwap - \\'a\\'] == 0) {\\n                    w1DistinctsTmp--;\\n                }\\n                if (word1Freq[word2ChrToSwap - \\'a\\'] == 1) {\\n                    w1DistinctsTmp++;\\n                }\\n                if (word2Freq[word2ChrToSwap - \\'a\\'] == 0) {\\n                    w2DistinctsTmp--;\\n                }\\n                if (word2Freq[word1ChrToSwap - \\'a\\'] == 1) {\\n                    w2DistinctsTmp++;\\n                }\\n\\n                // Check\\n                if (w1DistinctsTmp == w2DistinctsTmp) return true;\\n\\n                // Clean move\\n                word1Freq[word1ChrToSwap - \\'a\\']++;\\n                word1Freq[word2ChrToSwap - \\'a\\']--;\\n                word2Freq[word2ChrToSwap - \\'a\\']++;\\n                word2Freq[word1ChrToSwap - \\'a\\']--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Problem3 {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] word1Freq = new int[26];\\n        int[] word2Freq = new int[26];\\n        int w1Distincts = 0;\\n        int w2Distincts = 0;\\n        for (char chr : word1.toCharArray()) {\\n            word1Freq[chr - \\'a\\']++;\\n            if (word1Freq[chr - \\'a\\'] == 1) w1Distincts++;\\n        }\\n        for (char chr : word2.toCharArray()) {\\n            word2Freq[chr - \\'a\\']++;\\n            if (word2Freq[chr - \\'a\\'] == 1) w2Distincts++;\\n        }\\n\\n        // Try all potential character swaps\\n        for (int i = 0; i < 26; i++) {\\n            char word1ChrToSwap = (char) (\\'a\\' + i);\\n            if (word1Freq[word1ChrToSwap - \\'a\\'] == 0) continue;\\n            for (int j = 0; j < 26; j++) {\\n                char word2ChrToSwap = (char) (\\'a\\' + j);\\n                if (word2Freq[word2ChrToSwap - \\'a\\'] == 0) continue;\\n\\n                int w1DistinctsTmp = w1Distincts;\\n                int w2DistinctsTmp = w2Distincts;\\n\\n                // Make move\\n                word1Freq[word1ChrToSwap - \\'a\\']--;\\n                word1Freq[word2ChrToSwap - \\'a\\']++;\\n                word2Freq[word2ChrToSwap - \\'a\\']--;\\n                word2Freq[word1ChrToSwap - \\'a\\']++;\\n\\n                // Update frequencies\\n                if (word1Freq[word1ChrToSwap - \\'a\\'] == 0) {\\n                    w1DistinctsTmp--;\\n                }\\n                if (word1Freq[word2ChrToSwap - \\'a\\'] == 1) {\\n                    w1DistinctsTmp++;\\n                }\\n                if (word2Freq[word2ChrToSwap - \\'a\\'] == 0) {\\n                    w2DistinctsTmp--;\\n                }\\n                if (word2Freq[word1ChrToSwap - \\'a\\'] == 1) {\\n                    w2DistinctsTmp++;\\n                }\\n\\n                // Check\\n                if (w1DistinctsTmp == w2DistinctsTmp) return true;\\n\\n                // Clean move\\n                word1Freq[word1ChrToSwap - \\'a\\']++;\\n                word1Freq[word2ChrToSwap - \\'a\\']--;\\n                word2Freq[word2ChrToSwap - \\'a\\']++;\\n                word2Freq[word1ChrToSwap - \\'a\\']--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017239,
                "title": "c-solution-easy-to-understand",
                "content": "# Intuition\\n- Finding the prefect exchange\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n- Just went on applying all the combos\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int a[26]={0};\\n        int b[26]={0};\\n        set<char> distinct_a;\\n        set<char> distinct_b;\\n        int count_a=0,count_b=0;\\n        for(auto& i:word1){\\n            a[i-\\'a\\']++;\\n            distinct_a.insert(i);\\n        }\\n        for(auto& i:word2){\\n            b[i-\\'a\\']++;\\n            distinct_b.insert(i);\\n        }\\n        int diff=distinct_a.size()-distinct_b.size();\\n        diff=abs(diff);\\n        if(diff>2) return false;\\n        if(diff==0){\\n            for(int i=0;i<26;i++){\\n                if(a[i]>0 && b[i]>0) return true;\\n                for(int j=0;j<26;j++){\\n                    if(a[i]==1 && b[j]==1) return true;\\n                    if(a[i]>1 && b[j]>1 && a[j]==0 && b[i]==0) return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        if(distinct_a.size()<distinct_b.size()) swap(a,b);\\n            for(int i=0;i<26;i++){\\n                if(a[i]!=0 && b[i]==0){\\n                    for(int j=0;j<26;j++){\\n                        if(diff==1){\\n                            if(a[i]==1 && b[j]>1 && a[j]==0) return true;\\n                            if(a[i]>1 && b[j]>1 && a[j]!=0) return true;\\n                            if(a[i]==1 && b[j]==1 && a[j]!=0) return true;\\n                        }\\n                        else if(diff==2){\\n                            if(a[i]==1 && b[j]>1 && a[j]!=0) return true;\\n                        }\\n                    }\\n                }\\n            }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int a[26]={0};\\n        int b[26]={0};\\n        set<char> distinct_a;\\n        set<char> distinct_b;\\n        int count_a=0,count_b=0;\\n        for(auto& i:word1){\\n            a[i-\\'a\\']++;\\n            distinct_a.insert(i);\\n        }\\n        for(auto& i:word2){\\n            b[i-\\'a\\']++;\\n            distinct_b.insert(i);\\n        }\\n        int diff=distinct_a.size()-distinct_b.size();\\n        diff=abs(diff);\\n        if(diff>2) return false;\\n        if(diff==0){\\n            for(int i=0;i<26;i++){\\n                if(a[i]>0 && b[i]>0) return true;\\n                for(int j=0;j<26;j++){\\n                    if(a[i]==1 && b[j]==1) return true;\\n                    if(a[i]>1 && b[j]>1 && a[j]==0 && b[i]==0) return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        if(distinct_a.size()<distinct_b.size()) swap(a,b);\\n            for(int i=0;i<26;i++){\\n                if(a[i]!=0 && b[i]==0){\\n                    for(int j=0;j<26;j++){\\n                        if(diff==1){\\n                            if(a[i]==1 && b[j]>1 && a[j]==0) return true;\\n                            if(a[i]>1 && b[j]>1 && a[j]!=0) return true;\\n                            if(a[i]==1 && b[j]==1 && a[j]!=0) return true;\\n                        }\\n                        else if(diff==2){\\n                            if(a[i]==1 && b[j]>1 && a[j]!=0) return true;\\n                        }\\n                    }\\n                }\\n            }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016788,
                "title": "java-brute-force-o-26-3-commented",
                "content": "# Please Upvote :D\\n---\\n##### Simulate swapping by altering frequency at each particular index.\\n``` java []\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        // record the frequencies\\n        int[] f1 = getFreq(word1);\\n        int[] f2 = getFreq(word2);\\n        \\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                // if frequency is 0 we can\\'t swap\\n                if (!(f1[i] > 0 && f2[j] > 0)) {\\n                    continue;\\n                }\\n                \\n                // simulate swap\\n                f1[i]--; f2[i]++;   // frequency moves from f1 to f2\\n                f2[j]--; f1[j]++;   // frequency moves from f2 to f1\\n                \\n                // if distinct counts are equal, return true right away\\n                if (areCharsDistinct(f1, f2)) {\\n                    return true;\\n                } \\n    \\n                // otherwise, revert the swap\\n                f1[i]++; f2[j]++;\\n                f1[j]--; f2[i]--;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    // this function tells us if the count of distinct characters \\n    // in both strings are equal after swapping\\n    private boolean areCharsDistinct(int[] a, int[] b) {\\n        int d1 = 0, d2 = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (a[i] > 0) d1++;\\n            if (b[i] > 0) d2++;\\n        }\\n        \\n        return d1 == d2;\\n    }\\n\\n    // frequency array builder\\n    private int[] getFreq(String s) {\\n        int[] f = new int[26];\\n        for (char c : s.toCharArray()) {\\n            f[c - \\'a\\']++;\\n        }\\n        \\n        return f;\\n    }\\n}\\n\\n// TC: O(26 * 26 * 26) => O(1)\\n// SC: O(26 + 26) => O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        // record the frequencies\\n        int[] f1 = getFreq(word1);\\n        int[] f2 = getFreq(word2);\\n        \\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                // if frequency is 0 we can\\'t swap\\n                if (!(f1[i] > 0 && f2[j] > 0)) {\\n                    continue;\\n                }\\n                \\n                // simulate swap\\n                f1[i]--; f2[i]++;   // frequency moves from f1 to f2\\n                f2[j]--; f1[j]++;   // frequency moves from f2 to f1\\n                \\n                // if distinct counts are equal, return true right away\\n                if (areCharsDistinct(f1, f2)) {\\n                    return true;\\n                } \\n    \\n                // otherwise, revert the swap\\n                f1[i]++; f2[j]++;\\n                f1[j]--; f2[i]--;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    // this function tells us if the count of distinct characters \\n    // in both strings are equal after swapping\\n    private boolean areCharsDistinct(int[] a, int[] b) {\\n        int d1 = 0, d2 = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (a[i] > 0) d1++;\\n            if (b[i] > 0) d2++;\\n        }\\n        \\n        return d1 == d2;\\n    }\\n\\n    // frequency array builder\\n    private int[] getFreq(String s) {\\n        int[] f = new int[26];\\n        for (char c : s.toCharArray()) {\\n            f[c - \\'a\\']++;\\n        }\\n        \\n        return f;\\n    }\\n}\\n\\n// TC: O(26 * 26 * 26) => O(1)\\n// SC: O(26 + 26) => O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016756,
                "title": "easy-solution-create-frequency-map-then-use-nested-loops-to-check-if-switch-can-return-true",
                "content": "# Intuition\\n1. Create map for word1 and word2, the map is of distinct character to its frequency\\n2. Use nested loops to go through the 2 maps, check switch character operation will lead to equal map size or NOT, return ture if new size equals\\n3. Otherwise, return false in the end.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N), create the map take O(N), the nested loops takes O(26*26), O(N) + O(26*26) = O(N)\\n\\n- Space complexity:\\nO(1), 2 * O(26) = O(1)\\n\\n# Code\\n```\\n/**\\n * @param {string} word1\\n * @param {string} word2\\n * @return {boolean}\\n */\\nvar isItPossible = function (word1, word2) {\\n  function getMap(word) {\\n    let map = new Map();\\n    for (let c of word) {\\n      let cnt = map.get(c) || 0;\\n      cnt++;\\n      map.set(c, cnt);\\n    }\\n\\n    return map;\\n  }\\n\\n  let m1 = getMap(word1);\\n  let size1 = m1.size;\\n  let m2 = getMap(word2);\\n  let size2 = m2.size;\\n\\n  let dif = Math.abs(m1.size - m2.size);\\n  if (dif > 2) return false;\\n  for (let [char1, cnt1] of m1) {\\n    for (let [char2, cnt2] of m2) {\\n      if (char1 === char2) {\\n        if (size1 === size2) return true;\\n      } else {\\n        // char1 !== char2\\n        let newSize1 = size1;\\n        if (cnt1 === 1) newSize1--;\\n        if (!m1.has(char2)) newSize1++;\\n\\n        let newSize2 = size2;\\n        if (cnt2 === 1) newSize2--;\\n        if (!m2.has(char1)) newSize2++;\\n\\n        if (newSize1 === newSize2) return true;\\n      }\\n    }\\n  }\\n\\n  return false;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} word1\\n * @param {string} word2\\n * @return {boolean}\\n */\\nvar isItPossible = function (word1, word2) {\\n  function getMap(word) {\\n    let map = new Map();\\n    for (let c of word) {\\n      let cnt = map.get(c) || 0;\\n      cnt++;\\n      map.set(c, cnt);\\n    }\\n\\n    return map;\\n  }\\n\\n  let m1 = getMap(word1);\\n  let size1 = m1.size;\\n  let m2 = getMap(word2);\\n  let size2 = m2.size;\\n\\n  let dif = Math.abs(m1.size - m2.size);\\n  if (dif > 2) return false;\\n  for (let [char1, cnt1] of m1) {\\n    for (let [char2, cnt2] of m2) {\\n      if (char1 === char2) {\\n        if (size1 === size2) return true;\\n      } else {\\n        // char1 !== char2\\n        let newSize1 = size1;\\n        if (cnt1 === 1) newSize1--;\\n        if (!m1.has(char2)) newSize1++;\\n\\n        let newSize2 = size2;\\n        if (cnt2 === 1) newSize2--;\\n        if (!m2.has(char1)) newSize2++;\\n\\n        if (newSize1 === newSize2) return true;\\n      }\\n    }\\n  }\\n\\n  return false;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3024579,
                "title": "easy-short-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to find two characters that if subtracted from the first and added to the other word, the length of the Counter of the string characters become equal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCounters in Python have very nice characteristics.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(26 * 26 + m + n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(26)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        c1 = Counter(word1)\\n        c2 = Counter(word2)\\n        for ch1 in c1:\\n            for ch2 in c2:\\n                new_c1 = c1 - Counter({ch1: 1}) + Counter({ch2: 1})\\n                new_c2 = c2 + Counter({ch1: 1}) - Counter({ch2: 1})\\n                if len(new_c1) == len(new_c2): \\n                    return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        c1 = Counter(word1)\\n        c2 = Counter(word2)\\n        for ch1 in c1:\\n            for ch2 in c2:\\n                new_c1 = c1 - Counter({ch1: 1}) + Counter({ch2: 1})\\n                new_c2 = c2 + Counter({ch1: 1}) - Counter({ch2: 1})\\n                if len(new_c1) == len(new_c2): \\n                    return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022153,
                "title": "python-very-interesting-solution-take-advantage-of-nested-loops-115-ms",
                "content": "We do not mess with `Counter` directly, we play with constant numbers here.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know swapping can have the following possible results:\\n1. `word1[i] == word2[j]`\\n2. `word1[i]` not in `word2`\\n3. `word2[j]` not in `word1`\\n4. `word1[i]` appears only once\\n5. `word2[j]` appears only once\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use `collections.Counter` to make our lives easier:\\n`Counter` for `word1` is `cnt1`\\n`Counter` for `word2` is `cnt2`.\\n\\nThere\\'s one interesting thing we need to pay attention to: we\\'d better not use `del cnt1` stuff, b/c doing so in loops will be given: \"RuntimeError: dictionary changed size during iteration\". So, I recommend record their length before loops: `m, n = len(cnt1), len(cnt2)`.\\n\\nFor each possible results above:\\n1. we continue here, b/c swapping the same letters does not contribute anything to (# of distinct letters);\\n2. `cnt2` will have a new key, `word1[i]`. So `n+=1`;\\n3. very similar as above \"2\", `m+=1`;\\n4. deleting this letter will result in (# of keys in `cnt1` be decremented by 1): `m-=1`;\\n5. very similar as above \"2\", `n-=1`;\\n\\nAfter these checks, we restore the values for `m` and `n`.\\n\\nAnother thing we need to pay attention to is: \\nb/c we continue when `word1[i] == word2[j]`, so when we have two strings: `aaaaaaaaa` and `aaaaaa`, we should still `return True`. \\n**Thus, we need to check if the (# of checked letters) is the same as `m*n` (as we have a nested loop, the total number of checked letters is exactly `m*n`). If less than that, we retun False; return True otherwise.**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(max(26*26, len(word1), len(word2)))`\\nb/c the nested for loop costs `max(m, n) <= 26`, and `Counter`s cost `O(max(len(word1), len(word2)))`. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(26)`\\nb/c `Counter`s can have at most 26 keys.\\n\\n# Code\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        cnt1, cnt2 = Counter(word1), Counter(word2)\\n        m, n = len(cnt1), len(cnt2)\\n        cnt = 0\\n        for i in cnt1:\\n            for j in cnt2:\\n                if i == j: \\n                    cnt += 1\\n                    continue\\n                t1, t2 = m, n\\n                if cnt1[i] == 1: m -= 1\\n                if cnt2[j] == 1: n -= 1\\n                if i not in cnt2: n += 1\\n                if j not in cnt1: m += 1\\n                if m == n: return True\\n                m, n = t1, t2\\n        return False if cnt < m * n else True\\n        \\n```\\n\\nHope you enjoy!\\n\\nIf you have any question, or suggestion, please comment \\uD83D\\uDC47\\n",
                "solutionTags": [
                    "Python3",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        cnt1, cnt2 = Counter(word1), Counter(word2)\\n        m, n = len(cnt1), len(cnt2)\\n        cnt = 0\\n        for i in cnt1:\\n            for j in cnt2:\\n                if i == j: \\n                    cnt += 1\\n                    continue\\n                t1, t2 = m, n\\n                if cnt1[i] == 1: m -= 1\\n                if cnt2[j] == 1: n -= 1\\n                if i not in cnt2: n += 1\\n                if j not in cnt1: m += 1\\n                if m == n: return True\\n                m, n = t1, t2\\n        return False if cnt < m * n else True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017189,
                "title": "26-26-pairs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string w1, string w2) {\\n        unordered_map<char, int> m1, m2;\\n        for(char c : w1) m1[c]++;\\n        for(char c : w2) m2[c]++;\\n\\n        for(char i=\\'a\\'; i<=\\'z\\'; i++) {\\n            for(char j=\\'a\\'; j<=\\'z\\'; j++) {\\n                if(m1.find(i) == m1.end() || m2.find(j) == m2.end()) continue;\\n                if(!--m1[i]) m1.erase(i);\\n                m2[i]++;\\n                if(!--m2[j]) m2.erase(j);\\n                m1[j]++;\\n        \\n                if(m1.size() == m2.size()) return true;\\n\\n                m1[i]++;\\n                if(!--m2[i]) m2.erase(i);\\n                m2[j]++;\\n                if(!--m1[j]) m1.erase(j);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string w1, string w2) {\\n        unordered_map<char, int> m1, m2;\\n        for(char c : w1) m1[c]++;\\n        for(char c : w2) m2[c]++;\\n\\n        for(char i=\\'a\\'; i<=\\'z\\'; i++) {\\n            for(char j=\\'a\\'; j<=\\'z\\'; j++) {\\n                if(m1.find(i) == m1.end() || m2.find(j) == m2.end()) continue;\\n                if(!--m1[i]) m1.erase(i);\\n                m2[i]++;\\n                if(!--m2[j]) m2.erase(j);\\n                m1[j]++;\\n        \\n                if(m1.size() == m2.size()) return true;\\n\\n                m1[i]++;\\n                if(!--m2[i]) m2.erase(i);\\n                m2[j]++;\\n                if(!--m1[j]) m1.erase(j);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016992,
                "title": "c-brute-force-q3-done-at-9-31",
                "content": "Submitted but at 9:31 very disappointed \\n# Approach\\nsimple Brute force\\n\\n# Complexity\\n- Time complexity:\\nO(26*26)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string s, string t) {\\n        unordered_map<char,int> m;\\n        unordered_map<char,int> n;\\n        for(auto e:s)m[e]++;\\n        for(auto e:t)n[e]++;\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                char ch1=i+\\'a\\',ch2=j+\\'a\\';\\n                if(m.find(ch1)!=m.end() && n.find(ch2)!=n.end())\\n                {\\n                    // swap(s[i],t[j]);                \\n                m[ch1]--;\\n                n[ch2]--;\\n                if(m[ch1]==0)m.erase(ch1);\\n                if(n[ch2]==0)n.erase(ch2);\\n                m[ch2]++;\\n                n[ch1]++;\\n                \\n                if(m.size()==n.size())\\n                {\\n                    // cout<<i<<\" \"<<j<<end\\n                    return true;\\n                }\\n                // reverse the action\\n                //  ch1=s[i];\\n                // ch2=t[j];\\n                swap(ch1,ch2);                \\n                m[ch1]--;\\n                n[ch2]--;\\n                if(m[ch1]==0)m.erase(ch1);\\n                if(n[ch2]==0)n.erase(ch2);\\n                m[ch2]++;\\n                n[ch1]++;    \\n                }\\n                            \\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string s, string t) {\\n        unordered_map<char,int> m;\\n        unordered_map<char,int> n;\\n        for(auto e:s)m[e]++;\\n        for(auto e:t)n[e]++;\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                char ch1=i+\\'a\\',ch2=j+\\'a\\';\\n                if(m.find(ch1)!=m.end() && n.find(ch2)!=n.end())\\n                {\\n                    // swap(s[i],t[j]);                \\n                m[ch1]--;\\n                n[ch2]--;\\n                if(m[ch1]==0)m.erase(ch1);\\n                if(n[ch2]==0)n.erase(ch2);\\n                m[ch2]++;\\n                n[ch1]++;\\n                \\n                if(m.size()==n.size())\\n                {\\n                    // cout<<i<<\" \"<<j<<end\\n                    return true;\\n                }\\n                // reverse the action\\n                //  ch1=s[i];\\n                // ch2=t[j];\\n                swap(ch1,ch2);                \\n                m[ch1]--;\\n                n[ch2]--;\\n                if(m[ch1]==0)m.erase(ch1);\\n                if(n[ch2]==0)n.erase(ch2);\\n                m[ch2]++;\\n                n[ch1]++;    \\n                }\\n                            \\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3712665,
                "title": "easy-frequency-counting-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncalculate the frequency of each characters in both string and check **all possible pairs(26*26 pairs)** if it is **possible with one move** then return true otherwise return false.\\n# Complexity\\n- Time complexity:O(N+M+26*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> v1,vector<int> v2,int i,int j)\\n    {\\n        int cnt1 = 0,cnt2 = 0;\\n        v1[j]++; v1[i]--;\\n        v2[i]++; v2[j]--;\\n        for(int k = 0;k<26;k++)\\n        {\\n           if(v1[k]!=0) cnt1++;\\n           if(v2[k]!=0) cnt2++;\\n        }\\n        return cnt1==cnt2;\\n    }\\n    bool isItPossible(string w1, string w2) {\\n        int n = w1.size(),m = w2.size();\\n        vector<int> v1(26,0),v2(26,0);\\n        for(int i = 0;i<n;i++) v1[w1[i]-\\'a\\']++;\\n        for(int i = 0;i<m;i++) v2[w2[i]-\\'a\\']++;\\n\\n        for(int i = 0;i<26;i++)\\n        {\\n            if(v1[i]!=0)\\n            {\\n              for(int j = 0;j<26;j++)\\n              if(v2[j]!=0 && check(v1,v2,i,j)) return true;\\n            } \\n        }\\n        return false;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/77f68958-3cbb-42f4-9701-19a5d47cf0c1_1688385965.9035683.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> v1,vector<int> v2,int i,int j)\\n    {\\n        int cnt1 = 0,cnt2 = 0;\\n        v1[j]++; v1[i]--;\\n        v2[i]++; v2[j]--;\\n        for(int k = 0;k<26;k++)\\n        {\\n           if(v1[k]!=0) cnt1++;\\n           if(v2[k]!=0) cnt2++;\\n        }\\n        return cnt1==cnt2;\\n    }\\n    bool isItPossible(string w1, string w2) {\\n        int n = w1.size(),m = w2.size();\\n        vector<int> v1(26,0),v2(26,0);\\n        for(int i = 0;i<n;i++) v1[w1[i]-\\'a\\']++;\\n        for(int i = 0;i<m;i++) v2[w2[i]-\\'a\\']++;\\n\\n        for(int i = 0;i<26;i++)\\n        {\\n            if(v1[i]!=0)\\n            {\\n              for(int j = 0;j<26;j++)\\n              if(v2[j]!=0 && check(v1,v2,i,j)) return true;\\n            } \\n        }\\n        return false;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552235,
                "title": "detailed-intuition-c-fully-explained",
                "content": "# Brute Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOk the first thing we should do in this is go for brute force approach. i.e. Swap every $i && j$ and after swapping check if we have the same unique elements or not.\\nThe complexity of this code would be roughly $O(n^3)$ which can be modified to $O(n^2)$.\\n\\nlet\\'s see at the code of this brute force.\\n# Code\\n``` \\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) \\n    {\\n        unordered_map<char,int>mp1;\\n        unordered_map<char,int>mp2;\\n        \\n       \\n        for(int i =0;i<word1.size();i++)\\n        {\\n            for(int j =0;j<word2.size();j++)\\n            {\\n                swap(word1[i],word2[j]);\\n                for(int i =0;i<word1.size();i++) mp1[word1[i]]++;\\n                for(int i =0;i<word2.size();i++) mp2[word2[i]]++;\\n                if(mp1.size()==mp2.size()) return true;\\n                swap(word1[i],word2[j]);\\n                mp1.clear();\\n                mp2.clear();\\n\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nFROM THIS CODE WE CAN SEE IT IS going to $O(n^3)$ but still 66 test cases were passed by this. So, in Online Assessments of companies, just apply brute force to get some points atleast.\\n\\nWe can infer from this code that, we are comparing two characters even if they are equal we are swapping and checking. So, to reduce computations we can put a if statement $if(word[i]!=word2[j])$\\nBut still it will not decrease the complexity. But this thought gave me the intuition of the optimized solution.\\n\\n# Intuition\\nSo, we were comparing two characters right?\\nFor example the $string1$  = $\"abaef\"$ and $string2$  = $\"pq\"$.\\nSo are swapping includes\\n$\\nstring1[0] ----> string2[0]-------a---->p\\n$\\n$\\nstring1[0] ----> string2[1]-------a---->q\\n$\\n$\\nstring1[1] ----> string2[0]-------b---->p\\n$\\n$\\nstring1[1] ----> string2[1]-------b---->q\\n$\\n$\\nstring1[2] ----> string2[0]-------a---->p (LOOK HERE)\\n$\\n$\\nstring1[2] ----> string2[1]-------a---->q (LOOK HERE)\\n$\\nSo, if we look clearly, we swapped $a$ again with all elements of $string2$ and this can be taken care of.\\n\\nIt can be taken care if we keep frequency array of both strings and only swap 26 characters with each other.\\nHence, \\nWhy are we swapping same characters again and again and traversing whole string. We know we have only 26 lower case alphabets. So we can just swap these 26 characters one by one. And only swap if there frequency is one.\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we create frequency array of both strings.\\nSecond, we also keep track of unique elements in both strings.\\nNow we just iterate over those two frequency array and check after swapping, how the unique elements number will change.\\nIF SWAP ONLY IF $w1[i]!=0 && w2[j]!=0$.\\nIn the code, conditions are written when to increase the unique elements or not. and after checking change it again.\\n\\nIf $i ==j$ it means we are swapping same elements, but it can be answer because we have to do exactly one move. \\n\\n# Complexity\\n- Time complexity:O(26*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(52)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) \\n    {\\n        vector<int>w1(26,0); //frequency for string1\\n        vector<int>w2(26,0); //frequency for string2\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int n1=0; //keeps track of unique elements of string1\\n        int n2=0; //keeps track of unique elements of string2\\n        for(int i =0;i<word1.size();i++) \\n        {\\n            w1[word1[i]-\\'a\\']++;\\n            if(w1[word1[i]-\\'a\\']==1) n1++;\\n        }\\n        for(int i =0;i<word2.size();i++) \\n        {\\n            w2[word2[i]-\\'a\\']++;\\n            if(w2[word2[i]-\\'a\\']==1) n2++;\\n        }\\n        for(int i =0;i<26;i++)\\n        {\\n            for(int j =0;j<26;j++)\\n            {\\n                if(w1[i]!=0 && w2[j]!=0 && i!=j) //we are swapping i+\\'a\\' with j+\\'a\\'\\n                {\\n                    if(w2[j]==1) n2--; //if occureence of j in w2 is only 1, then after swapping unique element will decrease by one.\\n                    if(w2[i]==0) n2++;//if occureence of i in w2 is 0, then after swapping unique element will increase by one.\\n                    if(w1[j]==0) n1++; //if occureence of j in w1 is 0, then after swapping unique element will increase by one.\\n                    if(w1[i]==1) n1--; //if occureence of i in w1 is only 1, then after swapping unique element will decrease by one.\\n                    if(n1==n2) return true;\\n                    if(w2[i]==0) n2--;\\n                    if(w2[j]==1) n2++;\\n                    if(w1[j]==0) n1--;\\n                    if(w1[i]==1) n1++;\\n                }\\n                if(w1[i]!=0 && w2[j]!=0 && i==j)\\n                {\\n                    if(n1==n2) return true;\\n                }\\n            }\\n        }\\n\\n\\n       \\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) \\n    {\\n        unordered_map<char,int>mp1;\\n        unordered_map<char,int>mp2;\\n        \\n       \\n        for(int i =0;i<word1.size();i++)\\n        {\\n            for(int j =0;j<word2.size();j++)\\n            {\\n                swap(word1[i],word2[j]);\\n                for(int i =0;i<word1.size();i++) mp1[word1[i]]++;\\n                for(int i =0;i<word2.size();i++) mp2[word2[i]]++;\\n                if(mp1.size()==mp2.size()) return true;\\n                swap(word1[i],word2[j]);\\n                mp1.clear();\\n                mp2.clear();\\n\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) \\n    {\\n        vector<int>w1(26,0); //frequency for string1\\n        vector<int>w2(26,0); //frequency for string2\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int n1=0; //keeps track of unique elements of string1\\n        int n2=0; //keeps track of unique elements of string2\\n        for(int i =0;i<word1.size();i++) \\n        {\\n            w1[word1[i]-\\'a\\']++;\\n            if(w1[word1[i]-\\'a\\']==1) n1++;\\n        }\\n        for(int i =0;i<word2.size();i++) \\n        {\\n            w2[word2[i]-\\'a\\']++;\\n            if(w2[word2[i]-\\'a\\']==1) n2++;\\n        }\\n        for(int i =0;i<26;i++)\\n        {\\n            for(int j =0;j<26;j++)\\n            {\\n                if(w1[i]!=0 && w2[j]!=0 && i!=j) //we are swapping i+\\'a\\' with j+\\'a\\'\\n                {\\n                    if(w2[j]==1) n2--; //if occureence of j in w2 is only 1, then after swapping unique element will decrease by one.\\n                    if(w2[i]==0) n2++;//if occureence of i in w2 is 0, then after swapping unique element will increase by one.\\n                    if(w1[j]==0) n1++; //if occureence of j in w1 is 0, then after swapping unique element will increase by one.\\n                    if(w1[i]==1) n1--; //if occureence of i in w1 is only 1, then after swapping unique element will decrease by one.\\n                    if(n1==n2) return true;\\n                    if(w2[i]==0) n2--;\\n                    if(w2[j]==1) n2++;\\n                    if(w1[j]==0) n1--;\\n                    if(w1[i]==1) n1++;\\n                }\\n                if(w1[i]!=0 && w2[j]!=0 && i==j)\\n                {\\n                    if(n1==n2) return true;\\n                }\\n            }\\n        }\\n\\n\\n       \\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3313026,
                "title": "using-map-approach",
                "content": "Approach\\n  - The approach is kind of brute force type. As mentioned in the question that only lowercase letters will be there so there\\'s possibility of 26 letters means word1 contains 26 letters and word2 contains 26 letters at max.\\n- So we can store frequecy of each letter and remove one char from word1 and add to word2 and vice versa because in swapping also we\\'re just removing the char from word1 and adding it to word2.\\n- Then we can count number of unique characters present in the current string. If the count of both strings is same i.e unique1==unique2 then we\\'ll simply return true.\\n- If this was not the case then we can restore the changes by just simply reversing the signs.\\n\\n# Complexity\\n- Time complexity: O(26*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        \\n        map<char , int> m1,m2;\\n\\n        for(auto x: word1){\\n                \\n            m1[x]++;\\n        }\\n         for(auto x: word2){\\n                \\n            m2[x]++;\\n        }\\n\\n        for(char ch1=\\'a\\' ; ch1<=\\'z\\'; ch1++){\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++){\\n                if(m1[ch1]>0 && m2[ch2]>0){\\n                    m1[ch1]--;\\n                    m2[ch2]--;\\n                    m1[ch2]++;\\n                    m2[ch1]++;\\n                    int unique1=0 , unique2=0;\\n                    for(char temp=\\'a\\';temp<=\\'z\\';temp++){\\n                        if(m1[temp]>0){\\n                            unique1++;\\n                        }\\n                        if(m2[temp]>0){\\n                            unique2++;\\n                        }\\n                    }\\n                    if(unique1==unique2){\\n                        return true;\\n                    }\\n                    m1[ch2]--;\\n                    m2[ch1]--;\\n                    m1[ch1]++;\\n                    m2[ch2]++;\\n                }\\n                    \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nUPVOTE PLEASE IF THIS IS HELPFUL TO YOU:)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        \\n        map<char , int> m1,m2;\\n\\n        for(auto x: word1){\\n                \\n            m1[x]++;\\n        }\\n         for(auto x: word2){\\n                \\n            m2[x]++;\\n        }\\n\\n        for(char ch1=\\'a\\' ; ch1<=\\'z\\'; ch1++){\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++){\\n                if(m1[ch1]>0 && m2[ch2]>0){\\n                    m1[ch1]--;\\n                    m2[ch2]--;\\n                    m1[ch2]++;\\n                    m2[ch1]++;\\n                    int unique1=0 , unique2=0;\\n                    for(char temp=\\'a\\';temp<=\\'z\\';temp++){\\n                        if(m1[temp]>0){\\n                            unique1++;\\n                        }\\n                        if(m2[temp]>0){\\n                            unique2++;\\n                        }\\n                    }\\n                    if(unique1==unique2){\\n                        return true;\\n                    }\\n                    m1[ch2]--;\\n                    m2[ch1]--;\\n                    m1[ch1]++;\\n                    m2[ch2]++;\\n                }\\n                    \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050040,
                "title": "hindi-version-c-easy-understanding",
                "content": "The post is in hindi as there are very post which explained approach in HINDI.\\n# Approach\\nSimply har distinct character ko string 1 ke har distinct character se string 2 ko swap karke check karlo ki dono string ke distinct characters equal hogaye hai ya nahi and better understanding ke liye code mein comments provided hai read karo and saath mein ek example par dry run karke dekho.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n+m) [dono strings ke through traverse karke mapping karne ke liye] + O(26*26) [Characters waale loop ke liye jisme swap operation ko karke dekh rahe hai]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26) because 26 characters hai toh map mein bhi 26 characters ke liye hi space reserve hoga\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        // 2 maps lenge jinka size 26 hi hoga because 26 characters hai\\n        unordered_map<char,int>mp1,mp2;\\n        // word1 string ke characters ki frequency ko count kar rahe hai map mp1 mein\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[word1[i]]++;\\n        }\\n        // word2 string ke characters ki frequency ko count kar rahe hai map mp2 mein\\n        for(int i=0;i<m;i++)\\n        {\\n            mp2[word2[i]]++;\\n        }\\n        // Ye loop 26*26 times chalega because characters 26 hi hai from \\'a\\' to \\'z\\'\\n        for(char ch1=\\'a\\';ch1<=\\'z\\';ch1++)\\n        {\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++)\\n            {\\n                // agar ch1 character map mp1 mein hai and ch2 character map mp2 mein hai tabhi swap karna possible hoga\\n                if(mp1[ch1] && mp2[ch2])\\n                {\\n                    // character ch1 ko mp1 se remove kardo and character ch2 ko mp1 mein daaldo\\n                    mp1[ch1]--;\\n                    mp1[ch2]++;\\n                    // character ch2 ko mp2 se remove kardo and character ch1 ko mp2 mein daaldo\\n                    mp2[ch2]--;\\n                    mp2[ch1]++;\\n                    // ab dono map mein distinct characters ko count karo\\n                    int disone = 0;\\n                    int distwo = 0;\\n                    for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n                    {\\n                        if(mp1[ch]>0)\\n                        {\\n                            disone++;\\n                        }\\n                        if(mp2[ch]>0)\\n                        {\\n                            distwo++;\\n                        }\\n                    }\\n                    // agar dono map mein distinct characters equal hogaye hai iska matlab ki dono strings mein distinct characters equal hogaye hai and yahin se answer true return kardo\\n                    if(disone==distwo)\\n                    {\\n                        return true;\\n                    }\\n                    // Agar distinct characters equal nahi kar paaye toh hume waapis mp1 and mp2 ke swapped characters ko unke original string mein dalna hoga jisme woh pehle the\\n                    mp1[ch1]++;\\n                    mp1[ch2]--;\\n                    mp2[ch2]++;\\n                    mp2[ch1]--;\\n                }\\n            }\\n        }\\n        // agar kisi bhi swap se possible nahi ho paaya dono strings ke distinct characters ko equal karna toh answer false hoga\\n        return false;\\n    }\\n};\\n```\\n\\nAgar post se thodi bhi help mili ho toh please upvote karna!!!",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        // 2 maps lenge jinka size 26 hi hoga because 26 characters hai\\n        unordered_map<char,int>mp1,mp2;\\n        // word1 string ke characters ki frequency ko count kar rahe hai map mp1 mein\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[word1[i]]++;\\n        }\\n        // word2 string ke characters ki frequency ko count kar rahe hai map mp2 mein\\n        for(int i=0;i<m;i++)\\n        {\\n            mp2[word2[i]]++;\\n        }\\n        // Ye loop 26*26 times chalega because characters 26 hi hai from \\'a\\' to \\'z\\'\\n        for(char ch1=\\'a\\';ch1<=\\'z\\';ch1++)\\n        {\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++)\\n            {\\n                // agar ch1 character map mp1 mein hai and ch2 character map mp2 mein hai tabhi swap karna possible hoga\\n                if(mp1[ch1] && mp2[ch2])\\n                {\\n                    // character ch1 ko mp1 se remove kardo and character ch2 ko mp1 mein daaldo\\n                    mp1[ch1]--;\\n                    mp1[ch2]++;\\n                    // character ch2 ko mp2 se remove kardo and character ch1 ko mp2 mein daaldo\\n                    mp2[ch2]--;\\n                    mp2[ch1]++;\\n                    // ab dono map mein distinct characters ko count karo\\n                    int disone = 0;\\n                    int distwo = 0;\\n                    for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n                    {\\n                        if(mp1[ch]>0)\\n                        {\\n                            disone++;\\n                        }\\n                        if(mp2[ch]>0)\\n                        {\\n                            distwo++;\\n                        }\\n                    }\\n                    // agar dono map mein distinct characters equal hogaye hai iska matlab ki dono strings mein distinct characters equal hogaye hai and yahin se answer true return kardo\\n                    if(disone==distwo)\\n                    {\\n                        return true;\\n                    }\\n                    // Agar distinct characters equal nahi kar paaye toh hume waapis mp1 and mp2 ke swapped characters ko unke original string mein dalna hoga jisme woh pehle the\\n                    mp1[ch1]++;\\n                    mp1[ch2]--;\\n                    mp2[ch2]++;\\n                    mp2[ch1]--;\\n                }\\n            }\\n        }\\n        // agar kisi bhi swap se possible nahi ho paaya dono strings ke distinct characters ko equal karna toh answer false hoga\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047261,
                "title": "python-explained-mathematical-true-o-n-solution-not-26-26-the-best",
                "content": "# Intuition\\nDenote $$f_i(c) \\\\geqslant 0$$ as the frequency of letter $$c$$ in word $$w_{i \\\\in \\\\{1,2\\\\}}$$, and $$\\\\lVert w_i\\\\rVert$$ as the number of distinct letters in $$w_i$$. Consider moving a letter $$c_1\\\\in w_1$$ to $$w_2$$. The resulting *change* in $$\\\\Delta = \\\\lVert w_2\\\\rVert - \\\\lVert w_1\\\\rVert$$ can be classified as follows:\\n\\n1. If $$f_1(c_1)=1$$, $$\\\\Delta$$ increments by $$1$$; if $$f_1(c_1)>1$$, $$\\\\Delta$$ does not change.\\n2. If $$f_2(c_1)=0$$, $$\\\\Delta$$ increments by $$1$$; if $$f_2(c_1)>0$$, $$\\\\Delta$$ does not change.\\n\\nThe above can be shortened to $$[f_1(c_1)=1] + [f_2(c_1)=0]$$, where $$[\\\\textit{True}\\\\,] = 1$$ and $$[\\\\textit{False}\\\\,] = 0$$\\n\\nMoreover, consider swapping **different** letters $$c_1\\\\in w_1$$ and $$c_2 \\\\in w_2$$, $$c_1 \\\\neq c_2$$. The resulting *change* in $$\\\\Delta$$ is given by: $$([f_1(c_1)=1] + [f_2(c_1)=0]) - ([f_2(c_2)=1] + [f_1(c_2)=0])$$.\\n\\nWe can therefore classify all letters $$c_i \\\\in w_i$$ as contributing a value of $$0$$, $$1$$ or $$2$$ to the left or the right half of the $$\\\\Delta$$ change above, and look for values resulting in $$\\\\Delta=0$$.\\n\\nThe Best!\\n\\n# Approach\\nIn order to detect possible swaps of different letters, we need to know the letter value if it is the only letter in a class. If there are more letters, the swap of $$c_1\\\\neq c_2$$ is always possible, provided that the other class is not empty.\\n\\nWe therefore keep an array $$\\\\Delta_i$$ of size $$3$$ for both words $$w_i$$, where values in the array are either *False* (empty letter class), $$c$$ (class of size $$1$$ with the letter $$c$$), and *True* (class of size $$>1$$).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```py\\ndef isItPossible(self, word1: str, word2: str) -> bool:\\n    f1, f2 = collections.Counter(word1), collections.Counter(word2)\\n    if abs(delta := len(f2)-len(f1)) > 2:\\n        return False\\n    if delta == 0 and f1 & f2:\\n        return True\\n\\n    delta1, delta2 = [False]*3, [False]*3\\n    for c1, v1 in f1.items():\\n        delta1[d1] = True if delta1[d1 := (v1==1) + (c1 not in f2)] else c1\\n    for c2, v2 in f2.items():\\n        delta2[d2] = True if delta2[d2 := (v2==1) + (c2 not in f1)] else c2\\n\\n    return any(delta == d2-d1 and s1 and s2 and (s1 is True or s1 != s2)\\n               for d1, s1 in enumerate(delta1) for d2, s2 in enumerate(delta2))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\ndef isItPossible(self, word1: str, word2: str) -> bool:\\n    f1, f2 = collections.Counter(word1), collections.Counter(word2)\\n    if abs(delta := len(f2)-len(f1)) > 2:\\n        return False\\n    if delta == 0 and f1 & f2:\\n        return True\\n\\n    delta1, delta2 = [False]*3, [False]*3\\n    for c1, v1 in f1.items():\\n        delta1[d1] = True if delta1[d1 := (v1==1) + (c1 not in f2)] else c1\\n    for c2, v2 in f2.items():\\n        delta2[d2] = True if delta2[d2 := (v2==1) + (c2 not in f1)] else c2\\n\\n    return any(delta == d2-d1 and s1 and s2 and (s1 is True or s1 != s2)\\n               for d1, s1 in enumerate(delta1) for d2, s2 in enumerate(delta2))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3025528,
                "title": "javascript-o-n-solution",
                "content": "```\\n/**\\n * @param {string} word1\\n * @param {string} word2\\n * @return {boolean}\\n */\\nvar isItPossible = function(word1, word2) {\\n    const w1 = new Map();\\n    const w2 = new Map();\\n    \\n    const add = (map, c) => {\\n        const prev = map.get(c) || 0;\\n        map.set(c, prev + 1);\\n    }\\n    \\n    const remove = (map, c) => {\\n        if(map.get(c) === 1) {\\n            map.delete(c);\\n            return;\\n        }\\n        const prev = map.get(c);\\n        map.set(c, prev - 1);\\n    }\\n    \\n    for(const c of word1) add(w1, c);\\n    for(const c of word2) add(w2, c);\\n    \\n    const k1 = Array.from(w1.keys());\\n    const k2 = Array.from(w2.keys());\\n    \\n    for(const c1 of k1) {\\n        for(const c2 of k2) {\\n            remove(w1, c1);\\n            remove(w2, c2);\\n            add(w1, c2);\\n            add(w2, c1);\\n            if(w1.size === w2.size) return true;\\n            remove(w1, c2);\\n            remove(w2, c1);\\n            add(w1, c1);\\n            add(w2, c2);\\n        }\\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} word1\\n * @param {string} word2\\n * @return {boolean}\\n */\\nvar isItPossible = function(word1, word2) {\\n    const w1 = new Map();\\n    const w2 = new Map();\\n    \\n    const add = (map, c) => {\\n        const prev = map.get(c) || 0;\\n        map.set(c, prev + 1);\\n    }\\n    \\n    const remove = (map, c) => {\\n        if(map.get(c) === 1) {\\n            map.delete(c);\\n            return;\\n        }\\n        const prev = map.get(c);\\n        map.set(c, prev - 1);\\n    }\\n    \\n    for(const c of word1) add(w1, c);\\n    for(const c of word2) add(w2, c);\\n    \\n    const k1 = Array.from(w1.keys());\\n    const k2 = Array.from(w2.keys());\\n    \\n    for(const c1 of k1) {\\n        for(const c2 of k2) {\\n            remove(w1, c1);\\n            remove(w2, c2);\\n            add(w1, c2);\\n            add(w2, c1);\\n            if(w1.size === w2.size) return true;\\n            remove(w1, c2);\\n            remove(w2, c1);\\n            add(w1, c1);\\n            add(w2, c2);\\n        }\\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3017682,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] arr1 = new int[26];\\n        int[] arr2 = new int[26];\\n\\n        for (int i = 0; i < word1.length(); i++) {\\n            arr1[word1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < word2.length(); i++) {\\n            arr2[word2.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (arr1[i] == 0) continue;\\n            for (int j = 0; j < 26; j++) {\\n                if (arr2[j] == 0) continue;\\n                arr1[i]--;\\n                arr1[j]++;\\n                arr2[i]++;\\n                arr2[j]--;\\n                if (issame(arr1, arr2)) return true;\\n                arr1[i]++;\\n                arr1[j]--;\\n                arr2[i]--;\\n                arr2[j]++;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean issame(int[] arr1, int[] arr2) {\\n        int count1 = 0;\\n        int count2 = 0;\\n        for (int i = 0; i < arr1.length; i++) {\\n            if (arr1[i] > 0) count1++;\\n        }\\n        for (int i = 0; i < arr2.length; i++) {\\n            if (arr2[i] > 0) count2++;\\n        }\\n        return count1 == count2;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] arr1 = new int[26];\\n        int[] arr2 = new int[26];\\n\\n        for (int i = 0; i < word1.length(); i++) {\\n            arr1[word1.charAt(i) - \\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3017129,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        c1=collections.Counter(word1)\\n        c2=collections.Counter(word2)\\n        c1k=list(c1.keys())\\n        c2k=list(c2.keys())\\n        for x in c1k:\\n            for y in c2k:\\n                c1[y]+=1\\n                c1[x]-=1\\n                c2[x]+=1\\n                c2[y]-=1\\n                \\n                if c1[x]==0:\\n                    del c1[x]\\n                    \\n                if c2[y]==0:\\n                    del c2[y]\\n                    \\n                if len(c1)==len(c2):\\n                    return True\\n                c2[y]+=1\\n                c2[x]-=1\\n                c1[x]+=1\\n                c1[y]-=1\\n                if c2[x]==0:\\n                    del c2[x]\\n                    \\n                if c1[y]==0:\\n                    del c1[y]\\n                \\n        return False        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        c1=collections.Counter(word1)\\n        c2=collections.Counter(word2)\\n        c1k=list(c1.keys())\\n        c2k=list(c2.keys())\\n        for x in c1k:\\n            for y in c2k:\\n                c1[y]+=1\\n                c1[x]-=1\\n                c2[x]+=1\\n                c2[y]-=1\\n                \\n                if c1[x]==0:\\n                    del c1[x]\\n                    \\n                if c2[y]==0:\\n                    del c2[y]\\n                    \\n                if len(c1)==len(c2):\\n                    return True\\n                c2[y]+=1\\n                c2[x]-=1\\n                c1[x]+=1\\n                c1[y]-=1\\n                if c2[x]==0:\\n                    del c2[x]\\n                    \\n                if c1[y]==0:\\n                    del c1[y]\\n                \\n        return False        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017054,
                "title": "clean-code-tc-o-26-26-backtracking",
                "content": "\\n# Code\\n```\\n// Try all the combinations\\n//Backtracking - TC - O(26 * 26)\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char, int> m1, m2;\\n        for(auto w1 : word1)m1[w1]++;\\n        for(auto w2 : word2)m2[w2]++;\\n        \\n        for(auto it1 : m1){\\n            unordered_map<char, int> mm1 = m1, mm2 = m2;\\n            for(auto it2 : m2){\\n                char ch1 = it1.first;\\n                char ch2 = it2.first;\\n                \\n                mm1[ch2]++;\\n                mm2[ch1]++;\\n                \\n                mm1[ch1]--;\\n                mm2[ch2]--;\\n                if(mm1[ch1] == 0)mm1.erase(ch1);\\n                if(mm2[ch2] == 0)mm2.erase(ch2);\\n                \\n                if(mm1.size() == mm2.size())return true;\\n                //Backtracking//undo all the changes for the next iteration\\n                mm1[ch2]--;\\n                mm2[ch1]--;\\n\\n                mm1[ch1]++;\\n                mm2[ch2]++;\\n                if(mm1[ch2] == 0)mm1.erase(ch2);\\n                if(mm2[ch1] == 0)mm2.erase(ch1);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nNo bracktracking TC-O(26 * 26 * 26)\\n\\n```\\n// Try all the combinations\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char, int> m1, m2;\\n        for(auto w1 : word1)m1[w1]++;\\n        for(auto w2 : word2)m2[w2]++;\\n        \\n        for(auto it1 : m1){\\n            for(auto it2 : m2){\\n                unordered_map<char, int> mm1 = m1, mm2 = m2;\\n                char ch1 = it1.first;\\n                char ch2 = it2.first;\\n                \\n                mm1[ch2]++;\\n                mm2[ch1]++;\\n                \\n                mm1[ch1]--;\\n                mm2[ch2]--;\\n                if(mm1[ch1] == 0)mm1.erase(ch1);\\n                if(mm2[ch2] == 0)mm2.erase(ch2);\\n                \\n                if(mm1.size() == mm2.size())return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nPlease upvote if it was helpful\\uD83D\\uDE0A",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Try all the combinations\\n//Backtracking - TC - O(26 * 26)\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char, int> m1, m2;\\n        for(auto w1 : word1)m1[w1]++;\\n        for(auto w2 : word2)m2[w2]++;\\n        \\n        for(auto it1 : m1){\\n            unordered_map<char, int> mm1 = m1, mm2 = m2;\\n            for(auto it2 : m2){\\n                char ch1 = it1.first;\\n                char ch2 = it2.first;\\n                \\n                mm1[ch2]++;\\n                mm2[ch1]++;\\n                \\n                mm1[ch1]--;\\n                mm2[ch2]--;\\n                if(mm1[ch1] == 0)mm1.erase(ch1);\\n                if(mm2[ch2] == 0)mm2.erase(ch2);\\n                \\n                if(mm1.size() == mm2.size())return true;\\n                //Backtracking//undo all the changes for the next iteration\\n                mm1[ch2]--;\\n                mm2[ch1]--;\\n\\n                mm1[ch1]++;\\n                mm2[ch2]++;\\n                if(mm1[ch2] == 0)mm1.erase(ch2);\\n                if(mm2[ch1] == 0)mm2.erase(ch1);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\n// Try all the combinations\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char, int> m1, m2;\\n        for(auto w1 : word1)m1[w1]++;\\n        for(auto w2 : word2)m2[w2]++;\\n        \\n        for(auto it1 : m1){\\n            for(auto it2 : m2){\\n                unordered_map<char, int> mm1 = m1, mm2 = m2;\\n                char ch1 = it1.first;\\n                char ch2 = it2.first;\\n                \\n                mm1[ch2]++;\\n                mm2[ch1]++;\\n                \\n                mm1[ch1]--;\\n                mm2[ch2]--;\\n                if(mm1[ch1] == 0)mm1.erase(ch1);\\n                if(mm2[ch2] == 0)mm2.erase(ch2);\\n                \\n                if(mm1.size() == mm2.size())return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017033,
                "title": "java-easy-solution",
                "content": "Intution is just we applied n^2 approach on 26*26 i.e. means  on frequency array.\\n\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] arr1 = new int[26];\\n        int[] arr2 = new int[26];\\n        for(int i = 0; i < word1.length(); i++){\\n            char ch = word1.charAt(i);\\n            int idx = ch - \\'a\\';\\n            arr1[idx] = arr1[idx] + 1;     // count the frequency of character in word1\\n        }\\n        for(int i = 0; i < word2.length(); i++){\\n            char ch = word2.charAt(i);\\n            int idx = ch - \\'a\\';\\n            arr2[idx] = arr2[idx] + 1;  // count the frequency of character in word2\\n        }\\n\\n        \\n        for(int i = 0; i < 26; i++){\\n            for(int j = 0; j < 26; j++){\\n                if(arr1[i] > 0 && arr2[j] > 0){                  // both indices should have frequency greater than 0 for swapping\\n\\t\\t\\t\\t\\t\\tarr1[j] = arr1[j] + 1;                        // take the one character of  word2 from arr2 and put into arr1              \\n                    arr1[i] = arr1[i] - 1;                          // basically we are swapping here \\n                    arr2[i] = arr2[i] + 1;\\n                    arr2[j] = arr2[j] - 1;\\n                    int temp1 = 0;\\n                    int temp2 = 0;\\n                    for(int k = 0; k < 26; k++){\\n                        if(arr1[k] != 0){                                // here checking number of different characters\\n                            if(arr1[k] > 0)\\n                            temp1++;\\n                        }\\n                        if(arr2[k] != 0){\\n                            if(arr2[k] > 0)\\n                            temp2++;\\n                        }\\n                        \\n                    }\\n                    if(temp1 == temp2){                // if number of distinct character equal then return true\\n                          return true;\\n                    }\\n                    arr1[j] = arr1[j] - 1;                          // in postorder we again put the same value of arr1 and arr2 because one swapping allowed only\\n                    arr1[i] = arr1[i] + 1;\\n                    arr2[i] = arr2[i] - 1;\\n                    arr2[j] = arr2[j] + 1;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] arr1 = new int[26];\\n        int[] arr2 = new int[26];\\n        for(int i = 0; i < word1.length(); i++){\\n            char ch = word1.charAt(i);\\n            int idx = ch - \\'a\\';\\n            arr1[idx] = arr1[idx] + 1;     // count the frequency of character in word1\\n        }\\n        for(int i = 0; i < word2.length(); i++){\\n            char ch = word2.charAt(i);\\n            int idx = ch - \\'a\\';\\n            arr2[idx] = arr2[idx] + 1;  // count the frequency of character in word2\\n        }\\n\\n        \\n        for(int i = 0; i < 26; i++){\\n            for(int j = 0; j < 26; j++){\\n                if(arr1[i] > 0 && arr2[j] > 0){                  // both indices should have frequency greater than 0 for swapping\\n\\t\\t\\t\\t\\t\\tarr1[j] = arr1[j] + 1;                        // take the one character of  word2 from arr2 and put into arr1              \\n                    arr1[i] = arr1[i] - 1;                          // basically we are swapping here \\n                    arr2[i] = arr2[i] + 1;\\n                    arr2[j] = arr2[j] - 1;\\n                    int temp1 = 0;\\n                    int temp2 = 0;\\n                    for(int k = 0; k < 26; k++){\\n                        if(arr1[k] != 0){                                // here checking number of different characters\\n                            if(arr1[k] > 0)\\n                            temp1++;\\n                        }\\n                        if(arr2[k] != 0){\\n                            if(arr2[k] > 0)\\n                            temp2++;\\n                        }\\n                        \\n                    }\\n                    if(temp1 == temp2){                // if number of distinct character equal then return true\\n                          return true;\\n                    }\\n                    arr1[j] = arr1[j] - 1;                          // in postorder we again put the same value of arr1 and arr2 because one swapping allowed only\\n                    arr1[i] = arr1[i] + 1;\\n                    arr2[i] = arr2[i] - 1;\\n                    arr2[j] = arr2[j] + 1;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016796,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) \\n    {\\n        vector<int>m1(26,0),m2(26,0);\\n        \\n        for(auto i:word1)m1[i-\\'a\\']++;\\n        for(auto i:word2)m2[i-\\'a\\']++;\\n        \\n        for(int i = 0;i<26;i++)\\n        {\\n            for(int j = 0;j<26;j++)\\n            {\\n                if(m1[i] and m2[j])\\n                {\\n                     m1[i]--;\\n                m2[j]--;\\n                m1[j]++;\\n                m2[i]++;\\n                \\n                int c1 = 0,c2 = 0;\\n                for(auto k:m1)\\n                {\\n                    if(k>=1)c1++;\\n                }\\n                for(auto k:m2)\\n                {\\n                    if(k>=1)c2++;\\n                }\\n                \\n                if(c1 == c2)return true;\\n                \\n                m1[i]++;\\n                m2[j]++;\\n                m1[j]--;\\n                m2[i]--;\\n                }\\n               \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) \\n    {\\n        vector<int>m1(26,0),m2(26,0);\\n        \\n        for(auto i:word1)m1[i-\\'a\\']++;\\n        for(auto i:word2)m2[i-\\'a\\']++;\\n        \\n        for(int i = 0;i<26;i++)\\n        {\\n            for(int j = 0;j<26;j++)\\n            {\\n                if(m1[i] and m2[j])\\n                {\\n                     m1[i]--;\\n                m2[j]--;\\n                m1[j]++;\\n                m2[i]++;\\n                \\n                int c1 = 0,c2 = 0;\\n                for(auto k:m1)\\n                {\\n                    if(k>=1)c1++;\\n                }\\n                for(auto k:m2)\\n                {\\n                    if(k>=1)c2++;\\n                }\\n                \\n                if(c1 == c2)return true;\\n                \\n                m1[i]++;\\n                m2[j]++;\\n                m1[j]--;\\n                m2[i]--;\\n                }\\n               \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016732,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    bool isItPossible(const string &u, const string &v) {\\n        vi(ll)ump(26), vmp(26);\\n        for(char ch:u){\\n            ++ump[ch-\\'a\\'];\\n        }\\n        for(char ch:v){\\n            ++vmp[ch-\\'a\\'];\\n        }\\n        ll da=0, db=0; // distinct from u, distinct from v\\n        for(ll i=0;i<26;++i){\\n            da+=ump[i]>0, db+=vmp[i]>0;\\n        }\\n        for(ll i=0;i<26;++i){\\n            for(ll j=0;j<26;++j){\\n                ll cnta=ump[i], cntb=vmp[j];\\n                if(!cnta || !cntb){ // u can\\'t transact\\n                    continue;\\n                }\\n                    ll dac=da, dbc=db;\\n                    --cnta, cntb+=i==j; // precautionary measure when same characters being swapped\\n                    if(!cnta){\\n                        --dac; // ith letter does not exist anymore in u \\n                    }\\n                    if(!vmp[i]){\\n                        ++dbc; // new letter starts existing in v\\n                    }\\n                    --cntb, cnta+=i==j;\\n                    if(!cntb){\\n                        --dbc;\\n                    }\\n                    if(!ump[j]){\\n                        ++dac;\\n                    }\\n                    if(dac==dbc){\\n                        return 1;\\n                    }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    bool isItPossible(const string &u, const string &v) {\\n        vi(ll)ump(26), vmp(26);\\n        for(char ch:u){\\n            ++ump[ch-\\'a\\'];\\n        }\\n        for(char ch:v){\\n            ++vmp[ch-\\'a\\'];\\n        }\\n        ll da=0, db=0; // distinct from u, distinct from v\\n        for(ll i=0;i<26;++i){\\n            da+=ump[i]>0, db+=vmp[i]>0;\\n        }\\n        for(ll i=0;i<26;++i){\\n            for(ll j=0;j<26;++j){\\n                ll cnta=ump[i], cntb=vmp[j];\\n                if(!cnta || !cntb){ // u can\\'t transact\\n                    continue;\\n                }\\n                    ll dac=da, dbc=db;\\n                    --cnta, cntb+=i==j; // precautionary measure when same characters being swapped\\n                    if(!cnta){\\n                        --dac; // ith letter does not exist anymore in u \\n                    }\\n                    if(!vmp[i]){\\n                        ++dbc; // new letter starts existing in v\\n                    }\\n                    --cntb, cnta+=i==j;\\n                    if(!cntb){\\n                        --dbc;\\n                    }\\n                    if(!ump[j]){\\n                        ++dac;\\n                    }\\n                    if(dac==dbc){\\n                        return 1;\\n                    }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016713,
                "title": "o-letters-3-frequency-map-brute-force",
                "content": "Array or vector works too\\n``` \\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<int, int> freq1, freq2;\\n        // initialize map keys so we don\\'t accidentally add new values while iterating them\\n        for(int i = \\'a\\'; i <= \\'z\\'; i++) freq1[i] = 0;\\n        for(int i = \\'a\\'; i <= \\'z\\'; i++) freq2[i] = 0;\\n        for(auto& i : word1) freq1[i]++;\\n        for(auto& i : word2) freq2[i]++;\\n        \\n        for(auto& i : freq1){\\n            // can\\'t swap values that we have 0 of\\n            if(i.second == 0) continue;\\n            for(auto& j : freq2){\\n                if(j.second == 0) continue;\\n                // simulate swapping value1 with value2\\n                freq1[i.first]--;\\n                freq2[i.first]++;\\n                freq1[j.first]++;\\n                freq2[j.first]--;\\n                \\n                // check if distinct characters are the same\\n                int cnt1 = 0, cnt2 = 0;\\n                for(auto k : freq1) if(k.second > 0) cnt1++;\\n                for(auto k : freq2) if(k.second > 0) cnt2++;\\n                if(cnt1 == cnt2) return true;\\n                \\n                // simulate unswapping value1 with value2\\n                freq1[i.first]++;\\n                freq2[i.first]--;\\n                freq1[j.first]--;\\n                freq2[j.first]++;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<int, int> freq1, freq2;\\n        // initialize map keys so we don\\'t accidentally add new values while iterating them\\n        for(int i = \\'a\\'; i <= \\'z\\'; i++) freq1[i] = 0;\\n        for(int i = \\'a\\'; i <= \\'z\\'; i++) freq2[i] = 0;\\n        for(auto& i : word1) freq1[i]++;\\n        for(auto& i : word2) freq2[i]++;\\n        \\n        for(auto& i : freq1){\\n            // can\\'t swap values that we have 0 of\\n            if(i.second == 0) continue;\\n            for(auto& j : freq2){\\n                if(j.second == 0) continue;\\n                // simulate swapping value1 with value2\\n                freq1[i.first]--;\\n                freq2[i.first]++;\\n                freq1[j.first]++;\\n                freq2[j.first]--;\\n                \\n                // check if distinct characters are the same\\n                int cnt1 = 0, cnt2 = 0;\\n                for(auto k : freq1) if(k.second > 0) cnt1++;\\n                for(auto k : freq2) if(k.second > 0) cnt2++;\\n                if(cnt1 == cnt2) return true;\\n                \\n                // simulate unswapping value1 with value2\\n                freq1[i.first]++;\\n                freq2[i.first]--;\\n                freq1[j.first]--;\\n                freq2[j.first]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3065113,
                "title": "easy-to-understand-for-newbies-like-me-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust try all 26*26 possible pairs\\n\\n# Complexity\\n- Time complexity: O( N + M + 26*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*26) || O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool checkDistinct(vector<int>&a,vector<int>&b){\\n        int cnt1=0, cnt2=0;\\n        for(int i=0;i<26;i++){\\n            if(a[i])cnt1++;\\n            if(b[i])cnt2++;\\n        }\\n        return cnt1==cnt2;\\n    }\\npublic:\\n    bool isItPossible(string w1, string w2) {\\n        vector<int> a(26,0),b(26,0);\\n        for(auto&it:w1)a[it-\\'a\\']++;\\n        for(auto&it:w2)b[it-\\'a\\']++;\\n\\n        if(checkDistinct(a,b) && w1.size() == w2.size())return 1;\\n\\n        //trying all 26*26 possible pairs\\n        for(int i=0;i<26;i++)\\n            if(a[i]){\\n                for(int j=0;j<26;j++)\\n                    if(b[j]){\\n                        //swapping characters\\n                        a[i]--,b[i]++;\\n                        a[j]++,b[j]--; \\n                        if(checkDistinct(a,b))return 1;\\n                        //reverse back the changes\\n                        a[i]++,b[i]--;\\n                        a[j]--,b[j]++; \\n                    }\\n            }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool checkDistinct(vector<int>&a,vector<int>&b){\\n        int cnt1=0, cnt2=0;\\n        for(int i=0;i<26;i++){\\n            if(a[i])cnt1++;\\n            if(b[i])cnt2++;\\n        }\\n        return cnt1==cnt2;\\n    }\\npublic:\\n    bool isItPossible(string w1, string w2) {\\n        vector<int> a(26,0),b(26,0);\\n        for(auto&it:w1)a[it-\\'a\\']++;\\n        for(auto&it:w2)b[it-\\'a\\']++;\\n\\n        if(checkDistinct(a,b) && w1.size() == w2.size())return 1;\\n\\n        //trying all 26*26 possible pairs\\n        for(int i=0;i<26;i++)\\n            if(a[i]){\\n                for(int j=0;j<26;j++)\\n                    if(b[j]){\\n                        //swapping characters\\n                        a[i]--,b[i]++;\\n                        a[j]++,b[j]--; \\n                        if(checkDistinct(a,b))return 1;\\n                        //reverse back the changes\\n                        a[i]++,b[i]--;\\n                        a[j]--,b[j]++; \\n                    }\\n            }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039483,
                "title": "easy-explaination-and-easy-to-understand-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(26*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int n1=word1.length();\\n        int n2=word2.length();\\n        int fre1[26]={};\\n        int fre2[26]={};\\n        for(int i=0;i<n1;i++)\\n            fre1[word1[i]-\\'a\\']++;\\n        for(int i=0;i<n2;i++)\\n            fre2[word2[i]-\\'a\\']++;\\n        int dist1=0;\\n        int dist2=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(fre1[i]>0)\\n                dist1++;\\n            if(fre2[i]>0)\\n                dist2++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(fre1[i]>0)\\n            {\\n            fre1[i]--;\\n            if(fre1[i]==0)\\n                dist1--;\\n            if(fre2[i]==0)\\n                dist2++;\\n           \\n            for(int j=0;j<26;j++)\\n            {\\n                if(fre2[j]>0)\\n                {\\n                fre2[i]++;\\n                if(fre1[j]==0)\\n                    dist1++;\\n                fre1[j]++;\\n                fre2[j]--;\\n                if(fre2[j]==0)\\n                    dist2--;\\n                if(abs(dist1-dist2)==0)\\n                    return true;\\n                fre1[j]--;\\n                if(fre1[j]==0)\\n                    dist1--;\\n                if(fre2[j]==0)\\n                    dist2++;\\n                fre2[j]++; \\n                fre2[i]--;\\n                }\\n            }\\n            \\n            if(fre1[i]==0)\\n                dist1++;\\n            fre1[i]++;\\n            if(fre2[i]==0)\\n                dist2--;\\n            \\n        }\\n        }\\n        \\n    \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int n1=word1.length();\\n        int n2=word2.length();\\n        int fre1[26]={};\\n        int fre2[26]={};\\n        for(int i=0;i<n1;i++)\\n            fre1[word1[i]-\\'a\\']++;\\n        for(int i=0;i<n2;i++)\\n            fre2[word2[i]-\\'a\\']++;\\n        int dist1=0;\\n        int dist2=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(fre1[i]>0)\\n                dist1++;\\n            if(fre2[i]>0)\\n                dist2++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(fre1[i]>0)\\n            {\\n            fre1[i]--;\\n            if(fre1[i]==0)\\n                dist1--;\\n            if(fre2[i]==0)\\n                dist2++;\\n           \\n            for(int j=0;j<26;j++)\\n            {\\n                if(fre2[j]>0)\\n                {\\n                fre2[i]++;\\n                if(fre1[j]==0)\\n                    dist1++;\\n                fre1[j]++;\\n                fre2[j]--;\\n                if(fre2[j]==0)\\n                    dist2--;\\n                if(abs(dist1-dist2)==0)\\n                    return true;\\n                fre1[j]--;\\n                if(fre1[j]==0)\\n                    dist1--;\\n                if(fre2[j]==0)\\n                    dist2++;\\n                fre2[j]++; \\n                fre2[i]--;\\n                }\\n            }\\n            \\n            if(fre1[i]==0)\\n                dist1++;\\n            fre1[i]++;\\n            if(fre2[i]==0)\\n                dist2--;\\n            \\n        }\\n        }\\n        \\n    \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038238,
                "title": "c-using-frequency-array-t-c-o-max-m-n-s-c-o-1",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity = O(max(word1.length(), word2.length))\\n        Space Complexity = O(1)\\n    */\\n    \\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> freq1(26, 0), freq2(26, 0);\\n        \\n        for(int i=0; i<word1.size(); i++){\\n            freq1[word1[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i=0; i<word2.size(); i++){\\n            freq2[word2[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i=0; i<26; i++){\\n            for(int j=0; j<26; j++){\\n                if(freq1[i]>0 && freq2[j]){\\n                    freq1[i]--;\\n                    freq2[j]--;\\n                    \\n                    //Swapping the characters\\n                    freq1[j]++;\\n                    freq2[i]++;\\n                    \\n                    int cnt1=0, cnt2=0;\\n                    for(int k=0; k<26; k++){\\n                        if(freq1[k]>=1) cnt1++;\\n                        if(freq2[k]>=1) cnt2++;\\n                    }\\n                    \\n                    if(cnt1 == cnt2) return true;\\n                    \\n                    //Reversing the swaps\\n                    freq1[j]--;\\n                    freq2[i]--;\\n                    freq1[i]++;\\n                    freq2[j]++;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity = O(max(word1.length(), word2.length))\\n        Space Complexity = O(1)\\n    */\\n    \\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> freq1(26, 0), freq2(26, 0);\\n        \\n        for(int i=0; i<word1.size(); i++){\\n            freq1[word1[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i=0; i<word2.size(); i++){\\n            freq2[word2[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i=0; i<26; i++){\\n            for(int j=0; j<26; j++){\\n                if(freq1[i]>0 && freq2[j]){\\n                    freq1[i]--;\\n                    freq2[j]--;\\n                    \\n                    //Swapping the characters\\n                    freq1[j]++;\\n                    freq2[i]++;\\n                    \\n                    int cnt1=0, cnt2=0;\\n                    for(int k=0; k<26; k++){\\n                        if(freq1[k]>=1) cnt1++;\\n                        if(freq2[k]>=1) cnt2++;\\n                    }\\n                    \\n                    if(cnt1 == cnt2) return true;\\n                    \\n                    //Reversing the swaps\\n                    freq1[j]--;\\n                    freq2[i]--;\\n                    freq1[i]++;\\n                    freq2[j]++;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034853,
                "title": "c-optimised-solution",
                "content": "Plzz UPVOTE \\u2B06\\uFE0F if you find my solution helpful.\\u2028It really gives me the motivation to solve problems and post the best possible solutions for you guys, Your support means a lot.\\uD83D\\uDE4F Thankyou \\uD83D\\uDE4F\\n# Complexity\\n- Time complexity:O(26*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//Optimised Solution\\n//Easy approach\\n    bool isItPossible(string word1, string word2) {\\n        int ct1[26] = {};\\n        int ct2[26] = {};\\n        for (char c: word1) ct1[c-\\'a\\']++;\\n        for (char c: word2) ct2[c-\\'a\\']++;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (ct1[i] && ct2[j]) {\\n                   ct1[i]--, ct1[j]++;\\n                    ct2[i]++, ct2[j]--;\\n                    if (count(begin(ct1), end(ct1), 0) == count(begin(ct2), end(ct2), 0))\\n                        return true;\\n                   \\n                    ct1[i]++, ct1[j]--;\\n                    ct2[i]--, ct2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Optimised Solution\\n//Easy approach\\n    bool isItPossible(string word1, string word2) {\\n        int ct1[26] = {};\\n        int ct2[26] = {};\\n        for (char c: word1) ct1[c-\\'a\\']++;\\n        for (char c: word2) ct2[c-\\'a\\']++;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (ct1[i] && ct2[j]) {\\n                   ct1[i]--, ct1[j]++;\\n                    ct2[i]++, ct2[j]--;\\n                    if (count(begin(ct1), end(ct1), 0) == count(begin(ct2), end(ct2), 0))\\n                        return true;\\n                   \\n                    ct1[i]++, ct1[j]--;\\n                    ct2[i]--, ct2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022535,
                "title": "frequency-map-to-track-swap-character-in-given-words",
                "content": "# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n- Create frequency map of `w1` and `w2`\\n- Find distinct character count\\n- Swapping a character from both strings in terms of frequency map is changing the count of swapped characters `i` and `j`\\n> If new count of characters in `original strings become 0`, number of distinct char `decreases`.\\n> If new character (coming from other string) was not present in originial string and `new frequency becomes 1`, number of distinct char `increases`.\\n\\n\\n\\n# Time Complexity\\nO(26*26)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string w1, string w2) {\\n        int d1 = 0, d2 = 0, tmp1, tmp2;\\n        \\n        // Create a frequency map of both words\\n        vector<int> f1(26), f2(26);\\n        for (auto& c: w1) f1[c-\\'a\\']++;\\n        for (auto& c: w2) f2[c-\\'a\\']++;\\n        \\n        // Find distinct chars\\n        for (int i=0; i<26; i++) if (f1[i]>0) d1++;\\n        for (int i=0; i<26; i++) if (f2[i]>0) d2++;\\n        \\n        for (int i=0; i<26; i++) {\\n            // Character not present. Hence continue;\\n            if (f1[i] == 0) continue;\\n            for (int j=0; j<26; j++) {\\n                if (f2[j] == 0) continue;\\n\\n                // current distinct character count\\n                tmp1 = d1; tmp2 = d2;\\n\\n                // Swap chars in each word and resulting frequency-map\\n                f1[i]--; f2[j]--;\\n                f1[j]++; f2[i]++;\\n                \\n                if (f1[i] == 0) tmp1--;\\n                if (f2[j] == 0) tmp2--;\\n                \\n                if (f1[j] == 1) tmp1++;\\n                if (f2[i] == 1) tmp2++;\\n                \\n                if (tmp1 == tmp2) \\n                    return true;\\n\\n                f1[i]++; f2[j]++;\\n                f1[j]--; f2[i]--;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string w1, string w2) {\\n        int d1 = 0, d2 = 0, tmp1, tmp2;\\n        \\n        // Create a frequency map of both words\\n        vector<int> f1(26), f2(26);\\n        for (auto& c: w1) f1[c-\\'a\\']++;\\n        for (auto& c: w2) f2[c-\\'a\\']++;\\n        \\n        // Find distinct chars\\n        for (int i=0; i<26; i++) if (f1[i]>0) d1++;\\n        for (int i=0; i<26; i++) if (f2[i]>0) d2++;\\n        \\n        for (int i=0; i<26; i++) {\\n            // Character not present. Hence continue;\\n            if (f1[i] == 0) continue;\\n            for (int j=0; j<26; j++) {\\n                if (f2[j] == 0) continue;\\n\\n                // current distinct character count\\n                tmp1 = d1; tmp2 = d2;\\n\\n                // Swap chars in each word and resulting frequency-map\\n                f1[i]--; f2[j]--;\\n                f1[j]++; f2[i]++;\\n                \\n                if (f1[i] == 0) tmp1--;\\n                if (f2[j] == 0) tmp2--;\\n                \\n                if (f1[j] == 1) tmp1++;\\n                if (f2[i] == 1) tmp2++;\\n                \\n                if (tmp1 == tmp2) \\n                    return true;\\n\\n                f1[i]++; f2[j]++;\\n                f1[j]--; f2[i]--;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019284,
                "title": "easy-java-code",
                "content": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int map1[] = new int[26], map2[] = new int[26];\\n        int d1 =calculate(map1, word1), d2 = calculate(map2, word2);\\n        for(int i = 0; i<26; i++)\\n            for(int j = 0; j<26; j++)\\n                if(isPossible(map1, map2, i, j, d1, d2)) return true;\\n        return false;\\n    }\\n\\n    int calculate(int[] map, String word){\\n        for(char ch: word.toCharArray())\\n            map[(int)(ch-\\'a\\')]++;\\n        int d = 0;\\n        for(int m: map) if(m>0) d++;\\n        return d;\\n    }\\n\\n    boolean isPossible(int[] map1, int[] map2, int i, int j, int d1, int d2) {\\n        if(map1[i] == 0 || map2[j] == 0) return false;\\n        map1[i]--; map2[j]--;\\n        map1[j]++; map2[i]++;\\n\\n        if(map1[i] == 0) d1--;\\n        if(map1[j] == 1) d1++;\\n\\n        if(map2[j] == 0) d2--;\\n        if(map2[i] == 1) d2++;\\n\\n        if(d1 == d2) return true;\\n\\n        map1[i]++; map2[j]++;\\n        map1[j]--; map2[i]--;\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int map1[] = new int[26], map2[] = new int[26];\\n        int d1 =calculate(map1, word1), d2 = calculate(map2, word2);\\n        for(int i = 0; i<26; i++)\\n            for(int j = 0; j<26; j++)\\n                if(isPossible(map1, map2, i, j, d1, d2)) return true;\\n        return false;\\n    }\\n\\n    int calculate(int[] map, String word){\\n        for(char ch: word.toCharArray())\\n            map[(int)(ch-\\'a\\')]++;\\n        int d = 0;\\n        for(int m: map) if(m>0) d++;\\n        return d;\\n    }\\n\\n    boolean isPossible(int[] map1, int[] map2, int i, int j, int d1, int d2) {\\n        if(map1[i] == 0 || map2[j] == 0) return false;\\n        map1[i]--; map2[j]--;\\n        map1[j]++; map2[i]++;\\n\\n        if(map1[i] == 0) d1--;\\n        if(map1[j] == 1) d1++;\\n\\n        if(map2[j] == 0) d2--;\\n        if(map2[i] == 1) d2++;\\n\\n        if(d1 == d2) return true;\\n\\n        map1[i]++; map2[j]++;\\n        map1[j]--; map2[i]--;\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017911,
                "title": "c-brute-force-solution",
                "content": "# Intuition\\nfirst store both the strings in two different maps, now apply brute force approach by pick one element from first string and add that two second string and remove from first and similarly pick one element from second string and add that to first string and remove from second, now check the size of map( map size indicates the unique elements in the string), and if the size is same it means this swap is our answer and return true;\\n\\n# Complexity\\n- Time complexity:\\nO(26 * 26 * 26 + (n + m)) where n and m are the string sizes\\nand \\n26 * 26 * 26 -> 26 to iterate over first map, 26 to iterate over second map and 26 to make a copy of map in nested loop.\\n\\n- Space complexity:\\nO(n+m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> mp1,mp2;\\n        \\n        for(char ch : word1) mp1[ch]++;\\n        for(char ch : word2) mp2[ch]++;\\n        \\n        for(auto at : mp1){\\n            char ch1 = at.first;\\n            for(auto it: mp2){\\n                char ch2 = it.first;\\n                unordered_map<char,int> ump1 = mp1, ump2 = mp2;\\n                \\n                ump2[ch1]++; // add a character to second word\\n                ump1[ch2]++; // add a character to fitst word\\n                \\n                ump1[ch1]--; // move a character from first word that is added to second word\\n                ump2[ch2]--; // move a character from second word that is added to first word\\n                \\n                if(ump1[ch1] == 0) ump1.erase(ch1);\\n                if(ump2[ch2] == 0) ump2.erase(ch2);\\n                if(ump1.size() == ump2.size()) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> mp1,mp2;\\n        \\n        for(char ch : word1) mp1[ch]++;\\n        for(char ch : word2) mp2[ch]++;\\n        \\n        for(auto at : mp1){\\n            char ch1 = at.first;\\n            for(auto it: mp2){\\n                char ch2 = it.first;\\n                unordered_map<char,int> ump1 = mp1, ump2 = mp2;\\n                \\n                ump2[ch1]++; // add a character to second word\\n                ump1[ch2]++; // add a character to fitst word\\n                \\n                ump1[ch1]--; // move a character from first word that is added to second word\\n                ump2[ch2]--; // move a character from second word that is added to first word\\n                \\n                if(ump1[ch1] == 0) ump1.erase(ch1);\\n                if(ump2[ch2] == 0) ump2.erase(ch2);\\n                if(ump1.size() == ump2.size()) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017718,
                "title": "accepted-o-26-26-java",
                "content": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int [] map1 = new int[26];\\n        int [] map2 = new int[26];\\n        int dc1 = 0, dc2 = 0;\\n        for(char c: word1.toCharArray()){\\n            map1[c-\\'a\\']++;\\n            if(map1[c-\\'a\\']==1)dc1++;\\n        }\\n        for(char c: word2.toCharArray()){\\n            map2[c-\\'a\\']++;\\n            if(map2[c-\\'a\\']==1)dc2++;\\n        }\\n                \\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(map1[i]>0 && map2[j]>0){\\n                    \\n                    map1[i]--;\\n                    map1[j]++;\\n                    map2[j]--;\\n                    map2[i]++;\\n                    int v1 = dc1, v2 = dc2;\\n                    if(map1[i]==0) v1--;\\n                    if(map1[j]==1) v1++;\\n                    \\n                    if(map2[j]==0) v2--;\\n                    if(map2[i]==1) v2++;\\n                    \\n                    if(v1==v2)return true;\\n                    \\n                    map1[i]++;\\n                    map1[j]--;\\n                    map2[j]++;\\n                    map2[i]--;\\n                    \\n                }\\n            }\\n        }\\n                \\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int [] map1 = new int[26];\\n        int [] map2 = new int[26];\\n        int dc1 = 0, dc2 = 0;\\n        for(char c: word1.toCharArray()){\\n            map1[c-\\'a\\']++;\\n            if(map1[c-\\'a\\']==1)dc1++;\\n        }\\n        for(char c: word2.toCharArray()){\\n            map2[c-\\'a\\']++;\\n            if(map2[c-\\'a\\']==1)dc2++;\\n        }\\n                \\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(map1[i]>0 && map2[j]>0){\\n                    \\n                    map1[i]--;\\n                    map1[j]++;\\n                    map2[j]--;\\n                    map2[i]++;\\n                    int v1 = dc1, v2 = dc2;\\n                    if(map1[i]==0) v1--;\\n                    if(map1[j]==1) v1++;\\n                    \\n                    if(map2[j]==0) v2--;\\n                    if(map2[i]==1) v2++;\\n                    \\n                    if(v1==v2)return true;\\n                    \\n                    map1[i]++;\\n                    map1[j]--;\\n                    map2[j]++;\\n                    map2[i]--;\\n                    \\n                }\\n            }\\n        }\\n                \\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017232,
                "title": "brute-force-solution-with-hashmap",
                "content": "\\n# Approach\\nHashMap!\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n       Map<Character, Integer> map = new HashMap<>();\\n        Map<Character, Integer> map2 = new HashMap<>();\\n        Map<Character, Integer> map3;\\n        Map<Character, Integer> map4;\\n\\n        //add all chars to the map\\n        for (char character : word1.toCharArray()) {\\n            map.put(character, map.getOrDefault(character, 0) + 1);\\n        }\\n        for (char character : word2.toCharArray()) {\\n            map2.put(character, map2.getOrDefault(character, 0) + 1);\\n        }\\n\\n        for (Map.Entry<Character, Integer> entry : map.entrySet()) {\\n            for (Map.Entry<Character, Integer> entry1 : map2.entrySet()) {\\n                map3 = new HashMap<>(map);\\n                map4 = new HashMap<>(map2);\\n\\n                //remove one char from map3\\n                map3.put(entry.getKey(), map3.get(entry.getKey()) - 1);\\n                if (map3.get(entry.getKey()) == 0) map3.remove(entry.getKey());\\n                //add a new char to map3\\n                map3.put(entry1.getKey(), 1);\\n\\n                //remove one char from map4\\n                map4.put(entry1.getKey(), map4.get(entry1.getKey()) - 1);\\n                if (map4.get(entry1.getKey()) == 0) map4.remove(entry1.getKey());\\n                //add a new char to map4\\n                map4.put(entry.getKey(), 1);\\n\\n                if (map3.size() == map4.size()) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n       Map<Character, Integer> map = new HashMap<>();\\n        Map<Character, Integer> map2 = new HashMap<>();\\n        Map<Character, Integer> map3;\\n        Map<Character, Integer> map4;\\n\\n        //add all chars to the map\\n        for (char character : word1.toCharArray()) {\\n            map.put(character, map.getOrDefault(character, 0) + 1);\\n        }\\n        for (char character : word2.toCharArray()) {\\n            map2.put(character, map2.getOrDefault(character, 0) + 1);\\n        }\\n\\n        for (Map.Entry<Character, Integer> entry : map.entrySet()) {\\n            for (Map.Entry<Character, Integer> entry1 : map2.entrySet()) {\\n                map3 = new HashMap<>(map);\\n                map4 = new HashMap<>(map2);\\n\\n                //remove one char from map3\\n                map3.put(entry.getKey(), map3.get(entry.getKey()) - 1);\\n                if (map3.get(entry.getKey()) == 0) map3.remove(entry.getKey());\\n                //add a new char to map3\\n                map3.put(entry1.getKey(), 1);\\n\\n                //remove one char from map4\\n                map4.put(entry1.getKey(), map4.get(entry1.getKey()) - 1);\\n                if (map4.get(entry1.getKey()) == 0) map4.remove(entry1.getKey());\\n                //add a new char to map4\\n                map4.put(entry.getKey(), 1);\\n\\n                if (map3.size() == map4.size()) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017153,
                "title": "easy-to-follow-js-commented",
                "content": "# Intuition\\nCount frequency and try all possible truth swap.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nvar isItPossible = function (w1, w2) {\\n//Count frequency to each word.\\n  const cnt1 = {},cnt2 = {};\\n  for (let w of w1) {\\n    cnt1[w] = (cnt1[w] || 0) + 1;\\n  }\\n  for (let w of w2) {\\n    cnt2[w] = (cnt2[w] || 0) + 1;\\n  }\\n\\n//Deep copy frequency counter and swap each pair,\\n//return true if there is a pair is \\'possible\\'\\n  for (let word1 in cnt1) {\\n    for (let word2 in cnt2) {\\n      const cot1 = Object.assign({}, cnt1), cot2 = Object.assign({}, cnt2);\\n      swap(word1, word2, cot1, cot2);\\n      if (Object.keys(cot1).length === Object.keys(cot2).length) return true;\\n    }\\n  }\\n  return false;\\n\\n  function swap(wd1, wd2, ct1, ct2) {\\n    ct1[wd2] = (ct1[wd2] || 0) + 1;\\n    ct2[wd1] = (ct2[wd1] || 0) + 1;\\n    ct1[wd1]--;\\n    if (!ct1[wd1]) delete ct1[wd1];\\n    ct2[wd2]--;\\n    if (!ct2[wd2]) delete ct2[wd2];\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isItPossible = function (w1, w2) {\\n//Count frequency to each word.\\n  const cnt1 = {},cnt2 = {};\\n  for (let w of w1) {\\n    cnt1[w] = (cnt1[w] || 0) + 1;\\n  }\\n  for (let w of w2) {\\n    cnt2[w] = (cnt2[w] || 0) + 1;\\n  }\\n\\n//Deep copy frequency counter and swap each pair,\\n//return true if there is a pair is \\'possible\\'\\n  for (let word1 in cnt1) {\\n    for (let word2 in cnt2) {\\n      const cot1 = Object.assign({}, cnt1), cot2 = Object.assign({}, cnt2);\\n      swap(word1, word2, cot1, cot2);\\n      if (Object.keys(cot1).length === Object.keys(cot2).length) return true;\\n    }\\n  }\\n  return false;\\n\\n  function swap(wd1, wd2, ct1, ct2) {\\n    ct1[wd2] = (ct1[wd2] || 0) + 1;\\n    ct2[wd1] = (ct2[wd1] || 0) + 1;\\n    ct1[wd1]--;\\n    if (!ct1[wd1]) delete ct1[wd1];\\n    ct2[wd2]--;\\n    if (!ct2[wd2]) delete ct2[wd2];\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3017104,
                "title": "python-o-26-26-with-comments-beats-100",
                "content": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        d1 = Counter(word1)\\n        d2 = Counter(word2)\\n        \\n        # Avoid changing length of dictionary in the iterations.\\n        for c in \"abcdefghijklmnopqrstuvwxyz\":\\n            d1[c] = d1.get(c, 0)\\n            d2[c] = d2.get(c, 0)\\n        \\n        for c1 in d1:\\n            if d1[c1] > 0:\\n                # Swap c1 first\\n                d1[c1] -= 1\\n\\n                for c2 in d2:\\n                    if d2[c2] > 0:\\n                        # Finish the whole swaping:\\n                        # Same as word1[c1_idx], word2[c2_idx] = word2[c2_idx], word1[c1_idx] \\n                        d2[c1] += 1\\n                        d2[c2] -= 1\\n                        d1[c2] += 1\\n                        \\n                        # Check if the counts of distinct characters are same.\\n                        if len([1 for c in d1.values() if c > 0]) == len([1 for c in d2.values() if c > 0]):\\n                            return True\\n                        \\n                        # Restore current swap for the next swap\\n                        d2[c1] -= 1\\n                        d2[c2] += 1\\n                        d1[c2] -= 1\\n\\n                # Restore c1 for the next character of word1\\n                d1[c1] += 1\\n        \\n        # No swaps above reach the goal\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        d1 = Counter(word1)\\n        d2 = Counter(word2)\\n        \\n        # Avoid changing length of dictionary in the iterations.\\n        for c in \"abcdefghijklmnopqrstuvwxyz\":\\n            d1[c] = d1.get(c, 0)\\n            d2[c] = d2.get(c, 0)\\n        \\n        for c1 in d1:\\n            if d1[c1] > 0:\\n                # Swap c1 first\\n                d1[c1] -= 1\\n\\n                for c2 in d2:\\n                    if d2[c2] > 0:\\n                        # Finish the whole swaping:\\n                        # Same as word1[c1_idx], word2[c2_idx] = word2[c2_idx], word1[c1_idx] \\n                        d2[c1] += 1\\n                        d2[c2] -= 1\\n                        d1[c2] += 1\\n                        \\n                        # Check if the counts of distinct characters are same.\\n                        if len([1 for c in d1.values() if c > 0]) == len([1 for c in d2.values() if c > 0]):\\n                            return True\\n                        \\n                        # Restore current swap for the next swap\\n                        d2[c1] -= 1\\n                        d2[c2] += 1\\n                        d1[c2] -= 1\\n\\n                # Restore c1 for the next character of word1\\n                d1[c1] += 1\\n        \\n        # No swaps above reach the goal\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017085,
                "title": "c-bruteforce-check-every-pair",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int check(vector<int>&v){\\n        int res=0;\\n        \\n        for(int i=0;i<26;i++){\\n            if(v[i]>0)\\n                res++;\\n        }\\n        return res;\\n    }\\n    bool isItPossible(string word1, string word2) {\\n     \\n            vector<int>mpa(26,0);\\n            vector<int>mpb(26,0);\\n           \\n            for(int i=0;i<max(word1.size(),word2.size());i++){\\n                if(i<word1.size())\\n                    mpa[word1[i]-\\'a\\']++;\\n                if(i<word2.size())\\n                    mpb[word2[i]-\\'a\\']++;\\n            }\\n        \\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(mpa[i]>0 && mpb[j]>0){\\n                    mpa[i]-=1;\\n                    mpb[i]+=1;\\n                    mpb[j]-=1;\\n                    mpa[j]+=1;\\n                    if(check(mpa) == check(mpb))\\n                        return true;\\n                    mpa[i]+=1;\\n                    mpb[i]-=1;\\n                    mpb[j]+=1;\\n                    mpa[j]-=1;\\n                }\\n            }\\n        }       \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>&v){\\n        int res=0;\\n        \\n        for(int i=0;i<26;i++){\\n            if(v[i]>0)\\n                res++;\\n        }\\n        return res;\\n    }\\n    bool isItPossible(string word1, string word2) {\\n     \\n            vector<int>mpa(26,0);\\n            vector<int>mpb(26,0);\\n           \\n            for(int i=0;i<max(word1.size(),word2.size());i++){\\n                if(i<word1.size())\\n                    mpa[word1[i]-\\'a\\']++;\\n                if(i<word2.size())\\n                    mpb[word2[i]-\\'a\\']++;\\n            }\\n        \\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(mpa[i]>0 && mpb[j]>0){\\n                    mpa[i]-=1;\\n                    mpb[i]+=1;\\n                    mpb[j]-=1;\\n                    mpa[j]+=1;\\n                    if(check(mpa) == check(mpb))\\n                        return true;\\n                    mpa[i]+=1;\\n                    mpb[i]-=1;\\n                    mpb[j]+=1;\\n                    mpa[j]-=1;\\n                }\\n            }\\n        }       \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016972,
                "title": "python3-brute-force-o-26-26",
                "content": "# Approach\\n**Brute Force:**\\n- iterate over all possible iterations (i.e., 2 `for` loops)\\n- if both the letters exists (i.e., their count != 0)\\n- Swap\\n- Check for Validity\\n- Restore\\n\\n# Complexity\\n- Time complexity: $$O(26*26)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        cnt1, cnt2 = [0 for i in range(26)], [0 for i in range(26)]\\n        for i in range(len(word1)):\\n            cnt1[ord(word1[i]) - ord(\\'a\\')] += 1\\n        for i in range(len(word2)):\\n            cnt2[ord(word2[i]) - ord(\\'a\\')] += 1\\n        for i in range(26):\\n            for j in range(26):\\n                if cnt1[i] != 0 and cnt2[j] != 0:\\n                    # Swap\\n                    cnt1[j] += 1\\n                    cnt2[j] -= 1\\n                    cnt1[i] -= 1\\n                    cnt2[i] += 1\\n                    # Check Validity\\n                    if self.isValid(cnt1, cnt2):\\n                        return True\\n                    # Restore\\n                    cnt1[j] -= 1\\n                    cnt2[j] += 1\\n                    cnt1[i] += 1\\n                    cnt2[i] -= 1\\n        return False\\n    \\n    def isValid(self, c1, c2):\\n        d1, d2 = 0, 0\\n        for i in range(26):\\n            if c1[i] != 0:\\n                d1 += 1\\n            if c2[i] != 0:\\n                d2 += 1\\n        return d1 == d2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        cnt1, cnt2 = [0 for i in range(26)], [0 for i in range(26)]\\n        for i in range(len(word1)):\\n            cnt1[ord(word1[i]) - ord(\\'a\\')] += 1\\n        for i in range(len(word2)):\\n            cnt2[ord(word2[i]) - ord(\\'a\\')] += 1\\n        for i in range(26):\\n            for j in range(26):\\n                if cnt1[i] != 0 and cnt2[j] != 0:\\n                    # Swap\\n                    cnt1[j] += 1\\n                    cnt2[j] -= 1\\n                    cnt1[i] -= 1\\n                    cnt2[i] += 1\\n                    # Check Validity\\n                    if self.isValid(cnt1, cnt2):\\n                        return True\\n                    # Restore\\n                    cnt1[j] -= 1\\n                    cnt2[j] += 1\\n                    cnt1[i] += 1\\n                    cnt2[i] -= 1\\n        return False\\n    \\n    def isValid(self, c1, c2):\\n        d1, d2 = 0, 0\\n        for i in range(26):\\n            if c1[i] != 0:\\n                d1 += 1\\n            if c2[i] != 0:\\n                d2 += 1\\n        return d1 == d2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016917,
                "title": "c-easy-to-understand-brute-force-approach-clean",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTried out every swap between characters (and not index) and checked whether number of distinct characters became equal or not.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tbool isItPossible(string word1, string word2)\\n\\t{\\n\\t\\tvector<int> a(26, 0), b(26, 0);\\n\\t\\tfor (auto &x : word1)\\n\\t\\t\\ta[x - \\'a\\']++;\\n\\t\\tfor (auto &x : word2)\\n\\t\\t\\tb[x - \\'a\\']++;\\n\\t\\tfor (int i = 0; i < 26; i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < 26; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (a[j] <= 0 or b[i] <= 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\ta[i]++;\\n\\t\\t\\t\\ta[j]--;\\n\\t\\t\\t\\tb[i]--;\\n\\t\\t\\t\\tb[j]++;\\n\\t\\t\\t\\tint ct1 = 0, ct2 = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < 26; k++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (a[k] > 0)\\n\\t\\t\\t\\t\\t\\tct1++;\\n\\t\\t\\t\\t\\tif (b[k] > 0)\\n\\t\\t\\t\\t\\t\\tct2++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (ct1 == ct2)\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\ta[j]++;\\n\\t\\t\\t\\ta[i]--;\\n\\t\\t\\t\\tb[j]--;\\n\\t\\t\\t\\tb[i]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tbool isItPossible(string word1, string word2)\\n\\t{\\n\\t\\tvector<int> a(26, 0), b(26, 0);\\n\\t\\tfor (auto &x : word1)\\n\\t\\t\\ta[x - \\'a\\']++;\\n\\t\\tfor (auto &x : word2)\\n\\t\\t\\tb[x - \\'a\\']++;\\n\\t\\tfor (int i = 0; i < 26; i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < 26; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (a[j] <= 0 or b[i] <= 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\ta[i]++;\\n\\t\\t\\t\\ta[j]--;\\n\\t\\t\\t\\tb[i]--;\\n\\t\\t\\t\\tb[j]++;\\n\\t\\t\\t\\tint ct1 = 0, ct2 = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < 26; k++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (a[k] > 0)\\n\\t\\t\\t\\t\\t\\tct1++;\\n\\t\\t\\t\\t\\tif (b[k] > 0)\\n\\t\\t\\t\\t\\t\\tct2++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (ct1 == ct2)\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\ta[j]++;\\n\\t\\t\\t\\ta[i]--;\\n\\t\\t\\t\\tb[j]--;\\n\\t\\t\\t\\tb[i]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016897,
                "title": "python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        temp1, temp2 = [0] * 26, [0] * 26\\n        for i in range(len(word1)):\\n            temp1[ord(word1[i]) - ord(\\'a\\')] += 1\\n        for i in range(len(word2)):\\n            temp2[ord(word2[i]) - ord(\\'a\\')] += 1\\n\\n        for i in range(ord(\\'a\\'), ord(\\'z\\')+1):\\n            for j in range(ord(\\'a\\'), ord(\\'z\\')+1):\\n                if temp1[i - ord(\\'a\\')] <= 0 or temp2[j - ord(\\'a\\')] <= 0:\\n                    continue\\n                temp1[i - ord(\\'a\\')], temp2[j - ord(\\'a\\')] = temp1[i - ord(\\'a\\')]-1, temp2[j - ord(\\'a\\')]-1\\n                temp2[i - ord(\\'a\\')], temp1[j - ord(\\'a\\')] = temp2[i - ord(\\'a\\')]+1, temp1[j - ord(\\'a\\')]+1\\n                a, b = 0, 0\\n                for it in temp1:\\n                    if it > 0:\\n                        a += 1\\n                for it in temp2:\\n                    if it > 0:\\n                        b += 1\\n                if a == b:\\n                    return True\\n                temp1[i - ord(\\'a\\')], temp2[j - ord(\\'a\\')] = temp1[i - ord(\\'a\\')]+1, temp2[j - ord(\\'a\\')]+1\\n                temp1[j - ord(\\'a\\')], temp2[i - ord(\\'a\\')] =  temp1[j - ord(\\'a\\')]-1, temp2[i - ord(\\'a\\')]-1\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        temp1, temp2 = [0] * 26, [0] * 26\\n        for i in range(len(word1)):\\n            temp1[ord(word1[i]) - ord(\\'a\\')] += 1\\n        for i in range(len(word2)):\\n            temp2[ord(word2[i]) - ord(\\'a\\')] += 1\\n\\n        for i in range(ord(\\'a\\'), ord(\\'z\\')+1):\\n            for j in range(ord(\\'a\\'), ord(\\'z\\')+1):\\n                if temp1[i - ord(\\'a\\')] <= 0 or temp2[j - ord(\\'a\\')] <= 0:\\n                    continue\\n                temp1[i - ord(\\'a\\')], temp2[j - ord(\\'a\\')] = temp1[i - ord(\\'a\\')]-1, temp2[j - ord(\\'a\\')]-1\\n                temp2[i - ord(\\'a\\')], temp1[j - ord(\\'a\\')] = temp2[i - ord(\\'a\\')]+1, temp1[j - ord(\\'a\\')]+1\\n                a, b = 0, 0\\n                for it in temp1:\\n                    if it > 0:\\n                        a += 1\\n                for it in temp2:\\n                    if it > 0:\\n                        b += 1\\n                if a == b:\\n                    return True\\n                temp1[i - ord(\\'a\\')], temp2[j - ord(\\'a\\')] = temp1[i - ord(\\'a\\')]+1, temp2[j - ord(\\'a\\')]+1\\n                temp1[j - ord(\\'a\\')], temp2[i - ord(\\'a\\')] =  temp1[j - ord(\\'a\\')]-1, temp2[i - ord(\\'a\\')]-1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016831,
                "title": "using-bracktracking",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\n    bool isItPossible(string word1, string word2) {\\n            vector<int> cnt1(26),cnt2(26);\\n            for(auto ch:word1)cnt1[ch-\\'a\\']++;\\n            for(auto ch:word2)cnt2[ch-\\'a\\']++;\\n            \\n            \\n            for(int i=0;i<26;i++){\\n                if(!cnt1[i])continue;\\n                \\n                for(int j=0;j<26;j++){\\n                    if(!cnt2[j])continue;\\n                    //backtrack\\n                    cnt1[i]--,cnt2[j]--;\\n                    //do opearation\\n                    cnt2[i]++,cnt1[j]++;\\n                    \\n                    //check for distinct number\\n                    if(getCnt(cnt1)==getCnt(cnt2))return true;\\n                    \\n                    //do operation\\n                    cnt1[i]++,cnt2[j]++;\\n                    //backtrack\\n                    cnt2[i]--,cnt1[j]--;\\n                }\\n            }\\n            return false;\\n        }\\nprivate:\\n    int getCnt(vector<int>& arr,int cnt = 0){\\n       for(auto ele:arr)cnt+=ele>=1;\\n       return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    bool isItPossible(string word1, string word2) {\\n            vector<int> cnt1(26),cnt2(26);\\n            for(auto ch:word1)cnt1[ch-\\'a\\']++;\\n            for(auto ch:word2)cnt2[ch-\\'a\\']++;\\n            \\n            \\n            for(int i=0;i<26;i++){\\n                if(!cnt1[i])continue;\\n                \\n                for(int j=0;j<26;j++){\\n                    if(!cnt2[j])continue;\\n                    //backtrack\\n                    cnt1[i]--,cnt2[j]--;\\n                    //do opearation\\n                    cnt2[i]++,cnt1[j]++;\\n                    \\n                    //check for distinct number\\n                    if(getCnt(cnt1)==getCnt(cnt2))return true;\\n                    \\n                    //do operation\\n                    cnt1[i]++,cnt2[j]++;\\n                    //backtrack\\n                    cnt2[i]--,cnt1[j]--;\\n                }\\n            }\\n            return false;\\n        }\\nprivate:\\n    int getCnt(vector<int>& arr,int cnt = 0){\\n       for(auto ele:arr)cnt+=ele>=1;\\n       return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016819,
                "title": "java-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] arr1 = new int[26];\\n        int[] arr2 = new int[26];\\n        for(char c : word1.toCharArray()) arr1[c-\\'a\\']++;\\n        for(char c : word2.toCharArray()) arr2[c-\\'a\\']++;\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(arr1[i] == 0) continue;\\n            arr1[i]--;\\n            \\n            for(int j = 0; j < 26; j++) {\\n                if(arr2[j] == 0) continue;\\n                arr2[j]--;\\n                \\n                arr1[j]++;\\n                arr2[i]++;\\n                if(checkforsame(arr1, arr2)) return true;\\n                arr1[j]--; \\n                arr2[i]--; \\n\\n                arr2[j]++;\\n            }\\n            arr1[i]++;\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public boolean checkforsame(int[]a, int[] b) {\\n        int cnt1 = 0;\\n        int cnt2 = 0;\\n        for(int c : a) if(c != 0) cnt1++;\\n        for(int c : b) if(c != 0) cnt2++;\\n        return cnt1 == cnt2;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] arr1 = new int[26];\\n        int[] arr2 = new int[26];\\n        for(char c : word1.toCharArray()) arr1[c-\\'a\\']++;\\n        for(char c : word2.toCharArray()) arr2[c-\\'a\\']++;\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(arr1[i] == 0) continue;\\n            arr1[i]--;\\n            \\n            for(int j = 0; j < 26; j++) {\\n                if(arr2[j] == 0) continue;\\n                arr2[j]--;\\n                \\n                arr1[j]++;\\n                arr2[i]++;\\n                if(checkforsame(arr1, arr2)) return true;\\n                arr1[j]--; \\n                arr2[i]--; \\n\\n                arr2[j]++;\\n            }\\n            arr1[i]++;\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public boolean checkforsame(int[]a, int[] b) {\\n        int cnt1 = 0;\\n        int cnt2 = 0;\\n        for(int c : a) if(c != 0) cnt1++;\\n        for(int c : b) if(c != 0) cnt2++;\\n        return cnt1 == cnt2;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016758,
                "title": "c-use-count-of-each-character",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int a[26] = {0}, b[26]={0};\\n        for(auto i : word1){\\n            a[i-\\'a\\']++;\\n        }\\n        for(auto i : word2){\\n            b[i-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(a[i]  && b[j]){\\n                    b[i] += 1;\\n                    a[i] -= 1;\\n                    a[j] += 1;\\n                    b[j] -= 1;\\n                    int d1=0,d2=0;    \\n                    for(int aa=0;aa<26;aa++){\\n                        if(a[aa]>0) d1+=1;\\n                        if(b[aa]>0) d2+=1;\\n                    }\\n                    // cout<<d1<<\" \"<<d2<<\"\\\\n\";\\n                    b[i] -= 1;\\n                    a[i] += 1;\\n                    a[j] -= 1;\\n                    b[j] += 1;\\n                    if(d1==d2) return true;                 \\n                }       \\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int a[26] = {0}, b[26]={0};\\n        for(auto i : word1){\\n            a[i-\\'a\\']++;\\n        }\\n        for(auto i : word2){\\n            b[i-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(a[i]  && b[j]){\\n                    b[i] += 1;\\n                    a[i] -= 1;\\n                    a[j] += 1;\\n                    b[j] -= 1;\\n                    int d1=0,d2=0;    \\n                    for(int aa=0;aa<26;aa++){\\n                        if(a[aa]>0) d1+=1;\\n                        if(b[aa]>0) d2+=1;\\n                    }\\n                    // cout<<d1<<\" \"<<d2<<\"\\\\n\";\\n                    b[i] -= 1;\\n                    a[i] += 1;\\n                    a[j] -= 1;\\n                    b[j] += 1;\\n                    if(d1==d2) return true;                 \\n                }       \\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3016742,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] letters1 = new int[26];\\n        int[] letters2 = new int[26];\\n        for (int i = 0; i < word1.length(); i++) {\\n            char c = word1.charAt(i);\\n            letters1[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < word2.length(); i++) {\\n            char c = word2.charAt(i);\\n            letters2[c - \\'a\\']++;      \\n        }\\n        int count = 0;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (letters1[j] == 0 || letters2[i] == 0) {\\n                    continue;\\n                }\\n                letters1[j]--;\\n                letters2[j]++;\\n                letters1[i]++;\\n                letters2[i]--;\\n                int numDistinctCharacters1 = 0;\\n                int numDistinctCharacters2 = 0;\\n                for (int k = 0; k < 26; k++) {\\n                    if (letters1[k] > 0) {\\n                        numDistinctCharacters1++;\\n                    }\\n                    if (letters2[k] > 0) {\\n                        numDistinctCharacters2++;\\n                    }\\n                }\\n                if (numDistinctCharacters1 == numDistinctCharacters2) {\\n                    return true;\\n                }\\n                letters1[j]++;\\n                letters2[j]--;\\n                letters1[i]--;\\n                letters2[i]++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] letters1 = new int[26];\\n        int[] letters2 = new int[26];\\n        for (int i = 0; i < word1.length(); i++) {\\n            char c = word1.charAt(i);\\n            letters1[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < word2.length(); i++) {\\n            char c = word2.charAt(i);\\n            letters2[c - \\'a\\']++;      \\n        }\\n        int count = 0;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (letters1[j] == 0 || letters2[i] == 0) {\\n                    continue;\\n                }\\n                letters1[j]--;\\n                letters2[j]++;\\n                letters1[i]++;\\n                letters2[i]--;\\n                int numDistinctCharacters1 = 0;\\n                int numDistinctCharacters2 = 0;\\n                for (int k = 0; k < 26; k++) {\\n                    if (letters1[k] > 0) {\\n                        numDistinctCharacters1++;\\n                    }\\n                    if (letters2[k] > 0) {\\n                        numDistinctCharacters2++;\\n                    }\\n                }\\n                if (numDistinctCharacters1 == numDistinctCharacters2) {\\n                    return true;\\n                }\\n                letters1[j]++;\\n                letters2[j]--;\\n                letters1[i]--;\\n                letters2[i]++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060689,
                "title": "java-simple-solution",
                "content": "class Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n\\n        int t1[] = new int[26];\\n        for(int i=0;i<word1.length();i++){\\n            char ch = word1.charAt(i);\\n            t1[ch-\\'a\\']++;\\n        }\\n\\n        int t2[] = new int[26];\\n        for(int i=0;i<word2.length();i++){\\n            char ch = word2.charAt(i);\\n            t2[ch-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(t1[i]==0) continue;\\n            for(int j=0;j<26;j++){\\n                if(t2[j]==0) continue;\\n                   t2[j]--;\\n                   t1[i]--;\\n                   t1[j]++;\\n                   t2[i]++;\\n                   int x1 = swapfun(t1);\\n                   int x2 = swapfun(t2);\\n                   if(x1 == x2){System.out.println(i+\" \"+j); return true;}\\n                   t2[j]++;\\n                   t1[i]++;\\n                   t1[j]--;\\n                   t2[i]--;\\n            }\\n        }\\n        return false;\\n    }\\n    int swapfun(int t[]){\\n        int diff = 0;\\n        for(int i=0;i<26;i++){\\n            if(t[i]>0) diff++;\\n        }\\n        return diff;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n\\n        int t1[] = new int[26];\\n        for(int i=0;i<word1.length();i++){\\n            char ch = word1.charAt(i);\\n            t1[ch-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4046591,
                "title": "optiminal-possible-with-linear-time-complexity-easy-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(26*26)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(word1.length+word2.length) --> only for distinct characters**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        Map<Character, Integer> map1 = new HashMap<>();\\n        Map<Character, Integer> map2 = new HashMap<>();\\n\\n        for(char ch : word1.toCharArray()) map1.put(ch, map1.getOrDefault(ch, 0)+1);\\n        for(char ch : word2.toCharArray()) map2.put(ch, map2.getOrDefault(ch, 0)+1);\\n\\n        for( char i=\\'a\\'; i<=\\'z\\'; i++){\\n            for(char j=\\'a\\'; j<=\\'z\\'; j++){\\n                if(map1.containsKey(i) && map2.containsKey(j)){\\n                    map1.put(i, map1.getOrDefault(i,0)-1);\\n                    if(map1.get(i)==0) {\\n                        map1.remove(i);\\n                    }\\n                    map1.put(j, map1.getOrDefault(j, 0)+1);\\n\\n\\n                    map2.put(j, map2.getOrDefault(j,0)-1);\\n                    if(map2.get(j)==0){\\n                        map2.remove(j);\\n                    } \\n                    map2.put(i, map2.getOrDefault(i, 0)+1);\\n\\n\\n                    \\n                    if(map1.size() == map2.size()) return true;\\n\\n\\n                    map1.put(j, map1.getOrDefault(j,0)-1);\\n                    if(map1.get(j)==0) {\\n                        map1.remove(j);\\n                    }\\n                    map1.put(i, map1.getOrDefault(i, 0)+1);\\n\\n\\n                    map2.put(i, map2.getOrDefault(i,0)-1);\\n                    if(map2.get(i)==0){\\n                        map2.remove(i);\\n                    } \\n                    map2.put(j, map2.getOrDefault(j, 0)+1); \\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        Map<Character, Integer> map1 = new HashMap<>();\\n        Map<Character, Integer> map2 = new HashMap<>();\\n\\n        for(char ch : word1.toCharArray()) map1.put(ch, map1.getOrDefault(ch, 0)+1);\\n        for(char ch : word2.toCharArray()) map2.put(ch, map2.getOrDefault(ch, 0)+1);\\n\\n        for( char i=\\'a\\'; i<=\\'z\\'; i++){\\n            for(char j=\\'a\\'; j<=\\'z\\'; j++){\\n                if(map1.containsKey(i) && map2.containsKey(j)){\\n                    map1.put(i, map1.getOrDefault(i,0)-1);\\n                    if(map1.get(i)==0) {\\n                        map1.remove(i);\\n                    }\\n                    map1.put(j, map1.getOrDefault(j, 0)+1);\\n\\n\\n                    map2.put(j, map2.getOrDefault(j,0)-1);\\n                    if(map2.get(j)==0){\\n                        map2.remove(j);\\n                    } \\n                    map2.put(i, map2.getOrDefault(i, 0)+1);\\n\\n\\n                    \\n                    if(map1.size() == map2.size()) return true;\\n\\n\\n                    map1.put(j, map1.getOrDefault(j,0)-1);\\n                    if(map1.get(j)==0) {\\n                        map1.remove(j);\\n                    }\\n                    map1.put(i, map1.getOrDefault(i, 0)+1);\\n\\n\\n                    map2.put(i, map2.getOrDefault(i,0)-1);\\n                    if(map2.get(i)==0){\\n                        map2.remove(i);\\n                    } \\n                    map2.put(j, map2.getOrDefault(j, 0)+1); \\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012588,
                "title": "simple-c-using-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//Optimised Solution\\n//Easy approach\\n    bool isItPossible(string word1, string word2) {\\n        int ct1[26] = {};\\n        int ct2[26] = {};\\n        for (char c: word1) ct1[c-\\'a\\']++;\\n        for (char c: word2) ct2[c-\\'a\\']++;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (ct1[i] && ct2[j]) {\\n                   ct1[i]--, ct1[j]++;\\n                    ct2[i]++, ct2[j]--;\\n                    if (count(begin(ct1), end(ct1), 0) == count(begin(ct2), end(ct2), 0))\\n                        return true;\\n                   \\n                    ct1[i]++, ct1[j]--;\\n                    ct2[i]--, ct2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Optimised Solution\\n//Easy approach\\n    bool isItPossible(string word1, string word2) {\\n        int ct1[26] = {};\\n        int ct2[26] = {};\\n        for (char c: word1) ct1[c-\\'a\\']++;\\n        for (char c: word2) ct2[c-\\'a\\']++;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (ct1[i] && ct2[j]) {\\n                   ct1[i]--, ct1[j]++;\\n                    ct2[i]++, ct2[j]--;\\n                    if (count(begin(ct1), end(ct1), 0) == count(begin(ct2), end(ct2), 0))\\n                        return true;\\n                   \\n                    ct1[i]++, ct1[j]--;\\n                    ct2[i]--, ct2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011938,
                "title": "easy-solution",
                "content": "# Approach\\n* Swap characters\\n  - Delete a character from word1 and add it to word2.\\n  - Delete a character from word2 and add it to word1.\\n  \\n- Check if the distinct count matches. If it matches, the answer will be true.\\n\\nNote: In the code, instead of actually swapping characters, we maintain two variables to keep track of the count of distinct elements. However, the idea remains the same.\\n\\n# Code\\n```\\n\\nvar isItPossible = function(word1, word2) {\\n    const f1 = countElements(word1);\\n    const f2 = countElements(word2);\\n\\n    for(let c1 of f1.keys()) {\\n        for(let c2 of f2.keys()) {\\n            let distinct1 = f1.size;\\n            let distinct2 = f2.size;\\n\\n            if(c1 !== c2) {\\n                // delete c1 from word1 and add to word2\\n                if (f1.get(c1) === 1) distinct1--;\\n                if(!f2.has(c1)) distinct2++;\\n\\n                // delete c2 from word2 and add to word1\\n                if(f2.get(c2) === 1) distinct2--;\\n                if(!f1.has(c2)) distinct1++\\n            }\\n\\n            if (distinct1 === distinct2) {\\n                return true;\\n            }\\n        }\\n    }\\n\\n    return false;\\n};\\n\\nfunction countElements(arr) {\\n    const counts = new Map();\\n\\n    for (const element of arr) {\\n        counts.set(element,  (counts.get(element) || 0) + 1);\\n    }\\n\\n    return counts;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar isItPossible = function(word1, word2) {\\n    const f1 = countElements(word1);\\n    const f2 = countElements(word2);\\n\\n    for(let c1 of f1.keys()) {\\n        for(let c2 of f2.keys()) {\\n            let distinct1 = f1.size;\\n            let distinct2 = f2.size;\\n\\n            if(c1 !== c2) {\\n                // delete c1 from word1 and add to word2\\n                if (f1.get(c1) === 1) distinct1--;\\n                if(!f2.has(c1)) distinct2++;\\n\\n                // delete c2 from word2 and add to word1\\n                if(f2.get(c2) === 1) distinct2--;\\n                if(!f1.has(c2)) distinct1++\\n            }\\n\\n            if (distinct1 === distinct2) {\\n                return true;\\n            }\\n        }\\n    }\\n\\n    return false;\\n};\\n\\nfunction countElements(arr) {\\n    const counts = new Map();\\n\\n    for (const element of arr) {\\n        counts.set(element,  (counts.get(element) || 0) + 1);\\n    }\\n\\n    return counts;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972243,
                "title": "golang-hash-table-solution",
                "content": "# Code\\n```go\\nfunc isItPossible(word1 string, word2 string) bool {\\n\\thash1, hash2 := make(map[rune]int), make(map[rune]int)\\n\\tfor _, w := range word1 {\\n\\t\\thash1[w]++\\n\\t}\\n\\tfor _, w := range word2 {\\n\\t\\thash2[w]++\\n\\t}\\n\\tfor k1 := range hash1 {\\n\\t\\tfor k2 := range hash2 {\\n\\t\\t\\thash1[k1]--\\n\\t\\t\\tif hash1[k1] == 0 {\\n\\t\\t\\t\\tdelete(hash1, k1)\\n\\t\\t\\t}\\n\\t\\t\\thash2[k2]--\\n\\t\\t\\tif hash2[k2] == 0 {\\n\\t\\t\\t\\tdelete(hash2, k2)\\n\\t\\t\\t}\\n\\t\\t\\thash1[k2]++\\n\\t\\t\\thash2[k1]++\\n\\t\\t\\tif len(hash1) == len(hash2) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\thash1[k2]--\\n\\t\\t\\tif hash1[k2] == 0 {\\n\\t\\t\\t\\tdelete(hash1, k2)\\n\\t\\t\\t}\\n\\t\\t\\thash2[k1]--\\n\\t\\t\\tif hash2[k1] == 0 {\\n\\t\\t\\t\\tdelete(hash2, k1)\\n\\t\\t\\t}\\n\\t\\t\\thash1[k1]++\\n\\t\\t\\thash2[k2]++\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```go\\nfunc isItPossible(word1 string, word2 string) bool {\\n\\thash1, hash2 := make(map[rune]int), make(map[rune]int)\\n\\tfor _, w := range word1 {\\n\\t\\thash1[w]++\\n\\t}\\n\\tfor _, w := range word2 {\\n\\t\\thash2[w]++\\n\\t}\\n\\tfor k1 := range hash1 {\\n\\t\\tfor k2 := range hash2 {\\n\\t\\t\\thash1[k1]--\\n\\t\\t\\tif hash1[k1] == 0 {\\n\\t\\t\\t\\tdelete(hash1, k1)\\n\\t\\t\\t}\\n\\t\\t\\thash2[k2]--\\n\\t\\t\\tif hash2[k2] == 0 {\\n\\t\\t\\t\\tdelete(hash2, k2)\\n\\t\\t\\t}\\n\\t\\t\\thash1[k2]++\\n\\t\\t\\thash2[k1]++\\n\\t\\t\\tif len(hash1) == len(hash2) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\thash1[k2]--\\n\\t\\t\\tif hash1[k2] == 0 {\\n\\t\\t\\t\\tdelete(hash1, k2)\\n\\t\\t\\t}\\n\\t\\t\\thash2[k1]--\\n\\t\\t\\tif hash2[k1] == 0 {\\n\\t\\t\\t\\tdelete(hash2, k1)\\n\\t\\t\\t}\\n\\t\\t\\thash1[k1]++\\n\\t\\t\\thash2[k2]++\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971600,
                "title": "easy-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int>v1(26,0),v2(26,0);\\n        int cnt1=0,cnt2=0;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n          v1[word1[i]-\\'a\\']++;\\n        }\\n         for(int i=0;i<word2.size();i++)\\n        {\\n          v2[word2[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n          if(v1[i]!=0)\\n          cnt1++;\\n          if(v2[i]!=0)\\n          cnt2++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n          for(int j=0;j<26;j++)\\n          {\\n              if(v1[i]!=0&&v2[j]!=0)\\n              {\\n                if(i==j)\\n                {\\n                  if(cnt1==cnt2)\\n                  return(true);\\n                  continue;\\n                }\\n                int x=0,y=0;\\n                if(v2[i]==0)\\n                y++;\\n                if(v2[j]==1)\\n                {\\n                  y--;\\n                }\\n                if(v1[i]==1)\\n                x--;\\n                if(v1[j]==0)\\n                x++;\\n                cout<<x<<\"  \"<<y<<endl;\\n                if((cnt1+x)==(cnt2+y))\\n                return(true);\\n              }\\n          }\\n        }\\n        return(false);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int>v1(26,0),v2(26,0);\\n        int cnt1=0,cnt2=0;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n          v1[word1[i]-\\'a\\']++;\\n        }\\n         for(int i=0;i<word2.size();i++)\\n        {\\n          v2[word2[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n          if(v1[i]!=0)\\n          cnt1++;\\n          if(v2[i]!=0)\\n          cnt2++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n          for(int j=0;j<26;j++)\\n          {\\n              if(v1[i]!=0&&v2[j]!=0)\\n              {\\n                if(i==j)\\n                {\\n                  if(cnt1==cnt2)\\n                  return(true);\\n                  continue;\\n                }\\n                int x=0,y=0;\\n                if(v2[i]==0)\\n                y++;\\n                if(v2[j]==1)\\n                {\\n                  y--;\\n                }\\n                if(v1[i]==1)\\n                x--;\\n                if(v1[j]==0)\\n                x++;\\n                cout<<x<<\"  \"<<y<<endl;\\n                if((cnt1+x)==(cnt2+y))\\n                return(true);\\n              }\\n          }\\n        }\\n        return(false);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3950526,
                "title": "python",
                "content": "Another sphagetti code but it works\\n# Code\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n\\n        alphabets = \\'abcdefghijklmnopqrstuvwxyz\\'\\n       \\n        f1, f2 = Counter(word1), Counter(word2)\\n        # if len(set(word1)) == len()\\n        for i in range(26):\\n            for j in range(26):\\n                if f1[alphabets[i]] >= 1 and f2[alphabets[j]]>=1:\\n                    f1[alphabets[i]] -= 1\\n                    f1[alphabets[j]] += 1\\n                    f2[alphabets[j]] -= 1\\n                    f2[alphabets[i]] += 1\\n                    \\n                    n1, n2 = sum(1 for x in f1.values() if x>=1), sum(1 for x in f2.values() if x>=1)\\n\\n                    if n1 == n2:\\n                        return True\\n                    f1[alphabets[i]] += 1\\n                    f1[alphabets[j]] -= 1\\n                    f2[alphabets[j]] += 1\\n                    f2[alphabets[i]] -= 1\\n\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n\\n        alphabets = \\'abcdefghijklmnopqrstuvwxyz\\'\\n       \\n        f1, f2 = Counter(word1), Counter(word2)\\n        # if len(set(word1)) == len()\\n        for i in range(26):\\n            for j in range(26):\\n                if f1[alphabets[i]] >= 1 and f2[alphabets[j]]>=1:\\n                    f1[alphabets[i]] -= 1\\n                    f1[alphabets[j]] += 1\\n                    f2[alphabets[j]] -= 1\\n                    f2[alphabets[i]] += 1\\n                    \\n                    n1, n2 = sum(1 for x in f1.values() if x>=1), sum(1 for x in f2.values() if x>=1)\\n\\n                    if n1 == n2:\\n                        return True\\n                    f1[alphabets[i]] += 1\\n                    f1[alphabets[j]] -= 1\\n                    f2[alphabets[j]] += 1\\n                    f2[alphabets[i]] -= 1\\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889470,
                "title": "code-with-comments-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(max(m,n) + 26*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26 + 26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        vector<int> f1(26);\\n        vector<int> f2(26);\\n        int d1=0,d2=0;\\n        // store in an array and count the unique chars of each word.\\n        for(int i=0;i<max(n,m);i++){\\n            if(i<n && ++f1[word1[i]-\\'a\\']==1)d1++;\\n            if(i<m && ++f2[word2[i]-\\'a\\']==1)d2++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(f1[i]==0)continue;\\n            if(--f1[i]==0)d1--;\\n            for(int j=0;j<26;j++)\\n            {\\n                if(f2[j]==0)continue;\\n                if(--f2[j]==0)d2--; // erase j from word2\\n                if(++f1[j]==1)d1++; // put j in word1\\n                if(++f2[i]==1)d2++; // put i in word2\\n                if(d1==d2)return true; // condition satisfied return true\\n                if(--f1[j]==0)d1--; // else\\n                if(--f2[i]==0)d2--; // swap the chars to original positions\\n                if(++f2[j]==1)d2++;\\n            }   \\n            if(++f1[i]==1)d1++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        vector<int> f1(26);\\n        vector<int> f2(26);\\n        int d1=0,d2=0;\\n        // store in an array and count the unique chars of each word.\\n        for(int i=0;i<max(n,m);i++){\\n            if(i<n && ++f1[word1[i]-\\'a\\']==1)d1++;\\n            if(i<m && ++f2[word2[i]-\\'a\\']==1)d2++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(f1[i]==0)continue;\\n            if(--f1[i]==0)d1--;\\n            for(int j=0;j<26;j++)\\n            {\\n                if(f2[j]==0)continue;\\n                if(--f2[j]==0)d2--; // erase j from word2\\n                if(++f1[j]==1)d1++; // put j in word1\\n                if(++f2[i]==1)d2++; // put i in word2\\n                if(d1==d2)return true; // condition satisfied return true\\n                if(--f1[j]==0)d1--; // else\\n                if(--f2[i]==0)d2--; // swap the chars to original positions\\n                if(++f2[j]==1)d2++;\\n            }   \\n            if(++f1[i]==1)d1++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781903,
                "title": "bruteforce",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    public $alphabet = [\\'q\\',\\'w\\', \\'e\\', \\'r\\', \\'t\\', \\'y\\', \\'u\\', \\'i\\', \\'o\\', \\'p\\', \\'a\\', \\'s\\', \\'d\\', \\'f\\', \\'g\\', \\'h\\', \\'j\\', \\'k\\', \\'l\\', \\'z\\', \\'x\\', \\'c\\', \\'v\\', \\'b\\', \\'n\\', \\'m\\'];\\n\\n    /**\\n     * @param String $word1\\n     * @param String $word2\\n     * @return Boolean\\n     */\\n    function isItPossible($word1, $word2) {\\n        for($i = 0; $i < 26; $i++) {\\n            $char1 = $this->alphabet[$i];\\n            $pos1 = strpos($word1, $char1);\\n            if($pos1 === false) {\\n                continue;\\n            }\\n\\n            for($j = 0; $j < 26; $j++) {\\n                $char2 = $this->alphabet[$j];\\n                $pos2 = strpos($word2, $char2);\\n                if($pos2 === false) {\\n                    continue;\\n                }\\n\\n                $r1 = substr_replace($word1, $char2, $pos1, 1);\\n                $r2 = substr_replace($word2, $char1, $pos2, 1);\\n\\n                if($this->distQ($r1) === $this->distQ($r2)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function distQ($word)\\n    {\\n        $cnt = 0;\\n        foreach($this->alphabet as $char) {\\n            $pos = strpos($word, $char);\\n            if($pos === false) {\\n                continue;\\n            }\\n            $cnt++;\\n        }\\n\\n        return $cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    public $alphabet = [\\'q\\',\\'w\\', \\'e\\', \\'r\\', \\'t\\', \\'y\\', \\'u\\', \\'i\\', \\'o\\', \\'p\\', \\'a\\', \\'s\\', \\'d\\', \\'f\\', \\'g\\', \\'h\\', \\'j\\', \\'k\\', \\'l\\', \\'z\\', \\'x\\', \\'c\\', \\'v\\', \\'b\\', \\'n\\', \\'m\\'];\\n\\n    /**\\n     * @param String $word1\\n     * @param String $word2\\n     * @return Boolean\\n     */\\n    function isItPossible($word1, $word2) {\\n        for($i = 0; $i < 26; $i++) {\\n            $char1 = $this->alphabet[$i];\\n            $pos1 = strpos($word1, $char1);\\n            if($pos1 === false) {\\n                continue;\\n            }\\n\\n            for($j = 0; $j < 26; $j++) {\\n                $char2 = $this->alphabet[$j];\\n                $pos2 = strpos($word2, $char2);\\n                if($pos2 === false) {\\n                    continue;\\n                }\\n\\n                $r1 = substr_replace($word1, $char2, $pos1, 1);\\n                $r2 = substr_replace($word2, $char1, $pos2, 1);\\n\\n                if($this->distQ($r1) === $this->distQ($r2)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function distQ($word)\\n    {\\n        $cnt = 0;\\n        foreach($this->alphabet as $char) {\\n            $pos = strpos($word, $char);\\n            if($pos === false) {\\n                continue;\\n            }\\n            $cnt++;\\n        }\\n\\n        return $cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777543,
                "title": "o-26-26-important-tip-inside",
                "content": "# Complexity\\n- Time complexity: $$O(26*26)$$ \\n\\n- Space complexity: $$O(m+n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> m1, m2;\\n        int n1 = word1.length(), n2 = word2.length();\\n        string letter = \"abcdefghijklmnopqrstuvwxyz\";\\n        for(auto it : word1) m1[it]++;\\n        for(auto it : word2) m2[it]++;\\n\\n        for(auto ch1 : letter)\\n         {\\n             for(auto ch2 : letter)\\n             { //TIP : use m.count(ch) instead of m[ch] in below condition\\n               //because m[ch] will insert new (key,value) pair as [ch,0] in m\\n              //if key = ch1 was not already present in m which in turn will unneccesarily affect m.size()\\n                 if(m1.count(ch1) > 0 && m2.count(ch2) > 0)\\n                 {\\n                    m1[ch1]--;  if(m1[ch1] == 0) m1.erase(ch1);\\n                    m2[ch2]--;  if(m2[ch2] == 0) m2.erase(ch2);\\n                    m1[ch2]++;\\n                    m2[ch1]++;\\n\\n                    if(m1.size() == m2.size()) return true;\\n\\n                    m1[ch2]--; if(m1[ch2] == 0) m1.erase(ch2);\\n                    m2[ch1]--; if(m2[ch1] == 0) m2.erase(ch1);\\n                    m1[ch1]++;\\n                    m2[ch2]++; \\n                 }\\n             }\\n         }\\n        return false;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> m1, m2;\\n        int n1 = word1.length(), n2 = word2.length();\\n        string letter = \"abcdefghijklmnopqrstuvwxyz\";\\n        for(auto it : word1) m1[it]++;\\n        for(auto it : word2) m2[it]++;\\n\\n        for(auto ch1 : letter)\\n         {\\n             for(auto ch2 : letter)\\n             { //TIP : use m.count(ch) instead of m[ch] in below condition\\n               //because m[ch] will insert new (key,value) pair as [ch,0] in m\\n              //if key = ch1 was not already present in m which in turn will unneccesarily affect m.size()\\n                 if(m1.count(ch1) > 0 && m2.count(ch2) > 0)\\n                 {\\n                    m1[ch1]--;  if(m1[ch1] == 0) m1.erase(ch1);\\n                    m2[ch2]--;  if(m2[ch2] == 0) m2.erase(ch2);\\n                    m1[ch2]++;\\n                    m2[ch1]++;\\n\\n                    if(m1.size() == m2.size()) return true;\\n\\n                    m1[ch2]--; if(m1[ch2] == 0) m1.erase(ch2);\\n                    m2[ch1]--; if(m2[ch1] == 0) m2.erase(ch1);\\n                    m1[ch1]++;\\n                    m2[ch2]++; \\n                 }\\n             }\\n         }\\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730704,
                "title": "easy-java-solution-intuitive-solution-upvote",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] arr1 = new int[26];\\n        int[] arr2 = new int[26];\\n\\n        for(int i = 0; i < word1.length(); i++){\\n            arr1[word1.charAt(i) - \\'a\\']++;\\n        }\\n\\n        \\n        for(int i = 0; i < word2.length(); i++){\\n            arr2[word2.charAt(i) - \\'a\\']++;\\n        }\\n\\n        for(int i = 0; i < 26; i++){\\n            for(int j = 0; j < 26; j++){\\n                if(arr1[i] > 0 && arr2[j] > 0){\\n                    arr1[j]++;\\n                    arr1[i]--;\\n                    arr2[i]++;\\n                    arr2[j]--;\\n\\n                    int t1 = 0;\\n                    int t2 = 0;\\n\\n                    for(int k = 0; k < 26; k++){\\n                        if(arr1[k] != 0){                                \\n                            if(arr1[k] > 0)\\n                            t1++;\\n                        }\\n                        if(arr2[k] != 0){\\n                            if(arr2[k] > 0)\\n                            t2++;\\n                        }\\n                        \\n                    }\\n\\n                    if(t1 == t2) return true;\\n                    arr1[j]--;\\n                    arr1[i]++;\\n                    arr2[i]--;\\n                    arr2[j]++;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] arr1 = new int[26];\\n        int[] arr2 = new int[26];\\n\\n        for(int i = 0; i < word1.length(); i++){\\n            arr1[word1.charAt(i) - \\'a\\']++;\\n        }\\n\\n        \\n        for(int i = 0; i < word2.length(); i++){\\n            arr2[word2.charAt(i) - \\'a\\']++;\\n        }\\n\\n        for(int i = 0; i < 26; i++){\\n            for(int j = 0; j < 26; j++){\\n                if(arr1[i] > 0 && arr2[j] > 0){\\n                    arr1[j]++;\\n                    arr1[i]--;\\n                    arr2[i]++;\\n                    arr2[j]--;\\n\\n                    int t1 = 0;\\n                    int t2 = 0;\\n\\n                    for(int k = 0; k < 26; k++){\\n                        if(arr1[k] != 0){                                \\n                            if(arr1[k] > 0)\\n                            t1++;\\n                        }\\n                        if(arr2[k] != 0){\\n                            if(arr2[k] > 0)\\n                            t2++;\\n                        }\\n                        \\n                    }\\n\\n                    if(t1 == t2) return true;\\n                    arr1[j]--;\\n                    arr1[i]++;\\n                    arr2[i]--;\\n                    arr2[j]++;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717973,
                "title": "the-most-tricky-question-on-leetcode-solved-easily",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n    map<char,int> m1,m2;\\n    for(int i=0;i<word1.length();i++) m1[word1[i]]++;\\n    for(int j=0;j<word2.length();j++) m2[word2[j]]++;\\n    map<char,int>::iterator it1,it2;\\n    it1=m1.begin();\\n    while(it1!=m1.end()){\\n        it2=m2.begin();\\n        while(it2!=m2.end()){\\n            char a=it1->first,b=it2->first;\\n            m1[a]--; m2[b]--;\\n            m1[b]++; m2[a]++;\\n            int l=m1.size(),m=m2.size();\\n            if(m1[a]==0) l--;\\n            if(m2[b]==0) m--;\\n            if(l==m) return true;\\n            m1[a]++; m2[b]++;\\n            m1[b]--; m2[a]--;  \\n             if(m1[b]==0) m1.erase(b);\\n            if(m2[a]==0) m2.erase(a);\\n            it2++;\\n        }\\n        it1++;\\n    }\\n    return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n    map<char,int> m1,m2;\\n    for(int i=0;i<word1.length();i++) m1[word1[i]]++;\\n    for(int j=0;j<word2.length();j++) m2[word2[j]]++;\\n    map<char,int>::iterator it1,it2;\\n    it1=m1.begin();\\n    while(it1!=m1.end()){\\n        it2=m2.begin();\\n        while(it2!=m2.end()){\\n            char a=it1->first,b=it2->first;\\n            m1[a]--; m2[b]--;\\n            m1[b]++; m2[a]++;\\n            int l=m1.size(),m=m2.size();\\n            if(m1[a]==0) l--;\\n            if(m2[b]==0) m--;\\n            if(l==m) return true;\\n            m1[a]++; m2[b]++;\\n            m1[b]--; m2[a]--;  \\n             if(m1[b]==0) m1.erase(b);\\n            if(m2[a]==0) m2.erase(a);\\n            it2++;\\n        }\\n        it1++;\\n    }\\n    return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717240,
                "title": "c-simple-observation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possible(char key1, char key2, map<char, int> &cnt1, map<char, int> &cnt2) {\\n        if (key1 == key2) {\\n            return cnt1.size() == cnt2.size();\\n        }\\n        return (cnt1.size() + (cnt1.count(key2) == 0) - (cnt1[key1] == 1)) == (cnt2.size() + (cnt2.count(key1) == 0) - (cnt2[key2] == 1));\\n    }\\n    \\n    bool isItPossible(string word1, string word2) {\\n        map<char, int> cnt1, cnt2;\\n        for (char ch : word1) {\\n            cnt1[ch]++;\\n        }\\n        for (char ch : word2) {\\n            cnt2[ch]++;\\n        }\\n        \\n        for (auto [key1, val1] : cnt1) {\\n            for (auto [key2, val2] : cnt2) {\\n                if (possible(key1, key2, cnt1, cnt2)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(char key1, char key2, map<char, int> &cnt1, map<char, int> &cnt2) {\\n        if (key1 == key2) {\\n            return cnt1.size() == cnt2.size();\\n        }\\n        return (cnt1.size() + (cnt1.count(key2) == 0) - (cnt1[key1] == 1)) == (cnt2.size() + (cnt2.count(key1) == 0) - (cnt2[key2] == 1));\\n    }\\n    \\n    bool isItPossible(string word1, string word2) {\\n        map<char, int> cnt1, cnt2;\\n        for (char ch : word1) {\\n            cnt1[ch]++;\\n        }\\n        for (char ch : word2) {\\n            cnt2[ch]++;\\n        }\\n        \\n        for (auto [key1, val1] : cnt1) {\\n            for (auto [key2, val2] : cnt2) {\\n                if (possible(key1, key2, cnt1, cnt2)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716671,
                "title": "simple-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        \\n        int n = word1.size();\\n        map<char,int>freq1;\\n        for(int i = 0; i < n; i++) {\\n            freq1[word1[i]]++;\\n        }\\n\\n        int m = word2.size();\\n        map<char,int>freq2;\\n        for(int i = 0; i < m ; i++) {\\n            freq2[word2[i]]++;\\n        }\\n\\n\\n        for(char i = \\'a\\'; i <= \\'z\\'; i++) {\\n            for(char j = \\'a\\'; j <= \\'z\\'; j++) {\\n\\n                if(freq1.find(i) != freq1.end() && freq2.find(j) != freq2.end()) {\\n                \\n                    freq1[i]--;\\n                    if(freq1[i] == 0) freq1.erase(i);\\n                    freq2[i]++;\\n\\n                    freq2[j]--;\\n                    if(freq2[j] == 0) freq2.erase(j);\\n                    freq1[j]++;\\n\\n\\n                    if(freq1.size() == freq2.size()) return true;\\n\\n\\n                    freq1[j]--;\\n                    if(freq1[j] == 0) freq1.erase(j);\\n                    freq1[i]++;\\n\\n                    freq2[i]--;\\n                    if(freq2[i] == 0) freq2.erase(i);\\n                    freq2[j]++;\\n\\n\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        \\n        int n = word1.size();\\n        map<char,int>freq1;\\n        for(int i = 0; i < n; i++) {\\n            freq1[word1[i]]++;\\n        }\\n\\n        int m = word2.size();\\n        map<char,int>freq2;\\n        for(int i = 0; i < m ; i++) {\\n            freq2[word2[i]]++;\\n        }\\n\\n\\n        for(char i = \\'a\\'; i <= \\'z\\'; i++) {\\n            for(char j = \\'a\\'; j <= \\'z\\'; j++) {\\n\\n                if(freq1.find(i) != freq1.end() && freq2.find(j) != freq2.end()) {\\n                \\n                    freq1[i]--;\\n                    if(freq1[i] == 0) freq1.erase(i);\\n                    freq2[i]++;\\n\\n                    freq2[j]--;\\n                    if(freq2[j] == 0) freq2.erase(j);\\n                    freq1[j]++;\\n\\n\\n                    if(freq1.size() == freq2.size()) return true;\\n\\n\\n                    freq1[j]--;\\n                    if(freq1[j] == 0) freq1.erase(j);\\n                    freq1[i]++;\\n\\n                    freq2[i]--;\\n                    if(freq2[i] == 0) freq2.erase(i);\\n                    freq2[j]++;\\n\\n\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711649,
                "title": "java-array-frequencies-count-commented-for-better-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n\\n        int[] word1Freq = new int[26];\\n        int[] word2Freq = new int[26];\\n\\n        int distinctChrsWord1 = 0;\\n        int distinctChrsWord2 = 0;\\n\\n        for (char chr : word1.toCharArray()) {\\n\\n            word1Freq[chr - \\'a\\']++;\\n            //if a new char counted as 1, will increase a distinct chars\\n            if (word1Freq[chr - \\'a\\'] == 1) {\\n                distinctChrsWord1++;\\n            }\\n        }\\n\\n        for (char chr : word2.toCharArray()) {\\n\\n            word2Freq[chr - \\'a\\']++;\\n            //if a new char counted as 1, will increase a distinct chars\\n            if (word2Freq[chr - \\'a\\'] == 1) {\\n                distinctChrsWord2++;\\n            }\\n        }\\n\\n        //char \\'chi\\' represents chars in word1\\n        for (char chi = \\'a\\'; chi <= \\'z\\'; chi++) {\\n\\n            //if char \\'chi\\' doesn\\'t exists in word1\\n            if (word1Freq[chi - \\'a\\'] == 0) {\\n                continue;\\n            }\\n\\n            //char \\'chj\\' represents chars in word2\\n            for (char chj = \\'a\\'; chj <= \\'z\\'; chj++) {\\n\\n                //if char \\'chj\\' doesn\\'t exists in word2\\n                if (word2Freq[chj - \\'a\\'] == 0) {\\n                    continue;\\n                }\\n\\n                //word1[...\\'chi\\'...] swap word2[...\\'chj\\'...]\\n                //swaps oprns include:\\n                //1. add chj to word1 & check if need to incr distinct char count\\n                //for word1\\n                //2. remove chi from from word1 & check if need to decr distinct\\n                //char count for word1\\n                //3. add chi to word2 & check if need to incr distinct char count\\n                //for word2\\n                //4. remove chj from from word2 & check if need to decr distinct\\n                //char count for word2\\n                //1............\\n                //swap char chj from word2 to word1 so now word1 will have \\'chj\\'\\n                word1Freq[chj - \\'a\\']++;\\n                //if this \\'chj\\' is new distinct char added to word1, then incr\\n                //distinct char word1 count\\n                if (word1Freq[chj - \\'a\\'] == 1) {\\n                    distinctChrsWord1++;\\n                }\\n\\n                //2............\\n                //also swap \\'chi\\' from word1 to word2 so now word1 will not have \\'chi\\'\\n                word1Freq[chi - \\'a\\']--;\\n                //if this \\'chi\\' was a distinct char earlier,\\n                //then after decr this \\'chi\\' if this distinct char from word1 freq is 0\\n                //means word1 lost an existing distinct char \\n                if (word1Freq[chi - \\'a\\'] == 0) {\\n                    distinctChrsWord1--;\\n                }\\n\\n                //3............\\n                //swap char chi from word1 to word2 so now word2 will have \\'chi\\'\\n                word2Freq[chi - \\'a\\']++;\\n                //if this \\'chi\\' is new distinct char added to word2,\\n                //then incr distinct char word2 count\\n                if (word2Freq[chi - \\'a\\'] == 1) {\\n                    distinctChrsWord2++;\\n                }\\n\\n                //4............\\n                //also swap \\'chj\\' from word2 to word1 so now word2 will not have \\'chj\\'\\n                word2Freq[chj - \\'a\\']--;\\n                //if this \\'chj\\' was a distinct char earlier,\\n                //then after decr this \\'chj\\' if this distinct char from word2 freq is 0\\n                //means word2 lost an existing distinct char \\n                if (word2Freq[chj - \\'a\\'] == 0) {\\n                    distinctChrsWord2--;\\n                }\\n\\n                //since we are allowed to have \\'exactly one move\\' so in any 1 move\\n                //possible, if the distinct chars of both word1 & word2 are equal\\n                //then return true right away\\n                if (distinctChrsWord1 == distinctChrsWord2) {\\n                    return true;\\n                }\\n\\n                //reverting the swap move done above\\n                word1Freq[chi - \\'a\\']++;\\n                if (word1Freq[chi - \\'a\\'] == 1) {\\n                    distinctChrsWord1++;\\n                }\\n                \\n                word1Freq[chj - \\'a\\']--;\\n                if (word1Freq[chj - \\'a\\'] == 0) {\\n                    distinctChrsWord1--;\\n                }\\n\\n                word2Freq[chj - \\'a\\']++;\\n                if (word2Freq[chj - \\'a\\'] == 1) {\\n                    distinctChrsWord2++;\\n                }\\n                \\n                word2Freq[chi - \\'a\\']--;\\n                if (word2Freq[chi - \\'a\\'] == 0) {\\n                    distinctChrsWord2--;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n\\n        int[] word1Freq = new int[26];\\n        int[] word2Freq = new int[26];\\n\\n        int distinctChrsWord1 = 0;\\n        int distinctChrsWord2 = 0;\\n\\n        for (char chr : word1.toCharArray()) {\\n\\n            word1Freq[chr - \\'a\\']++;\\n            //if a new char counted as 1, will increase a distinct chars\\n            if (word1Freq[chr - \\'a\\'] == 1) {\\n                distinctChrsWord1++;\\n            }\\n        }\\n\\n        for (char chr : word2.toCharArray()) {\\n\\n            word2Freq[chr - \\'a\\']++;\\n            //if a new char counted as 1, will increase a distinct chars\\n            if (word2Freq[chr - \\'a\\'] == 1) {\\n                distinctChrsWord2++;\\n            }\\n        }\\n\\n        //char \\'chi\\' represents chars in word1\\n        for (char chi = \\'a\\'; chi <= \\'z\\'; chi++) {\\n\\n            //if char \\'chi\\' doesn\\'t exists in word1\\n            if (word1Freq[chi - \\'a\\'] == 0) {\\n                continue;\\n            }\\n\\n            //char \\'chj\\' represents chars in word2\\n            for (char chj = \\'a\\'; chj <= \\'z\\'; chj++) {\\n\\n                //if char \\'chj\\' doesn\\'t exists in word2\\n                if (word2Freq[chj - \\'a\\'] == 0) {\\n                    continue;\\n                }\\n\\n                //word1[...\\'chi\\'...] swap word2[...\\'chj\\'...]\\n                //swaps oprns include:\\n                //1. add chj to word1 & check if need to incr distinct char count\\n                //for word1\\n                //2. remove chi from from word1 & check if need to decr distinct\\n                //char count for word1\\n                //3. add chi to word2 & check if need to incr distinct char count\\n                //for word2\\n                //4. remove chj from from word2 & check if need to decr distinct\\n                //char count for word2\\n                //1............\\n                //swap char chj from word2 to word1 so now word1 will have \\'chj\\'\\n                word1Freq[chj - \\'a\\']++;\\n                //if this \\'chj\\' is new distinct char added to word1, then incr\\n                //distinct char word1 count\\n                if (word1Freq[chj - \\'a\\'] == 1) {\\n                    distinctChrsWord1++;\\n                }\\n\\n                //2............\\n                //also swap \\'chi\\' from word1 to word2 so now word1 will not have \\'chi\\'\\n                word1Freq[chi - \\'a\\']--;\\n                //if this \\'chi\\' was a distinct char earlier,\\n                //then after decr this \\'chi\\' if this distinct char from word1 freq is 0\\n                //means word1 lost an existing distinct char \\n                if (word1Freq[chi - \\'a\\'] == 0) {\\n                    distinctChrsWord1--;\\n                }\\n\\n                //3............\\n                //swap char chi from word1 to word2 so now word2 will have \\'chi\\'\\n                word2Freq[chi - \\'a\\']++;\\n                //if this \\'chi\\' is new distinct char added to word2,\\n                //then incr distinct char word2 count\\n                if (word2Freq[chi - \\'a\\'] == 1) {\\n                    distinctChrsWord2++;\\n                }\\n\\n                //4............\\n                //also swap \\'chj\\' from word2 to word1 so now word2 will not have \\'chj\\'\\n                word2Freq[chj - \\'a\\']--;\\n                //if this \\'chj\\' was a distinct char earlier,\\n                //then after decr this \\'chj\\' if this distinct char from word2 freq is 0\\n                //means word2 lost an existing distinct char \\n                if (word2Freq[chj - \\'a\\'] == 0) {\\n                    distinctChrsWord2--;\\n                }\\n\\n                //since we are allowed to have \\'exactly one move\\' so in any 1 move\\n                //possible, if the distinct chars of both word1 & word2 are equal\\n                //then return true right away\\n                if (distinctChrsWord1 == distinctChrsWord2) {\\n                    return true;\\n                }\\n\\n                //reverting the swap move done above\\n                word1Freq[chi - \\'a\\']++;\\n                if (word1Freq[chi - \\'a\\'] == 1) {\\n                    distinctChrsWord1++;\\n                }\\n                \\n                word1Freq[chj - \\'a\\']--;\\n                if (word1Freq[chj - \\'a\\'] == 0) {\\n                    distinctChrsWord1--;\\n                }\\n\\n                word2Freq[chj - \\'a\\']++;\\n                if (word2Freq[chj - \\'a\\'] == 1) {\\n                    distinctChrsWord2++;\\n                }\\n                \\n                word2Freq[chi - \\'a\\']--;\\n                if (word2Freq[chi - \\'a\\'] == 0) {\\n                    distinctChrsWord2--;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560101,
                "title": "alternative-o-n-m-rules-based-solution-without-brute-force",
                "content": "The time complexity of other leading solutions to this problem is `O(n + m + c^2)` where `c` is the size of the character set. The character set is constant in this problem, so this simplifies to `O(n + m)`, which is optimal.\\n\\n**However:** what if we tweaked the constraints of the problem so that it deals with a larger character set, such as Unicode (~150K chars)? Although `c^2` is still constant, it\\'s now a _very large_ constant, and definitely the bottleneck, since each string is no more than 10K characters long. The solution I am presenting eliminates `c^2` so that the algorithm will remain `O(n + m)` even with character sets of arbitrary size.\\n\\nIt\\'s important to note that this problem tweak and corresponding solution are hypothetical, and that it\\'s usually unwise to optimize for hypothetical situations. The \"brute force\" approach should perform better for this particular problem in terms of absolute runtime performance, as I will demonstrate.\\n\\n# Intuition\\n\\nFor each string, map each character to the number of times it appears in the string. Call these maps `m1` and `m2`, ensuring that `m1` has at least as many keys as `m2`.\\n\\nDepending on the difference between the map sizes (`m1.size - m2.size`), we can use different rules to determine whether it is possible to level out the character counts with a single swap.\\n\\n# Approach\\n\\nGiven the two maps, `m1` and `m2`, and given that `m1.size >= m2.size`, let `s1` and `s2` be the strings corresponsing respectively with the two maps. All of these examples list `s1` first for clarity, but note that the two strings inputs may come in any order.\\n\\n## Maps of Equal Size\\n\\nIf the two strings share at least one character, you can simply swap a shared character. Both of the strings will remain the same, and they will be balanced.\\n\\nExample: `\"ab\", \"ac\"`:\\n=> swap `a` with `a`\\n\\nIn the same example, it is also possible to balance the strings by swapping letters that only appear once and only in one string each:\\n\\n=> swap `b` with `c`\\n\\nIn some cases, we can balance the strings by having each string \"share\" a character that it has more than one of, and that the other string does not have at all:\\n\\nExample: `\"aa\", \"bb\"`:\\n=> swap `a` with `b`\\n\\n## Difference of 1\\n\\nThis case is by far the most challenging to solve. Kudos to you if you can think of all the edge cases that Leetcode tests for (it took me 8 tries).\\n\\nFirst, we could swap a character that appears exactly once in `s1` that that is absent from `s2` with a character that is present more than once in `s2` and absent from `s1`:\\n\\nExample: `\"bcd\", \"aab\"`\\n=> swap `d` with `a`\\n\\nWe could also swap a character that is present exactly once in `s1` and not at all in `s2` with a character that is present exactly once in `s2` and at least once in `s1`:\\n\\nExample: `\"ab\", \"a\"`\\n=> swap `b` with `a`\\n\\nOr, we could swap a character that appears more than once in `s1` and not at all in `s2` with a character that appears more than once in `s2` and at least once in `s1`:\\n\\nExample: `\"aabc\", \"ccd\"`\\n=> swap `a` with `c`\\n\\nFinally, we could swap a character that appears exactly once in `s1` and at least once in `s2` with a character that appears more than once in `s2` and at least once in `s1`:\\n\\nExample: `\"bcdf\", \"addff\"`\\n=> swap `d` (in the first string) with `f`\\n\\nDon\\'t overlook this particularly ghoulish edge case: if the character we choose to swap is _the same character in both strings_, then the swap will not work because it won\\'t change anything! This edge case hasn\\'t mattered yet because in all of the \"equal maps\" cases, it\\'s okay if the strings stay the same, and in all of the other examples in this section, at least one character must be absent from at least one of the strings, making this case impossible.\\n\\n## Difference of 2:\\n\\nYou can balance the two strings if, and only if, it is possible to swap a character present exactly once in `s1` (and absent from `s2`) with a character that is present more than once in `s2` (and at least once in `s1`):\\n\\nExample: `\"abc\", \"bb\"`\\n=> swap `a` (or `c`) with `b`\\n\\n## Difference of 3 or more:\\n\\nIt is not possible to balance the strings in this case, because you cannot reduce the unique character count of `s1` by more than one, nor can you increase that of `s2` by more than one.\\n\\n# Time complexity:\\n\\nLet `m` and `n` be the lengths of the two strings in any order. In the least performant case, we will end up iterating through both `m1` and `m2` a constant number of times: once each to create the character map, and once again to check each case listed. `O(2 * (n + m))` simplifies to `O(n + m)`.\\n\\nThis is not better than the brute force solution in the worst case scenario presented by the problem, even though it is represented the same way in terms of Big O: \\n\\n**Brute Force:** `O(n + m + 26^2)` = `10^5 + 10^5 + 26^2` = `200_676`\\n**Alternative:** `O(2 * (n + m))` = `2 * (10^5 + 10^5)` = `400_000`\\n\\nThe leading Ruby solution took 420ms whereas mine took 989ms. That\\'s roughly double, and on par with what I would expect given my analysis above.\\n\\n# Space complexity:\\n\\nIn the hypothetical case this solution addresses, where we make no guarantees about the size of the character set, the solution consumes `O(n + m)` space (the two char-count maps). However, since the size of the English alphabet is constant, the maps under the constraints of the original problem will never exceed size 26, making the in-practice space complexity `O(1)`, which is the same as that of the \"brute force\" solution.\\n\\n# Code\\n\\n```\\ndef is_it_possible(w1, w2)\\n    m1 = char_map(w1)\\n    m2 = char_map(w2)\\n\\n    # switch m1/m2 variables if needed to ensure that m1.size >= m2.size\\n    m1, m2 = m1.size > m2.size ? [m1, m2] : [m2, m1]\\n\\n    case m1.size - m2.size\\n    when 0 then can_swap_0?(m1, m2)\\n    when 1 then can_swap_1?(m1, m2)\\n    when 2 then can_swap_2?(m1, m2)\\n    else\\n        false\\n    end\\nend\\n\\ndef can_swap_0?(m1, m2)\\n    exactly1_in_m1_none_in_m2 = false\\n    exactly1_in_m2_none_in_m1 = false\\n\\n    morethan1_in_m1_none_in_m2 = false\\n    morethan1_in_m2_none_in_m1 = false\\n\\n    # nit: loop through m2 first because it\\'s smaller and might have early return\\n    m2.each do |char, count|\\n        return true if m1[char]\\n        \\n        if count == 1\\n            exactly1_in_m2_none_in_m1 = true if m1[char].nil?\\n        elsif count > 1\\n            morethan1_in_m2_none_in_m1 = true if m1[char].nil?\\n        end\\n    end\\n\\n    m1.each do |char, count|\\n        if count == 1\\n            exactly1_in_m1_none_in_m2 = true if m2[char].nil?\\n        elsif count > 1\\n            morethan1_in_m1_none_in_m2 = true if m2[char].nil?\\n        end\\n    end\\n\\n    (exactly1_in_m1_none_in_m2 && exactly1_in_m2_none_in_m1) ||\\n        (morethan1_in_m1_none_in_m2 && morethan1_in_m2_none_in_m1)\\nend\\n\\ndef can_swap_1?(m1, m2)\\n    exactly1_in_m1_none_in_m2 = false\\n    morethan1_in_m2_none_in_m1 = false\\n\\n    exactly1_in_m2_atleast1_in_m1 = false\\n\\n    morethan1_in_m1_none_in_m2 = false\\n    # morethan1_in_m2_atleast1_in_m1 = false\\n\\n    # candidates array rather than flag because we have to make sure we\\n    # aren\\'t swapping the same char from both strings in this edge case\\n    # (no need to store more than 2 in each array)\\n    exactly1_in_m1_atleast1_in_m2_candidates = []\\n    morethan1_in_m2_atleast1_in_m1_candidates = []\\n\\n    m1.each do |char, count|\\n        if count == 1\\n            exactly1_in_m1_none_in_m2 = true if m2[char].nil?\\n\\n            if exactly1_in_m1_atleast1_in_m2_candidates.size < 2\\n                exactly1_in_m1_atleast1_in_m2_candidates << char if m2[char]&.>=(1)\\n            end\\n        elsif count > 1\\n            morethan1_in_m1_none_in_m2 = true if m2[char].nil?\\n        end\\n    end\\n\\n    m2.each do |char, count|\\n        if count == 1\\n            exactly1_in_m2_atleast1_in_m1 = true if m1[char]&.>=(1)\\n        elsif count > 1\\n            morethan1_in_m2_none_in_m1 = true if m1[char].nil?\\n\\n            if morethan1_in_m2_atleast1_in_m1_candidates.size < 2\\n                morethan1_in_m2_atleast1_in_m1_candidates << char if m1[char]&.>=(1)\\n            end\\n        end\\n    end\\n\\n    return true if (exactly1_in_m1_none_in_m2 && morethan1_in_m2_none_in_m1) || \\n        (exactly1_in_m1_none_in_m2 && exactly1_in_m2_atleast1_in_m1) ||\\n        (morethan1_in_m1_none_in_m2 && morethan1_in_m2_atleast1_in_m1_candidates.any?)\\n\\n    cands1 = exactly1_in_m1_atleast1_in_m2_candidates\\n    cands2 = morethan1_in_m2_atleast1_in_m1_candidates\\n\\n    if cands1.size == 1 && cands1.size == cands2.size\\n        return cands1[0] != cands2[0]\\n    end\\n\\n    cands1.any? && cands2.any?\\nend\\n\\ndef can_swap_2?(m1, m2)\\n    m1.any? { |char, count| count == 1 && m2[char].nil? } &&\\n        m2.any? { |char, count| count >= 2 && m1[char] }\\nend\\n\\ndef char_map(str)\\n    map = Hash.new\\n\\n    i = 0\\n    until i == str.length\\n        map[str[i]] ||= 0\\n        map[str[i]] += 1\\n        i += 1\\n    end\\n\\n    map\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef is_it_possible(w1, w2)\\n    m1 = char_map(w1)\\n    m2 = char_map(w2)\\n\\n    # switch m1/m2 variables if needed to ensure that m1.size >= m2.size\\n    m1, m2 = m1.size > m2.size ? [m1, m2] : [m2, m1]\\n\\n    case m1.size - m2.size\\n    when 0 then can_swap_0?(m1, m2)\\n    when 1 then can_swap_1?(m1, m2)\\n    when 2 then can_swap_2?(m1, m2)\\n    else\\n        false\\n    end\\nend\\n\\ndef can_swap_0?(m1, m2)\\n    exactly1_in_m1_none_in_m2 = false\\n    exactly1_in_m2_none_in_m1 = false\\n\\n    morethan1_in_m1_none_in_m2 = false\\n    morethan1_in_m2_none_in_m1 = false\\n\\n    # nit: loop through m2 first because it\\'s smaller and might have early return\\n    m2.each do |char, count|\\n        return true if m1[char]\\n        \\n        if count == 1\\n            exactly1_in_m2_none_in_m1 = true if m1[char].nil?\\n        elsif count > 1\\n            morethan1_in_m2_none_in_m1 = true if m1[char].nil?\\n        end\\n    end\\n\\n    m1.each do |char, count|\\n        if count == 1\\n            exactly1_in_m1_none_in_m2 = true if m2[char].nil?\\n        elsif count > 1\\n            morethan1_in_m1_none_in_m2 = true if m2[char].nil?\\n        end\\n    end\\n\\n    (exactly1_in_m1_none_in_m2 && exactly1_in_m2_none_in_m1) ||\\n        (morethan1_in_m1_none_in_m2 && morethan1_in_m2_none_in_m1)\\nend\\n\\ndef can_swap_1?(m1, m2)\\n    exactly1_in_m1_none_in_m2 = false\\n    morethan1_in_m2_none_in_m1 = false\\n\\n    exactly1_in_m2_atleast1_in_m1 = false\\n\\n    morethan1_in_m1_none_in_m2 = false\\n    # morethan1_in_m2_atleast1_in_m1 = false\\n\\n    # candidates array rather than flag because we have to make sure we\\n    # aren\\'t swapping the same char from both strings in this edge case\\n    # (no need to store more than 2 in each array)\\n    exactly1_in_m1_atleast1_in_m2_candidates = []\\n    morethan1_in_m2_atleast1_in_m1_candidates = []\\n\\n    m1.each do |char, count|\\n        if count == 1\\n            exactly1_in_m1_none_in_m2 = true if m2[char].nil?\\n\\n            if exactly1_in_m1_atleast1_in_m2_candidates.size < 2\\n                exactly1_in_m1_atleast1_in_m2_candidates << char if m2[char]&.>=(1)\\n            end\\n        elsif count > 1\\n            morethan1_in_m1_none_in_m2 = true if m2[char].nil?\\n        end\\n    end\\n\\n    m2.each do |char, count|\\n        if count == 1\\n            exactly1_in_m2_atleast1_in_m1 = true if m1[char]&.>=(1)\\n        elsif count > 1\\n            morethan1_in_m2_none_in_m1 = true if m1[char].nil?\\n\\n            if morethan1_in_m2_atleast1_in_m1_candidates.size < 2\\n                morethan1_in_m2_atleast1_in_m1_candidates << char if m1[char]&.>=(1)\\n            end\\n        end\\n    end\\n\\n    return true if (exactly1_in_m1_none_in_m2 && morethan1_in_m2_none_in_m1) || \\n        (exactly1_in_m1_none_in_m2 && exactly1_in_m2_atleast1_in_m1) ||\\n        (morethan1_in_m1_none_in_m2 && morethan1_in_m2_atleast1_in_m1_candidates.any?)\\n\\n    cands1 = exactly1_in_m1_atleast1_in_m2_candidates\\n    cands2 = morethan1_in_m2_atleast1_in_m1_candidates\\n\\n    if cands1.size == 1 && cands1.size == cands2.size\\n        return cands1[0] != cands2[0]\\n    end\\n\\n    cands1.any? && cands2.any?\\nend\\n\\ndef can_swap_2?(m1, m2)\\n    m1.any? { |char, count| count == 1 && m2[char].nil? } &&\\n        m2.any? { |char, count| count >= 2 && m1[char] }\\nend\\n\\ndef char_map(str)\\n    map = Hash.new\\n\\n    i = 0\\n    until i == str.length\\n        map[str[i]] ||= 0\\n        map[str[i]] += 1\\n        i += 1\\n    end\\n\\n    map\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3482576,
                "title": "java-o-m-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we need to track the distinct character, we should build a map(buckets) of the word. Try to exchange \\'a\\' to \\'z\\' from word1 to word2, we have to jump when buckets[i] equals 0. If i == j, there is no count change.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n + 25 * 26)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] b1 = getBuckets(word1);\\n        int[] b2 = getBuckets(word2);\\n        return helper(b1, b2);\\n    }\\n    \\n    public boolean helper(int[] buckets1, int[] buckets2){        \\n        if(buckets1[26] < buckets2[26]) return helper(buckets2, buckets1);\\n        int diff = buckets1[26] - buckets2[26];\\n        if(diff > 2) return false;\\n        for(int i = 0; i < 26; ++i){\\n            if(buckets1[i] == 0) continue;\\n            for(int j = 0; j < 26; ++j){\\n                if(buckets2[j] == 0) continue;\\n                if(i == j && diff == 0) return true;\\n                if(i == j) continue;\\n                int d = 0;\\n                if(buckets1[i] - 1 == 0) ++d;\\n                if(buckets1[j] + 1 == 1) --d;\\n                if(buckets2[i] + 1 == 1) ++d;\\n                if(buckets2[j] - 1 == 0) --d;\\n                if(d == diff) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int[] getBuckets(String word){\\n        int[] res = new int[27];\\n        for(char c: word.toCharArray()){\\n            res[c - \\'a\\']++;\\n            if(res[c - \\'a\\'] == 1)\\n                res[26]++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] b1 = getBuckets(word1);\\n        int[] b2 = getBuckets(word2);\\n        return helper(b1, b2);\\n    }\\n    \\n    public boolean helper(int[] buckets1, int[] buckets2){        \\n        if(buckets1[26] < buckets2[26]) return helper(buckets2, buckets1);\\n        int diff = buckets1[26] - buckets2[26];\\n        if(diff > 2) return false;\\n        for(int i = 0; i < 26; ++i){\\n            if(buckets1[i] == 0) continue;\\n            for(int j = 0; j < 26; ++j){\\n                if(buckets2[j] == 0) continue;\\n                if(i == j && diff == 0) return true;\\n                if(i == j) continue;\\n                int d = 0;\\n                if(buckets1[i] - 1 == 0) ++d;\\n                if(buckets1[j] + 1 == 1) --d;\\n                if(buckets2[i] + 1 == 1) ++d;\\n                if(buckets2[j] - 1 == 0) --d;\\n                if(d == diff) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int[] getBuckets(String word){\\n        int[] res = new int[27];\\n        for(char c: word.toCharArray()){\\n            res[c - \\'a\\']++;\\n            if(res[c - \\'a\\'] == 1)\\n                res[26]++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455441,
                "title": "python-counter-easy-solution",
                "content": "# Approach\\nUse counter to store char frequency for word1 and word2, then swap  all possible pairs of char between word1 and word2 and update their length of distinct characters respectively. \\n\\nBe aware of when swapping the same char, the length won\\'t change.\\n \\n\\n# Code\\n```\\nclass Solution(object):\\n    def isItPossible(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: bool\\n        \"\"\"\\n        a,b = Counter(word1),Counter(word2) \\n        for x in a: \\n            for y in b:\\n                length1 = len(a)\\n                length2 = len(b)\\n                if a[x] == 1 and x != y:\\n                    length1 -= 1\\n                if b[y] == 1 and x != y:\\n                    length2 -= 1\\n                if y not in a:\\n                    length1 += 1\\n                if x not in b:\\n                    length2 += 1\\n                if length1 == length2:\\n                    return True\\n        return False\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Counting"
                ],
                "code": "```\\nclass Solution(object):\\n    def isItPossible(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: bool\\n        \"\"\"\\n        a,b = Counter(word1),Counter(word2) \\n        for x in a: \\n            for y in b:\\n                length1 = len(a)\\n                length2 = len(b)\\n                if a[x] == 1 and x != y:\\n                    length1 -= 1\\n                if b[y] == 1 and x != y:\\n                    length2 -= 1\\n                if y not in a:\\n                    length1 += 1\\n                if x not in b:\\n                    length2 += 1\\n                if length1 == length2:\\n                    return True\\n        return False\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407507,
                "title": "easy-solution-c-tc-o-26-26",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int n=word1.size(),m=word2.size();\\n        map<char,int> mp1,mp2;\\n        int c1=0,c2=0;\\n        for(int i=0;i<n;i++){\\n            mp1[word1[i]]++;            \\n        }\\n        for(int i=0;i<m;i++){\\n            mp2[word2[i]]++;            \\n        }\\n        for(auto it:mp1){\\n            for(auto it1:mp2){\\n                map<char,int> a=mp1,b=mp2;\\n                a[it1.first]++;\\n                b[it.first]++;\\n                a[it.first]--;\\n                b[it1.first]--;\\n                \\n                if(a[it.first]==0){\\n                    a.erase(it.first);\\n                }\\n                if(b[it1.first]==0){\\n                    b.erase(it1.first);\\n                }\\n                if(a.size()==b.size()){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int n=word1.size(),m=word2.size();\\n        map<char,int> mp1,mp2;\\n        int c1=0,c2=0;\\n        for(int i=0;i<n;i++){\\n            mp1[word1[i]]++;            \\n        }\\n        for(int i=0;i<m;i++){\\n            mp2[word2[i]]++;            \\n        }\\n        for(auto it:mp1){\\n            for(auto it1:mp2){\\n                map<char,int> a=mp1,b=mp2;\\n                a[it1.first]++;\\n                b[it.first]++;\\n                a[it.first]--;\\n                b[it1.first]--;\\n                \\n                if(a[it.first]==0){\\n                    a.erase(it.first);\\n                }\\n                if(b[it1.first]==0){\\n                    b.erase(it1.first);\\n                }\\n                if(a.size()==b.size()){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396143,
                "title": "python-solution-with-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        # create 2 list with 0 values\\n        arr = [0]*26\\n        brr = [0]*26\\n\\n        # store frequency of word1-letter in  arr \\n        for i in word1:\\n            arr[ord(i)-97] += 1\\n        \\n        # store frequency of word2-letter in  brr \\n        for i in word2:\\n            brr[ord(i)-97] += 1\\n        \\n        # it return number of digit greater then 0 from list\\n        def cal(krr):\\n            cnt = 0\\n            for i in krr:\\n                if i > 0 :\\n                    cnt += 1\\n            return cnt\\n\\n        #  try to check each and every swap\\n        for i in range(26):\\n            for j in range(26):\\n\\n            #   by this we swap of values in arr and brr\\n                if arr[i] and brr[j]:\\n                    arr[i] -= 1\\n                    brr[j] -= 1\\n                    arr[j] += 1\\n                    brr[i] += 1\\n\\n            # if arr and brr len same than return True\\n                    if cal(arr) == cal(brr):\\n                        return True\\n\\n            # otherwise restore initial state\\n                    else:\\n                        arr[i] += 1\\n                        brr[j] += 1\\n                        arr[j] -= 1\\n                        brr[i] -= 1\\n\\n    #   after finishing loop their is no posibility , so simply return False\\n        return False\\n\\n  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        # create 2 list with 0 values\\n        arr = [0]*26\\n        brr = [0]*26\\n\\n        # store frequency of word1-letter in  arr \\n        for i in word1:\\n            arr[ord(i)-97] += 1\\n        \\n        # store frequency of word2-letter in  brr \\n        for i in word2:\\n            brr[ord(i)-97] += 1\\n        \\n        # it return number of digit greater then 0 from list\\n        def cal(krr):\\n            cnt = 0\\n            for i in krr:\\n                if i > 0 :\\n                    cnt += 1\\n            return cnt\\n\\n        #  try to check each and every swap\\n        for i in range(26):\\n            for j in range(26):\\n\\n            #   by this we swap of values in arr and brr\\n                if arr[i] and brr[j]:\\n                    arr[i] -= 1\\n                    brr[j] -= 1\\n                    arr[j] += 1\\n                    brr[i] += 1\\n\\n            # if arr and brr len same than return True\\n                    if cal(arr) == cal(brr):\\n                        return True\\n\\n            # otherwise restore initial state\\n                    else:\\n                        arr[i] += 1\\n                        brr[j] += 1\\n                        arr[j] -= 1\\n                        brr[i] -= 1\\n\\n    #   after finishing loop their is no posibility , so simply return False\\n        return False\\n\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365574,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        // unordered_map<char,int> mp1;\\n        // unordered_map<char,int> mp2;\\n        int mp1[26]={};\\n        int mp2[26]={};\\n        int cnt1=0;\\n        int cnt2=0;\\n        for(int i=0;i<word1.size();i++){\\n            mp1[word1[i]-\\'a\\']++;\\n            if(mp1[word1[i]-\\'a\\']==1) cnt1++;\\n        }\\n        \\n        for(int i=0;i<word2.size();i++){\\n            mp2[word2[i]-\\'a\\']++;\\n            if(mp2[word2[i]-\\'a\\']==1) cnt2++;\\n        }\\n        if(abs(cnt2-cnt1)>2) return false;\\n        for(int i=0;i<26;i++){\\n            if(mp1[i]==0) continue;\\n            for(int j=0;j<26;j++){\\n                if(mp2[j]==0) continue;\\n                int x1=mp1[i];\\n                int x2=mp1[j];\\n                int x3=mp2[i];\\n                int x4=mp2[j];\\n                int a=cnt1;\\n                int b=cnt2;\\n                mp1[i]--;\\n                mp2[j]--;\\n                if(mp1[i]==0) a--;\\n                if(mp2[j]==0) b--;\\n                mp1[j]++;\\n                mp2[i]++;\\n                if(mp1[j]==1) a++;\\n                if(mp2[i]==1) b++;\\n                if(a==b) return true; \\n                mp1[i]=x1;\\n                mp1[j]=x2;\\n                mp2[i]=x3;\\n                mp2[j]=x4;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        // unordered_map<char,int> mp1;\\n        // unordered_map<char,int> mp2;\\n        int mp1[26]={};\\n        int mp2[26]={};\\n        int cnt1=0;\\n        int cnt2=0;\\n        for(int i=0;i<word1.size();i++){\\n            mp1[word1[i]-\\'a\\']++;\\n            if(mp1[word1[i]-\\'a\\']==1) cnt1++;\\n        }\\n        \\n        for(int i=0;i<word2.size();i++){\\n            mp2[word2[i]-\\'a\\']++;\\n            if(mp2[word2[i]-\\'a\\']==1) cnt2++;\\n        }\\n        if(abs(cnt2-cnt1)>2) return false;\\n        for(int i=0;i<26;i++){\\n            if(mp1[i]==0) continue;\\n            for(int j=0;j<26;j++){\\n                if(mp2[j]==0) continue;\\n                int x1=mp1[i];\\n                int x2=mp1[j];\\n                int x3=mp2[i];\\n                int x4=mp2[j];\\n                int a=cnt1;\\n                int b=cnt2;\\n                mp1[i]--;\\n                mp2[j]--;\\n                if(mp1[i]==0) a--;\\n                if(mp2[j]==0) b--;\\n                mp1[j]++;\\n                mp2[i]++;\\n                if(mp1[j]==1) a++;\\n                if(mp2[i]==1) b++;\\n                if(a==b) return true; \\n                mp1[i]=x1;\\n                mp1[j]=x2;\\n                mp2[i]=x3;\\n                mp2[j]=x4;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364851,
                "title": "c-using-o-26-26-of-constant-time-for-computation-o-n-for-hashing",
                "content": "# Approach\\n  Hash the characters in the given strings and also keep the count of distinct characters present in each string initially.\\nLet ph and qh be the hash map of th characters in the two given strings p and q, respectively.\\nLet pc and qc be the count of distinct characters present in the two given strings p and q, respectively.\\nNow we have exactly one move to make the distinct characters count in both the strings.\\nSo we try all the 26 * 26 possibilities of the characters swaps\\nLet\\'s understand this by considering an example : \\n\\nLet p=\"abbcde\"\\nLet q=\"bfghi\"\\n\\nSo ph={ a=1, b=2, c=1, d=1, e=1 }\\nand qh={ b=1, f=1, g=1, h=1, i=1 }\\n\\nAlso, pc=5 and qc=5.\\n\\nSo now we start with nested for loops having i=\\'a\\' to \\'z\\' and for every i, j=\\'a\\' to \\'z\\'.\\nph has \\'a\\' but qh do not \\'a\\', so we cannot swap.\\nMoving further.\\nph has \\'a\\' and qh also has \\'b\\' so we can swap.\\nwhen we swap,\\nMoving single character \\'a\\' from string p to q makes the count of \\'a\\' 0 in p. So we reduce the distinct count of string p i.e. pc=4.\\nBut moving single character \\'a\\' from string p to q causes 1 more new character to come in string q. So we increase the distinct count of string of q i.e. qc=6.\\nMoving single character \\'b\\' from string q to p makes the count of \\'b\\' 0 in q. So we reduce the distinct count of string q i.e. qc=5.\\nBut moving single character \\'b\\' from string q to p causes 1 more new character to come in string p. So we increase the distinct count of string of p i.e. pc=5.\\nSo this completes our one swap.\\nNow we check whether pc==qc. If true then return true else continue further which in our case evaluates to true as pc and qc both are 5.\\nBut before moving to next case, we have to revert back the changes we have done to the in this loop, so we have to reverse everything.\\n\\nIn the code below, you can see that there are 3 parts in nested for loop - \\n1. Front operation.\\n2. Checking.\\n3. Back operation.\\n\\n\\n# Complexity\\n- Time complexity : O(n)+O(26 * 26)\\n\\n- Space complexity : O(26 * 2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int s=26;\\n\\n    bool isItPossible(string p, string q) {\\n        vector<int> ph(s,0),qh(s,0);\\n        int pc=0,qc=0;\\n\\n        for(char c:p){\\n            if(ph[int(c-\\'a\\')]==0){\\n                pc++;\\n            }\\n            ph[int(c-\\'a\\')]++;\\n        }    \\n        for(char c:q){\\n            if(qh[int(c-\\'a\\')]==0){\\n                qc++;\\n            }\\n            qh[int(c-\\'a\\')]++;\\n        }\\n        bool status=0;\\n        for(int i=0;i<s;i++){\\n            if(ph[i]){\\n                for(int j=0;j<s;j++){\\n                    if(qh[j]){\\n                        // front operation\\n                        ph[i]--;\\n                        qh[i]++;\\n                        if(ph[i]==0){\\n                            pc--;\\n                        }\\n                        if(qh[i]==1){\\n                            qc++;\\n                        }\\n                        \\n                        ph[j]++;\\n                        qh[j]--;\\n                        if(ph[j]==1){\\n                            pc++;\\n                        }\\n                        if(qh[j]==0){\\n                            qc--;\\n                        }\\n                        \\n                        // checking\\n                        cout<<endl;\\n                        if(pc==qc){\\n                            status=1;\\n                            goto x;\\n                        }\\n\\n                        // back operation\\n                        ph[i]++;\\n                        qh[i]--;\\n                        if(ph[i]==1){\\n                            pc++;\\n                        }\\n                        if(qh[i]==0){\\n                            qc--;\\n                        }\\n                        \\n                        ph[j]--;\\n                        qh[j]++;\\n                        if(ph[j]==0){\\n                            pc--;\\n                        }\\n                        if(qh[j]==1){\\n                            qc++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        x:;\\n        return status;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int s=26;\\n\\n    bool isItPossible(string p, string q) {\\n        vector<int> ph(s,0),qh(s,0);\\n        int pc=0,qc=0;\\n\\n        for(char c:p){\\n            if(ph[int(c-\\'a\\')]==0){\\n                pc++;\\n            }\\n            ph[int(c-\\'a\\')]++;\\n        }    \\n        for(char c:q){\\n            if(qh[int(c-\\'a\\')]==0){\\n                qc++;\\n            }\\n            qh[int(c-\\'a\\')]++;\\n        }\\n        bool status=0;\\n        for(int i=0;i<s;i++){\\n            if(ph[i]){\\n                for(int j=0;j<s;j++){\\n                    if(qh[j]){\\n                        // front operation\\n                        ph[i]--;\\n                        qh[i]++;\\n                        if(ph[i]==0){\\n                            pc--;\\n                        }\\n                        if(qh[i]==1){\\n                            qc++;\\n                        }\\n                        \\n                        ph[j]++;\\n                        qh[j]--;\\n                        if(ph[j]==1){\\n                            pc++;\\n                        }\\n                        if(qh[j]==0){\\n                            qc--;\\n                        }\\n                        \\n                        // checking\\n                        cout<<endl;\\n                        if(pc==qc){\\n                            status=1;\\n                            goto x;\\n                        }\\n\\n                        // back operation\\n                        ph[i]++;\\n                        qh[i]--;\\n                        if(ph[i]==1){\\n                            pc++;\\n                        }\\n                        if(qh[i]==0){\\n                            qc--;\\n                        }\\n                        \\n                        ph[j]--;\\n                        qh[j]++;\\n                        if(ph[j]==0){\\n                            pc--;\\n                        }\\n                        if(qh[j]==1){\\n                            qc++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        x:;\\n        return status;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3362542,
                "title": "c-simple-o-m-n-solution-beats-94-96",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> t1(26,0), t2(26,0);\\n        for(char ch: word1)\\n            t1[ch-\\'a\\']++;\\n        for(char ch: word2)\\n            t2[ch-\\'a\\']++;\\n        for(int i=0; i<26; i++){\\n            for(int j=0; j<26; j++){\\n                if(t1[i] && t2[j]){\\n                    t1[j]++, t2[j]--, t1[i]--, t2[i]++;\\n                    int d1=check_distinct(t1);\\n                    int d2=check_distinct(t2);\\n                    if(d1==d2) return true;\\n                    t1[i]++, t1[j]--, t2[i]--, t2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int check_distinct(vector<int> &t){\\n        int res=0;\\n        for(int i=0; i<26; i++)\\n            if(t[i]) res++;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> t1(26,0), t2(26,0);\\n        for(char ch: word1)\\n            t1[ch-\\'a\\']++;\\n        for(char ch: word2)\\n            t2[ch-\\'a\\']++;\\n        for(int i=0; i<26; i++){\\n            for(int j=0; j<26; j++){\\n                if(t1[i] && t2[j]){\\n                    t1[j]++, t2[j]--, t1[i]--, t2[i]++;\\n                    int d1=check_distinct(t1);\\n                    int d2=check_distinct(t2);\\n                    if(d1==d2) return true;\\n                    t1[i]++, t1[j]--, t2[i]--, t2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int check_distinct(vector<int> &t){\\n        int res=0;\\n        for(int i=0; i<26; i++)\\n            if(t[i]) res++;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331955,
                "title": "python-o-n-runtime-100-set-counter-corner-cases-check",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can only make 1 move, so the maximum difference in cardinality of 2 strings are 2. We can then check the cases when cardinality difference is 0, 1, and 2. For each of those cases, we can apply corresponding if else logic.  \\n\\n![Screenshot 2023-03-23 at 11.13.28.png](https://assets.leetcode.com/users/images/d12a9fe3-cc73-4a03-877a-016168e0f508_1679570354.5313284.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        c1 = Counter(word1)\\n        c2 = Counter(word2)\\n        cardinality_diff = abs(len(c1) - len(c2))\\n\\n        if cardinality_diff == 0:\\n            # Same cardinality\\n            if 1 in c1.values() and 1 in c2.values():\\n                return True\\n\\n            if any([c > 1 for c in c1.values()]) and any([c > 1 for c in c2.values()]):\\n                return True\\n\\n            if c1.keys() == c2.keys():\\n                return True\\n        else:\\n            smaller_ct, larger_ct = (c1, c2) if len(c1) < len(c2) else (c2, c1)\\n\\n            if cardinality_diff == 1:\\n                # there should be at least 1 item with count == 1\\n                if any([larger_ct[i] == 1 for i in (larger_ct - smaller_ct)]):\\n                    if any([smaller_ct[i] > 1 and i not in larger_ct for i in smaller_ct]):\\n                        return True\\n\\n                    for item in smaller_ct:\\n                        if smaller_ct[item] > 1:\\n                            if any([i in smaller_ct and larger_ct[i] == 1 and i != item for i in larger_ct]):\\n                                return True\\n\\n                    if any([smaller_ct[i] == 1 and i in larger_ct for i in smaller_ct]):\\n                        return True\\n\\n                else:\\n                    # all items in larger diff set have count more than 1\\n                    # => there must be a common item between 2 strings that has count > 1\\n                    if any([(smaller_ct[i] > 1 and i in c2) for i in smaller_ct]):\\n                        return True\\n\\n            elif cardinality_diff == 2:\\n                if any([larger_ct[i] == 1 for i in (larger_ct - smaller_ct)]):\\n                    if any([smaller_ct[i] > 1 and i in larger_ct for i in smaller_ct]):\\n                        return True\\n\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        c1 = Counter(word1)\\n        c2 = Counter(word2)\\n        cardinality_diff = abs(len(c1) - len(c2))\\n\\n        if cardinality_diff == 0:\\n            # Same cardinality\\n            if 1 in c1.values() and 1 in c2.values():\\n                return True\\n\\n            if any([c > 1 for c in c1.values()]) and any([c > 1 for c in c2.values()]):\\n                return True\\n\\n            if c1.keys() == c2.keys():\\n                return True\\n        else:\\n            smaller_ct, larger_ct = (c1, c2) if len(c1) < len(c2) else (c2, c1)\\n\\n            if cardinality_diff == 1:\\n                # there should be at least 1 item with count == 1\\n                if any([larger_ct[i] == 1 for i in (larger_ct - smaller_ct)]):\\n                    if any([smaller_ct[i] > 1 and i not in larger_ct for i in smaller_ct]):\\n                        return True\\n\\n                    for item in smaller_ct:\\n                        if smaller_ct[item] > 1:\\n                            if any([i in smaller_ct and larger_ct[i] == 1 and i != item for i in larger_ct]):\\n                                return True\\n\\n                    if any([smaller_ct[i] == 1 and i in larger_ct for i in smaller_ct]):\\n                        return True\\n\\n                else:\\n                    # all items in larger diff set have count more than 1\\n                    # => there must be a common item between 2 strings that has count > 1\\n                    if any([(smaller_ct[i] > 1 and i in c2) for i in smaller_ct]):\\n                        return True\\n\\n            elif cardinality_diff == 2:\\n                if any([larger_ct[i] == 1 for i in (larger_ct - smaller_ct)]):\\n                    if any([smaller_ct[i] > 1 and i in larger_ct for i in smaller_ct]):\\n                        return True\\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320471,
                "title": "simple-solution-160ms-using-map-handle-edge-cases-and-exist-early",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} word1\\n * @param {string} word2\\n * @return {boolean}\\n */\\nfunction isItPossible(word1, word2) {\\n  // get the distint characters and its occurrances\\n  const map1 = getMap(word1);\\n  const map2 = getMap(word2);\\n\\n  // with 1 move, only +-1 change in size can be made.\\n  // if there are more than 2 distint character between 2 words, it is impossible\\n  if (Math.abs(map1.size - map2.size) > 2) return false;\\n\\n  for (let [char1, count1] of map1) {\\n    for (let [char2, count2] of map2) {\\n      let nDistintChars1 = map1.size;\\n      let nDistintChars2 = map2.size;\\n\\n      if (char1 === char2) {\\n        // edge case: only 1 character with many occurances in both words\\n        if (nDistintChars1 === nDistintChars2) return true;\\n\\n        // don\\'t process with the same character\\n        continue;\\n      };\\n\\n      // After swap, if the outgoing character is distint, the number of distint characters of that map reduces by 1 \\n      if(count1 === 1) nDistintChars1--;\\n      if(count2 === 1) nDistintChars2--;\\n\\n      // After swap, if the incoming character is NOT distint, the number of distint characters of that map incrases by 1\\n      if (!hasChar(map1, char2)) nDistintChars1++;\\n      if (!hasChar(map2, char1)) nDistintChars2++;\\n\\n      // Finally after swap, if the numbers are the same, exist the loop.\\n      if (nDistintChars1 === nDistintChars2) return true;\\n    }\\n  }\\n  return false;\\n};\\n\\n/**\\n * @param {string} word\\n * @return {Map<string, number>}\\n */\\nfunction getMap(word) {\\n  const map = new Map();\\n  for (let character of word) {\\n    map.set(character, (map.get(character) + 1) || 1);\\n  }\\n  return map;\\n}\\n\\n/**\\n * @param {Map<string, number>} map\\n * @param {string} char\\n * @return {boolean}\\n */\\nfunction hasChar(map, char){\\n  return map.get(char) != undefined;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} word1\\n * @param {string} word2\\n * @return {boolean}\\n */\\nfunction isItPossible(word1, word2) {\\n  // get the distint characters and its occurrances\\n  const map1 = getMap(word1);\\n  const map2 = getMap(word2);\\n\\n  // with 1 move, only +-1 change in size can be made.\\n  // if there are more than 2 distint character between 2 words, it is impossible\\n  if (Math.abs(map1.size - map2.size) > 2) return false;\\n\\n  for (let [char1, count1] of map1) {\\n    for (let [char2, count2] of map2) {\\n      let nDistintChars1 = map1.size;\\n      let nDistintChars2 = map2.size;\\n\\n      if (char1 === char2) {\\n        // edge case: only 1 character with many occurances in both words\\n        if (nDistintChars1 === nDistintChars2) return true;\\n\\n        // don\\'t process with the same character\\n        continue;\\n      };\\n\\n      // After swap, if the outgoing character is distint, the number of distint characters of that map reduces by 1 \\n      if(count1 === 1) nDistintChars1--;\\n      if(count2 === 1) nDistintChars2--;\\n\\n      // After swap, if the incoming character is NOT distint, the number of distint characters of that map incrases by 1\\n      if (!hasChar(map1, char2)) nDistintChars1++;\\n      if (!hasChar(map2, char1)) nDistintChars2++;\\n\\n      // Finally after swap, if the numbers are the same, exist the loop.\\n      if (nDistintChars1 === nDistintChars2) return true;\\n    }\\n  }\\n  return false;\\n};\\n\\n/**\\n * @param {string} word\\n * @return {Map<string, number>}\\n */\\nfunction getMap(word) {\\n  const map = new Map();\\n  for (let character of word) {\\n    map.set(character, (map.get(character) + 1) || 1);\\n  }\\n  return map;\\n}\\n\\n/**\\n * @param {Map<string, number>} map\\n * @param {string} char\\n * @return {boolean}\\n */\\nfunction hasChar(map, char){\\n  return map.get(char) != undefined;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3302285,
                "title": "c-brute-force",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    bool isItPossible(string word1, string word2) \\n    {\\n        int cnt1[26] = {0}, cnt2[26] = {0};\\n\\n        for (auto c : word1)\\n        {\\n            ++cnt1[c - \\'a\\'];\\n        }\\n\\n        for (auto c : word2)\\n        {\\n            ++cnt2[c - \\'a\\'];\\n        }\\n\\n        for (int i = 0; i < 26; ++i)\\n        {\\n            if (cnt1[i] == 0)\\n            {\\n                continue;\\n            }\\n\\n            for (int j = 0; j < 26; ++j)\\n            {\\n                if (cnt2[j] == 0)\\n                {\\n                    continue;\\n                }\\n\\n                int t1[26] = {0};\\n                memcpy(t1, cnt1, sizeof(cnt1));\\n                int t2[26] = {0};\\n                memcpy(t2, cnt2, sizeof(cnt2));\\n\\n                ++t1[j], --t1[i];\\n                ++t2[i], --t2[j];\\n\\n                int dist1 = 0;\\n                for (int k = 0; k < 26; ++k)\\n                {\\n                    dist1 += t1[k] > 0;\\n                }\\n\\n                int dist2 = 0;\\n                for (int k = 0; k < 26; ++k)\\n                {\\n                    dist2 += t2[k] > 0;\\n                }\\n\\n                if (dist1 == dist2)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isItPossible(string word1, string word2) \\n    {\\n        int cnt1[26] = {0}, cnt2[26] = {0};\\n\\n        for (auto c : word1)\\n        {\\n            ++cnt1[c - \\'a\\'];\\n        }\\n\\n        for (auto c : word2)\\n        {\\n            ++cnt2[c - \\'a\\'];\\n        }\\n\\n        for (int i = 0; i < 26; ++i)\\n        {\\n            if (cnt1[i] == 0)\\n            {\\n                continue;\\n            }\\n\\n            for (int j = 0; j < 26; ++j)\\n            {\\n                if (cnt2[j] == 0)\\n                {\\n                    continue;\\n                }\\n\\n                int t1[26] = {0};\\n                memcpy(t1, cnt1, sizeof(cnt1));\\n                int t2[26] = {0};\\n                memcpy(t2, cnt2, sizeof(cnt2));\\n\\n                ++t1[j], --t1[i];\\n                ++t2[i], --t2[j];\\n\\n                int dist1 = 0;\\n                for (int k = 0; k < 26; ++k)\\n                {\\n                    dist1 += t1[k] > 0;\\n                }\\n\\n                int dist2 = 0;\\n                for (int k = 0; k < 26; ++k)\\n                {\\n                    dist2 += t2[k] > 0;\\n                }\\n\\n                if (dist1 == dist2)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294433,
                "title": "c-map-chars",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> w1(26, 0);\\n        vector<int> w2(26, 0);\\n        for(int i = 0; i < word1.size(); i++) w1[word1[i] - \\'a\\']++;\\n        for(int i = 0; i < word2.size(); i++) w2[word2[i] - \\'a\\']++;\\n        for(int i = 0; i < w1.size(); i++){\\n            for(int j = 0; j < w2.size(); j++){\\n                if(w1[i] == 0) continue;\\n                if(w2[j] == 0) continue;\\n                w1[i]--;\\n                w2[j]--;\\n                w1[j]++;\\n                w2[i]++;\\n                int w1count = 0;\\n                int w2count = 0;\\n                for(int k = 0; k < 26; k++){\\n                    if(w1[k] > 0) w1count++;\\n                    if(w2[k] > 0) w2count++;\\n                }\\n                if(w1count == w2count) return true;\\n                w1[i]++;\\n                w2[j]++;\\n                w1[j]--;\\n                w2[i]--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> w1(26, 0);\\n        vector<int> w2(26, 0);\\n        for(int i = 0; i < word1.size(); i++) w1[word1[i] - \\'a\\']++;\\n        for(int i = 0; i < word2.size(); i++) w2[word2[i] - \\'a\\']++;\\n        for(int i = 0; i < w1.size(); i++){\\n            for(int j = 0; j < w2.size(); j++){\\n                if(w1[i] == 0) continue;\\n                if(w2[j] == 0) continue;\\n                w1[i]--;\\n                w2[j]--;\\n                w1[j]++;\\n                w2[i]++;\\n                int w1count = 0;\\n                int w2count = 0;\\n                for(int k = 0; k < 26; k++){\\n                    if(w1[k] > 0) w1count++;\\n                    if(w2[k] > 0) w2count++;\\n                }\\n                if(w1count == w2count) return true;\\n                w1[i]++;\\n                w2[j]++;\\n                w1[j]--;\\n                w2[i]--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253832,
                "title": "c-concise",
                "content": "# Intuition\\nin this problem, a string can be represented by a counter array with size=26. a swap between two string will change to counter like this:\\n            v1[i]--;\\n            v1[j]++;\\n            v2[i]++;\\n            v2[j]--;\\nif the two array has same count of none zero value, return true.\\nwe will need to iterate i and j from 0 to 26.\\n\\nTime Complexity: O(26*26*26) = O(1)\\nSpace Complexity: 2*O(26) = O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        auto v1 = normalize(word1), v2 = normalize(word2);\\n        auto vswap = [&](int i, int j){\\n            v1[i]--, v1[j]++, v2[i]++, v2[j]--;\\n        };\\n\\n        for(int i=0;i<26;i++) for(int j=0;j<26;j++){\\n            if(v1[i] == 0 || v2[j] == 0) continue;\\n            vswap(i, j);\\n            if(countChar(v1) == countChar(v2)) return true;\\n            vswap(j, i);\\n        }\\n        return false;\\n    }\\n\\n    int countChar(const vector<int>& cnt){\\n        return count_if(begin(cnt), end(cnt), [](int n){return n>0;});\\n    }\\n\\n    vector<int> normalize(const string& s){\\n        vector<int> cnt(26,0);\\n        for(char c:s) cnt[c-\\'a\\']++;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        auto v1 = normalize(word1), v2 = normalize(word2);\\n        auto vswap = [&](int i, int j){\\n            v1[i]--, v1[j]++, v2[i]++, v2[j]--;\\n        };\\n\\n        for(int i=0;i<26;i++) for(int j=0;j<26;j++){\\n            if(v1[i] == 0 || v2[j] == 0) continue;\\n            vswap(i, j);\\n            if(countChar(v1) == countChar(v2)) return true;\\n            vswap(j, i);\\n        }\\n        return false;\\n    }\\n\\n    int countChar(const vector<int>& cnt){\\n        return count_if(begin(cnt), end(cnt), [](int n){return n>0;});\\n    }\\n\\n    vector<int> normalize(const string& s){\\n        vector<int> cnt(26,0);\\n        for(char c:s) cnt[c-\\'a\\']++;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229640,
                "title": "java-clean-code-and-explanations",
                "content": "# Intuition\\nCount the letters into an int[26]. This can server as grouping. Check each letter and determine if it\\'s unique between str1/str2, if strings share more letters etc.\\nIf str1 has one unique letter and gives it to str2, then str1 grouping will be -1 and str2 grouping will be +1.\\n# Approach\\n1. Count and store each char of word1, word2 in an int[26] for letters a-z.\\nThis grouping will say how many distinc chars each string has.\\n    - eg: \"abcabc\" -> [2,2,2,0,0......] => 3 distinct groups\\n    - \"defdg\"  ->[0,0,0,2,1,1,1..] => 4 distinch groups\\n2. If the diff between the groups is > 2, they cannot be made equal, so return false.\\n3. The true difficulty comes when there is a difference of 0,1 and 2 between the two strings\\n4. Use a holder class Uniqueness that will compare and store (as flags) seveal info about each string  -count of letters - int[26] \\n5. Use two holder classes eg: Uniqueness u1, u2 for each string.\\n   - EG: if one letter is present in one string but not the other, mark this as hasOneUnique flag for string 2.\\n    - if the same letter is present multiple times in s1 and not in s2, mark hasMoreUnique as true.\\n6. These flags will be used to compare various edge cases and possibilities.\\n7. Ex: if both strings have same number of unique chars we can make the swaps in next condition:(diff 0)\\n    - both strings have one common char (eg: \"abc\" \"dbg\" each string has 3 unique but one is shared so the shared can be swapped)\\n    - str1 has one unique char and str2 has one unique char which can be swapped.\\n    - eg: [abc , def] -> any letter can be swapped\\n    - str2 has more unique chars and str1 has more unique chars.\\n8. Apply combined logic for edge cases of diff 1 and diff2\\n    - diff1 :EG: str1 has 3 distinct and str2 has 4. You need to eithert make str1 have 4 or make str2 to have 3\\n    - diff2: str1 has 3 and str2 has 5. The only case is when you make str1 to have 4 and str2 to have 4.\\n\\n# Complexity\\n- Time complexity:$$O(m + n + 26)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(26 x 2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        Uniqueness u1 = getUniquess(word1);\\n        Uniqueness u2 = getUniquess(word2);\\n        Uniqueness[] uniqueness = populateUniqueness(u1, u2);\\n        switch(uniqueness[1].size - uniqueness[0].size) {\\n            case 0 : return assertZeroDifference(uniqueness[0], uniqueness[1]);\\n            case 1: return assertOneDifference(uniqueness[0], uniqueness[1]);\\n            case 2: return assertTwoDifference(uniqueness[0], uniqueness[1]);\\n            default: return false;\\n        }\\n    }\\n\\n    private Uniqueness getUniquess(String word) {\\n        int[] count = new int[26];\\n        int size = 0;\\n        char ch;\\n        for (int i = 0; i < word.length(); i++) {\\n            ch = word.charAt(i);\\n            count[ch - \\'a\\']++;\\n            if (count[ch - \\'a\\'] == 1) {\\n                size++;\\n            }\\n        }\\n        return new Uniqueness(count, size);\\n    }\\n\\n    private Uniqueness[] populateUniqueness(Uniqueness u1, Uniqueness u2) {\\n        for (int i = 0; i < 26; i++) {\\n            if (u1.count[i] > 0 && u2.count[i] > 0) {\\n                u1.hasSharedCharacter = u2.hasSharedCharacter = true;\\n            }\\n            if (u1.count[i] == 1 && u2.count[i] == 0) {\\n                u1.hasOneUnique = true;\\n            }\\n            if (u1.count[i] > 1 && u2.count[i] == 0) {\\n                u1.hasMoreUniques = true;\\n            }\\n            if (u2.count[i] == 1 && u1.count[i] == 0) {\\n                u2.hasOneUnique = true;\\n            }\\n            if (u2.count[i] > 1 && u1.count[i] == 0) {\\n                u2.hasMoreUniques = true;\\n            }\\n            if (u1.count[i] > 1 && u2.count[i] > 0) {\\n                u1.hasMoreSharedCharacters = true;\\n            }\\n            if (u2.count[i] > 1 && u1.count[i] > 0) {\\n                u2.hasMoreSharedCharacters = true;\\n            }\\n            if (u1.count[i] == 1 && u2.count[i] > 0) {\\n                u1.hasOneSharedCharacter = true;\\n            }\\n            if (u2.count[i] == 1 && u1.count[i] > 0) {\\n                u2.hasOneSharedCharacter = true;\\n            }\\n        }\\n        return u1.size <= u2.size ? new Uniqueness[]{u1, u2} : new Uniqueness[]{u2, u1};\\n    }\\n\\n    private boolean assertZeroDifference(Uniqueness u1, Uniqueness u2) {\\n        return u1.hasSharedCharacter || (u1.hasOneUnique && u2.hasOneUnique) || (u1.hasMoreUniques && u2.hasMoreUniques);\\n    }\\n\\n    private boolean assertOneDifference(Uniqueness u1, Uniqueness u2) {\\n        return (u2.hasMoreUniques && u1.hasMoreSharedCharacters) || (u2.hasOneUnique && u1.hasMoreUniques) || (u2.hasOneUnique && u1.hasOneSharedCharacter)\\n            || (u2.hasOneSharedCharacter && u1.hasMoreSharedCharacters && isNotTheSame(u2, u1));\\n    }\\n\\n    private boolean isNotTheSame(Uniqueness u2, Uniqueness u1) {\\n        int count = 0;\\n        int hasMoreToSwap = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (u2.count[i] == 1 && u1.count[i] > 1) {\\n                count++;\\n            }\\n            if(u1.count[i] >= 1 && u2.count[i] >= 1) {\\n                hasMoreToSwap++;\\n            }\\n        }\\n        return count > 1 || hasMoreToSwap > 1;\\n    }\\n\\n    private boolean assertTwoDifference(Uniqueness u1, Uniqueness u2) {\\n        return u2.hasOneUnique && u1.hasMoreSharedCharacters;\\n    }\\n\\n    private static class Uniqueness {\\n        int size;\\n        int[] count;\\n        // case 0\\n        boolean hasSharedCharacter;\\n        boolean hasOneUnique;\\n        boolean hasMoreUniques;\\n        // case 1\\n        boolean hasMoreSharedCharacters;\\n        boolean hasOneSharedCharacter;\\n\\n        public Uniqueness(int[] count, int size) {\\n            this.count = count;\\n            this.size =  size;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        Uniqueness u1 = getUniquess(word1);\\n        Uniqueness u2 = getUniquess(word2);\\n        Uniqueness[] uniqueness = populateUniqueness(u1, u2);\\n        switch(uniqueness[1].size - uniqueness[0].size) {\\n            case 0 : return assertZeroDifference(uniqueness[0], uniqueness[1]);\\n            case 1: return assertOneDifference(uniqueness[0], uniqueness[1]);\\n            case 2: return assertTwoDifference(uniqueness[0], uniqueness[1]);\\n            default: return false;\\n        }\\n    }\\n\\n    private Uniqueness getUniquess(String word) {\\n        int[] count = new int[26];\\n        int size = 0;\\n        char ch;\\n        for (int i = 0; i < word.length(); i++) {\\n            ch = word.charAt(i);\\n            count[ch - \\'a\\']++;\\n            if (count[ch - \\'a\\'] == 1) {\\n                size++;\\n            }\\n        }\\n        return new Uniqueness(count, size);\\n    }\\n\\n    private Uniqueness[] populateUniqueness(Uniqueness u1, Uniqueness u2) {\\n        for (int i = 0; i < 26; i++) {\\n            if (u1.count[i] > 0 && u2.count[i] > 0) {\\n                u1.hasSharedCharacter = u2.hasSharedCharacter = true;\\n            }\\n            if (u1.count[i] == 1 && u2.count[i] == 0) {\\n                u1.hasOneUnique = true;\\n            }\\n            if (u1.count[i] > 1 && u2.count[i] == 0) {\\n                u1.hasMoreUniques = true;\\n            }\\n            if (u2.count[i] == 1 && u1.count[i] == 0) {\\n                u2.hasOneUnique = true;\\n            }\\n            if (u2.count[i] > 1 && u1.count[i] == 0) {\\n                u2.hasMoreUniques = true;\\n            }\\n            if (u1.count[i] > 1 && u2.count[i] > 0) {\\n                u1.hasMoreSharedCharacters = true;\\n            }\\n            if (u2.count[i] > 1 && u1.count[i] > 0) {\\n                u2.hasMoreSharedCharacters = true;\\n            }\\n            if (u1.count[i] == 1 && u2.count[i] > 0) {\\n                u1.hasOneSharedCharacter = true;\\n            }\\n            if (u2.count[i] == 1 && u1.count[i] > 0) {\\n                u2.hasOneSharedCharacter = true;\\n            }\\n        }\\n        return u1.size <= u2.size ? new Uniqueness[]{u1, u2} : new Uniqueness[]{u2, u1};\\n    }\\n\\n    private boolean assertZeroDifference(Uniqueness u1, Uniqueness u2) {\\n        return u1.hasSharedCharacter || (u1.hasOneUnique && u2.hasOneUnique) || (u1.hasMoreUniques && u2.hasMoreUniques);\\n    }\\n\\n    private boolean assertOneDifference(Uniqueness u1, Uniqueness u2) {\\n        return (u2.hasMoreUniques && u1.hasMoreSharedCharacters) || (u2.hasOneUnique && u1.hasMoreUniques) || (u2.hasOneUnique && u1.hasOneSharedCharacter)\\n            || (u2.hasOneSharedCharacter && u1.hasMoreSharedCharacters && isNotTheSame(u2, u1));\\n    }\\n\\n    private boolean isNotTheSame(Uniqueness u2, Uniqueness u1) {\\n        int count = 0;\\n        int hasMoreToSwap = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (u2.count[i] == 1 && u1.count[i] > 1) {\\n                count++;\\n            }\\n            if(u1.count[i] >= 1 && u2.count[i] >= 1) {\\n                hasMoreToSwap++;\\n            }\\n        }\\n        return count > 1 || hasMoreToSwap > 1;\\n    }\\n\\n    private boolean assertTwoDifference(Uniqueness u1, Uniqueness u2) {\\n        return u2.hasOneUnique && u1.hasMoreSharedCharacters;\\n    }\\n\\n    private static class Uniqueness {\\n        int size;\\n        int[] count;\\n        // case 0\\n        boolean hasSharedCharacter;\\n        boolean hasOneUnique;\\n        boolean hasMoreUniques;\\n        // case 1\\n        boolean hasMoreSharedCharacters;\\n        boolean hasOneSharedCharacter;\\n\\n        public Uniqueness(int[] count, int size) {\\n            this.count = count;\\n            this.size =  size;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220718,
                "title": "c-map",
                "content": "\\n# Complexity\\n- Time complexity:O(N) + O(26 * 26 * 26);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        \\n        vector<int> a(26,0),b(26,0);\\n        for(int i = 0; i < word1.size(); i++) a[word1[i] - \\'a\\']++;\\n        for(int i = 0; i < word2.size(); i++) b[word2[i] - \\'a\\']++;\\n\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < 26; j++) {\\n                if(a[i] <= 0 || b[j] <= 0) continue;\\n                a[i] -= 1;\\n                b[j] -= 1;\\n                b[i] += 1;\\n                a[j] += 1;\\n                if(check(a,b)) {\\n                    // cout<<a[i]<<b[j]<<endl;\\n                    return true;\\n                }\\n                a[i] += 1;\\n                b[j] += 1;\\n                b[i] -= 1;\\n                a[j] -= 1;\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    bool check(vector<int> &a,vector<int> &b) {\\n        int cnt1 = 0,cnt2 = 0;\\n        for(int i = 0; i < 26; i++) {\\n            if(a[i] > 0) cnt1++;\\n        }\\n        for(int j = 0; j < 26; j++) {\\n            if(b[j] > 0) cnt2++;\\n        }\\n\\n        return cnt1 == cnt2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        \\n        vector<int> a(26,0),b(26,0);\\n        for(int i = 0; i < word1.size(); i++) a[word1[i] - \\'a\\']++;\\n        for(int i = 0; i < word2.size(); i++) b[word2[i] - \\'a\\']++;\\n\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < 26; j++) {\\n                if(a[i] <= 0 || b[j] <= 0) continue;\\n                a[i] -= 1;\\n                b[j] -= 1;\\n                b[i] += 1;\\n                a[j] += 1;\\n                if(check(a,b)) {\\n                    // cout<<a[i]<<b[j]<<endl;\\n                    return true;\\n                }\\n                a[i] += 1;\\n                b[j] += 1;\\n                b[i] -= 1;\\n                a[j] -= 1;\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    bool check(vector<int> &a,vector<int> &b) {\\n        int cnt1 = 0,cnt2 = 0;\\n        for(int i = 0; i < 26; i++) {\\n            if(a[i] > 0) cnt1++;\\n        }\\n        for(int j = 0; j < 26; j++) {\\n            if(b[j] > 0) cnt2++;\\n        }\\n\\n        return cnt1 == cnt2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3147477,
                "title": "easy-c-solution-optimize-solution-using-hash-table-tc-o-1-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using String + Hash Table + Counting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approache by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(1), the algorithm itself takes constant time which is 26*26 iteration due to nested loop.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), the algorithm itself takes constant 26 size of unordered map space which a to z lowercase letters.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(1), the algorithm itself takes constant time which is 26*26 iteration due to nested loop.\\n\\n    Space Complexity : O(1), the algorithm itself takes constant 26 size of unordered map space which a to z\\n    lowercase letters.\\n\\n    Using String + HashTable + Counting.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char, int> map1;\\n        unordered_map<char, int> map2;\\n        for(auto it : word1) map1[it]++;\\n        for(auto it : word2) map2[it]++;\\n\\n        for(char ch1=\\'a\\'; ch1<=\\'z\\'; ch1++){\\n            for(char ch2=\\'a\\'; ch2<=\\'z\\'; ch2++){\\n                if(map1.find(ch1) != map1.end() && map2.find(ch2) != map2.end()){\\n                    if(--map1[ch1] == 0) map1.erase(ch1);\\n                    if(--map2[ch2] == 0) map2.erase(ch2); \\n\\n                    map1[ch2]++;\\n                    map2[ch1]++;\\n\\n                    if(map1.size() == map2.size()){\\n                        return true;\\n                    }\\n\\n                    if(--map1[ch2] == 0) map1.erase(ch2);\\n                    if(--map2[ch1] == 0) map2.erase(ch1); \\n\\n                    map1[ch1]++;\\n                    map2[ch2]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(1), the algorithm itself takes constant time which is 26*26 iteration due to nested loop.\\n\\n    Space Complexity : O(1), the algorithm itself takes constant 26 size of unordered map space which a to z\\n    lowercase letters.\\n\\n    Using String + HashTable + Counting.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char, int> map1;\\n        unordered_map<char, int> map2;\\n        for(auto it : word1) map1[it]++;\\n        for(auto it : word2) map2[it]++;\\n\\n        for(char ch1=\\'a\\'; ch1<=\\'z\\'; ch1++){\\n            for(char ch2=\\'a\\'; ch2<=\\'z\\'; ch2++){\\n                if(map1.find(ch1) != map1.end() && map2.find(ch2) != map2.end()){\\n                    if(--map1[ch1] == 0) map1.erase(ch1);\\n                    if(--map2[ch2] == 0) map2.erase(ch2); \\n\\n                    map1[ch2]++;\\n                    map2[ch1]++;\\n\\n                    if(map1.size() == map2.size()){\\n                        return true;\\n                    }\\n\\n                    if(--map1[ch2] == 0) map1.erase(ch2);\\n                    if(--map2[ch1] == 0) map2.erase(ch1); \\n\\n                    map1[ch1]++;\\n                    map2[ch2]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139219,
                "title": "golang-counting",
                "content": "# Code\\n```\\nfunc equals(freq1, freq2 []int) bool {\\n    var count1, count2 int = 0, 0\\n    for i := 0; i < 26; i++ {\\n        if freq1[i] > 0 {count1++}\\n        if freq2[i] > 0 {count2++}\\n    }\\n    return count1 == count2\\n}\\n\\nfunc insertRemove(freq []int, i, j int) {\\n    freq[i]--\\n    freq[j]++\\n}\\n\\nfunc isItPossible(word1 string, word2 string) bool {\\n    freq1 := make([]int, 26)\\n    freq2 := make([]int, 26)\\n    for _, ch := range word1 {freq1[ch - \\'a\\']++}\\n    for _, ch := range word2 {freq2[ch - \\'a\\']++}\\n    for i := 0; i < 26; i++ {\\n        if freq1[i] == 0 {continue} \\n        for j := 0; j < 26; j++ {\\n            if freq2[j] == 0 {continue}\\n            insertRemove(freq1, i, j)\\n            insertRemove(freq2, j, i)\\n            if equals(freq1, freq2) {return true}\\n            insertRemove(freq2, i, j)\\n            insertRemove(freq1, j, i)\\n        }\\n    }\\n    return false\\n}    \\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nfunc equals(freq1, freq2 []int) bool {\\n    var count1, count2 int = 0, 0\\n    for i := 0; i < 26; i++ {\\n        if freq1[i] > 0 {count1++}\\n        if freq2[i] > 0 {count2++}\\n    }\\n    return count1 == count2\\n}\\n\\nfunc insertRemove(freq []int, i, j int) {\\n    freq[i]--\\n    freq[j]++\\n}\\n\\nfunc isItPossible(word1 string, word2 string) bool {\\n    freq1 := make([]int, 26)\\n    freq2 := make([]int, 26)\\n    for _, ch := range word1 {freq1[ch - \\'a\\']++}\\n    for _, ch := range word2 {freq2[ch - \\'a\\']++}\\n    for i := 0; i < 26; i++ {\\n        if freq1[i] == 0 {continue} \\n        for j := 0; j < 26; j++ {\\n            if freq2[j] == 0 {continue}\\n            insertRemove(freq1, i, j)\\n            insertRemove(freq2, j, i)\\n            if equals(freq1, freq2) {return true}\\n            insertRemove(freq2, i, j)\\n            insertRemove(freq1, j, i)\\n        }\\n    }\\n    return false\\n}    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3137565,
                "title": "c-counting",
                "content": "# Code\\n```\\nclass Solution {\\n    bool equals(int freq1[], int freq2[]) {\\n        int count1 = 0, count2 = 0;\\n        for(int i = 0; i < 26; i++) {\\n            count1 += (freq1[i] > 0);\\n            count2 += (freq2[i] > 0);\\n        }\\n        return count1 == count2;\\n    }\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int freq1[26] = {0}, freq2[26] = {0};\\n        for(char ch: word1) freq1[ch - \\'a\\']++;\\n        for(char ch: word2) freq2[ch - \\'a\\']++;\\n        for(int i = 0; i < 26; i++) {\\n            if(!freq1[i]) continue; \\n            for(int j = 0; j < 26; j++) {\\n                if(!freq2[j]) continue;\\n                freq1[i]--;\\n                freq2[i]++;\\n                freq1[j]++;\\n                freq2[j]--;\\n                if(equals(freq1, freq2)) return true;\\n                freq1[i]++;\\n                freq2[i]--;\\n                freq1[j]--;\\n                freq2[j]++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\n    bool equals(int freq1[], int freq2[]) {\\n        int count1 = 0, count2 = 0;\\n        for(int i = 0; i < 26; i++) {\\n            count1 += (freq1[i] > 0);\\n            count2 += (freq2[i] > 0);\\n        }\\n        return count1 == count2;\\n    }\\n    void insertRemove(int freq[], int i, int j) {\\n        freq[i]--;\\n        freq[j]++;\\n    }\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int freq1[26] = {0}, freq2[26] = {0};\\n        for(char ch: word1) freq1[ch - \\'a\\']++;\\n        for(char ch: word2) freq2[ch - \\'a\\']++;\\n        for(int i = 0; i < 26; i++) {\\n            if(!freq1[i]) continue; \\n            for(int j = 0; j < 26; j++) {\\n                if(!freq2[j]) continue;\\n                insertRemove(freq1, i, j);\\n                insertRemove(freq2, j, i);\\n                if(equals(freq1, freq2)) return true;\\n                insertRemove(freq2, i, j);\\n                insertRemove(freq1, j, i);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    bool equals(int freq1[], int freq2[]) {\\n        int count1 = 0, count2 = 0;\\n        for(int i = 0; i < 26; i++) {\\n            count1 += (freq1[i] > 0);\\n            count2 += (freq2[i] > 0);\\n        }\\n        return count1 == count2;\\n    }\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int freq1[26] = {0}, freq2[26] = {0};\\n        for(char ch: word1) freq1[ch - \\'a\\']++;\\n        for(char ch: word2) freq2[ch - \\'a\\']++;\\n        for(int i = 0; i < 26; i++) {\\n            if(!freq1[i]) continue; \\n            for(int j = 0; j < 26; j++) {\\n                if(!freq2[j]) continue;\\n                freq1[i]--;\\n                freq2[i]++;\\n                freq1[j]++;\\n                freq2[j]--;\\n                if(equals(freq1, freq2)) return true;\\n                freq1[i]++;\\n                freq2[i]--;\\n                freq1[j]--;\\n                freq2[j]++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\n    bool equals(int freq1[], int freq2[]) {\\n        int count1 = 0, count2 = 0;\\n        for(int i = 0; i < 26; i++) {\\n            count1 += (freq1[i] > 0);\\n            count2 += (freq2[i] > 0);\\n        }\\n        return count1 == count2;\\n    }\\n    void insertRemove(int freq[], int i, int j) {\\n        freq[i]--;\\n        freq[j]++;\\n    }\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int freq1[26] = {0}, freq2[26] = {0};\\n        for(char ch: word1) freq1[ch - \\'a\\']++;\\n        for(char ch: word2) freq2[ch - \\'a\\']++;\\n        for(int i = 0; i < 26; i++) {\\n            if(!freq1[i]) continue; \\n            for(int j = 0; j < 26; j++) {\\n                if(!freq2[j]) continue;\\n                insertRemove(freq1, i, j);\\n                insertRemove(freq2, j, i);\\n                if(equals(freq1, freq2)) return true;\\n                insertRemove(freq2, i, j);\\n                insertRemove(freq1, j, i);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127814,
                "title": "easy-c-code-optimize-and-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Determining if Two Words are Transformable by Swapping Two Characters**\\n\\nThe problem asks if it\\'s possible to obtain one word from another by swapping exactly two characters. To solve this, we need to check if both words have the same frequency of characters.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Count the frequency of each character in both words using two arrays or maps.\\n2. For each pair of characters in the alphabet, check if both words have at least one occurrence of these characters.\\n3. If both words have the characters, swap them and check if both words have the same number of distinct characters.\\n4. Repeat this process for all pairs of characters and return true if any of the swaps result in two words with the same number of distinct characters.\\n# Complexity\\n- Time complexity: $O(26^2)$, because for each pair of characters we check their frequency and make a swap if possible, and this operation takes constant time. The total number of pairs is $26^2$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(26)$, because we use two arrays of size 26 to store the frequency of each character in the alphabet.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool isItPossible(string word1, string word2) {\\n    int freq1[26] = {0}, freq2[26] = {0};\\n    //count frequency of each char in word1 and word2\\n    for(char ch: word1) freq1[ch-\\'a\\']++;\\n    for(char ch: word2) freq2[ch-\\'a\\']++;\\n\\n    for(int i=0; i < 26; i++){\\n        for(int j=0; j < 26; j++){\\n            char ch1 = i + \\'a\\', ch2 = j + \\'a\\';\\n            //if both words have at least one occurrence of ch1 and ch2\\n            if(freq1[i] && freq2[j]){\\n                //swap the chars\\n                freq1[i]--;\\n                freq2[j]--;\\n                freq1[j]++;\\n                freq2[i]++;\\n\\n                //check if both words have same number of distinct chars\\n                int sum1=0, sum2=0;\\n                for(int k=0; k<26; k++)\\n                {\\n                    if(freq1[k]) sum1++;\\n                    if(freq2[k]) sum2++;\\n                }\\n                if(sum1 == sum2) return true;\\n\\n                //add back the removed chars\\n                freq1[j]--;\\n                freq2[i]--;\\n                freq1[i]++;\\n                freq2[j]++;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool isItPossible(string word1, string word2) {\\n    int freq1[26] = {0}, freq2[26] = {0};\\n    //count frequency of each char in word1 and word2\\n    for(char ch: word1) freq1[ch-\\'a\\']++;\\n    for(char ch: word2) freq2[ch-\\'a\\']++;\\n\\n    for(int i=0; i < 26; i++){\\n        for(int j=0; j < 26; j++){\\n            char ch1 = i + \\'a\\', ch2 = j + \\'a\\';\\n            //if both words have at least one occurrence of ch1 and ch2\\n            if(freq1[i] && freq2[j]){\\n                //swap the chars\\n                freq1[i]--;\\n                freq2[j]--;\\n                freq1[j]++;\\n                freq2[i]++;\\n\\n                //check if both words have same number of distinct chars\\n                int sum1=0, sum2=0;\\n                for(int k=0; k<26; k++)\\n                {\\n                    if(freq1[k]) sum1++;\\n                    if(freq2[k]) sum2++;\\n                }\\n                if(sum1 == sum2) return true;\\n\\n                //add back the removed chars\\n                freq1[j]--;\\n                freq2[i]--;\\n                freq1[i]++;\\n                freq2[j]++;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118885,
                "title": "simple-c-with-comments",
                "content": "# Intuition\\nWe just need to swap characters \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nFor all possibilities of swapping charaters i.e (26*26)  check the number of distinct charaters of both the string.  \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(26x26x26) , can be said to constant \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(2x26) : just two vector of size 26, i.e constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code with comments  \\n```\\nclass Solution {\\npublic:\\n    \\n    // A function that callcultes for distinct characters \\n    int DISTINCT_CHAR(vector<int> &v)\\n    {\\n        int c= 0  ;       \\n        \\n        for(int i:v)\\n        if(i>0)c++; \\n        \\n        return c;\\n    }\\n    \\n    bool isItPossible(string s1, string s2 ) {\\n        \\n        // freq vector for string  s1 and s2  \\n        vector<int> v1(26,0) , v2(26,0);\\n        \\n        for(char i : s1)\\n        v1[i-\\'a\\']++;\\n                    \\n        for(char i : s2)\\n        v2[i-\\'a\\']++;\\n                \\n        for(int i = 0; i<26;i++)\\n        {\\n            // if that character is not present in string s1 then just leave that \\n            if(v1[i] == 0 ) continue ; \\n             \\n            for(int j = 0 ;j<26;j++)\\n            {\\n                // if that character is not present in string s2 then just leave that \\n                if(v2[j] == 0  ) continue;\\n                \\n                /* \\n                  before swapping \\n                  \\n                s1 :  <-------i------>  \\n                s2 :  <--j-----------> \\n\\n                  After swapping \\n                  \\n                s1 :  <-------j------>  \\n                s2 :  <--i-----------> \\n\\n                  now here we see char i of string s1 is swapped with char j of s2 are swapped \\n                  then freq of char j in s1 increase by 1 and freq of char i decrease by 1\\n                  and similarly for s2 freq for char j decrease by 1 and for char i increase by 1 \\n\\n                 */    \\n\\n                v1[i]--;    \\n                v1[j]++;\\n                \\n                v2[j]--;\\n                v2[i]++;\\n                \\n                // if distinct char same for both after one swap then return true\\n                if( DISTINCT_CHAR(v1) == DISTINCT_CHAR(v2)) \\n                return true;\\n                \\n                // now here we need to get our original freq vector for s1 and s2 back for further possibilities  \\n                v1[i]++ ;\\n                v1[j]-- ;\\n                \\n                v2[j]++; \\n                v2[i]--;\\n            }\\n        }    \\n\\n        // after all posoibilities return false\\n        return false;\\n    \\n    }\\n};\\n```\\n# Code without comments  \\n```\\nclass Solution {\\npublic:\\n\\n    int DISTINCT_CHAR(vector<int> &v)\\n    {\\n        int c= 0  ;       \\n        \\n        for(int i:v)\\n        if(i>0)c++; \\n        \\n        return c;\\n    }\\n    \\n    bool isItPossible(string s1, string s2 ) {\\n        \\n        \\n        vector<int> v1(26,0) , v2(26,0);\\n        \\n        for(char i : s1)\\n        v1[i-\\'a\\']++;\\n                    \\n        for(char i : s2)\\n        v2[i-\\'a\\']++;\\n                \\n        for(int i = 0; i<26;i++)\\n        {\\n           \\n            if(v1[i] == 0 ) continue ; \\n             \\n            for(int j = 0 ;j<26;j++)\\n            {\\n                \\n                if(v2[j] == 0  ) continue;\\n            \\n                v1[i]--;    \\n                v1[j]++;\\n                \\n                v2[j]--;\\n                v2[i]++;\\n                \\n                \\n                if( DISTINCT_CHAR(v1) == DISTINCT_CHAR(v2)) \\n                return true;\\n                \\n                v1[i]++ ;\\n                v1[j]-- ;\\n                \\n                v2[j]++; \\n                v2[i]--;\\n            }\\n        }    \\n        return false;\\n    \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // A function that callcultes for distinct characters \\n    int DISTINCT_CHAR(vector<int> &v)\\n    {\\n        int c= 0  ;       \\n        \\n        for(int i:v)\\n        if(i>0)c++; \\n        \\n        return c;\\n    }\\n    \\n    bool isItPossible(string s1, string s2 ) {\\n        \\n        // freq vector for string  s1 and s2  \\n        vector<int> v1(26,0) , v2(26,0);\\n        \\n        for(char i : s1)\\n        v1[i-\\'a\\']++;\\n                    \\n        for(char i : s2)\\n        v2[i-\\'a\\']++;\\n                \\n        for(int i = 0; i<26;i++)\\n        {\\n            // if that character is not present in string s1 then just leave that \\n            if(v1[i] == 0 ) continue ; \\n             \\n            for(int j = 0 ;j<26;j++)\\n            {\\n                // if that character is not present in string s2 then just leave that \\n                if(v2[j] == 0  ) continue;\\n                \\n                /* \\n                  before swapping \\n                  \\n                s1 :  <-------i------>  \\n                s2 :  <--j-----------> \\n\\n                  After swapping \\n                  \\n                s1 :  <-------j------>  \\n                s2 :  <--i-----------> \\n\\n                  now here we see char i of string s1 is swapped with char j of s2 are swapped \\n                  then freq of char j in s1 increase by 1 and freq of char i decrease by 1\\n                  and similarly for s2 freq for char j decrease by 1 and for char i increase by 1 \\n\\n                 */    \\n\\n                v1[i]--;    \\n                v1[j]++;\\n                \\n                v2[j]--;\\n                v2[i]++;\\n                \\n                // if distinct char same for both after one swap then return true\\n                if( DISTINCT_CHAR(v1) == DISTINCT_CHAR(v2)) \\n                return true;\\n                \\n                // now here we need to get our original freq vector for s1 and s2 back for further possibilities  \\n                v1[i]++ ;\\n                v1[j]-- ;\\n                \\n                v2[j]++; \\n                v2[i]--;\\n            }\\n        }    \\n\\n        // after all posoibilities return false\\n        return false;\\n    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int DISTINCT_CHAR(vector<int> &v)\\n    {\\n        int c= 0  ;       \\n        \\n        for(int i:v)\\n        if(i>0)c++; \\n        \\n        return c;\\n    }\\n    \\n    bool isItPossible(string s1, string s2 ) {\\n        \\n        \\n        vector<int> v1(26,0) , v2(26,0);\\n        \\n        for(char i : s1)\\n        v1[i-\\'a\\']++;\\n                    \\n        for(char i : s2)\\n        v2[i-\\'a\\']++;\\n                \\n        for(int i = 0; i<26;i++)\\n        {\\n           \\n            if(v1[i] == 0 ) continue ; \\n             \\n            for(int j = 0 ;j<26;j++)\\n            {\\n                \\n                if(v2[j] == 0  ) continue;\\n            \\n                v1[i]--;    \\n                v1[j]++;\\n                \\n                v2[j]--;\\n                v2[i]++;\\n                \\n                \\n                if( DISTINCT_CHAR(v1) == DISTINCT_CHAR(v2)) \\n                return true;\\n                \\n                v1[i]++ ;\\n                v1[j]-- ;\\n                \\n                v2[j]++; \\n                v2[i]--;\\n            }\\n        }    \\n        return false;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092622,
                "title": "c-o-m-n-26-26-listing-all-possible-exchanges-of-alphabets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet the respective frequencies of alphabets in two strings and try all the possible exchange between alphabets(e.g. `a` in first string with `b` in the second string). Then compare the numbers of unique alphabets after the exchange.\\n\\nI use `u1`, `u2` to store the number of unique alphabets in the two strings. When removing an alphabet `a` in the first string, I will check if the frequency of `a` decreases to 0. If so, then u1 should decrease by 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nGetting the frequencies of alphabets of two strings takes $O(m + n)$.\\nThe possible exchanges of alphabets is at most `O(26*26)`\\nHence the total time complexity is `O(m + n + 26*26)`\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(26 + 26) = O(1)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int hist1[26] = {0}, hist2[26] = {0};\\n        int u1 = 0, u2 = 0;\\n        for (char & c: word1) { if (hist1[c - \\'a\\']++ == 0) {++u1;} }\\n        for (char & c: word2) { if (hist2[c - \\'a\\']++ == 0) {++u2;} }\\n        for (int i = 0; i < 26; ++i) {\\n            if (hist1[i] == 0) continue;\\n            if (--hist1[i] == 0) {--u1;}\\n            for (int j = 0; j < 26; ++j) {\\n                if (hist2[j] == 0) continue;\\n                if (++hist2[i] == 1) {++u2;} \\n                if (--hist2[j] == 0) {--u2;}\\n                if (++hist1[j] == 1) {++u1;}\\n                if (u1 == u2) return true;\\n                if (--hist1[j] == 0) {--u1;}\\n                if (++hist2[j] == 1) {++u2;}\\n                if (--hist2[i] == 0) {--u2;}\\n            }\\n            if (++hist1[i] == 1) {++u1;}\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int hist1[26] = {0}, hist2[26] = {0};\\n        int u1 = 0, u2 = 0;\\n        for (char & c: word1) { if (hist1[c - \\'a\\']++ == 0) {++u1;} }\\n        for (char & c: word2) { if (hist2[c - \\'a\\']++ == 0) {++u2;} }\\n        for (int i = 0; i < 26; ++i) {\\n            if (hist1[i] == 0) continue;\\n            if (--hist1[i] == 0) {--u1;}\\n            for (int j = 0; j < 26; ++j) {\\n                if (hist2[j] == 0) continue;\\n                if (++hist2[i] == 1) {++u2;} \\n                if (--hist2[j] == 0) {--u2;}\\n                if (++hist1[j] == 1) {++u1;}\\n                if (u1 == u2) return true;\\n                if (--hist1[j] == 0) {--u1;}\\n                if (++hist2[j] == 1) {++u2;}\\n                if (--hist2[i] == 0) {--u2;}\\n            }\\n            if (++hist1[i] == 1) {++u1;}\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088294,
                "title": "easy-to-understand-dictionary-binning-c-2-approaches",
                "content": "```\\nusing um = unordered_map<char,int>;\\n    void add(um &m, char c) {\\n        m[c]++;\\n    }\\n    void remove(um &m, char c) {\\n        m[c]--;\\n        if (m[c] == 0)\\n            m.erase(c);\\n    }\\n    \\n    bool isItPossible(string word1, string word2) {\\n        um m1,m2;\\n        vector<char> u1,u2;\\n        for (auto &c : word1) \\n            m1[c]++;\\n        for (auto &c : word2)\\n            m2[c]++;\\n        for (auto &k : m1)\\n            u1.push_back(k.first);\\n        for (auto &k : m2)\\n            u2.push_back(k.first);\\n        \\n        for (auto &k1 : u1) {\\n            remove(m1,k1);\\n            for (auto &k2 : u2) {\\n                remove(m2,k2);\\n                add(m1,k2);\\n                add(m2,k1);\\n                if (m1.size() == m2.size())\\n                    return true;\\n                remove(m1,k2);\\n                remove(m2,k1);\\n                add(m2,k2);\\n            }\\n            add(m1,k1);\\n        }\\n        return false;\\n    }\\n\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> u1(26,0);\\n        vector<int> u2(26,0);\\n        int d1 = 0, d2 = 0;\\n        // Bin frequency and unique count of word1\\n        for (auto &c : word1) {\\n            if (u1[c-\\'a\\'] == 0)\\n                d1++;\\n            u1[c-\\'a\\']++;\\n        }\\n        // Bin frequency and unique count of word2\\n        for (auto &c : word2) {\\n            if (u2[c-\\'a\\'] == 0)\\n                d2++;\\n            u2[c-\\'a\\']++;\\n        }\\n        \\n        // if same frequencey and have common character then self swap is sufficient\\n        if (d1 == d2) {\\n            for (int i = 0; i < 26; i++) {\\n                if (u1[i] && u2[i]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        // else try swap between all unique character of word1 vs word2\\n        for (int i = 0; i < 26; i++) {\\n            if (u1[i]) {\\n                for (int j = 0; j < 26; j++) {\\n                    if ((i != j) && u2[j]) {\\n                        // if particular character is unique then it reduces frequencey by 1\\n                        // if incoming swap is unique for target word then increase the frequency by 1\\n                        int n1 = d1 - (u1[i] == 1) + (u1[j] == 0);\\n                        int n2 = d2 - (u2[j] == 1) + (u2[i] == 0);\\n                        // if after swap frequency matches then return true\\n                        if (n1 == n2)\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing um = unordered_map<char,int>;\\n    void add(um &m, char c) {\\n        m[c]++;\\n    }\\n    void remove(um &m, char c) {\\n        m[c]--;\\n        if (m[c] == 0)\\n            m.erase(c);\\n    }\\n    \\n    bool isItPossible(string word1, string word2) {\\n        um m1,m2;\\n        vector<char> u1,u2;\\n        for (auto &c : word1) \\n            m1[c]++;\\n        for (auto &c : word2)\\n            m2[c]++;\\n        for (auto &k : m1)\\n            u1.push_back(k.first);\\n        for (auto &k : m2)\\n            u2.push_back(k.first);\\n        \\n        for (auto &k1 : u1) {\\n            remove(m1,k1);\\n            for (auto &k2 : u2) {\\n                remove(m2,k2);\\n                add(m1,k2);\\n                add(m2,k1);\\n                if (m1.size() == m2.size())\\n                    return true;\\n                remove(m1,k2);\\n                remove(m2,k1);\\n                add(m2,k2);\\n            }\\n            add(m1,k1);\\n        }\\n        return false;\\n    }\\n\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> u1(26,0);\\n        vector<int> u2(26,0);\\n        int d1 = 0, d2 = 0;\\n        // Bin frequency and unique count of word1\\n        for (auto &c : word1) {\\n            if (u1[c-\\'a\\'] == 0)\\n                d1++;\\n            u1[c-\\'a\\']++;\\n        }\\n        // Bin frequency and unique count of word2\\n        for (auto &c : word2) {\\n            if (u2[c-\\'a\\'] == 0)\\n                d2++;\\n            u2[c-\\'a\\']++;\\n        }\\n        \\n        // if same frequencey and have common character then self swap is sufficient\\n        if (d1 == d2) {\\n            for (int i = 0; i < 26; i++) {\\n                if (u1[i] && u2[i]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        // else try swap between all unique character of word1 vs word2\\n        for (int i = 0; i < 26; i++) {\\n            if (u1[i]) {\\n                for (int j = 0; j < 26; j++) {\\n                    if ((i != j) && u2[j]) {\\n                        // if particular character is unique then it reduces frequencey by 1\\n                        // if incoming swap is unique for target word then increase the frequency by 1\\n                        int n1 = d1 - (u1[i] == 1) + (u1[j] == 0);\\n                        int n2 = d2 - (u2[j] == 1) + (u2[i] == 0);\\n                        // if after swap frequency matches then return true\\n                        if (n1 == n2)\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083291,
                "title": "c-brute-force",
                "content": "# Intuition\\nThink of all possible pairs of exchanging characters.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n + m + 26 * 26)$$\\n\\n- Space complexity:\\n$$O(26)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> cnt1(26);\\n        vector<int> cnt2(26);\\n        int dis1 = 0;\\n        int dis2 = 0;\\n        for (char c : word1) {\\n            ++cnt1[c - \\'a\\'];\\n            if (cnt1[c - \\'a\\'] == 1) {\\n                ++dis1;\\n            }\\n        }\\n        for (char c : word2) {\\n            ++cnt2[c - \\'a\\'];\\n            if (cnt2[c - \\'a\\'] == 1) {\\n                ++dis2;\\n            }\\n        }\\n        for (int i = 0; i < 26; ++i) {\\n            for (int j = 0; j < 26; ++j) {\\n                int cur_dis1 = dis1, cur_dis2 = dis2;\\n                if (cnt1[i] > 0 && cnt2[j] > 0) {\\n                    if (i == j) {\\n                        if (dis1 == dis2) {\\n                            return true;\\n                        } else {\\n                            continue;\\n                        }\\n                    }\\n                    if (cnt1[i] == 1) cur_dis1 -= 1;\\n                    if (cnt1[j] == 0) cur_dis1 += 1;\\n                    if (cnt2[i] == 0) cur_dis2 += 1;\\n                    if (cnt2[j] == 1) cur_dis2 -= 1;    \\n                    if (cur_dis1 == cur_dis2) {\\n                        cout << i << \" \" << j << endl;\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> cnt1(26);\\n        vector<int> cnt2(26);\\n        int dis1 = 0;\\n        int dis2 = 0;\\n        for (char c : word1) {\\n            ++cnt1[c - \\'a\\'];\\n            if (cnt1[c - \\'a\\'] == 1) {\\n                ++dis1;\\n            }\\n        }\\n        for (char c : word2) {\\n            ++cnt2[c - \\'a\\'];\\n            if (cnt2[c - \\'a\\'] == 1) {\\n                ++dis2;\\n            }\\n        }\\n        for (int i = 0; i < 26; ++i) {\\n            for (int j = 0; j < 26; ++j) {\\n                int cur_dis1 = dis1, cur_dis2 = dis2;\\n                if (cnt1[i] > 0 && cnt2[j] > 0) {\\n                    if (i == j) {\\n                        if (dis1 == dis2) {\\n                            return true;\\n                        } else {\\n                            continue;\\n                        }\\n                    }\\n                    if (cnt1[i] == 1) cur_dis1 -= 1;\\n                    if (cnt1[j] == 0) cur_dis1 += 1;\\n                    if (cnt2[i] == 0) cur_dis2 += 1;\\n                    if (cnt2[j] == 1) cur_dis2 -= 1;    \\n                    if (cur_dis1 == cur_dis2) {\\n                        cout << i << \" \" << j << endl;\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3080449,
                "title": "brute-force-swap-set-trick-to-avoid-tle-super-easy-python-solution",
                "content": "# Complexity\\n- Time complexity: O(n*n)\\n\\n# Code\\n```python []\\nfrom collections import Counter\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        word1_map = Counter(word1)\\n        word1_dn = 0\\n        for k in word1_map.keys():\\n            word1_dn += 1\\n        word2_map = Counter(word2)\\n        word2_dn = 0\\n        for k in word2_map.keys():\\n            word2_dn += 1\\n\\n        for chr1 in set(word1):\\n            for chr2 in set(word2):\\n                # chr2 added in word1\\n                word1_map[chr2] += 1\\n                if word1_map[chr2] == 1:\\n                    word1_dn += 1\\n                word2_map[chr2] -= 1\\n                if word2_map[chr2] == 0:\\n                    word2_dn -= 1\\n                \\n                # chr1 added in word2\\n                word2_map[chr1] += 1\\n                if word2_map[chr1] == 1:\\n                    word2_dn += 1\\n                word1_map[chr1] -= 1\\n                if word1_map[chr1] == 0:\\n                    word1_dn -= 1\\n\\n\\n                # check\\n                if word1_dn == word2_dn: return True\\n\\n\\n                # chr2 removed from word1\\n                word1_map[chr2] -= 1\\n                if word1_map[chr2] == 0:\\n                    word1_dn -= 1\\n                word2_map[chr2] += 1\\n                if word2_map[chr2] == 1:\\n                    word2_dn += 1\\n\\n                # chr1 removed from word2\\n                word2_map[chr1] -= 1\\n                if word2_map[chr1] == 0:\\n                    word2_dn -= 1\\n                word1_map[chr1] += 1\\n                if word1_map[chr1] == 1:\\n                    word1_dn += 1\\n\\n        return False\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```python []\\nfrom collections import Counter\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        word1_map = Counter(word1)\\n        word1_dn = 0\\n        for k in word1_map.keys():\\n            word1_dn += 1\\n        word2_map = Counter(word2)\\n        word2_dn = 0\\n        for k in word2_map.keys():\\n            word2_dn += 1\\n\\n        for chr1 in set(word1):\\n            for chr2 in set(word2):\\n                # chr2 added in word1\\n                word1_map[chr2] += 1\\n                if word1_map[chr2] == 1:\\n                    word1_dn += 1\\n                word2_map[chr2] -= 1\\n                if word2_map[chr2] == 0:\\n                    word2_dn -= 1\\n                \\n                # chr1 added in word2\\n                word2_map[chr1] += 1\\n                if word2_map[chr1] == 1:\\n                    word2_dn += 1\\n                word1_map[chr1] -= 1\\n                if word1_map[chr1] == 0:\\n                    word1_dn -= 1\\n\\n\\n                # check\\n                if word1_dn == word2_dn: return True\\n\\n\\n                # chr2 removed from word1\\n                word1_map[chr2] -= 1\\n                if word1_map[chr2] == 0:\\n                    word1_dn -= 1\\n                word2_map[chr2] += 1\\n                if word2_map[chr2] == 1:\\n                    word2_dn += 1\\n\\n                # chr1 removed from word2\\n                word2_map[chr1] -= 1\\n                if word2_map[chr1] == 0:\\n                    word2_dn -= 1\\n                word1_map[chr1] += 1\\n                if word1_map[chr1] == 1:\\n                    word1_dn += 1\\n\\n        return False\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072842,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(26 x 26 x 26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2x26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public boolean isItPossible(String word1, String word2) {\\n        int one[] = new int[26];\\n        int two[] = new int[26];\\n        for (int i = 0; i < word1.length(); i++) {\\n            int pos = word1.charAt(i) - \\'a\\';\\n            one[pos]++;\\n        }\\n        for (int i = 0; i < word2.length(); i++) {\\n            int pos = word2.charAt(i) - \\'a\\';\\n            two[pos]++;\\n        }\\n        /*System.out.println(Arrays.toString(one));\\n        System.out.println(Arrays.toString(two));*/\\n        for (int i = 0; i < 26; i++) {\\n            if(one[i]==0)\\n                continue;\\n            one[i]--;\\n\\n            for (int j = 0; j < 26; j++) {\\n                if(two[j]==0)\\n                    continue;\\n                two[i]++;\\n                one[j]++;\\n                two[j]--;\\n                long x= Arrays.stream(one).filter(a->a!=0).count();\\n                long y=Arrays.stream(two).filter(a->a!=0).count();\\n                if (x==y)\\n                    return true;\\n                two[i]--;\\n                one[j]--;\\n                two[j]++;\\n\\n            }\\n            one[i]++;\\n           \\n\\n        }\\n        return false;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public boolean isItPossible(String word1, String word2) {\\n        int one[] = new int[26];\\n        int two[] = new int[26];\\n        for (int i = 0; i < word1.length(); i++) {\\n            int pos = word1.charAt(i) - \\'a\\';\\n            one[pos]++;\\n        }\\n        for (int i = 0; i < word2.length(); i++) {\\n            int pos = word2.charAt(i) - \\'a\\';\\n            two[pos]++;\\n        }\\n        /*System.out.println(Arrays.toString(one));\\n        System.out.println(Arrays.toString(two));*/\\n        for (int i = 0; i < 26; i++) {\\n            if(one[i]==0)\\n                continue;\\n            one[i]--;\\n\\n            for (int j = 0; j < 26; j++) {\\n                if(two[j]==0)\\n                    continue;\\n                two[i]++;\\n                one[j]++;\\n                two[j]--;\\n                long x= Arrays.stream(one).filter(a->a!=0).count();\\n                long y=Arrays.stream(two).filter(a->a!=0).count();\\n                if (x==y)\\n                    return true;\\n                two[i]--;\\n                one[j]--;\\n                two[j]++;\\n\\n            }\\n            one[i]++;\\n           \\n\\n        }\\n        return false;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072290,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    void insertAndRemove(unordered_map<char,int>&mp, char toInsert, char toRemove){  \\n        mp[toInsert]++;    \\n        mp[toRemove]--;     \\n        if(mp[toRemove]==0) mp.erase(toRemove);  \\n    }\\n\\t\\n    \\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> mp1, mp2;\\n        \\n        for(char w1: word1) mp1[w1]++;   \\n        for(char w2: word2) mp2[w2]++;  \\n\\n        for(char c1=\\'a\\'; c1<=\\'z\\'; c1++){\\n            for(char c2=\\'a\\'; c2<=\\'z\\'; c2++){\\n                if(mp1.count(c1)==0 || mp2.count(c2)==0) continue; \\n\\t\\t\\t\\t\\n                insertAndRemove(mp1, c2, c1); \\n                insertAndRemove(mp2, c1, c2); \\n                \\n                if(mp1.size()==mp2.size()) return true; \\n\\t\\t\\t\\t\\n                insertAndRemove(mp1, c1, c2);\\n                insertAndRemove(mp2, c2, c1); \\n                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void insertAndRemove(unordered_map<char,int>&mp, char toInsert, char toRemove){  \\n        mp[toInsert]++;    \\n        mp[toRemove]--;     \\n        if(mp[toRemove]==0) mp.erase(toRemove);  \\n    }\\n\\t\\n    \\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> mp1, mp2;\\n        \\n        for(char w1: word1) mp1[w1]++;   \\n        for(char w2: word2) mp2[w2]++;  \\n\\n        for(char c1=\\'a\\'; c1<=\\'z\\'; c1++){\\n            for(char c2=\\'a\\'; c2<=\\'z\\'; c2++){\\n                if(mp1.count(c1)==0 || mp2.count(c2)==0) continue; \\n\\t\\t\\t\\t\\n                insertAndRemove(mp1, c2, c1); \\n                insertAndRemove(mp2, c1, c2); \\n                \\n                if(mp1.size()==mp2.size()) return true; \\n\\t\\t\\t\\t\\n                insertAndRemove(mp1, c1, c2);\\n                insertAndRemove(mp2, c2, c1); \\n                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070909,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int numOfLetters = 26;\\n        int[] letters1 = new int[numOfLetters];\\n        int[] letters2 = new int[numOfLetters];\\n\\n        char[] chars1 = word1.toCharArray();\\n        char[] chars2 = word2.toCharArray();\\n\\n        for (char c : chars1) {\\n            letters1[c - \\'a\\']++;\\n        }\\n\\n        for (char c : chars2) {\\n            letters2[c - \\'a\\']++;\\n        }\\n\\n        int numOfDistincts1 = countDistincts(letters1);\\n        int numOfDistincts2 = countDistincts(letters2);\\n\\n        for (int i = 0; i < numOfLetters; i++) {\\n            boolean isEqual = swapAndCompare(i, letters1, numOfDistincts1, letters2, numOfDistincts2);\\n            if (isEqual) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean swapAndCompare(int i, int[] l1, int initialSize1, int[] l2, int initialSize2) {\\n        for (int j = 0; j < l2.length; j++) {\\n            // RESET SIZES\\n            int size1 = initialSize1;\\n            int size2 = initialSize2;\\n         \\n            // DECREASE\\n            int count1ToDecrease = l1[i];\\n            int count2ToDecrease = l2[j];\\n\\n            if (count1ToDecrease * count2ToDecrease == 0) continue;\\n            if (i == j) {\\n                if (size1 == size2) return true;\\n                continue;\\n            };\\n\\n            count1ToDecrease--;\\n            count2ToDecrease--;\\n            if (count1ToDecrease == 0) size1--;\\n            if (count2ToDecrease == 0) size2--;\\n            \\n            // INCREASE\\n            int count1ToIncrease = l1[j];\\n            int count2ToIncrease = l2[i];\\n\\n            count1ToIncrease++;\\n            count2ToIncrease++;\\n            if (count1ToIncrease == 1) size1++;\\n            if (count2ToIncrease == 1) size2++;\\n\\n            if (size1 == size2) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private int countDistincts(int[] letters) {\\n        int count = 0;\\n\\n        for (int lCount : letters) {\\n            if (lCount > 0) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int numOfLetters = 26;\\n        int[] letters1 = new int[numOfLetters];\\n        int[] letters2 = new int[numOfLetters];\\n\\n        char[] chars1 = word1.toCharArray();\\n        char[] chars2 = word2.toCharArray();\\n\\n        for (char c : chars1) {\\n            letters1[c - \\'a\\']++;\\n        }\\n\\n        for (char c : chars2) {\\n            letters2[c - \\'a\\']++;\\n        }\\n\\n        int numOfDistincts1 = countDistincts(letters1);\\n        int numOfDistincts2 = countDistincts(letters2);\\n\\n        for (int i = 0; i < numOfLetters; i++) {\\n            boolean isEqual = swapAndCompare(i, letters1, numOfDistincts1, letters2, numOfDistincts2);\\n            if (isEqual) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean swapAndCompare(int i, int[] l1, int initialSize1, int[] l2, int initialSize2) {\\n        for (int j = 0; j < l2.length; j++) {\\n            // RESET SIZES\\n            int size1 = initialSize1;\\n            int size2 = initialSize2;\\n         \\n            // DECREASE\\n            int count1ToDecrease = l1[i];\\n            int count2ToDecrease = l2[j];\\n\\n            if (count1ToDecrease * count2ToDecrease == 0) continue;\\n            if (i == j) {\\n                if (size1 == size2) return true;\\n                continue;\\n            };\\n\\n            count1ToDecrease--;\\n            count2ToDecrease--;\\n            if (count1ToDecrease == 0) size1--;\\n            if (count2ToDecrease == 0) size2--;\\n            \\n            // INCREASE\\n            int count1ToIncrease = l1[j];\\n            int count2ToIncrease = l2[i];\\n\\n            count1ToIncrease++;\\n            count2ToIncrease++;\\n            if (count1ToIncrease == 1) size1++;\\n            if (count2ToIncrease == 1) size2++;\\n\\n            if (size1 == size2) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private int countDistincts(int[] letters) {\\n        int count = 0;\\n\\n        for (int lCount : letters) {\\n            if (lCount > 0) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070083,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Observe the question.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    count the alphabets in each words and swap it.\\n    if size of map is equal then it\\'s true.\\n# Complexity\\n- Time complexity:\\n    26*26\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    4 maps\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n       map<char, int> m1;\\n       map<char, int> m2;\\n\\n       for(auto c : word1)\\n       {\\n           m1[c]++;\\n       }\\n\\n        for(auto c : word2)\\n       {\\n           m2[c]++;\\n       }\\n\\n        //int diff = m1.size() - m2.size();\\n\\n        //if(abs(diff) >= 2)\\n            //return false;\\n\\n        cout<< m1.size() << \" \" << m2.size();\\n        for(auto c1 : m1){\\n            for(auto c2 : m2)\\n            {\\n                char temp1 = c1.first, temp2 = c2.first;\\n                auto mm1 = m1, mm2 = m2;\\n                mm1[temp1]--;\\n                if(mm1[temp1] == 0)\\n                    mm1.erase(temp1);\\n                mm2[temp1]++;\\n                mm2[temp2]--;\\n                if( mm2[temp2]==0)\\n                    mm2.erase(temp2);\\n                mm1[temp2]++;\\n                //cout << temp1 << \" \" << temp2 << \" \"<<m1[temp2] << \" \" << m2[temp1]<<endl;\\n\\n                if(mm1.size() == mm2.size())\\n                    return true;\\n            }\\n        }\\n\\n       return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n       map<char, int> m1;\\n       map<char, int> m2;\\n\\n       for(auto c : word1)\\n       {\\n           m1[c]++;\\n       }\\n\\n        for(auto c : word2)\\n       {\\n           m2[c]++;\\n       }\\n\\n        //int diff = m1.size() - m2.size();\\n\\n        //if(abs(diff) >= 2)\\n            //return false;\\n\\n        cout<< m1.size() << \" \" << m2.size();\\n        for(auto c1 : m1){\\n            for(auto c2 : m2)\\n            {\\n                char temp1 = c1.first, temp2 = c2.first;\\n                auto mm1 = m1, mm2 = m2;\\n                mm1[temp1]--;\\n                if(mm1[temp1] == 0)\\n                    mm1.erase(temp1);\\n                mm2[temp1]++;\\n                mm2[temp2]--;\\n                if( mm2[temp2]==0)\\n                    mm2.erase(temp2);\\n                mm1[temp2]++;\\n                //cout << temp1 << \" \" << temp2 << \" \"<<m1[temp2] << \" \" << m2[temp1]<<endl;\\n\\n                if(mm1.size() == mm2.size())\\n                    return true;\\n            }\\n        }\\n\\n       return false;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3068268,
                "title": "c-hash-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /* \\nMethod:\\n\\nCreate two maps to store frequency of characters of the strings.\\n\\nTry swapping all possible pairs of alphabets between word1 and word2.\\n\\nHow do we try swapping all possible pairs of alphabets between word1 and word2?\\n2.1 Create two for loops iterating c1: \\'a\\' to \\'z\\', c2: \\'a\\' to \\'z\\'\\n2.2 When char c1 is in word1 and char c2 is in word2\\n2.3 Remove c1 and put c2 in word1\\'s map\\n2.4 Remove c2 and put c1 in word2\\'s map\\n\\nNow check the sizes of maps. If the maps\\' sizes are same means both words now have equal distinct characters. So, return true\\n\\nIf map sizes are not same then reset the maps back.\\n\\nHow do we reset the maps?\\n4.1 Remove c2 and put back c1 in word1\\'s map (opposite of 2.3)\\n4.2 Remove c1 and put back c2 in word2\\'s map (opposite of 2.4)\\n    */\\n    bool isItPossible(string word1, string word2) {\\n        map<char, int> mp1;\\n        map<char, int> mp2;\\n\\n        for(auto i: word1) mp1[i]++;\\n        for(auto i: word2) mp2[i]++;\\n\\n        for(char i = \\'a\\'; i <= \\'z\\'; i++) {\\n            for(char j = \\'a\\'; j <= \\'z\\'; j++) {\\n                if(mp1.count(i) and mp2.count(j)) {\\n                    mp1[i]--; // remove\\n                    if(mp1[i] == 0) mp1.erase(i);\\n                    mp1[j]++; // add\\n\\n                    mp2[j]--; // remove\\n                    if(mp2[j] == 0) mp2.erase(j);\\n                    mp2[i]++; // add\\n\\n                    if(mp1.size() == mp2.size()) return true;\\n\\n                    mp1[j]--;\\n                    if(mp1[j] == 0) mp1.erase(j);\\n\\n                    mp2[i]--;\\n                    if(mp2[i] == 0) mp2.erase(i);\\n\\n                    mp1[i]++;\\n                    mp2[j]++;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* \\nMethod:\\n\\nCreate two maps to store frequency of characters of the strings.\\n\\nTry swapping all possible pairs of alphabets between word1 and word2.\\n\\nHow do we try swapping all possible pairs of alphabets between word1 and word2?\\n2.1 Create two for loops iterating c1: \\'a\\' to \\'z\\', c2: \\'a\\' to \\'z\\'\\n2.2 When char c1 is in word1 and char c2 is in word2\\n2.3 Remove c1 and put c2 in word1\\'s map\\n2.4 Remove c2 and put c1 in word2\\'s map\\n\\nNow check the sizes of maps. If the maps\\' sizes are same means both words now have equal distinct characters. So, return true\\n\\nIf map sizes are not same then reset the maps back.\\n\\nHow do we reset the maps?\\n4.1 Remove c2 and put back c1 in word1\\'s map (opposite of 2.3)\\n4.2 Remove c1 and put back c2 in word2\\'s map (opposite of 2.4)\\n    */\\n    bool isItPossible(string word1, string word2) {\\n        map<char, int> mp1;\\n        map<char, int> mp2;\\n\\n        for(auto i: word1) mp1[i]++;\\n        for(auto i: word2) mp2[i]++;\\n\\n        for(char i = \\'a\\'; i <= \\'z\\'; i++) {\\n            for(char j = \\'a\\'; j <= \\'z\\'; j++) {\\n                if(mp1.count(i) and mp2.count(j)) {\\n                    mp1[i]--; // remove\\n                    if(mp1[i] == 0) mp1.erase(i);\\n                    mp1[j]++; // add\\n\\n                    mp2[j]--; // remove\\n                    if(mp2[j] == 0) mp2.erase(j);\\n                    mp2[i]++; // add\\n\\n                    if(mp1.size() == mp2.size()) return true;\\n\\n                    mp1[j]--;\\n                    if(mp1[j] == 0) mp1.erase(j);\\n\\n                    mp2[i]--;\\n                    if(mp2[i] == 0) mp2.erase(i);\\n\\n                    mp1[i]++;\\n                    mp2[j]++;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062568,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(max(26*26*26, max(size(word1, word2)))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> arr1(26), arr2(26);\\n        for (char c : word1) \\n            arr1[c - \\'a\\']++;\\n        for (char c : word2) \\n            arr2[c - \\'a\\']++;\\n\\n        auto cnt_distinct = [&] (vector<int> arr) {\\n            int cnt = 0;\\n            for (int i = 0; i < 26; i++) {\\n                if (arr[i]) \\n                    cnt++;\\n            }\\n            return cnt;\\n        };\\n        vector<int> v1, v2;\\n        for(char c1 = \\'a\\'; c1 <= \\'z\\'; c1++) {\\n            for (char c2 = \\'a\\'; c2 <= \\'z\\'; c2++) {\\n                v1 = arr1, v2 = arr2;\\n                if(v1[c1 - \\'a\\'] > 0 && v2[c2 - \\'a\\'] > 0) {\\n                    v1[c1 - \\'a\\'] --;\\n                    v2[c1 - \\'a\\'] ++;\\n                    v2[c2 - \\'a\\'] --;\\n                    v1[c2 - \\'a\\'] ++;\\n                    if (cnt_distinct(v1) == cnt_distinct(v2))\\n                        return true;\\n                } \\n            }\\n        }   \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> arr1(26), arr2(26);\\n        for (char c : word1) \\n            arr1[c - \\'a\\']++;\\n        for (char c : word2) \\n            arr2[c - \\'a\\']++;\\n\\n        auto cnt_distinct = [&] (vector<int> arr) {\\n            int cnt = 0;\\n            for (int i = 0; i < 26; i++) {\\n                if (arr[i]) \\n                    cnt++;\\n            }\\n            return cnt;\\n        };\\n        vector<int> v1, v2;\\n        for(char c1 = \\'a\\'; c1 <= \\'z\\'; c1++) {\\n            for (char c2 = \\'a\\'; c2 <= \\'z\\'; c2++) {\\n                v1 = arr1, v2 = arr2;\\n                if(v1[c1 - \\'a\\'] > 0 && v2[c2 - \\'a\\'] > 0) {\\n                    v1[c1 - \\'a\\'] --;\\n                    v2[c1 - \\'a\\'] ++;\\n                    v2[c2 - \\'a\\'] --;\\n                    v1[c2 - \\'a\\'] ++;\\n                    if (cnt_distinct(v1) == cnt_distinct(v2))\\n                        return true;\\n                } \\n            }\\n        }   \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062138,
                "title": "clear-solution-in-java",
                "content": "\\n# Approach\\n We are comparing 26 character of word1 with 26 character of word2 , first we swap and check after swapping count of distinct character is equal or not if not then reswap and put in original location in map and try with aother char if count equal return true. \\n\\n# Complexity\\n- Time complexity: 26 * 26\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        HashMap<Character , Integer> map1 = new  HashMap<>();\\n        char ch1[] = word1.toCharArray();\\n        char ch2[] = word2.toCharArray();\\n        \\n        for(char ch : ch1){\\n            map1.put(ch , map1.getOrDefault(ch , 0 )+ 1);\\n        }\\n          HashMap<Character , Integer> map2 = new  HashMap<>();\\n         for(char ch : ch2){\\n            map2.put(ch , map2.getOrDefault(ch , 0 )+ 1);\\n        }\\n        \\n        for(char i = \\'a\\' ; i <= \\'z\\' ; i++)\\n        {\\n            for(char j = \\'a\\' ; j <= \\'z\\' ; j++)\\n            {\\n                if(map1.getOrDefault(i , 0) > 0 && map2.getOrDefault(j , 0) > 0 )\\n                {\\n                    // swap the to character \\n                   map1.put(j , map1.getOrDefault(j , 0) +1);\\n                   map1.put(i , map1.get(i) - 1);\\n                    if(map1.get(i) == 0){\\n                        map1.remove(i);\\n                    }\\n                    \\n                  map2.put(i , map2.getOrDefault(i , 0) +1);\\n                  map2.put(j , map2.get(j)- 1 );\\n                    if(map2.get(j) == 0){\\n                        map2.remove(j);\\n                    }\\n                    \\n                    // check distinct char are equal\\n                    if(map1.size() == map2.size())return true;\\n                    \\n                    // put in original position reswap\\n                    map1.put(i , map1.getOrDefault(i , 0) +1);\\n                   map1.put(j , map1.get(j) - 1);\\n                    if(map1.get(j) == 0){\\n                        map1.remove(j);\\n                    }\\n                    \\n                  map2.put(j , map2.getOrDefault(j , 0) +1);\\n                  map2.put(i , map2.get(i)- 1 );\\n                    if(map2.get(i) == 0){\\n                        map2.remove(i);\\n                    }\\n                }\\n            }\\n        }\\n      \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        HashMap<Character , Integer> map1 = new  HashMap<>();\\n        char ch1[] = word1.toCharArray();\\n        char ch2[] = word2.toCharArray();\\n        \\n        for(char ch : ch1){\\n            map1.put(ch , map1.getOrDefault(ch , 0 )+ 1);\\n        }\\n          HashMap<Character , Integer> map2 = new  HashMap<>();\\n         for(char ch : ch2){\\n            map2.put(ch , map2.getOrDefault(ch , 0 )+ 1);\\n        }\\n        \\n        for(char i = \\'a\\' ; i <= \\'z\\' ; i++)\\n        {\\n            for(char j = \\'a\\' ; j <= \\'z\\' ; j++)\\n            {\\n                if(map1.getOrDefault(i , 0) > 0 && map2.getOrDefault(j , 0) > 0 )\\n                {\\n                    // swap the to character \\n                   map1.put(j , map1.getOrDefault(j , 0) +1);\\n                   map1.put(i , map1.get(i) - 1);\\n                    if(map1.get(i) == 0){\\n                        map1.remove(i);\\n                    }\\n                    \\n                  map2.put(i , map2.getOrDefault(i , 0) +1);\\n                  map2.put(j , map2.get(j)- 1 );\\n                    if(map2.get(j) == 0){\\n                        map2.remove(j);\\n                    }\\n                    \\n                    // check distinct char are equal\\n                    if(map1.size() == map2.size())return true;\\n                    \\n                    // put in original position reswap\\n                    map1.put(i , map1.getOrDefault(i , 0) +1);\\n                   map1.put(j , map1.get(j) - 1);\\n                    if(map1.get(j) == 0){\\n                        map1.remove(j);\\n                    }\\n                    \\n                  map2.put(j , map2.getOrDefault(j , 0) +1);\\n                  map2.put(i , map2.get(i)- 1 );\\n                    if(map2.get(i) == 0){\\n                        map2.remove(i);\\n                    }\\n                }\\n            }\\n        }\\n      \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058305,
                "title": "java-beats-99-86-83-2",
                "content": "# Intuition\\nTry all combinations and if met the condition return true, else continue till the end.\\nIf not found, return false.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int numOfLetters = 26;\\n        int[] letters1 = new int[numOfLetters];\\n        int[] letters2 = new int[numOfLetters];\\n\\n        char[] chars1 = word1.toCharArray();\\n        char[] chars2 = word2.toCharArray();\\n\\n        for (char c : chars1) {\\n            letters1[c - \\'a\\']++;\\n        }\\n\\n        for (char c : chars2) {\\n            letters2[c - \\'a\\']++;\\n        }\\n\\n        int numOfDistincts1 = countDistincts(letters1);\\n        int numOfDistincts2 = countDistincts(letters2);\\n\\n        for (int i = 0; i < numOfLetters; i++) {\\n            boolean isEqual = swapAndCompare(i, letters1, numOfDistincts1, letters2, numOfDistincts2);\\n            if (isEqual) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean swapAndCompare(int i, int[] l1, int initialSize1, int[] l2, int initialSize2) {\\n        for (int j = 0; j < l2.length; j++) {\\n            // RESET SIZES\\n            int size1 = initialSize1;\\n            int size2 = initialSize2;\\n         \\n            // DECREASE\\n            int count1ToDecrease = l1[i];\\n            int count2ToDecrease = l2[j];\\n\\n            if (count1ToDecrease * count2ToDecrease == 0) continue;\\n            if (i == j) {\\n                if (size1 == size2) return true;\\n                continue;\\n            };\\n\\n            count1ToDecrease--;\\n            count2ToDecrease--;\\n            if (count1ToDecrease == 0) size1--;\\n            if (count2ToDecrease == 0) size2--;\\n            \\n            // INCREASE\\n            int count1ToIncrease = l1[j];\\n            int count2ToIncrease = l2[i];\\n\\n            count1ToIncrease++;\\n            count2ToIncrease++;\\n            if (count1ToIncrease == 1) size1++;\\n            if (count2ToIncrease == 1) size2++;\\n\\n            if (size1 == size2) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private int countDistincts(int[] letters) {\\n        int count = 0;\\n\\n        for (int lCount : letters) {\\n            if (lCount > 0) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int numOfLetters = 26;\\n        int[] letters1 = new int[numOfLetters];\\n        int[] letters2 = new int[numOfLetters];\\n\\n        char[] chars1 = word1.toCharArray();\\n        char[] chars2 = word2.toCharArray();\\n\\n        for (char c : chars1) {\\n            letters1[c - \\'a\\']++;\\n        }\\n\\n        for (char c : chars2) {\\n            letters2[c - \\'a\\']++;\\n        }\\n\\n        int numOfDistincts1 = countDistincts(letters1);\\n        int numOfDistincts2 = countDistincts(letters2);\\n\\n        for (int i = 0; i < numOfLetters; i++) {\\n            boolean isEqual = swapAndCompare(i, letters1, numOfDistincts1, letters2, numOfDistincts2);\\n            if (isEqual) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean swapAndCompare(int i, int[] l1, int initialSize1, int[] l2, int initialSize2) {\\n        for (int j = 0; j < l2.length; j++) {\\n            // RESET SIZES\\n            int size1 = initialSize1;\\n            int size2 = initialSize2;\\n         \\n            // DECREASE\\n            int count1ToDecrease = l1[i];\\n            int count2ToDecrease = l2[j];\\n\\n            if (count1ToDecrease * count2ToDecrease == 0) continue;\\n            if (i == j) {\\n                if (size1 == size2) return true;\\n                continue;\\n            };\\n\\n            count1ToDecrease--;\\n            count2ToDecrease--;\\n            if (count1ToDecrease == 0) size1--;\\n            if (count2ToDecrease == 0) size2--;\\n            \\n            // INCREASE\\n            int count1ToIncrease = l1[j];\\n            int count2ToIncrease = l2[i];\\n\\n            count1ToIncrease++;\\n            count2ToIncrease++;\\n            if (count1ToIncrease == 1) size1++;\\n            if (count2ToIncrease == 1) size2++;\\n\\n            if (size1 == size2) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private int countDistincts(int[] letters) {\\n        int count = 0;\\n\\n        for (int lCount : letters) {\\n            if (lCount > 0) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054131,
                "title": "java-o-n-26-with-explanation",
                "content": "class Solution {\\n    /*\\n    CA:\\n    R:\\n        Int[26] to save all chars appearance \\n        \\n        total # of distinct -> big has more, small has less \\n        \\n        // i move from big to small\\n        // j move from small to big\\n        \\n        if big - small > 2 --> false, can\\'t reach\\n        \\n        if big - small == 2 \\n        \\n            i: B-1, S+1\\n            j: no impact\\n            \\n        if big - small == 1\\n            \\n            i: B - 1\\n            j: no impact \\n            \\n            or \\n            \\n            i: no impact\\n            j: S + 1\\n            \\n            or \\n            \\n            i: S++, B--\\n            j: B++\\n            \\n            or \\n            i: b--, s++\\n            j: s--\\n            \\n\\n            \\n        if big == small:\\n        \\n            i: no impact\\n            j: no impact\\n            \\n            or\\n        \\n            i: B - 1, S + 1 \\n            j: S - 1, B + 1          \\n            or \\n            \\n            i: B - 1\\n            j: B + 1\\n            \\n            or \\n            \\n            i: S + 1\\n            j: S - 1\\n            \\n            or \\n            \\n            i: S + 1\\n            j: B + 1\\n            \\n            or \\n            i: B - 1\\n            j: S - 1 ........\\n            \\n            ----- NO -->  too many conditions \\n            Try when fails\\n            \\n            when swap will definitely make changes on total dist\\n            \\n            one is all 1 appearance,  // must - 1 on b->s\\n            another is all >1 appearance  // must no change on s->b\\n            \\n            and they have no same chars\\n            \\n            \\n            \\n            TC: O(n)  // n as ave length of strings\\n            SC: O(1) // O(26)\\n    \\n    T:\\n    \\n    */\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] record1 = new int[26];\\n        int[] record2 = new int[26];\\n        \\n        int dist1 = getDist(word1, record1);\\n        int dist2 = getDist(word2, record2);\\n        \\n        switch(Math.abs(dist1 - dist2)) {\\n            case 0:\\n                return getRes0(record1, record2);\\n            case 1:\\n                return (dist1 > dist2) ? getRes1(record1, record2) : getRes1(record2, record1);\\n            case 2:\\n                return (dist1 > dist2) ? getRes2(record1, record2) : getRes2(record2, record1);\\n            default:\\n                return false;\\n        }\\n    }\\n    \\n    private int getDist(String word, int[] record) {\\n        int total = 0;\\n        for (int i = 0; i < word.length(); i++) {\\n            char cur = word.charAt(i);\\n            record[cur - \\'a\\']++;\\n            if (record[cur - \\'a\\'] == 1) {\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n        \\n        \\n    private boolean getRes2(int[] big, int[] small) {\\n        boolean flag1 = false;\\n        boolean flag2 = false;\\n        for (int i = 0; i < 26; i++) {\\n            if (big[i] == 1 && small[i] == 0 && !flag1) { // b - 1, s + 1\\n                flag1 = true;\\n            } else if (big[i] >= 1 && small[i] > 1) { // no impact\\n                flag2 = true;\\n            }\\n        }    \\n        return flag1 && flag2;\\n    }\\n    \\n    private boolean getRes1(int[] big, int[] small) {\\n        boolean flag1 = false;\\n        boolean flag2 = false;\\n        for (int i = 0; i < 26; i++) {\\n            if (big[i] == 1 && small[i] >= 1 && !flag1) { // b->s, b - 1\\n                flag1 = true;\\n            } else if (big[i] >= 1 && small[i] > 1) { // s->b\\n                flag2 = true;\\n            }\\n        }  \\n        \\n        boolean flag3 = false;\\n        boolean flag4 = false;        \\n        for (int i = 0; i < 26; i++) {\\n            if (big[i] > 1 && small[i] == 0 && !flag3) { // b->s, s + 1\\n                flag3 = true;\\n            } else if (big[i] >= 1 && small[i] > 1) { // s->b\\n                flag4 = true;\\n            }\\n        }  \\n        \\n        boolean flag5 = false;\\n        boolean flag6 = false;        \\n        for (int i = 0; i < 26; i++) {\\n            if (big[i] == 1 && small[i] == 0 && !flag5) { // b->s, s + 1 , b-1\\n                flag5 = true;\\n            } else if (big[i] == 0 && small[i] > 1) { // s->b, b++\\n                flag6 = true;\\n            }\\n        } \\n        \\n        boolean flag7 = false;\\n        boolean flag8 = false;        \\n        for (int i = 0; i < 26; i++) {\\n            if (big[i] == 1 && small[i] == 0 && !flag7) { // b->s, s + 1 , b-1\\n                flag7 = true;\\n            } else if (big[i] >= 1 && small[i] == 1) { // s->b, s--\\n                flag8 = true;\\n            }\\n        }  \\n              \\n        return flag1 && flag2 || flag3 && flag4 || flag5 && flag6 || flag7 && flag8;\\n    }\\n    \\n    private boolean getRes0(int[] a, int[] b) {\\n        int sumAone = 0;\\n        int sumBone = 0;\\n        int sumAmul = 0;\\n        int sumBmul = 0;\\n        int same = 0;\\n        \\n        for (int i = 0; i < 26; i++) {\\n            if (a[i] == 1) {\\n                sumAone++;\\n            } else if (a[i] > 1) {\\n                sumAmul++;\\n            }\\n            \\n            if (b[i] == 1) {\\n                sumBone++;\\n            } else if (b[i] > 1) {\\n                sumBmul++;\\n            }\\n            \\n            if (a[i] != 0 && b[i] != 0) {\\n                same++;\\n            }\\n        }\\n        \\n        return !((sumAone == 0 && sumBmul == 0 && same == 0) || (sumAmul == 0 && sumBone == 0 && same == 0));\\n    }\\n     \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    /*\\n    CA:\\n    R:\\n        Int[26] to save all chars appearance \\n        \\n        total # of distinct -> big has more, small has less \\n        \\n        // i move from big to small\\n        // j move from small to big\\n        \\n        if big - small > 2 --> false, can\\'t reach\\n        \\n        if big - small == 2 \\n        \\n            i: B-1, S+1\\n            j: no impact\\n            \\n        if big - small == 1\\n            \\n            i: B - 1\\n            j: no impact \\n            \\n            or \\n            \\n            i: no impact\\n            j: S + 1\\n            \\n            or \\n            \\n            i: S++, B--\\n            j: B++\\n            \\n            or \\n            i: b--, s++\\n            j: s--\\n            \\n\\n            \\n        if big == small:\\n        \\n            i: no impact\\n            j: no impact\\n            \\n            or\\n        \\n            i: B - 1, S + 1 \\n            j: S - 1, B + 1          \\n            or \\n            \\n            i: B - 1\\n            j: B + 1\\n            \\n            or \\n            \\n            i: S + 1\\n            j: S - 1\\n            \\n            or \\n            \\n            i: S + 1\\n            j: B + 1\\n            \\n            or \\n            i: B - 1\\n            j: S - 1 ........\\n            \\n            ----- NO -->  too many conditions \\n            Try when fails\\n            \\n            when swap will definitely make changes on total dist\\n            \\n            one is all 1 appearance,  // must - 1 on b->s\\n            another is all >1 appearance  // must no change on s->b\\n            \\n            and they have no same chars\\n            \\n            \\n            \\n            TC: O(n)  // n as ave length of strings\\n            SC: O(1) // O(26)\\n    \\n    T:\\n    \\n    */\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] record1 = new int[26];\\n        int[] record2 = new int[26];\\n        \\n        int dist1 = getDist(word1, record1);\\n        int dist2 = getDist(word2, record2);\\n        \\n        switch(Math.abs(dist1 - dist2)) {\\n            case 0:\\n                return getRes0(record1, record2);\\n            case 1:\\n                return (dist1 > dist2) ? getRes1(record1, record2) : getRes1(record2, record1);\\n            case 2:\\n                return (dist1 > dist2) ? getRes2(record1, record2) : getRes2(record2, record1);\\n            default:\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3052518,
                "title": "worst-solution-ever",
                "content": "# Worst Solution ever\\n\\n# Code\\n```\\n#include <cstdlib>\\n#include <iostream>\\n#include <stdlib.h>\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map <char, int> m1;\\n        unordered_map <char, int> m2;\\n        unordered_map <string, pair<vector<int>, vector<int>>> fq1;\\n        unordered_map <string, pair<vector<int>, vector<int>>> fq2;\\n        unordered_set <char> same;\\n        unordered_set <char> diff;\\n        \\n        string one = \"1\";\\n        string plus = \"+1\";\\n        \\n        for (auto c1 : word1)\\n            m1[c1]++;\\n    \\n        for (auto c2 : word2)\\n            m2[c2]++;\\n    \\n        int ddiff = m1.size() - m2.size();\\n        \\n        if (ddiff < 0) {\\n            ddiff = -1 * ddiff;\\n        }\\n    \\n        if (ddiff > 2)\\n            return false;\\n        \\n        \\n        for (auto i : m1) {\\n            if (m2.count(i.first)) {\\n                same.insert(i.first);\\n                if (m1[i.first] > 1) {\\n                    fq1[plus].first.push_back(i.first);\\n                } else {\\n                    fq1[one].first.push_back(i.first);\\n                }\\n            } else {\\n                diff.insert(i.first);\\n                if (m1[i.first] > 1) {\\n                    fq1[plus].second.push_back(i.first);\\n                } else {\\n                    fq1[one].second.push_back(i.first);\\n                }\\n            }\\n        }\\n        \\n        for (auto i : m2) {\\n            if (m1.count(i.first)) {\\n                 if (m2[i.first] > 1) {\\n                    fq2[plus].first.push_back(i.first);\\n                } else {\\n                    fq2[one].first.push_back(i.first);\\n                }   \\n            } else {\\n                if (m2[i.first] > 1) {\\n                    fq2[plus].second.push_back(i.first);\\n                } else {\\n                    fq2[one].second.push_back(i.first);\\n                }\\n            }\\n        }\\n        \\n        bool one_different = (fq2[one].second.size() && fq1[one].second.size());\\n        bool one_same = (fq2[one].first.size() && fq1[one].first.size());\\n        bool many_same = (fq2[plus].first.size() && fq1[plus].first.size());\\n        bool many_different = (fq2[plus].second.size() && fq1[plus].second.size());\\n        bool many_same_one_same_m1 = (fq2[plus].first.size() && fq1[one].first.size());\\n        bool many_same_one_same_m2 = (fq1[plus].first.size() && fq2[one].first.size());\\n        bool give_one_same_m1 = (fq1[one].first.size());\\n        bool take_many_same_m1 = (fq1[plus].first.size());\\n        bool take_many_same_m2 = (fq2[plus].first.size());\\n        bool give_one_same_m2 = (fq2[one].first.size());\\n        bool give_one_different_m1 = (fq1[one].second.size());\\n        bool give_one_different_m2 = (fq2[one].second.size());\\n        bool give_many_different_m1 = (fq1[plus].second.size());\\n        bool give_many_different_m2 = (fq2[plus].second.size());\\n        bool many_same_m2 = (fq2[plus].first.size() == 1);\\n        bool many_same_m1 = (fq1[plus].first.size() == 1);\\n        \\n    \\n        if (ddiff == 0) {\\n            if (same.size() == 0) {\\n                return one_different || many_different;\\n            } else if (diff.size() == 0) {\\n                return true;\\n            } else {\\n                return one_different || one_same || many_different || many_same || many_same_one_same_m1 || many_same_one_same_m2;\\n            }     \\n        }\\n        else if (ddiff == 1) {\\n            if (m1.size() > m2.size()) {\\n                return (give_one_same_m1 && take_many_same_m2 && !many_same_m2) || (take_many_same_m2 && give_many_different_m1)                     || (give_one_different_m1 && give_one_same_m2);\\n            } else {\\n                return (give_one_same_m2 && take_many_same_m1 && !many_same_m1) || (take_many_same_m1 && give_many_different_m2) || (give_one_different_m2 && give_one_same_m1);\\n            }\\n        } else {\\n            if (m1.size() > m2.size()) {\\n                return give_one_different_m1 && take_many_same_m2;\\n            } else {\\n                return give_one_different_m2 && take_many_same_m1;\\n            }\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <cstdlib>\\n#include <iostream>\\n#include <stdlib.h>\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map <char, int> m1;\\n        unordered_map <char, int> m2;\\n        unordered_map <string, pair<vector<int>, vector<int>>> fq1;\\n        unordered_map <string, pair<vector<int>, vector<int>>> fq2;\\n        unordered_set <char> same;\\n        unordered_set <char> diff;\\n        \\n        string one = \"1\";\\n        string plus = \"+1\";\\n        \\n        for (auto c1 : word1)\\n            m1[c1]++;\\n    \\n        for (auto c2 : word2)\\n            m2[c2]++;\\n    \\n        int ddiff = m1.size() - m2.size();\\n        \\n        if (ddiff < 0) {\\n            ddiff = -1 * ddiff;\\n        }\\n    \\n        if (ddiff > 2)\\n            return false;\\n        \\n        \\n        for (auto i : m1) {\\n            if (m2.count(i.first)) {\\n                same.insert(i.first);\\n                if (m1[i.first] > 1) {\\n                    fq1[plus].first.push_back(i.first);\\n                } else {\\n                    fq1[one].first.push_back(i.first);\\n                }\\n            } else {\\n                diff.insert(i.first);\\n                if (m1[i.first] > 1) {\\n                    fq1[plus].second.push_back(i.first);\\n                } else {\\n                    fq1[one].second.push_back(i.first);\\n                }\\n            }\\n        }\\n        \\n        for (auto i : m2) {\\n            if (m1.count(i.first)) {\\n                 if (m2[i.first] > 1) {\\n                    fq2[plus].first.push_back(i.first);\\n                } else {\\n                    fq2[one].first.push_back(i.first);\\n                }   \\n            } else {\\n                if (m2[i.first] > 1) {\\n                    fq2[plus].second.push_back(i.first);\\n                } else {\\n                    fq2[one].second.push_back(i.first);\\n                }\\n            }\\n        }\\n        \\n        bool one_different = (fq2[one].second.size() && fq1[one].second.size());\\n        bool one_same = (fq2[one].first.size() && fq1[one].first.size());\\n        bool many_same = (fq2[plus].first.size() && fq1[plus].first.size());\\n        bool many_different = (fq2[plus].second.size() && fq1[plus].second.size());\\n        bool many_same_one_same_m1 = (fq2[plus].first.size() && fq1[one].first.size());\\n        bool many_same_one_same_m2 = (fq1[plus].first.size() && fq2[one].first.size());\\n        bool give_one_same_m1 = (fq1[one].first.size());\\n        bool take_many_same_m1 = (fq1[plus].first.size());\\n        bool take_many_same_m2 = (fq2[plus].first.size());\\n        bool give_one_same_m2 = (fq2[one].first.size());\\n        bool give_one_different_m1 = (fq1[one].second.size());\\n        bool give_one_different_m2 = (fq2[one].second.size());\\n        bool give_many_different_m1 = (fq1[plus].second.size());\\n        bool give_many_different_m2 = (fq2[plus].second.size());\\n        bool many_same_m2 = (fq2[plus].first.size() == 1);\\n        bool many_same_m1 = (fq1[plus].first.size() == 1);\\n        \\n    \\n        if (ddiff == 0) {\\n            if (same.size() == 0) {\\n                return one_different || many_different;\\n            } else if (diff.size() == 0) {\\n                return true;\\n            } else {\\n                return one_different || one_same || many_different || many_same || many_same_one_same_m1 || many_same_one_same_m2;\\n            }     \\n        }\\n        else if (ddiff == 1) {\\n            if (m1.size() > m2.size()) {\\n                return (give_one_same_m1 && take_many_same_m2 && !many_same_m2) || (take_many_same_m2 && give_many_different_m1)                     || (give_one_different_m1 && give_one_same_m2);\\n            } else {\\n                return (give_one_same_m2 && take_many_same_m1 && !many_same_m1) || (take_many_same_m1 && give_many_different_m2) || (give_one_different_m2 && give_one_same_m1);\\n            }\\n        } else {\\n            if (m1.size() > m2.size()) {\\n                return give_one_different_m1 && take_many_same_m2;\\n            } else {\\n                return give_one_different_m2 && take_many_same_m1;\\n            }\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3052479,
                "title": "swift-solution",
                "content": "# Approach\\n1. Compute the frequency maps of w1 and w2, and also the count of unique chars for each of them.\\n2. If the difference of unique chars count is > 2, it is not possible to get two strings with same frequency map.\\n3. Iterate over all chars in w1, and select only the ones that exist in w1.\\n4. Iterate over all chars in w2, and select only the ones that exist in w2.\\n5. For each pair of (w1 char, w2 char), try to swap it (and see if we can get two strings with same frequency map).\\n6. If we can, return true.\\n7. If we could not swap any pair, return false.\\n\\n# Complexity\\n- Time complexity: O(26^2) = O(1) // 26 is the max number of unique chars in a string\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func isItPossible(_ w1: String, _ w2: String) -> Bool {\\n        var m1 = [Int](repeating: 0, count: 26), m2 = [Int](repeating: 0, count: 26)\\n        var c1 = 0, c2 = 0 \\n        for c in w1 {\\n            let i = Int(c.asciiValue! - 97)\\n            if m1[i] == 0 { c1 += 1 }\\n            m1[i] += 1\\n        }\\n        for c in w2 {\\n            let i = Int(c.asciiValue! - 97)\\n            if m2[i] == 0 { c2 += 1 }\\n            m2[i] += 1\\n        }\\n\\n        if abs(c1 - c2) > 2 { return false }\\n\\n        for i in 0..<26 {\\n            if m1[i] == 0 { continue }\\n            var a1 = c1, a2 = c2 \\n            if m1[i] == 1 { a1 -= 1 }\\n            if m2[i] == 0 { a2 += 1 }\\n            for j in 0..<26 {\\n                if m2[j] == 0 { continue }\\n\\n                var b1 = a1, b2 = a2 \\n                if i == j { if m1[i] == 1 { b1 += 1 } } \\n                else if m2[j] == 1 { b2 -= 1 } \\n                if m1[j] == 0 { b1 += 1 }\\n                if b1 == b2 { return true }\\n            }\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isItPossible(_ w1: String, _ w2: String) -> Bool {\\n        var m1 = [Int](repeating: 0, count: 26), m2 = [Int](repeating: 0, count: 26)\\n        var c1 = 0, c2 = 0 \\n        for c in w1 {\\n            let i = Int(c.asciiValue! - 97)\\n            if m1[i] == 0 { c1 += 1 }\\n            m1[i] += 1\\n        }\\n        for c in w2 {\\n            let i = Int(c.asciiValue! - 97)\\n            if m2[i] == 0 { c2 += 1 }\\n            m2[i] += 1\\n        }\\n\\n        if abs(c1 - c2) > 2 { return false }\\n\\n        for i in 0..<26 {\\n            if m1[i] == 0 { continue }\\n            var a1 = c1, a2 = c2 \\n            if m1[i] == 1 { a1 -= 1 }\\n            if m2[i] == 0 { a2 += 1 }\\n            for j in 0..<26 {\\n                if m2[j] == 0 { continue }\\n\\n                var b1 = a1, b2 = a2 \\n                if i == j { if m1[i] == 1 { b1 += 1 } } \\n                else if m2[j] == 1 { b2 -= 1 } \\n                if m1[j] == 0 { b1 += 1 }\\n                if b1 == b2 { return true }\\n            }\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051604,
                "title": "c-hashmap-o-m-n-26-26-26",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        map<char, int> mp1, mp2;\\n        \\n        for(auto ch1 : word1)\\n            mp1[ch1]++;\\n        for(auto ch2 : word2)\\n            mp2[ch2]++;\\n        \\n        for(char ch1=\\'a\\'; ch1<=\\'z\\'; ch1++){\\n            for(char ch2=\\'a\\'; ch2<=\\'z\\'; ch2++){\\n                if(mp1[ch1]>0 && mp2[ch2]>0){\\n                    mp1[ch1]--;\\n                    mp2[ch2]--;\\n                    mp1[ch2]++;\\n                    mp2[ch1]++;\\n\\n                    int unique1=0, unique2=0;\\n                    for(char temp=\\'a\\'; temp<=\\'z\\'; temp++){\\n                        if(mp1[temp]>0)\\n                            unique1++;\\n                        if(mp2[temp]>0)\\n                            unique2++;\\n                    }\\n\\n                    if(unique1==unique2)\\n                        return true;\\n                \\n\\n                    mp1[ch2]--;\\n                    mp2[ch1]--;\\n                    mp1[ch1]++;\\n                    mp2[ch2]++;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        map<char, int> mp1, mp2;\\n        \\n        for(auto ch1 : word1)\\n            mp1[ch1]++;\\n        for(auto ch2 : word2)\\n            mp2[ch2]++;\\n        \\n        for(char ch1=\\'a\\'; ch1<=\\'z\\'; ch1++){\\n            for(char ch2=\\'a\\'; ch2<=\\'z\\'; ch2++){\\n                if(mp1[ch1]>0 && mp2[ch2]>0){\\n                    mp1[ch1]--;\\n                    mp2[ch2]--;\\n                    mp1[ch2]++;\\n                    mp2[ch1]++;\\n\\n                    int unique1=0, unique2=0;\\n                    for(char temp=\\'a\\'; temp<=\\'z\\'; temp++){\\n                        if(mp1[temp]>0)\\n                            unique1++;\\n                        if(mp2[temp]>0)\\n                            unique2++;\\n                    }\\n\\n                    if(unique1==unique2)\\n                        return true;\\n                \\n\\n                    mp1[ch2]--;\\n                    mp2[ch1]--;\\n                    mp1[ch1]++;\\n                    mp2[ch2]++;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050681,
                "title": "cpp-very-easy-code-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string str1, string str2) \\n    {\\n        unordered_map<char,int>mp1;\\n        unordered_map<char,int>mp2;\\n\\n        //to keep the distinct char count for the string 1\\n        int count1=0;\\n        //creating the freq array for the string 1\\n        vector<int>v1(26,0);\\n        //to keep the distinct char count for the string 2\\n        int count2=0;\\n        //creating the freq arrray for the string 2\\n        vector<int>v2(26,0);\\n\\n        //filling the freq array for str1\\n        for(int i=0;i<str1.length();i++)\\n        {\\n            mp1[str1[i]]++;\\n            v1[str1[i]-\\'a\\']++;\\n        }\\n        \\n        //filling the freq array for str2\\n        for(int i=0;i<str2.length();i++)\\n        {\\n            mp2[str2[i]]++;\\n            v2[str2[i]-\\'a\\']++;\\n        }\\n\\n        //getting the distinct freq count for str1\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(v1[i]>0)\\n            count1++;\\n        }\\n\\n        //getting the distinct freq count for str2\\n        for(int i=0;i<v2.size();i++)\\n        {\\n            if(v2[i]>0)\\n            count2++;\\n        }\\n        \\n        //checking if the ith char of the v1 can be swapped with the jth cahr of the str2\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(v1[i] == 0)\\n            continue;\\n\\n            for(int j=0;j<v2.size();j++)\\n            {\\n                if(v2[j] == 0)\\n                continue;\\n\\n                //both the ith char and jth char are availbale for the swaaping \\n                \\n                //swapping and checking\\n                char ch1 = \\'a\\' + i;\\n                char ch2 = \\'a\\' + j;\\n\\n                mp1[ch1]--;\\n                if(mp1[ch1] == 0)\\n                {\\n                    mp1.erase(ch1);\\n                }\\n\\n                mp2[ch2]--;\\n                if(mp2[ch2] == 0)\\n                {\\n                    mp2.erase(ch2);\\n                }\\n\\n                mp1[ch2]++;\\n                mp2[ch1]++;\\n\\n                if(mp1.size() == mp2.size())\\n                return true;\\n\\n                mp1[ch2]--;\\n                if(mp1[ch2] == 0)\\n                mp1.erase(ch2);\\n\\n                mp2[ch1]--;\\n                if(mp2[ch1] == 0)\\n                mp2.erase(ch1);\\n\\n                mp1[ch1]++;\\n                mp2[ch2]++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string str1, string str2) \\n    {\\n        unordered_map<char,int>mp1;\\n        unordered_map<char,int>mp2;\\n\\n        //to keep the distinct char count for the string 1\\n        int count1=0;\\n        //creating the freq array for the string 1\\n        vector<int>v1(26,0);\\n        //to keep the distinct char count for the string 2\\n        int count2=0;\\n        //creating the freq arrray for the string 2\\n        vector<int>v2(26,0);\\n\\n        //filling the freq array for str1\\n        for(int i=0;i<str1.length();i++)\\n        {\\n            mp1[str1[i]]++;\\n            v1[str1[i]-\\'a\\']++;\\n        }\\n        \\n        //filling the freq array for str2\\n        for(int i=0;i<str2.length();i++)\\n        {\\n            mp2[str2[i]]++;\\n            v2[str2[i]-\\'a\\']++;\\n        }\\n\\n        //getting the distinct freq count for str1\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(v1[i]>0)\\n            count1++;\\n        }\\n\\n        //getting the distinct freq count for str2\\n        for(int i=0;i<v2.size();i++)\\n        {\\n            if(v2[i]>0)\\n            count2++;\\n        }\\n        \\n        //checking if the ith char of the v1 can be swapped with the jth cahr of the str2\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(v1[i] == 0)\\n            continue;\\n\\n            for(int j=0;j<v2.size();j++)\\n            {\\n                if(v2[j] == 0)\\n                continue;\\n\\n                //both the ith char and jth char are availbale for the swaaping \\n                \\n                //swapping and checking\\n                char ch1 = \\'a\\' + i;\\n                char ch2 = \\'a\\' + j;\\n\\n                mp1[ch1]--;\\n                if(mp1[ch1] == 0)\\n                {\\n                    mp1.erase(ch1);\\n                }\\n\\n                mp2[ch2]--;\\n                if(mp2[ch2] == 0)\\n                {\\n                    mp2.erase(ch2);\\n                }\\n\\n                mp1[ch2]++;\\n                mp2[ch1]++;\\n\\n                if(mp1.size() == mp2.size())\\n                return true;\\n\\n                mp1[ch2]--;\\n                if(mp1[ch2] == 0)\\n                mp1.erase(ch2);\\n\\n                mp2[ch1]--;\\n                if(mp2[ch1] == 0)\\n                mp2.erase(ch1);\\n\\n                mp1[ch1]++;\\n                mp2[ch2]++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050563,
                "title": "c-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string w1, string w2) {\\n        int cnt1[26]{}, cnt2[26]{}, f1 = 0, f2 = 0;\\n        for(auto e : w1) if(cnt1[e-\\'a\\']++ == 0) f1++;\\n        for(auto e : w2) if(cnt2[e-\\'a\\']++ == 0) f2++;\\n\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < 26; j++) {\\n                if(cnt1[i] && cnt2[j]) {\\n                    if(i == j) if(f1 == f2) return true; else continue;\\n                    int p1 = f1 + (cnt1[i] == 1 ? -1 : 0) + (cnt1[j] == 0 ? 1 : 0);\\n                    int p2 = f2 + (cnt2[j] == 1 ? -1 : 0) + (cnt2[i] == 0 ? 1 : 0);\\n                    if(p1 == p2) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string w1, string w2) {\\n        int cnt1[26]{}, cnt2[26]{}, f1 = 0, f2 = 0;\\n        for(auto e : w1) if(cnt1[e-\\'a\\']++ == 0) f1++;\\n        for(auto e : w2) if(cnt2[e-\\'a\\']++ == 0) f2++;\\n\\n        for(int i = 0; i < 26; i++) {\\n            for(int j = 0; j < 26; j++) {\\n                if(cnt1[i] && cnt2[j]) {\\n                    if(i == j) if(f1 == f2) return true; else continue;\\n                    int p1 = f1 + (cnt1[i] == 1 ? -1 : 0) + (cnt1[j] == 0 ? 1 : 0);\\n                    int p2 = f2 + (cnt2[j] == 1 ? -1 : 0) + (cnt2[i] == 0 ? 1 : 0);\\n                    if(p1 == p2) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050106,
                "title": "simple-brute-force-approach-o-26-26",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nit wants to swap two character one from word1 and another from word2\\nhe say this operation occurs **exectly one**, so let\\'s try every sigle character.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe don\\'t need to go through every sigle character in word, we just need to go through 26 english letter  \\nand firstly check if this letter in word1 and another letter in word2 then try to swap them and check if distinct characters in them equal or not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(26*26)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(26)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    bool isItPossible(string str1, string str2) {\\n        std::unordered_map<char,int>mp1, mp2;\\n        for(auto x : str1){\\n            mp1[x]++;\\n        }\\n        for(auto x :str2){\\n            mp2[x]++;\\n        }\\n        \\n        for(char x=\\'a\\';x<=\\'z\\';x++){\\n            for(char z=\\'a\\';z<=\\'z\\';z++){\\n                if(mp1[x]>=1 and mp2[z]>=1 ){\\n                    mp1[x]--;\\n                    mp1[z]++;\\n                    mp2[x]++;\\n                    mp2[z]--;\\n                    \\n                    int t=0;\\n                    for(char a=\\'a\\';a<=\\'z\\';a++){\\n                        t += mp1[a] > 0;\\n                    }\\n                    int t2=0;\\n                     for(char a=\\'a\\';a<=\\'z\\';a++){\\n                        t2 += mp2[a] > 0;\\n                    }\\n                    \\n                    if(t==t2)return true;\\n                    \\n                    mp1[x]++;\\n                    mp1[z]--;\\n                    mp2[x]--;\\n                    mp2[z]++;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    bool isItPossible(string str1, string str2) {\\n        std::unordered_map<char,int>mp1, mp2;\\n        for(auto x : str1){\\n            mp1[x]++;\\n        }\\n        for(auto x :str2){\\n            mp2[x]++;\\n        }\\n        \\n        for(char x=\\'a\\';x<=\\'z\\';x++){\\n            for(char z=\\'a\\';z<=\\'z\\';z++){\\n                if(mp1[x]>=1 and mp2[z]>=1 ){\\n                    mp1[x]--;\\n                    mp1[z]++;\\n                    mp2[x]++;\\n                    mp2[z]--;\\n                    \\n                    int t=0;\\n                    for(char a=\\'a\\';a<=\\'z\\';a++){\\n                        t += mp1[a] > 0;\\n                    }\\n                    int t2=0;\\n                     for(char a=\\'a\\';a<=\\'z\\';a++){\\n                        t2 += mp2[a] > 0;\\n                    }\\n                    \\n                    if(t==t2)return true;\\n                    \\n                    mp1[x]++;\\n                    mp1[z]--;\\n                    mp2[x]--;\\n                    mp2[z]++;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049980,
                "title": "cpp-try-all-combinations-of-swap",
                "content": "### Intuition\\n- There are at max $$26*26$$ possible swap combinations\\n- Try each combination and check if after swap, does the condition satisfy\\n\\n### Complexity\\n- Time: $$O(26*26*26)$$ worst case\\n- Space: $$O(26*2)$$\\n\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    bool checkFreq(vector<int>& freq1, vector<int>& freq2) {\\n        int distinctCharsinFirst = 0, distinctCharsinSecond = 0;\\n        \\n        for(int i=0;i<26;i++) {\\n            if(freq1[i]>0) distinctCharsinFirst++;\\n            if(freq2[i]>0) distinctCharsinSecond++;\\n        }\\n        \\n        return distinctCharsinFirst == distinctCharsinSecond;\\n    }\\n    \\n    bool isItPossible(string word1, string word2) {\\n        vector<int> freq1(26, 0), freq2(26, 0);\\n        \\n        for(char c: word1) freq1[c-\\'a\\']++;\\n        for(char c: word2) freq2[c-\\'a\\']++;\\n        \\n        for(int i=0;i<26;i++) {\\n            for(int j=0;j<26;j++) {\\n                if(freq1[i]==0 or freq2[j]==0) continue;\\n                \\n                // Swap word1[i] with word2[j]\\n                freq1[i]--; freq2[i]++;\\n                freq1[j]++; freq2[j]--;\\n                \\n                if(checkFreq(freq1, freq2)) return true;\\n\\n                // Revert the swap before checking other combinations\\n                freq1[i]++; freq2[i]--;\\n                freq1[j]--; freq2[j]++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkFreq(vector<int>& freq1, vector<int>& freq2) {\\n        int distinctCharsinFirst = 0, distinctCharsinSecond = 0;\\n        \\n        for(int i=0;i<26;i++) {\\n            if(freq1[i]>0) distinctCharsinFirst++;\\n            if(freq2[i]>0) distinctCharsinSecond++;\\n        }\\n        \\n        return distinctCharsinFirst == distinctCharsinSecond;\\n    }\\n    \\n    bool isItPossible(string word1, string word2) {\\n        vector<int> freq1(26, 0), freq2(26, 0);\\n        \\n        for(char c: word1) freq1[c-\\'a\\']++;\\n        for(char c: word2) freq2[c-\\'a\\']++;\\n        \\n        for(int i=0;i<26;i++) {\\n            for(int j=0;j<26;j++) {\\n                if(freq1[i]==0 or freq2[j]==0) continue;\\n                \\n                // Swap word1[i] with word2[j]\\n                freq1[i]--; freq2[i]++;\\n                freq1[j]++; freq2[j]--;\\n                \\n                if(checkFreq(freq1, freq2)) return true;\\n\\n                // Revert the swap before checking other combinations\\n                freq1[i]++; freq2[i]--;\\n                freq1[j]--; freq2[j]++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049541,
                "title": "100-fast-two-freq-vectors-only-short-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> freq1(26, 0), freq2(26, 0);\\n        for(auto it : word1){\\n            freq1[it - \\'a\\']++;\\n        }\\n        for(auto it : word2){\\n            freq2[it - \\'a\\']++;\\n        }\\n        int cnt1 = 0;\\n        int cnt2 = 0;\\n        for(int i = 0; i < 26; ++i){\\n            if(freq1[i]){\\n                cnt1++;\\n            }\\n            if(freq2[i]){\\n                cnt2++;\\n            }\\n        }\\n        for(int i = 0; i < 26; ++i){\\n            for(int j = 0; j < 26; ++j){\\n                if(freq1[i] && freq2[j]){\\n                    int c1 = freq1[i];\\n                    int c2 = freq1[j];\\n                    int c3 = freq2[i];\\n                    int c4 = freq2[j];\\n                    int cnt1_c = cnt1;\\n                    int cnt2_c = cnt2;\\n                    freq1[i]--;\\n                    if(freq1[i] == 0){\\n                        cnt1_c--;\\n                    }\\n                    freq1[j]++;\\n                    if(freq1[j] == 1){\\n                        cnt1_c++;\\n                    }\\n                    freq2[j]--;\\n                    if(freq2[j] == 0){\\n                        cnt2_c--;\\n                    }\\n                    freq2[i]++;\\n                    if(freq2[i] == 1){\\n                        cnt2_c++;\\n                    }\\n                    if(cnt1_c == cnt2_c){\\n                        return true;\\n                    }\\n                    freq1[i] = c1;\\n                    freq1[j] = c2;\\n                    freq2[i] = c3;\\n                    freq2[j] = c4;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> freq1(26, 0), freq2(26, 0);\\n        for(auto it : word1){\\n            freq1[it - \\'a\\']++;\\n        }\\n        for(auto it : word2){\\n            freq2[it - \\'a\\']++;\\n        }\\n        int cnt1 = 0;\\n        int cnt2 = 0;\\n        for(int i = 0; i < 26; ++i){\\n            if(freq1[i]){\\n                cnt1++;\\n            }\\n            if(freq2[i]){\\n                cnt2++;\\n            }\\n        }\\n        for(int i = 0; i < 26; ++i){\\n            for(int j = 0; j < 26; ++j){\\n                if(freq1[i] && freq2[j]){\\n                    int c1 = freq1[i];\\n                    int c2 = freq1[j];\\n                    int c3 = freq2[i];\\n                    int c4 = freq2[j];\\n                    int cnt1_c = cnt1;\\n                    int cnt2_c = cnt2;\\n                    freq1[i]--;\\n                    if(freq1[i] == 0){\\n                        cnt1_c--;\\n                    }\\n                    freq1[j]++;\\n                    if(freq1[j] == 1){\\n                        cnt1_c++;\\n                    }\\n                    freq2[j]--;\\n                    if(freq2[j] == 0){\\n                        cnt2_c--;\\n                    }\\n                    freq2[i]++;\\n                    if(freq2[i] == 1){\\n                        cnt2_c++;\\n                    }\\n                    if(cnt1_c == cnt2_c){\\n                        return true;\\n                    }\\n                    freq1[i] = c1;\\n                    freq1[j] = c2;\\n                    freq2[i] = c3;\\n                    freq2[j] = c4;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049372,
                "title": "java-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(26*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nimport java.io.*;\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        Map<Character,Integer>  m1 = new ConcurrentHashMap<Character,Integer>();\\n        Map<Character,Integer>  m2 = new ConcurrentHashMap<Character,Integer>();\\n        for(int i=0; i<word1.length(); i++){\\n            char c1 = word1.charAt(i);\\n            m1.put(c1,m1.getOrDefault(c1,0)+1);\\n        }\\n        \\n        for(int i=0; i<word2.length(); i++){\\n            char c2 = word2.charAt(i);\\n            m2.put(c2,m2.getOrDefault(c2,0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> mp1: m1.entrySet()){\\n                char c1 = mp1.getKey();\\n                for(Map.Entry<Character,Integer> mp2: m2.entrySet()){\\n                    char c2 = mp2.getKey();\\n                    \\n                    // adding c2 to m1;\\n                    m1.put(c2,m1.getOrDefault(c2,0)+1);\\n                    if(m1.get(c1)==1){\\n                        m1.remove(c1);\\n                    }else{\\n                        m1.put(c1,m1.get(c1)-1);\\n                    }\\n                    \\n                    // add c1 to m1;\\n                    m2.put(c1,m2.getOrDefault(c1,0)+1);\\n                    if(m2.get(c2)==1){\\n                        m2.remove(c2);\\n                    }else{\\n                        m2.put(c2,m2.get(c2)-1);\\n                    }\\n                    \\n                    if(m1.size()==m2.size()) return true;\\n                    else{\\n                        m1.put(c1,m1.getOrDefault(c1,0)+1);\\n                        if(m1.get(c2)==1){\\n                            m1.remove(c2);\\n                        }else{\\n                            m1.put(c2,m1.get(c2)-1);\\n                        }\\n                        \\n                        m2.put(c2,m2.getOrDefault(c2,0)+1);\\n                        if(m2.get(c1)==1){\\n                            m2.remove(c1);\\n                        }else{\\n                            m2.put(c1,m2.get(c1)-1);\\n                        }\\n                    }\\n                }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nimport java.io.*;\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        Map<Character,Integer>  m1 = new ConcurrentHashMap<Character,Integer>();\\n        Map<Character,Integer>  m2 = new ConcurrentHashMap<Character,Integer>();\\n        for(int i=0; i<word1.length(); i++){\\n            char c1 = word1.charAt(i);\\n            m1.put(c1,m1.getOrDefault(c1,0)+1);\\n        }\\n        \\n        for(int i=0; i<word2.length(); i++){\\n            char c2 = word2.charAt(i);\\n            m2.put(c2,m2.getOrDefault(c2,0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> mp1: m1.entrySet()){\\n                char c1 = mp1.getKey();\\n                for(Map.Entry<Character,Integer> mp2: m2.entrySet()){\\n                    char c2 = mp2.getKey();\\n                    \\n                    // adding c2 to m1;\\n                    m1.put(c2,m1.getOrDefault(c2,0)+1);\\n                    if(m1.get(c1)==1){\\n                        m1.remove(c1);\\n                    }else{\\n                        m1.put(c1,m1.get(c1)-1);\\n                    }\\n                    \\n                    // add c1 to m1;\\n                    m2.put(c1,m2.getOrDefault(c1,0)+1);\\n                    if(m2.get(c2)==1){\\n                        m2.remove(c2);\\n                    }else{\\n                        m2.put(c2,m2.get(c2)-1);\\n                    }\\n                    \\n                    if(m1.size()==m2.size()) return true;\\n                    else{\\n                        m1.put(c1,m1.getOrDefault(c1,0)+1);\\n                        if(m1.get(c2)==1){\\n                            m1.remove(c2);\\n                        }else{\\n                            m1.put(c2,m1.get(c2)-1);\\n                        }\\n                        \\n                        m2.put(c2,m2.getOrDefault(c2,0)+1);\\n                        if(m2.get(c1)==1){\\n                            m2.remove(c1);\\n                        }else{\\n                            m2.put(c1,m2.get(c1)-1);\\n                        }\\n                    }\\n                }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049308,
                "title": "character-frequency-vector-constructive-algorithm-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> freq1(26, 0), freq2(26, 0);\\n        for(auto it : word1){\\n            freq1[it - \\'a\\']++;\\n        }\\n        for(auto it : word2){\\n            freq2[it - \\'a\\']++;\\n        }\\n        int cnt1, cnt2;\\n        for(int i = 0; i < 26; ++i){\\n            for(int j = 0; j < 26; ++j){\\n                if(freq1[i] && freq2[j]){\\n                    freq1[i]--;\\n                    freq2[i]++;\\n                    freq2[j]--;\\n                    freq1[j]++;\\n                    cnt1 = cnt2 = 0;\\n                    for(int k = 0; k < 26; ++k){\\n                        if(freq1[k]){\\n                            cnt1++;\\n                        }\\n                        if(freq2[k]){\\n                            cnt2++;\\n                        }\\n                    }\\n                    if(cnt1 == cnt2){\\n                        return true;\\n                    }\\n                    freq1[i]++;\\n                    freq1[j]--;\\n                    freq2[i]--;\\n                    freq2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> freq1(26, 0), freq2(26, 0);\\n        for(auto it : word1){\\n            freq1[it - \\'a\\']++;\\n        }\\n        for(auto it : word2){\\n            freq2[it - \\'a\\']++;\\n        }\\n        int cnt1, cnt2;\\n        for(int i = 0; i < 26; ++i){\\n            for(int j = 0; j < 26; ++j){\\n                if(freq1[i] && freq2[j]){\\n                    freq1[i]--;\\n                    freq2[i]++;\\n                    freq2[j]--;\\n                    freq1[j]++;\\n                    cnt1 = cnt2 = 0;\\n                    for(int k = 0; k < 26; ++k){\\n                        if(freq1[k]){\\n                            cnt1++;\\n                        }\\n                        if(freq2[k]){\\n                            cnt2++;\\n                        }\\n                    }\\n                    if(cnt1 == cnt2){\\n                        return true;\\n                    }\\n                    freq1[i]++;\\n                    freq1[j]--;\\n                    freq2[i]--;\\n                    freq2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045111,
                "title": "simple-mapping-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string s, string t) {\\n        vector<int> mp1(30,0),mp2(30,0);\\n        int n1=0,n2=0;\\n        for(auto e:s){\\n            if(!mp1[e-\\'a\\'])\\n                n1++;\\n            mp1[e-\\'a\\']++;\\n        }\\n        \\n        for(auto e:t){\\n            if(!mp2[e-\\'a\\'])\\n                n2++;\\n            mp2[e-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<=26;i++){\\n            for(int j=0;j<=26;j++){\\n                int t1=n1,t2=n2;\\n                if(mp1[i] and mp2[j]){\\n                    if(i==j){\\n                        if(n1==n2)\\n                            return 1;\\n                        continue;\\n                    }\\n                    if(mp1[i]==1)\\n                        t1--;\\n                    \\n                    if(mp2[i]==0)\\n                        t2++;\\n                    \\n                    if(mp2[j]==1)\\n                        t2--;\\n                    \\n                    if(mp1[j]==0)\\n                        t1++;\\n                    \\n                    \\n                    if(t1==t2)\\n                        return 1;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string s, string t) {\\n        vector<int> mp1(30,0),mp2(30,0);\\n        int n1=0,n2=0;\\n        for(auto e:s){\\n            if(!mp1[e-\\'a\\'])\\n                n1++;\\n            mp1[e-\\'a\\']++;\\n        }\\n        \\n        for(auto e:t){\\n            if(!mp2[e-\\'a\\'])\\n                n2++;\\n            mp2[e-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<=26;i++){\\n            for(int j=0;j<=26;j++){\\n                int t1=n1,t2=n2;\\n                if(mp1[i] and mp2[j]){\\n                    if(i==j){\\n                        if(n1==n2)\\n                            return 1;\\n                        continue;\\n                    }\\n                    if(mp1[i]==1)\\n                        t1--;\\n                    \\n                    if(mp2[i]==0)\\n                        t2++;\\n                    \\n                    if(mp2[j]==1)\\n                        t2--;\\n                    \\n                    if(mp1[j]==0)\\n                        t1++;\\n                    \\n                    \\n                    if(t1==t2)\\n                        return 1;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038303,
                "title": "php-brute-force-77ms",
                "content": "```\\nclass Solution {\\n    function Arr ($n) { $a = array(); for ($i = 0; $i < $n; $i++) array_push($a, 0); return $a;}\\n\\n    function isItPossible($s, $t) {\\n        $a = $this->Arr(26);\\n        $b = $this->Arr(26);\\n        for ($i = 0; $i < strlen($s); $i++) $a[ord($s[$i]) - 97]++;\\n        for ($i = 0; $i < strlen($t); $i++) $b[ord($t[$i]) - 97]++;\\n        for ($i = 0; $i < 26; $i++) {\\n           if ($a[$i] > 0) {\\n               for ($j = 0; $j < 26; $j++) {\\n                  if ($b[$j] > 0) {\\n                     $a[$i]--;\\n                     $b[$i]++;\\n                     $b[$j]--;\\n                     $a[$j]++;\\n                     if ($this->equalDistinct($a, $b)) return true;\\n                     $a[$i]++;\\n                     $b[$i]--;\\n                     $b[$j]++;\\n                     $a[$j]--;\\n                  }\\n               }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function equalDistinct ($a, $b) {\\n        $cntA = 0;\\n        $cntB = 0;\\n        for ($i = 0; $i < 26; $i++) {\\n            if ($a[$i] > 0) $cntA++;\\n            if ($b[$i] > 0) $cntB++;\\n        }\\n        return $cntA == $cntB;\\n    }\\n}\\n```\\nJavascript version:\\nhttps://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3025313/javascript-brute-force-83ms/",
                "solutionTags": [
                    "JavaScript",
                    "PHP",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    function Arr ($n) { $a = array(); for ($i = 0; $i < $n; $i++) array_push($a, 0); return $a;}\\n\\n    function isItPossible($s, $t) {\\n        $a = $this->Arr(26);\\n        $b = $this->Arr(26);\\n        for ($i = 0; $i < strlen($s); $i++) $a[ord($s[$i]) - 97]++;\\n        for ($i = 0; $i < strlen($t); $i++) $b[ord($t[$i]) - 97]++;\\n        for ($i = 0; $i < 26; $i++) {\\n           if ($a[$i] > 0) {\\n               for ($j = 0; $j < 26; $j++) {\\n                  if ($b[$j] > 0) {\\n                     $a[$i]--;\\n                     $b[$i]++;\\n                     $b[$j]--;\\n                     $a[$j]++;\\n                     if ($this->equalDistinct($a, $b)) return true;\\n                     $a[$i]++;\\n                     $b[$i]--;\\n                     $b[$j]++;\\n                     $a[$j]--;\\n                  }\\n               }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function equalDistinct ($a, $b) {\\n        $cntA = 0;\\n        $cntB = 0;\\n        for ($i = 0; $i < 26; $i++) {\\n            if ($a[$i] > 0) $cntA++;\\n            if ($b[$i] > 0) $cntB++;\\n        }\\n        return $cntA == $cntB;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038225,
                "title": "simple-to-understand-solution-with-explanation-java-o-26-26",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstead of looping through every pair of indices in the string, which would result in a TLE, we loop through switching a pair of letters that is present in both strings.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first tally the amount of each character we have in one string. Then we loop through every possible letter combination pair. If both strings has their respective letter present, we attempt a switch and update the number of unique letters. After each swap, we check if the unique letter counts are equal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(26\\\\cdot26)$$ -> $$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(26)$$ -> $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] s1 = new int[26];\\n        int[] s2 = new int[26];\\n\\n        for (int i = 0; i < word1.length(); i++) {\\n            s1[word1.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for (int i = 0; i < word2.length(); i++) {\\n            s2[word2.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        int uni1 = 0;\\n        int uni2 = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (s1[i]>0) uni1++;\\n            if (s2[i]>0) uni2++;\\n        }\\n        \\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (s1[i] > 0 && s2[j] > 0) {\\n                    int tmp1 = uni1;\\n                    int tmp2 = uni2;\\n                    s1[i]--;\\n                    s2[j]--;\\n                    \\n                    if (s1[i] == 0) tmp1--;\\n                    if (s2[j] == 0) tmp2--;\\n                    \\n                    if (s1[j] == 0) tmp1++;\\n                    if (s2[i] == 0) tmp2++;\\n                    \\n                    if(tmp1 == tmp2) return true;\\n                    s1[i]++;\\n                    s2[j]++;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] s1 = new int[26];\\n        int[] s2 = new int[26];\\n\\n        for (int i = 0; i < word1.length(); i++) {\\n            s1[word1.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for (int i = 0; i < word2.length(); i++) {\\n            s2[word2.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        int uni1 = 0;\\n        int uni2 = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (s1[i]>0) uni1++;\\n            if (s2[i]>0) uni2++;\\n        }\\n        \\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (s1[i] > 0 && s2[j] > 0) {\\n                    int tmp1 = uni1;\\n                    int tmp2 = uni2;\\n                    s1[i]--;\\n                    s2[j]--;\\n                    \\n                    if (s1[i] == 0) tmp1--;\\n                    if (s2[j] == 0) tmp2--;\\n                    \\n                    if (s1[j] == 0) tmp1++;\\n                    if (s2[i] == 0) tmp2++;\\n                    \\n                    if(tmp1 == tmp2) return true;\\n                    s1[i]++;\\n                    s2[j]++;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037957,
                "title": "o-unique-alphabets-1-unique-alphabets-2-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCounter + set approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(26*26)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(26)\\n# Code\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        cntr1,cntr2 = Counter(word1),Counter(word2)\\n        set1,set2 = set(list(cntr1.keys())),set(list(cntr2.keys()))\\n        for k1 in cntr1:\\n            for k2 in cntr2:\\n                set1_copy = set1.copy()\\n                set2_copy = set2.copy()\\n                if(cntr1[k1]==1):\\n                    set1_copy.remove(k1)\\n                set1_copy.add(k2)\\n                if(cntr2[k2]==1):\\n                    set2_copy.remove(k2)\\n                set2_copy.add(k1)\\n                if(len(set1_copy)==len(set2_copy)):\\n                    return True\\n        return False\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        cntr1,cntr2 = Counter(word1),Counter(word2)\\n        set1,set2 = set(list(cntr1.keys())),set(list(cntr2.keys()))\\n        for k1 in cntr1:\\n            for k2 in cntr2:\\n                set1_copy = set1.copy()\\n                set2_copy = set2.copy()\\n                if(cntr1[k1]==1):\\n                    set1_copy.remove(k1)\\n                set1_copy.add(k2)\\n                if(cntr2[k2]==1):\\n                    set2_copy.remove(k2)\\n                set2_copy.add(k1)\\n                if(len(set1_copy)==len(set2_copy)):\\n                    return True\\n        return False\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037758,
                "title": "java-o-26-26-easy-and-clean-solution",
                "content": "```\\n    public boolean isItPossible(String word1, String word2) {\\n        Map<Character, Integer> map1 = buildCharMap(word1);\\n        Map<Character, Integer> map2 = buildCharMap(word2);\\n        for (Map.Entry<Character, Integer> es1 : map1.entrySet()) {\\n            char a = es1.getKey();\\n            for (Map.Entry<Character, Integer> es2 : map2.entrySet()) {\\n                char b = es2.getKey();\\n                Map<Character, Integer> newMap1 = insertAndRemove(map1, b, a);\\n                Map<Character, Integer> newMap2 = insertAndRemove(map2, a, b);\\n                if (newMap1.size() == newMap2.size()) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private Map<Character, Integer> buildCharMap(String word) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : word.toCharArray()) {\\n            int count = map.getOrDefault(c, 0);\\n            map.put(c, count + 1);\\n        }\\n        return map;\\n    }\\n    \\n    private Map<Character, Integer> insertAndRemove(Map<Character, Integer> map, char inC, char rmC) {\\n        Map<Character, Integer> resMap = new HashMap<>(map);\\n        if (inC == rmC) return resMap;\\n        int count = map.getOrDefault(inC, 0);\\n        resMap.put(inC, count + 1);\\n        count = map.get(rmC);\\n        if (count == 1) resMap.remove(rmC);\\n        else resMap.put(rmC, count - 1);\\n        return resMap;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean isItPossible(String word1, String word2) {\\n        Map<Character, Integer> map1 = buildCharMap(word1);\\n        Map<Character, Integer> map2 = buildCharMap(word2);\\n        for (Map.Entry<Character, Integer> es1 : map1.entrySet()) {\\n            char a = es1.getKey();\\n            for (Map.Entry<Character, Integer> es2 : map2.entrySet()) {\\n                char b = es2.getKey();\\n                Map<Character, Integer> newMap1 = insertAndRemove(map1, b, a);\\n                Map<Character, Integer> newMap2 = insertAndRemove(map2, a, b);\\n                if (newMap1.size() == newMap2.size()) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private Map<Character, Integer> buildCharMap(String word) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : word.toCharArray()) {\\n            int count = map.getOrDefault(c, 0);\\n            map.put(c, count + 1);\\n        }\\n        return map;\\n    }\\n    \\n    private Map<Character, Integer> insertAndRemove(Map<Character, Integer> map, char inC, char rmC) {\\n        Map<Character, Integer> resMap = new HashMap<>(map);\\n        if (inC == rmC) return resMap;\\n        int count = map.getOrDefault(inC, 0);\\n        resMap.put(inC, count + 1);\\n        count = map.get(rmC);\\n        if (count == 1) resMap.remove(rmC);\\n        else resMap.put(rmC, count - 1);\\n        return resMap;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3036758,
                "title": "simple-solution-using-vectors-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount occurences of alphabets and simultate exchanges of chars .\\n# Complexity\\n- Time complexity: O(26^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> alp1(26,0), alp2(26,0);\\n        int cnt1 = 0, cnt2 = 0; // count for different chars in word1 and word2\\n        for(int i=0;i<word1.length();i++){\\n            if(alp1[word1[i]-\\'a\\'] == 0) cnt1++;\\n            alp1[word1[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            if(alp2[word2[i]-\\'a\\'] == 0) cnt2++;\\n            alp2[word2[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(alp1[i] > 0 && alp2[j] > 0){\\n                    // we are exchanging i and j\\n                    int a = cnt1, b = cnt2;\\n                    // changing char count for alp1\\n                    if (alp1[j] == 0) a++; alp1[j]++;\\n                    if (alp1[i] == 1) a--; alp1[i]--;\\n                    if (alp2[i] == 0) b++; alp2[i]++;\\n                    if (alp2[j] == 1) b--; alp2[j]--;\\n                    if(a == b) return 1;\\n                    alp2[j]++;\\n                    alp2[i]--;\\n                    alp1[i]++;\\n                    alp1[j]--;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> alp1(26,0), alp2(26,0);\\n        int cnt1 = 0, cnt2 = 0; // count for different chars in word1 and word2\\n        for(int i=0;i<word1.length();i++){\\n            if(alp1[word1[i]-\\'a\\'] == 0) cnt1++;\\n            alp1[word1[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            if(alp2[word2[i]-\\'a\\'] == 0) cnt2++;\\n            alp2[word2[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(alp1[i] > 0 && alp2[j] > 0){\\n                    // we are exchanging i and j\\n                    int a = cnt1, b = cnt2;\\n                    // changing char count for alp1\\n                    if (alp1[j] == 0) a++; alp1[j]++;\\n                    if (alp1[i] == 1) a--; alp1[i]--;\\n                    if (alp2[i] == 0) b++; alp2[i]++;\\n                    if (alp2[j] == 1) b--; alp2[j]--;\\n                    if(a == b) return 1;\\n                    alp2[j]++;\\n                    alp2[i]--;\\n                    alp1[i]++;\\n                    alp1[j]--;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036283,
                "title": "c-solution-using-2-frequency-arrays",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &v1,vector<int> &v2){\\n        int x=0,y=0;\\n        for (auto it:v1){\\n            if (it!=0) x++;\\n        }\\n        for (auto it:v2){\\n            if (it!=0) y++;\\n        }\\n        return x==y;\\n    }\\n    bool isItPossible(string s, string t) {\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        for (int i=0;i<s.size();i++) v1[s[i]-\\'a\\']++;\\n        for (int i=0;i<t.size();i++) v2[t[i]-\\'a\\']++;\\n        if (s==t) return true;\\n        for (int i=0;i<26;i++){\\n            if (v1[i]==0) continue;\\n            int ch1=i;\\n            for (int j=0;j<26;j++){\\n                if (v2[j]==0) continue;\\n                int ch2=j;\\n                v1[ch2]++;\\n                v2[ch2]--;\\n                v2[ch1]++;\\n                v1[ch1]--;\\n                if (check(v1,v2)) return true;\\n                else{\\n                    v2[ch1]--;\\n                    v2[ch2]++;\\n                    v1[ch2]--;\\n                    v1[ch1]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &v1,vector<int> &v2){\\n        int x=0,y=0;\\n        for (auto it:v1){\\n            if (it!=0) x++;\\n        }\\n        for (auto it:v2){\\n            if (it!=0) y++;\\n        }\\n        return x==y;\\n    }\\n    bool isItPossible(string s, string t) {\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        for (int i=0;i<s.size();i++) v1[s[i]-\\'a\\']++;\\n        for (int i=0;i<t.size();i++) v2[t[i]-\\'a\\']++;\\n        if (s==t) return true;\\n        for (int i=0;i<26;i++){\\n            if (v1[i]==0) continue;\\n            int ch1=i;\\n            for (int j=0;j<26;j++){\\n                if (v2[j]==0) continue;\\n                int ch2=j;\\n                v1[ch2]++;\\n                v2[ch2]--;\\n                v2[ch1]++;\\n                v1[ch1]--;\\n                if (check(v1,v2)) return true;\\n                else{\\n                    v2[ch1]--;\\n                    v2[ch2]++;\\n                    v1[ch2]--;\\n                    v1[ch1]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031166,
                "title": "dart-o-diffword1-o-diffword2-clean-code",
                "content": "# Intuition\\nAdd, Minus\\n\\n# Approach\\nHashMap\\n\\n# Complexity\\n- Time complexity:\\nO(DiffWord1) * O(DiffWord2)\\n\\n- Space complexity:\\nO(DiffWord1) * O(DiffWord2)\\n\\n# Code\\n```\\nimport \"dart:collection\";\\n\\nclass Solution {\\n  bool isItPossible(String word1, String word2) {\\n    int n = word1.length;\\n    int m = word2.length;\\n    HashMap<String, int> map1 = HashMap();\\n    HashMap<String, int> map2 = HashMap();\\n\\n    void plusOne(HashMap<String, int> map, String key) =>\\n        map.update(key, (value) => value + 1, ifAbsent: () => 1);\\n\\n    void minusOne(HashMap<String, int> map, String key) {\\n      map.update(key, (value) => value - 1);\\n      if (map[key] == 0) {\\n        map.remove(key);\\n      }\\n    }\\n\\n    for (var i = 0; i < n; i++) {\\n      plusOne(map1, word1[i]);\\n    }\\n\\n    for (var i = 0; i < m; i++) {\\n      plusOne(map2, word2[i]);\\n    }\\n    var keys1 = map1.keys.toList();\\n    var keys2 = map2.keys.toList();\\n\\n    for (var i = 0; i < keys1.length; i++) {\\n      minusOne(map1, keys1[i]);\\n      plusOne(map2, keys1[i]);\\n\\n      for (var j = 0; j < keys2.length; j++) {\\n        plusOne(map1, keys2[j]);\\n        minusOne(map2, keys2[j]);\\n\\n        if (map1.length == map2.length) {\\n          return true;\\n        }\\n\\n        minusOne(map1, keys2[j]);\\n        plusOne(map2, keys2[j]);\\n      }\\n      plusOne(map1, keys1[i]);\\n      minusOne(map2, keys1[i]);\\n    }\\n\\n    return false;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \"dart:collection\";\\n\\nclass Solution {\\n  bool isItPossible(String word1, String word2) {\\n    int n = word1.length;\\n    int m = word2.length;\\n    HashMap<String, int> map1 = HashMap();\\n    HashMap<String, int> map2 = HashMap();\\n\\n    void plusOne(HashMap<String, int> map, String key) =>\\n        map.update(key, (value) => value + 1, ifAbsent: () => 1);\\n\\n    void minusOne(HashMap<String, int> map, String key) {\\n      map.update(key, (value) => value - 1);\\n      if (map[key] == 0) {\\n        map.remove(key);\\n      }\\n    }\\n\\n    for (var i = 0; i < n; i++) {\\n      plusOne(map1, word1[i]);\\n    }\\n\\n    for (var i = 0; i < m; i++) {\\n      plusOne(map2, word2[i]);\\n    }\\n    var keys1 = map1.keys.toList();\\n    var keys2 = map2.keys.toList();\\n\\n    for (var i = 0; i < keys1.length; i++) {\\n      minusOne(map1, keys1[i]);\\n      plusOne(map2, keys1[i]);\\n\\n      for (var j = 0; j < keys2.length; j++) {\\n        plusOne(map1, keys2[j]);\\n        minusOne(map2, keys2[j]);\\n\\n        if (map1.length == map2.length) {\\n          return true;\\n        }\\n\\n        minusOne(map1, keys2[j]);\\n        plusOne(map2, keys2[j]);\\n      }\\n      plusOne(map1, keys1[i]);\\n      minusOne(map2, keys1[i]);\\n    }\\n\\n    return false;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031054,
                "title": "best-short-solution-in-c-hashmap",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> mp1,mp2;\\n        for(auto it:word1)\\n            mp1[it]++;\\n        for(auto it:word2)\\n            mp2[it]++;\\n        for(auto it:mp1){\\n            char ch1=it.first;\\n            for(auto gt:mp2){\\n                char ch2=gt.first;\\n                unordered_map<char,int> new1=mp1,new2=mp2;\\n                new1[ch1]--;\\n                if(new1[ch1]==0)\\n                    new1.erase(ch1);\\n                new2[ch2]--;\\n                if(new2[ch2]==0)\\n                    new2.erase(ch2);\\n                new1[ch2]++;\\n                new2[ch1]++;\\n                if(new1.size()==new2.size())\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> mp1,mp2;\\n        for(auto it:word1)\\n            mp1[it]++;\\n        for(auto it:word2)\\n            mp2[it]++;\\n        for(auto it:mp1){\\n            char ch1=it.first;\\n            for(auto gt:mp2){\\n                char ch2=gt.first;\\n                unordered_map<char,int> new1=mp1,new2=mp2;\\n                new1[ch1]--;\\n                if(new1[ch1]==0)\\n                    new1.erase(ch1);\\n                new2[ch2]--;\\n                if(new2[ch2]==0)\\n                    new2.erase(ch2);\\n                new1[ch2]++;\\n                new2[ch1]++;\\n                if(new1.size()==new2.size())\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030378,
                "title": "easy-to-understand-c-simple-logic-runtime-57-ms-beats-73-39-memory-16-7-mb-beats-88-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the frequency of each letter of both words in two vectors.\\nThen iterate for each v1[i] and v2[j] pair and check if it satisfies the given condition.\\n\\n# Complexity\\n- Time complexity: O(n)+O(m)+O(26 * 26 * 26 * 2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)+O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int>v1(26,0);\\n        vector<int>v2(26,0);\\n\\n        for(int i=0;i<word1.size();i++){\\n            v1[word1[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<word2.size();i++){\\n            v2[word2[i]-\\'a\\']++;\\n        }\\n\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(v1[i]==0 or v2[j]==0) continue;\\n\\n                v1[i]--;\\n                v2[i]++;\\n                v2[j]--;\\n                v1[j]++;\\n\\n                int dist1=0;\\n                int dist2=0;\\n                for(int k=0;k<26;k++){\\n                    if(v1[k]>0) dist1++;\\n                }\\n                for(int k=0;k<26;k++){\\n                    if(v2[k]>0) dist2++;\\n                }\\n\\n                if(dist1==dist2) return true;\\n\\n                v1[i]++;\\n                v2[i]--;\\n                v2[j]++;\\n                v1[j]--;\\n\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        vector<int>v1(26,0);\\n        vector<int>v2(26,0);\\n\\n        for(int i=0;i<word1.size();i++){\\n            v1[word1[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<word2.size();i++){\\n            v2[word2[i]-\\'a\\']++;\\n        }\\n\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(v1[i]==0 or v2[j]==0) continue;\\n\\n                v1[i]--;\\n                v2[i]++;\\n                v2[j]--;\\n                v1[j]++;\\n\\n                int dist1=0;\\n                int dist2=0;\\n                for(int k=0;k<26;k++){\\n                    if(v1[k]>0) dist1++;\\n                }\\n                for(int k=0;k<26;k++){\\n                    if(v2[k]>0) dist2++;\\n                }\\n\\n                if(dist1==dist2) return true;\\n\\n                v1[i]++;\\n                v2[i]--;\\n                v2[j]++;\\n                v1[j]--;\\n\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029689,
                "title": "c-map-approach-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> m1,m2;\\n      \\n\\n        for(auto i:word1){\\n            m1[i]++;\\n        }\\n\\n        for(auto i:word2){\\n            m2[i]++;\\n        }\\n\\n        for(char ch1=\\'a\\';ch1<=\\'z\\';ch1++){\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++){\\n                if(m1[ch1]>0 && m2[ch2]>0){\\n                    m1[ch1]--;\\n                    m2[ch2]--;\\n                    m1[ch2]++;\\n                    m2[ch1]++;\\n                \\n\\n                int w1=0;\\n                int w2=0;\\n\\n                for(char temp=\\'a\\';temp<=\\'z\\';temp++){\\n                   if(m1[temp]>0){\\n                       w1++;\\n                   }\\n\\n                   if(m2[temp]>0){\\n                       w2++;\\n                   }\\n                }\\n\\n                if(w1==w2){\\n                    return true;\\n                }\\n                else{\\n                m1[ch1]++;\\n                m2[ch2]++;\\n                m1[ch2]--;\\n                m2[ch1]--;\\n                }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int> m1,m2;\\n      \\n\\n        for(auto i:word1){\\n            m1[i]++;\\n        }\\n\\n        for(auto i:word2){\\n            m2[i]++;\\n        }\\n\\n        for(char ch1=\\'a\\';ch1<=\\'z\\';ch1++){\\n            for(char ch2=\\'a\\';ch2<=\\'z\\';ch2++){\\n                if(m1[ch1]>0 && m2[ch2]>0){\\n                    m1[ch1]--;\\n                    m2[ch2]--;\\n                    m1[ch2]++;\\n                    m2[ch1]++;\\n                \\n\\n                int w1=0;\\n                int w2=0;\\n\\n                for(char temp=\\'a\\';temp<=\\'z\\';temp++){\\n                   if(m1[temp]>0){\\n                       w1++;\\n                   }\\n\\n                   if(m2[temp]>0){\\n                       w2++;\\n                   }\\n                }\\n\\n                if(w1==w2){\\n                    return true;\\n                }\\n                else{\\n                m1[ch1]++;\\n                m2[ch2]++;\\n                m1[ch2]--;\\n                m2[ch1]--;\\n                }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029383,
                "title": "c-o-m-n-26-26",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int a[26] = {0}, b[26] = {0};\\n        for (char c : word1) ++a[c - \\'a\\'];\\n        for (char c : word2) ++b[c - \\'a\\'];\\n        \\n        int count_a = 0, count_b = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            count_a += a[i] > 0;\\n            count_b += b[i] > 0;\\n        }\\n        \\n        if (abs(count_a - count_b) > 2) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i < 26; ++i) {\\n            if (!a[i]) continue;\\n            for (int j = 0; j < 26; ++j) {\\n                if (!b[j]) continue;\\n                int m = ((--a[i] == 0) ? -1 : 0) + ((++a[j] == 1) ? 1 : 0);\\n                int n = ((--b[j] == 0) ? -1 : 0) + ((++b[i] == 1) ? 1 : 0);\\n                ++a[i], --a[j], --b[i], ++b[j];\\n                \\n                if (count_a + m == count_b + n) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int a[26] = {0}, b[26] = {0};\\n        for (char c : word1) ++a[c - \\'a\\'];\\n        for (char c : word2) ++b[c - \\'a\\'];\\n        \\n        int count_a = 0, count_b = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            count_a += a[i] > 0;\\n            count_b += b[i] > 0;\\n        }\\n        \\n        if (abs(count_a - count_b) > 2) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i < 26; ++i) {\\n            if (!a[i]) continue;\\n            for (int j = 0; j < 26; ++j) {\\n                if (!b[j]) continue;\\n                int m = ((--a[i] == 0) ? -1 : 0) + ((++a[j] == 1) ? 1 : 0);\\n                int n = ((--b[j] == 0) ? -1 : 0) + ((++b[i] == 1) ? 1 : 0);\\n                ++a[i], --a[j], --b[i], ++b[j];\\n                \\n                if (count_a + m == count_b + n) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028991,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n\\n        //create a two vectors t store the frequency and count the distinct numbs\\n\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        int countStr1=0;\\n        int countStr2=0;\\n        for(int i=0;i<word1.size();i++){\\n            v1[word1[i]-\\'a\\']++;\\n            if(v1[word1[i]-\\'a\\']==1){\\n                countStr1++;\\n\\n            }\\n        }\\n        for(int i=0;i<word2.size();i++){\\n            v2[word2[i]-\\'a\\']++;\\n            if(v2[word2[i]-\\'a\\']==1){\\n                countStr2++;\\n            }\\n\\n        }\\n\\n       // cout<<countStr1<<countStr2;\\n\\n        //Now because we have vector of 26 we have to check every possible combination\\n\\n        for(int i=0;i<26;i++){\\n            if(v1[i]==0){\\n                continue;\\n            }\\n\\n\\n\\n            for(int j=0;j<26;j++){\\n                if(v2[j]==0){\\n                    continue;\\n                }\\n\\n\\n                //swapping has to done...now\\n                //if i pick a from v1 i have to put that a in a\\'s postion in \\n                //v2 so if i swap a of v1 then i have to put that at itth positon of v2 also\\n\\n                v1[i]--;\\n                if(v1[i]==0){\\n                    countStr1--;\\n                }\\n                v2[i]++;\\n                if(v2[i]==1){\\n                    countStr2++;\\n\\n                }\\n\\n                v2[j]--;\\n                if(v2[j]==0){\\n                    countStr2--;\\n                }\\n                v1[j]++;\\n                if(v1[j]==1){\\n                    countStr1++;\\n                }  \\n                cout<<countStr1<<countStr2;\\n\\n                if(countStr1==countStr2){\\n                    return true;\\n                }\\n\\n                //if count was not equal then backtrack now..\\n\\n                v1[i]++;\\n                if(v1[i]==1)\\n                    countStr1++;\\n\\n                v2[i]--;\\n                if(v2[i]==0)\\n                    countStr2--;\\n                \\n                v2[j]++;\\n                if(v2[j]==1)\\n                    countStr2++;\\n               \\n                v1[j]--;\\n                if(v1[j]==0)\\n                    countStr1--;\\n\\n                \\n\\n            }\\n        }\\n\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n\\n        //create a two vectors t store the frequency and count the distinct numbs\\n\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        int countStr1=0;\\n        int countStr2=0;\\n        for(int i=0;i<word1.size();i++){\\n            v1[word1[i]-\\'a\\']++;\\n            if(v1[word1[i]-\\'a\\']==1){\\n                countStr1++;\\n\\n            }\\n        }\\n        for(int i=0;i<word2.size();i++){\\n            v2[word2[i]-\\'a\\']++;\\n            if(v2[word2[i]-\\'a\\']==1){\\n                countStr2++;\\n            }\\n\\n        }\\n\\n       // cout<<countStr1<<countStr2;\\n\\n        //Now because we have vector of 26 we have to check every possible combination\\n\\n        for(int i=0;i<26;i++){\\n            if(v1[i]==0){\\n                continue;\\n            }\\n\\n\\n\\n            for(int j=0;j<26;j++){\\n                if(v2[j]==0){\\n                    continue;\\n                }\\n\\n\\n                //swapping has to done...now\\n                //if i pick a from v1 i have to put that a in a\\'s postion in \\n                //v2 so if i swap a of v1 then i have to put that at itth positon of v2 also\\n\\n                v1[i]--;\\n                if(v1[i]==0){\\n                    countStr1--;\\n                }\\n                v2[i]++;\\n                if(v2[i]==1){\\n                    countStr2++;\\n\\n                }\\n\\n                v2[j]--;\\n                if(v2[j]==0){\\n                    countStr2--;\\n                }\\n                v1[j]++;\\n                if(v1[j]==1){\\n                    countStr1++;\\n                }  \\n                cout<<countStr1<<countStr2;\\n\\n                if(countStr1==countStr2){\\n                    return true;\\n                }\\n\\n                //if count was not equal then backtrack now..\\n\\n                v1[i]++;\\n                if(v1[i]==1)\\n                    countStr1++;\\n\\n                v2[i]--;\\n                if(v2[i]==0)\\n                    countStr2--;\\n                \\n                v2[j]++;\\n                if(v2[j]==1)\\n                    countStr2++;\\n               \\n                v1[j]--;\\n                if(v1[j]==0)\\n                    countStr1--;\\n\\n                \\n\\n            }\\n        }\\n\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3028925,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn is_it_possible(word1: String, word2: String) -> bool {\\n        let counter = |s: &str| {\\n            s.bytes().fold([0; 26], |mut acc, b| {\\n                acc[(b - b\\'a\\') as usize] += 1;\\n                acc\\n            })\\n        };\\n\\n        let idx = |arr: &[i32; 26]| -> Vec<usize> {\\n            arr.iter()\\n                .enumerate()\\n                .filter_map(|(i, n)| (*n > 0).then(|| i))\\n                .collect()\\n        };\\n\\n        let move_letters = |c1: &mut [i32; 26], c2: &mut [i32; 26], i: usize, j: usize, k: i32| {\\n            c1[i] -= k;\\n            c2[i] += k;\\n            c1[j] += k;\\n            c2[j] -= k;\\n        };\\n\\n        let check_distinct = |c1: &[i32; 26], c2: &[i32; 26]| {\\n            c1.iter().filter(|n| **n > 0).count() == c2.iter().filter(|n| **n > 0).count()\\n        };\\n\\n        let mut c1 = counter(word1.as_str());\\n        let mut c2 = counter(word2.as_str());\\n\\n        for &i in &idx(&c1) {\\n            for &j in &idx(&c2) {\\n                move_letters(&mut c1, &mut c2, i, j, 1);\\n                if check_distinct(&c1, &c2) {\\n                    return true;\\n                }\\n                move_letters(&mut c1, &mut c2, i, j, -1);\\n            }\\n        }\\n\\n        false\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "String",
                    "Counting",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_it_possible(word1: String, word2: String) -> bool {\\n        let counter = |s: &str| {\\n            s.bytes().fold([0; 26], |mut acc, b| {\\n                acc[(b - b\\'a\\') as usize] += 1;\\n                acc\\n            })\\n        };\\n\\n        let idx = |arr: &[i32; 26]| -> Vec<usize> {\\n            arr.iter()\\n                .enumerate()\\n                .filter_map(|(i, n)| (*n > 0).then(|| i))\\n                .collect()\\n        };\\n\\n        let move_letters = |c1: &mut [i32; 26], c2: &mut [i32; 26], i: usize, j: usize, k: i32| {\\n            c1[i] -= k;\\n            c2[i] += k;\\n            c1[j] += k;\\n            c2[j] -= k;\\n        };\\n\\n        let check_distinct = |c1: &[i32; 26], c2: &[i32; 26]| {\\n            c1.iter().filter(|n| **n > 0).count() == c2.iter().filter(|n| **n > 0).count()\\n        };\\n\\n        let mut c1 = counter(word1.as_str());\\n        let mut c2 = counter(word2.as_str());\\n\\n        for &i in &idx(&c1) {\\n            for &j in &idx(&c2) {\\n                move_letters(&mut c1, &mut c2, i, j, 1);\\n                if check_distinct(&c1, &c2) {\\n                    return true;\\n                }\\n                move_letters(&mut c1, &mut c2, i, j, -1);\\n            }\\n        }\\n\\n        false\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3026890,
                "title": "easy-c-solution-in-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnly lower case characters allowed basically allows you to loop twice for all lower characters\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSee if deleting a character in string 1 and adding it to string 2, and vice versa gives you an answer.\\nfor all i,j  in {\\'a\\', \\'b\\', ...\\'z\\'}\\n    if(adding i to string1 and removing i from string 2)\\n        if(adding j to string2 and removing j from string 1)\\n            gives same distinct count return true\\nreturn false\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(26*26)+O(n) to store count = O(n)\\n- Space complexity:\\n- O(2*n) to store count of every character in string 1,2 \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char, int>m, n;\\n        int c=0, d=0;\\n        for(int i=0;i<word1.length();i++){\\n            if(m[word1[i]] == 0)\\n                c++;\\n            m[word1[i]]++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            if(n[word2[i]] == 0)\\n                d++;\\n            n[word2[i]]++;\\n        }\\n        for(int i=0;i<26;i++){\\n            int p = c, q = d;\\n            int w = m[i+\\'a\\'], x = n[i+\\'a\\'];  \\n            if(m[i+\\'a\\'] >= 1 ){\\n                if(m[i+\\'a\\'] == 1){\\n                     p--;\\n                }\\n                if(n[i+\\'a\\'] == 0){\\n                    q++;\\n                }\\n                n[i+\\'a\\']++;\\n                m[i+\\'a\\']--;\\n            } else {\\n                continue;\\n            }\\n            for(int j=0;j<26;j++){\\n                int t = p, u = q; \\n                int y = m[j+\\'a\\'], z = n[j+\\'a\\'];\\n                 if(n[j+\\'a\\'] >= 1){ //\\n                    if(i == j){\\n                        if(n[j+\\'a\\']<2){\\n                            continue;\\n                        }\\n                    } \\n                    if(n[j+\\'a\\'] == 1){\\n                        q--;\\n                    }\\n                    if(m[j+\\'a\\'] == 0){\\n                        p++;\\n                    }\\n                    n[j+\\'a\\']--;\\n                    m[j+\\'a\\']++;                     \\n                } else {\\n                    continue;\\n                }\\n                if(p == q){\\n                    return true;\\n                }\\n                m[j+\\'a\\'] = y;\\n                n[j+\\'a\\'] = z;\\n                p = t;\\n                q= u;\\n            }\\n            m[i+\\'a\\'] = w;\\n            n[i+\\'a\\'] = x;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char, int>m, n;\\n        int c=0, d=0;\\n        for(int i=0;i<word1.length();i++){\\n            if(m[word1[i]] == 0)\\n                c++;\\n            m[word1[i]]++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            if(n[word2[i]] == 0)\\n                d++;\\n            n[word2[i]]++;\\n        }\\n        for(int i=0;i<26;i++){\\n            int p = c, q = d;\\n            int w = m[i+\\'a\\'], x = n[i+\\'a\\'];  \\n            if(m[i+\\'a\\'] >= 1 ){\\n                if(m[i+\\'a\\'] == 1){\\n                     p--;\\n                }\\n                if(n[i+\\'a\\'] == 0){\\n                    q++;\\n                }\\n                n[i+\\'a\\']++;\\n                m[i+\\'a\\']--;\\n            } else {\\n                continue;\\n            }\\n            for(int j=0;j<26;j++){\\n                int t = p, u = q; \\n                int y = m[j+\\'a\\'], z = n[j+\\'a\\'];\\n                 if(n[j+\\'a\\'] >= 1){ //\\n                    if(i == j){\\n                        if(n[j+\\'a\\']<2){\\n                            continue;\\n                        }\\n                    } \\n                    if(n[j+\\'a\\'] == 1){\\n                        q--;\\n                    }\\n                    if(m[j+\\'a\\'] == 0){\\n                        p++;\\n                    }\\n                    n[j+\\'a\\']--;\\n                    m[j+\\'a\\']++;                     \\n                } else {\\n                    continue;\\n                }\\n                if(p == q){\\n                    return true;\\n                }\\n                m[j+\\'a\\'] = y;\\n                n[j+\\'a\\'] = z;\\n                p = t;\\n                q= u;\\n            }\\n            m[i+\\'a\\'] = w;\\n            n[i+\\'a\\'] = x;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026779,
                "title": "c-swap-and-restore",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int cnt1[26] = {}, cnt2[26] = {};\\n        for (char c: word1) cnt1[c-\\'a\\']++;\\n        for (char c: word2) cnt2[c-\\'a\\']++;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (cnt1[i] && cnt2[j]) {\\n                    // swap\\n                    cnt1[i]--, cnt1[j]++;\\n                    cnt2[i]++, cnt2[j]--;\\n                    if (count(begin(cnt1), end(cnt1), 0) == count(begin(cnt2), end(cnt2), 0))\\n                        return true;\\n                    // restore\\n                    cnt1[i]++, cnt1[j]--;\\n                    cnt2[i]--, cnt2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int cnt1[26] = {}, cnt2[26] = {};\\n        for (char c: word1) cnt1[c-\\'a\\']++;\\n        for (char c: word2) cnt2[c-\\'a\\']++;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (cnt1[i] && cnt2[j]) {\\n                    // swap\\n                    cnt1[i]--, cnt1[j]++;\\n                    cnt2[i]++, cnt2[j]--;\\n                    if (count(begin(cnt1), end(cnt1), 0) == count(begin(cnt2), end(cnt2), 0))\\n                        return true;\\n                    // restore\\n                    cnt1[i]++, cnt1[j]--;\\n                    cnt2[i]--, cnt2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026647,
                "title": "easy-with-explanation-c-using-vectors",
                "content": "Created an array of alphabets, which will store count of each alphabet in these two words. Then we navigate those two arrays simultaneously using nested for loop. We try replacing, that is increasing and dicreasing the value at swapped position, and checking if both had equal count. \\n\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int c1= 0,c2 =0;\\n        vector<int> w1(26,0), w2(26,0);\\n        //int std = int(\\'a\\');\\n        for(int i= 0 ;i<word1.size();i++)\\n        {\\n            if(!w1[word1[i]-\\'a\\'])\\n                c1++;\\n            w1[word1[i]-\\'a\\']++;\\n        }\\n        for(int i= 0 ;i<word2.size();i++)\\n        {\\n            if(!w2[word2[i]-\\'a\\'])\\n                c2++;\\n            w2[word2[i]-\\'a\\']++;\\n        }\\n        if((c1-c2)>2)\\n            return false;\\n        for(int i = 0;i<26;i++)\\n        {\\n            for(int j = 0;j<26;j++)\\n            {\\n                if(w1[i]&&w2[j])\\n                {\\n                    w1[i]--;\\n                    w1[j]++;\\n                    w2[i]++;\\n                    w2[j]--;\\n                    if(!w1[i])\\n                        c1--;\\n                    if(w1[j]==1)\\n                        c1++;\\n                    if(!w2[j])\\n                        c2--;\\n                    if(w2[i]==1)\\n                        c2++;\\n                    if(c1==c2)\\n                        return true;\\n                    if(!w1[i])\\n                        c1++;\\n                    if(w1[j]==1)\\n                        c1--;\\n                    if(!w2[j])\\n                        c2++;\\n                    if(w2[i]==1)\\n                        c2--;\\n                    w1[i]++;\\n                    w1[j]--;\\n                    w2[i]--;\\n                    w2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int c1= 0,c2 =0;\\n        vector<int> w1(26,0), w2(26,0);\\n        //int std = int(\\'a\\');\\n        for(int i= 0 ;i<word1.size();i++)\\n        {\\n            if(!w1[word1[i]-\\'a\\'])\\n                c1++;\\n            w1[word1[i]-\\'a\\']++;\\n        }\\n        for(int i= 0 ;i<word2.size();i++)\\n        {\\n            if(!w2[word2[i]-\\'a\\'])\\n                c2++;\\n            w2[word2[i]-\\'a\\']++;\\n        }\\n        if((c1-c2)>2)\\n            return false;\\n        for(int i = 0;i<26;i++)\\n        {\\n            for(int j = 0;j<26;j++)\\n            {\\n                if(w1[i]&&w2[j])\\n                {\\n                    w1[i]--;\\n                    w1[j]++;\\n                    w2[i]++;\\n                    w2[j]--;\\n                    if(!w1[i])\\n                        c1--;\\n                    if(w1[j]==1)\\n                        c1++;\\n                    if(!w2[j])\\n                        c2--;\\n                    if(w2[i]==1)\\n                        c2++;\\n                    if(c1==c2)\\n                        return true;\\n                    if(!w1[i])\\n                        c1++;\\n                    if(w1[j]==1)\\n                        c1--;\\n                    if(!w2[j])\\n                        c2++;\\n                    if(w2[i]==1)\\n                        c2--;\\n                    w1[i]++;\\n                    w1[j]--;\\n                    w2[i]--;\\n                    w2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026635,
                "title": "basic-dict-usage-and-simulation-python",
                "content": "1- A solution format\\n```\\n# Treatment: dict ADT basic usage\\n\\n# Observation: there are 26 lowercase English letters. Therefore, the number\\n# of unique chars in each word is bounded above by the constant 26.\\n\\n# We hence could try the swaps, i.e, consider all possibilities. We could\\n# use the subclass Counter of dict class to do the job.\\n\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2)\\n        \\n        # do the swaps\\n        for a in cnt1:\\n            for b in cnt2:\\n                ref1, ref2 = cnt1.copy(), cnt2.copy()\\n                ref1[a] -= 1\\n                ref1[b] += 1\\n                ref2[a] += 1\\n                ref2[b] -= 1\\n                if ref1[a] == 0:\\n                    del ref1[a]\\n                if ref2[b] == 0:\\n                    del ref2[b]\\n                if len(ref1.keys()) == len(ref2.keys()):\\n                    return True\\n        return False\\n    \\n```\\n2- Video Explanation: [Click Here](https://youtu.be/mnWyYkpuUcU;)\\n\\n",
                "solutionTags": [],
                "code": "```\\n# Treatment: dict ADT basic usage\\n\\n# Observation: there are 26 lowercase English letters. Therefore, the number\\n# of unique chars in each word is bounded above by the constant 26.\\n\\n# We hence could try the swaps, i.e, consider all possibilities. We could\\n# use the subclass Counter of dict class to do the job.\\n\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2)\\n        \\n        # do the swaps\\n        for a in cnt1:\\n            for b in cnt2:\\n                ref1, ref2 = cnt1.copy(), cnt2.copy()\\n                ref1[a] -= 1\\n                ref1[b] += 1\\n                ref2[a] += 1\\n                ref2[b] -= 1\\n                if ref1[a] == 0:\\n                    del ref1[a]\\n                if ref2[b] == 0:\\n                    del ref2[b]\\n                if len(ref1.keys()) == len(ref2.keys()):\\n                    return True\\n        return False\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026242,
                "title": "100-c-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCounting \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O ( 26 * 26 + n + m )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O( 26 + 26) ~= O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define upper_limit 97+26\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int a2[upper_limit]={0},a[upper_limit]={0};\\n        int c =0,c2=0;\\n        for(auto &i:word1){   \\n            if(a[i]==0)\\n                c++;\\n            a[i]++;\\n        }\\n        for(auto &i:word2){\\n            if(a2[i]==0)\\n                c2++;\\n            a2[i]++;\\n        }\\n        for(int i= 97 ; i< upper_limit;i++){\\n            for(int j = 97;j<upper_limit;j++){\\n                if(a[i]==0 || a2[j]==0)\\n                    continue;\\n                if(i==j){\\n                    if(c==c2)\\n                        return true;\\n                    else\\n                        continue;\\n                }\\n                if(true){\\n                    int at = a[i] , a2jt = a2[j] , ct = c , c2t=c2;\\n                    int aj = a[j] , a2it = a2[i];\\n                    at--;\\n                    if(at==0) ct--;\\n                    if(aj==0)\\n                        ct++;\\n                    aj++;\\n                    \\n                    a2jt--;\\n                    if(a2jt==0) c2t--;\\n                    if(a2it==0)\\n                        c2t++;\\n                    a2it++;\\n                    \\n                    if(ct==c2t) return true;   \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define upper_limit 97+26\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int a2[upper_limit]={0},a[upper_limit]={0};\\n        int c =0,c2=0;\\n        for(auto &i:word1){   \\n            if(a[i]==0)\\n                c++;\\n            a[i]++;\\n        }\\n        for(auto &i:word2){\\n            if(a2[i]==0)\\n                c2++;\\n            a2[i]++;\\n        }\\n        for(int i= 97 ; i< upper_limit;i++){\\n            for(int j = 97;j<upper_limit;j++){\\n                if(a[i]==0 || a2[j]==0)\\n                    continue;\\n                if(i==j){\\n                    if(c==c2)\\n                        return true;\\n                    else\\n                        continue;\\n                }\\n                if(true){\\n                    int at = a[i] , a2jt = a2[j] , ct = c , c2t=c2;\\n                    int aj = a[j] , a2it = a2[i];\\n                    at--;\\n                    if(at==0) ct--;\\n                    if(aj==0)\\n                        ct++;\\n                    aj++;\\n                    \\n                    a2jt--;\\n                    if(a2jt==0) c2t--;\\n                    if(a2it==0)\\n                        c2t++;\\n                    a2it++;\\n                    \\n                    if(ct==c2t) return true;   \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026154,
                "title": "golang-bit-set-manipulation-8-ms-6-3-mb-o-n-m",
                "content": "# Complexity\\n- Time complexity: $$O(n+m)$$\\n- Space complexity: $$O(1)$$\\n# Code\\n```\\ntype DistinctChars struct {\\n\\tchars         int32\\n\\tsingleChars   int32\\n\\tmultipleChars int32\\n}\\n\\nfunc (d DistinctChars) canMoveNewSingleCharTo(destination DistinctChars) bool {\\n\\treturn d.singleChars^(d.singleChars&destination.chars) != 0\\n}\\nfunc (d DistinctChars) canMoveExistingSingleCharTo(destination DistinctChars) bool {\\n\\treturn d.singleChars&destination.chars != 0\\n}\\nfunc (d DistinctChars) canMoveNewMultipleCharTo(destination DistinctChars) bool {\\n\\treturn d.multipleChars^(d.multipleChars&destination.chars) != 0\\n}\\nfunc (d DistinctChars) canMoveExistingMultipleCharTo(destination DistinctChars) bool {\\n\\treturn d.multipleChars&destination.chars != 0\\n}\\n\\nfunc toDistinctChars(word string) (distinctCharsCount int8, distinctChars DistinctChars) {\\n\\tvar counts [26]uint32\\n\\tfor i := range word {\\n\\t\\tcounts[word[i]-\\'a\\']++\\n\\t}\\n\\tfor i, count := range counts {\\n\\t\\tif count != 0 {\\n\\t\\t\\tdistinctCharsCount++\\n\\t\\t\\tif count == 1 {\\n\\t\\t\\t\\tdistinctChars.singleChars |= 1 << i\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdistinctChars.multipleChars |= 1 << i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tdistinctChars.chars = distinctChars.singleChars | distinctChars.multipleChars\\n\\treturn\\n}\\n\\nfunc isItPossible(word1 string, word2 string) bool {\\n\\tcount1, d1 := toDistinctChars(word1)\\n\\tcount2, d2 := toDistinctChars(word2)\\n\\tif count1 < count2 {\\n\\t\\tcount1, count2 = count2, count1\\n\\t\\td1, d2 = d2, d1\\n\\t}\\n\\tif count1 == 2 && count2 == 1 {\\n\\t\\treturn d1.singleChars&d2.singleChars != 0\\n\\t}\\n\\tswitch count1 - count2 {\\n\\tcase 0:\\n\\t\\treturn (d1.canMoveNewMultipleCharTo(d2) && d2.canMoveNewMultipleCharTo(d1)) ||\\n\\t\\t\\t(d1.canMoveExistingMultipleCharTo(d2) && d2.canMoveExistingMultipleCharTo(d1)) ||\\n\\t\\t\\t(d1.canMoveNewSingleCharTo(d2) && d2.canMoveNewSingleCharTo(d1))\\n\\tcase 1:\\n\\t\\treturn (d1.canMoveNewMultipleCharTo(d2) && d2.canMoveExistingMultipleCharTo(d1)) ||\\n\\t\\t\\t(d1.canMoveNewSingleCharTo(d2) && d2.canMoveNewMultipleCharTo(d1)) ||\\n\\t\\t\\t(d1.canMoveExistingSingleCharTo(d2) && d2.canMoveExistingMultipleCharTo(d1))\\n\\tcase 2:\\n\\t\\treturn d1.canMoveNewSingleCharTo(d2) && d2.canMoveExistingMultipleCharTo(d1)\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype DistinctChars struct {\\n\\tchars         int32\\n\\tsingleChars   int32\\n\\tmultipleChars int32\\n}\\n\\nfunc (d DistinctChars) canMoveNewSingleCharTo(destination DistinctChars) bool {\\n\\treturn d.singleChars^(d.singleChars&destination.chars) != 0\\n}\\nfunc (d DistinctChars) canMoveExistingSingleCharTo(destination DistinctChars) bool {\\n\\treturn d.singleChars&destination.chars != 0\\n}\\nfunc (d DistinctChars) canMoveNewMultipleCharTo(destination DistinctChars) bool {\\n\\treturn d.multipleChars^(d.multipleChars&destination.chars) != 0\\n}\\nfunc (d DistinctChars) canMoveExistingMultipleCharTo(destination DistinctChars) bool {\\n\\treturn d.multipleChars&destination.chars != 0\\n}\\n\\nfunc toDistinctChars(word string) (distinctCharsCount int8, distinctChars DistinctChars) {\\n\\tvar counts [26]uint32\\n\\tfor i := range word {\\n\\t\\tcounts[word[i]-\\'a\\']++\\n\\t}\\n\\tfor i, count := range counts {\\n\\t\\tif count != 0 {\\n\\t\\t\\tdistinctCharsCount++\\n\\t\\t\\tif count == 1 {\\n\\t\\t\\t\\tdistinctChars.singleChars |= 1 << i\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdistinctChars.multipleChars |= 1 << i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tdistinctChars.chars = distinctChars.singleChars | distinctChars.multipleChars\\n\\treturn\\n}\\n\\nfunc isItPossible(word1 string, word2 string) bool {\\n\\tcount1, d1 := toDistinctChars(word1)\\n\\tcount2, d2 := toDistinctChars(word2)\\n\\tif count1 < count2 {\\n\\t\\tcount1, count2 = count2, count1\\n\\t\\td1, d2 = d2, d1\\n\\t}\\n\\tif count1 == 2 && count2 == 1 {\\n\\t\\treturn d1.singleChars&d2.singleChars != 0\\n\\t}\\n\\tswitch count1 - count2 {\\n\\tcase 0:\\n\\t\\treturn (d1.canMoveNewMultipleCharTo(d2) && d2.canMoveNewMultipleCharTo(d1)) ||\\n\\t\\t\\t(d1.canMoveExistingMultipleCharTo(d2) && d2.canMoveExistingMultipleCharTo(d1)) ||\\n\\t\\t\\t(d1.canMoveNewSingleCharTo(d2) && d2.canMoveNewSingleCharTo(d1))\\n\\tcase 1:\\n\\t\\treturn (d1.canMoveNewMultipleCharTo(d2) && d2.canMoveExistingMultipleCharTo(d1)) ||\\n\\t\\t\\t(d1.canMoveNewSingleCharTo(d2) && d2.canMoveNewMultipleCharTo(d1)) ||\\n\\t\\t\\t(d1.canMoveExistingSingleCharTo(d2) && d2.canMoveExistingMultipleCharTo(d1))\\n\\tcase 2:\\n\\t\\treturn d1.canMoveNewSingleCharTo(d2) && d2.canMoveExistingMultipleCharTo(d1)\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3026133,
                "title": "dart",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(1)$\\n\\n# Code\\n```dart\\nclass Solution {\\n  bool isItPossible(String word1, String word2) {\\n    final chars1 = _charFreq(word1), chars2 = _charFreq(word2);\\n    final count1 = _distinctCharacters(chars1), count2 = _distinctCharacters(chars2);\\n    final targetCountDiff = count2 - count1;\\n\\n    for (var l = 0; l < chars1.length; l++) {\\n      if (chars1[l] == 0) {\\n        continue;\\n      }\\n      for (var r = 0; r < chars2.length; r++) {\\n        if (chars2[r] == 0) {\\n          continue;\\n        }\\n        var netCountDiff = 0;\\n        if (l != r) {\\n          if (chars1[l] == 1) {\\n            // Moving word1[l] to word2 reduces distinct characters in word1.\\n            netCountDiff--;\\n          }\\n          if (chars2[l] == 0) {\\n            // Moving word1[l] to word2 increases distinct characters in word2.\\n            netCountDiff--;\\n          }\\n          if (chars2[r] == 1) {\\n            // Moving word2[r] to word1 decreases distinct characters in word2.\\n            netCountDiff++;\\n          }\\n          if (chars1[r] == 0) {\\n            // Moving word2[r] to word1 increases distinct characters in word1.\\n            netCountDiff++;\\n          }\\n        }\\n        if (netCountDiff == targetCountDiff) {\\n          return true;\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  List<int> _charFreq(String word) {\\n    final freq = List<int>.filled(26, 0);\\n    for (final char in word.codeUnits) {\\n      freq[char - _a]++;\\n    }\\n    return freq;\\n  }\\n\\n  int _distinctCharacters(List<int> charFrequency) {\\n    var result = 0;\\n    for (final count in charFrequency) {\\n      if (count > 0) {\\n        result++;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  final _a = \\'a\\'.codeUnitAt(0);\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```dart\\nclass Solution {\\n  bool isItPossible(String word1, String word2) {\\n    final chars1 = _charFreq(word1), chars2 = _charFreq(word2);\\n    final count1 = _distinctCharacters(chars1), count2 = _distinctCharacters(chars2);\\n    final targetCountDiff = count2 - count1;\\n\\n    for (var l = 0; l < chars1.length; l++) {\\n      if (chars1[l] == 0) {\\n        continue;\\n      }\\n      for (var r = 0; r < chars2.length; r++) {\\n        if (chars2[r] == 0) {\\n          continue;\\n        }\\n        var netCountDiff = 0;\\n        if (l != r) {\\n          if (chars1[l] == 1) {\\n            // Moving word1[l] to word2 reduces distinct characters in word1.\\n            netCountDiff--;\\n          }\\n          if (chars2[l] == 0) {\\n            // Moving word1[l] to word2 increases distinct characters in word2.\\n            netCountDiff--;\\n          }\\n          if (chars2[r] == 1) {\\n            // Moving word2[r] to word1 decreases distinct characters in word2.\\n            netCountDiff++;\\n          }\\n          if (chars1[r] == 0) {\\n            // Moving word2[r] to word1 increases distinct characters in word1.\\n            netCountDiff++;\\n          }\\n        }\\n        if (netCountDiff == targetCountDiff) {\\n          return true;\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  List<int> _charFreq(String word) {\\n    final freq = List<int>.filled(26, 0);\\n    for (final char in word.codeUnits) {\\n      freq[char - _a]++;\\n    }\\n    return freq;\\n  }\\n\\n  int _distinctCharacters(List<int> charFrequency) {\\n    var result = 0;\\n    for (final count in charFrequency) {\\n      if (count > 0) {\\n        result++;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  final _a = \\'a\\'.codeUnitAt(0);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026058,
                "title": "c-proper-explanation-o-26-26",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Simple approach to check which pair of characters is safe to swap and that creates a balance.\\n- To keep the complexity as O(26*26) we used the Unordered_map.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n ```\\nInput: word1 = \"abcc\", word2 = \"aab\"\\nOutput: true\\n\\n1st valid Match :- ch1 = a     ch2 = a\\n    However, on swapping them we dosen\\'t create a difference  \\n\\n2nd valid Match :- ch1 = a     ch2 = a\\n    Similarly, of no use\\n\\n3rd valid match :- ch1 = a     ch2 = b\\n    Similarly, of no use\\n\\n4rd valid match :- ch1 = b     ch2 = a\\n    Similarly, of no use\\n\\n5rd valid match :- ch1 = b     ch2 = a\\n    Similarly, of no use\\n\\n6rd valid match :- ch1 = b     ch2 = b\\n    Similarly, of no use\\n\\n7rd valid match :- ch1 = c     ch2 = a\\n    Swap ch1 and ch2\\n    Now, Number of unique characters in word1 = 3. ie. a,b,c\\n         Number of unique characters in word2 = 3. ie. a,b,c\\n\\n    Hence, mp1.size() == mp2.size()  => and now return True;\\n```\\n\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(26*26)**\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(M+N)**\\nM - word1.size()\\nN - word2.size()\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int>mp1,mp2;\\n\\n        for(auto it:word1)mp1[it]++;\\n        for(auto it:word2)mp2[it]++;\\n\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                int ch1 = i + \\'a\\', ch2 = j + \\'a\\';\\n\\n                if(mp1.count(ch1) & mp2.count(ch2)){\\n                    if(--mp1[ch1] == 0)mp1.erase(ch1);\\n                    if(--mp2[ch2] == 0)mp2.erase(ch2);\\n\\n                    mp1[ch2]++;\\n                    mp2[ch1]++;\\n\\n                    if(mp1.size() == mp2.size()){\\n                        return true;\\n                    }\\n\\n                    if(--mp1[ch2] == 0){\\n                        mp1.erase(ch2);\\n                    }\\n                    if(--mp2[ch1] == 0){\\n                        mp2.erase(ch1);\\n                    }\\n                    mp1[ch1]++;\\n                    mp2[ch2]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n//Credit @geekykant for code\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nInput: word1 = \"abcc\", word2 = \"aab\"\\nOutput: true\\n\\n1st valid Match :- ch1 = a     ch2 = a\\n    However, on swapping them we dosen\\'t create a difference  \\n\\n2nd valid Match :- ch1 = a     ch2 = a\\n    Similarly, of no use\\n\\n3rd valid match :- ch1 = a     ch2 = b\\n    Similarly, of no use\\n\\n4rd valid match :- ch1 = b     ch2 = a\\n    Similarly, of no use\\n\\n5rd valid match :- ch1 = b     ch2 = a\\n    Similarly, of no use\\n\\n6rd valid match :- ch1 = b     ch2 = b\\n    Similarly, of no use\\n\\n7rd valid match :- ch1 = c     ch2 = a\\n    Swap ch1 and ch2\\n    Now, Number of unique characters in word1 = 3. ie. a,b,c\\n         Number of unique characters in word2 = 3. ie. a,b,c\\n\\n    Hence, mp1.size() == mp2.size()  => and now return True;\\n```\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char,int>mp1,mp2;\\n\\n        for(auto it:word1)mp1[it]++;\\n        for(auto it:word2)mp2[it]++;\\n\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                int ch1 = i + \\'a\\', ch2 = j + \\'a\\';\\n\\n                if(mp1.count(ch1) & mp2.count(ch2)){\\n                    if(--mp1[ch1] == 0)mp1.erase(ch1);\\n                    if(--mp2[ch2] == 0)mp2.erase(ch2);\\n\\n                    mp1[ch2]++;\\n                    mp2[ch1]++;\\n\\n                    if(mp1.size() == mp2.size()){\\n                        return true;\\n                    }\\n\\n                    if(--mp1[ch2] == 0){\\n                        mp1.erase(ch2);\\n                    }\\n                    if(--mp2[ch1] == 0){\\n                        mp2.erase(ch1);\\n                    }\\n                    mp1[ch1]++;\\n                    mp2[ch2]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n//Credit @geekykant for code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025313,
                "title": "javascript-brute-force-83ms",
                "content": "Main idea: use two 26 length arrays to record the conditions of two strings, swap chars can be represents as a[i]-- b[i]++ b[j]-- a[j]++, compare two arrays during each swap to check if equal distinct meet.\\n```\\nconst ord = (c) => c.charCodeAt();\\n\\nconst isItPossible = (s, t) => {\\n    let a = Array(26).fill(0), b = Array(26).fill(0);\\n    for (const c of s) a[ord(c) - 97]++;\\n    for (const c of t) b[ord(c) - 97]++;\\n    for (let i = 0; i < 26; i++) {\\n        if (a[i] > 0) {\\n            for (let j = 0; j < 26; j++) {\\n                if (b[j] > 0) {\\n                   // swap chars\\n                   a[i]--;\\n                   b[i]++; // s char to t\\n                   b[j]--;\\n                   a[j]++; // t char to s\\n                   if (equalDistinct(a, b)) return true;\\n                   // withdraw\\n                   a[i]++;\\n                   b[i]--;\\n                   b[j]++;\\n                   a[j]--;\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n};\\n\\nconst equalDistinct = (a, b) => {\\n    let cntA = 0, cntB = 0;\\n    for (let i = 0; i < 26; i++) {\\n        if (a[i] > 0) cntA++;\\n        if (b[i] > 0) cntB++;\\n    }\\n    return cntA == cntB;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Counting"
                ],
                "code": "```\\nconst ord = (c) => c.charCodeAt();\\n\\nconst isItPossible = (s, t) => {\\n    let a = Array(26).fill(0), b = Array(26).fill(0);\\n    for (const c of s) a[ord(c) - 97]++;\\n    for (const c of t) b[ord(c) - 97]++;\\n    for (let i = 0; i < 26; i++) {\\n        if (a[i] > 0) {\\n            for (let j = 0; j < 26; j++) {\\n                if (b[j] > 0) {\\n                   // swap chars\\n                   a[i]--;\\n                   b[i]++; // s char to t\\n                   b[j]--;\\n                   a[j]++; // t char to s\\n                   if (equalDistinct(a, b)) return true;\\n                   // withdraw\\n                   a[i]++;\\n                   b[i]--;\\n                   b[j]++;\\n                   a[j]--;\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n};\\n\\nconst equalDistinct = (a, b) => {\\n    let cntA = 0, cntB = 0;\\n    for (let i = 0; i < 26; i++) {\\n        if (a[i] > 0) cntA++;\\n        if (b[i] > 0) cntB++;\\n    }\\n    return cntA == cntB;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3024751,
                "title": "easy-java-solution-one-of-the-best-question",
                "content": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int [] w1 = new int[26];\\n        int [] w2 = new int[26];\\n        int L1 = word1.length(); \\n        int L2 = word2.length();\\n     \\n        for(int i=0; i<L1; i++) {\\n            int index = word1.charAt(i)-\\'a\\';\\n            w1[index] = w1[index] + 1;\\n        }\\n        for(int i=0; i<L2; i++) {\\n            int index = word2.charAt(i)-\\'a\\';\\n            w2[index] = w2[index] + 1;   \\n        }\\n        \\n        for(int i=0; i<26; i++) {\\n            if(w1[i]>0) {\\n                 for(int j=0; j<26; j++) {\\n                      if(w2[j]>0) {\\n                          w1[j]++;\\n                          w1[i]--;\\n                          w2[i]++;\\n                          w2[j]--;\\n                          int x = count(w1);\\n                          int y = count(w2);\\n                          if(x==y) {\\n                              return true;\\n                          }\\n                          w1[j]--;\\n                          w1[i]++;\\n                          w2[i]--;\\n                          w2[j]++;\\n                      }\\n                 }\\n            }\\n        }    \\n        return false;\\n            \\n    } \\n        \\n        int count (int [] letter) {\\n            int count = 0;\\n            for(int i=0; i<26; i++) {\\n                if(letter[i]>0) {\\n                    count++;\\n                }\\n            }\\n            return count;\\n        }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int [] w1 = new int[26];\\n        int [] w2 = new int[26];\\n        int L1 = word1.length(); \\n        int L2 = word2.length();\\n     \\n        for(int i=0; i<L1; i++) {\\n            int index = word1.charAt(i)-\\'a\\';\\n            w1[index] = w1[index] + 1;\\n        }\\n        for(int i=0; i<L2; i++) {\\n            int index = word2.charAt(i)-\\'a\\';\\n            w2[index] = w2[index] + 1;   \\n        }\\n        \\n        for(int i=0; i<26; i++) {\\n            if(w1[i]>0) {\\n                 for(int j=0; j<26; j++) {\\n                      if(w2[j]>0) {\\n                          w1[j]++;\\n                          w1[i]--;\\n                          w2[i]++;\\n                          w2[j]--;\\n                          int x = count(w1);\\n                          int y = count(w2);\\n                          if(x==y) {\\n                              return true;\\n                          }\\n                          w1[j]--;\\n                          w1[i]++;\\n                          w2[i]--;\\n                          w2[j]++;\\n                      }\\n                 }\\n            }\\n        }    \\n        return false;\\n            \\n    } \\n        \\n        int count (int [] letter) {\\n            int count = 0;\\n            for(int i=0; i<26; i++) {\\n                if(letter[i]>0) {\\n                    count++;\\n                }\\n            }\\n            return count;\\n        }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024463,
                "title": "java-ascii-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean isItPossible(String word1, String word2) {\\n    int let1[] = getLetters(word1);\\n    int let2[] = getLetters(word2);\\n\\n    for(int i = 0; i != 26; i++)\\n      if(let1[i] != 0){\\n        for(int j = 0; j != 26; j++)\\n          if(let2[j] != 0){\\n            let2[j]--;\\n            let1[j]++;\\n            let1[i]--;\\n            let2[i]++;\\n\\n            if(getDistinct(let1) == getDistinct(let2)) return true;\\n\\n            let1[i]++;\\n            let2[i]--;\\n            let2[j]++;\\n            let1[j]--;\\n          }     \\n      }\\n \\n    return false;      \\n  }\\n\\n  private int[] getLetters(String word){\\n    int letters[] = new int[26];\\n    for(int i = 0; i != word.length(); i++)\\n      letters[word.charAt(i)-\\'a\\']++;\\n    return letters;\\n  }\\n\\n  private int getDistinct(int[] letters){\\n    int distinct = 0;\\n    for(int letter : letters)\\n      if(letter != 0) distinct++;\\n    return distinct;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean isItPossible(String word1, String word2) {\\n    int let1[] = getLetters(word1);\\n    int let2[] = getLetters(word2);\\n\\n    for(int i = 0; i != 26; i++)\\n      if(let1[i] != 0){\\n        for(int j = 0; j != 26; j++)\\n          if(let2[j] != 0){\\n            let2[j]--;\\n            let1[j]++;\\n            let1[i]--;\\n            let2[i]++;\\n\\n            if(getDistinct(let1) == getDistinct(let2)) return true;\\n\\n            let1[i]++;\\n            let2[i]--;\\n            let2[j]++;\\n            let1[j]--;\\n          }     \\n      }\\n \\n    return false;      \\n  }\\n\\n  private int[] getLetters(String word){\\n    int letters[] = new int[26];\\n    for(int i = 0; i != word.length(); i++)\\n      letters[word.charAt(i)-\\'a\\']++;\\n    return letters;\\n  }\\n\\n  private int getDistinct(int[] letters){\\n    int distinct = 0;\\n    for(int letter : letters)\\n      if(letter != 0) distinct++;\\n    return distinct;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024440,
                "title": "beat-70-explaining-all-the-possible-branch-c-solution-with-explanation",
                "content": "# Intuition\\nWe could consider a swap as two move. Move a char from string a to b and move a char from string b to a.\\n- The outcome of each move is either:\\n    - string a lose a character and string b add a character (denote -1 in a and + 1 in b)\\n        - it is the only character in a and there is no that character in b\\n    - string a no change and string b add a character (denote -0 in a and + 1 in b)\\n        - there are more than one character in a and there is no character in b\\n    - string a lose a character and string b no change (denote -1 in a and + 1 in b)\\n        - it is the only character in a and there is character in b\\n    - string a no change and string b no change (denote -0 in a and + 0 in b)\\n        - there are more than one character in a and there is character in b\\n\\n- Therefore, in the four outcomes in 1 move, the result is either (-1, +1), (-1, +0), (-0, +1), (-0, +0)\\n- Reversely, from move b to a, the result is either (+1, -1), (+1, -0), (+0, -1), (+0, -0)\\n\\n=> As a result, by combining two moves into a swap, (which would be 4 * 4 possible cases) we could get that after a swap, it would either(-1/0/+1, -1/0/+1)\\n=> By preprocessing, we could know that diff between distinct of string a and string b\\n=> Let\\'s say for example, if distinct(a) == distinct(b), we only need to consider the combination of move that contribute to swap for (+1, +1), (-1, -1), (0, 0)\\n=> Let\\'s say for example, if distinct(a - 1) == distinct(b), we only need to consider the combination of move that contribute to swap for (+1, 0), (0, -1)\\n=> and this case will be the answer\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char, int> dict, dict2;\\n        for (auto &a: word1) dict[a]++; \\n        for (auto &a: word2) dict2[a]++;\\n        if (dict.size() < dict2.size()) swap(dict, dict2);\\n        // 0: add; 1: minus\\n        bool condition10(false), condition11(false), condition01(false), condition00(false);\\n        for (auto &a: dict){\\n            if (a.second > 1 && dict2.find(a.first) == dict2.end()) condition10 = true;\\n            if (a.second == 1 && dict2.find(a.first) == dict2.end()) condition11 = true;\\n            if (a.second > 1 && dict2.find(a.first) != dict2.end()) condition00 = true;\\n            if (a.second == 1 && dict2.find(a.first) != dict2.end()) condition01 = true;\\n        }\\n\\n        if (dict.size() == dict2.size()){\\n            // sum == 0\\n            for (auto &b: dict2){\\n                if (b.second > 1 && dict.find(b.first) != dict.end() && condition00) return true;\\n                if ((b.second == 1 && dict.find(b.first) != dict.end() || (b.second > 1 && dict.find(b.first) == dict.end())) && (condition10 || condition01)) return true;\\n                if (b.second == 1 && dict.find(b.first) == dict.end() && condition11) return true;\\n            }\\n        }else if(dict.size() - 1 == dict2.size()){\\n            // sum == 1 = -1 + 2 or 0 + 1\\n            for (auto &b: dict2){\\n                if ((b.second == 1 && dict.find(b.first) != dict.end() || (b.second > 1 && dict.find(b.first) == dict.end())) && condition11) return true;\\n                if (b.second > 1 && dict.find(b.first) != dict.end() && (condition10 || condition10)) return true;\\n            }\\n        }else if(dict.size() - 2 == dict2.size()){\\n            // sum == 2 = 0 + 2\\n            for (auto &b : dict2) \\n                if (b.second > 1 && dict.find(b.first) != dict.end() && condition11) return true;\\n        } \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        unordered_map<char, int> dict, dict2;\\n        for (auto &a: word1) dict[a]++; \\n        for (auto &a: word2) dict2[a]++;\\n        if (dict.size() < dict2.size()) swap(dict, dict2);\\n        // 0: add; 1: minus\\n        bool condition10(false), condition11(false), condition01(false), condition00(false);\\n        for (auto &a: dict){\\n            if (a.second > 1 && dict2.find(a.first) == dict2.end()) condition10 = true;\\n            if (a.second == 1 && dict2.find(a.first) == dict2.end()) condition11 = true;\\n            if (a.second > 1 && dict2.find(a.first) != dict2.end()) condition00 = true;\\n            if (a.second == 1 && dict2.find(a.first) != dict2.end()) condition01 = true;\\n        }\\n\\n        if (dict.size() == dict2.size()){\\n            // sum == 0\\n            for (auto &b: dict2){\\n                if (b.second > 1 && dict.find(b.first) != dict.end() && condition00) return true;\\n                if ((b.second == 1 && dict.find(b.first) != dict.end() || (b.second > 1 && dict.find(b.first) == dict.end())) && (condition10 || condition01)) return true;\\n                if (b.second == 1 && dict.find(b.first) == dict.end() && condition11) return true;\\n            }\\n        }else if(dict.size() - 1 == dict2.size()){\\n            // sum == 1 = -1 + 2 or 0 + 1\\n            for (auto &b: dict2){\\n                if ((b.second == 1 && dict.find(b.first) != dict.end() || (b.second > 1 && dict.find(b.first) == dict.end())) && condition11) return true;\\n                if (b.second > 1 && dict.find(b.first) != dict.end() && (condition10 || condition10)) return true;\\n            }\\n        }else if(dict.size() - 2 == dict2.size()){\\n            // sum == 2 = 0 + 2\\n            for (auto &b : dict2) \\n                if (b.second > 1 && dict.find(b.first) != dict.end() && condition11) return true;\\n        } \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024294,
                "title": "easy-java-solution",
                "content": "# Approach\\nJust swapping every character of word1 with word2 and checking the count of distinct characters\\n\\n# Complexity\\n- Time complexity:\\n  O(26 * 26 * 26)\\n\\n- Space complexity:\\n   O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] a=new int[26];\\n        int[] b=new int[26];\\n        for(int i=0;i<word1.length();i++){\\n            a[word1.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            b[word2.charAt(i)-\\'a\\']++;\\n        }\\n        boolean f=false;\\n        for(int i=0;i<26;i++){\\n            if(a[i]>0){\\n                for(int j=0;j<26;j++){\\n                    if(b[j]>0){\\n                        a[j]++;         //swapping the characters in these 4 lines\\n                        a[i]--;\\n                        b[j]--;\\n                        b[i]++;\\n                        int x=solve(a); // counting no. of distinct characters\\n                        int y=solve(b);\\n                        if(x==y) return true;\\n                        a[j]--;                //swapping the characters back in these 4 lines\\n                        a[i]++;\\n                        b[j]++;\\n                        b[i]--;\\n                    }\\n                }\\n            }\\n        }\\n        return f;\\n    }\\n    int solve(int[] a){\\n        int c=0;\\n        for(int i:a){\\n            if(i>0) c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int[] a=new int[26];\\n        int[] b=new int[26];\\n        for(int i=0;i<word1.length();i++){\\n            a[word1.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            b[word2.charAt(i)-\\'a\\']++;\\n        }\\n        boolean f=false;\\n        for(int i=0;i<26;i++){\\n            if(a[i]>0){\\n                for(int j=0;j<26;j++){\\n                    if(b[j]>0){\\n                        a[j]++;         //swapping the characters in these 4 lines\\n                        a[i]--;\\n                        b[j]--;\\n                        b[i]++;\\n                        int x=solve(a); // counting no. of distinct characters\\n                        int y=solve(b);\\n                        if(x==y) return true;\\n                        a[j]--;                //swapping the characters back in these 4 lines\\n                        a[i]++;\\n                        b[j]++;\\n                        b[i]--;\\n                    }\\n                }\\n            }\\n        }\\n        return f;\\n    }\\n    int solve(int[] a){\\n        int c=0;\\n        for(int i:a){\\n            if(i>0) c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024225,
                "title": "python-3-iterative-solution-t-m-100-71",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe basic idea here is to compute the effect of swapping a set of character between the words. For every distinct pair of characters, one each from each word, we assess the impact of this swap on the total number of distinct elements in each word.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCompare every unique character in word1 with every unique character from word2. Assign effect values based on various conditions.\\nSome of the conditions to watch out for are : \\n1. If both characters are the same\\n2. Whether the number of occurences of the character in the word is once or more than once.\\n3. Whether the character is present in the other word as well\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI believe O(nm), where n and m are number of unique characters in both words\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        \\n        from collections import Counter\\n\\n        c1,c2 = Counter(word1), Counter(word2)\\n        word1,word2 = set(word1), set(word2)\\n        n1,n2 = len(word1), len(word2)\\n\\n\\n        outcomes = []\\n\\n        for char1 in word1:\\n            for char2 in word2:\\n\\n                if char1 == char2:\\n                    outcomes.append((0,0))\\n                else:\\n\\n                    if c1[char1]==1:\\n                        effect1 = -1 if char2 in word1 else 0\\n                    else:\\n                        effect1 = 0 if char2 in word1 else 1\\n\\n                    if c2[char2]==1:\\n                        effect2 = -1 if char1 in word2 else 0\\n                    else:\\n                        effect2 = 0 if char1 in word2 else 1\\n\\n                    outcomes.append((effect1, effect2))\\n         \\n        \\n        for i in set(outcomes):\\n            // if any of the potential outcomes can make the number of unique characters in both words the same, then we return true\\n            if n1+i[0] == n2+i[1]:\\n                return True \\n\\n        return False\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        \\n        from collections import Counter\\n\\n        c1,c2 = Counter(word1), Counter(word2)\\n        word1,word2 = set(word1), set(word2)\\n        n1,n2 = len(word1), len(word2)\\n\\n\\n        outcomes = []\\n\\n        for char1 in word1:\\n            for char2 in word2:\\n\\n                if char1 == char2:\\n                    outcomes.append((0,0))\\n                else:\\n\\n                    if c1[char1]==1:\\n                        effect1 = -1 if char2 in word1 else 0\\n                    else:\\n                        effect1 = 0 if char2 in word1 else 1\\n\\n                    if c2[char2]==1:\\n                        effect2 = -1 if char1 in word2 else 0\\n                    else:\\n                        effect2 = 0 if char1 in word2 else 1\\n\\n                    outcomes.append((effect1, effect2))\\n         \\n        \\n        for i in set(outcomes):\\n            // if any of the potential outcomes can make the number of unique characters in both words the same, then we return true\\n            if n1+i[0] == n2+i[1]:\\n                return True \\n\\n        return False\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024076,
                "title": "clean-java-o-1-comments-explained",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int d1=0, d2=0; //distinct counts\\n        int[] f1 = new int[26]; //count for 26 alphabets\\n        int[] f2 = new int[26];\\n        for(char c : word1.toCharArray()) { //distinct & each char count\\n            int i = c-\\'a\\';\\n            if(f1[i]==0) d1++;\\n            f1[i]++;    \\n        }\\n        \\n        for(char c : word2.toCharArray()) { //distinct & each char count\\n            int i = c-\\'a\\';\\n            if(f2[i]==0) d2++;\\n            f2[i]++;    \\n        }\\n        \\n        //if distinct char count diff is more than 2 then can\\'t swap in exactly once\\n        if(Math.abs(d1-d2)>2) return false;\\n        \\n        //swap ith -> jth char\\n        for(int i=0; i<26; i++) {\\n            if(f1[i] == 0) continue;\\n            for(int j=0; j<26; j++) {\\n                if(f2[j] == 0) continue;\\n                int c1 = f1[i];\\n                int c2 = f2[j];\\n                int c1New = f1[j]; //after swap\\n                int c2New = f2[i]; //after swap\\n                int d1New=d1, d2New=d2;\\n                if(i!=j && c1New==0) d1New++; //when after swap count=0 then increase distinct count\\n                if(i!=j && c2New==0) d2New++;\\n                if(i!=j && c1==1) d1New--; //when before swap count=1 then decrease distinct count\\n                if(i!=j && c2==1) d2New--;\\n                if(d1New == d2New) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isItPossible(String word1, String word2) {\\n        int d1=0, d2=0; //distinct counts\\n        int[] f1 = new int[26]; //count for 26 alphabets\\n        int[] f2 = new int[26];\\n        for(char c : word1.toCharArray()) { //distinct & each char count\\n            int i = c-\\'a\\';\\n            if(f1[i]==0) d1++;\\n            f1[i]++;    \\n        }\\n        \\n        for(char c : word2.toCharArray()) { //distinct & each char count\\n            int i = c-\\'a\\';\\n            if(f2[i]==0) d2++;\\n            f2[i]++;    \\n        }\\n        \\n        //if distinct char count diff is more than 2 then can\\'t swap in exactly once\\n        if(Math.abs(d1-d2)>2) return false;\\n        \\n        //swap ith -> jth char\\n        for(int i=0; i<26; i++) {\\n            if(f1[i] == 0) continue;\\n            for(int j=0; j<26; j++) {\\n                if(f2[j] == 0) continue;\\n                int c1 = f1[i];\\n                int c2 = f2[j];\\n                int c1New = f1[j]; //after swap\\n                int c2New = f2[i]; //after swap\\n                int d1New=d1, d2New=d2;\\n                if(i!=j && c1New==0) d1New++; //when after swap count=0 then increase distinct count\\n                if(i!=j && c2New==0) d2New++;\\n                if(i!=j && c1==1) d1New--; //when before swap count=1 then decrease distinct count\\n                if(i!=j && c2==1) d2New--;\\n                if(d1New == d2New) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023930,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> vec1,vector<int> vec2){\\n        int a = 0,b=0;\\n        for(auto i:vec1) if(i>0) a++;\\n        for(auto i:vec2) if(i>0) b++;\\n        return a==b;\\n    }\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> vec1(26,0),vec2(26,0);\\n        for(auto i:word1) vec1[i-\\'a\\']++;\\n        for(auto i:word2) vec2[i-\\'a\\']++;\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(vec1[i]>0 && vec2[j]>0){\\n                    --vec1[i],--vec2[j];\\n                    vec1[j]++,vec2[i]++;\\n                    if(check(vec1,vec2)) return true;\\n                    --vec1[j],--vec2[i];\\n                    vec1[i]++,vec2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> vec1,vector<int> vec2){\\n        int a = 0,b=0;\\n        for(auto i:vec1) if(i>0) a++;\\n        for(auto i:vec2) if(i>0) b++;\\n        return a==b;\\n    }\\n    bool isItPossible(string word1, string word2) {\\n        vector<int> vec1(26,0),vec2(26,0);\\n        for(auto i:word1) vec1[i-\\'a\\']++;\\n        for(auto i:word2) vec2[i-\\'a\\']++;\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                if(vec1[i]>0 && vec2[j]>0){\\n                    --vec1[i],--vec2[j];\\n                    vec1[j]++,vec2[i]++;\\n                    if(check(vec1,vec2)) return true;\\n                    --vec1[j],--vec2[i];\\n                    vec1[i]++,vec2[j]++;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023857,
                "title": "c-solution-tc-o-n-m",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int arr[26]={0};\\n        int brr[26]={0};\\n        for(auto it:word1)arr[it-\\'a\\']++;\\n        for(auto it:word2) brr[it-\\'a\\']++;\\n\\n        for(int i=0;i<26;i++){\\n            if(arr[i]==0)continue;\\n            for(int j=0;j<26;j++){\\n                if(brr[j]>0){\\n                    arr[i]--;\\n                    arr[j]++;\\n                    brr[j]--;\\n                    brr[i]++;\\n                    int cnt1=0,cnt2=0;\\n                    for(int l=0;l<26;l++){\\n                        cnt1+=arr[l]>0;\\n                        cnt2+=brr[l]>0;\\n                    }                  \\n                    if(cnt1==cnt2)return true;\\n                    arr[i]++;\\n                    arr[j]--;\\n                    brr[j]++;\\n                    brr[i]--;  \\n                }\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isItPossible(string word1, string word2) {\\n        int arr[26]={0};\\n        int brr[26]={0};\\n        for(auto it:word1)arr[it-\\'a\\']++;\\n        for(auto it:word2) brr[it-\\'a\\']++;\\n\\n        for(int i=0;i<26;i++){\\n            if(arr[i]==0)continue;\\n            for(int j=0;j<26;j++){\\n                if(brr[j]>0){\\n                    arr[i]--;\\n                    arr[j]++;\\n                    brr[j]--;\\n                    brr[i]++;\\n                    int cnt1=0,cnt2=0;\\n                    for(int l=0;l<26;l++){\\n                        cnt1+=arr[l]>0;\\n                        cnt2+=brr[l]>0;\\n                    }                  \\n                    if(cnt1==cnt2)return true;\\n                    arr[i]++;\\n                    arr[j]--;\\n                    brr[j]++;\\n                    brr[i]--;  \\n                }\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023854,
                "title": "python-simple-solution-o-m-n-o-26-26",
                "content": "# Code\\n```\\nimport copy \\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        # print(word1, word2)\\n        s1 = set(list(word1))\\n        s2 = set(list(word2))\\n        if(len(word1)==len(s1) and len(word2)==len(s2) and len(s1)==len(s2)):\\n            return True\\n        if(len(s1)<len(s2)):\\n            temp = s2\\n            s2 = s1\\n            s1 = temp\\n        if(len(s1-s2)==0):\\n            return True\\n        else:\\n            dic1={}\\n            dic2 = {}\\n            for i in range(len(word1)):\\n                if(word1[i] in dic1):\\n                    dic1[word1[i]]+=1\\n                else:\\n                    dic1[word1[i]]=1\\n            for i in range(len(word2)):\\n                if(word2[i] in dic2):\\n                    dic2[word2[i]]+=1\\n                else:\\n                    dic2[word2[i]]=1\\n            for i in dic1:\\n                temp1 = copy.deepcopy(dic1)\\n                temp2 = copy.deepcopy(dic2)\\n                for j in dic2:\\n                    temp1[i]-=1\\n                    if(temp1[i]==0):\\n                        del temp1[i]\\n                    temp2[j]-=1\\n                    if(temp2[j]==0):\\n                        del temp2[j]\\n                    if(j in temp1):\\n                        temp1[j]+=1\\n                    else:\\n                        temp1[j]=1\\n                    if(i in temp2):\\n                        temp2[i]+=1\\n                    else:\\n                        temp2[i]=1\\n                    if(len(temp1)==len(temp2)):\\n                        return True\\n                    else:\\n                        if(j in temp2):\\n                            temp2[j]+=1\\n                        else:\\n                            temp2[j]=1\\n                        temp2[i]-=1\\n                        if(temp2[i]==0):\\n                            del temp2[i]\\n                        if(i in temp1):\\n                            temp1[i]+=1\\n                        else:\\n                            temp1[i]=1\\n                        temp1[j]-=1\\n                        if(temp1[j]==0):\\n                            del temp1[j]\\n            return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nimport copy \\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        # print(word1, word2)\\n        s1 = set(list(word1))\\n        s2 = set(list(word2))\\n        if(len(word1)==len(s1) and len(word2)==len(s2) and len(s1)==len(s2)):\\n            return True\\n        if(len(s1)<len(s2)):\\n            temp = s2\\n            s2 = s1\\n            s1 = temp\\n        if(len(s1-s2)==0):\\n            return True\\n        else:\\n            dic1={}\\n            dic2 = {}\\n            for i in range(len(word1)):\\n                if(word1[i] in dic1):\\n                    dic1[word1[i]]+=1\\n                else:\\n                    dic1[word1[i]]=1\\n            for i in range(len(word2)):\\n                if(word2[i] in dic2):\\n                    dic2[word2[i]]+=1\\n                else:\\n                    dic2[word2[i]]=1\\n            for i in dic1:\\n                temp1 = copy.deepcopy(dic1)\\n                temp2 = copy.deepcopy(dic2)\\n                for j in dic2:\\n                    temp1[i]-=1\\n                    if(temp1[i]==0):\\n                        del temp1[i]\\n                    temp2[j]-=1\\n                    if(temp2[j]==0):\\n                        del temp2[j]\\n                    if(j in temp1):\\n                        temp1[j]+=1\\n                    else:\\n                        temp1[j]=1\\n                    if(i in temp2):\\n                        temp2[i]+=1\\n                    else:\\n                        temp2[i]=1\\n                    if(len(temp1)==len(temp2)):\\n                        return True\\n                    else:\\n                        if(j in temp2):\\n                            temp2[j]+=1\\n                        else:\\n                            temp2[j]=1\\n                        temp2[i]-=1\\n                        if(temp2[i]==0):\\n                            del temp2[i]\\n                        if(i in temp1):\\n                            temp1[i]+=1\\n                        else:\\n                            temp1[i]=1\\n                        temp1[j]-=1\\n                        if(temp1[j]==0):\\n                            del temp1[j]\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023750,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsItPossible(string word1, string word2) {\\n        char[] arr1 = new char[26];\\n        char[] arr2 = new char[26];\\n        for(int i = 0; i < word1.Length; i++){\\n            arr1[word1[i] - \\'a\\']++;\\n        }\\n        for(int j = 0; j < word2.Length; j++){\\n            arr2[word2[j] - \\'a\\']++;\\n        }\\n        for(int m = 0; m < arr1.Length; m++){\\n            for(int n = 0; n < arr2.Length; n++){\\n                if(arr1[m] == 0 || arr2[n] == 0){\\n                    continue;\\n                }\\n                int count1 = 0;\\n                int count2 = 0;\\n                arr1[m]--;\\n                arr1[n]++;\\n                arr2[m]++;\\n                arr2[n]--;\\n                for(int p = 0; p < arr1.Length; p++){\\n                    if(arr1[p] > 0){\\n                        count1++;\\n                    }\\n                    if(arr2[p] > 0){\\n                        count2++;\\n                    }\\n                }\\n                if(count1 == count2){\\n                    return true;\\n                }\\n                arr1[m]++;\\n                arr1[n]--;\\n                arr2[m]--;\\n                arr2[n]++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsItPossible(string word1, string word2) {\\n        char[] arr1 = new char[26];\\n        char[] arr2 = new char[26];\\n        for(int i = 0; i < word1.Length; i++){\\n            arr1[word1[i] - \\'a\\']++;\\n        }\\n        for(int j = 0; j < word2.Length; j++){\\n            arr2[word2[j] - \\'a\\']++;\\n        }\\n        for(int m = 0; m < arr1.Length; m++){\\n            for(int n = 0; n < arr2.Length; n++){\\n                if(arr1[m] == 0 || arr2[n] == 0){\\n                    continue;\\n                }\\n                int count1 = 0;\\n                int count2 = 0;\\n                arr1[m]--;\\n                arr1[n]++;\\n                arr2[m]++;\\n                arr2[n]--;\\n                for(int p = 0; p < arr1.Length; p++){\\n                    if(arr1[p] > 0){\\n                        count1++;\\n                    }\\n                    if(arr2[p] > 0){\\n                        count2++;\\n                    }\\n                }\\n                if(count1 == count2){\\n                    return true;\\n                }\\n                arr1[m]++;\\n                arr1[n]--;\\n                arr2[m]--;\\n                arr2[n]++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022817,
                "title": "brute-force",
                "content": "Frustating Brute Force \\n\\n# Code\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        C1, C2 = Counter(word1), Counter(word2)\\n        \\n        l1, l2 = len(C1), len(C2)\\n        for i in C1:\\n            for j in C2:\\n                if i==j:\\n                    continue\\n                a,b = l1, l2\\n                if C1[i] == 1:\\n                    a -= 1\\n                if i not in C2:\\n                    b += 1\\n                if C2[j] == 1:\\n                    b -= 1\\n                if j not in C1:\\n                    a += 1\\n                if a==b:\\n                    return True\\n        return C1==C2\\n\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        C1, C2 = Counter(word1), Counter(word2)\\n        \\n        l1, l2 = len(C1), len(C2)\\n        for i in C1:\\n            for j in C2:\\n                if i==j:\\n                    continue\\n                a,b = l1, l2\\n                if C1[i] == 1:\\n                    a -= 1\\n                if i not in C2:\\n                    b += 1\\n                if C2[j] == 1:\\n                    b -= 1\\n                if j not in C1:\\n                    a += 1\\n                if a==b:\\n                    return True\\n        return C1==C2\\n\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022712,
                "title": "o-n-clean-and-clear",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThere are only 26 different characters to swap, and we can easily count the unique numbers of characters after each swap.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Store each character and its frequency in a map for word1 and word2 respectively,\\n2. Iterate all swap cases and recount the unique characters for word1 and word2, if they are equal, return true, else return false after all cases have been considered.\\n\\n# Python3\\n```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        counter1, counter2 = Counter(word1), Counter(word2)\\n        for char1, count1 in counter1.items():\\n            for char2, count2 in counter2.items():\\n                if char1 == char2:\\n                    if len(counter1) == len(counter2):\\n                        return True\\n                else:\\n                    if len(counter1) + (char2 not in counter1) - (count1 == 1)\\n                    == len(counter2) + (char1 not in counter2) - (count2 == 1):\\n                        return True\\n        return False\\n```\\n\\n# JavaScript\\n```\\n/**\\n * @param {string} word1\\n * @param {string} word2\\n * @return {boolean}\\n */\\nvar isItPossible = function(word1, word2) {\\n    const counter1 = {}, counter2 = {}\\n    for (let char of word1) {\\n        counter1[char] = (counter1[char] || 0) + 1\\n    }\\n    for (let char of word2) {\\n        counter2[char] = (counter2[char] || 0) + 1\\n    }\\n    for (let char1 of Object.keys(counter1)) {\\n        for (let char2 of Object.keys(counter2)) {\\n            if (char1 === char2) {\\n                if (Object.keys(counter1).length === Object.keys(counter2).length) {\\n                    return true\\n                }\\n            } else if (Object.keys(counter1).length + !counter1[char2] - (counter1[char1] === 1) \\n                       === Object.keys(counter2).length + !counter2[char1] - (counter2[char2] === 1)) {\\n                return true\\n            }\\n        }\\n    }\\n    return false\\n};\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M + N + 26 * 26) = O(N) where M is the length of word1 and N is the length of word2, because we have to iterate word1 and word2 to form the counter map.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(26 * 2) = O(1) to store 2 counter maps for word1 and word2 respectively.\\n",
                "solutionTags": [
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        counter1, counter2 = Counter(word1), Counter(word2)\\n        for char1, count1 in counter1.items():\\n            for char2, count2 in counter2.items():\\n                if char1 == char2:\\n                    if len(counter1) == len(counter2):\\n                        return True\\n                else:\\n                    if len(counter1) + (char2 not in counter1) - (count1 == 1)\\n                    == len(counter2) + (char1 not in counter2) - (count2 == 1):\\n                        return True\\n        return False\\n```\n```\\n/**\\n * @param {string} word1\\n * @param {string} word2\\n * @return {boolean}\\n */\\nvar isItPossible = function(word1, word2) {\\n    const counter1 = {}, counter2 = {}\\n    for (let char of word1) {\\n        counter1[char] = (counter1[char] || 0) + 1\\n    }\\n    for (let char of word2) {\\n        counter2[char] = (counter2[char] || 0) + 1\\n    }\\n    for (let char1 of Object.keys(counter1)) {\\n        for (let char2 of Object.keys(counter2)) {\\n            if (char1 === char2) {\\n                if (Object.keys(counter1).length === Object.keys(counter2).length) {\\n                    return true\\n                }\\n            } else if (Object.keys(counter1).length + !counter1[char2] - (counter1[char1] === 1) \\n                       === Object.keys(counter2).length + !counter2[char1] - (counter2[char2] === 1)) {\\n                return true\\n            }\\n        }\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022531,
                "title": "beats-100-using-frequency-array",
                "content": "# Complexity\\n- Time complexity:O(26* 26*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26+26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsItPossible(string word1, string word2) {\\n\\n        //frequency array\\n        int[] arr1=new int[26];\\n        int[] arr2=new int[26]; \\n\\n        for(int i=0;i<word1.Length;i++)\\n             arr1[word1[i]-\\'a\\']++;\\n        for(int i=0;i<word2.Length;i++)\\n             arr2[word2[i]-\\'a\\']++;   \\n\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr1[i]==0) continue;\\n            for(int j=0;j<26;j++)\\n            {\\n                if(arr2[j]==0) continue;\\n\\n                arr1[i]--;\\n                arr2[i]++;\\n\\n                arr2[j]--;\\n                arr1[j]++;\\n\\n                if(EqualCount(arr1,arr2)) return true;\\n\\n                //if count are not equal reverse the process\\n\\n                arr1[i]++;\\n                arr2[i]--;\\n\\n                arr2[j]++;\\n                arr1[j]--;\\n\\n            }\\n        }  \\n        return false;\\n    }\\n    bool EqualCount(int[] arr1,int[] arr2)\\n    {\\n        int count1=0,count2=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr1[i]>0) count1++;\\n            if(arr2[i]>0) count2++;\\n        }\\n        return count1==count2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsItPossible(string word1, string word2) {\\n\\n        //frequency array\\n        int[] arr1=new int[26];\\n        int[] arr2=new int[26]; \\n\\n        for(int i=0;i<word1.Length;i++)\\n             arr1[word1[i]-\\'a\\']++;\\n        for(int i=0;i<word2.Length;i++)\\n             arr2[word2[i]-\\'a\\']++;   \\n\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr1[i]==0) continue;\\n            for(int j=0;j<26;j++)\\n            {\\n                if(arr2[j]==0) continue;\\n\\n                arr1[i]--;\\n                arr2[i]++;\\n\\n                arr2[j]--;\\n                arr1[j]++;\\n\\n                if(EqualCount(arr1,arr2)) return true;\\n\\n                //if count are not equal reverse the process\\n\\n                arr1[i]++;\\n                arr2[i]--;\\n\\n                arr2[j]++;\\n                arr1[j]--;\\n\\n            }\\n        }  \\n        return false;\\n    }\\n    bool EqualCount(int[] arr1,int[] arr2)\\n    {\\n        int count1=0,count2=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr1[i]>0) count1++;\\n            if(arr2[i]>0) count2++;\\n        }\\n        return count1==count2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022495,
                "title": "beats-100-t-o-n-s-o-1-distinct-counts-must-not-differ-by-more-than-2",
                "content": "# Intuition\\nThis was a tough problem. I\\'ve included the brute force N**2 approach which is where I started. After that solution timed out I looked for a hint and noticed people using dictionaries / maps and realized that was a better approach. The trick is that we don\\'t care how long the strings are because we will only be performing 1 swap. Therefore, we only care about the set of chars that the strings contain.\\n\\n# Approach\\nUse dictionaries to count the chars in each word. The number of dictionary keys tells us the distinct char count for each word.\\n\\nUse nested loops to iterate over the dictionary keys. In the worst case this is 26 * 26 iterations, which is constant time: T(1).\\n\\nEmulate the swaps by manipulating the distinct counts.\\n\\nNote that if the distinct counts differ by more than 2 there is no need to emulate swaps because it isn\\'t possible for the distinct counts to eventually match.\\n\\n# Complexity\\n- Time complexity:\\nO(n + m) for counting the chars to create the dictionaries.\\n\\n- Space complexity:\\nO(1) because the dictionaries are constant size (max 26 keys)\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    # T: O(n) for counting the chars to create dictionary\\n    # S: O(1) dicts are contant size (26 keys, 26 vals)\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        counts1 = Counter(word1)\\n        distinctCount1 = len(counts1.keys())\\n        counts2 = Counter(word2)\\n        distinctCount2 = len(counts2.keys())\\n\\n        if abs(distinctCount1 - distinctCount2) > 2:\\n            # the number of distinct vals in each word must not differ\\n            #  by more than 2.\\n            return False\\n\\n        for c1 in counts1.keys(): # T: O(1) => (26 * 26) worst case\\n            for c2 in counts2.keys():\\n                dC1 = distinctCount1\\n                dC2 = distinctCount2\\n                if counts1[c1] == 1 and c1 != c2:\\n                    dC1 -= 1\\n                if c2 not in counts1:\\n                    dC1 += 1\\n                if counts2[c2] == 1 and c1 != c2:\\n                    dC2 -= 1\\n                if c1 not in counts2:\\n                    dC2 += 1\\n                if dC1 == dC2:\\n                    return True\\n        return False\\n\\n    # T: O(n**2) TLE\\n    def isItPossibleSlow(self, word1: str, word2: str) -> bool:\\n        word1 = list(word1)\\n        word2 = list(word2)\\n        \\n        for i in range(len(word1)):\\n            for j in range(len(word2)):\\n                word1[i], word2[j] = word2[j], word1[i]\\n                if len(set(word1)) == len(set(word2)):\\n                       return True\\n                word1[i], word2[j] = word2[j], word1[i]\\n        \\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    # T: O(n) for counting the chars to create dictionary\\n    # S: O(1) dicts are contant size (26 keys, 26 vals)\\n    def isItPossible(self, word1: str, word2: str) -> bool:\\n        counts1 = Counter(word1)\\n        distinctCount1 = len(counts1.keys())\\n        counts2 = Counter(word2)\\n        distinctCount2 = len(counts2.keys())\\n\\n        if abs(distinctCount1 - distinctCount2) > 2:\\n            # the number of distinct vals in each word must not differ\\n            #  by more than 2.\\n            return False\\n\\n        for c1 in counts1.keys(): # T: O(1) => (26 * 26) worst case\\n            for c2 in counts2.keys():\\n                dC1 = distinctCount1\\n                dC2 = distinctCount2\\n                if counts1[c1] == 1 and c1 != c2:\\n                    dC1 -= 1\\n                if c2 not in counts1:\\n                    dC1 += 1\\n                if counts2[c2] == 1 and c1 != c2:\\n                    dC2 -= 1\\n                if c1 not in counts2:\\n                    dC2 += 1\\n                if dC1 == dC2:\\n                    return True\\n        return False\\n\\n    # T: O(n**2) TLE\\n    def isItPossibleSlow(self, word1: str, word2: str) -> bool:\\n        word1 = list(word1)\\n        word2 = list(word2)\\n        \\n        for i in range(len(word1)):\\n            for j in range(len(word2)):\\n                word1[i], word2[j] = word2[j], word1[i]\\n                if len(set(word1)) == len(set(word2)):\\n                       return True\\n                word1[i], word2[j] = word2[j], word1[i]\\n        \\n        return False\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1747252,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1747256,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1747255,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1747285,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1747247,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1747267,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1759240,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1748373,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1748345,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1747537,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1747252,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1747256,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1747255,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1747285,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1747247,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1747267,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1759240,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1748373,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1748345,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1747537,
                "content": [
                    {
                        "username": "S_Basu",
                        "content": "***I tried so hard & got so far...***\\n***But in the end it doesn\\'t even matter...***\\n\\nThese lines by Linkin Park are so so relatable in my case for this problem."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "[@the_kalakar](/the_kalakar) so many cases to handle"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@the_kalakar](/the_kalakar) exactly \\uD83D\\uDE05"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "SO TRUE !! \\nWe all were thinking of a possible math approach for this. But after I used the test case \"aaaa\" and \"bbbc\", it was sure that it is a simulation problem."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Did they took revenge for yesterday contest xor problem?"
                    },
                    {
                        "username": "praveen40109",
                        "content": "I guess yes \\uD83D\\uDE05"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "ok so the brute force worked and i was trying to solve it in O(26) f*** me why do I have to make everything overcomplex"
                    },
                    {
                        "username": "VinayV9",
                        "content": "I feel the pain."
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@JobComeHere](/JobComeHere) literally bro hahaha"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "Found my guy here."
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@insaneBanda](/insaneBanda)  us bro us"
                    },
                    {
                        "username": "JobComeHere",
                        "content": "I also like using fancy method. Every time I meet a question, I always try to solve it in O(n) or O(1) by using facy solution, while find the best solution is just follow the question."
                    },
                    {
                        "username": "insaneBanda",
                        "content": "We are same bro"
                    },
                    {
                        "username": "Lyle_C",
                        "content": "I like that it tricks you into thinking it\\'s easy by making it a 4 points question. God, I hate random brute force question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "I was trying to implement a Math solution for it by counting the number of common characters in two strings, and unique characters in string1 and string2. However, I failed to implement this approach in due time. :(\nDid someone solve the problem using this approach without actually simulating the whole problem?"
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be done, see [my solution](https://leetcode.com/discuss/topic/3047261/). It\\'s short, but quite painful to get everything right, I don\\'t think I would be able to do that in a contest. Also, there is no sense of achievement in the end, so I guess it\\'s just a very annoying problem in the end. :)"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@annahung](/annahung) After looking at your code, I wonder how many test cases you possibly thought of !! xD"
                    },
                    {
                        "username": "annahung",
                        "content": "I did go this way, but it takes me about an hour to cover all the testcase and got AC in the last minute lol\\nI beats 100% time, but I think maybe the code can be more concise...\\nJust FYI: https://leetcode.com/problems/make-number-of-distinct-characters-equal/solutions/3017191/python-using-set-operation-beats-100-time/?orderBy=most_votes"
                    },
                    {
                        "username": "ajaxWin",
                        "content": "I guess they baited us to think like that"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Testcases were Op \\uD83D\\uDE05"
                    },
                    {
                        "username": "tirtha_indian",
                        "content": "worst question of the last couple of contests"
                    },
                    {
                        "username": "_aka5h",
                        "content": "One of the most interesting problem I did in a while."
                    },
                    {
                        "username": "VinayV9",
                        "content": "It spoiled my day."
                    },
                    {
                        "username": "vik333",
                        "content": "I was going to rage about the difficulty, but now that I solved it in the simplest way possible after the contest,... I feel nothing but pain :)"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you know what else is hard? nothing, just this f***ing problem\nedit: now that i've seen the solution, i feel really stupid"
                    }
                ]
            },
            {
                "id": 1964072,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "Bruh , i will respect brute force from now on :). "
                    },
                    {
                        "username": "user6694qk",
                        "content": "tricky question :)"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Successfully wasted a whole day in this question! "
                    },
                    {
                        "username": "hasan_15_07_03",
                        "content": "When I saw the solution of others, I didn\\'t understood why they stored the key of second for loop word, means we can do directly it2.first. But when I tried without storing this value, I got an error. I am not understanding why it is giving error. Please explain!!!\\n"
                    },
                    {
                        "username": "gainik_roy",
                        "content": "how is \"acc\" && \"acb\" TRUE?????\\n"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "swap a of \"acc\" with b of \"acb\" \\nIt will result in \"bcc\" which have 2 distinct characters and \"acc\" which also have 2 distinct characters . Hence answer is True "
                    },
                    {
                        "username": "andydtest",
                        "content": "\\'aac\\' is equivalent to \\'ccb\\' - 2*\\'a\\' + 1*\\'c\\' == 2*\\'c\\' + 1*\\'b\\'  >> 2+1 == 2+1"
                    },
                    {
                        "username": "Md_Kamran_Ali",
                        "content": "can anybody help why im getting runtime error,im 100% sure that there is no runtime error\\n\\nbool isItPossible(string word1, string word2) {\\n        int i,j,k,n=word1.size(),m=word2.size(),s1=0,s2=0,n1=0,n2=0;\\n        int w1[26]={0,0};\\n        int w2[26]={0,0};\\n        for(i=0;i<n;i+=1)\\n        {w1[word1[i]-\\'a\\']+=1; if(w1[i]==1) s1+=1;}\\n        for(i=0;i<m;i+=1)\\n        {w2[word2[i]-\\'a\\']+=1; if(w2[i]==1) s2+=1;}\\n        for(i=0;i<26;i+=1)\\n        {\\n            if(w1[i]>=1)\\n            {\\n                for(j=0;j<26;j+=1)\\n                {\\n                    if(w2[j]>=1)\\n                    {\\n                    \\tn1=0;\\n                    \\tn2=0;\\n                        int c[26]={0,0};\\n                        int d[26]={0,0};\\n                        for(k=0;k<26;k+=1)\\n                        {\\n                        \\tc[k]=w1[k];\\n                        \\td[k]=w2[k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tc[j]+=1;\\n\\t\\t\\t\\t\\t\\tc[i]-=1;\\n\\t\\t\\t\\t\\t\\td[j]-=1;\\n\\t\\t\\t\\t\\t\\td[i]+=1;\\n\\t\\t\\t\\t\\t\\tfor(k=0;k<26;k+=1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(c[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn1+=1;\\n\\t\\t\\t\\t\\t\\t\\tif(d[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn2+=1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(n1==n2)\\n\\t\\t\\t\\t\\t\\treturn true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "feistyfawn",
                        "content": "Why it is returning true when string1=\"abc\" and string2=\"aab\" ?"
                    },
                    {
                        "username": "ronak037",
                        "content": "can be converted to str1= aabb, str2= aac\\n"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "word1 = \"aab\" word2 = \"bccd\"\\nExpected output = True\\nHow is this edge case even possible?\\nSince we can only swap once and length of keys have to be distinct and match in both words"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "[@takanuva15](/takanuva15) it makes sense now. Thanks"
                    },
                    {
                        "username": "takanuva15",
                        "content": "You can swap \"b\" from the first word with \"d\" in the 2nd word. The new words become \"aad\" and \"bccb\" which both have 2 distinct characters"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY THIS IS WRONG??\nit failed for testcase \nword1=\"a\"\nwrod2=\"bb\"\n\n\nclass Solution {\npublic:\n    bool isItPossible(string word1, string word2) {\n        unordered_map<char,int>m1;\n        unordered_map<char,int>m2;\n        bool f1=false;\n        bool f2=false;\n        for(auto x:word1){\n        m1[x]++;\n        if(m1[x]>1)\n        f1=true;\n        }\n        for(auto x:word2){\n        m2[x]++;\n        if(m2[x]>1)\n        f2=true;}\n        if((m1.size()==m2.size() )|| (f1==true && f2==true))return 1;\n        else\n        return 0;\n\n    }\n};"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "was pretty  easy in the end , just the string length of 10**5 threw me off . Should have gone for brute force  and solve it under time "
                    }
                ]
            },
            {
                "id": 1920509,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "Bruh , i will respect brute force from now on :). "
                    },
                    {
                        "username": "user6694qk",
                        "content": "tricky question :)"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Successfully wasted a whole day in this question! "
                    },
                    {
                        "username": "hasan_15_07_03",
                        "content": "When I saw the solution of others, I didn\\'t understood why they stored the key of second for loop word, means we can do directly it2.first. But when I tried without storing this value, I got an error. I am not understanding why it is giving error. Please explain!!!\\n"
                    },
                    {
                        "username": "gainik_roy",
                        "content": "how is \"acc\" && \"acb\" TRUE?????\\n"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "swap a of \"acc\" with b of \"acb\" \\nIt will result in \"bcc\" which have 2 distinct characters and \"acc\" which also have 2 distinct characters . Hence answer is True "
                    },
                    {
                        "username": "andydtest",
                        "content": "\\'aac\\' is equivalent to \\'ccb\\' - 2*\\'a\\' + 1*\\'c\\' == 2*\\'c\\' + 1*\\'b\\'  >> 2+1 == 2+1"
                    },
                    {
                        "username": "Md_Kamran_Ali",
                        "content": "can anybody help why im getting runtime error,im 100% sure that there is no runtime error\\n\\nbool isItPossible(string word1, string word2) {\\n        int i,j,k,n=word1.size(),m=word2.size(),s1=0,s2=0,n1=0,n2=0;\\n        int w1[26]={0,0};\\n        int w2[26]={0,0};\\n        for(i=0;i<n;i+=1)\\n        {w1[word1[i]-\\'a\\']+=1; if(w1[i]==1) s1+=1;}\\n        for(i=0;i<m;i+=1)\\n        {w2[word2[i]-\\'a\\']+=1; if(w2[i]==1) s2+=1;}\\n        for(i=0;i<26;i+=1)\\n        {\\n            if(w1[i]>=1)\\n            {\\n                for(j=0;j<26;j+=1)\\n                {\\n                    if(w2[j]>=1)\\n                    {\\n                    \\tn1=0;\\n                    \\tn2=0;\\n                        int c[26]={0,0};\\n                        int d[26]={0,0};\\n                        for(k=0;k<26;k+=1)\\n                        {\\n                        \\tc[k]=w1[k];\\n                        \\td[k]=w2[k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tc[j]+=1;\\n\\t\\t\\t\\t\\t\\tc[i]-=1;\\n\\t\\t\\t\\t\\t\\td[j]-=1;\\n\\t\\t\\t\\t\\t\\td[i]+=1;\\n\\t\\t\\t\\t\\t\\tfor(k=0;k<26;k+=1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(c[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn1+=1;\\n\\t\\t\\t\\t\\t\\t\\tif(d[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn2+=1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(n1==n2)\\n\\t\\t\\t\\t\\t\\treturn true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "feistyfawn",
                        "content": "Why it is returning true when string1=\"abc\" and string2=\"aab\" ?"
                    },
                    {
                        "username": "ronak037",
                        "content": "can be converted to str1= aabb, str2= aac\\n"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "word1 = \"aab\" word2 = \"bccd\"\\nExpected output = True\\nHow is this edge case even possible?\\nSince we can only swap once and length of keys have to be distinct and match in both words"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "[@takanuva15](/takanuva15) it makes sense now. Thanks"
                    },
                    {
                        "username": "takanuva15",
                        "content": "You can swap \"b\" from the first word with \"d\" in the 2nd word. The new words become \"aad\" and \"bccb\" which both have 2 distinct characters"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY THIS IS WRONG??\nit failed for testcase \nword1=\"a\"\nwrod2=\"bb\"\n\n\nclass Solution {\npublic:\n    bool isItPossible(string word1, string word2) {\n        unordered_map<char,int>m1;\n        unordered_map<char,int>m2;\n        bool f1=false;\n        bool f2=false;\n        for(auto x:word1){\n        m1[x]++;\n        if(m1[x]>1)\n        f1=true;\n        }\n        for(auto x:word2){\n        m2[x]++;\n        if(m2[x]>1)\n        f2=true;}\n        if((m1.size()==m2.size() )|| (f1==true && f2==true))return 1;\n        else\n        return 0;\n\n    }\n};"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "was pretty  easy in the end , just the string length of 10**5 threw me off . Should have gone for brute force  and solve it under time "
                    }
                ]
            },
            {
                "id": 1752870,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "Bruh , i will respect brute force from now on :). "
                    },
                    {
                        "username": "user6694qk",
                        "content": "tricky question :)"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Successfully wasted a whole day in this question! "
                    },
                    {
                        "username": "hasan_15_07_03",
                        "content": "When I saw the solution of others, I didn\\'t understood why they stored the key of second for loop word, means we can do directly it2.first. But when I tried without storing this value, I got an error. I am not understanding why it is giving error. Please explain!!!\\n"
                    },
                    {
                        "username": "gainik_roy",
                        "content": "how is \"acc\" && \"acb\" TRUE?????\\n"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "swap a of \"acc\" with b of \"acb\" \\nIt will result in \"bcc\" which have 2 distinct characters and \"acc\" which also have 2 distinct characters . Hence answer is True "
                    },
                    {
                        "username": "andydtest",
                        "content": "\\'aac\\' is equivalent to \\'ccb\\' - 2*\\'a\\' + 1*\\'c\\' == 2*\\'c\\' + 1*\\'b\\'  >> 2+1 == 2+1"
                    },
                    {
                        "username": "Md_Kamran_Ali",
                        "content": "can anybody help why im getting runtime error,im 100% sure that there is no runtime error\\n\\nbool isItPossible(string word1, string word2) {\\n        int i,j,k,n=word1.size(),m=word2.size(),s1=0,s2=0,n1=0,n2=0;\\n        int w1[26]={0,0};\\n        int w2[26]={0,0};\\n        for(i=0;i<n;i+=1)\\n        {w1[word1[i]-\\'a\\']+=1; if(w1[i]==1) s1+=1;}\\n        for(i=0;i<m;i+=1)\\n        {w2[word2[i]-\\'a\\']+=1; if(w2[i]==1) s2+=1;}\\n        for(i=0;i<26;i+=1)\\n        {\\n            if(w1[i]>=1)\\n            {\\n                for(j=0;j<26;j+=1)\\n                {\\n                    if(w2[j]>=1)\\n                    {\\n                    \\tn1=0;\\n                    \\tn2=0;\\n                        int c[26]={0,0};\\n                        int d[26]={0,0};\\n                        for(k=0;k<26;k+=1)\\n                        {\\n                        \\tc[k]=w1[k];\\n                        \\td[k]=w2[k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tc[j]+=1;\\n\\t\\t\\t\\t\\t\\tc[i]-=1;\\n\\t\\t\\t\\t\\t\\td[j]-=1;\\n\\t\\t\\t\\t\\t\\td[i]+=1;\\n\\t\\t\\t\\t\\t\\tfor(k=0;k<26;k+=1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(c[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn1+=1;\\n\\t\\t\\t\\t\\t\\t\\tif(d[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn2+=1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(n1==n2)\\n\\t\\t\\t\\t\\t\\treturn true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "feistyfawn",
                        "content": "Why it is returning true when string1=\"abc\" and string2=\"aab\" ?"
                    },
                    {
                        "username": "ronak037",
                        "content": "can be converted to str1= aabb, str2= aac\\n"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "word1 = \"aab\" word2 = \"bccd\"\\nExpected output = True\\nHow is this edge case even possible?\\nSince we can only swap once and length of keys have to be distinct and match in both words"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "[@takanuva15](/takanuva15) it makes sense now. Thanks"
                    },
                    {
                        "username": "takanuva15",
                        "content": "You can swap \"b\" from the first word with \"d\" in the 2nd word. The new words become \"aad\" and \"bccb\" which both have 2 distinct characters"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY THIS IS WRONG??\nit failed for testcase \nword1=\"a\"\nwrod2=\"bb\"\n\n\nclass Solution {\npublic:\n    bool isItPossible(string word1, string word2) {\n        unordered_map<char,int>m1;\n        unordered_map<char,int>m2;\n        bool f1=false;\n        bool f2=false;\n        for(auto x:word1){\n        m1[x]++;\n        if(m1[x]>1)\n        f1=true;\n        }\n        for(auto x:word2){\n        m2[x]++;\n        if(m2[x]>1)\n        f2=true;}\n        if((m1.size()==m2.size() )|| (f1==true && f2==true))return 1;\n        else\n        return 0;\n\n    }\n};"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "was pretty  easy in the end , just the string length of 10**5 threw me off . Should have gone for brute force  and solve it under time "
                    }
                ]
            },
            {
                "id": 1750539,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "Bruh , i will respect brute force from now on :). "
                    },
                    {
                        "username": "user6694qk",
                        "content": "tricky question :)"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Successfully wasted a whole day in this question! "
                    },
                    {
                        "username": "hasan_15_07_03",
                        "content": "When I saw the solution of others, I didn\\'t understood why they stored the key of second for loop word, means we can do directly it2.first. But when I tried without storing this value, I got an error. I am not understanding why it is giving error. Please explain!!!\\n"
                    },
                    {
                        "username": "gainik_roy",
                        "content": "how is \"acc\" && \"acb\" TRUE?????\\n"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "swap a of \"acc\" with b of \"acb\" \\nIt will result in \"bcc\" which have 2 distinct characters and \"acc\" which also have 2 distinct characters . Hence answer is True "
                    },
                    {
                        "username": "andydtest",
                        "content": "\\'aac\\' is equivalent to \\'ccb\\' - 2*\\'a\\' + 1*\\'c\\' == 2*\\'c\\' + 1*\\'b\\'  >> 2+1 == 2+1"
                    },
                    {
                        "username": "Md_Kamran_Ali",
                        "content": "can anybody help why im getting runtime error,im 100% sure that there is no runtime error\\n\\nbool isItPossible(string word1, string word2) {\\n        int i,j,k,n=word1.size(),m=word2.size(),s1=0,s2=0,n1=0,n2=0;\\n        int w1[26]={0,0};\\n        int w2[26]={0,0};\\n        for(i=0;i<n;i+=1)\\n        {w1[word1[i]-\\'a\\']+=1; if(w1[i]==1) s1+=1;}\\n        for(i=0;i<m;i+=1)\\n        {w2[word2[i]-\\'a\\']+=1; if(w2[i]==1) s2+=1;}\\n        for(i=0;i<26;i+=1)\\n        {\\n            if(w1[i]>=1)\\n            {\\n                for(j=0;j<26;j+=1)\\n                {\\n                    if(w2[j]>=1)\\n                    {\\n                    \\tn1=0;\\n                    \\tn2=0;\\n                        int c[26]={0,0};\\n                        int d[26]={0,0};\\n                        for(k=0;k<26;k+=1)\\n                        {\\n                        \\tc[k]=w1[k];\\n                        \\td[k]=w2[k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tc[j]+=1;\\n\\t\\t\\t\\t\\t\\tc[i]-=1;\\n\\t\\t\\t\\t\\t\\td[j]-=1;\\n\\t\\t\\t\\t\\t\\td[i]+=1;\\n\\t\\t\\t\\t\\t\\tfor(k=0;k<26;k+=1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(c[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn1+=1;\\n\\t\\t\\t\\t\\t\\t\\tif(d[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn2+=1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(n1==n2)\\n\\t\\t\\t\\t\\t\\treturn true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "feistyfawn",
                        "content": "Why it is returning true when string1=\"abc\" and string2=\"aab\" ?"
                    },
                    {
                        "username": "ronak037",
                        "content": "can be converted to str1= aabb, str2= aac\\n"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "word1 = \"aab\" word2 = \"bccd\"\\nExpected output = True\\nHow is this edge case even possible?\\nSince we can only swap once and length of keys have to be distinct and match in both words"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "[@takanuva15](/takanuva15) it makes sense now. Thanks"
                    },
                    {
                        "username": "takanuva15",
                        "content": "You can swap \"b\" from the first word with \"d\" in the 2nd word. The new words become \"aad\" and \"bccb\" which both have 2 distinct characters"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY THIS IS WRONG??\nit failed for testcase \nword1=\"a\"\nwrod2=\"bb\"\n\n\nclass Solution {\npublic:\n    bool isItPossible(string word1, string word2) {\n        unordered_map<char,int>m1;\n        unordered_map<char,int>m2;\n        bool f1=false;\n        bool f2=false;\n        for(auto x:word1){\n        m1[x]++;\n        if(m1[x]>1)\n        f1=true;\n        }\n        for(auto x:word2){\n        m2[x]++;\n        if(m2[x]>1)\n        f2=true;}\n        if((m1.size()==m2.size() )|| (f1==true && f2==true))return 1;\n        else\n        return 0;\n\n    }\n};"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "was pretty  easy in the end , just the string length of 10**5 threw me off . Should have gone for brute force  and solve it under time "
                    }
                ]
            },
            {
                "id": 1750091,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "Bruh , i will respect brute force from now on :). "
                    },
                    {
                        "username": "user6694qk",
                        "content": "tricky question :)"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Successfully wasted a whole day in this question! "
                    },
                    {
                        "username": "hasan_15_07_03",
                        "content": "When I saw the solution of others, I didn\\'t understood why they stored the key of second for loop word, means we can do directly it2.first. But when I tried without storing this value, I got an error. I am not understanding why it is giving error. Please explain!!!\\n"
                    },
                    {
                        "username": "gainik_roy",
                        "content": "how is \"acc\" && \"acb\" TRUE?????\\n"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "swap a of \"acc\" with b of \"acb\" \\nIt will result in \"bcc\" which have 2 distinct characters and \"acc\" which also have 2 distinct characters . Hence answer is True "
                    },
                    {
                        "username": "andydtest",
                        "content": "\\'aac\\' is equivalent to \\'ccb\\' - 2*\\'a\\' + 1*\\'c\\' == 2*\\'c\\' + 1*\\'b\\'  >> 2+1 == 2+1"
                    },
                    {
                        "username": "Md_Kamran_Ali",
                        "content": "can anybody help why im getting runtime error,im 100% sure that there is no runtime error\\n\\nbool isItPossible(string word1, string word2) {\\n        int i,j,k,n=word1.size(),m=word2.size(),s1=0,s2=0,n1=0,n2=0;\\n        int w1[26]={0,0};\\n        int w2[26]={0,0};\\n        for(i=0;i<n;i+=1)\\n        {w1[word1[i]-\\'a\\']+=1; if(w1[i]==1) s1+=1;}\\n        for(i=0;i<m;i+=1)\\n        {w2[word2[i]-\\'a\\']+=1; if(w2[i]==1) s2+=1;}\\n        for(i=0;i<26;i+=1)\\n        {\\n            if(w1[i]>=1)\\n            {\\n                for(j=0;j<26;j+=1)\\n                {\\n                    if(w2[j]>=1)\\n                    {\\n                    \\tn1=0;\\n                    \\tn2=0;\\n                        int c[26]={0,0};\\n                        int d[26]={0,0};\\n                        for(k=0;k<26;k+=1)\\n                        {\\n                        \\tc[k]=w1[k];\\n                        \\td[k]=w2[k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tc[j]+=1;\\n\\t\\t\\t\\t\\t\\tc[i]-=1;\\n\\t\\t\\t\\t\\t\\td[j]-=1;\\n\\t\\t\\t\\t\\t\\td[i]+=1;\\n\\t\\t\\t\\t\\t\\tfor(k=0;k<26;k+=1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(c[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn1+=1;\\n\\t\\t\\t\\t\\t\\t\\tif(d[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn2+=1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(n1==n2)\\n\\t\\t\\t\\t\\t\\treturn true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "feistyfawn",
                        "content": "Why it is returning true when string1=\"abc\" and string2=\"aab\" ?"
                    },
                    {
                        "username": "ronak037",
                        "content": "can be converted to str1= aabb, str2= aac\\n"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "word1 = \"aab\" word2 = \"bccd\"\\nExpected output = True\\nHow is this edge case even possible?\\nSince we can only swap once and length of keys have to be distinct and match in both words"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "[@takanuva15](/takanuva15) it makes sense now. Thanks"
                    },
                    {
                        "username": "takanuva15",
                        "content": "You can swap \"b\" from the first word with \"d\" in the 2nd word. The new words become \"aad\" and \"bccb\" which both have 2 distinct characters"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY THIS IS WRONG??\nit failed for testcase \nword1=\"a\"\nwrod2=\"bb\"\n\n\nclass Solution {\npublic:\n    bool isItPossible(string word1, string word2) {\n        unordered_map<char,int>m1;\n        unordered_map<char,int>m2;\n        bool f1=false;\n        bool f2=false;\n        for(auto x:word1){\n        m1[x]++;\n        if(m1[x]>1)\n        f1=true;\n        }\n        for(auto x:word2){\n        m2[x]++;\n        if(m2[x]>1)\n        f2=true;}\n        if((m1.size()==m2.size() )|| (f1==true && f2==true))return 1;\n        else\n        return 0;\n\n    }\n};"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "was pretty  easy in the end , just the string length of 10**5 threw me off . Should have gone for brute force  and solve it under time "
                    }
                ]
            },
            {
                "id": 1749600,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "Bruh , i will respect brute force from now on :). "
                    },
                    {
                        "username": "user6694qk",
                        "content": "tricky question :)"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Successfully wasted a whole day in this question! "
                    },
                    {
                        "username": "hasan_15_07_03",
                        "content": "When I saw the solution of others, I didn\\'t understood why they stored the key of second for loop word, means we can do directly it2.first. But when I tried without storing this value, I got an error. I am not understanding why it is giving error. Please explain!!!\\n"
                    },
                    {
                        "username": "gainik_roy",
                        "content": "how is \"acc\" && \"acb\" TRUE?????\\n"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "swap a of \"acc\" with b of \"acb\" \\nIt will result in \"bcc\" which have 2 distinct characters and \"acc\" which also have 2 distinct characters . Hence answer is True "
                    },
                    {
                        "username": "andydtest",
                        "content": "\\'aac\\' is equivalent to \\'ccb\\' - 2*\\'a\\' + 1*\\'c\\' == 2*\\'c\\' + 1*\\'b\\'  >> 2+1 == 2+1"
                    },
                    {
                        "username": "Md_Kamran_Ali",
                        "content": "can anybody help why im getting runtime error,im 100% sure that there is no runtime error\\n\\nbool isItPossible(string word1, string word2) {\\n        int i,j,k,n=word1.size(),m=word2.size(),s1=0,s2=0,n1=0,n2=0;\\n        int w1[26]={0,0};\\n        int w2[26]={0,0};\\n        for(i=0;i<n;i+=1)\\n        {w1[word1[i]-\\'a\\']+=1; if(w1[i]==1) s1+=1;}\\n        for(i=0;i<m;i+=1)\\n        {w2[word2[i]-\\'a\\']+=1; if(w2[i]==1) s2+=1;}\\n        for(i=0;i<26;i+=1)\\n        {\\n            if(w1[i]>=1)\\n            {\\n                for(j=0;j<26;j+=1)\\n                {\\n                    if(w2[j]>=1)\\n                    {\\n                    \\tn1=0;\\n                    \\tn2=0;\\n                        int c[26]={0,0};\\n                        int d[26]={0,0};\\n                        for(k=0;k<26;k+=1)\\n                        {\\n                        \\tc[k]=w1[k];\\n                        \\td[k]=w2[k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tc[j]+=1;\\n\\t\\t\\t\\t\\t\\tc[i]-=1;\\n\\t\\t\\t\\t\\t\\td[j]-=1;\\n\\t\\t\\t\\t\\t\\td[i]+=1;\\n\\t\\t\\t\\t\\t\\tfor(k=0;k<26;k+=1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(c[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn1+=1;\\n\\t\\t\\t\\t\\t\\t\\tif(d[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn2+=1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(n1==n2)\\n\\t\\t\\t\\t\\t\\treturn true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "feistyfawn",
                        "content": "Why it is returning true when string1=\"abc\" and string2=\"aab\" ?"
                    },
                    {
                        "username": "ronak037",
                        "content": "can be converted to str1= aabb, str2= aac\\n"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "word1 = \"aab\" word2 = \"bccd\"\\nExpected output = True\\nHow is this edge case even possible?\\nSince we can only swap once and length of keys have to be distinct and match in both words"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "[@takanuva15](/takanuva15) it makes sense now. Thanks"
                    },
                    {
                        "username": "takanuva15",
                        "content": "You can swap \"b\" from the first word with \"d\" in the 2nd word. The new words become \"aad\" and \"bccb\" which both have 2 distinct characters"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY THIS IS WRONG??\nit failed for testcase \nword1=\"a\"\nwrod2=\"bb\"\n\n\nclass Solution {\npublic:\n    bool isItPossible(string word1, string word2) {\n        unordered_map<char,int>m1;\n        unordered_map<char,int>m2;\n        bool f1=false;\n        bool f2=false;\n        for(auto x:word1){\n        m1[x]++;\n        if(m1[x]>1)\n        f1=true;\n        }\n        for(auto x:word2){\n        m2[x]++;\n        if(m2[x]>1)\n        f2=true;}\n        if((m1.size()==m2.size() )|| (f1==true && f2==true))return 1;\n        else\n        return 0;\n\n    }\n};"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "was pretty  easy in the end , just the string length of 10**5 threw me off . Should have gone for brute force  and solve it under time "
                    }
                ]
            },
            {
                "id": 1748528,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "Bruh , i will respect brute force from now on :). "
                    },
                    {
                        "username": "user6694qk",
                        "content": "tricky question :)"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Successfully wasted a whole day in this question! "
                    },
                    {
                        "username": "hasan_15_07_03",
                        "content": "When I saw the solution of others, I didn\\'t understood why they stored the key of second for loop word, means we can do directly it2.first. But when I tried without storing this value, I got an error. I am not understanding why it is giving error. Please explain!!!\\n"
                    },
                    {
                        "username": "gainik_roy",
                        "content": "how is \"acc\" && \"acb\" TRUE?????\\n"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "swap a of \"acc\" with b of \"acb\" \\nIt will result in \"bcc\" which have 2 distinct characters and \"acc\" which also have 2 distinct characters . Hence answer is True "
                    },
                    {
                        "username": "andydtest",
                        "content": "\\'aac\\' is equivalent to \\'ccb\\' - 2*\\'a\\' + 1*\\'c\\' == 2*\\'c\\' + 1*\\'b\\'  >> 2+1 == 2+1"
                    },
                    {
                        "username": "Md_Kamran_Ali",
                        "content": "can anybody help why im getting runtime error,im 100% sure that there is no runtime error\\n\\nbool isItPossible(string word1, string word2) {\\n        int i,j,k,n=word1.size(),m=word2.size(),s1=0,s2=0,n1=0,n2=0;\\n        int w1[26]={0,0};\\n        int w2[26]={0,0};\\n        for(i=0;i<n;i+=1)\\n        {w1[word1[i]-\\'a\\']+=1; if(w1[i]==1) s1+=1;}\\n        for(i=0;i<m;i+=1)\\n        {w2[word2[i]-\\'a\\']+=1; if(w2[i]==1) s2+=1;}\\n        for(i=0;i<26;i+=1)\\n        {\\n            if(w1[i]>=1)\\n            {\\n                for(j=0;j<26;j+=1)\\n                {\\n                    if(w2[j]>=1)\\n                    {\\n                    \\tn1=0;\\n                    \\tn2=0;\\n                        int c[26]={0,0};\\n                        int d[26]={0,0};\\n                        for(k=0;k<26;k+=1)\\n                        {\\n                        \\tc[k]=w1[k];\\n                        \\td[k]=w2[k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tc[j]+=1;\\n\\t\\t\\t\\t\\t\\tc[i]-=1;\\n\\t\\t\\t\\t\\t\\td[j]-=1;\\n\\t\\t\\t\\t\\t\\td[i]+=1;\\n\\t\\t\\t\\t\\t\\tfor(k=0;k<26;k+=1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(c[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn1+=1;\\n\\t\\t\\t\\t\\t\\t\\tif(d[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn2+=1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(n1==n2)\\n\\t\\t\\t\\t\\t\\treturn true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "feistyfawn",
                        "content": "Why it is returning true when string1=\"abc\" and string2=\"aab\" ?"
                    },
                    {
                        "username": "ronak037",
                        "content": "can be converted to str1= aabb, str2= aac\\n"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "word1 = \"aab\" word2 = \"bccd\"\\nExpected output = True\\nHow is this edge case even possible?\\nSince we can only swap once and length of keys have to be distinct and match in both words"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "[@takanuva15](/takanuva15) it makes sense now. Thanks"
                    },
                    {
                        "username": "takanuva15",
                        "content": "You can swap \"b\" from the first word with \"d\" in the 2nd word. The new words become \"aad\" and \"bccb\" which both have 2 distinct characters"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY THIS IS WRONG??\nit failed for testcase \nword1=\"a\"\nwrod2=\"bb\"\n\n\nclass Solution {\npublic:\n    bool isItPossible(string word1, string word2) {\n        unordered_map<char,int>m1;\n        unordered_map<char,int>m2;\n        bool f1=false;\n        bool f2=false;\n        for(auto x:word1){\n        m1[x]++;\n        if(m1[x]>1)\n        f1=true;\n        }\n        for(auto x:word2){\n        m2[x]++;\n        if(m2[x]>1)\n        f2=true;}\n        if((m1.size()==m2.size() )|| (f1==true && f2==true))return 1;\n        else\n        return 0;\n\n    }\n};"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "was pretty  easy in the end , just the string length of 10**5 threw me off . Should have gone for brute force  and solve it under time "
                    }
                ]
            },
            {
                "id": 1748114,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "Bruh , i will respect brute force from now on :). "
                    },
                    {
                        "username": "user6694qk",
                        "content": "tricky question :)"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Successfully wasted a whole day in this question! "
                    },
                    {
                        "username": "hasan_15_07_03",
                        "content": "When I saw the solution of others, I didn\\'t understood why they stored the key of second for loop word, means we can do directly it2.first. But when I tried without storing this value, I got an error. I am not understanding why it is giving error. Please explain!!!\\n"
                    },
                    {
                        "username": "gainik_roy",
                        "content": "how is \"acc\" && \"acb\" TRUE?????\\n"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "swap a of \"acc\" with b of \"acb\" \\nIt will result in \"bcc\" which have 2 distinct characters and \"acc\" which also have 2 distinct characters . Hence answer is True "
                    },
                    {
                        "username": "andydtest",
                        "content": "\\'aac\\' is equivalent to \\'ccb\\' - 2*\\'a\\' + 1*\\'c\\' == 2*\\'c\\' + 1*\\'b\\'  >> 2+1 == 2+1"
                    },
                    {
                        "username": "Md_Kamran_Ali",
                        "content": "can anybody help why im getting runtime error,im 100% sure that there is no runtime error\\n\\nbool isItPossible(string word1, string word2) {\\n        int i,j,k,n=word1.size(),m=word2.size(),s1=0,s2=0,n1=0,n2=0;\\n        int w1[26]={0,0};\\n        int w2[26]={0,0};\\n        for(i=0;i<n;i+=1)\\n        {w1[word1[i]-\\'a\\']+=1; if(w1[i]==1) s1+=1;}\\n        for(i=0;i<m;i+=1)\\n        {w2[word2[i]-\\'a\\']+=1; if(w2[i]==1) s2+=1;}\\n        for(i=0;i<26;i+=1)\\n        {\\n            if(w1[i]>=1)\\n            {\\n                for(j=0;j<26;j+=1)\\n                {\\n                    if(w2[j]>=1)\\n                    {\\n                    \\tn1=0;\\n                    \\tn2=0;\\n                        int c[26]={0,0};\\n                        int d[26]={0,0};\\n                        for(k=0;k<26;k+=1)\\n                        {\\n                        \\tc[k]=w1[k];\\n                        \\td[k]=w2[k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tc[j]+=1;\\n\\t\\t\\t\\t\\t\\tc[i]-=1;\\n\\t\\t\\t\\t\\t\\td[j]-=1;\\n\\t\\t\\t\\t\\t\\td[i]+=1;\\n\\t\\t\\t\\t\\t\\tfor(k=0;k<26;k+=1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(c[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn1+=1;\\n\\t\\t\\t\\t\\t\\t\\tif(d[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn2+=1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(n1==n2)\\n\\t\\t\\t\\t\\t\\treturn true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "feistyfawn",
                        "content": "Why it is returning true when string1=\"abc\" and string2=\"aab\" ?"
                    },
                    {
                        "username": "ronak037",
                        "content": "can be converted to str1= aabb, str2= aac\\n"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "word1 = \"aab\" word2 = \"bccd\"\\nExpected output = True\\nHow is this edge case even possible?\\nSince we can only swap once and length of keys have to be distinct and match in both words"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "[@takanuva15](/takanuva15) it makes sense now. Thanks"
                    },
                    {
                        "username": "takanuva15",
                        "content": "You can swap \"b\" from the first word with \"d\" in the 2nd word. The new words become \"aad\" and \"bccb\" which both have 2 distinct characters"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY THIS IS WRONG??\nit failed for testcase \nword1=\"a\"\nwrod2=\"bb\"\n\n\nclass Solution {\npublic:\n    bool isItPossible(string word1, string word2) {\n        unordered_map<char,int>m1;\n        unordered_map<char,int>m2;\n        bool f1=false;\n        bool f2=false;\n        for(auto x:word1){\n        m1[x]++;\n        if(m1[x]>1)\n        f1=true;\n        }\n        for(auto x:word2){\n        m2[x]++;\n        if(m2[x]>1)\n        f2=true;}\n        if((m1.size()==m2.size() )|| (f1==true && f2==true))return 1;\n        else\n        return 0;\n\n    }\n};"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "was pretty  easy in the end , just the string length of 10**5 threw me off . Should have gone for brute force  and solve it under time "
                    }
                ]
            },
            {
                "id": 1747977,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "Bruh , i will respect brute force from now on :). "
                    },
                    {
                        "username": "user6694qk",
                        "content": "tricky question :)"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Successfully wasted a whole day in this question! "
                    },
                    {
                        "username": "hasan_15_07_03",
                        "content": "When I saw the solution of others, I didn\\'t understood why they stored the key of second for loop word, means we can do directly it2.first. But when I tried without storing this value, I got an error. I am not understanding why it is giving error. Please explain!!!\\n"
                    },
                    {
                        "username": "gainik_roy",
                        "content": "how is \"acc\" && \"acb\" TRUE?????\\n"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "swap a of \"acc\" with b of \"acb\" \\nIt will result in \"bcc\" which have 2 distinct characters and \"acc\" which also have 2 distinct characters . Hence answer is True "
                    },
                    {
                        "username": "andydtest",
                        "content": "\\'aac\\' is equivalent to \\'ccb\\' - 2*\\'a\\' + 1*\\'c\\' == 2*\\'c\\' + 1*\\'b\\'  >> 2+1 == 2+1"
                    },
                    {
                        "username": "Md_Kamran_Ali",
                        "content": "can anybody help why im getting runtime error,im 100% sure that there is no runtime error\\n\\nbool isItPossible(string word1, string word2) {\\n        int i,j,k,n=word1.size(),m=word2.size(),s1=0,s2=0,n1=0,n2=0;\\n        int w1[26]={0,0};\\n        int w2[26]={0,0};\\n        for(i=0;i<n;i+=1)\\n        {w1[word1[i]-\\'a\\']+=1; if(w1[i]==1) s1+=1;}\\n        for(i=0;i<m;i+=1)\\n        {w2[word2[i]-\\'a\\']+=1; if(w2[i]==1) s2+=1;}\\n        for(i=0;i<26;i+=1)\\n        {\\n            if(w1[i]>=1)\\n            {\\n                for(j=0;j<26;j+=1)\\n                {\\n                    if(w2[j]>=1)\\n                    {\\n                    \\tn1=0;\\n                    \\tn2=0;\\n                        int c[26]={0,0};\\n                        int d[26]={0,0};\\n                        for(k=0;k<26;k+=1)\\n                        {\\n                        \\tc[k]=w1[k];\\n                        \\td[k]=w2[k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tc[j]+=1;\\n\\t\\t\\t\\t\\t\\tc[i]-=1;\\n\\t\\t\\t\\t\\t\\td[j]-=1;\\n\\t\\t\\t\\t\\t\\td[i]+=1;\\n\\t\\t\\t\\t\\t\\tfor(k=0;k<26;k+=1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(c[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn1+=1;\\n\\t\\t\\t\\t\\t\\t\\tif(d[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn2+=1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(n1==n2)\\n\\t\\t\\t\\t\\t\\treturn true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "feistyfawn",
                        "content": "Why it is returning true when string1=\"abc\" and string2=\"aab\" ?"
                    },
                    {
                        "username": "ronak037",
                        "content": "can be converted to str1= aabb, str2= aac\\n"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "word1 = \"aab\" word2 = \"bccd\"\\nExpected output = True\\nHow is this edge case even possible?\\nSince we can only swap once and length of keys have to be distinct and match in both words"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "[@takanuva15](/takanuva15) it makes sense now. Thanks"
                    },
                    {
                        "username": "takanuva15",
                        "content": "You can swap \"b\" from the first word with \"d\" in the 2nd word. The new words become \"aad\" and \"bccb\" which both have 2 distinct characters"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY THIS IS WRONG??\nit failed for testcase \nword1=\"a\"\nwrod2=\"bb\"\n\n\nclass Solution {\npublic:\n    bool isItPossible(string word1, string word2) {\n        unordered_map<char,int>m1;\n        unordered_map<char,int>m2;\n        bool f1=false;\n        bool f2=false;\n        for(auto x:word1){\n        m1[x]++;\n        if(m1[x]>1)\n        f1=true;\n        }\n        for(auto x:word2){\n        m2[x]++;\n        if(m2[x]>1)\n        f2=true;}\n        if((m1.size()==m2.size() )|| (f1==true && f2==true))return 1;\n        else\n        return 0;\n\n    }\n};"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "was pretty  easy in the end , just the string length of 10**5 threw me off . Should have gone for brute force  and solve it under time "
                    }
                ]
            },
            {
                "id": 1747851,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "Bruh , i will respect brute force from now on :). "
                    },
                    {
                        "username": "user6694qk",
                        "content": "tricky question :)"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Successfully wasted a whole day in this question! "
                    },
                    {
                        "username": "hasan_15_07_03",
                        "content": "When I saw the solution of others, I didn\\'t understood why they stored the key of second for loop word, means we can do directly it2.first. But when I tried without storing this value, I got an error. I am not understanding why it is giving error. Please explain!!!\\n"
                    },
                    {
                        "username": "gainik_roy",
                        "content": "how is \"acc\" && \"acb\" TRUE?????\\n"
                    },
                    {
                        "username": "scorpioneer",
                        "content": "swap a of \"acc\" with b of \"acb\" \\nIt will result in \"bcc\" which have 2 distinct characters and \"acc\" which also have 2 distinct characters . Hence answer is True "
                    },
                    {
                        "username": "andydtest",
                        "content": "\\'aac\\' is equivalent to \\'ccb\\' - 2*\\'a\\' + 1*\\'c\\' == 2*\\'c\\' + 1*\\'b\\'  >> 2+1 == 2+1"
                    },
                    {
                        "username": "Md_Kamran_Ali",
                        "content": "can anybody help why im getting runtime error,im 100% sure that there is no runtime error\\n\\nbool isItPossible(string word1, string word2) {\\n        int i,j,k,n=word1.size(),m=word2.size(),s1=0,s2=0,n1=0,n2=0;\\n        int w1[26]={0,0};\\n        int w2[26]={0,0};\\n        for(i=0;i<n;i+=1)\\n        {w1[word1[i]-\\'a\\']+=1; if(w1[i]==1) s1+=1;}\\n        for(i=0;i<m;i+=1)\\n        {w2[word2[i]-\\'a\\']+=1; if(w2[i]==1) s2+=1;}\\n        for(i=0;i<26;i+=1)\\n        {\\n            if(w1[i]>=1)\\n            {\\n                for(j=0;j<26;j+=1)\\n                {\\n                    if(w2[j]>=1)\\n                    {\\n                    \\tn1=0;\\n                    \\tn2=0;\\n                        int c[26]={0,0};\\n                        int d[26]={0,0};\\n                        for(k=0;k<26;k+=1)\\n                        {\\n                        \\tc[k]=w1[k];\\n                        \\td[k]=w2[k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tc[j]+=1;\\n\\t\\t\\t\\t\\t\\tc[i]-=1;\\n\\t\\t\\t\\t\\t\\td[j]-=1;\\n\\t\\t\\t\\t\\t\\td[i]+=1;\\n\\t\\t\\t\\t\\t\\tfor(k=0;k<26;k+=1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(c[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn1+=1;\\n\\t\\t\\t\\t\\t\\t\\tif(d[k]>=1)\\n\\t\\t\\t\\t\\t\\t\\tn2+=1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(n1==n2)\\n\\t\\t\\t\\t\\t\\treturn true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "feistyfawn",
                        "content": "Why it is returning true when string1=\"abc\" and string2=\"aab\" ?"
                    },
                    {
                        "username": "ronak037",
                        "content": "can be converted to str1= aabb, str2= aac\\n"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "word1 = \"aab\" word2 = \"bccd\"\\nExpected output = True\\nHow is this edge case even possible?\\nSince we can only swap once and length of keys have to be distinct and match in both words"
                    },
                    {
                        "username": "anchitdhar",
                        "content": "[@takanuva15](/takanuva15) it makes sense now. Thanks"
                    },
                    {
                        "username": "takanuva15",
                        "content": "You can swap \"b\" from the first word with \"d\" in the 2nd word. The new words become \"aad\" and \"bccb\" which both have 2 distinct characters"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY THIS IS WRONG??\nit failed for testcase \nword1=\"a\"\nwrod2=\"bb\"\n\n\nclass Solution {\npublic:\n    bool isItPossible(string word1, string word2) {\n        unordered_map<char,int>m1;\n        unordered_map<char,int>m2;\n        bool f1=false;\n        bool f2=false;\n        for(auto x:word1){\n        m1[x]++;\n        if(m1[x]>1)\n        f1=true;\n        }\n        for(auto x:word2){\n        m2[x]++;\n        if(m2[x]>1)\n        f2=true;}\n        if((m1.size()==m2.size() )|| (f1==true && f2==true))return 1;\n        else\n        return 0;\n\n    }\n};"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "was pretty  easy in the end , just the string length of 10**5 threw me off . Should have gone for brute force  and solve it under time "
                    }
                ]
            }
        ]
    }
]