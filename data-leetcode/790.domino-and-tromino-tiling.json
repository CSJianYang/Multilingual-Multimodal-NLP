[
    {
        "title": "Domino and Tromino Tiling",
        "question_content": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n&nbsp;\nExample 1:\n\nInput: n = 3\nOutput: 5\nExplanation: The five different ways are show above.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 1000",
        "solutions": [
            {
                "id": 116581,
                "title": "detail-and-explanation-of-o-n-solution-why-dp-n-2-d-n-1-dp-n-3",
                "content": "when N==0, we need return 0, but in dp , we need make dp[0]=1 for easy to construct formula\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengkaiwei/image_1519539268.png)\nsorry my handwriting is ugly\n\ndp[n]=dp[n-1]+dp[n-2]+ 2*(dp[n-3]+...+d[0])\n=dp[n-1]+dp[n-2]+dp[n-3]+dp[n-3]+2*(dp[n-4]+...+d[0])\n=dp[n-1]+dp[n-3]+(dp[n-2]+dp[n-3]+2*(dp[n-4]+...+d[0]))\n=dp[n-1]+dp[n-3]+dp[n-1]\n=2*dp[n-1]+dp[n-3]\n\n\n\n```\n int numTilings(int N) {\n    int md=1e9;\n    md+=7;\n    vector<long long> v(1001,0);\n    v[1]=1;\n    v[2]=2;\n    v[3]=5;\n    if(N<=3)\n        return v[N];\n    for(int i=4;i<=N;++i){\n        v[i]=2*v[i-1]+v[i-3]; \n        v[i]%=md;\n    }\n    return v[N];\n    \n}\n```\n",
                "solutionTags": [],
                "code": "```\n int numTilings(int N) {\n    int md=1e9;\n    md+=7;\n    vector<long long> v(1001,0);\n    v[1]=1;\n    v[2]=2;\n    v[3]=5;\n    if(N<=3)\n        return v[N];\n    for(int i=4;i<=N;++i){\n        v[i]=2*v[i-1]+v[i-3]; \n        v[i]%=md;\n    }\n    return v[N];\n    \n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116664,
                "title": "schematic-explanation-of-two-equivalent-dp-recurrence-formula",
                "content": "First, how many types of tiles do we have (including rotation)?\\n\\nThe answer is six: two types from domino and four types from trimino. I label them as follows:\\n\\ntype 1: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519580711.png)representing vertical domino\\ntype 2: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519580764.png)representing horizontal domino\\ntype 3: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519580948.png)representing `L`-shaped trimino\\ntype 4: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519580968.png)representing `Gamma`-shaped trimino\\ntype 5: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519581008.png) representing mirrored-`L`-shaped trimino\\ntype 6: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519581060.png)representing mirrored-`Gamma`-shaped trimino\\n\\nNow let\\'s define `T(N)` as the number of ways tiling the `2 x N` board. To obtain the recurrence relations for `T(N)`, we shall consider the very **last tile** in the  `2 x N` board (this is the tile which occupies at least one of the two grids at index `N` and completes the `2 x N` board). So what type can it be?\\n\\nImmediately we can rule out type 3 and 4, because they will never complete the board, thus cannot be the last tile. So we end up with four choices for the last tile:\\n\\n1. **The last tile is of type 1**: in this case, the rest tiles will fill up the `2 x (N-1)` board, then by definition, the number of ways for this case will be `T(N-1)`.\\n\\n2. **The last tile is of type 2**: in this case, the second to last tile must also be of type 2 (so they together fill up the last `2 x 2` region), and the rest tiles will fill up the `2 x (N-2)` board, again by definition, the number of ways for this case will be `T(N-2)`.\\n\\n3. **The last tile is of type 5**: in this case, the rest tiles must fill up the `2 x (N-1)` board except for the lower grid at index `N-1`, like this shape: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519582901.png). Our definition of `T(N)` does not cover this case, so we have to generalize it and define `T_up(N)` as the the number of ways to fill a `2 x N` board except for the last lower grid. Then the number of ways for this case will be `T_up(N-1)`.\\n\\n4. **The last tile is of type 6**: in this case, the rest tiles must fill up the `2 x (N-1)` board except for the upper grid at index `N-1`, like this shape: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519583189.png). Our definition of `T(N)` does not cover this case either, so we define `T_down(N)` as the the number of ways to fill a `2 x N` board except for the last upper grid. Then the number of ways for this case will be `T_down(N-1)`.\\n\\nIt\\'s easy to show that the four cases will not overlap with each other (because at least the last tile will be different), and since the last tile must be one of the four cases, we conclude:\\n\\n `T(N) = T(N-1) + T(N-2) + T_up(N-1) + T_down(N-1)`\\n\\nThis looks like a recurrence formula, except that we do not know `T_up(N)` and `T_down(N)` yet. To figure them out, we can follow exactly the same analyses above by considering the very last tile for each of them.\\n\\nTake `T_up(N)` as an example. We want to fill up a board shape like this: ![image](https://s3-lc-upload.s3.amazonaws.com/users/fun4leetcode/image_1519583923.png). What could the type of the very last tile be? The answer is: **type 2** (horizontal domino) and **type 4** (`Gamma`-shaped trimino). For the former, the rest of tiles will fill up a `2 x (N-1)` board except for the last upper grid, and by definition, there are `T_down(N-1)` ways to do this. For the latter, the rest tiles will fill up a `2 x (N-2)` board completely, and by definition, there are `T(N-2)` ways to do so. So we conclude:\\n\\n`T_up(N) = T_down(N-1) + T(N-2)`\\n\\nSimilarly we can obtain:\\n\\n`T_down(N) = T_up(N-1) + T(N-2)`\\n\\nAnd, there you go, we have found the recurrence relations for `T(N)`, `T_up(N)`, `T_down(N)`:\\n\\n`T(N) = T(N-1) + T(N-2) + T_up(N-1) + T_down(N-1)`\\n\\n`T_up(N) = T_down(N-1) + T(N-2)`\\n\\n`T_down(N) = T_up(N-1) + T(N-2)`\\n\\nThe termination conditions are as follows:\\n\\nFor `N = 0`, we have `T(0) = 1`, `T_up(0) =  T_down(0) = 0`;\\nFor `N = 1`, we have `T(1) = 1`, `T_up(1) =  T_down(1) = 0`.\\n\\nNow it is straightforward to write the `O(N)` space solution. However, if you notice that `T(N)`, `T_up(N)`, `T_down(N)` are only related to those at indices `N-1` and `N-2`, the space can be cut down to `O(1)`. Here is a quick implementation in Java:\\n\\n\\n```\\nprivate static final int MOD = 1_000_000_007;\\n    \\npublic int numTilings(int N) {\\n    int T_prepre = 1, T_pre = 1;\\n    int T_up_pre = 0, T_down_pre = 0;\\n        \\n    for (int n = 2; n <= N; n++) {\\n        int T_cur = (int)((0L + T_prepre + T_pre + T_up_pre + T_down_pre) % MOD);\\n        int T_up_cur = (T_prepre + T_down_pre) % MOD;\\n        int T_down_cur = (T_prepre + T_up_pre) % MOD;\\n            \\n        T_prepre = T_pre;\\n        T_pre = T_cur;\\n            \\n        T_up_pre = T_up_cur;\\n        T_down_pre = T_down_cur;\\n    }\\n        \\n    return T_pre;\\n}\\n```\\n\\n<br>\\n\\nWait..., we are not done yet. It turns out that the recurrence relations for `T(N)`, `T_up(N)`, `T_down(N)` can be combined into a single one. To see how, first note that we have:\\n\\n `T(N) = T(N-1) + T(N-2) + T_up(N-1) + T_down(N-1)`\\n \\n `T_up(N-1) = T_down(N-2) + T(N-3)`\\n \\n `T_down(N-1) = T_up(N-2) + T(N-3)`\\n \\n Now plugging the second and third equations into the first one, we get:\\n \\n `T(N) = T(N-1) + T(N-2) + T_down(N-2) + T(N-3) + T_up(N-2) + T(N-3)`\\n \\nwhich can be regrouped as:\\n\\n`T(N) = T(N-1) + T(N-3) + [T(N-2) + T(N-3) + T_up(N-2) + T_down(N-2)]`\\n\\t\\nNow if you recognize the part in **square brakets** which is simply `T(N-1)`, we arrive at: \\n \\n `T(N) = 2 * T(N-1) + T(N-3)`.\\n \\nI would refer you to this [post](https://leetcode.com/problems/domino-and-tromino-tiling/discuss/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3) shared by [zhengkaiwei](https://leetcode.com/zhengkaiwei/) for more explanations of the meaning of this formula. Anyway, the following is the `O(N)` time and `O(1)` space based on this formula, where I used `p3`, `p2`, `p1` to denote `T(N-3)`, `T(N-2)`, `T(N-1)` respectively, and initialized them to `-1`, `0` and `1` to account for correct recurrence values.\\n\\n```\\nprivate static final int MOD = 1_000_000_007;\\n    \\npublic int numTilings(int N) {\\n    int p3 = -1, p2 = 0, p1 = 1;\\n        \\n    for (int n = 1; n <= N; n++) {\\n        int cur = (int)((p1 * 2L + p3) % MOD);\\n        p3 = p2;\\n        p2 = p1;\\n        p1 = cur;\\n    }\\n        \\n    return p1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nprivate static final int MOD = 1_000_000_007;\\n    \\npublic int numTilings(int N) {\\n    int T_prepre = 1, T_pre = 1;\\n    int T_up_pre = 0, T_down_pre = 0;\\n        \\n    for (int n = 2; n <= N; n++) {\\n        int T_cur = (int)((0L + T_prepre + T_pre + T_up_pre + T_down_pre) % MOD);\\n        int T_up_cur = (T_prepre + T_down_pre) % MOD;\\n        int T_down_cur = (T_prepre + T_up_pre) % MOD;\\n            \\n        T_prepre = T_pre;\\n        T_pre = T_cur;\\n            \\n        T_up_pre = T_up_cur;\\n        T_down_pre = T_down_cur;\\n    }\\n        \\n    return T_pre;\\n}\\n```\n```\\nprivate static final int MOD = 1_000_000_007;\\n    \\npublic int numTilings(int N) {\\n    int p3 = -1, p2 = 0, p1 = 1;\\n        \\n    for (int n = 1; n <= N; n++) {\\n        int cur = (int)((p1 * 2L + p3) % MOD);\\n        p3 = p2;\\n        p2 = p1;\\n        p1 = cur;\\n    }\\n        \\n    return p1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1620975,
                "title": "c-python-simple-solution-w-images-explanation-optimization-from-brute-force-to-dp",
                "content": "We are given a `2xn` grid and we need to return number of ways to tile the grid using domino (2x1 shape) and tromino(L shape) tiles.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force)***\\n\\nFirst let\\'s see what different types of shapes we have with us (considering rotations) -\\n\\n<p align = middle>\\n<img src= https://assets.leetcode.com/users/images/9f0fa40d-874c-45dd-88fb-a6d964026e69_1639105504.9259145.png />\\n</p>\\n\\nSo in total, we get 6 different types of shapes (2 from domino & 4 from tromino). **These tile-1, tile-2,... will henceforth be referred as T1, T2, and so on... respectively**\\n\\nLet\\'s see how we can approach this problem using brute-force approach. Since we are only given a `2xn` grid, let our current position on the grid be denoted by an index `i` which denotes that we are currently at `i`th column of grid. At each column, we have the choice to choose any form of the above 6 tiles. However, the current choice will be limited by our previous choices. For eg. If we previously chose T3, we cannot choose T4 after it since that would leave a gap in the grid. Let\\'s see the different cases we have in which we can place tiles -\\n\\n\\n\\n<p align = middle>\\n<img src = https://assets.leetcode.com/users/images/9a096afe-85f9-4358-a179-5563f960fc37_1639115832.0220907.png />\\n<img src = https://assets.leetcode.com/users/images/6cbfc1b2-edda-402b-a386-27b29ce215cf_1639115869.433002.png />\\n</p>\\n\\nThese are all the possible cases using which we can recursively fill our `2xn` grid. We have two different cases where previous rows have no gaps and where previous rows do have gaps. We need to treat them different as that affects the choices of our tiles. So to sum up, we have - \\n1. **No Previous Gaps:**\\n\\t* Place T1 and move to `i+1`: **`solve(i+1, previousGap=false)`**\\n\\t* Place T2 in pair and move to `i+2`: **`solve(i+2, previousGap=false)`**\\n\\t* Place either T3 or T4 (consider both cases) and move to `i+2` with gap at `i+1`th column: **`2*solve(i+2, previousGap=true)`**\\n\\n2. **Previous Gaps Present:**\\n\\t* Place T5 or T6 & fill previous gap (consider only 1 bcoz depending on current configuration, only 1 grid out of them will fit) and move to `i+1` with no previous gaps remaining: **`solve(i+1, previousGap=false)`**\\n\\t* Place T2 & fill previous gap and move to `i+1` with gap present in `i`th column: **`solve(i+1, previousGap=true)`**\\n\\n\\nThat\\'s it! We now just recursively fill the grid using above cases. If we reach the end of the grid (column `i = n`) with no previous gaps, then we know that we found 1 possible way of tiling grid, so we return 1. Otherwise if we exceed bounds of grid or reach end with previous gaps remaining, then we return false.\\n\\n**C++**\\n> *Tiling from Start-to-End*\\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        return solve(0, n, false);\\n    }\\n    long solve(int i, int n, bool previousGap) {\\n        if(i > n) return 0;                 // previous tiling exceeded bounds of grid - return 0 denoting not a valid tiling\\n        if(i == n) return !previousGap;     // return 1 when there was no previous gap present\\n        if(previousGap)                     // previous column had gap remaining in it\\n            return (solve(i+1, n, false) + solve(i+1, n, true)) % MOD;\\n        return (solve(i+1, n, false) + solve(i+2, n, false) + 2l*solve(i+2, n, true)) % MOD;\\n    }\\n};\\n```\\n> *Tiling from End-to-Start*\\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int numTilings(int n, bool previousGap = false) {\\n        if(n < 0) return 0;\\n        if(n == 0) return !previousGap;\\n        if(previousGap)\\n            return (numTilings(n-1) + numTilings(n-1, true)) % MOD;\\n        return (numTilings(n-1) + numTilings(n-2) + 2l*numTilings(n-2, true)) % MOD;\\n    }\\n};\\n```\\n\\n\\n**Python**\\n> *Tiling from Start-to-End*\\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        def solve(i, previous_gap):\\n            if i > n: return 0\\n            if i == n: return not previous_gap\\n            if previous_gap:\\n                return solve(i+1, False) + solve(i+1, True)\\n            return solve(i+1, False) + solve(i+2, False) + 2*solve(i+2, True)\\n        return solve(0, False) % 1_000_000_007\\n```\\n> *Tiling from End-to-Start*\\n```python\\nclass Solution:\\n    def numTilings(self, n, previous_gap = False):\\n        if n < 0: return 0\\n        if n == 0: return not previous_gap\\n        if previous_gap:\\n            return (self.numTilings(n-1) + self.numTilings(n-1, True)) % 1_000_000_007\\n        return (self.numTilings(n-1) + self.numTilings(n-2) + 2*self.numTilings(n-2, True)) % 1_000_000_007\\n```\\n\\n***Time Complexity :*** <code>O(3<sup>N</sup>)</code> where `N` is the given number of columns of grid. We are branching out a max of 3 recursive calls each time and `N` such states giving total  time complexity of <code>O(3<sup>N</sup>)</code> \\n***Space Complexity :*** `O(N)`, required for recursive stack.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Memoization)***\\n\\nDrawing out the recursion tree for previous approach, we can observe that we were doing many repeated redundant calls to the same function state. But for the given parameters - `i` and `previousGap`, the answer will always remain the same. So, we dont need to repeatedly calculate the same results over and over again. We can instead calculate it once and store the result and whenever same call will be made, we can directly return this result instead of repeating the whole calculation.\\n\\nFor this purpose, we will use dynamic programming and memoize the result before returning from each recursive call. We use a `dp` array where `dp[i][previousGap]` denotes the number of ways to tile a grid starting from the `i`th column and `previousGap` denotes whether previous column had gap in it or not. Whenever we find that `dp[i][previousGap]` is already calculated, we can directly return the result.\\n\\n**C++**\\n> *Tiling from Start-to-End*\\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int dp[1001][2]{};\\n    int numTilings(int n) {\\n        return solve(0, n, false);\\n    }\\n    long solve(int i, int n, bool previousGap) {\\n        if(i > n) return 0;\\n        if(i == n) return !previousGap;\\n        if(dp[i][previousGap]) return dp[i][previousGap];\\n        if(previousGap)\\n            return dp[i][previousGap] = (solve(i+1, n, false) + solve(i+1, n, true)) % MOD;\\n        return dp[i][previousGap] = (solve(i+1, n, false) + solve(i+2, n, false) + 2*solve(i+2, n, true)) % MOD;\\n    }\\n};\\n```\\n> *Tiling from End-to-Start*\\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int dp[1001][2]{};\\n    int numTilings(int n, bool previousGap = false) {\\n        if(n < 0) return 0;\\n        if(n == 0) return !previousGap;\\n        if(dp[n][previousGap]) return dp[n][previousGap];\\n        if(previousGap)\\n            return dp[n][previousGap] = (numTilings(n-1) + numTilings(n-1, true)) % MOD;\\n        return dp[n][previousGap] = (numTilings(n-1) + numTilings(n-2) + 2l*numTilings(n-2, true)) % MOD;\\n    }\\n};\\n```\\n\\n**Python**\\n> *Tiling from Start-to-End*\\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        @cache\\n        def solve(i, previous_gap):\\n            if i > n: return 0\\n            if i == n: return not previous_gap\\n            if previous_gap:\\n                return solve(i+1, False) + solve(i+1, True)\\n            return solve(i+1, False) + solve(i+2, False) + 2*solve(i+2, True)\\n        return solve(0, False) % 1_000_000_007\\n```\\n> *Tiling from End-to-Start*\\n```python\\nclass Solution:\\n    @cache\\n    def numTilings(self, n, previous_gap = False):\\n        if n < 0: return 0\\n        if n == 0: return not previous_gap\\n        if previous_gap:\\n            return (self.numTilings(n-1) + self.numTilings(n-1, True)) % 1_000_000_007\\n        return (self.numTilings(n-1) + self.numTilings(n-2) + 2*self.numTilings(n-2, True)) % 1_000_000_007\\n```\\n\\n***Time Complexity :*** <code>O(N)</code> where `N` is the given number of columns of grid\\n***Space Complexity :*** `O(N)`, required for recursive stack and maintaining `dp` \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Tabulation)***\\n\\nWe can also solve this iteratively using dynamic programming. The logic remains similar to the above approach. Here, we again use a `dp` array where `dp[i][0]` denotes the number of ways to tile the grid till `i`th column (including `i`th column) and keeping no gap & `dp[i][1]` denotes the number of ways to completely tile the grid till `i`th column keeping a gap in `i+1`th column (a square protruding out).\\n\\nSimilar to previous solution, we will consider above-mentioned various cases with slight change to adjust for this iterative solutions building in bottom-up manner instead of recursive solution which was calculating in top-down manner. \\n\\n1. **`dp[i][0]`: (number of ways to tile till `i`th column leaving no gap)**\\n\\t* Add T1 at `i`th column updating previous dp state till `i-1`th column that had no previous gap: `dp[i-1][0]`\\n\\t* Add T2 in pair at `i-1`th column updating dp state till `i-2`th column that had no previous gap: `dp[i-2][0]`\\n\\t* Add T5 or T6 at `i-1`th column updating previous dp state till `i-2`th column & filling up the gap at `i-1`th column left by that dp state: `2*dp[i-2][1]` (2x because both T5/T6 can be used to fill the previous dp state having a gap)\\n\\t\\n\\n2. \\t**`dp[i][1]`: (number of ways to tile till `i`th column leaving a gap in `i+1`th column)**\\n\\t* Add T3/T4 at `i`th column updating previous dp state till `i-1`th column having no gap: `dp[i-1][0]`\\n\\t* Use T2 at `i`th column updating previous dp state till `i-1`th column which had a gap at `i`th column: `dp[i-1][1]`\\n\\nThe base conditions are when we have grid with 1 column, `dp[1][0]=1` since we can tile using T1, `dp[1][1]=1` since we can only either use T3 or T4 to tile and leave a gap at `i+1=2`th column. \\nSimilarly, `dp[2][0]=2` since we can tile by adding T1 to `dp[1][0]` ( <img src =\"https://assets.leetcode.com/users/images/89d14903-48f5-47c2-aaab-d0c9f4c7f2e5_1639147300.2449708.png\" height=30 /> ) or use T2 in pairs ( <img src=\"https://assets.leetcode.com/users/images/82ab26e8-e719-4f3c-8897-2749087c5769_1639147180.0998144.png\" height=30 /> ) and `dp[2][1]=2` since we can add T2 to `dp[1][1]` (  <img src=\"https://assets.leetcode.com/users/images/ea4d3fa9-5470-4d6b-a842-cbac38e6e4b3_1639147400.0859642.png\" height=30 /> ) or add T3/T4 to `dp[1][0]` ( <img src=\"https://assets.leetcode.com/users/images/e8709c3f-df65-42ee-93bb-5bc097624a27_1639147533.6720436.png\" height=30 /> ) \\n\\n\\n\\n\\n\\n**C++**\\t\\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(n+2, vector<int>(2));\\n        dp[1] = {1, 1}, dp[2] = {2, 2};                 // base cases\\n        for(int i = 3; i <= n; i++) {\\n            dp[i][0] = (dp[i-1][0] + dp[i-2][0] + 2l*dp[i-2][1]) % MOD;\\n            dp[i][1] = (dp[i-1][0] + dp[i-1][1]) % MOD;\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        dp = [[0, 0] for _ in range(n+2)]\\n        dp[1], dp[2] = [1, 1], [2, 2]\\n        for i in range(3, n+1):\\n            dp[i][0] = dp[i-1][0] + dp[i-2][0] + 2*dp[i-2][1]\\n            dp[i][1] = dp[i-1][0] + dp[i-1][1]\\n        return dp[n][0] % 1_000_000_007\\n```\\n\\nIf the above wasn\\'t understood, the following is based on slightly different definition of DP which maybe better understood by some people.\\n\\n<blockquote>\\n<details>\\n<summary><b><em>Slight Different DP modelling</em></b></summary>\\n\\nThere\\'s a slightly different way of implementation as well which depends upon how we model & define our dp states. If we consider a dp array, where `dp[i][0]` denotes number of ways to completely tile till & including `i`th column leaving no gap and `dp[i][1]` denotes the number of ways to complete tile till `i-1`th column and leaving a gap at `i` column (Notice the difference from above definition).\\n\\nIn this case, we define the state transition cases as -\\n\\n1. **`dp[i][0]`: (number of ways to tile till `i`th column leaving no gap)**\\n\\t* Add T1 at `i`th column updating previous dp state till `i-1`th column having no previous gap: `dp[i-1][0]`\\n\\t* Add T2 in pair at `i-1`th column updating dp state till `i-2`th column having no previous gap: `dp[i-2][0]`\\n\\t* Add T5 or T6 at `i-1`th column updating previous dp state at `i-1`th column & filling up the gap at `i-1`th column left by that dp state: `2*dp[i-1][1]` (*<- different definition of dp changed this*)\\n\\t\\n2. \\t**`dp[i][1]`: (number of ways to tile till `i-1`th column keeping a gap in `i`th column)** (*different definition of dp changes this*)\\n\\t* Add T3/T4 at `i-1`th column updating dp state till `i-2`th column that had no gap (and this leaves a gap at `i`th column instead of `i+1`th column as in above approach): `dp[i-2][0]`\\n\\t* Use T2 at `i-1`th column updating previous dp state till `i-1`th column that had a gap at `i-1`th column (again this leaves gap at `i`th column instead of `i+1` as in above approach): `dp[i-1][1]`\\n\\nThe base conditions change accordingly as well.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(n+2, vector<int>(2));\\n        dp[1] = {1, 1}, dp[2] = {2, 1};                 // base cases\\n        for(int i = 3; i <= n; i++) {\\n            dp[i][0] = (dp[i-1][0] + dp[i-2][0] + 2l*dp[i-1][1]) % MOD;\\n            dp[i][1] = (dp[i-2][0] + dp[i-1][1]) % MOD;\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        dp = [[0, 0] for _ in range(n+2)]\\n        dp[1], dp[2] = [1, 1], [2, 1]\\n        for i in range(3, n+1):\\n            dp[i][0] = dp[i-1][0] + dp[i-2][0] + 2*dp[i-1][1]\\n            dp[i][1] = dp[i-2][0] + dp[i-1][1]\\n        return dp[n][0] % 1_000_000_007\\n```\\n\\n</details>\\n</blockquote>\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** `O(N)`, required maintaining `dp` \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Space Optimized Dynamic Programming)***\\n\\nIn the above solution, we can observe that we are only ever accesing results stored in `i-1` & `i-2` columns. So we can optimize space by just storing those previous columns which are required to calculate the result for current column.\\n\\nFor this, we can either keep the structure of previous code as it is but use a dp array of only 3 rows and just modulo 3. Or we can use separate variables to store previous results. Use whichever is easier/preferable to your style\\n\\n**C++**\\n*Using mod3 on dp of 3 rows*\\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(3, vector<int>(2));  // note only 3 rows are declared\\n        dp[1] = {1, 1}, dp[2] = {2, 2};\\n        for(int i = 3; i <= n; i++) {\\n            dp[i%3][0] = (dp[(i-1)%3][0] + dp[(i-2)%3][0] + 2l*dp[(i-2)%3][1]) % MOD;\\n            dp[i%3][1] = (dp[(i-1)%3][0] + dp[(i-1)%3][1]) % MOD;\\n        }\\n        return dp[n%3][0];\\n    }\\n};\\n```\\n\\n*Separate variables storing previous results*\\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        if(n <= 2) return n;\\n\\t\\t// filled_prev = dp[i-1][0], filled_prev2 = dp[i-2][0]...same for gap_prev & gap_prev2\\n        int filled_prev = 2, gap_prev = 2, filled_prev2 = 1, gap_prev2 = 1;\\n        for(int i = 3; i <= n; i++) {\\n            int filled = (filled_prev + filled_prev2 + 2l*gap_prev2) % MOD;\\n            int gap = (filled_prev + gap_prev) % MOD;\\n            \\n            filled_prev2 = filled_prev, filled_prev = filled;\\n            gap_prev2 = gap_prev, gap_prev = gap;\\n        }\\n        return filled_prev;\\n    }\\n};\\n```\\n\\n**Python**\\n*Using mod3 of dp of 3 rows*\\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        dp = [[0, 0] for _ in range(3)]\\n        dp[1], dp[2] = [1, 1], [2, 2]\\n        for i in range(3, n+1):\\n            dp[i%3][0] = dp[(i-1)%3][0] + dp[(i-2)%3][0] + 2*dp[(i-2)%3][1]\\n            dp[i%3][1] = dp[(i-1)%3][0] + dp[(i-1)%3][1]\\n        return dp[n%3][0] % 1_000_000_007\\n```\\n\\n*Separate variables storing previous results*\\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        if n <= 2: return n\\n        filled_prev, gap_prev, filled_prev2, gap_prev2 = 2,2,1,1\\n        for i in range(3, n+1):\\n            filled = filled_prev + filled_prev2 + 2*gap_prev2\\n            gap = filled_prev + gap_prev\\n            \\n            filled_prev2, filled_prev, gap_prev2, gap_prev = filled_prev, filled, gap_prev, gap\\n        return filled_prev % 1_000_000_007\\n```\\n\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** `O(1)`, only constant extra space is used\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        return solve(0, n, false);\\n    }\\n    long solve(int i, int n, bool previousGap) {\\n        if(i > n) return 0;                 // previous tiling exceeded bounds of grid - return 0 denoting not a valid tiling\\n        if(i == n) return !previousGap;     // return 1 when there was no previous gap present\\n        if(previousGap)                     // previous column had gap remaining in it\\n            return (solve(i+1, n, false) + solve(i+1, n, true)) % MOD;\\n        return (solve(i+1, n, false) + solve(i+2, n, false) + 2l*solve(i+2, n, true)) % MOD;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int numTilings(int n, bool previousGap = false) {\\n        if(n < 0) return 0;\\n        if(n == 0) return !previousGap;\\n        if(previousGap)\\n            return (numTilings(n-1) + numTilings(n-1, true)) % MOD;\\n        return (numTilings(n-1) + numTilings(n-2) + 2l*numTilings(n-2, true)) % MOD;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        def solve(i, previous_gap):\\n            if i > n: return 0\\n            if i == n: return not previous_gap\\n            if previous_gap:\\n                return solve(i+1, False) + solve(i+1, True)\\n            return solve(i+1, False) + solve(i+2, False) + 2*solve(i+2, True)\\n        return solve(0, False) % 1_000_000_007\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n, previous_gap = False):\\n        if n < 0: return 0\\n        if n == 0: return not previous_gap\\n        if previous_gap:\\n            return (self.numTilings(n-1) + self.numTilings(n-1, True)) % 1_000_000_007\\n        return (self.numTilings(n-1) + self.numTilings(n-2) + 2*self.numTilings(n-2, True)) % 1_000_000_007\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int dp[1001][2]{};\\n    int numTilings(int n) {\\n        return solve(0, n, false);\\n    }\\n    long solve(int i, int n, bool previousGap) {\\n        if(i > n) return 0;\\n        if(i == n) return !previousGap;\\n        if(dp[i][previousGap]) return dp[i][previousGap];\\n        if(previousGap)\\n            return dp[i][previousGap] = (solve(i+1, n, false) + solve(i+1, n, true)) % MOD;\\n        return dp[i][previousGap] = (solve(i+1, n, false) + solve(i+2, n, false) + 2*solve(i+2, n, true)) % MOD;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int dp[1001][2]{};\\n    int numTilings(int n, bool previousGap = false) {\\n        if(n < 0) return 0;\\n        if(n == 0) return !previousGap;\\n        if(dp[n][previousGap]) return dp[n][previousGap];\\n        if(previousGap)\\n            return dp[n][previousGap] = (numTilings(n-1) + numTilings(n-1, true)) % MOD;\\n        return dp[n][previousGap] = (numTilings(n-1) + numTilings(n-2) + 2l*numTilings(n-2, true)) % MOD;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        @cache\\n        def solve(i, previous_gap):\\n            if i > n: return 0\\n            if i == n: return not previous_gap\\n            if previous_gap:\\n                return solve(i+1, False) + solve(i+1, True)\\n            return solve(i+1, False) + solve(i+2, False) + 2*solve(i+2, True)\\n        return solve(0, False) % 1_000_000_007\\n```\n```python\\nclass Solution:\\n    @cache\\n    def numTilings(self, n, previous_gap = False):\\n        if n < 0: return 0\\n        if n == 0: return not previous_gap\\n        if previous_gap:\\n            return (self.numTilings(n-1) + self.numTilings(n-1, True)) % 1_000_000_007\\n        return (self.numTilings(n-1) + self.numTilings(n-2) + 2*self.numTilings(n-2, True)) % 1_000_000_007\\n```\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(n+2, vector<int>(2));\\n        dp[1] = {1, 1}, dp[2] = {2, 2};                 // base cases\\n        for(int i = 3; i <= n; i++) {\\n            dp[i][0] = (dp[i-1][0] + dp[i-2][0] + 2l*dp[i-2][1]) % MOD;\\n            dp[i][1] = (dp[i-1][0] + dp[i-1][1]) % MOD;\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        dp = [[0, 0] for _ in range(n+2)]\\n        dp[1], dp[2] = [1, 1], [2, 2]\\n        for i in range(3, n+1):\\n            dp[i][0] = dp[i-1][0] + dp[i-2][0] + 2*dp[i-2][1]\\n            dp[i][1] = dp[i-1][0] + dp[i-1][1]\\n        return dp[n][0] % 1_000_000_007\\n```\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(n+2, vector<int>(2));\\n        dp[1] = {1, 1}, dp[2] = {2, 1};                 // base cases\\n        for(int i = 3; i <= n; i++) {\\n            dp[i][0] = (dp[i-1][0] + dp[i-2][0] + 2l*dp[i-1][1]) % MOD;\\n            dp[i][1] = (dp[i-2][0] + dp[i-1][1]) % MOD;\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        dp = [[0, 0] for _ in range(n+2)]\\n        dp[1], dp[2] = [1, 1], [2, 1]\\n        for i in range(3, n+1):\\n            dp[i][0] = dp[i-1][0] + dp[i-2][0] + 2*dp[i-1][1]\\n            dp[i][1] = dp[i-2][0] + dp[i-1][1]\\n        return dp[n][0] % 1_000_000_007\\n```\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(3, vector<int>(2));  // note only 3 rows are declared\\n        dp[1] = {1, 1}, dp[2] = {2, 2};\\n        for(int i = 3; i <= n; i++) {\\n            dp[i%3][0] = (dp[(i-1)%3][0] + dp[(i-2)%3][0] + 2l*dp[(i-2)%3][1]) % MOD;\\n            dp[i%3][1] = (dp[(i-1)%3][0] + dp[(i-1)%3][1]) % MOD;\\n        }\\n        return dp[n%3][0];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n\\tconst int MOD = 1e9+7;\\n    int numTilings(int n) {\\n        if(n <= 2) return n;\\n\\t\\t// filled_prev = dp[i-1][0], filled_prev2 = dp[i-2][0]...same for gap_prev & gap_prev2\\n        int filled_prev = 2, gap_prev = 2, filled_prev2 = 1, gap_prev2 = 1;\\n        for(int i = 3; i <= n; i++) {\\n            int filled = (filled_prev + filled_prev2 + 2l*gap_prev2) % MOD;\\n            int gap = (filled_prev + gap_prev) % MOD;\\n            \\n            filled_prev2 = filled_prev, filled_prev = filled;\\n            gap_prev2 = gap_prev, gap_prev = gap;\\n        }\\n        return filled_prev;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        dp = [[0, 0] for _ in range(3)]\\n        dp[1], dp[2] = [1, 1], [2, 2]\\n        for i in range(3, n+1):\\n            dp[i%3][0] = dp[(i-1)%3][0] + dp[(i-2)%3][0] + 2*dp[(i-2)%3][1]\\n            dp[i%3][1] = dp[(i-1)%3][0] + dp[(i-1)%3][1]\\n        return dp[n%3][0] % 1_000_000_007\\n```\n```python\\nclass Solution:\\n    def numTilings(self, n):\\n        if n <= 2: return n\\n        filled_prev, gap_prev, filled_prev2, gap_prev2 = 2,2,1,1\\n        for i in range(3, n+1):\\n            filled = filled_prev + filled_prev2 + 2*gap_prev2\\n            gap = filled_prev + gap_prev\\n            \\n            filled_prev2, filled_prev, gap_prev2, gap_prev = filled_prev, filled, gap_prev, gap\\n        return filled_prev % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116612,
                "title": "easy-to-understand-o-n-solution-with-drawing-picture-explanation",
                "content": "The way to solve is too simple ,it's easy to understand by see the pictrue drawing here:\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/yuweiming70/image_1519549786.png)\n\nso the code can be write as this:\n\n```\n    int numTilings(int N) \n    {\n        long long g[1001],u[1001];\n        int mod=1000000007;\n        g[0]=0; g[1]=1; g[2]=2;\n        u[0]=0; u[1]=1; u[2]=2;\n        \n        for(int i=3;i<=N;i++)\n        {\n            u[i] = (u[i-1] + g[i-1]           )   %mod;\n            g[i] = (g[i-1] + g[i-2] + 2*u[i-2])   %mod;\n        }\n        return g[N]%mod;\n    }\n```",
                "solutionTags": [],
                "code": "```\n    int numTilings(int N) \n    {\n        long long g[1001],u[1001];\n        int mod=1000000007;\n        g[0]=0; g[1]=1; g[2]=2;\n        u[0]=0; u[1]=1; u[2]=2;\n        \n        for(int i=3;i<=N;i++)\n        {\n            u[i] = (u[i-1] + g[i-1]           )   %mod;\n            g[i] = (g[i-1] + g[i-2] + 2*u[i-2])   %mod;\n        }\n        return g[N]%mod;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1620809,
                "title": "python-java-c-c-dp-image-visualized-explanation-100-faster-o-n",
                "content": "* dp[i] denotes the number of ways to tile an 2 * (i + 1) board, note that dp is 0-indexed.\\n\\t* Intuitively, dp[0] = 1 and dp[1] = 2\\n* dpa[i] denotes the number of ways to tile an 2 * i board and 1 more square left below(or above symmetrically).\\n\\t* Intuitively, dpa[0] = 0 and dpa[1] = 1\\n\\t* I just explained the case where in i-th column, 2nd row is filled. But it should be noted that the two cases(the other is in i-th column, 1st row is filled) are symmetric and the numbers are both dpa[i], you may imagine dpb[i] = dpa[i] for the second case where i-th column 1st row is filled.\\n![image](https://assets.leetcode.com/users/images/875bd993-2f8d-44f5-95eb-c113e8983cc8_1639109494.0658832.jpeg)\\n![image](https://assets.leetcode.com/users/images/de639bbf-995e-48da-96ee-47bc830cd220_1639109512.768774.jpeg)\\n\\nFurther More!\\n![image](https://assets.leetcode.com/users/images/45740626-fc9e-4cc5-be36-6553da40efaa_1639117939.3698611.jpeg)\\n\\n\\n\\n**If you hava any question, feel free to ask. If you like the solution or the explaination, Please UPVOTE!**\\n\\n**Python/Python3**\\n```\\nclass Solution(object):\\n    def numTilings(self, n):\\n        dp = [1, 2, 5] + [0] * n\\n        for i in range(3, n):\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007\\n        return dp[n - 1]\\n```\\n```\\nclass Solution(object):\\n    def numTilings(self, n):\\n        dp, dpa = [1, 2] + [0] * n, [1] * n\\n        for i in range(2, n):\\n            dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007\\n            dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007\\n        return dp[n - 1]\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        long[] dp = new long[n + 3]; dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n        for (int i = 3; i < n; i ++) {\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007;\\n        }\\n        return (int)dp[n - 1];\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        long[] dp = new long[n + 2]; dp[0] = 1; dp[1] = 2;\\n        long[] dpa = new long[n + 2]; dpa[1] = 1;\\n        for (int i = 2; i < n; i ++) {\\n            dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007;\\n            dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007;\\n        }\\n        return (int)dp[n - 1];\\n    }\\n}\\n```\\n**C/C++**\\n```\\nint numTilings(int n) {\\n    unsigned int dp[n + 3]; dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n    for (int i = 3; i < n; i ++) {\\n        dp[i] = (2 * dp[i - 1] + dp[i - 3]) % 1000000007;\\n    }\\n    return dp[n - 1];\\n}\\n```\\n```\\nint numTilings(int n){\\n    if (n == 1) return 1;\\n    unsigned int dp[n]; dp[0] = 1; dp[1] = 2;\\n    unsigned int dpa[n]; dpa[1] = 1;\\n    for (int i = 2; i < n; i ++) {\\n        dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007;\\n        dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007;\\n    }\\n    return dp[n - 1];\\n}\\n```\\n\\n**Please UPVOTE!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def numTilings(self, n):\\n        dp = [1, 2, 5] + [0] * n\\n        for i in range(3, n):\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007\\n        return dp[n - 1]\\n```\n```\\nclass Solution(object):\\n    def numTilings(self, n):\\n        dp, dpa = [1, 2] + [0] * n, [1] * n\\n        for i in range(2, n):\\n            dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007\\n            dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007\\n        return dp[n - 1]\\n```\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        long[] dp = new long[n + 3]; dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n        for (int i = 3; i < n; i ++) {\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007;\\n        }\\n        return (int)dp[n - 1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        long[] dp = new long[n + 2]; dp[0] = 1; dp[1] = 2;\\n        long[] dpa = new long[n + 2]; dpa[1] = 1;\\n        for (int i = 2; i < n; i ++) {\\n            dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007;\\n            dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007;\\n        }\\n        return (int)dp[n - 1];\\n    }\\n}\\n```\n```\\nint numTilings(int n) {\\n    unsigned int dp[n + 3]; dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n    for (int i = 3; i < n; i ++) {\\n        dp[i] = (2 * dp[i - 1] + dp[i - 3]) % 1000000007;\\n    }\\n    return dp[n - 1];\\n}\\n```\n```\\nint numTilings(int n){\\n    if (n == 1) return 1;\\n    unsigned int dp[n]; dp[0] = 1; dp[1] = 2;\\n    unsigned int dpa[n]; dpa[1] = 1;\\n    for (int i = 2; i < n; i ++) {\\n        dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007;\\n        dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007;\\n    }\\n    return dp[n - 1];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600275,
                "title": "java-dp-diagrams-explanation",
                "content": "### Detailed Explanation:\\n\\n![image](https://assets.leetcode.com/users/images/c1a13d98-45d2-45d5-8ade-515576f004c6_1638081170.1326487.jpeg)\\n![image](https://assets.leetcode.com/users/images/720c22aa-077f-4078-a5b5-fa925077c40a_1638081179.2062912.jpeg)\\n![image](https://assets.leetcode.com/users/images/27ffdec8-22a6-48d2-8435-84de9cdc2303_1638081187.4332094.jpeg)\\n\\n\\n<br/>\\n\\n### Code:\\n\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n <= 2)\\n            return n;\\n        \\n        int mod = 1_000_000_007;\\n        long[] fullTiling = new long[n+1];\\n        long[] partTiling = new long[n+1];\\n        \\n        // One tile vertical can fill a pair of cells (or 1 column)\\n        fullTiling[1] = 1;\\n        // 2 vertical and 2 horizontals can fill up 2 pair of cells (or 2 columns)\\n        fullTiling[2] = 2; \\n        \\n        // Cannot fill one cell (in a column) with either domino or tromino\\n        partTiling[1] = 0; \\n        // If 1 cell out of 4 (2 pair of cells) is already filled then a tromino can fill the remaining 3 cells\\n        partTiling[2] = 1; \\n        \\n        for(int i=3; i <= n; i++){\\n            fullTiling[i] = (fullTiling[i-1] + fullTiling[i-2] + 2 * partTiling[i-1]) % mod;\\n            partTiling[i] = (partTiling[i-1] + fullTiling[i-2]) % mod;\\n        }        \\n        return (int)(fullTiling[n]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n <= 2)\\n            return n;\\n        \\n        int mod = 1_000_000_007;\\n        long[] fullTiling = new long[n+1];\\n        long[] partTiling = new long[n+1];\\n        \\n        // One tile vertical can fill a pair of cells (or 1 column)\\n        fullTiling[1] = 1;\\n        // 2 vertical and 2 horizontals can fill up 2 pair of cells (or 2 columns)\\n        fullTiling[2] = 2; \\n        \\n        // Cannot fill one cell (in a column) with either domino or tromino\\n        partTiling[1] = 0; \\n        // If 1 cell out of 4 (2 pair of cells) is already filled then a tromino can fill the remaining 3 cells\\n        partTiling[2] = 1; \\n        \\n        for(int i=3; i <= n; i++){\\n            fullTiling[i] = (fullTiling[i-1] + fullTiling[i-2] + 2 * partTiling[i-1]) % mod;\\n            partTiling[i] = (partTiling[i-1] + fullTiling[i-2]) % mod;\\n        }        \\n        return (int)(fullTiling[n]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620735,
                "title": "java-dp-detailed-explanation-using-image",
                "content": "**Intution and Explanation:**\\n![image](https://assets.leetcode.com/users/images/67d814a1-a8ef-49be-baea-4edffbd0cdd2_1639143595.6763859.jpeg)\\n\\nTime Complexity : O(n)\\nSpace Complexity : O(n)\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        int dp[] = new int[n+4];\\n        \\n        int mod = (int)(Math.pow(10,9)+7);\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        \\n        for(int i=4;i<=n;i++){\\n            dp[i] = ((2*dp[i-1])%mod)+dp[i-3];\\n            dp[i] %= mod;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n\\nThanks for reading it...I hope I was able to explain clearly!!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        int dp[] = new int[n+4];\\n        \\n        int mod = (int)(Math.pow(10,9)+7);\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        \\n        for(int i=4;i<=n;i++){\\n            dp[i] = ((2*dp[i-1])%mod)+dp[i-3];\\n            dp[i] %= mod;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620641,
                "title": "c-simple-and-short-solution-with-detailed-explanation",
                "content": "**Idea:**\\nIn any iteration, our empty slots in the board can look in two ways:\\nEither it\\'s a full rectangle or it\\'s a rectangle with one more square sticking out.\\n\\nWe define two functions:\\nD[i] = The number of ways to fill a full rectangle in the size of i * 2.\\nT[i] = The number of ways to fill a rectangle of size i * 2 + one square sticking out.\\n\\n**D[i]:**\\nWe have a rectangle.\\nWe have 3 options:\\n1. put one domino vertically on the side, leaving us with a full rectangle of size i-1 - `D[i-1]`.\\n2. put two dominoes on the side, leaving us with a full rectangle of size i-2 - `D[i-2]`.\\n3. Put a tromino on the side - leaving us with a rectangle of size i-2 plus another sticking out square - `T[i-2]`.\\nThere are two directions to put the tromino, so we have `2 * T[i-2]`.\\n\\nConclusion - **D[i] = D[i-1] + D[1-2] + 2 * T[i-2]**.\\n\\n**T[i]:**\\nWe have a rectangle with a square sticking out, it doesn\\'t matter if on the top row or bottom.\\nWe have two options:\\n1. Put a domino horizontally in the sticking out square, leaving us again with a sticking out square on the other row - `T[i-1]`.\\n2. Put a tromino completing the extra square, leaving us with a full rectangle - `D[i-1]`.\\n\\nConclusion - **T[i] = T[i-1] + D[i-1]**.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(n)\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if (n < 3) return n;\\n        \\n        int mod = pow(10, 9) + 7;\\n        vector<long> D(n+1, 0), T(n+1, 0);\\n        D[0] = 0, D[1] = 1, D[2] = 2;\\n        T[0] = 0, T[1] = 1, T[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++) {\\n            D[i] = (D[i-1] + D[i-2] + 2*T[i-2]) % mod;\\n            T[i] = (T[i-1] + D[i-1]) % mod;\\n        }\\n        \\n        return D[n];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if (n < 3) return n;\\n        \\n        int mod = pow(10, 9) + 7;\\n        vector<long> D(n+1, 0), T(n+1, 0);\\n        D[0] = 0, D[1] = 1, D[2] = 2;\\n        T[0] = 0, T[1] = 1, T[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++) {\\n            D[i] = (D[i-1] + D[i-2] + 2*T[i-2]) % mod;\\n            T[i] = (T[i-1] + D[i-1]) % mod;\\n        }\\n        \\n        return D[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116506,
                "title": "python-recursive-dp-solution-with-cache-w-explanation",
                "content": "The idea is to have two functions numTilingsD that handles the number of ways of filling using Domio and numTilingsT that handles number of ways of filling using Tromino.\nAs this is a DP with recursive solution we have 2 caches cacheD and cacheT to store the corresponding solutions.\n\nIf you open the images below in a new tab, they are a bit more readable.\n\n[Also, kindly refer to @vegito2002@gmail.com's diagram, in this thread, for a more clear picutre]\n\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/johnyrufus16/image_1519552844.png)\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/johnyrufus16/image_1519552870.png)\n\n\n\n\n\n\n```\ndef numTilings(self, N):\n    def numTilingsD(N):\n        if N in cacheD: return cacheD[N]\n        if N <= 2: return N if N > 0 else 1 \n        cacheD[N] = (numTilingsD(N - 2) + numTilingsD(N - 1) + (2 * numTilingsT(N - 1))) % ((10**9) + 7)\n        return cacheD[N]\n\n    def numTilingsT(N):\n        if N in cacheT: return cacheT[N]\n        if N <= 2: return 0 if N == 1 else 1\n        cacheT[N] = (numTilingsD(N - 2) + numTilingsT(N - 1)) % ((10**9) + 7)\n        return cacheT[N]\n    cacheD, cacheT = {}, {}\n    return numTilingsD(N)\n```",
                "solutionTags": [],
                "code": "```\ndef numTilings(self, N):\n    def numTilingsD(N):\n        if N in cacheD: return cacheD[N]\n        if N <= 2: return N if N > 0 else 1 \n        cacheD[N] = (numTilingsD(N - 2) + numTilingsD(N - 1) + (2 * numTilingsT(N - 1))) % ((10**9) + 7)\n        return cacheD[N]\n\n    def numTilingsT(N):\n        if N in cacheT: return cacheT[N]\n        if N <= 2: return 0 if N == 1 else 1\n        cacheT[N] = (numTilingsD(N - 2) + numTilingsT(N - 1)) % ((10**9) + 7)\n        return cacheT[N]\n    cacheD, cacheT = {}, {}\n    return numTilingsD(N)\n```",
                "codeTag": "Python3"
            },
            {
                "id": 116544,
                "title": "c-java-python-o-n-time-and-o-1-space",
                "content": "The answer will be a recursive sequence as follow: ```1, 1, 2, 5, 11, 24, 53, 117, 258, 569, 1255```\\nIt grows at a speed about 2 times bigger each time.\\nIf you write down this recursive sequence and do some calculations, you may find that: \\n\\n```5 = 2 * 2 + 1```\\n```11 = 5 * 2 + 1```\\n```24 = 11 * 2 + 2```\\n```53 = 24 * 2 + 5```\\n```117 = 53 * 2 + 11```\\n```A[N] = A[N-1] * 2 + A[N-3]```\\n\\nOnce you notice it, the rest work will be easy, even it may be hard to prove it.\\n\\nC++:\\n```\\n    int numTilings(int N) {\\n        int a = 0, b = 1, c = 1, c2, mod = 1e9 + 7;\\n        while (--N) {\\n            c2 = (c * 2 % mod + a) % mod;\\n            a = b;\\n            b = c;\\n            c = c2;\\n        }\\n        return c;\\n    }\\n```\\n\\nJava:\\n```\\n   public int numTilings(int N) {\\n        int a = 0, b = 1, c = 1, c2, mod = 1000000007;\\n        while (--N > 0) {\\n            c2 = (c * 2 % mod + a) % mod;\\n            a = b;\\n            b = c;\\n            c = c2;\\n        }\\n        return c;\\n    }\\n```\\n\\nPython:\\n```\\n    def numTilings(self, N):\\n        a, b, c = 0, 1, 1\\n        for i in range(N - 1): a, b, c = b, c, (c + c + a) % int(1e9 + 7)\\n        return c\\n````\\n\\nUpdated:\\nMy original DP solution:\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/discuss/116534\\n",
                "solutionTags": [],
                "code": "```1, 1, 2, 5, 11, 24, 53, 117, 258, 569, 1255```\n```5 = 2 * 2 + 1```\n```11 = 5 * 2 + 1```\n```24 = 11 * 2 + 2```\n```53 = 24 * 2 + 5```\n```117 = 53 * 2 + 11```\n```A[N] = A[N-1] * 2 + A[N-3]```\n```\\n    int numTilings(int N) {\\n        int a = 0, b = 1, c = 1, c2, mod = 1e9 + 7;\\n        while (--N) {\\n            c2 = (c * 2 % mod + a) % mod;\\n            a = b;\\n            b = c;\\n            c = c2;\\n        }\\n        return c;\\n    }\\n```\n```\\n   public int numTilings(int N) {\\n        int a = 0, b = 1, c = 1, c2, mod = 1000000007;\\n        while (--N > 0) {\\n            c2 = (c * 2 % mod + a) % mod;\\n            a = b;\\n            b = c;\\n            c = c2;\\n        }\\n        return c;\\n    }\\n```\n```\\n    def numTilings(self, N):\\n        a, b, c = 0, 1, 1\\n        for i in range(N - 1): a, b, c = b, c, (c + c + a) % int(1e9 + 7)\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 931254,
                "title": "recursively-solve-sub-problems-with-pictures-no-confusing-dp-math-formulas-o-n",
                "content": "**Imagine we are looking at the `i`th column, all previous columns have been fully tiled.**\\n\\n**There are three possible states at the ith column**\\n\\n**1. BOTH TOP AND BOTTOM CELLS ARE EMPTY**\\n\\n![image](https://assets.leetcode.com/users/images/d71ff7e3-b01a-4466-aa30-dcd6c9bef79c_1605052246.083369.png)\\n\\n**2. ONLY THE BOTTOM CELL IS EMPTY** (green block = used cell)\\n\\n![image](https://assets.leetcode.com/users/images/01adb44e-a3fa-4735-b0f0-ac763547896d_1605052289.985583.png)\\n\\n**3. ONLY THE TOP CELL IS EMPTY** (green block = used cell)\\n\\n![image](https://assets.leetcode.com/users/images/c09c7572-961f-4483-9504-d1ed7bdeb911_1605052313.539652.png)\\n\\n**WHEN BOTH CELLS EMPTY (STATE 1)**\\n\\n**At the current column, we can use**\\n\\n- One vertical domino\\n\\t- **after using it at `i`th column, we need to calculate `i + 1`th column at state 1** (at `i + 1` both cells are still empty)\\n- OR two horizontal dominos\\n\\t- **then we calculate `i + 2`th at state 1** (each horizontal domino takes two columns, at `i + 2` both cells are empty)\\n- OR a L tromino\\n\\t- **then calculate `i+1` at state 3 above** after using it, at `i + 1` the bottom cell will be used.\\n- OR a flipped L tromino\\n\\t- **then calculate `i+1` at state 2 above** after using it, at `i + 1` the top cell will be used.\\n\\n**For state 1, the total number of ways is the sum of all four posibilities**\\n\\n![image](https://assets.leetcode.com/users/images/aa2b11c4-7ca8-4a00-9e31-b04ab949dcd6_1605052038.9683368.png)\\n\\n**WHEN BOTTOM CELL EMPTY (STATE 2)**\\n\\n**we can use**\\n\\n- one horizontal tile at the bottom\\n\\t- **after using it, we need to calculate `i+1` at state 3**, bottom cell of `i+1` is used\\n- one horizontally flipped L tromino\\n\\t- **after using it, we need to calculate `i+2` at state 1**, both top and bottom cells at `i+2` are empty, L tromino takes two columns, hence `i + 2`\\n\\n**Total number of ways is the sum of both possibilities**\\n\\n![image](https://assets.leetcode.com/users/images/33acc706-5062-411c-8277-552770f1be1b_1605052136.7791326.png)\\n\\n**WHEN TOP CELL EMPTY (STATE 3)**\\n\\n**we can use**\\n\\n- one horizontal tile at the top\\n\\t- **after using it, we need to calculate `i+1` at state 2**, top cell of `i+1` is used\\n- one flipped L tromino\\n\\t- **after using it, we need to calculate `i+2` at state 1**, both top and bottom cells at `i+2` are empty, L tromino takes two columns, hence `i + 2`\\n\\n**Total number of ways is the sum of both possibilities**\\n\\n![image](https://assets.leetcode.com/users/images/93b1a388-ca1f-441b-aa74-d73a9d439c69_1605052179.572588.png)\\n\\n**We just need to recursively solve the same problem at each index.**\\n\\n**Implementation**\\n```javascript\\nfunction rc (n, index = 0, state = \\'topBottomFree\\') {\\n    if (index >= n) return state === \\'topBottomFree\\' && index === n ? 1 : 0;\\n    switch (state) {\\n        case \\'topBottomFree\\':\\n            const useVerticalDomino = rc(n, index + 1, \\'topBottomFree\\');\\n            const useTwoHorizontalDomino = rc(n, index + 2, \\'topBottomFree\\');\\n            const useTopTromino = rc(n, index + 1, \\'bottomFree\\');\\n            const useBottomTromino = rc(n, index + 1, \\'topFree\\');\\n            return useVerticalDomino + useTwoHorizontalDomino + useTopTromino + useBottomTromino;\\n        case \\'bottomFree\\':\\n            const useHorizontallyFlippedBottomTromino = rc(n, index + 2, \\'topBottomFree\\');\\n            const useHorizontalDominoAtBottom = rc(n, index + 1, \\'topFree\\');\\n            return useHorizontallyFlippedBottomTromino + useHorizontalDominoAtBottom;\\n        case \\'topFree\\':\\n            const useHorizontallyFlippedTopTromino = rc(n, index + 2, \\'topBottomFree\\');\\n            const useHorizontalDominoAtTop = rc(n, index + 1, \\'bottomFree\\');\\n            return useHorizontallyFlippedTopTromino + useHorizontalDominoAtTop;\\n    }\\n}\\n```\\n\\n**Add memoisation, there are only 3 states at each index, complexity O(3n)**\\n```javascript\\nfunction rc2 (n, index = 0, state = 0, memo = {}) {\\n    if (index >= n) return state === 0 && index === n ? 1 : 0;\\n    \\n    const memoKey = `${index},${state}`;\\n    if (memo[memoKey] !== undefined) return memo[memoKey];\\n    \\n    switch (state) {\\n        case 0:\\n            return memo[memoKey] = (rc2(n, index + 1, 0, memo) + rc2(n, index + 2, 0, memo) + rc2(n, index + 1, 1, memo) + rc2(n, index + 1, 2, memo)) % 1000000007;\\n        case 1:\\n            return memo[memoKey] = (rc2(n, index + 2, 0, memo) + rc2(n, index + 1, 2, memo)) % 1000000007;\\n        case 2:\\n            return memo[memoKey] = (rc2(n, index + 2, 0, memo) + rc2(n, index + 1, 1, memo)) % 1000000007;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```javascript\\nfunction rc (n, index = 0, state = \\'topBottomFree\\') {\\n    if (index >= n) return state === \\'topBottomFree\\' && index === n ? 1 : 0;\\n    switch (state) {\\n        case \\'topBottomFree\\':\\n            const useVerticalDomino = rc(n, index + 1, \\'topBottomFree\\');\\n            const useTwoHorizontalDomino = rc(n, index + 2, \\'topBottomFree\\');\\n            const useTopTromino = rc(n, index + 1, \\'bottomFree\\');\\n            const useBottomTromino = rc(n, index + 1, \\'topFree\\');\\n            return useVerticalDomino + useTwoHorizontalDomino + useTopTromino + useBottomTromino;\\n        case \\'bottomFree\\':\\n            const useHorizontallyFlippedBottomTromino = rc(n, index + 2, \\'topBottomFree\\');\\n            const useHorizontalDominoAtBottom = rc(n, index + 1, \\'topFree\\');\\n            return useHorizontallyFlippedBottomTromino + useHorizontalDominoAtBottom;\\n        case \\'topFree\\':\\n            const useHorizontallyFlippedTopTromino = rc(n, index + 2, \\'topBottomFree\\');\\n            const useHorizontalDominoAtTop = rc(n, index + 1, \\'bottomFree\\');\\n            return useHorizontallyFlippedTopTromino + useHorizontalDominoAtTop;\\n    }\\n}\\n```\n```javascript\\nfunction rc2 (n, index = 0, state = 0, memo = {}) {\\n    if (index >= n) return state === 0 && index === n ? 1 : 0;\\n    \\n    const memoKey = `${index},${state}`;\\n    if (memo[memoKey] !== undefined) return memo[memoKey];\\n    \\n    switch (state) {\\n        case 0:\\n            return memo[memoKey] = (rc2(n, index + 1, 0, memo) + rc2(n, index + 2, 0, memo) + rc2(n, index + 1, 1, memo) + rc2(n, index + 1, 2, memo)) % 1000000007;\\n        case 1:\\n            return memo[memoKey] = (rc2(n, index + 2, 0, memo) + rc2(n, index + 1, 2, memo)) % 1000000007;\\n        case 2:\\n            return memo[memoKey] = (rc2(n, index + 2, 0, memo) + rc2(n, index + 1, 1, memo)) % 1000000007;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1620764,
                "title": "c-easy-to-solve-visualized-image-and-explanations-beginner-friendly",
                "content": "# **Dynamic Thinking Approach**\\n\\n**Intuition:**\\nAfter reading the question we get a intuition of doing recursion and dp .Now those of you who got intuition as recursion you are not wrong but your code will be one of the most unoptimized code. So let\\'s discuss when to use a dp ,If the two case are confirmed in a problem then you can use dp\\n1. If it has overlapping sub problems \\n2. If optimizing the sub problems wll optimize the whole question\\nBoth the above the condition are satisfied in this question. So now let\\'s discuss the approach :)\\n\\n**Algorithm:**\\n1. Wheneve we put a domino or tromino we are either left out with a whole rectangle or with a rectangle + left alone square  [lonely doge]\\n2. So to fill out the whole rectangle the number of ways can be `i*2 `and to fill a lonely doge the number of ways is to fill a rectangle of size `i*2 + one square sticking out.`\\n3. Whenever we use a domino tile we are either left with a full rectangle of size i-1 or  with a full rectangle of size i-2 . This leads to formulation of domino that is *`Domino[i] = Domino[i-1] + Domino[1-2]`*\\n4. Now let\\'s think we put out a tromino first then we are left with lonely doge .so the size of that lonely doge is i-2 . Also tromino is non symmetric in shape so it has two orientaions which leads to 2(i-2).\\nThis makes our end conclusion for domino` Domino=Domino[i] = Domino[i-1] + Domino[1-2] + 2 * Tromino[i-2]`\\n5. Let\\'s continue with tromino i.e whenever we use it we are left alone with a lonely doge so to fill that we got two options\\n* put a domino leaving us all again with a left alone square again .This gives Tromino[i-1]\\n* The second option is put tromino aligning with lonely doge and completing them as a whole rectangle. A happy endng we all want .Btw this gives Domino[i-1]\\n\\n6.Thus to conclude this ,the formula will be `Tromino[i]=Tromino[i-1]+Domino[i-1]`\\n7.And now again ... ok you thought something is remaining, lol the problem is solved .KABOOM\\n\\n**Before starting with code let\\'s take a dry run[You can skip if you are confident :) ]**\\n![image](https://assets.leetcode.com/users/images/75039a8f-b7ac-404a-b753-3cd8e1160b03_1639105851.6693509.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/6ffd3b67-3a83-423d-97e0-0b3f3fa5d346_1639105853.825289.jpeg)\\nI have wrote torino instead of tromino in the above image so pardon me :(\\n\\n\\n**Code :-**\\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        //base case-1\\n        if (n < 3) return n;\\n        //given in the question that answer may be long\\n        int modulo = pow(10, 9) + 7;  \\n        \\n        vector<long> Domino(n+1, 0), Tromino(n+1, 0);\\n        //base case-2\\n        Domino[0] = 0,Domino[1] = 1, Domino[2] = 2;\\n        Tromino[0] = 0, Tromino[1] = 1, Tromino[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++) {\\n            Domino[i] = (Domino[i-1] + Domino[i-2] + 2*Tromino[i-2]) % modulo;\\n            Tromino[i] = (Tromino[i-1] + Domino[i-1]) % modulo;\\n        }\\n        \\n        return Domino[n];\\n    }\\n};\\n```\\n\\n\\n**If you have suggestions or doubts feel free to comment ;)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        //base case-1\\n        if (n < 3) return n;\\n        //given in the question that answer may be long\\n        int modulo = pow(10, 9) + 7;  \\n        \\n        vector<long> Domino(n+1, 0), Tromino(n+1, 0);\\n        //base case-2\\n        Domino[0] = 0,Domino[1] = 1, Domino[2] = 2;\\n        Tromino[0] = 0, Tromino[1] = 1, Tromino[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++) {\\n            Domino[i] = (Domino[i-1] + Domino[i-2] + 2*Tromino[i-2]) % modulo;\\n            Tromino[i] = (Tromino[i-1] + Domino[i-1]) % modulo;\\n        }\\n        \\n        return Domino[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944366,
                "title": "simple-java-solution-with-dynamic-programming-in-o-n-100-beats",
                "content": "\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n==1)\\n        return 1;\\n        else if(n==2)\\n        return 2;\\n      int mod = 1000000007;\\n\\n    int [] dp=new int[n+1];\\n\\n    dp[1]=1;\\n    dp[2]=2;\\n    dp[3]=5;\\n    for(int i =4;i<=n;i++){\\n        dp[i]=(2*dp[i-1]%mod+dp[i-3]%mod)%mod;\\n    }\\n    return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n==1)\\n        return 1;\\n        else if(n==2)\\n        return 2;\\n      int mod = 1000000007;\\n\\n    int [] dp=new int[n+1];\\n\\n    dp[1]=1;\\n    dp[2]=2;\\n    dp[3]=5;\\n    for(int i =4;i<=n;i++){\\n        dp[i]=(2*dp[i-1]%mod+dp[i-3]%mod)%mod;\\n    }\\n    return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944113,
                "title": "27ms-98-89-13-8mb-99-21-python-explained",
                "content": "# Intuition\\nFirst look at the numbers really good and long.\\nSearch patterns and the according offsets to reach our values...\\nLike sum, fibonacci etc.\\n|i | n | sum|off| \\n|--|--:|--:|-:|\\n1|1|1|+1\\n2|2|3|+2\\n3|5|8|+3\\n4|11|19|+5\\n5|24|43|+10\\n6|53|96|+21\\n7|117|213|+45\\n8|258|471|+98\\n9|569|1040|+215\\n10|1255|\\n\\nFirst this rather looks like powers of 2.\\nBut there are offsets growing irrationally like sums.\\n|n | 2^(i-1) | off|\\n|--|-:|-:|\\n1|1|+0\\n2|2|+0\\n5|4|+1\\n11|8|+3\\n24|16|+8\\n53|32|+21\\n117|64|+53\\n258|128|+130\\n\\nThen it looks like nextN=2*lastN.\\n|n | 2*(n-1) | off|\\n|--|-:|-:|\\n1   |2*0   |(+1)\\n2   |2*1   |(+0)\\n5   |2*2   |(+1)\\n11  |2*5   |(+1)\\n24  |2*11  |(+2)\\n53  |2*24   |+5\\n117 |2*53  |+11\\n258 |2*117 |+24\\n569 |2*258 |+53\\n1255|2*569|+117\\n\\nThis offsets looks really similar!\\n# Approach\\ndefaultcases for 1,2,3,4,5.\\nthen use this vars: a=5 b=11 c=24\\nand for each i up to n:\\n(a,b,c)->(b,c,a+c+c)\\na\\'=b \\nb\\'=c \\nc\\'=a+2c\\n\\nE.g. first defaults:\\n1\\n2\\n5\\n11\\n24\\nThen these jumps from 5,11,24:\\n|a|b|c|\\n|-|-|-|\\n11|24|**53**\\n24|53|**117**\\n53|117|**258**\\n117|258|**569**\\n258|569|**1255**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1: return 1\\n        if n == 2: return 2\\n        if n == 3: return 5\\n        if n == 4: return 11\\n        if n == 5: return 24\\n        a,b,c = 5,11,24 #[a,b,c] => [b,c,a+c+c] => [b,c]+[2*c+a]\\n        for i in range(6,n+1):\\n            a,b,c = b,c,2*c+a\\n        return c % (10**9+7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1: return 1\\n        if n == 2: return 2\\n        if n == 3: return 5\\n        if n == 4: return 11\\n        if n == 5: return 24\\n        a,b,c = 5,11,24 #[a,b,c] => [b,c,a+c+c] => [b,c]+[2*c+a]\\n        for i in range(6,n+1):\\n            a,b,c = b,c,2*c+a\\n        return c % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116534,
                "title": "python-easy-and-concise-solution",
                "content": "3 simple steps to solve this problem:\\n1. Decide use dynamic programming.\\n2. Find dp equation.\\n3. Find initilization.\\n\\n```A[i]``` the number of tiling a ```2*N-1``` board, ```B[i]``` the number of tiling a ```2*N``` board.\\nWe can find this regular as .\\n```\\nA[i] = B[i - 2] + A[i - 1]\\nB[i] = B[i - 1] + B[i - 2] + A[i - 1] * 2\\n```\\nI also initialize ```B[0] = B[1] = 1, A[0] = A[1] = 0```\\n\\nPython:\\n```\\ndef numTilings(self, N):\\n        A = [0] * (N + 1)\\n        B = [1, 1] + [0] * (N - 1)\\n        for i in range(2, N + 1):\\n            A[i] = (B[i - 2] + A[i - 1]) % int(1e9 + 7)\\n            B[i] = (B[i - 1] + B[i - 2] + A[i - 1] * 2) % int(1e9 + 7)\\n        return B[N]\\n```\\n\\nResult:\\n```\\nN =  0   1   2   3   4   5   6    7    8    9    10 ...\\nA = [0,  0,  1,  2,  4,  9, 20,  44,  97, 214,  472 ...\\nB = [1,  1,  2,  5, 11, 24, 53, 117, 258, 569, 1255 ...\\n```\\nThis is in fact a double recursive sequence.\\nThe code will be much simpler if you find out the regular for single recursive sequence.\\nFind here: https://leetcode.com/problems/domino-and-tromino-tiling/discuss/116544/O(N)-time-and-O(1)-space-C++JavaPython",
                "solutionTags": [],
                "code": "```A[i]```\n```2*N-1```\n```B[i]```\n```2*N```\n```\\nA[i] = B[i - 2] + A[i - 1]\\nB[i] = B[i - 1] + B[i - 2] + A[i - 1] * 2\\n```\n```B[0] = B[1] = 1, A[0] = A[1] = 0```\n```\\ndef numTilings(self, N):\\n        A = [0] * (N + 1)\\n        B = [1, 1] + [0] * (N - 1)\\n        for i in range(2, N + 1):\\n            A[i] = (B[i - 2] + A[i - 1]) % int(1e9 + 7)\\n            B[i] = (B[i - 1] + B[i - 2] + A[i - 1] * 2) % int(1e9 + 7)\\n        return B[N]\\n```\n```\\nN =  0   1   2   3   4   5   6    7    8    9    10 ...\\nA = [0,  0,  1,  2,  4,  9, 20,  44,  97, 214,  472 ...\\nB = [1,  1,  2,  5, 11, 24, 53, 117, 258, 569, 1255 ...\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2944191,
                "title": "complete-explanation-with-images-easy-to-understand",
                "content": "#  Consider the following fix width configurations \\uD83D\\uDC47\\n![image](https://assets.leetcode.com/users/images/314ad41a-9604-403b-96ff-2ebafa73808a_1671853682.579165.jpeg)\\n//=======================================================================================================================\\n\\n\\n# FINAL SOLUTION \\uD83D\\uDC47 [FIX-WIDTH CONFIGURATIONS APPENDED WITH (WIDTH - FIXWIDTH) WAYS]\\n![image](https://assets.leetcode.com/users/images/c9df3c5b-53f1-4c43-acbe-335b597b41b1_1671853694.6105545.jpeg)\\n![image](https://assets.leetcode.com/users/images/b209acca-df4b-4704-851a-c7d7e2e95362_1671853700.8129582.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) \\n    {\\n        vector<long long>dp(n + 1);\\n        dp[1] = 1; dp[0] = 1;\\n        int MOD = 1000000007;\\n        for (int width = 2; width <= n; width++)\\n        {\\n            long long totalWays = 0;\\n            for (int fixWidth = 1; fixWidth <= width; fixWidth++)\\n            {\\n                int leftWidth = width - fixWidth;\\n                long long ways = dp[leftWidth]; \\n                if (fixWidth > 2) ways = (ways * 2) % MOD; //because from fixWidth > 2, two configurations exist for each case\\n                //fixWidthConfiguration appended to all dp[leftWidth] configurations\\n                \\n                totalWays = (totalWays + ways) % MOD;\\n            }\\n            dp[width] = totalWays;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) \\n    {\\n        vector<long long>dp(n + 1);\\n        dp[1] = 1; dp[0] = 1;\\n        int MOD = 1000000007;\\n        for (int width = 2; width <= n; width++)\\n        {\\n            long long totalWays = 0;\\n            for (int fixWidth = 1; fixWidth <= width; fixWidth++)\\n            {\\n                int leftWidth = width - fixWidth;\\n                long long ways = dp[leftWidth]; \\n                if (fixWidth > 2) ways = (ways * 2) % MOD; //because from fixWidth > 2, two configurations exist for each case\\n                //fixWidthConfiguration appended to all dp[leftWidth] configurations\\n                \\n                totalWays = (totalWays + ways) % MOD;\\n            }\\n            dp[width] = totalWays;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620750,
                "title": "c-recursive-memoization",
                "content": "```\\nclass Solution {\\n    private:\\n    int MOD = 1e9+7;\\n    private :\\n    int helper(int firstRow, int secondRow, vector<vector<int>> &dp)\\n    {\\n        if(firstRow == 0 && secondRow == 0) \\n            return 1;\\n        \\n        if(firstRow < 0 || secondRow < 0)\\n            return 0;\\n        \\n        if(dp[firstRow][secondRow] != -1) \\n            return dp[firstRow][secondRow];\\n        \\n        int res;\\n        \\n        // 4 cases\\n        // 1) one vertical Domino (1 dot at firstRow, 1 dot at secondRow)\\n        // 2) one horizontal Domino (either 2 dots at firstRow or 2 dots at secondRow, we have to consider both)\\n        // 3) Tromino (2 dots at firstRow & 1 dot at secondRow)\\n        // 4) Inverted Tromino (1 dot at firstRow & 2 dots at secondRow)\\n        if(firstRow == secondRow)\\n        {\\n                  // one vertical Domino\\n            res = ((((helper(firstRow-1, secondRow-1, dp) % MOD + \\n                    \\n                    // one horizontal Domino (consider both first and second row)\\n                    helper(firstRow-2, secondRow-2, dp) % MOD) % MOD + \\n                   \\n                    // Tromino\\n                    helper(firstRow-2, secondRow-1, dp) % MOD) % MOD +\\n                \\n                    // Inverted Tromino\\n                    helper(firstRow-1, secondRow-2, dp) % MOD) % MOD );\\n        }\\n        \\n        // If dots in firstRow > secondRow, then 2 cases (we have to reduce the dots)\\n        // 1) at firstRow, we have to add horizontal Domino (so it will reduce 2 dots)\\n        // 2) Add Tromino (so, it will reduce 2 dots at firstRow, 1 dots at secondRow)\\n        else if(firstRow > secondRow)\\n        {\\n                  // Add horizontal domino at firstRow\\n            res = ((helper(firstRow-2, secondRow, dp) % MOD + \\n                   \\n                    // Add Tromino\\n                    helper(firstRow-2, secondRow-1, dp) % MOD) % MOD);\\n        }\\n        \\n        // If dots in firstRow < secondRow, then 2 cases\\n        // 1) Add Inverted Tromino (so, it will reduce 1 dot at firstRow, 2 dots at secondRow)\\n        // 2) At secondRow, we have to add horizontal Domino (so it will reduce 2 dots)\\n        else if(firstRow < secondRow)\\n        {\\n                  // Add horizontal domino at secondRow\\n            res = ((helper(firstRow, secondRow-2, dp) % MOD + \\n                   \\n                    // Add Inverted Tromino\\n                    helper(firstRow-1, secondRow-2, dp) % MOD) % MOD);\\n        }\\n        \\n        return dp[firstRow][secondRow] = res;\\n    }\\n    \\npublic:\\n    int numTilings(int n) {\\n        \\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        \\n        // first row, second row (because, we have 2xN board, so 2 rows, N column)\\n        return helper(n, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int MOD = 1e9+7;\\n    private :\\n    int helper(int firstRow, int secondRow, vector<vector<int>> &dp)\\n    {\\n        if(firstRow == 0 && secondRow == 0) \\n            return 1;\\n        \\n        if(firstRow < 0 || secondRow < 0)\\n            return 0;\\n        \\n        if(dp[firstRow][secondRow] != -1) \\n            return dp[firstRow][secondRow];\\n        \\n        int res;\\n        \\n        // 4 cases\\n        // 1) one vertical Domino (1 dot at firstRow, 1 dot at secondRow)\\n        // 2) one horizontal Domino (either 2 dots at firstRow or 2 dots at secondRow, we have to consider both)\\n        // 3) Tromino (2 dots at firstRow & 1 dot at secondRow)\\n        // 4) Inverted Tromino (1 dot at firstRow & 2 dots at secondRow)\\n        if(firstRow == secondRow)\\n        {\\n                  // one vertical Domino\\n            res = ((((helper(firstRow-1, secondRow-1, dp) % MOD + \\n                    \\n                    // one horizontal Domino (consider both first and second row)\\n                    helper(firstRow-2, secondRow-2, dp) % MOD) % MOD + \\n                   \\n                    // Tromino\\n                    helper(firstRow-2, secondRow-1, dp) % MOD) % MOD +\\n                \\n                    // Inverted Tromino\\n                    helper(firstRow-1, secondRow-2, dp) % MOD) % MOD );\\n        }\\n        \\n        // If dots in firstRow > secondRow, then 2 cases (we have to reduce the dots)\\n        // 1) at firstRow, we have to add horizontal Domino (so it will reduce 2 dots)\\n        // 2) Add Tromino (so, it will reduce 2 dots at firstRow, 1 dots at secondRow)\\n        else if(firstRow > secondRow)\\n        {\\n                  // Add horizontal domino at firstRow\\n            res = ((helper(firstRow-2, secondRow, dp) % MOD + \\n                   \\n                    // Add Tromino\\n                    helper(firstRow-2, secondRow-1, dp) % MOD) % MOD);\\n        }\\n        \\n        // If dots in firstRow < secondRow, then 2 cases\\n        // 1) Add Inverted Tromino (so, it will reduce 1 dot at firstRow, 2 dots at secondRow)\\n        // 2) At secondRow, we have to add horizontal Domino (so it will reduce 2 dots)\\n        else if(firstRow < secondRow)\\n        {\\n                  // Add horizontal domino at secondRow\\n            res = ((helper(firstRow, secondRow-2, dp) % MOD + \\n                   \\n                    // Add Inverted Tromino\\n                    helper(firstRow-1, secondRow-2, dp) % MOD) % MOD);\\n        }\\n        \\n        return dp[firstRow][secondRow] = res;\\n    }\\n    \\npublic:\\n    int numTilings(int n) {\\n        \\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        \\n        // first row, second row (because, we have 2xN board, so 2 rows, N column)\\n        return helper(n, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620867,
                "title": "java-explanation-by-image-visualization-dp",
                "content": "Lets Fill for some small test cases :\\n---\\n|![image](https://assets.leetcode.com/users/images/b910c16e-be2a-4f26-9f46-279c98c3d093_1639110091.7002633.jpeg)|\\n_\\n\\n\\n\\n\\n## Taking out some insight from this : \\n|![image](https://assets.leetcode.com/users/images/89d403d4-b09a-4bbf-b0dc-de2e2155043d_1639110183.932951.jpeg)   |\\n-\\n|   |\\n\\n---\\n---\\n\\n### Why we add 2*p(2)-\\nsee for n=2 , 2*n size grid , there is two ways to partial fill it \\n| ![image](https://assets.leetcode.com/users/images/568b3823-9d75-4a68-ba71-817e7809656e_1639110857.8280482.jpeg) |\\n-\\n So finally  Our equation Comes out :\\n*\\t **f(k)=f(k\\u22121)+f(k\\u22122)+2\\u2217p(k\\u22121)**\\n*\\t**p(k) = p(k-1) + f(k-2)p(k)=p(k\\u22121)+f(k\\u22122)**\\n\\n### Code : \\n---\\n```\\n public int numTilings(int n) {\\n        int MOD  =  1_000_000_000+7;\\n       \\n        if(n<=2) return n;\\n        long[]f =  new long[n+1];//n+1 size because , ans is at n index \\n        long[]p =  new long[n+1];\\n        \\n        // base case \\n        f[1] =1;f[2]=2;\\n        p[2] = 1;                        \\n\\t\\t\\n        for(int i=3;i<n+1;i++){            \\n            f[i] = ( f[i-1]+f[i-2]+2*p[i-1])%MOD;\\n            p[i] =  (p[i-1]+f[i-2])%MOD; // for n=3, 2 col wil contribute partial fill and 1 column contribute fully filled             \\n        }        \\n        return (int)f[n];        \\n    }\\n   \\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int numTilings(int n) {\\n        int MOD  =  1_000_000_000+7;\\n       \\n        if(n<=2) return n;\\n        long[]f =  new long[n+1];//n+1 size because , ans is at n index \\n        long[]p =  new long[n+1];\\n        \\n        // base case \\n        f[1] =1;f[2]=2;\\n        p[2] = 1;                        \\n\\t\\t\\n        for(int i=3;i<n+1;i++){            \\n            f[i] = ( f[i-1]+f[i-2]+2*p[i-1])%MOD;\\n            p[i] =  (p[i-1]+f[i-2])%MOD; // for n=3, 2 col wil contribute partial fill and 1 column contribute fully filled             \\n        }        \\n        return (int)f[n];        \\n    }\\n   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1621074,
                "title": "python-2-solutions-dp-and-matrix-power-explained",
                "content": "#### Solution 1\\nAs any problem with tiling, here we need to write down recurrent equations. Let `Fn` be number of tilings for `(n+1)\\xD72` board and `Gn` be number of tilings for `(n+1)\\xD72` board with one cell added. Then it can be shown that `Fn=F_{n\\u22121}+F_{n\\u22122}+2\\u22C5G_{n\\u22122}` and Gn=G_{n\\u22121}+F_{n\\u22121} and `F0=1,F1=2,G0=1,G1=2.`\\n\\n#### Complexity\\nTime and space complexity will be `O(n)`.\\n\\nCode\\n```python\\nclass Solution:\\n    def numTilings(self, N):\\n        M = 10**9 + 7\\n        if N <= 2: return N\\n        F = [1, 2] + [0]*(N-2)\\n        G = [1, 2] + [0]*(N-2)\\n        for i in range(2, N):\\n            F[i] = (F[i-1] + F[i-2] + 2*G[i-2]) % M\\n            G[i] = (G[i-1] + F[i-1]) % M\\n            \\n        return F[-1]\\n```\\n\\n#### Solution 2\\nMoreover it can be shown, that `Fn=2*F_{n\\u22121}+F_{n\\u22123}`, so it can be written using only `O(1)` memory. Also, as for any recurrent equation, it can be solved in `O(log n) * Q^3`, if we evaluate power of the transition matrix `A = [[2, 0, 1], [1, 0, 0], [0, 1, 0]]`, where `Q = 3` is size of this matrix. We need to evaluate `b * A^n`, where `b = [0, 1, 1]` are starting positions.\\n\\n#### Complexity\\nIt is `O(log n) * Q^3`, where `Q = 3`. Space is `O(Q^3)`.\\n\\n#### Code\\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def numTilings(self, N):\\n        def power(M, n, MOD):\\n            result = np.eye(len(M), dtype = np.int64)\\n            while n > 0:\\n                if n%2: result = np.dot(M, result) % MOD\\n                M = np.dot(M, M) % MOD\\n                n //= 2\\n            return result\\n        \\n        m = power([[2,0,1],[1,0,0],[0,1,0]], N-1, 10**9 + 7)\\n        return (m[0][0] + m[0][1]) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def numTilings(self, N):\\n        M = 10**9 + 7\\n        if N <= 2: return N\\n        F = [1, 2] + [0]*(N-2)\\n        G = [1, 2] + [0]*(N-2)\\n        for i in range(2, N):\\n            F[i] = (F[i-1] + F[i-2] + 2*G[i-2]) % M\\n            G[i] = (G[i-1] + F[i-1]) % M\\n            \\n        return F[-1]\\n```\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def numTilings(self, N):\\n        def power(M, n, MOD):\\n            result = np.eye(len(M), dtype = np.int64)\\n            while n > 0:\\n                if n%2: result = np.dot(M, result) % MOD\\n                M = np.dot(M, M) % MOD\\n                n //= 2\\n            return result\\n        \\n        m = power([[2,0,1],[1,0,0],[0,1,0]], N-1, 10**9 + 7)\\n        return (m[0][0] + m[0][1]) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288662,
                "title": "java-o-n-dp-solution-with-really-simple-math",
                "content": "Assume before column n, every cell is filled. In column n, there are two states: both cells filled and only one cell filled. \\nFrom there we have:\\nf(n) as the number of ways to reach the state that both cells are filled in column n.\\ng(n) as the number of ways to reach the state that one cell is filled in column n.\\nWritten as:\\n```\\n1. \\tf(n) = f(n - 1) + f(n - 2) + g(n - 1)\\n2. \\tg(n) = g(n - 1) + 2 * f(n - 2)\\n\\nAccording to formula 1:\\nf(n) - f(n - 1) = [f(n - 1) + f(n - 2) + g(n - 1)] - [f(n - 2) + f(n - 3) + g(n - 2)]\\n=> f(n) = 2 * f(n - 1) - f(n - 3) + g(n - 1) - g(n - 2)\\n\\nBring in formula 2, we get the final formula: f(n) = 2 * f(n - 1) + f(n - 3)\\n```\\nExplained in picture:\\n![image](https://assets.leetcode.com/users/wbowei2008/image_1557300446.png)\\n```\\nJava:\\nclass Solution {\\n    public int numTilings(int N) {\\n        if(N == 1) return 1;\\n        else if(N == 2 ) return 2;\\n        int mod = 1000000007;\\n\\t\\tint[] f = new int[N + 1];\\n        \\n        f[1] = 1;\\n        f[2] = 2;\\n        f[3] = 5;\\n        for(int i = 4; i <= N; i++) {\\n            f[i] = 2 * f[i - 1] % mod + f[i - 3] % mod;\\n            f[i] %= mod;\\n        }\\n        return (int) f[N];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1. \\tf(n) = f(n - 1) + f(n - 2) + g(n - 1)\\n2. \\tg(n) = g(n - 1) + 2 * f(n - 2)\\n\\nAccording to formula 1:\\nf(n) - f(n - 1) = [f(n - 1) + f(n - 2) + g(n - 1)] - [f(n - 2) + f(n - 3) + g(n - 2)]\\n=> f(n) = 2 * f(n - 1) - f(n - 3) + g(n - 1) - g(n - 2)\\n\\nBring in formula 2, we get the final formula: f(n) = 2 * f(n - 1) + f(n - 3)\\n```\n```\\nJava:\\nclass Solution {\\n    public int numTilings(int N) {\\n        if(N == 1) return 1;\\n        else if(N == 2 ) return 2;\\n        int mod = 1000000007;\\n\\t\\tint[] f = new int[N + 1];\\n        \\n        f[1] = 1;\\n        f[2] = 2;\\n        f[3] = 5;\\n        for(int i = 4; i <= N; i++) {\\n            f[i] = 2 * f[i - 1] % mod + f[i - 3] % mod;\\n            f[i] %= mod;\\n        }\\n        return (int) f[N];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946029,
                "title": "c-easy-to-understand-solution-beats-100",
                "content": "# Approach\\nTested on few testcases\\n\\nn = 1 : ans = 1\\nn = 2 : ans = 2\\nn = 3 : ans = 5\\nn = 4 : ans = 11\\nn = 5 : ans = 24\\n\\nConsidering a pattern formed with current **\"n\"** and previously calculated **\"n\"** :\\n`ans[n] = 2 * ans[n-1] + ans[n-3]`\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define md 1000000007\\n    int numTilings(int n) {\\n        vector<long long> v(1001, 0);\\n\\n        v[1] = 1;\\n        v[2] = 2;\\n        v[3] = 5;\\n        \\n        for(int i = 4; i <= n; i++)\\n            v[i] = (2 * v[i-1] + v[i-3]) % md;\\n        \\n    return v[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define md 1000000007\\n    int numTilings(int n) {\\n        vector<long long> v(1001, 0);\\n\\n        v[1] = 1;\\n        v[2] = 2;\\n        v[3] = 5;\\n        \\n        for(int i = 4; i <= n; i++)\\n            v[i] = (2 * v[i-1] + v[i-3]) % md;\\n        \\n    return v[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621160,
                "title": "explanation-with-image-0ms-100-faster",
                "content": "**Idea?**\\n* *Dynamic Programming*\\n* **dp[i] = number of ways to form 2 x i board with gives tiles.**\\n* Suppose, we had already calculated the dp[j] for all j belongs to [1,i-1], Now how to get dp[i] ?\\n* Let\\'s look out certain domino we can place at \\'i\\'th position.\\n\\n![image](https://assets.leetcode.com/users/images/0d9a6e41-89e5-4a89-ba4c-92af0f4a9527_1639123044.4028025.png)\\n\\n![image](https://assets.leetcode.com/users/images/53cb9214-7591-45db-b6cc-6c1eb556c92c_1639123069.2442987.png)\\n\\n![image](https://assets.leetcode.com/users/images/36e79f50-4eb3-4abc-b0fd-f72004a08792_1639123084.2648911.png)\\n\\n**Generating dp relation:-**\\n\\n![image](https://assets.leetcode.com/users/images/072039ac-2f71-43c2-a2a7-6ea930e4bbfc_1639132061.445384.png)\\n\\n\\n**Note:- if n==0, we must return 0 as our answer. Here dp[0] = 1 for calculation.**\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define MOD 1000000007\\n    int numTilings(int n) {\\n        vector<ll> dp(n+1);\\n        iota(dp.begin(),dp.end(),0);\\n        dp[0] = 1;\\n        for(int i=3;i<=n;i++)\\n            dp[i] = (dp[i-1]+dp[i-1]+dp[i-3])%MOD;\\n        return dp.back();\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/76c4c03c-ad60-4fd8-9d1e-3a3983d2129a_1639123137.3745196.png)\\n\\n**Don\\'t forget to Upvote!**\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define MOD 1000000007\\n    int numTilings(int n) {\\n        vector<ll> dp(n+1);\\n        iota(dp.begin(),dp.end(),0);\\n        dp[0] = 1;\\n        for(int i=3;i<=n;i++)\\n            dp[i] = (dp[i-1]+dp[i-1]+dp[i-3])%MOD;\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762470,
                "title": "neat-explanation-c-dp-solution",
                "content": "```\\nlet\\'s focus on the shape of the last column it can be\\nx  (A)                 or          xx   (B)               or       x  (C)\\nx                                  x                               xx\\n\\nif we want to add another column we can get complete figure by using\\nx  (for 1st configuration)                    x  (for 2nd)                            xx  (for 3rd)\\nx                                            xx                                        x \\n\\nso  ans for A[i] =  getting   x   in the last column\\n\\t\\t\\t\\t\\t\\t      x\\t\\t\\t\\nB[i]     =     getting     x         in the last column\\n\\t\\t\\t\\t\\t\\t   xx\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \\n \\n C[i] =   getting   xx   in the last column\\n\\t\\t\\t        x\\n\\nA[i]   =    A[i-1]( adding   x  )   +            A[i-2](adding two xx )     +  ( B[i-1] + C[i-1]) (adding    xx  or   x )\\n\\t\\t\\t\\t\\t\\t     x\\t\\t\\t                           xx                                         x      xx\\nB[i]    =   A[i-2](adding  x   )       +           B[i-1](adding      x              +     xx           =       xxx)  \\n\\t\\t\\t\\t\\t\\t   xx                                         xx                                        xx              \\n\\n\\nC[i] =     A[i-2]       +            C[i-1] \\nbut B and C are numerically same so we can use one array only\\n\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n      if(N <= 2)return N;\\n      vector<long int>A(N+1,0);\\n      vector<long int>B(N+1,0);\\n        A[1] = 1;\\n        A[2] = 2;\\n        B[1] = 0;\\n        B[2] = 1;\\n        int mod = 1000000007;\\n        for(int i=3;i<=N;i++)\\n        {\\n            A[i] = (A[i-1]+A[i-2]+ 2*B[i-1])%mod;\\n            B[i] = (B[i-1] + A[i-2])%mod;\\n        }\\n        \\n        return A[N];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet\\'s focus on the shape of the last column it can be\\nx  (A)                 or          xx   (B)               or       x  (C)\\nx                                  x                               xx\\n\\nif we want to add another column we can get complete figure by using\\nx  (for 1st configuration)                    x  (for 2nd)                            xx  (for 3rd)\\nx                                            xx                                        x \\n\\nso  ans for A[i] =  getting   x   in the last column\\n\\t\\t\\t\\t\\t\\t      x\\t\\t\\t\\nB[i]     =     getting     x         in the last column\\n\\t\\t\\t\\t\\t\\t   xx\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \\n \\n C[i] =   getting   xx   in the last column\\n\\t\\t\\t        x\\n\\nA[i]   =    A[i-1]( adding   x  )   +            A[i-2](adding two xx )     +  ( B[i-1] + C[i-1]) (adding    xx  or   x )\\n\\t\\t\\t\\t\\t\\t     x\\t\\t\\t                           xx                                         x      xx\\nB[i]    =   A[i-2](adding  x   )       +           B[i-1](adding      x              +     xx           =       xxx)  \\n\\t\\t\\t\\t\\t\\t   xx                                         xx                                        xx              \\n\\n\\nC[i] =     A[i-2]       +            C[i-1] \\nbut B and C are numerically same so we can use one array only\\n\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n      if(N <= 2)return N;\\n      vector<long int>A(N+1,0);\\n      vector<long int>B(N+1,0);\\n        A[1] = 1;\\n        A[2] = 2;\\n        B[1] = 0;\\n        B[2] = 1;\\n        int mod = 1000000007;\\n        for(int i=3;i<=N;i++)\\n        {\\n            A[i] = (A[i-1]+A[i-2]+ 2*B[i-1])%mod;\\n            B[i] = (B[i-1] + A[i-2])%mod;\\n        }\\n        \\n        return A[N];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132473,
                "title": "c-dp-faster-than-100-00-explained-with-image",
                "content": "It was a good problem, probably on the harder side of the `Medium` problems. For guys finding it difficult to approach, I would suggest to solve Domino Tiling (not available on leetcode) first. Here I tried to think along the lines of the forming some sort of recurrence relation and the result was pretty satisfying considering the time complexity I obtained. \\n\\n**Image: for better understanding**\\n![image](https://assets.leetcode.com/users/images/c4af608c-c80e-4c1d-b9e4-769ad1fb8e23_1654805144.7800725.jpeg)\\n\\n\\n**Thinking Process:**\\nTo start off, consider establishing some base cases. For n=1, the number of ways would be 1 and for n=2, the number of ways would be 2. (that much is obvious). For n=0, the number of ways would be 1 and for negative integers, it can be assumed to be 0.\\nNow, If we want to find out the number of ways for for n=3, we can do it in a pretty intuitive way. All we need to do is attach a vertical domino at the end of all the different arrangements obtained for n=2 which would be 2. Then we can attach 2 horizontal bars at the end of all the arrangements obtained for n=1 which would be 1. And finally, 2 new patterns will be obtained if we consider the interlocking of two trominoes (which btw is only possible for n>=3). Hence, total no. of arrangements would be 2+1+2 = 5 which is indeed correct.\\nSimilarly, for n=4, we can attach a vertical domino at the end of all the different arrangements obtained for n=3 which would be 5. Then we can attach 2 horizontal bars at the end of all the arrangements obtained for n=2 which would be 2. Then we can attach 2 interlocking trominoes(obtained initially at n=3) at the end of all the arrangements obtained for n=1 which would be 2. And finally, 2 new patterns will be obtained as shown in the figure.\\n\\nHere, we start to see a pattern here.For any n, first we attach single vertical domino (which was initially obtained at n=1) with the arrangements obtained at n-1. then we attach two horizontal dominos(which was initially obtained at n=2) with the arrangements obtained at n-2. Then we attach the 2 new patterns obtained at n=3 with the with the arrangements obtained at n-3 and so on.\\n\\nAnd, it we can see that every n>=3 creates two entirely new patterns. Processing all of this, we can generate a recurrence relation which goes as follows:\\n\\ndp[n] = dp[n-1] + dp[n-2] + 2*dp[n-3] + 2*dp[n-4] + ................. + 2*dp[0].\\n\\nNow, this is a correct recurrence relation, but we can do better.\\nSubstituting n for n-1, in the above relation, we obtain:\\n\\ndp[n-1] = dp[n-2] + dp[n-3] + 2*dp[n-4] + 2*dp[n-5] + ................. + 2*dp[0] + 2*dp[-1].\\n\\nWe already assumed the answer to the negative integers to be 0. Hence it can be removed. Solving  both equation we obtain:\\n\\ndp[n] = 2*dp[i-3] + dp[i-3]\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(n==3)\\n            return 5;\\n        if(n==4)\\n            return 11;\\n        \\n        vector<unsigned int> dp(n+1,0);\\n        \\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        dp[4] = 11;\\n        \\n        \\n        for(int i=5; i<=n; ++i) {\\n            dp[i] = (2*dp[i-1] +dp[i-3]) % 1000000007;\\n        }\\n        \\n        return dp[n];\\n        \\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/63c5e6af-fcb3-4095-a085-4e0fd6650f5f_1654806632.3793948.png)\\n\\n\\nIn this way we can obtain a time complexity of O(n).\\nPlease upvote if my solution was of any help.\\nP.S.: Comment for any query.\\nHave a great day ;)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(n==3)\\n            return 5;\\n        if(n==4)\\n            return 11;\\n        \\n        vector<unsigned int> dp(n+1,0);\\n        \\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        dp[4] = 11;\\n        \\n        \\n        for(int i=5; i<=n; ++i) {\\n            dp[i] = (2*dp[i-1] +dp[i-3]) % 1000000007;\\n        }\\n        \\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116622,
                "title": "o-logn-time-o-1-space-linear-algebraic-algorithm-in-python",
                "content": "```\nimport numpy as np\nclass Solution(object):\n    def numTilings(self, n):\n        if n <= 1:\n            return 1\n        elif n == 2: \n            return 2\n        x = np.array([2,1,1],dtype=np.int64)\n        A = np.array([[2,1,1],[3,1,1],[4,2,1]],dtype=np.int64)\n        y1 = np.array([1,1,2],dtype=np.int64)\n        y2 = np.array([2,3,4],dtype=np.int64)\n        if n%2 == 1:\n            k = (n-3)/2\n            y = y1\n        else: \n            k = (n-4)/2\n            y = y2\n        xA = x\n        while k>0:\n            if k%2 == 1:\n                xA = xA.dot(A)%1000000007\n            k /= 2\n            A = A.dot(A)%1000000007\n        return int(xA.dot(y)%1000000007)\n```\nThe rationale of this algorithm is based on the following observation:\nWe first define ```T(n)``` as the number of different tilings when the area to be covered is ```2 x n```. \nFurthermore, if we put a ```2 x 1```  domino, then the area to be covered is ```2 x (n-1)``` left; \nif we put a ```1 x 2``` domino, then we need to align another ```1 x 2``` domino with the previous one so that the area to be covered remains a rectangular ```2 x (n-2)```. Considering all possible first picks, we can expand ```T(n)``` into\n![image](https://s3-lc-upload.s3.amazonaws.com/users/yinghaotaiwan/image_1519622531.png)\nDefine the coefficients ```[a1, b1, c1]```, which is initiated as```[1, 1, 2]```, we have\n![image](https://s3-lc-upload.s3.amazonaws.com/users/yinghaotaiwan/image_1519622634.png)\nBy expanding ```T(n)```, we can obtained the following relationships,\n![image](https://s3-lc-upload.s3.amazonaws.com/users/yinghaotaiwan/image_1519622702.png)\nObviously, the ```T(n)``` can be computed by the following algorithm in ```O(n)``` time:\n```\ndef T(n):\n\ta,b,c = 1,0,0\n\tif n <= 1:\n\t\treturn 1\n\telif n == 2:\n\t\treturn 2\n\tfor i in xrange(n-2):\n\t\ta, b, c = a+b, a+c, 2*a+c\n\treturn 2*a + b + c\n```\nAfter some operations, these equations can be rewritten as\n![image](https://s3-lc-upload.s3.amazonaws.com/users/yinghaotaiwan/image_1519622826.png)\nwhich is similar to the recursive form of ```T(n)```. It implies that\n![image](https://s3-lc-upload.s3.amazonaws.com/users/yinghaotaiwan/image_1519624128.png)\nTherefore, ```T(n)``` can be represented as the following closed form: when ```n > 2```, ![image](https://s3-lc-upload.s3.amazonaws.com/users/yinghaotaiwan/image_1519624393.png)\nThis results in an ```O(logn)``` algorithm.\n\n\nThe bottleneck of this algorithm is the computation of ``` A^{k-1} ```, which costs ```O(logn)``` there. If there is better way to solve this problem, maybe the computional complexity can be reduced.\n(I have tried ```numpy.linalg.eig```, but it didn't work)",
                "solutionTags": [],
                "code": "```\nimport numpy as np\nclass Solution(object):\n    def numTilings(self, n):\n        if n <= 1:\n            return 1\n        elif n == 2: \n            return 2\n        x = np.array([2,1,1],dtype=np.int64)\n        A = np.array([[2,1,1],[3,1,1],[4,2,1]],dtype=np.int64)\n        y1 = np.array([1,1,2],dtype=np.int64)\n        y2 = np.array([2,3,4],dtype=np.int64)\n        if n%2 == 1:\n            k = (n-3)/2\n            y = y1\n        else: \n            k = (n-4)/2\n            y = y2\n        xA = x\n        while k>0:\n            if k%2 == 1:\n                xA = xA.dot(A)%1000000007\n            k /= 2\n            A = A.dot(A)%1000000007\n        return int(xA.dot(y)%1000000007)\n```\n```T(n)```\n```2 x n```\n```2 x 1```\n```2 x (n-1)```\n```1 x 2```\n```1 x 2```\n```2 x (n-2)```\n```T(n)```\n```[a1, b1, c1]```\n```[1, 1, 2]```\n```T(n)```\n```T(n)```\n```O(n)```\n```\ndef T(n):\n\ta,b,c = 1,0,0\n\tif n <= 1:\n\t\treturn 1\n\telif n == 2:\n\t\treturn 2\n\tfor i in xrange(n-2):\n\t\ta, b, c = a+b, a+c, 2*a+c\n\treturn 2*a + b + c\n```\n```T(n)```\n```T(n)```\n```n > 2```\n```O(logn)```\n``` A^{k-1} ```\n```O(logn)```\n```numpy.linalg.eig```",
                "codeTag": "Java"
            },
            {
                "id": 215670,
                "title": "java-o-n-math-proof-on-paper",
                "content": "```\\nclass Solution {\\n    \\n    public int numTilings(int N) {\\n        if (N <= 0) return 0;\\n        if (N == 1) return 1;\\n        if (N == 2) return 2;\\n        long[] dp = new long[N + 1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        int mod = (int) 1e9 + 7;\\n        for (int i = 3; i <= N; i++) {\\n            dp[i] = (2 * dp[i - 1] + dp[i- 3]) % mod;\\n        }\\n        return (int) dp[N];\\n    }\\n    \\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/cheng_coding_attack/image_1546972782.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int numTilings(int N) {\\n        if (N <= 0) return 0;\\n        if (N == 1) return 1;\\n        if (N == 2) return 2;\\n        long[] dp = new long[N + 1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        int mod = (int) 1e9 + 7;\\n        for (int i = 3; i <= N; i++) {\\n            dp[i] = (2 * dp[i - 1] + dp[i- 3]) % mod;\\n        }\\n        return (int) dp[N];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116513,
                "title": "java-solution-dp",
                "content": "Reference: https://cs.stackexchange.com/questions/66658/domino-and-tromino-combined-tiling\n```\nclass Solution {\n    private static final int MOD = 1000000007;\n    public int numTilings(int N) {\n        if (N == 1) return 1;\n        if (N == 2) return 2;\n        long[] dp = new long[N + 1];\n        dp[0] = 1; dp[1] = 1; dp[2] = 2;\n        for (int i = 3; i <= N; i++) {\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % MOD;\n        }\n        return (int) dp[N];\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    private static final int MOD = 1000000007;\n    public int numTilings(int N) {\n        if (N == 1) return 1;\n        if (N == 2) return 2;\n        long[] dp = new long[N + 1];\n        dp[0] = 1; dp[1] = 1; dp[2] = 2;\n        for (int i = 3; i <= N; i++) {\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % MOD;\n        }\n        return (int) dp[N];\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944361,
                "title": "python-3-4-lines-recurrence-relation-w-example-and-brief-comments-t-m-99-5-86",
                "content": "A few drawings on scratch paper will convince you that there are two states because of the two types of tiles. A little tougher task is determining the recurence relationship and initial counts.\\n```\\nclass Solution:\\n    def numTilings(self,n:int)->int:                            # Example:  n = 5\\n\\n        prev, curr, tri = 1, 1, 0                               #  n   prev  curr  tri \\n                                                                # ---  ----  ----  ----\\n        for i in range(1,n):                                    #   1     1     1     0\\n                                                                #   2     1     2     1\\n            prev, curr, tri = curr, prev+curr+2*tri, prev+tri   #   3     2     5     2\\n                                                                #   4     5    11     4\\n        return curr%1000000007                                  #   5    11    24     9\\n                                                                #              / \\n                                                                #           return\\n```\\n[https://leetcode.com/problems/domino-and-tromino-tiling/submissions/864496961/](http://)\\n\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(1).\\n\\'\\'\\'",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self,n:int)->int:                            # Example:  n = 5\\n\\n        prev, curr, tri = 1, 1, 0                               #  n   prev  curr  tri \\n                                                                # ---  ----  ----  ----\\n        for i in range(1,n):                                    #   1     1     1     0\\n                                                                #   2     1     2     1\\n            prev, curr, tri = curr, prev+curr+2*tri, prev+tri   #   3     2     5     2\\n                                                                #   4     5    11     4\\n        return curr%1000000007                                  #   5    11    24     9\\n                                                                #              / \\n                                                                #           return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620640,
                "title": "python-dynamic-programming-in-4-lines-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        full_0, full_1, incomp_1 = 1, 2, 2\\n        for i in range(2, n):\\n            full_0, full_1, incomp_1 = full_1, full_0 + full_1 + incomp_1, 2 * full_0 + incomp_1\\n        return full_1 % (10 ** 9 + 7) if n >= 2 else 1\\n```\\n\\nThis below one is more readable, but it\\'s O(N) time and O(N) space.\\n* dp_full[i] denotes the number of possible cases where 0, 1, .... i th columns are full\\n dp_full[i] = dp_full[i - 2] + dp_full[i - 1] + dp_incomp[i - 1] because we can achieve the state of dp_full[i] by **dp_full[i - 2] + (horizontal block) x 2** or **dp_full[i - 1] + (vertical block) x 1** or **dp_incomp[i - 1] + (tromino block) x 1**\\n* dp_incomp[i] denotes the number of possible cases where 0, 1, ... i - 1 the columns are full, and i th column is half filled\\n Similarly, dp_incomp[i] = dp_full[i - 2] * 2 + dp_incomp[i - 1] because we can achieve the state of dp_incomp[i] by **dp_full[i - 2] + (vertical block) x 2** or **dp_full[i - 2] + (horizontal block) x 2** or **dp_incomp[i - 1] + (tromino block) x 1**\\n\\n\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        #edge case\\n        if n == 1:\\n            return 1\\n        \\n        mod = 10 ** 9 + 7\\n        dp_full = [0 for _ in range(n)]\\n        dp_incomp = [0 for _ in range(n)]\\n        \\n        dp_full[0] = 1\\n        dp_full[1] = 2\\n        dp_incomp[1] = 2\\n        \\n        for i in range(2, n):\\n            dp_full[i] = dp_full[i - 2] + dp_full[i - 1] + dp_incomp[i - 1]\\n            dp_incomp[i] = dp_full[i - 2] * 2 + dp_incomp[i - 1]\\n        \\n        return dp_full[-1] % mod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        full_0, full_1, incomp_1 = 1, 2, 2\\n        for i in range(2, n):\\n            full_0, full_1, incomp_1 = full_1, full_0 + full_1 + incomp_1, 2 * full_0 + incomp_1\\n        return full_1 % (10 ** 9 + 7) if n >= 2 else 1\\n```\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        #edge case\\n        if n == 1:\\n            return 1\\n        \\n        mod = 10 ** 9 + 7\\n        dp_full = [0 for _ in range(n)]\\n        dp_incomp = [0 for _ in range(n)]\\n        \\n        dp_full[0] = 1\\n        dp_full[1] = 2\\n        dp_incomp[1] = 2\\n        \\n        for i in range(2, n):\\n            dp_full[i] = dp_full[i - 2] + dp_full[i - 1] + dp_incomp[i - 1]\\n            dp_incomp[i] = dp_full[i - 2] * 2 + dp_incomp[i - 1]\\n        \\n        return dp_full[-1] % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209282,
                "title": "java-top-down-and-bottom-up-dp-explained-with-ascii-pictures",
                "content": "Top-down\\n\\n```\\n/*\\n0 => \\u2589\\u2589\\u2580\\n1 => \\u2589\\u2589\\u2583\\n2 => \\u2589\\u2589\\u2589\\n*/\\npublic int numTilings(int n) {\\n\\treturn numTilingsForFinalStateOf(n, 2);\\n}\\nMap<String, Integer> memo = new HashMap<>();\\npublic int numTilingsForFinalStateOf(int n, int colState) {\\n\\tint mod = 1_000_000_007;\\n\\tif (n < 0) return 0;\\n\\n\\tif (n == 0) {\\n\\t\\tif (colState == 2) { // goal achieved\\n\\t\\t\\treturn 1;\\n\\t\\t} else {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n\\tString memKey = n+\"|\"+colState;\\n\\tif (memo.containsKey(memKey)) return memo.get(memKey);\\n\\n\\tlong ways = 0;\\n\\tif (colState == 0) { // attempting to generate tilings for \\u2589\\u2589\\u2580 means summing...\\n\\t\\tways += numTilingsForFinalStateOf(n-2, 2);// \\u2589\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 1);// \\u2589\\u2583\\n\\t} else if (colState == 1) { // attempting to generate tilings for \\u2589\\u2589\\u2583 means summing...\\n\\t\\tways += numTilingsForFinalStateOf(n-2, 2);// \\u2589\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 0);// \\u2589\\u2580\\n\\t} else if (colState == 2) { // attempting to generate tilings for \\u2589\\u2589\\u2589 means summing...\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 0);// \\u2589\\u2580\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 1);// \\u2589\\u2583\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 2);// \\u2589\\u2589\\n\\t\\tways += numTilingsForFinalStateOf(n-2, 2);// \\u2589\\n\\t}\\n\\n\\tways = Math.floorMod(ways, mod);\\n\\tmemo.put(memKey, (int) ways);\\n\\treturn (int) ways;\\n}\\n```\\n\\nBottom-up\\n```\\n/*\\n0 => \\u2589\\u2589\\u2580\\n1 => \\u2589\\u2589\\u2583\\n2 => \\u2589\\u2589\\u2589\\n*/\\npublic int numTilings(int n) {\\n\\tint mod = 1_000_000_007;\\n\\tlong dp[][] = new long[n+1][3];\\n\\t// entire \"zero-th\" row is possible because DP \\xAF\\\\_(\\u30C4)_/\\xAF\\n\\tdp[0][0] = 1;\\n\\tdp[0][1] = 1;\\n\\tdp[0][2] = 1;\\n\\t// we can start with a full row 1 by placing single domino (\\u2589)\\n\\t// other states are impossible because monominoes don\\'t exist\\n\\tdp[1][0] = 0;\\n\\tdp[1][1] = 0;\\n\\tdp[1][2] = 1;\\n\\n\\tfor (int i = 2; i<=n; i++) {\\n\\t\\t// calculate all the ways to get to \\u2589\\u2589\\u2580\\n\\t\\tdp[i][0] += dp[i-1][1]; // \\u2589\\u2583 + \\u2580\\u2580\\n\\t\\tdp[i][0] += dp[i-2][2]; // \\u2589  + \\u2589\\u2580\\n\\t\\tdp[i][0] = Math.floorMod(dp[i][0], mod);\\n\\n\\t\\t// calculate all the ways to get to \\u2589\\u2589\\u2583\\n\\t\\tdp[i][1] += dp[i-1][0]; // \\u2589\\u2580 + \\u2583\\u2583\\n\\t\\tdp[i][1] += dp[i-2][2]; // \\u2589  + \\u2589\\u2583\\n\\t\\tdp[i][1] = Math.floorMod(dp[i][1], mod);\\n\\n\\t\\t// calculate all the ways to get to \\u2589\\u2589\\u2589\\n\\t\\tdp[i][2] += dp[i-1][2]; // \\u2589\\u2589 + \\u2589\\n\\t\\tdp[i][2] += dp[i-2][2]; // \\u2589  + \\u2550\\u2550\\n\\t\\tdp[i][2] += dp[i-1][0]; // \\u2589\\u2580 + \\u2583\\u2589\\n\\t\\tdp[i][2] += dp[i-1][1]; // \\u2589\\u2583 + \\u2580\\u2589\\n\\t\\tdp[i][2] = Math.floorMod(dp[i][2], mod);\\n\\t}\\n\\n\\treturn (int) dp[n][2];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/*\\n0 => \\u2589\\u2589\\u2580\\n1 => \\u2589\\u2589\\u2583\\n2 => \\u2589\\u2589\\u2589\\n*/\\npublic int numTilings(int n) {\\n\\treturn numTilingsForFinalStateOf(n, 2);\\n}\\nMap<String, Integer> memo = new HashMap<>();\\npublic int numTilingsForFinalStateOf(int n, int colState) {\\n\\tint mod = 1_000_000_007;\\n\\tif (n < 0) return 0;\\n\\n\\tif (n == 0) {\\n\\t\\tif (colState == 2) { // goal achieved\\n\\t\\t\\treturn 1;\\n\\t\\t} else {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n\\tString memKey = n+\"|\"+colState;\\n\\tif (memo.containsKey(memKey)) return memo.get(memKey);\\n\\n\\tlong ways = 0;\\n\\tif (colState == 0) { // attempting to generate tilings for \\u2589\\u2589\\u2580 means summing...\\n\\t\\tways += numTilingsForFinalStateOf(n-2, 2);// \\u2589\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 1);// \\u2589\\u2583\\n\\t} else if (colState == 1) { // attempting to generate tilings for \\u2589\\u2589\\u2583 means summing...\\n\\t\\tways += numTilingsForFinalStateOf(n-2, 2);// \\u2589\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 0);// \\u2589\\u2580\\n\\t} else if (colState == 2) { // attempting to generate tilings for \\u2589\\u2589\\u2589 means summing...\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 0);// \\u2589\\u2580\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 1);// \\u2589\\u2583\\n\\t\\tways += numTilingsForFinalStateOf(n-1, 2);// \\u2589\\u2589\\n\\t\\tways += numTilingsForFinalStateOf(n-2, 2);// \\u2589\\n\\t}\\n\\n\\tways = Math.floorMod(ways, mod);\\n\\tmemo.put(memKey, (int) ways);\\n\\treturn (int) ways;\\n}\\n```\n```\\n/*\\n0 => \\u2589\\u2589\\u2580\\n1 => \\u2589\\u2589\\u2583\\n2 => \\u2589\\u2589\\u2589\\n*/\\npublic int numTilings(int n) {\\n\\tint mod = 1_000_000_007;\\n\\tlong dp[][] = new long[n+1][3];\\n\\t// entire \"zero-th\" row is possible because DP \\xAF\\\\_(\\u30C4)_/\\xAF\\n\\tdp[0][0] = 1;\\n\\tdp[0][1] = 1;\\n\\tdp[0][2] = 1;\\n\\t// we can start with a full row 1 by placing single domino (\\u2589)\\n\\t// other states are impossible because monominoes don\\'t exist\\n\\tdp[1][0] = 0;\\n\\tdp[1][1] = 0;\\n\\tdp[1][2] = 1;\\n\\n\\tfor (int i = 2; i<=n; i++) {\\n\\t\\t// calculate all the ways to get to \\u2589\\u2589\\u2580\\n\\t\\tdp[i][0] += dp[i-1][1]; // \\u2589\\u2583 + \\u2580\\u2580\\n\\t\\tdp[i][0] += dp[i-2][2]; // \\u2589  + \\u2589\\u2580\\n\\t\\tdp[i][0] = Math.floorMod(dp[i][0], mod);\\n\\n\\t\\t// calculate all the ways to get to \\u2589\\u2589\\u2583\\n\\t\\tdp[i][1] += dp[i-1][0]; // \\u2589\\u2580 + \\u2583\\u2583\\n\\t\\tdp[i][1] += dp[i-2][2]; // \\u2589  + \\u2589\\u2583\\n\\t\\tdp[i][1] = Math.floorMod(dp[i][1], mod);\\n\\n\\t\\t// calculate all the ways to get to \\u2589\\u2589\\u2589\\n\\t\\tdp[i][2] += dp[i-1][2]; // \\u2589\\u2589 + \\u2589\\n\\t\\tdp[i][2] += dp[i-2][2]; // \\u2589  + \\u2550\\u2550\\n\\t\\tdp[i][2] += dp[i-1][0]; // \\u2589\\u2580 + \\u2583\\u2589\\n\\t\\tdp[i][2] += dp[i-1][1]; // \\u2589\\u2583 + \\u2580\\u2589\\n\\t\\tdp[i][2] = Math.floorMod(dp[i][2], mod);\\n\\t}\\n\\n\\treturn (int) dp[n][2];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413360,
                "title": "c-dp-solution-with-step-by-step-optimization-and-explanation",
                "content": "# Step 1:\\nTwo dimension DP[i, j] array.\\ni is the i-th column of the grid.\\nj indicates 3 states of the i-th column. \\n\\t\\t0 : Fully covered by a tile(Domino or Tromino).\\n\\t\\t1 : Only top part is coverd by a tile.\\n\\t\\t2 : Only bottom part is covered by a tile.\\nNow we can come up with 3 DP formulas: \\n```\\ndp[i,0] = dp[i-2,0] + dp[i-1,0] + dp[i-1,1] + dp[i-1,2];\\ndp[i,1] = dp[i-2,0] + dp[i-1,2];\\ndp[i,2] = dp[i-2,0] + dp[i-1,1];\\n```\\n```\\npublic int NumTilings(int N) {\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        long[,] dp = new long[N+1,3];\\n        dp[0,0] = 1;\\n        dp[1,0] = 1;\\n        for(int i = 2; i <= N; i++)\\n        {\\n            dp[i,0] = (dp[i-2,0] + dp[i-1,0] + dp[i-1,1] + dp[i-1,2]) % mod;\\n            dp[i,1] = (dp[i-2,0] + dp[i-1,2]) % mod;\\n            dp[i,2] = (dp[i-2,0] + dp[i-1,1]) % mod;\\n        }\\n        \\n        return (int)dp[N,0];\\n    }\\n```           \\n\\t\\n# Step 2:\\nLook at the formula again, DP[i, 1] and DP[i, 2] are equivalent.\\nSo the formula can be simplified: \\n```\\ndp[i,0] = dp[i-2,0] + dp[i-1,0] + 2 * dp[i-1,1];\\ndp[i,1] = dp[i-2,0] + dp[i-1,1];\\n```\\nDo some math, get rid of dp[i-1,1] and dp[i,1] by :\\n```\\ndp[i-1,1] = 1/2 * (dp[i,0] - dp[i-2,0] - dp[i-1,0]);\\ndp[i,1] = 1/2 * (dp[i+1,0] - dp[i-1,0] - dp[i,0]);\\n```\\nThen we get :\\n```\\n1/2 * (dp[i+1,0] - dp[i-1,0] - dp[i,0]) = dp[i-2,0] + 1/2 * (dp[i,0] - dp[i-2,0] - dp[i-1,0]);\\ndp[i+1,0] **- dp[i-1,0]** - dp[i,0] = 2 * dp[i-2,0] + dp[i,0] - dp[i-2,0] **- dp[i-1,0]**;\\ndp[i+1,0] - dp[i,0] = 2 * **dp[i-2,0]** + dp[i,0] - **dp[i-2,0]**;\\ndp[i+1,0] - **dp[i,0]** = dp[i-2,0] + **dp[i,0]**;\\ndp[i+1,0] = dp[i-2,0] + 2 * dp[i,0];\\ndp[i,0] = dp[i-3,0] + 2 * dp[i-1,0];\\n```\\nNow, the formula can be converted to one dimension array.\\n```\\ndp[i] = dp[i-3] + 2 * dp[i-1];\\n```\\n```\\npublic int NumTilings(int N) {\\n        if(N < 3)\\n            return N;\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        long[] dp = new long[N+1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for(int i = 3; i <= N; i++)\\n        {\\n            dp[i] = (dp[i-3] + 2 * dp[i-1]) % mod;\\n        }\\n        \\n        return (int)dp[N];\\n    }\\n```\\n\\n# Step 3:\\nNotice that in the formula we only need to track the last 3 previous result, \\nSo we can replace the DP array by 3 variables:\\n```\\npublic int NumTilings(int N) {\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        long a = 0, b = 1, c = 1, cur = 1;\\n        while(--N > 0)\\n        {\\n            cur = (a + c * 2) % mod;\\n            a = b;\\n            b = c;\\n            c = cur;\\n        }\\n        return (int)cur;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i,0] = dp[i-2,0] + dp[i-1,0] + dp[i-1,1] + dp[i-1,2];\\ndp[i,1] = dp[i-2,0] + dp[i-1,2];\\ndp[i,2] = dp[i-2,0] + dp[i-1,1];\\n```\n```\\npublic int NumTilings(int N) {\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        long[,] dp = new long[N+1,3];\\n        dp[0,0] = 1;\\n        dp[1,0] = 1;\\n        for(int i = 2; i <= N; i++)\\n        {\\n            dp[i,0] = (dp[i-2,0] + dp[i-1,0] + dp[i-1,1] + dp[i-1,2]) % mod;\\n            dp[i,1] = (dp[i-2,0] + dp[i-1,2]) % mod;\\n            dp[i,2] = (dp[i-2,0] + dp[i-1,1]) % mod;\\n        }\\n        \\n        return (int)dp[N,0];\\n    }\\n```\n```\\ndp[i,0] = dp[i-2,0] + dp[i-1,0] + 2 * dp[i-1,1];\\ndp[i,1] = dp[i-2,0] + dp[i-1,1];\\n```\n```\\ndp[i-1,1] = 1/2 * (dp[i,0] - dp[i-2,0] - dp[i-1,0]);\\ndp[i,1] = 1/2 * (dp[i+1,0] - dp[i-1,0] - dp[i,0]);\\n```\n```\\n1/2 * (dp[i+1,0] - dp[i-1,0] - dp[i,0]) = dp[i-2,0] + 1/2 * (dp[i,0] - dp[i-2,0] - dp[i-1,0]);\\ndp[i+1,0] **- dp[i-1,0]** - dp[i,0] = 2 * dp[i-2,0] + dp[i,0] - dp[i-2,0] **- dp[i-1,0]**;\\ndp[i+1,0] - dp[i,0] = 2 * **dp[i-2,0]** + dp[i,0] - **dp[i-2,0]**;\\ndp[i+1,0] - **dp[i,0]** = dp[i-2,0] + **dp[i,0]**;\\ndp[i+1,0] = dp[i-2,0] + 2 * dp[i,0];\\ndp[i,0] = dp[i-3,0] + 2 * dp[i-1,0];\\n```\n```\\ndp[i] = dp[i-3] + 2 * dp[i-1];\\n```\n```\\npublic int NumTilings(int N) {\\n        if(N < 3)\\n            return N;\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        long[] dp = new long[N+1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for(int i = 3; i <= N; i++)\\n        {\\n            dp[i] = (dp[i-3] + 2 * dp[i-1]) % mod;\\n        }\\n        \\n        return (int)dp[N];\\n    }\\n```\n```\\npublic int NumTilings(int N) {\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        long a = 0, b = 1, c = 1, cur = 1;\\n        while(--N > 0)\\n        {\\n            cur = (a + c * 2) % mod;\\n            a = b;\\n            b = c;\\n            c = cur;\\n        }\\n        return (int)cur;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 296419,
                "title": "dp-solution-easy-to-understand-with-two-arrays-drawing-picture",
                "content": "Use two arrays for dp, `up[i]` means the board is complete from `0` to `i-1` , only the `i-th` column has only one square, `ret[i]` means the board is compelte from `0` to `i`.\\nSee the picture for clarification.\\n\\n![image](https://assets.leetcode.com/users/liyz1997/image_1558428660.png)\\n\\n```\\nconst int maxn = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        vector<long long> up(N + 1, 0), ret(N + 1, 0);\\n        ret[0] = 1;  // empty considered 1 way\\n        for (int i = 1; i <= N; i++) {\\n\\t\\t\\t// for up[i]\\n            up[i] += up[i - 1];  // case 1\\n            if (i > 1)  // case 2\\n                up[i] += ret[i - 2];\\n\\t\\t\\t\\t\\n            // for ret[i]\\n            ret[i] += ret[i - 1];  // case 1\\n            ret[i] += (2 * up[i - 1]);  // case 2\\n            if (i > 1)  // case 3\\n                ret[i] += ret[i - 2];\\n            \\n            up[i] %= maxn;\\n            ret[i] %= maxn;\\n        }\\n        return ret[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int maxn = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        vector<long long> up(N + 1, 0), ret(N + 1, 0);\\n        ret[0] = 1;  // empty considered 1 way\\n        for (int i = 1; i <= N; i++) {\\n\\t\\t\\t// for up[i]\\n            up[i] += up[i - 1];  // case 1\\n            if (i > 1)  // case 2\\n                up[i] += ret[i - 2];\\n\\t\\t\\t\\t\\n            // for ret[i]\\n            ret[i] += ret[i - 1];  // case 1\\n            ret[i] += (2 * up[i - 1]);  // case 2\\n            if (i > 1)  // case 3\\n                ret[i] += ret[i - 2];\\n            \\n            up[i] %= maxn;\\n            ret[i] %= maxn;\\n        }\\n        return ret[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945616,
                "title": "beats-100-solve-by-simple-linear-equation-with-explanation",
                "content": "My first intution was that f(n) can only depend on f(n-1), f(n-2) and f(n-3). Hence I formulated a linear equation as follows and solved it with known values (you can use leetcode testcase runner or compute manually for n=4,5,6). \\n\\n     linear equation\\n     f(n) = x * f(n-1) + y * f(n-2) + z * f(n-3)\\n     n = 4 => 5x + 2y + z = 11 \\n     n = 5 => 11x + 5y + 2z = 24\\n     n = 6 => 24x + 11y + 5z = 53\\n     With 3 equations we can find 3 unknowns.\\n     x = 2, y = 0, z = 1 \\n     i.e there is no dependency on f(n-2)\\n     \\n     Final equation:\\n     f(n) = 2*f(n-1) + f(n-3)\\n\\n\\nFind the java code here -> using DP tabulation similar to fibonacci\\nhttps://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/dp/DominoTrominoTiling.java",
                "solutionTags": [
                    "Java"
                ],
                "code": "My first intution was that f(n) can only depend on f(n-1), f(n-2) and f(n-3). Hence I formulated a linear equation as follows and solved it with known values (you can use leetcode testcase runner or compute manually for n=4,5,6). \\n\\n     linear equation\\n     f(n) = x * f(n-1) + y * f(n-2) + z * f(n-3)\\n     n = 4 => 5x + 2y + z = 11 \\n     n = 5 => 11x + 5y + 2z = 24\\n     n = 6 => 24x + 11y + 5z = 53\\n     With 3 equations we can find 3 unknowns.\\n     x = 2, y = 0, z = 1 \\n     i.e there is no dependency on f(n-2)\\n     \\n     Final equation:\\n     f(n) = 2*f(n-1) + f(n-3)\\n\\n\\nFind the java code here -> using DP tabulation similar to fibonacci\\nhttps://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/dp/DominoTrominoTiling.java",
                "codeTag": "Unknown"
            },
            {
                "id": 2945016,
                "title": "0ms-dp-solution-with-memoization-c-with-comments-and-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThinking of dp with memoization by finding the number of ways to fill from the column 1 to column i.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // up -> can be 0 or 1, 0 means there is no tile in a cell in first row and 1 means there is a tile in a cell in first row\\n    // down -> can be 0 or 1, 0 means there is no tile in a cell in second row and 1 means there is a tile in a cell in second row\\n    // dp[i][up][down] -> number of ways to fill the first i columns of the grid with the above constraints \\n    int dp[1001][3][3];\\n    int mod=1000000007;\\n    int rec(int i, int n, int up, int down){\\n        if (i==n+1){ // base case, if we reach out of the grid\\n            if (up+down==0) return 1; // No tile should be present in out of the grid, then that will be a valid way\\n            return 0;\\n        } \\n\\n        if (dp[i][up][down]!=-1) // If already calculated, then return the value\\n            return dp[i][up][down];\\n\\n        if (up+down==2) // If both rows have a tile. \\n            return dp[i][up][down]=rec(i+1, n, 0, 0); // Move to next column and in the next column, we have no tile, so both up and down are 0.\\n\\n        else if (up+down==0){ // If both rows have no tile\\n            int a=rec(i+1, n, 0, 0); // Fill with one tile of size 2x1, so for the next column up and down will be zero.\\n            int b=rec(i+1, n, 1, 1); // Fill with two tiles of size 1x2, so for the next column up and down will be one.\\n            int c=rec(i+1, n, 1, 0); // Fill with tromino such that in the next column, up has a tile and down hasn\\'t.\\n            int d=rec(i+1, n, 0, 1); // Fill with tromino such that in the next column, down has a tile and up hasn\\'t.\\n            return dp[i][up][down]=((long long)a+b+c+d)%mod; // Return the total number of ways.\\n        }\\n\\n        else if (up==1){ // If only up has a tile\\n            int a=rec(i+1, n, 1, 1); // Fill with a tromino covering the down and so in the next column, both up and down will have a tile.\\n            int b=rec(i+1, n, 0, 1); // Fill with a tile 1x2 covering the down and so in the next column, up will have no tile and down will have a tile.\\n            return dp[i][up][down]=((long long)a+b)%mod;\\n        }\\n\\n        else if (down==1){ // If only down has a tile\\n            int a=rec(i+1, n, 1, 1); // Fill with a tromino covering the up and so in the next column, both up and down will have a tile.\\n            int b=rec(i+1, n, 1, 0); // Fill with a tile 1x2 covering the up and so in the next column, up will have a tile and down will have no tile.\\n            return dp[i][up][down]=((long long)a+b)%mod;\\n        }\\n        \\n        return 0;\\n    }\\n    int numTilings(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return rec(1, n, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // up -> can be 0 or 1, 0 means there is no tile in a cell in first row and 1 means there is a tile in a cell in first row\\n    // down -> can be 0 or 1, 0 means there is no tile in a cell in second row and 1 means there is a tile in a cell in second row\\n    // dp[i][up][down] -> number of ways to fill the first i columns of the grid with the above constraints \\n    int dp[1001][3][3];\\n    int mod=1000000007;\\n    int rec(int i, int n, int up, int down){\\n        if (i==n+1){ // base case, if we reach out of the grid\\n            if (up+down==0) return 1; // No tile should be present in out of the grid, then that will be a valid way\\n            return 0;\\n        } \\n\\n        if (dp[i][up][down]!=-1) // If already calculated, then return the value\\n            return dp[i][up][down];\\n\\n        if (up+down==2) // If both rows have a tile. \\n            return dp[i][up][down]=rec(i+1, n, 0, 0); // Move to next column and in the next column, we have no tile, so both up and down are 0.\\n\\n        else if (up+down==0){ // If both rows have no tile\\n            int a=rec(i+1, n, 0, 0); // Fill with one tile of size 2x1, so for the next column up and down will be zero.\\n            int b=rec(i+1, n, 1, 1); // Fill with two tiles of size 1x2, so for the next column up and down will be one.\\n            int c=rec(i+1, n, 1, 0); // Fill with tromino such that in the next column, up has a tile and down hasn\\'t.\\n            int d=rec(i+1, n, 0, 1); // Fill with tromino such that in the next column, down has a tile and up hasn\\'t.\\n            return dp[i][up][down]=((long long)a+b+c+d)%mod; // Return the total number of ways.\\n        }\\n\\n        else if (up==1){ // If only up has a tile\\n            int a=rec(i+1, n, 1, 1); // Fill with a tromino covering the down and so in the next column, both up and down will have a tile.\\n            int b=rec(i+1, n, 0, 1); // Fill with a tile 1x2 covering the down and so in the next column, up will have no tile and down will have a tile.\\n            return dp[i][up][down]=((long long)a+b)%mod;\\n        }\\n\\n        else if (down==1){ // If only down has a tile\\n            int a=rec(i+1, n, 1, 1); // Fill with a tromino covering the up and so in the next column, both up and down will have a tile.\\n            int b=rec(i+1, n, 1, 0); // Fill with a tile 1x2 covering the up and so in the next column, up will have a tile and down will have no tile.\\n            return dp[i][up][down]=((long long)a+b)%mod;\\n        }\\n        \\n        return 0;\\n    }\\n    int numTilings(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return rec(1, n, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156332,
                "title": "o-log-n-c-concise-and-clean-and-easy-dp-solution",
                "content": "`f[i]` represents the number of ways to construct such shape:\\n`oooooooooo`\\n`oooooooooo`\\nwhere there are total 2i `o`s.\\n\\n`g[i]` represents the number of ways to construct such shape:\\n`oooooooooo`\\n`ooooooooo`\\nwhere there are total (2i - 1) `o`s.\\n\\nThen:\\n```\\nf(i) = f(i - 1) + f(i -2) + 2g(i - 1)\\ng(i) = g(i - 1) + f(i - 2)\\n```\\n\\nWe can then get an easy O(n) solution.\\n\\n***\\n\\nBut it can be faster:\\nIf we use matrix multiply to calculate f, it can be written as:\\n```\\n[1, 1, 2] [f(i-1), f(i-2), g(i-1)]^T = f(i)  // ^T: matrix\\'s transpose\\n```\\nwe can also use f(i-1), f(i-2), and g(i-1) only to construct f(i-1), g(i):\\n```\\n[1, 0, 0] [f(i-1), f(i-2), g(i-1)]^T = f(i-1)\\n[0, 1, 1] [f(i-1), f(i-2), g(i-1)]^T = g(i)\\n```\\n\\nTHEN,\\n```\\n/ 1 1 2 \\\\  /f(i-1)\\\\     / f(i) \\\\\\n| 1 0 0 |  |f(i-2)|  =  |f(i-1)|\\n\\\\ 0 1 1 /  \\\\g(i-1)/     \\\\ g(i) /\\n```\\n\\n***\\n\\nOkay, if we want to calculate f(4), it will be:\\n```\\n/ 1 1 2 \\\\  / 1 1 2 \\\\  /f(2)\\\\     /f(4)\\\\\\n| 1 0 0 |  | 1 0 0 |  |f(1)|  =  |f(3)|\\n\\\\ 0 1 1 /  \\\\ 0 1 1 /  \\\\g(2)/     \\\\g(4)/\\n```\\ngenerally, let R = `[[1,1,2],[1,0,0],[0,1,1]]`, then\\n```\\n[f(N), f(N - 1), g(N)]^T = R^(N - 2) * [f(2), f(1), g(2)]^T\\n```\\n\\nWe can calculate the matrix exponentiation `R^(N-2)` using a time of O(log N). Done.\\n\\n***\\n\\n```cpp\\n/*\\n/ 1 1 2 \\\\  /f(i-1)\\\\     / f(i) \\\\\\n| 1 0 0 |  |f(i-2)|  =  |f(i-1)|\\n\\\\ 0 1 1 /  \\\\g(i-1)/     \\\\ g(i) /\\n*/\\n#define M 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        if (N <= 2) return N;\\n        vector<vector<ll>> r;\\n        r.push_back({1, 1, 2});\\n        r.push_back({1, 0, 0});\\n        r.push_back({0, 1, 1});\\n        r = power(r, N - 2);\\n        return (r[0][0] * 2 + r[0][1] + r[0][2]) % M;\\n    }\\n    \\n    vector<vector<ll>> power(vector<vector<ll>>& x, int n) {\\n        if (n == 1) return x;\\n        int m = n >> 1;\\n        auto r = power(x, m);\\n        r = multiply(r, r);\\n        if (n & 1) {\\n            r = multiply(r, x);\\n        }\\n        return r;\\n    }\\n    \\nprivate:\\n    vector<vector<ll>> multiply(const vector<vector<ll>>& a, const vector<vector<ll>>& b) {\\n        vector<vector<ll>> r(3, vector<ll>(3, 0));\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                for (int k = 0; k < 3; k++) {\\n                    r[i][j] += a[i][k] * b[k][j];\\n                }\\n                r[i][j] %= M;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nf(i) = f(i - 1) + f(i -2) + 2g(i - 1)\\ng(i) = g(i - 1) + f(i - 2)\\n```\n```\\n[1, 1, 2] [f(i-1), f(i-2), g(i-1)]^T = f(i)  // ^T: matrix\\'s transpose\\n```\n```\\n[1, 0, 0] [f(i-1), f(i-2), g(i-1)]^T = f(i-1)\\n[0, 1, 1] [f(i-1), f(i-2), g(i-1)]^T = g(i)\\n```\n```\\n/ 1 1 2 \\\\  /f(i-1)\\\\     / f(i) \\\\\\n| 1 0 0 |  |f(i-2)|  =  |f(i-1)|\\n\\\\ 0 1 1 /  \\\\g(i-1)/     \\\\ g(i) /\\n```\n```\\n/ 1 1 2 \\\\  / 1 1 2 \\\\  /f(2)\\\\     /f(4)\\\\\\n| 1 0 0 |  | 1 0 0 |  |f(1)|  =  |f(3)|\\n\\\\ 0 1 1 /  \\\\ 0 1 1 /  \\\\g(2)/     \\\\g(4)/\\n```\n```\\n[f(N), f(N - 1), g(N)]^T = R^(N - 2) * [f(2), f(1), g(2)]^T\\n```\n```cpp\\n/*\\n/ 1 1 2 \\\\  /f(i-1)\\\\     / f(i) \\\\\\n| 1 0 0 |  |f(i-2)|  =  |f(i-1)|\\n\\\\ 0 1 1 /  \\\\g(i-1)/     \\\\ g(i) /\\n*/\\n#define M 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        if (N <= 2) return N;\\n        vector<vector<ll>> r;\\n        r.push_back({1, 1, 2});\\n        r.push_back({1, 0, 0});\\n        r.push_back({0, 1, 1});\\n        r = power(r, N - 2);\\n        return (r[0][0] * 2 + r[0][1] + r[0][2]) % M;\\n    }\\n    \\n    vector<vector<ll>> power(vector<vector<ll>>& x, int n) {\\n        if (n == 1) return x;\\n        int m = n >> 1;\\n        auto r = power(x, m);\\n        r = multiply(r, r);\\n        if (n & 1) {\\n            r = multiply(r, x);\\n        }\\n        return r;\\n    }\\n    \\nprivate:\\n    vector<vector<ll>> multiply(const vector<vector<ll>>& a, const vector<vector<ll>>& b) {\\n        vector<vector<ll>> r(3, vector<ll>(3, 0));\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                for (int k = 0; k < 3; k++) {\\n                    r[i][j] += a[i][k] * b[k][j];\\n                }\\n                r[i][j] %= M;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944977,
                "title": "java-dp-in-a-different-way-explained-and-commented",
                "content": "# Intuition\\nThe idea in this problem is to figure out the transitions we can make.\\n\\nBasically we have the following transitions:\\n\\n* Put a 2x1 tile ( | ) then we move to the next column.\\n* Put a 1x2 tile ( _ ) then we must match below and move i+2 column.\\n* Put an L shape tromino. Then we either close with inverted L or put _ above\\n* The previous point can also be inverted therefore we multiply the result by 2 of that transition.\\n\\nThe flag `isAdjacentTaken` in the code is for situations where we put an L shape tromino and move to the next column. In this situation, the row beneath (or above because we can invert the tromino) is taken. This is a unique state that we need to account for.\\n\\n![image.png](https://assets.leetcode.com/users/images/3528a929-a120-43c2-b3cc-3ad326cddd10_1671870454.7892098.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private final int MOD = 1_000_000_007;\\n\\n    public int numTilings(int n) {\\n        long[][] dp = new long[n][2];\\n        for (long[] A : dp) {\\n            Arrays.fill(A, -1);\\n        }\\n        return (int) solve(0, n, false, dp);\\n    }\\n\\n    public long solve(int i, int n, boolean isAdjacentTaken, long[][] dp) {\\n        if (i == n && !isAdjacentTaken) return 1;\\n        if (i >= n) return 0;\\n        if (dp[i][isAdjacentTaken ? 0 : 1] != -1) return dp[i][isAdjacentTaken ? 0 : 1];\\n\\n        long ans = 0;\\n        if (!isAdjacentTaken) {\\n            ans += solve(i + 1, n, false, dp); // if we put 2x1 tile\\n            ans += solve(i + 2, n, false, dp); // 1x2 tiles twice\\n            ans += 2 * solve(i + 1, n, true, dp); // L shape (and inverted L)\\n        } else {\\n            ans += solve(i + 1, n, true, dp); // 1x2 tile and go down\\n            ans += solve(i + 2, n, false, dp); // L to close\\n        }\\n        ans %= MOD;\\n        return dp[i][isAdjacentTaken ? 0 : 1] = ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private final int MOD = 1_000_000_007;\\n\\n    public int numTilings(int n) {\\n        long[][] dp = new long[n][2];\\n        for (long[] A : dp) {\\n            Arrays.fill(A, -1);\\n        }\\n        return (int) solve(0, n, false, dp);\\n    }\\n\\n    public long solve(int i, int n, boolean isAdjacentTaken, long[][] dp) {\\n        if (i == n && !isAdjacentTaken) return 1;\\n        if (i >= n) return 0;\\n        if (dp[i][isAdjacentTaken ? 0 : 1] != -1) return dp[i][isAdjacentTaken ? 0 : 1];\\n\\n        long ans = 0;\\n        if (!isAdjacentTaken) {\\n            ans += solve(i + 1, n, false, dp); // if we put 2x1 tile\\n            ans += solve(i + 2, n, false, dp); // 1x2 tiles twice\\n            ans += 2 * solve(i + 1, n, true, dp); // L shape (and inverted L)\\n        } else {\\n            ans += solve(i + 1, n, true, dp); // 1x2 tile and go down\\n            ans += solve(i + 2, n, false, dp); // L to close\\n        }\\n        ans %= MOD;\\n        return dp[i][isAdjacentTaken ? 0 : 1] = ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353813,
                "title": "recursive-dp-and-iterative-dp-how-i-d-approach-this-in-an-interview",
                "content": "## Approach\\nAfter spending less than a minute on the problem, you\\'ll quickly realize that this is a classical DP problem. So we need to come up with base cases and figure out how to divide a bigger problem into smaller ones or in other words, derive recurrence relations.\\n\\n### Deriving the recurrences\\n\\nLet\\'s define the function `F(n)` = number of ways to solve for a `2 x n` grid \\nFor a `2 x n` grid, we can use either a domino or a tromino.\\n*  **Domino**: If we put the domino vertically, we need to solve `2 x (n-1)` grid. If we put the domino horizontally, we have to use another domino horizontally to fill the slot, which means we need to solve `2 x (n-2)` grid. So choosing a domino requires us to solve sub problems of size `n-1` and `n-2` \\n*  **Tromino**: We can put a tromino in two valid ways, both of which are symmetric sub-problems, but these subproblems are of a different kind. They have one additional tile which can be filled by a domino or a tromino. So we need to define another function:\\n`G(n)` = number of ways to solve a `2 x n` grid with an additional empty tile to fill (at `n+1`st level)\\n\\nFor `G(n)` we have two valid choices:\\n* **Domino**: If we put a domino to fill the additional empty tile, we are left with another empty tile, but the problem reduces by 1 in size namely, `G(n-1)`\\n* **Tromino**: If we use a tromino, we will fill that empty tile and the new problem to solve is `F(n-1)`\\n\\n### Base cases\\nSince we have to fill a `2 x n`  grid, an obvious base case is `2 x 1`. But since we also have a tromino which would not fit in a `2 x 1` grid, we also want to consider `2 x 2` grid for the base case. \\n* For function `F` \\n\\t* A `2 x 1` grid can only be filled with one domino in one way. \\n\\t* A `2 x 2` grid can be filled with only dominoes, but in 2 different ways - both vertical or both horizontal. \\n* For function `G`\\n\\t* A `2 x 1` grid with an additional empty tile can be filled in only one way, by using a tromino.\\n\\t* A `2 x 2` grid with an additional empty tile can be filled in two ways, both by using a domino and a tromino in different configurations.\\n\\nNow we can write the base cases and recurrence relations as follows:\\n```\\n    F(1) = G(1) = 1\\n    F(2) = G(2) = 2\\n    F(n) = F(n-1) + F(n-2) + 2 * G(n-2)\\n    G(n) = F(n-1) + G(n-1)\\n```    \\n\\n### Recursive solution in Python\\n\\n```\\nF(n) = find(n, False)\\nG(n) = find(n, True)\\n```\\n\\n```\\n    def numTilings(self, n: int) -> int:\\n        M = 10**9+7\\n        @cache\\n        def find(m, extra = False):\\n            if m < 3: return m\\n            if extra: return (find(m-1) + find(m-1, True)) % M\\n            return (find(m-1) + find(m-2) + 2*find(m-2, True)) % M\\n            \\n        return find(n)\\n```\\n\\n* `O(n)` time \\n* `O(n)` space due to recursion stack\\n\\n### Iterative solution in Python\\n```\\n    def numTilings(self, n: int) -> int:\\n        if n < 3: return n\\n        M = 10**9+7\\n        F1 = G1 = 1\\n        F2 = G2 = 2\\n        for i in range(n-2): \\n\\t\\t\\tF1, G1, F2, G2 = F2, G2, (F2+F1+2*G1)%M, (F2+G2)%M\\n        return F2\\n```\\n* `O(n)` time \\n* `O(1)` space\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    F(1) = G(1) = 1\\n    F(2) = G(2) = 2\\n    F(n) = F(n-1) + F(n-2) + 2 * G(n-2)\\n    G(n) = F(n-1) + G(n-1)\\n```\n```\\nF(n) = find(n, False)\\nG(n) = find(n, True)\\n```\n```\\n    def numTilings(self, n: int) -> int:\\n        M = 10**9+7\\n        @cache\\n        def find(m, extra = False):\\n            if m < 3: return m\\n            if extra: return (find(m-1) + find(m-1, True)) % M\\n            return (find(m-1) + find(m-2) + 2*find(m-2, True)) % M\\n            \\n        return find(n)\\n```\n```\\n    def numTilings(self, n: int) -> int:\\n        if n < 3: return n\\n        M = 10**9+7\\n        F1 = G1 = 1\\n        F2 = G2 = 2\\n        for i in range(n-2): \\n\\t\\t\\tF1, G1, F2, G2 = F2, G2, (F2+F1+2*G1)%M, (F2+G2)%M\\n        return F2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 182591,
                "title": "javascript-simple-dp-with-graphic-explanations-about-the-equations",
                "content": "### DP\\n`dp[i][0]` means the possibilities when the first `i` columns are full;\\n`dp[i][1]` means the possibilities when the first `i-1` columns are full and the `ith` column has only one item.\\n\\n---------\\n\\n### Equations\\n`dp[i][0] = dp[i-2][0] + dp[i-1][1] + dp[i-1][0];`\\n```\\ndp[i-2][0] ---> dp[i][0]\\n*...*AA\\n*...*BB\\n```\\n```\\ndp[i-1][1] ---> dp[i][0]\\n*...**A\\n*...*AA\\nor\\n*...*AA\\n*...**A\\nPS: dp[i-1][1] already includes the two possibilities above, so no need to multiply 2.\\n```\\n```\\ndp[i-1][0] ---> dp[i][0]\\n*...**A\\n*...**A\\n```\\n`dp[i][1] = dp[i-2][0] * 2 + dp[i-1][1]`\\n```\\ndp[i-2][0]*2 ---> dp[i][1]\\n*...*AA\\n*...*A\\nand\\n*...*A\\n*...*AA\\n```\\n```\\ndp[i-1][1] ---> dp[i][1]\\n*...**\\n*...*AA\\nor\\n*...*AA\\n*...**\\nPS: dp[i-1][1] already includes the two possibilities above, so no need to multiply 2.\\n```\\n\\n-------\\n\\n### Code\\n```\\nvar numTilings = function(N) {\\n    let mod=1e9+7;\\n    let dp=Array.from({length:N+1}, x=>[0,0]);\\n    dp[1][0]=1;\\n    dp[1][1]=0;\\n    if(N>1) dp[2][0]=dp[2][1]=2;\\n    for(let i=3; i<=N; i++){\\n        dp[i][0]=(dp[i-2][0]+dp[i-1][1]+dp[i-1][0])%mod;\\n        dp[i][1]=(dp[i-2][0]*2+dp[i-1][1])%mod;\\n    }\\n    return dp[N][0];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i-2][0] ---> dp[i][0]\\n*...*AA\\n*...*BB\\n```\n```\\ndp[i-1][1] ---> dp[i][0]\\n*...**A\\n*...*AA\\nor\\n*...*AA\\n*...**A\\nPS: dp[i-1][1] already includes the two possibilities above, so no need to multiply 2.\\n```\n```\\ndp[i-1][0] ---> dp[i][0]\\n*...**A\\n*...**A\\n```\n```\\ndp[i-2][0]*2 ---> dp[i][1]\\n*...*AA\\n*...*A\\nand\\n*...*A\\n*...*AA\\n```\n```\\ndp[i-1][1] ---> dp[i][1]\\n*...**\\n*...*AA\\nor\\n*...*AA\\n*...**\\nPS: dp[i-1][1] already includes the two possibilities above, so no need to multiply 2.\\n```\n```\\nvar numTilings = function(N) {\\n    let mod=1e9+7;\\n    let dp=Array.from({length:N+1}, x=>[0,0]);\\n    dp[1][0]=1;\\n    dp[1][1]=0;\\n    if(N>1) dp[2][0]=dp[2][1]=2;\\n    for(let i=3; i<=N; i++){\\n        dp[i][0]=(dp[i-2][0]+dp[i-1][1]+dp[i-1][0])%mod;\\n        dp[i][1]=(dp[i-2][0]*2+dp[i-1][1])%mod;\\n    }\\n    return dp[N][0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2947428,
                "title": "best-python-solution-simple-dp-soln-no-complex-full-partial-case-equation-needed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink like we are filling a 2xn matrix with given blocks. First row count is tracked by i and second row count is tracked by j.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen i=j we can put 4 blocks.\\n![Screenshot 2022-12-24 at 3.44.04 PM.png](https://assets.leetcode.com/users/images/8041d634-cb53-48fd-9ee8-207b37aee883_1671918312.788086.png)\\n\\nwhen i>j we can put 2 blocks.\\n![Screenshot 2022-12-24 at 3.44.33 PM.png](https://assets.leetcode.com/users/images/df2a5d14-5a8e-4d88-98c8-3610518ce7cf_1671918368.1857407.png)\\n\\n\\nwhen i<j we can put 2 blocks.\\n![Screenshot 2022-12-24 at 3.44.53 PM.png](https://assets.leetcode.com/users/images/e0250c0c-258b-4e3e-bdee-845f6e1c556c_1671918381.1000497.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n\\n        conf = defaultdict(list)\\n        conf[1] = [[1,1],[2,2],[2,1],[1,2]]  ##4 possible blocks when i==j\\n        conf[2] = [[0,2],[1,2]]  ##2 possible blocks when i>j\\n        conf[3] = [[2,0],[2,1]]  ##2 possible blocks when i<j\\n        # @cache\\n        def dp(i,j):\\n            nonlocal conf,n,memo\\n            tempcount = 0\\n\\n            if i==n and j==n:\\n                return 1\\n            if i>n or j>n:\\n                return 0\\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n\\n            if (i==j):\\n                for c in conf[1]:\\n                    tempcount += dp(i+c[0],j+c[1])\\n            if (i>j):\\n                for c in conf[2]:\\n                    tempcount += dp(i+c[0],j+c[1])\\n            if (i<j):\\n                for c in conf[3]:\\n                    tempcount += dp(i+c[0],j+c[1])\\n            \\n            memo[(i,j)] = tempcount\\n            return tempcount\\n        \\n        memo = {}\\n        res = dp(0,0)\\n        \\n        return res%(10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n\\n        conf = defaultdict(list)\\n        conf[1] = [[1,1],[2,2],[2,1],[1,2]]  ##4 possible blocks when i==j\\n        conf[2] = [[0,2],[1,2]]  ##2 possible blocks when i>j\\n        conf[3] = [[2,0],[2,1]]  ##2 possible blocks when i<j\\n        # @cache\\n        def dp(i,j):\\n            nonlocal conf,n,memo\\n            tempcount = 0\\n\\n            if i==n and j==n:\\n                return 1\\n            if i>n or j>n:\\n                return 0\\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n\\n            if (i==j):\\n                for c in conf[1]:\\n                    tempcount += dp(i+c[0],j+c[1])\\n            if (i>j):\\n                for c in conf[2]:\\n                    tempcount += dp(i+c[0],j+c[1])\\n            if (i<j):\\n                for c in conf[3]:\\n                    tempcount += dp(i+c[0],j+c[1])\\n            \\n            memo[(i,j)] = tempcount\\n            return tempcount\\n        \\n        memo = {}\\n        res = dp(0,0)\\n        \\n        return res%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947365,
                "title": "python-solution-with-explanation-using-dp",
                "content": "class Solution:\\n\\n    def numTilings(self, n: int) -> int:\\n        dp = [0] * (n + 1)\\n        dp[0] = 1\\n        dp[1] = 1\\n        if n < 2: return dp[n]\\n            \\n        dp[2] = 2\\n        mod = 10**9 + 7\\n        \\n        for i in range(3, n + 1):\\n            dp[i] = (2*dp[i - 1] + dp[i - 3]) % mod\\n            \\n        return dp[n]\\n        \\n        \\n        \\n#For understanding\\n\\n\\n\"\"\"\\ndp[n] = dp[n-1] + dp[n-2] + dp[n-3] * 2 + ... dp[0] * 2:\\nFor all f(n-1), it can be transformed to f(n) by appending a domino |, hence f(n - 1) * 1.\\nFor all f(n - 2), though f(2) contains 2 cases: = and ||, however the case || has been covered by f(n - 1) plus |,\\nso literally there is only one distinct way to transform f(n-2) to f(n), hence f(n - 2) * 1.\\n\\nFor all f(n - i) where i > 2, the ways complementing them to f(n) by dominoes (either horizontal or vertical domino) have been covered by f(n - 1) and f(n - 2),\\nhence the remaining distinct ways are either appending triminoes or combination of triminoes and dominoes. And there are always only 2 ways to do this (as demonstrated in the picture in this post), all of them can be considered as derived from either f(3) or f(4) by adding dominoes.\\n\\n#. dp[n - 1], and dp[n - 2] have one way to transform to dp[n]\\n#. dp[n - 3], ..., dp[1], dp[0], have two way to transform to dp[n]\\n  so,         dp[n] = dp[n-1] + dp[n-2] + 2 * (dp[n-3] + ... + dp[0]) -- E1\\n  shift one:  dp[n-1] = dp[n-2] + dp[n-3] + 2 * (dp[n-4] + ... + dp[0]) -- E2\\n E1 - E2:     dp[n] - dp[n-1] = dp[n-1] + dp[n-3]  \\n E1 - E2:     --> dp[n] = 2*dp[n-1] + dp[n-3]\\n\"\"\"\\nplz upvote if you like it!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n\\n    def numTilings(self, n: int) -> int:\\n        dp = [0] * (n + 1)\\n        dp[0] = 1\\n        dp[1] = 1\\n        if n < 2: return dp[n]\\n            \\n        dp[2] = 2\\n        mod = 10**9 + 7\\n        \\n        for i in range(3, n + 1):\\n            dp[i] = (2*dp[i - 1] + dp[i - 3]) % mod\\n            \\n        return dp[n]\\n        \\n        \\n        \\n#For understanding\\n\\n\\n\"\"\"\\ndp[n] = dp[n-1] + dp[n-2] + dp[n-3] * 2 + ... dp[0] * 2:\\nFor all f(n-1), it can be transformed to f(n) by appending a domino |, hence f(n - 1) * 1.\\nFor all f(n - 2), though f(2) contains 2 cases: = and ||, however the case || has been covered by f(n - 1) plus |,\\nso literally there is only one distinct way to transform f(n-2) to f(n), hence f(n - 2) * 1.\\n\\nFor all f(n - i) where i > 2, the ways complementing them to f(n) by dominoes (either horizontal or vertical domino) have been covered by f(n - 1) and f(n - 2),\\nhence the remaining distinct ways are either appending triminoes or combination of triminoes and dominoes. And there are always only 2 ways to do this (as demonstrated in the picture in this post), all of them can be considered as derived from either f(3) or f(4) by adding dominoes.\\n\\n#. dp[n - 1], and dp[n - 2] have one way to transform to dp[n]\\n#. dp[n - 3], ..., dp[1], dp[0], have two way to transform to dp[n]\\n  so,         dp[n] = dp[n-1] + dp[n-2] + 2 * (dp[n-3] + ... + dp[0]) -- E1\\n  shift one:  dp[n-1] = dp[n-2] + dp[n-3] + 2 * (dp[n-4] + ... + dp[0]) -- E2\\n E1 - E2:     dp[n] - dp[n-1] = dp[n-1] + dp[n-3]  \\n E1 - E2:     --> dp[n] = 2*dp[n-1] + dp[n-3]\\n\"\"\"\\nplz upvote if you like it!",
                "codeTag": "Java"
            },
            {
                "id": 2945687,
                "title": "dp-solution-o-n-time-and-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs this problem includes tromino, it can happen that one column is partially filled, we will need an extra state ```filled``` to provide us with info if the column is partially filled or not.\\n\\nSo there will be two states in our dp solution ```col``` and ```filled```.\\n\\nCase 1: If the column is partially filled then we have two choices, first is to use a valid domino, which will result in partial filling in next column and second choice is to use tromino which will remove the partial filling.\\n\\nCase 2: If the column is not prtially filled, then we can either choose one vertical domino and move to ```col+1```, or use two horizontal domino and move to ```col+2``` both of these will not result in partial filling but if we choose to use tromino we will have a partial filling at ```col+1```. \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int recurse(int col, int filled,vector<vector<long long int>> &dp){\\n        int n = dp.size();\\n        if(col >= n || (col==n-1 && filled==0)) return 1;\\n        if(col == n-1 && filled == 1) return 0;\\n\\n        if(dp[col][filled] != -1) return dp[col][filled];\\n        if(filled == 0){\\n                return dp[col][filled] = (recurse(col+2,0,dp)+(2*recurse(col+1,1,dp))+recurse(col+1,0,dp))%1000000007;\\n        }\\n        else{\\n            return dp[col][filled]= (recurse(col+1,1,dp) + recurse(col+2,0,dp))%1000000007;\\n        }\\n\\n        return 0;\\n    }\\n    int numTilings(int n) {\\n        vector<vector<long long int>> dp(n,vector<long long int>(2,-1));\\n\\n        return recurse(0,0,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```filled```\n```col```\n```filled```\n```col+1```\n```col+2```\n```col+1```\n```\\nclass Solution {\\npublic:\\n    long long int recurse(int col, int filled,vector<vector<long long int>> &dp){\\n        int n = dp.size();\\n        if(col >= n || (col==n-1 && filled==0)) return 1;\\n        if(col == n-1 && filled == 1) return 0;\\n\\n        if(dp[col][filled] != -1) return dp[col][filled];\\n        if(filled == 0){\\n                return dp[col][filled] = (recurse(col+2,0,dp)+(2*recurse(col+1,1,dp))+recurse(col+1,0,dp))%1000000007;\\n        }\\n        else{\\n            return dp[col][filled]= (recurse(col+1,1,dp) + recurse(col+2,0,dp))%1000000007;\\n        }\\n\\n        return 0;\\n    }\\n    int numTilings(int n) {\\n        vector<vector<long long int>> dp(n,vector<long long int>(2,-1));\\n\\n        return recurse(0,0,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944263,
                "title": "simple-java-solution-beats-100-with-o-n-with-explanation",
                "content": "* Mathematical  Analysis\\n   Case-----------Answer\\n   n = 1__________1\\n   n = 2__________2\\n   n = 3__________5\\n   n = 4__________11\\n   n = 5__________24\\n\\n   so the series is following \\n    f(n) = f(n-1)*2 + f(n-3)                    \\n\\n*--------------------------------------------------------------\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if (n == 1) return 1;\\n        if (n == 2) return 2;\\n        long[] dp = new long[n + 1];\\n        int mod = 1000000007;\\n        dp[0] = 1; dp[1] = 1; dp[2] = 2;\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % mod;\\n        }\\n        return (int) dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if (n == 1) return 1;\\n        if (n == 2) return 2;\\n        long[] dp = new long[n + 1];\\n        int mod = 1000000007;\\n        dp[0] = 1; dp[1] = 1; dp[2] = 2;\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % mod;\\n        }\\n        return (int) dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893115,
                "title": "sneeit-solution-domino-and-tromino-tiling-with-explanation",
                "content": "(This problem is solved using Dynamic Programming that you can learn at: **https://sneeit.com/dynamic-progamming/**)\\n\\n.\\n____\\n# Explanation\\nYou can form a board i from\\n* board i - 1 by adding ![image](https://assets.leetcode.com/users/images/99002dbe-1c70-4fbd-95e2-7c75a97f8ca8_1648522000.2958794.png)\\n* board i - 2 by adding ![image](https://assets.leetcode.com/users/images/e386bb15-1ba4-4388-a49e-6bd507c29217_1648522039.1159534.png)\\n* board i - 3 by adding ![image](https://assets.leetcode.com/users/images/ec0b84fb-e0da-4959-9ea1-3efe45209ccd_1648522175.4989698.png) or ![image](https://assets.leetcode.com/users/images/3bcefba5-a1c4-479f-97e5-7058753e3b46_1657612458.5683823.png)\\n* board i - 4 by adding ![image](https://assets.leetcode.com/users/images/265834f4-c062-42e3-a3e8-65812f996c7f_1648522281.5093086.png) or ![image](https://assets.leetcode.com/users/images/92497a5d-049c-443a-b50c-f3df0ef61905_1648522286.097149.png)\\n* board i - 5 by adding ![image](https://assets.leetcode.com/users/images/0f123209-94e9-43b1-acae-5c061f8fb559_1648522367.9747984.png) or ![image](https://assets.leetcode.com/users/images/03d44911-1155-437c-8dd3-1baf54cabb6f_1648522391.3840377.png)\\n* board i - 6 to board 0 can use the same tile textures like board i - 5 to build board i\\n\\nSo the total ways to build board i is\\nways[i] = ways[i-1] + ways[i-2] + 2 * ( ways[i-3] + ways[i-4] + ... + ways[0] )\\n\\nIf we extract the formula like this\\nways[i] = ways[i-1] + ***ways[i-2] + ways[i-3] + 2  ( ways[i-4] + ... + ways[0] )*** + ways[i-3]\\nways[i] = ways[i-1] + **ways[i-1]** + ways[i-3]\\nways[i] = 2 * ways[i-1] + ways[i-3]\\n\\nThere are always 4 variables involved in calculating our results so we can use an array of 4 to reduce our space. And here is the final code\\n.\\n____\\n# Bottom-Up O(n) Time, O(1) Space\\n```\\nvar numTilings = function(n) {\\n    let mod = 10 ** 9 + 7;    \\n    let len = 4;\\n    let ways = new Array(len).fill(0);\\n\\n    // base cases\\n    ways[0] = 1;\\n    ways[1] = 1;\\n    ways[2] = 2;\\n\\n    // already calculated above\\n    if (n < len - 1) {\\n        return ways[n];\\n    }    \\n\\n    // use % len to circulate values inside our array\\n    for (var i = len - 1; i <= n;i++) {        \\n        ways[i % len] = ( \\n            ways[(len + i - 1) % len] * 2\\n            + \\n            ways[(len + i - 3) % len] \\n        ) % mod;          \\n    }\\n    \\n    return ways[(i - 1) % len];\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar numTilings = function(n) {\\n    let mod = 10 ** 9 + 7;    \\n    let len = 4;\\n    let ways = new Array(len).fill(0);\\n\\n    // base cases\\n    ways[0] = 1;\\n    ways[1] = 1;\\n    ways[2] = 2;\\n\\n    // already calculated above\\n    if (n < len - 1) {\\n        return ways[n];\\n    }    \\n\\n    // use % len to circulate values inside our array\\n    for (var i = len - 1; i <= n;i++) {        \\n        ways[i % len] = ( \\n            ways[(len + i - 1) % len] * 2\\n            + \\n            ways[(len + i - 3) % len] \\n        ) % mod;          \\n    }\\n    \\n    return ways[(i - 1) % len];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1620920,
                "title": "easy-to-understand-in-c-d-p-bottom-up",
                "content": "**This is the best Approach by D.p(Bottom-up)**\\ndp[0]=0;\\ndp[1]=1;\\ndp[2]=2;\\ndp[3]=5;\\n**Than by Observation:-**\\n   dp[4]=( 2*dp[i-1]+dp[i-3])\\n            =2(5)+1;\\n\\t\\t\\t=11\\n\\nclass Solution {\\npublic:\\n\\n    #define mod 1000000007\\n    int numTilings(int n) {\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        if(n==3){\\n            return 5;\\n        }\\n        vector<int>dp(n+1,0);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        for(int i=4;i<=n;i++){\\n            dp[i] = ((2*(dp[i-1])%mod)%mod +(dp[i-3])%mod)%mod;\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    #define mod 1000000007\\n    int numTilings(int n) {\\n        if(n==1){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1370968,
                "title": "c-dp-solution-o-n-time-and-space-with-intuition",
                "content": "```\\nint numTilings(int n) {\\n        \\n        if(n == 1)\\n            return 1;\\n        \\n        long long mod = 1e9+7;\\n     \\n        vector<long long int> dp1(n + 1, 0);\\n        vector<long long int> dp2(n + 1, 0);\\n        vector<long long int> dp3(n + 1, 0);\\n        \\n        /*\\n\\t\\t\\tUsing 1-indexed Levels\\n            dp1[i] denotes the number of ways with all cols from 1 to i filled\\n            dp2[i] denotes the number of ways with all cols from 1 to i - 1 filled and only top grid in col i is filled\\n            dp3[i] denotes the number of ways with all cols from 1 to i - 1 filled and only bottom grid in col i is filled\\n        \\n            to return dp1[n]\\n            \\n            Base Cases:\\n            dp1[1] = 1\\n            dp1[2] = 2\\n            \\n            dp2[1] = 0; dp2[2] = 1\\n            dp3[1] = 0; dp3[2] = 1;\\n            \\n            DP relation: (for all i >= 3)\\n            \\n            dp1[i] = dp1[i - 1] (add 1 vertical domino) + dp1[i - 2] (add 2-horizontal dominoes)  + dp2[i - 1] (add 1 tromino in _| manner) + dp3[i - 1] (add 1 tromino such that top space in i - 1 col and i col gets filled)\\n            \\n            dp2[i] = dp1[i - 2] (put one tribonaaci) + dp3[i - 1] (put on domino in horizontal fashion)\\n            \\n            similarly => dp3[i] = dp1[i - 2] + dp2[i - 1]\\n        */\\n        \\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n\\n        dp2[1] = 0;\\n        dp2[2] = 1;\\n        \\n        dp3[1] = 0;\\n        dp3[2] = 1;\\n\\n        \\n        for(int i = 3 ; i <= n ; i++)\\n        {\\n            dp1[i] = (dp1[i - 1] + dp1[i - 2] + dp2[i - 1]+ dp3[i - 1]) % mod;\\n            dp2[i] = (dp1[i - 2] + dp3[i - 1]) % mod;\\n            dp3[i] = (dp1[i - 2] + dp2[i - 1]) % mod;\\n        }\\n        \\n        return dp1[n];\\n    }\\n```\\n\\nYou can see by symmetry that the values of dp2[i] and dp3[i] would be the same. Hence we can reduce the space constraint by a whole vector. However, at the same time it is important to not that the two sub-problems are different and not the same.\\n\\n```\\n//Improved DP\\n\\n  for(int i = 3 ; i <= n ; i++)\\n        {\\n            dp1[i] = (dp1[i - 1] + dp1[i - 2] + 2*dp2[i - 1]) % mod;\\n            dp2[i] = (dp1[i - 2] + dp2[i - 1]) % mod;\\n        }\\n        \\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint numTilings(int n) {\\n        \\n        if(n == 1)\\n            return 1;\\n        \\n        long long mod = 1e9+7;\\n     \\n        vector<long long int> dp1(n + 1, 0);\\n        vector<long long int> dp2(n + 1, 0);\\n        vector<long long int> dp3(n + 1, 0);\\n        \\n        /*\\n\\t\\t\\tUsing 1-indexed Levels\\n            dp1[i] denotes the number of ways with all cols from 1 to i filled\\n            dp2[i] denotes the number of ways with all cols from 1 to i - 1 filled and only top grid in col i is filled\\n            dp3[i] denotes the number of ways with all cols from 1 to i - 1 filled and only bottom grid in col i is filled\\n        \\n            to return dp1[n]\\n            \\n            Base Cases:\\n            dp1[1] = 1\\n            dp1[2] = 2\\n            \\n            dp2[1] = 0; dp2[2] = 1\\n            dp3[1] = 0; dp3[2] = 1;\\n            \\n            DP relation: (for all i >= 3)\\n            \\n            dp1[i] = dp1[i - 1] (add 1 vertical domino) + dp1[i - 2] (add 2-horizontal dominoes)  + dp2[i - 1] (add 1 tromino in _| manner) + dp3[i - 1] (add 1 tromino such that top space in i - 1 col and i col gets filled)\\n            \\n            dp2[i] = dp1[i - 2] (put one tribonaaci) + dp3[i - 1] (put on domino in horizontal fashion)\\n            \\n            similarly => dp3[i] = dp1[i - 2] + dp2[i - 1]\\n        */\\n        \\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n\\n        dp2[1] = 0;\\n        dp2[2] = 1;\\n        \\n        dp3[1] = 0;\\n        dp3[2] = 1;\\n\\n        \\n        for(int i = 3 ; i <= n ; i++)\\n        {\\n            dp1[i] = (dp1[i - 1] + dp1[i - 2] + dp2[i - 1]+ dp3[i - 1]) % mod;\\n            dp2[i] = (dp1[i - 2] + dp3[i - 1]) % mod;\\n            dp3[i] = (dp1[i - 2] + dp2[i - 1]) % mod;\\n        }\\n        \\n        return dp1[n];\\n    }\\n```\n```\\n//Improved DP\\n\\n  for(int i = 3 ; i <= n ; i++)\\n        {\\n            dp1[i] = (dp1[i - 1] + dp1[i - 2] + 2*dp2[i - 1]) % mod;\\n            dp2[i] = (dp1[i - 2] + dp2[i - 1]) % mod;\\n        }\\n        \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136076,
                "title": "simple-dp-explained-c",
                "content": "Explaination:\\ndp[i][1] -> represents number of ways to fill i tiles(length) and ending tile is completely filled\\ndp[i][0] -> represents number of ways to fill i tiles(length) but ending tile has only one tile filled out of the two.\\n\\nSo we derive the relation:\\ndp[i][1] = dp[i-1][1] (*fill tiles till i-1 and put a 2x1 tile standing with height as 2*)\\n\\\\+ dp[i-2][1] (*fill tiles till i-2 and put two 2x1 tiles sitting on top of each other with length as 2*)  \\n\\\\+ dp[i-1][0] (*fill tiles till i-2 completely but fill only one tile in i-1, and we put a L-shaped tile on the remaining*)\\n\\ndp[i][0] = (dp[i-2][1]\\\\*2) (*completely fill till i-2 and then we can fill the last two tiles by putting 1 L-shaped tile, so that last tile\\'s one part remains*)\\n\\\\+ dp[i-1][0] (*fill with last tile remaining a part, and add 2x1 tile in the end horizontally*)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        int mod = 1000000007;\\n        int dp[N+1][2];\\n        dp[0][1] = 1, dp[0][0] = 0;\\n        dp[1][1] = 1, dp[1][0] = 0;\\n        \\n        for(int i=2; i<N+1; i++){\\n            dp[i][1] = ((dp[i-1][1] + dp[i-2][1])%mod + (dp[i-1][0])%mod)%mod;\\n            dp[i][0] = ((dp[i-2][1]*2)%mod + (dp[i-1][0])%mod)%mod;\\n        }\\n        return dp[N][1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        int mod = 1000000007;\\n        int dp[N+1][2];\\n        dp[0][1] = 1, dp[0][0] = 0;\\n        dp[1][1] = 1, dp[1][0] = 0;\\n        \\n        for(int i=2; i<N+1; i++){\\n            dp[i][1] = ((dp[i-1][1] + dp[i-2][1])%mod + (dp[i-1][0])%mod)%mod;\\n            dp[i][0] = ((dp[i-2][1]*2)%mod + (dp[i-1][0])%mod)%mod;\\n        }\\n        return dp[N][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116536,
                "title": "easy-and-very-concise-clear-in-java",
                "content": "```\nclass Solution {\n    static final int mod = 1000000007;\n    public int numTilings(int N) {\n        int dp[] = new int[N + 10];\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[2] = 2;\n        dp[3] = 5;\n        for(int i = 4 ; i <= N; i++){\n            dp[i] = dp[i - 1] * 2 % mod + dp[i - 3] % mod;\n            dp[i] %= mod;\n        }\n        return dp[N];\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    static final int mod = 1000000007;\n    public int numTilings(int N) {\n        int dp[] = new int[N + 10];\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[2] = 2;\n        dp[3] = 5;\n        for(int i = 4 ; i <= N; i++){\n            dp[i] = dp[i - 1] * 2 % mod + dp[i - 3] % mod;\n            dp[i] %= mod;\n        }\n        return dp[N];\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 116531,
                "title": "o-1-time-o-n-space-solution-3ms",
                "content": "    constexpr uint64_t CON = 1000000007;\n    \n    constexpr uint64_t func(int i) {\n        if (i == 0) return 1;\n        if (i == 1) return 1;\n        if (i == 2) return 2;\n        return (func(i - 1) * 2 % CON + func(i - 3)) % CON;\n    }\n    \n    template<uint64_t... i>\n    constexpr auto calc(index_sequence<i...>) {\n        return array<uint64_t, sizeof...(i)>{func(i)...};\n    }\n    \n    template<uint64_t size>\n    constexpr auto calc() {\n        return calc(make_index_sequence<size>());\n    }\n    \n    constexpr auto f = calc<1000>();\n    \n    class Solution {\n    public:\n        int numTilings(int N) {\n            return f[N];\n        }\n    };",
                "solutionTags": [],
                "code": "class Solution {\n    public:\n        int numTilings(int N) {\n            return f[N];\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3237546,
                "title": "recursion-solution-state-machine-approach",
                "content": "# Intuition\\nthink like in start we have the 0th column empty so we need to fill it first we have four ways to fill it(here 0 means emplty cell 1 means filled) see last ifelse condition. u^d means if upper is epmty ans lower is filled or vice verca then we have 2 ways use a trainagular peice or a horizonatal peice . if both is 1 then simply we ask i+1 for 0 0.\\nbase case is wehn we go ou of block i.e i==n then both up and down shuould be 0 0 \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nstate machine approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst unsigned int M = 1000000007;\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[1000][2][2];\\n    int numTilings(int n) {\\n        this->n=n;\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,0);\\n        // return 0;\\n        \\n    }\\n    int f(int i,bool u , bool d){\\n        if(i==n ){\\n            if(!u && !d) return 1;\\n            return 0;\\n        }\\n        if(dp[i][u][d]!=-1) return dp[i][u][d];\\n        int ans=0;\\n        \\n        if(u^d){\\n            ans+=f(i+1,1,1)%M;//1 traingular \\n            ans+=f(i+1,!u,!d)%M;//1 horizontal \\n        }\\n        \\n        else if(u==1 && d==1) ans+=f(i+1,0,0)%M;//just empty cel;\\n        else if(u==0 && d==0){\\n            ans+=f(i+1,1,1)%M;//2 horizontal\\n            ans+=f(i+1,0,0)%M;//1 vertical\\n            ans+=f(i+1,0,1)%M;//1 traiangualar \\n            ans+=f(i+1,1,0)%M;//1 down triangular\\n        }\\n        return dp[i][u][d]=ans%M;\\n    }\\n};\\n```\\n\\nplease upvote if you liked it.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nconst unsigned int M = 1000000007;\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[1000][2][2];\\n    int numTilings(int n) {\\n        this->n=n;\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,0);\\n        // return 0;\\n        \\n    }\\n    int f(int i,bool u , bool d){\\n        if(i==n ){\\n            if(!u && !d) return 1;\\n            return 0;\\n        }\\n        if(dp[i][u][d]!=-1) return dp[i][u][d];\\n        int ans=0;\\n        \\n        if(u^d){\\n            ans+=f(i+1,1,1)%M;//1 traingular \\n            ans+=f(i+1,!u,!d)%M;//1 horizontal \\n        }\\n        \\n        else if(u==1 && d==1) ans+=f(i+1,0,0)%M;//just empty cel;\\n        else if(u==0 && d==0){\\n            ans+=f(i+1,1,1)%M;//2 horizontal\\n            ans+=f(i+1,0,0)%M;//1 vertical\\n            ans+=f(i+1,0,1)%M;//1 traiangualar \\n            ans+=f(i+1,1,0)%M;//1 down triangular\\n        }\\n        return dp[i][u][d]=ans%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947380,
                "title": "pyhton-easy-to-undestand-formula-explanation-98-in-run-time",
                "content": "**The Formule:**\\nif i = 1 -> 1\\nif i = 2 -> 2 \\nif i = 3 -> 5\\nelse:\\nA[i] = A[i-1] * 2 + A[i-3]\\n\\n\\n<table>\\n<tr>\\n<td><b>n</b></td>\\n<td><b>Output</b></td>\\n<td><b>Formula</b></td>\\n<td><b>Assignment</b></td>\\n</tr>\\n\\n<tr>\\n<td>1</td>\\n<td>1</td>\\n</tr>\\n\\n<tr>\\n<td>2</td>\\n<td>2</td>\\n</tr>\\n\\n<tr>\\n<td>3</td>\\n<td>5</td>\\n</tr>\\n\\n<tr>\\n<td>4</td>\\n<td>11</td>\\n<td>A[3] * 2 + A[1]</td>\\n<td>5 * 2 + 1 = 11</td>\\n</tr>\\n\\n<tr>\\n<td>5</td>\\n<td>24</td>\\n<td>A[4] * 2 + A[2]</td>\\n<td>11 * 2 + 2 = 24</td>\\n</tr>\\n\\n<tr>\\n<td>6</td>\\n<td>53</td>\\n<td>A[5] * 2 + A[3]</td>\\n<td>24 * 2 + 5 = 53</td>\\n</tr>\\n\\n<tr>\\n<td>7</td>\\n<td>117</td>\\n<td>A[6] * 2 + A[4]</td>\\n<td>53 * 2 + 11 = 117</td>\\n</tr>\\n\\n<tr>\\n<td>8</td>\\n<td>258</td>\\n<td>A[7] * 2 + A[5]</td>\\n<td>117 * 2 + 24 = 258</td>\\n</tr>\\n</table>\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        helper = [1, 2, 5]\\n        if n <= 3:\\n            return helper[n-1]\\n        for i in range(4, n+1):\\n            ans = helper[-1] *2 +helper[0]\\n            helper.pop(0)\\n            helper.append(ans)\\n        return helper[-1]%(10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        helper = [1, 2, 5]\\n        if n <= 3:\\n            return helper[n-1]\\n        for i in range(4, n+1):\\n            ans = helper[-1] *2 +helper[0]\\n            helper.pop(0)\\n            helper.append(ans)\\n        return helper[-1]%(10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945305,
                "title": "c-solution-for-domino-and-tromino-tiling-problem-using-dp",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to use dynamic programming to store and build upon previously calculated solutions.\\n\\nThe function starts by initializing a vector called dp with the first 3 elements already set to the values 1, 2, and 5. These values represent the number of ways to tile a 1x1 grid, a 2x1 grid, and a 3x1 grid, respectively.\\n\\nThe function then checks if the input value n is less than or equal to 3. If it is, it returns the value stored in dp at the index of n, as these are already pre-calculated and do not need further processing.\\n\\nIf n is greater than 3, the function enters a for loop that starts at 4 and continues until it reaches n. For each iteration, it calculates the number of ways to tile a grid using the previous solutions stored in dp. It does this by setting **dp[i]** equal to 2 times **dp[i-1]** plus **dp[i-3]**. It then takes the modulus of this value with the constant mod, which is set to 1e9+7.\\n\\nFinally, the function returns the value stored in dp at the index of n, taking the modulus with mod once again.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is **O(n)** because the for loop iterates n times, and each iteration involves a constant number of operations (calculating the value of dp[i] and taking the modulus).\\n\\n- Space complexity:\\nThe space complexity is **O(n)** because the solution uses a vector called dp to store the calculated solutions. The size of this vector is directly proportional to the input size n, making the space complexity O(n).\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    const long long mod = 1e9+7;\\npublic:\\n    int numTilings(int n) {\\n        vector<long long> dp(1000, 0);\\n        //If n<=3\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        if(n<=3){\\n            return dp[n];\\n        }\\n        //If n>3\\n        for(int i=4;i<=n;i++){\\n            dp[i]=2*dp[i-1]+dp[i-3];\\n            dp[i]%=mod;\\n        }\\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const long long mod = 1e9+7;\\npublic:\\n    int numTilings(int n) {\\n        vector<long long> dp(1000, 0);\\n        //If n<=3\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        if(n<=3){\\n            return dp[n];\\n        }\\n        //If n>3\\n        for(int i=4;i<=n;i++){\\n            dp[i]=2*dp[i-1]+dp[i-3];\\n            dp[i]%=mod;\\n        }\\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753425,
                "title": "c-top-bottom-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    const int N = 1e9 +7;\\n    int dp[1001][1001];\\n    int rec(int row1, int row2){\\n        \\n        if(row1 ==0 and row2==0)\\n            return 1;\\n        \\n        if(row1<0 or row2<0)\\n            return 0;\\n        \\n        if(dp[row1][row2] != 0)\\n            return dp[row1][row2] % N;\\n        \\n        int ans=0;\\n        \\n        if(row1 == row2){\\n            ans= ((ans%N) + (rec(row1-2,row2-2)) %N)%N;\\n            ans= ((ans%N) + (rec(row1-1,row2-1)) %N)%N;\\n            ans= ((ans%N) + (rec(row1-2,row2-1)) %N)%N;\\n            ans= ((ans%N) + (rec(row1-1,row2-2)) %N)%N;    \\n        }\\n        \\n        if(row1 > row2){\\n            \\n            ans = ((ans%N) + (rec(row1 -2,row2)) %N)%N;\\n            ans = ((ans%N) + (rec(row1-2,row2-1)) %N)%N;\\n            \\n        }\\n        \\n        if(row1 < row2){\\n            \\n            ans = ((ans%N) + (rec(row1,row2-2)) %N)%N;\\n            ans = ((ans%N) + (rec(row1-1,row2-2)) %N)%N;\\n            \\n        }\\n            \\n        return dp[row1][row2] = ans %N;\\n    }\\n    \\n    int numTilings(int n) {\\n        return rec(n,n);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    const int N = 1e9 +7;\\n    int dp[1001][1001];\\n    int rec(int row1, int row2){\\n        \\n        if(row1 ==0 and row2==0)\\n            return 1;\\n        \\n        if(row1<0 or row2<0)\\n            return 0;\\n        \\n        if(dp[row1][row2] != 0)\\n            return dp[row1][row2] % N;\\n        \\n        int ans=0;\\n        \\n        if(row1 == row2){\\n            ans= ((ans%N) + (rec(row1-2,row2-2)) %N)%N;\\n            ans= ((ans%N) + (rec(row1-1,row2-1)) %N)%N;\\n            ans= ((ans%N) + (rec(row1-2,row2-1)) %N)%N;\\n            ans= ((ans%N) + (rec(row1-1,row2-2)) %N)%N;    \\n        }\\n        \\n        if(row1 > row2){\\n            \\n            ans = ((ans%N) + (rec(row1 -2,row2)) %N)%N;\\n            ans = ((ans%N) + (rec(row1-2,row2-1)) %N)%N;\\n            \\n        }\\n        \\n        if(row1 < row2){\\n            \\n            ans = ((ans%N) + (rec(row1,row2-2)) %N)%N;\\n            ans = ((ans%N) + (rec(row1-1,row2-2)) %N)%N;\\n            \\n        }\\n            \\n        return dp[row1][row2] = ans %N;\\n    }\\n    \\n    int numTilings(int n) {\\n        return rec(n,n);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390413,
                "title": "rust-dp-with-detailed-recursive-relation",
                "content": "```\\nimpl Solution {\\n    pub fn num_tilings(n: i32) -> i32 {\\n        // DP by considering filling the last column of space\\n        // T(n) = T(n - 1)      | end with one vertical domino\\n        //      + T(n - 2)      | end with two horizontal domino\\n        //      + T_up(n - 1)   | end with trimino filling the former lower grid\\n        //      + T_down(n - 1) | end with trimino filling the former upper grid//\\n        // T_up(n): having an unfilled lower grid, therefore it can be formed by\\n        // T_up(n) = T(n - 2)      | Fully filled followed with a trimino filling lower grid\\n        //         + T_down(n - 1) | T_down(n - 1) with an upper horizontal domino\\n        // T_down(n): equivalent as above\\n        // T_down(n) = T(n - 2)\\n        //           + T_up(n - 1)\\n\\n        // To sum up:\\n        // T(n) = T(n-1) + T(n-2) + T_up(n-1) + T_down(n-1)\\n        // T_up(n-1) = T_down(n-2) + T(n-3)\\n        // T_down(n-1) = T_up(n-2) + T(n-3)\\n        // --> T(n) = T(n-1) + T(n-2) + T_down(n-2) + T(n-3) + T_up(n-2) + T(n-3)\\n        // --> T(n) = T(n-1) + T(n-3) + [T(n-2) + T(n-3) + T_up(n-2) + T_down(n-2)]\\n        // --> T(n) = 2 * T(n-1) + T(n-3)\\n\\n        // Since every state change only concerns the previous three values\\n        // Space can be reduced to O(1) in three variables\\n\\n        // Base case by reverse calculation:\\n        // Initially, T(0) = 0, T(1) = 1, T(2) = 2, T(3) = 5 ...\\n        // Thus, T(2) = 2 * T(1) + T(-1) --> T(-1) = 0\\n        //       T(1) = 2 * T(0) + T(-2) --> T(-2) = -1\\n\\n        const MOD: i32 = 1_000_000_007;\\n        // T(n-3), T(n-2), T(n-1) respectively\\n        let (mut x, mut y, mut z) = (-1, 0, 1);\\n        for _ in 1..=n {\\n            let cur = (2 * z % MOD + x) % MOD; // mod everytime to prevent overflow\\n            x = y;\\n            y = z;\\n            z = cur;\\n        }\\n        z\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_tilings(n: i32) -> i32 {\\n        // DP by considering filling the last column of space\\n        // T(n) = T(n - 1)      | end with one vertical domino\\n        //      + T(n - 2)      | end with two horizontal domino\\n        //      + T_up(n - 1)   | end with trimino filling the former lower grid\\n        //      + T_down(n - 1) | end with trimino filling the former upper grid//\\n        // T_up(n): having an unfilled lower grid, therefore it can be formed by\\n        // T_up(n) = T(n - 2)      | Fully filled followed with a trimino filling lower grid\\n        //         + T_down(n - 1) | T_down(n - 1) with an upper horizontal domino\\n        // T_down(n): equivalent as above\\n        // T_down(n) = T(n - 2)\\n        //           + T_up(n - 1)\\n\\n        // To sum up:\\n        // T(n) = T(n-1) + T(n-2) + T_up(n-1) + T_down(n-1)\\n        // T_up(n-1) = T_down(n-2) + T(n-3)\\n        // T_down(n-1) = T_up(n-2) + T(n-3)\\n        // --> T(n) = T(n-1) + T(n-2) + T_down(n-2) + T(n-3) + T_up(n-2) + T(n-3)\\n        // --> T(n) = T(n-1) + T(n-3) + [T(n-2) + T(n-3) + T_up(n-2) + T_down(n-2)]\\n        // --> T(n) = 2 * T(n-1) + T(n-3)\\n\\n        // Since every state change only concerns the previous three values\\n        // Space can be reduced to O(1) in three variables\\n\\n        // Base case by reverse calculation:\\n        // Initially, T(0) = 0, T(1) = 1, T(2) = 2, T(3) = 5 ...\\n        // Thus, T(2) = 2 * T(1) + T(-1) --> T(-1) = 0\\n        //       T(1) = 2 * T(0) + T(-2) --> T(-2) = -1\\n\\n        const MOD: i32 = 1_000_000_007;\\n        // T(n-3), T(n-2), T(n-1) respectively\\n        let (mut x, mut y, mut z) = (-1, 0, 1);\\n        for _ in 1..=n {\\n            let cur = (2 * z % MOD + x) % MOD; // mod everytime to prevent overflow\\n            x = y;\\n            y = z;\\n            z = cur;\\n        }\\n        z\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 804473,
                "title": "beats-100-2-dp-n-1-dp-n-3-c",
                "content": "```\\nclass Solution {\\n    const int mod=1e9+7;\\npublic:\\n    /*dp[n]=dp[n-1]+dp[n-2]+ 2*(dp[n-3]+...+d[0])\\n=dp[n-1]+dp[n-2]+dp[n-3]+dp[n-3]+2*(dp[n-4]+...+d[0])\\n=dp[n-1]+dp[n-3]+(dp[n-2]+dp[n-3]+2*(dp[n-4]+...+d[0]))\\n=dp[n-1]+dp[n-3]+dp[n-1]\\n=2*dp[n-1]+dp[n-3]*/\\n    int numTilings(int n) {\\n        vector<int> dp(n+1);\\n        if(n==1)\\n            return 1;\\n        else if(n==2)\\n            return 2;\\n        else if(n==3)\\n            return 5;\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        for(int i=4;i<=n;i++)\\n        {\\n            dp[i]+=((long)dp[i-1]*2+(long)dp[i-3])%mod;\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    const int mod=1e9+7;\\npublic:\\n    /*dp[n]=dp[n-1]+dp[n-2]+ 2*(dp[n-3]+...+d[0])\\n=dp[n-1]+dp[n-2]+dp[n-3]+dp[n-3]+2*(dp[n-4]+...+d[0])\\n=dp[n-1]+dp[n-3]+(dp[n-2]+dp[n-3]+2*(dp[n-4]+...+d[0]))\\n=dp[n-1]+dp[n-3]+dp[n-1]\\n=2*dp[n-1]+dp[n-3]*/\\n    int numTilings(int n) {\\n        vector<int> dp(n+1);\\n        if(n==1)\\n            return 1;\\n        else if(n==2)\\n            return 2;\\n        else if(n==3)\\n            return 5;\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        for(int i=4;i<=n;i++)\\n        {\\n            dp[i]+=((long)dp[i-1]*2+(long)dp[i-3])%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 116546,
                "title": "using-recurrence-log-n-very-quick-log-n-in-java-can-run-with-n-1000000000",
                "content": "```\nclass Solution {\n    static final int mod = 1000000007;\n    long[][] base = {{0, 1, 0}, {0, 0, 1}, {1, 0, 2}};\n    public long[][] pow(int n){\n        if(n == 1){\n            long mt[][] = new long[3][3];\n            for(int i = 0; i < 3; i++){\n                for(int j = 0; j < 3; j++){\n                    mt[i][j] = base[i][j];\n                }\n            }\n            return mt;\n        }\n        long[][] f = pow(n / 2);\n        long tmp[][] = new long[3][3];\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                tmp[i][j] = 0;\n                for(int k = 0; k < 3; k++){\n                    tmp[i][j] += ((f[i][k] * f[k][j]) % mod);\n                    tmp[i][j] %= mod;\n                }\n            }\n        }\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                f[i][j] = tmp[i][j];\n            }\n        }\n        if(n % 2 == 1){\n            tmp = new long[3][3];\n            for(int i = 0; i < 3; i++){\n                for(int j = 0; j < 3; j++){\n                    tmp[i][j] = 0;\n                    for(int k = 0; k < 3; k++){\n                        tmp[i][j] += ((base[i][k] * f[k][j]) % mod);\n                        tmp[i][j] %= mod;\n                    }\n                }\n            }\n            for(int i = 0; i < 3; i++){\n                for(int j = 0; j < 3; j++){\n                    f[i][j] = tmp[i][j];\n                }\n            }\n        }\n        return f;\n    }\n    int a = 1, b = 2, c = 5;\n    public int numTilings(int N) {\n        int n = N;\n        if(n == 1) return a;\n        if(n == 2) return b;\n        if(n == 3) return c;\n        long result[][] = pow(N - 3);\n        long ans = (result[2][0] * a % mod + result[2][1] * b % mod) % mod + result[2][2] * c % mod;\n        int xx = (int)(ans % mod);\n        return xx;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    static final int mod = 1000000007;\n    long[][] base = {{0, 1, 0}, {0, 0, 1}, {1, 0, 2}};\n    public long[][] pow(int n){\n        if(n == 1){\n            long mt[][] = new long[3][3];\n            for(int i = 0; i < 3; i++){\n                for(int j = 0; j < 3; j++){\n                    mt[i][j] = base[i][j];\n                }\n            }\n            return mt;\n        }\n        long[][] f = pow(n / 2);\n        long tmp[][] = new long[3][3];\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                tmp[i][j] = 0;\n                for(int k = 0; k < 3; k++){\n                    tmp[i][j] += ((f[i][k] * f[k][j]) % mod);\n                    tmp[i][j] %= mod;\n                }\n            }\n        }\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                f[i][j] = tmp[i][j];\n            }\n        }\n        if(n % 2 == 1){\n            tmp = new long[3][3];\n            for(int i = 0; i < 3; i++){\n                for(int j = 0; j < 3; j++){\n                    tmp[i][j] = 0;\n                    for(int k = 0; k < 3; k++){\n                        tmp[i][j] += ((base[i][k] * f[k][j]) % mod);\n                        tmp[i][j] %= mod;\n                    }\n                }\n            }\n            for(int i = 0; i < 3; i++){\n                for(int j = 0; j < 3; j++){\n                    f[i][j] = tmp[i][j];\n                }\n            }\n        }\n        return f;\n    }\n    int a = 1, b = 2, c = 5;\n    public int numTilings(int N) {\n        int n = N;\n        if(n == 1) return a;\n        if(n == 2) return b;\n        if(n == 3) return c;\n        long result[][] = pow(N - 3);\n        long ans = (result[2][0] * a % mod + result[2][1] * b % mod) % mod + result[2][2] * c % mod;\n        int xx = (int)(ans % mod);\n        return xx;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947563,
                "title": "clean-solution-for-dp-dummy-with-images",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFirst we need to understand what possible states we can achieve at each width `i`. Apparently there are two states at each width `i`: fully filled and partially filled. Then we need to figure out the relationship between different states so that we can propagate to the next width `i + 1`. It\\'s helpful to look back from the complete board and see what\\'s the last step to take.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## Finding the Equations\\n\\nWe will use `f[i]` to denote fully filled state at width `i` and `p[i]` to denote partially filled state at width `i`, where \"partially filled\" means there is one and only one square missing at the end of the board.\\n    \\nTo achieve a fully filled state, we can start from the two aforementioned states:\\n\\n1. Fully filled states: There are two states we can use to get to `f[i]`: `f[i - 1]` and `f[i - 2]`. The following images illustrate how we can fill the board starting from `f[i - 1]` using a vertical domino and `f[i - 2]` using two horizontal dominos:\\n![1.png](https://assets.leetcode.com/users/images/abaae0d2-d302-4c09-a3ab-2ef9aab5dc6b_1671981645.5786984.png)\\n![2.png](https://assets.leetcode.com/users/images/f64fe341-9c6a-465e-9220-c0b8fe5be73b_1671981568.9936988.png)\\n\\n\\n2. Partially filled state: There are two symmetrical states that we can use. Since it\\'s symmetrical, we simply use `p[i - 1]` for both cases and the following images illustarte how a partially filled state `p[i-1]` is filled with a tromino to achieve `f[i]`.\\n![f3.png](https://assets.leetcode.com/users/images/6b0ac0fb-a726-4eb6-b630-3d2e259bb739_1671923920.569472.png)\\n![f4.png](https://assets.leetcode.com/users/images/371eb30d-033f-4f12-b85d-1f914b675104_1671923927.7636256.png)\\n\\nTherefore, there are total of 4 ways to achieve `f[i]`:\\n\\n`f[i] = f[i - 1] + f[i - 2] + 2 * p[i - 1]`\\n\\nNow we have the equation for `f[i]`. What about `p[i]`? By observation, we can find two ways to ahieve `p[i]`:\\n\\n1. From a fully filled state `f[i - 2]`: A tromino is added to a fuly filled state `f[i - 2]` to form a partially filled state `p[i]`.\\n![p2.png](https://assets.leetcode.com/users/images/0c8a0e55-7c94-4286-98db-ac2bc03ecf23_1671924284.977628.png)\\n\\n2. From a previous partially filled state `p[i - 1]`: A horizontal domino is added to a partially filled state `p[i - 1]` to form the next partially filled state `p[i]`.\\n![p1.png](https://assets.leetcode.com/users/images/e76622ec-7770-4283-bd71-b559b48be8b3_1671924298.2419508.png)\\n\\nNow we have the last piece of equation we need:\\n\\n`p[i] = p[i - 1] + f[i - 2]`\\n\\n*Due to symmetry, We can double the number of ways to achieve `p[i]` if we flip the board vertically. This symmetrical doubling (factor of 2x) is already considered in the calculation of `f[i]`. Therefore, it\\'s not considered here.*\\n\\n## Initial Values and Updating\\n\\nAt `i = 1`, the only thing we can do is put a vertical domino and fully fill the board and there is no way to partially fill the board.\\n`f[1] = 1`\\n`p[1] = 0`\\n\\nAt `i = 2`, there are two ways to fully fill the board (2x vertical dominos or 2x horizontal dominos) and one way to partially fill (actually 2 symmetrical ways, but the factor 2 is already considered when calculating `f[i]`).\\n`f[2] = 2`\\n`p[2] = 1`\\n\\nAt `i > 2`, we simply keep updating `f[i]` and `p[i]` using the equations we just found until `i == n`:\\n`f[i] = f[i - 1] + f[i - 2] + 2 * p[i - 1]`\\n`p[i] = p[i - 1] + f[i - 2]`\\n\\nBy close observation, we can see that we only need 4 variables at any given time. There is no need to keep a complete array of all states. Check the code to see which 4 variables are used.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n$$O(n)$$ if using array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if (n == 1) return 1;\\n        if (n == 2) return 2;\\n\\n        int mod = 1e9+7;\\n\\n        unsigned long res, f1 = 2, f2 = 1, p1 = 1;\\n        // res: number of ways to fully fill at f[i]\\n        // f1: number of ways to fully fill at f[i - 1]\\n        // f2: number of ways to fully fill at f[i - 2]\\n        // p1: number of ways to partially fill at p[i - 1]\\n\\n        for (int i = 2; i < n; i++) {\\n            res = (f1 + f2 + 2 * p1) % mod;\\n            p1 = (p1 + f2) % mod;\\n            f2 = f1;\\n            f1 = res;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if (n == 1) return 1;\\n        if (n == 2) return 2;\\n\\n        int mod = 1e9+7;\\n\\n        unsigned long res, f1 = 2, f2 = 1, p1 = 1;\\n        // res: number of ways to fully fill at f[i]\\n        // f1: number of ways to fully fill at f[i - 1]\\n        // f2: number of ways to fully fill at f[i - 2]\\n        // p1: number of ways to partially fill at p[i - 1]\\n\\n        for (int i = 2; i < n; i++) {\\n            res = (f1 + f2 + 2 * p1) % mod;\\n            p1 = (p1 + f2) % mod;\\n            f2 = f1;\\n            f1 = res;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947123,
                "title": "domino-and-tromino-tiling-clean-and-short-dp-solution",
                "content": "# Intuition\\nWhen we look at the problem you can see that we can find a solution using Dynamic Programming. Though, it requires a little bit more than a basic DP formulation. \\n\\n# Approach\\nLet us define three different DP arrays : \\n\\n- dpr[i] is holding the number of ways to tile on a board of length i;\\n- dpu[i] is holding the number of ways to tile on a board of length i where first row has one more cell then the second row\\n- dpd[i] is holding the number of ways to tile on a board of length i where first row has one less cell then the second row\\n \\nIf we consider only the right-most(last) tile there are these alternatives: \\n\\n-  the last tile is a vertical 2*1 domino. Then the number of ways to tile the previous tiles is dpr[i-1]\\n\\n- the last tile is a horizontal 2*1 domino. Then there must be another horizontal domino below that and the number of ways to tile the previous tiles is dpr[i-2]\\n\\n- the last tile is a tromino with 2 cells on the first row.\\n    1 1\\n    0 1\\n    Then, ways to tile the previous tiles is dpd[i-1]\\n\\n- the last tile is a tromino with 2 cells on the second row.\\n    0 1\\n    1 1\\n    Then, ways to tile the previous tiles is dpu[i-1]\\n\\n  \\nso our DP formula for dpr :\\n\\n    dpr[i] = dpr[i-1] + dpr[i-2] + dpu[i-1] + dpd[i-1]\\n\\nwith similar approach we can find formulas for dpu and dpd\\n\\n    dpu[i] = dpd[i-1] + dpr[i-2]\\n\\n    dpd[i] = dpu[i-1] + dpr[i-2]\\n\\n# Complexity\\n- Time complexity:\\nTime complexity to calculate the number of tilings is O(n)\\n\\n\\n- Space complexity:\\nSpace complexity to calculate the number of tilings is also O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    const long MODULO = 1000000007;\\n    public int NumTilings(int n) {\\n        var dpr = new long[n+1];\\n        var dpu = new long[n+1];\\n        var dpd = new long[n+1];\\n        dpr[0] = 1;\\n        dpr[1] = 1;\\n        for (int i = 2; i <= n; i++)\\n        {\\n            dpu[i] = (dpd[i-1] + dpr[i-2]) % MODULO;\\n            dpd[i] = (dpu[i-1] + dpr[i-2]) % MODULO;\\n            dpr[i] = (dpr[i-1] + dpr[i-2] + dpu[i-1] + dpd[i-1]) % MODULO;\\n        }\\n\\n        return (int)dpr[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    const long MODULO = 1000000007;\\n    public int NumTilings(int n) {\\n        var dpr = new long[n+1];\\n        var dpu = new long[n+1];\\n        var dpd = new long[n+1];\\n        dpr[0] = 1;\\n        dpr[1] = 1;\\n        for (int i = 2; i <= n; i++)\\n        {\\n            dpu[i] = (dpd[i-1] + dpr[i-2]) % MODULO;\\n            dpd[i] = (dpu[i-1] + dpr[i-2]) % MODULO;\\n            dpr[i] = (dpr[i-1] + dpr[i-2] + dpu[i-1] + dpd[i-1]) % MODULO;\\n        }\\n\\n        return (int)dpr[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946547,
                "title": "c-100-faster-easy-to-understand-iterative-dp",
                "content": "# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    const int mod = 1e9 + 7;\\n    \\n    int numTilings(int n) {\\n\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n\\n        long long dp[n+1];\\n\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n\\n        for(int i=4;i<=n;i++) {\\n            dp[i] = 2*dp[i-1] + dp[i-3];\\n            dp[i] %= mod;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    const int mod = 1e9 + 7;\\n    \\n    int numTilings(int n) {\\n\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n\\n        long long dp[n+1];\\n\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n\\n        for(int i=4;i<=n;i++) {\\n            dp[i] = 2*dp[i-1] + dp[i-3];\\n            dp[i] %= mod;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945524,
                "title": "c-easy-clean-fastest-recursion-memoization-image-detailed-explanation",
                "content": "# Intuition\\nAs we have 2 x n Board to tile only with two tiling options: Domino and Tromino, think of breaking down problem into cases where each case includes tiling the board with domino or tromino (given choices). From this, We can deduce that our problem can be broken down into subproblems which gives intuition of recursion/ memoization/ dp.\\n\\n# Approach\\nPlease check below image for more detailed visualization. It can be observed that a Rectangular (Rec.) board of width n can be broken into cases of Rec. board of width n - 1 and n - 2 when tiling is done using domino. On the other hand if tiling is done with a tromino, Rec. board of width n can be broken into: nonRec. board Down width of n - 1 and Up width of n - 1. Similarly, we can break nonRec. boards into cases when they get tiled by domino or tromino, refer to image below.\\n\\n![Screenshot 2022-12-24 at 4.34.35 PM.png](https://assets.leetcode.com/users/images/6a839363-0dc7-446d-8da2-06f897952960_1671881131.2062058.png)\\n\\nLooking at above image, its not difficult to come up with a recursive approach and then use memoization to solve the overlapping subproblems only once. Clearly, this can be further optimised using DP.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n#define vi vector<int>\\n#define UL unsigned long\\n\\nclass Solution {\\npublic:\\n    const int m = 1e9 + 7;\\n    vi MR, MNRD;\\n\\n    int add(UL a, UL b) { return ((a % m) + (b % m)) % m; }\\n\\n    int dfsRec(int n) {\\n        if(n <= 1) return n >= 0;\\n        if(MR[n] >= 0) return MR[n];\\n        auto rec = add(dfsRec(n - 1), dfsRec(n - 2));\\n        auto nonRec = add(dfsNonRecDown(n - 1), dfsNonRecUp(n - 1));\\n        return MR[n] = add(rec, nonRec);\\n    }\\n\\n    int dfsNonRecDown(int n) {\\n        if(n <= 2) return n == 2;\\n        if(MNRD[n] >= 0) return MNRD[n];\\n        return MNRD[n] = add(dfsNonRecUp(n - 1), dfsRec(n - 2));\\n    }\\n\\n    int dfsNonRecUp(int n) {\\n        return add(dfsNonRecDown(n - 1), dfsRec(n - 2));\\n    }\\n\\n    int dfs(int n) {\\n        MR.resize(n + 1, -1), MNRD.resize(n + 1, -1);\\n        return dfsRec(n);\\n    }\\n\\n    int numTilings(int n) {\\n        return dfs(n);\\n    }\\n};\\n```\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written posts on:\\n1. All C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n2. Kadane\\'s Algorithm and Follow up Questions [C++] in a cleaner way [here](https://leetcode.com/problems/maximum-subarray/discuss/1470547/C++-Easy-and-Clean-Solution-or-Fastest:-0ms-or-All-Methods-or-Follow-Ups-or-Detailed-Explanation) on leetcode.\\n\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#define vi vector<int>\\n#define UL unsigned long\\n\\nclass Solution {\\npublic:\\n    const int m = 1e9 + 7;\\n    vi MR, MNRD;\\n\\n    int add(UL a, UL b) { return ((a % m) + (b % m)) % m; }\\n\\n    int dfsRec(int n) {\\n        if(n <= 1) return n >= 0;\\n        if(MR[n] >= 0) return MR[n];\\n        auto rec = add(dfsRec(n - 1), dfsRec(n - 2));\\n        auto nonRec = add(dfsNonRecDown(n - 1), dfsNonRecUp(n - 1));\\n        return MR[n] = add(rec, nonRec);\\n    }\\n\\n    int dfsNonRecDown(int n) {\\n        if(n <= 2) return n == 2;\\n        if(MNRD[n] >= 0) return MNRD[n];\\n        return MNRD[n] = add(dfsNonRecUp(n - 1), dfsRec(n - 2));\\n    }\\n\\n    int dfsNonRecUp(int n) {\\n        return add(dfsNonRecDown(n - 1), dfsRec(n - 2));\\n    }\\n\\n    int dfs(int n) {\\n        MR.resize(n + 1, -1), MNRD.resize(n + 1, -1);\\n        return dfsRec(n);\\n    }\\n\\n    int numTilings(int n) {\\n        return dfs(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945466,
                "title": "dp-solution-memoization-to-space-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    // Memoization\\n    long solve(int n, vector<int>& dp)\\n    {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        if (n == 3) {\\n            return 5;\\n        }\\n\\n        if (dp[n] != -1) {\\n            return dp[n];\\n        }\\n\\n        return ((2 * (solve(n - 1, dp)) + solve(n - 3, dp))) % mod;\\n    }\\n\\n    // Tabulation\\n    int solveTab(int n)\\n    {\\n        vector<long> dp(n + 3, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = (2 * ((dp[i - 1]) % mod) + dp[i - 3]);\\n        }\\n\\n        return (dp[n]) % mod;\\n    }\\n\\n    // Space Optimization\\n    int solveUsingSpaceOptimisation(int n)\\n    {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        long prev1 = 2;\\n        long prev2 = 1;\\n        long prev3 = 1;\\n        long curr = 0;\\n        for (int i = 3; i <= n; i++) {\\n\\n            curr = (2 * ((prev1) % mod) + prev3);\\n            prev3 = prev2;\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n\\n        return (curr % mod);\\n    }\\n\\n    int numTilings(int n)\\n    {\\n        // vector<int> dp(n+1,-1);\\n        // return solve(n,dp);\\n        return solveUsingSpaceOptimisation(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    // Memoization\\n    long solve(int n, vector<int>& dp)\\n    {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        if (n == 3) {\\n            return 5;\\n        }\\n\\n        if (dp[n] != -1) {\\n            return dp[n];\\n        }\\n\\n        return ((2 * (solve(n - 1, dp)) + solve(n - 3, dp))) % mod;\\n    }\\n\\n    // Tabulation\\n    int solveTab(int n)\\n    {\\n        vector<long> dp(n + 3, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = (2 * ((dp[i - 1]) % mod) + dp[i - 3]);\\n        }\\n\\n        return (dp[n]) % mod;\\n    }\\n\\n    // Space Optimization\\n    int solveUsingSpaceOptimisation(int n)\\n    {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        long prev1 = 2;\\n        long prev2 = 1;\\n        long prev3 = 1;\\n        long curr = 0;\\n        for (int i = 3; i <= n; i++) {\\n\\n            curr = (2 * ((prev1) % mod) + prev3);\\n            prev3 = prev2;\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n\\n        return (curr % mod);\\n    }\\n\\n    int numTilings(int n)\\n    {\\n        // vector<int> dp(n+1,-1);\\n        // return solve(n,dp);\\n        return solveUsingSpaceOptimisation(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945202,
                "title": "c-easy-and-simple-solution-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Just Take few test cases and find the relation between the output.\\n- for e.g  Here for 1 --> 1, 2--> 2, 3--> 5, 4-->11 (which is 2 times prev output + third last output) , Same goes for 5--> 24(which is (2*11) + 2).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If input is less than 3 we return the same number else we start claculate till \\'n-2\\' times, as we have calculated for n<3 earlier.\\n2. So we store values of first  outputs in 3 variables $$prev$$,$$prev2$$ and $$prev3$$, and update their values at each iteration.\\n3. One of the important thing is to take (ans)%m at every step to avoid integer overflows.\\n4. Lastly we will have our answer in $$prev$$ and/or $$curr$$ we can return any of them.\\nHope You Understand!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$//Linear Time.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ Constant as only variables used.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    int numTilings(int n) {\\n        if(n<3)return n;\\n        else\\n        {\\n            long long prev3 = 1;\\n            long long prev2 = 1;\\n            long long prev  = 2;\\n            long long curr=0;\\n            for(int i=2;i<n;i++)\\n            {\\n                curr = ((prev*2) + prev3)%m;\\n                prev3 = prev2;\\n                prev2 = prev;\\n                prev = curr;\\n            }\\n            return prev;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    int numTilings(int n) {\\n        if(n<3)return n;\\n        else\\n        {\\n            long long prev3 = 1;\\n            long long prev2 = 1;\\n            long long prev  = 2;\\n            long long curr=0;\\n            for(int i=2;i<n;i++)\\n            {\\n                curr = ((prev*2) + prev3)%m;\\n                prev3 = prev2;\\n                prev2 = prev;\\n                prev = curr;\\n            }\\n            return prev;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945079,
                "title": "java-100-faster-simple-clean-solution-fibbonaci-based",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question itself is pretty weird if you look at the way it is described but pretty simple once you try to plot a picture in your head. Now if you draw all the possibilites for first few test cases, you\\'ll notice something.\\n\\n`n = 1, ans = 1`\\n`n = 2, ans = 2`\\n`n = 3, ans = 5`\\n`n = 4, ans = 11`\\n`n = 5, ans = 24`\\n`n = 6, ans = 53`\\n`n = 7, ans = 117`\\n\\nFrom the 4th testcase onwards, it follows a pattern which can be formulated as:\\n`ans[i] = 2 * ans[i - 1] + ans[i - 3]`\\n\\nAnd that is it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate an array of size `n` and do a tabulated fibbonaci. Define for first 3 base cases i.e., `n = 1, 2, 3` and calculate for the rest.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        if(n == 3) return 5;\\n        int mod = 1000000007;\\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        ans[1] = 2;\\n        ans[2] = 5;\\n        for(int i = 3; i < n; i++) {\\n            ans[i] = (((ans[i - 1] % mod) * 2)% mod + ans[i - 3] % mod) % mod;\\n        }\\n        return ans[n - 1]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        if(n == 3) return 5;\\n        int mod = 1000000007;\\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        ans[1] = 2;\\n        ans[2] = 5;\\n        for(int i = 3; i < n; i++) {\\n            ans[i] = (((ans[i - 1] % mod) * 2)% mod + ans[i - 3] % mod) % mod;\\n        }\\n        return ans[n - 1]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944758,
                "title": "c-dp-tabulation-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply by dry running some solution we can reach a point to find a pattern involved in it\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can analyse that \\ndp[1]=1\\ndp[2]=2\\ndp[3]=5\\ndp[4]=11\\ndp[i]=2*dp[i-1]+dp[i-3]\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIt is a 1D with linear time complexity i.e O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe are using only a vector so space complexity is O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<long long>dp(n+1,0);\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(n==3)\\n            return 5;\\n        if(n==4)\\n            return 11;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        dp[4] = 11;\\n        for(int i=5; i<=n; ++i) {\\n            dp[i] = (2*dp[i-1] +dp[i-3]) % 1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<long long>dp(n+1,0);\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(n==3)\\n            return 5;\\n        if(n==4)\\n            return 11;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        dp[4] = 11;\\n        for(int i=5; i<=n; ++i) {\\n            dp[i] = (2*dp[i-1] +dp[i-3]) % 1000000007;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944744,
                "title": "matrix-exponentiation-detailed-explanation-o-log-n-solution",
                "content": "# Approach\\n\\nMatrix Exponentiation is one of the most interesting techniques in competitive programming where you can reduce the complexity of your solution from O(N) to O(Log N) for a lot of recurrence relations.\\n\\nI\\'ll not be going into the details of the recurrence relation. This post is about understanding matrix exponentiation given some recurrence relation which in our case is: \\n\\nF(N) = 2\\\\*F(N-1) + 1\\\\*F(N-3)\\n\\nThe above equation can be rewritten as:\\n\\nF(N) = 2\\\\*F(N-1) + 0\\\\*F(N-2) + 1\\\\*F(N-3)\\n\\nSo the current value is depending on 3 previous values\\n\\n[1st Matrix] = [Some matrix] * [3rd Matrix]\\n\\n![1.png](https://assets.leetcode.com/users/images/2a2fc543-bd81-4e4c-88cc-8bb12b75419a_1671863617.9997604.png)\\n\\nDimension of the 1st and 3rd matrix is 3\\\\*1 so the dimension of the 2nd matrix must be 3\\\\*3\\n\\nAccording to our equation:\\n\\nF(N) = 2\\\\*F(N-1) + 0\\\\*F(N-2) + F(N-3)\\nF(N-1) = F(N-1)\\nF(N-2) = F(N-2)\\n\\nWriting this in matrix form we get our second matrix as:\\n\\n| 2 0 1 |\\n| 1 0 0 |\\n| 0 1 0 |\\n\\nOur relation becomes:\\n \\n![2.png](https://assets.leetcode.com/users/images/7e518475-9018-4cd5-a491-26c60214b5e6_1671864145.4730778.png)\\n\\nInitial values are F(0) = 1, F(1) = 1, F(2) = 2\\n\\nFor N = 3 \\n\\n![3.png](https://assets.leetcode.com/users/images/7bc0b7f3-0603-4dc9-ac9b-5aad0e6b3e3a_1671864277.6640637.png)\\n\\nFor N = 4\\n\\n![5.png](https://assets.leetcode.com/users/images/1adf94e6-c6de-40c9-9c65-ed89cab4cc87_1671864831.8639169.png)\\n\\n\\nSo for some N \\n\\n![6.png](https://assets.leetcode.com/users/images/23edab65-0784-4b83-9d0e-8faa89c09af7_1671864958.975979.png)\\n\\n\\nThus we can multiply the second matrix N-2 times and finally multiply it with the base matrix to get the answer for F(N)\\n\\nThis multiplication of the matrix can be done using fast exponentiation which will provide us the final matrix in O(Log N) time \\n\\n# Complexity\\n- Time complexity: O(Log N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    typedef long long ll;\\n    const int mod=1e9+7;\\n\\n    void multiply(vector<vector<ll>> &A, vector<vector<ll>> &B){\\n        vector<vector<ll>> temp(3, vector<ll>(3));\\n        for(int i=0; i<3; ++i){\\n            for(int j=0; j<3; ++j){\\n                for(int k=0; k<3; ++k){\\n                    (temp[i][j]+=(A[i][k]%mod * B[k][j]%mod)%mod)%mod;\\n                }\\n            }\\n        } \\n        A=temp;\\n    }\\n\\n    void power(vector<vector<ll>> &A, ll n){\\n        if(n==1) return;\\n        power(A, n/2);\\n        multiply(A, A);\\n        if(n%2){\\n            vector<vector<ll>> B={{2, 0, 1}, {1, 0, 0}, {0, 1, 0}};\\n            multiply(A, B);\\n        }\\n    }\\n\\n    int numTilings(int n) {\\n        if(n<=2)return n;\\n        vector<vector<ll>> A={{2, 0, 1}, {1, 0, 0}, {0, 1, 0}};\\n        power(A, n-2);\\n        return (2*A[0][0]%mod + A[0][1]%mod + A[0][2]%mod)%mod;\\n    }\\n};\\n```\\n\\nDo Upvote, If found helpful \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Matrix",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    typedef long long ll;\\n    const int mod=1e9+7;\\n\\n    void multiply(vector<vector<ll>> &A, vector<vector<ll>> &B){\\n        vector<vector<ll>> temp(3, vector<ll>(3));\\n        for(int i=0; i<3; ++i){\\n            for(int j=0; j<3; ++j){\\n                for(int k=0; k<3; ++k){\\n                    (temp[i][j]+=(A[i][k]%mod * B[k][j]%mod)%mod)%mod;\\n                }\\n            }\\n        } \\n        A=temp;\\n    }\\n\\n    void power(vector<vector<ll>> &A, ll n){\\n        if(n==1) return;\\n        power(A, n/2);\\n        multiply(A, A);\\n        if(n%2){\\n            vector<vector<ll>> B={{2, 0, 1}, {1, 0, 0}, {0, 1, 0}};\\n            multiply(A, B);\\n        }\\n    }\\n\\n    int numTilings(int n) {\\n        if(n<=2)return n;\\n        vector<vector<ll>> A={{2, 0, 1}, {1, 0, 0}, {0, 1, 0}};\\n        power(A, n-2);\\n        return (2*A[0][0]%mod + A[0][1]%mod + A[0][2]%mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944679,
                "title": "c-dp-tabulation-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy analizing the first few results, the following formula is obtained.\\n    Initialize the size of DP =(n+5), as if n<4 it will not through an error.\\n    //Initial DP values are obtained by analizing the first few results. They are\\n    * DP[1] = 1;\\n    * DP[2] = 2;\\n    * DP[3] = 5\\n    * DP[i] = 2*DP[i-1]+DP[i-3];\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    As it is a linear DP traversal, TC will be O(N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    SC : O(N).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<int>dp(n+5,0);\\n        int mod=1000000007;\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=((2*((dp[i-1])%mod))%mod+(dp[i-3])%mod)%(mod);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<int>dp(n+5,0);\\n        int mod=1000000007;\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=((2*((dp[i-1])%mod))%mod+(dp[i-3])%mod)%(mod);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944400,
                "title": "c-simple-idea-code-0ms-runtime-explain-by-image-and-comment",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIm just find out the rule of result:\\n![image.png](https://assets.leetcode.com/users/images/d5e4b02d-b832-4bdc-aefe-7a7e968ab5c1_1671938023.1976612.png)\\n -> I don\\'t consider case * **n less than 4** since A(0) doesn\\'t exist.\\n### For example: \\n\\n- **n = 4**\\n![image.png](https://assets.leetcode.com/users/images/5c4679e0-676f-405b-b5e8-28f188d4b786_1671857992.599562.png)\\n- **n = 5**\\n![image.png](https://assets.leetcode.com/users/images/83e469a8-69f1-4ae3-bd9a-9b8a9c516e30_1671858130.2308517.png)\\n- **n = 6**\\n![image.png](https://assets.leetcode.com/users/images/b6518daf-2e1f-4e17-bbcb-1c43a08a7b1e_1671858244.1903396.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor the general, I let variable **a** store (n-3) value and **c** for (n-1) then  we can easily calculate the result.\\n- **n = 4**\\n![image.png](https://assets.leetcode.com/users/images/46ca036e-5f91-4a50-827e-db521ae1f69f_1671859739.1557844.png)\\n\\n- **n = 5**\\n![image.png](https://assets.leetcode.com/users/images/7cc70323-1199-49ec-94dd-ce6bb76163f3_1671859068.1883385.png)\\n\\nand so on..\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n <= 2)\\n            return n;\\n        if(n == 3)\\n            return 5;\\n        //a = n(1), b = n(2), c = n(3)\\n        long res, a = 1, b = 2, c = 5;\\n        while(n-- > 3) {\\n            res = (2*c + a) % int (1e9 + 7);\\n            //shift a,b,c to the right\\n            a = b;\\n            b = c;\\n            c = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n <= 2)\\n            return n;\\n        if(n == 3)\\n            return 5;\\n        //a = n(1), b = n(2), c = n(3)\\n        long res, a = 1, b = 2, c = 5;\\n        while(n-- > 3) {\\n            res = (2*c + a) % int (1e9 + 7);\\n            //shift a,b,c to the right\\n            a = b;\\n            b = c;\\n            c = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944373,
                "title": "tabulation-solution-simple-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n<=2)return n;\\n        int [] arr = new int[n+1];\\n        arr[0] = 0;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n        arr[3] = 5;\\n        int mod = 10*10*10*10*10*10*10*10*10 + 7;\\n        for(int x = 4; x<=n;x++){\\n            arr[x] = arr[x-3]+2*arr[x-1]%(mod);\\n            arr[x] = arr[x]%(mod);\\n        }\\n\\n        return arr[n];\\n    }\\n    // public int domino(int n,int x){\\n    //     if(x<1){\\n    //         if(x<0)return 0;\\n    //         return 1;\\n    //         }\\n    //     int left = domino(n,x-1);\\n    //     int right = domino(n,x-2);\\n    //     return left+right;\\n    // }\\n    // public int tramino(int n,int x){\\n    //     if(x<1){\\n    //         if(x<0)return 0;\\n    //         return 1;\\n    //         }\\n    //     int l = 2*tramino(n,x-4);\\n    //     int right1 = 2*tramino(n,x-3);\\n    //     int right = tramino(n,x-2);\\n    //     int left = tramino(n,x-1);\\n    //     return left+right+right1+l;\\n    // }\\n}\\n```\\n# Request \\nif find recursive solution for the tromino function then please put it in the comments.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n<=2)return n;\\n        int [] arr = new int[n+1];\\n        arr[0] = 0;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n        arr[3] = 5;\\n        int mod = 10*10*10*10*10*10*10*10*10 + 7;\\n        for(int x = 4; x<=n;x++){\\n            arr[x] = arr[x-3]+2*arr[x-1]%(mod);\\n            arr[x] = arr[x]%(mod);\\n        }\\n\\n        return arr[n];\\n    }\\n    // public int domino(int n,int x){\\n    //     if(x<1){\\n    //         if(x<0)return 0;\\n    //         return 1;\\n    //         }\\n    //     int left = domino(n,x-1);\\n    //     int right = domino(n,x-2);\\n    //     return left+right;\\n    // }\\n    // public int tramino(int n,int x){\\n    //     if(x<1){\\n    //         if(x<0)return 0;\\n    //         return 1;\\n    //         }\\n    //     int l = 2*tramino(n,x-4);\\n    //     int right1 = 2*tramino(n,x-3);\\n    //     int right = tramino(n,x-2);\\n    //     int left = tramino(n,x-1);\\n    //     return left+right+right1+l;\\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944332,
                "title": "c-solution",
                "content": "# Code\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n < 3) return n;\\n        vector<long long> dp(n+1);\\n        dp[0] = 1, dp[1] = 1, dp[2] = 2;\\n        for(int i=3; i<=n; i++) {\\n            dp[i] = (2 * dp[i-1] + dp[i-3]) % mod;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n < 3) return n;\\n        vector<long long> dp(n+1);\\n        dp[0] = 1, dp[1] = 1, dp[2] = 2;\\n        for(int i=3; i<=n; i++) {\\n            dp[i] = (2 * dp[i-1] + dp[i-3]) % mod;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944220,
                "title": "observation-o-n-100-fast-easy-understanding-5-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Observation\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int arr[1001],N=1e9+7;\\n    int numTilings(int n) {\\n         arr[1]=1; arr[2]=2; arr[3]=5;\\n         for(int i=4;i<=n;i++){ //obeservation is arr[i]=arr[i-1]*2+arr[i-3]\\n             arr[i]=((arr[i-1]*2)%N+arr[i-3])%N; //for i>=4\\n         }\\n        return arr[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int arr[1001],N=1e9+7;\\n    int numTilings(int n) {\\n         arr[1]=1; arr[2]=2; arr[3]=5;\\n         for(int i=4;i<=n;i++){ //obeservation is arr[i]=arr[i-1]*2+arr[i-3]\\n             arr[i]=((arr[i-1]*2)%N+arr[i-3])%N; //for i>=4\\n         }\\n        return arr[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549003,
                "title": "c-100-fastest-solution-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(int n,vector<int>&dp){\\n        //base case\\n        if(n==1)return 1;\\n        if(n==2)return 2;\\n        if(n==3)return 5;\\n        //check the cache\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        return \\n            dp[n]=((2*solve(n-1,dp))%mod + solve(n-3,dp)%mod)%mod;\\n    }\\n    int numTilings(int n) {\\n        \\n        vector<int>dp(n+10,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(int n,vector<int>&dp){\\n        //base case\\n        if(n==1)return 1;\\n        if(n==2)return 2;\\n        if(n==3)return 5;\\n        //check the cache\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        return \\n            dp[n]=((2*solve(n-1,dp))%mod + solve(n-3,dp)%mod)%mod;\\n    }\\n    int numTilings(int n) {\\n        \\n        vector<int>dp(n+10,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463108,
                "title": "4-line-python",
                "content": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        dp=[0]*(n+3)\\n        dp[1]=1\\n        dp[2]=2\\n        dp[3]=5\\n        for i in range(4,n+1):\\n            dp[i]=int((2*dp[i-1]+dp[i-3])%(1e9+7))\\n        return dp[n]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        dp=[0]*(n+3)\\n        dp[1]=1\\n        dp[2]=2\\n        dp[3]=5\\n        for i in range(4,n+1):\\n            dp[i]=int((2*dp[i-1]+dp[i-3])%(1e9+7))\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622024,
                "title": "c-simple-solution-w-images-explanation-optimization-from-brute-force-to-dp",
                "content": "\\u2714\\uFE0F **Solution (Dynamic Programming - Tabulation)**\\n**1-D DP**\\nSimple basic approach to these question comprises of three steps :\\n\\n**Step 1:** (putting   ![image](https://assets.leetcode.com/users/images/1a819d99-9305-456d-985d-81fc4c12fa8c_1639162617.0363584.png)   at the end , this can be done in **dp[i-1]** ways ) .\\n\\n**Step 2**: (putting     ![image](https://assets.leetcode.com/users/images/c17ad4a1-1f58-4c94-88af-e110f1abc266_1639162680.2571974.png)  at the end , this can be done in **dp[i-2]** ways ) .\\n\\n\\n**Step 3**: ( putting all those boxes formed by the combination of ![image](https://assets.leetcode.com/users/images/a9033da0-53e2-4e72-b124-11af378e6c75_1639162724.4785063.png)![image](https://assets.leetcode.com/users/images/59eaaab0-4f85-4b12-bfc0-f1b7c664d34b_1639162735.3517957.png)\\n\\n![image](https://assets.leetcode.com/users/images/d5edcfbe-1754-4e60-a241-a3830bf63c88_1639162748.0943146.png)  \\n, this can be done by all those combinations **greater than or equal to 3 till n** )\\n\\n**For example** : dp[4] = dp[3] + dp[2] + dp[1]*2 + 2 (2 combination formed by n in step 3)  ; \\n\\nSo , we can genelarise the code as ,\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long long int MOD = 1000000007 ;\\n        vector<int>dp(n+2,0);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            dp[i]=(dp[i-1]%MOD+dp[i-2]%MOD+2)%MOD;   \\n            for(int j=3;j<i;j++)\\n            {\\n                dp[i]=(dp[i]%MOD+(dp[i-j]*2)%MOD)%MOD;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\nTime Complexity : O(N^2)\\nSpace Complexity : O(N), required maintaining dp\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long long int MOD = 1000000007 ;\\n        vector<int>dp(n+2,0);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            dp[i]=(dp[i-1]%MOD+dp[i-2]%MOD+2)%MOD;   \\n            for(int j=3;j<i;j++)\\n            {\\n                dp[i]=(dp[i]%MOD+(dp[i-j]*2)%MOD)%MOD;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621129,
                "title": "c-recursion-memoization-beats-100",
                "content": "Everytime we reach upto a column, we may have either 2 or 1 untiled cells in that column.\\nIf 2 empty cells are present: \\n* Insert a single vertical domino and move ahead.\\n* Insert 2 horizontal dominos.\\n* Add a tromino, which means next column will only have 1 untiled cell.\\n\\nIf only 1 empty cell is preset:\\n* Place a tromino so that next column has 2 untiled cells.\\n* Add a horizontal domino to continue the 1 untiled cell pattern.\\n```\\n\\tconst int mod = 1e9+7;\\n\\t\\n    long long dp[1001][3];\\n    long long f(int n, int empty){\\n        if(n<=1) return empty==2;//At the last column, there must be 2 empty cells, otherwise this is an invalid way, so return 0\\n        if(dp[n][empty]!=-1) return dp[n][empty]%mod;\\n        long long res = 0;\\n        \\n        if(empty==2){\\n            res += f(n-1, 2)%mod;//single verticle domino\\n            if(n>=2) res += f(n-2, 2)%mod;// 2 horizontal dominos\\n            res += (2 * f(n-1, 1)%mod)%mod;//tromino placed\\n        }\\n        else{\\n            res+= f(n-2, 2)%mod;//placed a tromino to fill the gap\\n            res+= f(n-1, 1)%mod;//horizontal domino added\\n        }\\n        \\n        return dp[n][empty] = res%mod;\\n    }\\n    long long numTilings(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return f(n, 2)%mod;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tconst int mod = 1e9+7;\\n\\t\\n    long long dp[1001][3];\\n    long long f(int n, int empty){\\n        if(n<=1) return empty==2;//At the last column, there must be 2 empty cells, otherwise this is an invalid way, so return 0\\n        if(dp[n][empty]!=-1) return dp[n][empty]%mod;\\n        long long res = 0;\\n        \\n        if(empty==2){\\n            res += f(n-1, 2)%mod;//single verticle domino\\n            if(n>=2) res += f(n-2, 2)%mod;// 2 horizontal dominos\\n            res += (2 * f(n-1, 1)%mod)%mod;//tromino placed\\n        }\\n        else{\\n            res+= f(n-2, 2)%mod;//placed a tromino to fill the gap\\n            res+= f(n-1, 1)%mod;//horizontal domino added\\n        }\\n        \\n        return dp[n][empty] = res%mod;\\n    }\\n    long long numTilings(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return f(n, 2)%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1620860,
                "title": "dp-with-bitmasks-c-clear-explanation",
                "content": "* Here In this solution we just need to check all possibilities from the current postion to next position and assign the mask values based on the filled situations.\\n* It\\'s not actually the bitmasking level problem but taken the mask variable to indicates the possible states using the numbers.\\n* We will use memoization for the avoiding repetitive recursion tasks.\\n* Lets Try to under stand the all possible states and their possibilities:\\n* Consider the 2*2 grid. **This dimenstion is taken because this is the minimum dimension required to consider the generated states by using two types of tiles.**\\n\\n\\t![image](https://assets.leetcode.com/users/images/5de6ead3-10f5-4bde-b9ce-dcefe52f74d3_1639195755.7855394.png)\\n\\n\\n\\n\\n* At last we will return 1 if all boxes **filled in valid manner by verifying mask is 0 means state 1.**\\n\\n**Below is the code implementation of the above approach:**\\n```\\nclass Solution {\\npublic:\\n\\n    const int mod = 1e9 + 7;\\n    int dp[1001][4];\\n    int n;\\n    int solve(int index,int mask)\\n    {\\n        if(index > n)\\n        {\\n            return 0;\\n        }\\n        if(index == n)\\n        {\\n            return mask == 0;\\n        }\\n        if(dp[index][mask] != -1) return dp[index][mask];\\n\\n        int ans = 0;\\n\\n        if(mask == 0)\\n        {\\n            ans = (ans + solve(index+1,0))%mod;\\n            ans = (ans + solve(index+2,0))%mod;\\n            ans = (ans + solve(index+1,1))%mod;\\n            ans = (ans + solve(index+1,2))%mod;\\n            \\n            \\n        }\\n        else if(mask == 1)\\n        {\\n            ans = (ans + solve(index+1,3))%mod;\\n            ans = (ans + solve(index+1,2))%mod;\\n        }\\n        else if(mask == 2)\\n        {\\n            ans = (ans + solve(index+1,3))%mod;\\n            ans = (ans + solve(index+1,1))%mod;\\n        }\\n        else\\n        {\\n            ans = solve(index+1,0) % mod;\\n        }\\n        return dp[index][mask] = ans;\\n    }\\n\\n    int numTilings(int N) {\\n        n = N;\\n        memset(dp,-1,sizeof dp);\\n\\n        return solve(0,0);\\n        \\n    }\\n};\\n```\\n\\n**Upvote if you understand this approach. Let me know  if any doubts or other more optimal approach.**\\n\\n\\n",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    const int mod = 1e9 + 7;\\n    int dp[1001][4];\\n    int n;\\n    int solve(int index,int mask)\\n    {\\n        if(index > n)\\n        {\\n            return 0;\\n        }\\n        if(index == n)\\n        {\\n            return mask == 0;\\n        }\\n        if(dp[index][mask] != -1) return dp[index][mask];\\n\\n        int ans = 0;\\n\\n        if(mask == 0)\\n        {\\n            ans = (ans + solve(index+1,0))%mod;\\n            ans = (ans + solve(index+2,0))%mod;\\n            ans = (ans + solve(index+1,1))%mod;\\n            ans = (ans + solve(index+1,2))%mod;\\n            \\n            \\n        }\\n        else if(mask == 1)\\n        {\\n            ans = (ans + solve(index+1,3))%mod;\\n            ans = (ans + solve(index+1,2))%mod;\\n        }\\n        else if(mask == 2)\\n        {\\n            ans = (ans + solve(index+1,3))%mod;\\n            ans = (ans + solve(index+1,1))%mod;\\n        }\\n        else\\n        {\\n            ans = solve(index+1,0) % mod;\\n        }\\n        return dp[index][mask] = ans;\\n    }\\n\\n    int numTilings(int N) {\\n        n = N;\\n        memset(dp,-1,sizeof dp);\\n\\n        return solve(0,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430395,
                "title": "domino-tromino-best-0-ms-faster-than-100-simplest-solution-with-intution",
                "content": "In this question the intution starts to build on the basis of 2x1 and Mx1 tiling problem if you haven\\'t done these two then i strongly suggest you to please do these two first.\\nNow you have done those two problems then You will going to able to find a pattern for both domino and tromino that is for domino you will find f[n]=f[n-1]+f[n-2] a recursive solution.\\nso we have a table\\n![image](https://assets.leetcode.com/users/images/432420c9-edd3-49f9-bbb5-4f4c390267b8_1630140280.6376898.png)\\n\\nnow let\\'s analyse the pattern\\n```\\n\\t\\tn=3   f[3]=5\\n\\t\\tn=4   f[4]= 11 =2*5+1;\\n\\t\\tn=5   f[5]= 24 =2*11+2;\\n\\t\\tn=6   f[6]= 53 =2*24+5\\n\\nif we try to generalise the pattern we see\\n\\nf[n]= 2*f[n-1]+f[n-3]  hence we will get our answer\\n\\ncode for the question:\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int numTilings(int n) {\\n        vector<long long> dp(n+1);\\n        if(n<3)\\n        return n;\\n        dp[0]=1;//here i have taken dp[0]=1 coz at the edge case that is when n=3 dp[n-3] will give the runtime error but can you find a way without putting it dp[0]=1? \\n\\t\\t\\t\\t\\t\\t//tell me in the comment section\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<n+1;i++)\\n            dp[i]=(2*dp[i-1]+dp[i-3])%mod;\\n        return dp[n];\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int mod=1e9+7;\\n    int numTilings(int n) {\\n        vector<long long> dp(n+1);\\n        if(n<3)\\n        return n;\\n        dp[0]=1;//here i have taken dp[0]=1 coz at the edge case that is when n=3 dp[n-3] will give the runtime error but can you find a way without putting it dp[0]=1? \\n\\t\\t\\t\\t\\t\\t//tell me in the comment section\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<n+1;i++)\\n            dp[i]=(2*dp[i-1]+dp[i-3])%mod;\\n        return dp[n];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1415741,
                "title": "domino-and-tromino-tiling-java-o-n-solution-using-dynamic-programming",
                "content": "\\tThe pattern here is formed when we consider the domino and tromino arrangements seperately and add them to get total number of arrangements.\\n\\tIndexes (n):    0 1 2 3 4 5 6\\n\\tUsing dominos:  0 1 2 3 5 8 13 and so on\\n\\tUsing trominos: 0 0 0 2 6 16 40 and so on\\n\\tTotal:          0 1 2 5 11 24 53\\n\\t\\n\\tIf we initialise our DP array with these total values, exception being that we put dp[0] = 1 as well, we get 1 1 2 5 11 24 53 where we can see that the pattern is defined by: \\n\\tdp[i] = 2 * dp[i-1] + dp[i-3] \\n\\tFor example, 11 = 2 * 5 + 1\\n\\t             24 = 2 * 11 + 2\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t \\n\\t```\\n\\tprivate static final int MODULO = (int) Math.pow(10, 9) + 7;\\n    public int numTilings(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        long[] dp1 = new long[n+1];\\n        \\n        dp1[0] = 1;\\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n        \\n        for(int i = 3; i < dp1.length; i++){\\n            dp1[i] = (dp1[i-1] * 2 + dp1[i-3])%MODULO;  \\n        }\\n        return (int)dp1[n];\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tprivate static final int MODULO = (int) Math.pow(10, 9) + 7;\\n    public int numTilings(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        long[] dp1 = new long[n+1];\\n        \\n        dp1[0] = 1;\\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n        \\n        for(int i = 3; i < dp1.length; i++){\\n            dp1[i] = (dp1[i-1] * 2 + dp1[i-3])%MODULO;  \\n        }\\n        return (int)dp1[n];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174623,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1005][1005];\\n    int MOD = 1000000007;\\n    int solve(int up, int down)\\n    {\\n        if(up==0 && down==0)\\n            return 1;\\n        if(up<0 || down<0)\\n            return 0;\\n        if(dp[up][down]!=-1)\\n            return dp[up][down];\\n        int ans;\\n        //if up==down then all four types are 1=>put vrrtical 2x1 domino, 2=>put 2 horizontal domino on each other, 3=>put one tromino, 4=>put inverted tromino\\n        if(up==down)\\n        {\\n            ans = (((solve(up-1, down-1)%MOD + solve(up-2, down-2)%MOD)%MOD + solve(up-2, down-1)%MOD)%MOD + solve(up-1, down-2)%MOD)%MOD; \\n        }\\n        //if up is more then down, then we have two cases, 1=>put inverted tromino, 2=>put one horizontal domino at top\\n        else if(up==down+1)\\n        {\\n            ans = (solve(up-2, down-1)%MOD +solve(up-2, down)%MOD)%MOD;\\n        }\\n        //if up is less then down, then we have two cases, 1=>put tromino, 2=>put one horizontal domino at bottom\\n        else if(up==down-1)\\n        {\\n            ans = (solve(up-1, down-2)%MOD + solve(up, down-2)%MOD)%MOD;\\n        }\\n        return dp[up][down] = ans;\\n    }\\n    int numTilings(int N) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(N,N);\\n    }\\n};\\n```\\n\\nI hope you understood my solution.\\nFeel free to ask doubts in comment section.\\nHappy Coding :)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1005][1005];\\n    int MOD = 1000000007;\\n    int solve(int up, int down)\\n    {\\n        if(up==0 && down==0)\\n            return 1;\\n        if(up<0 || down<0)\\n            return 0;\\n        if(dp[up][down]!=-1)\\n            return dp[up][down];\\n        int ans;\\n        //if up==down then all four types are 1=>put vrrtical 2x1 domino, 2=>put 2 horizontal domino on each other, 3=>put one tromino, 4=>put inverted tromino\\n        if(up==down)\\n        {\\n            ans = (((solve(up-1, down-1)%MOD + solve(up-2, down-2)%MOD)%MOD + solve(up-2, down-1)%MOD)%MOD + solve(up-1, down-2)%MOD)%MOD; \\n        }\\n        //if up is more then down, then we have two cases, 1=>put inverted tromino, 2=>put one horizontal domino at top\\n        else if(up==down+1)\\n        {\\n            ans = (solve(up-2, down-1)%MOD +solve(up-2, down)%MOD)%MOD;\\n        }\\n        //if up is less then down, then we have two cases, 1=>put tromino, 2=>put one horizontal domino at bottom\\n        else if(up==down-1)\\n        {\\n            ans = (solve(up-1, down-2)%MOD + solve(up, down-2)%MOD)%MOD;\\n        }\\n        return dp[up][down] = ans;\\n    }\\n    int numTilings(int N) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(N,N);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099691,
                "title": "dynamic-programming-solution-o-n-time-and-o-n-space-solution-with-explaination",
                "content": "Types of Tiles after Rotation\\n\\nType 1 :- ![image](https://assets.leetcode.com/users/images/fd53a390-f070-4023-bb2f-27cfdc8347a1_1615202764.4124565.png)\\nType 2 :- ![image](https://assets.leetcode.com/users/images/bb35864e-7e96-465c-a217-b59cc53e7589_1615202818.247449.png)\\nType 3 :- ![image](https://assets.leetcode.com/users/images/22a86c40-ae82-4ad4-8bf2-40064298fd1f_1615202829.6135092.png)\\nType 4 :- ![image](https://assets.leetcode.com/users/images/9e643e52-9282-437e-a5b6-e6cf042eaad1_1615202853.7448912.png)\\nType 5 :- ![image](https://assets.leetcode.com/users/images/478d29b8-b4c9-4390-972a-318f045d5e72_1615202865.6793249.png)\\nType 6 :- ![image](https://assets.leetcode.com/users/images/0fe046ad-4e14-4bd5-a200-a226361e7a71_1615202876.948113.png)\\n\\n\\nlets **define DP[N]** as number of ways to fill the tiles in first N colums of 2XN grid.\\nlets take every tile as last tile\\n\\n**Type 1** :- number of ways will DP[N-1]\\n**Type 2** :- number of ways will DP[N-2] and we will place two tiles of this type parallely.\\n**Type 3** :- cannot take this, because grid will not end or a box will remain empty.\\n**Type 4** :- cannot take this, because grid will not end or a box will remain empty.\\n**Type 5** :- ![image](https://assets.leetcode.com/users/images/5a30ab43-e84a-407c-b541-65cf2848a654_1615203470.964799.png) number of ways will be number of grids ending with this configuration. **DP_UP[N-1]**\\n**Type 6** :- ![image](https://assets.leetcode.com/users/images/0869b3f6-58f2-49e2-9b57-c20d832ea689_1615203560.9002962.png) number of ways will be the number of grids ending with this configuration. **DP_DOWN[N-1]**.\\n\\n\\nso,\\n**DP[N]=DP[N-1]+DP[N-2] + DP_UP[N-1]+DP_DOWN[N-1]**   --------(A)\\n\\n_________________________________________________________________________________________________\\n\\n\\n![image](https://assets.leetcode.com/users/images/5a73a3c5-3608-41b9-a0d9-0f6539e88dae_1615203738.0106196.png) + ![image](https://assets.leetcode.com/users/images/0ba03912-10e6-496c-937a-de0570a22f8a_1615203749.7741885.png) = ![image](https://assets.leetcode.com/users/images/9e4e590f-c67a-4000-be32-a99a6359f768_1615203780.648613.png)\\n\\n\\nand \\n\\n![image](https://assets.leetcode.com/users/images/284b9f10-0426-45fe-97fa-cb0b67ffe4c7_1615203841.987641.png) + ![image](https://assets.leetcode.com/users/images/60a8d7a7-3659-4cf7-b7bb-4ee755bd65f0_1615203850.8945684.png) =![image](https://assets.leetcode.com/users/images/0762cf9b-94f9-4e9c-b55d-6efe4c14c4d1_1615203866.1455088.png)\\n\\nso,\\n**DP_UP[N]=DP_DOWN[N-1] +DP[N-2]**\\n\\nsimilarly\\n\\n**DP_DOWN[N]=DP_UP[N-1] + DP[N-2]**\\n\\n\\nafter using above relations\\n\\n**DP_UP[N-1]=DP_DOWN[N-2] +DP[N-3]**\\n**DP_DOWN[N-1]=DP_UP[N-2] + DP[N-3]**\\n\\nputting above relations in the Equation A\\n\\nDP[N]=DP[N-1] + DP[N-2] + DP_DOWN[N-2] + DP[N-3] + DP_UP[N-2] + DP[N-3]\\n\\nDP[N]=DP[N-1] + DP[N-3] + **{** DP[N-2] + DP[N-3] +DP_UP[N-2] + DP_DOWN[N-2] **}** \\n\\nabove expression in brackets can be replaced by DP[N-1]\\n\\n\\nso ,\\n\\n\\n**DP[N]=2xDP[N-1] + DP[N-2]**\\n\\nwith base cases of \\nDP[0]=1,DP[1]=1,DP[2]=2\\n\\n\\n**CODE**\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int dp[1001];\\n    int numTilings(int N) { \\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for(int i=3; i<=N; i++){\\n            dp[i] = (2*dp[i-1]%mod + dp[i-3]%mod)%mod;\\n        }\\n        \\n        return dp[N]%mod;\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int dp[1001];\\n    int numTilings(int N) { \\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for(int i=3; i<=N; i++){\\n            dp[i] = (2*dp[i-1]%mod + dp[i-3]%mod)%mod;\\n        }\\n        \\n        return dp[N]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010393,
                "title": "recursion-memoization-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<int> t;\\n    int solve(int i){\\n        if(i<=1)\\n            return 1;\\n        \\n        if(i==2)\\n            return 2;\\n        \\n        if(t[i]!=-1)\\n            return t[i];\\n        \\n        int ans=0;\\n        ans=((2*solve(i-1))%mod+(solve(i-3))%mod)%mod;\\n        \\n        return t[i]=ans;\\n    }\\n    \\n    int numTilings(int N) {\\n        t.resize(N+1,-1);\\n        return solve(N);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<int> t;\\n    int solve(int i){\\n        if(i<=1)\\n            return 1;\\n        \\n        if(i==2)\\n            return 2;\\n        \\n        if(t[i]!=-1)\\n            return t[i];\\n        \\n        int ans=0;\\n        ans=((2*solve(i-1))%mod+(solve(i-3))%mod)%mod;\\n        \\n        return t[i]=ans;\\n    }\\n    \\n    int numTilings(int N) {\\n        t.resize(N+1,-1);\\n        return solve(N);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802103,
                "title": "c-2-vectors-dp-with-explanation",
                "content": "The whole area is `N*2`, for each small column `i`, there\\'re three possible states:\\n(1) Both cells in the `i`th column is covered.\\n(2) One cell is covered, while the other not.\\n(3) The other one is covered, symmetric to (2).\\n\\nThen `dp[i][0]` is the number of ways to cover all cells through `0` to `i`, and `dp[i][1]`, `dp[i][2]` is the number of ways to cover all cells through `0` to `i-1` and one of the cells in `i`th column.\\n\\nThe relationship between different states is:\\nFor `dp[i][1]`: it can come from either adding a tromino for `dp[i-2][0]` or adding a domino for `dp[i-1][2]`. And `dp[i][2]` is symmetric.\\nFor `dp[i][0]`: it can come from adding a domino for `dp[i-1][0]`, adding 2 horizontal dominos for `dp[i-2][0]`, or adding a tromino for either `dp[i-1][1]` or `dp[i-1][2]`.\\n\\nFinally, `dp[N-1][0]` is the answer. Since state (2) and (3) are symmetric, we can use one vector for both states.\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        if (N <= 2) return N;\\n        const long r = 1000000007;\\n        vector<vector<long>> dp(N, vector<long>(2,0));\\n        dp[0][0] = 1;\\n        dp[1][0] = 2;\\n        dp[1][1] = 1;\\n        for (int i = 2; i < N; i++) {\\n            dp[i][0] = (dp[i-2][0] + dp[i-1][1] * 2 + dp[i-1][0]) % r;\\n            dp[i][1] = (dp[i-2][0] + dp[i-1][1]) % r;\\n        }\\n        return dp[N-1][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        if (N <= 2) return N;\\n        const long r = 1000000007;\\n        vector<vector<long>> dp(N, vector<long>(2,0));\\n        dp[0][0] = 1;\\n        dp[1][0] = 2;\\n        dp[1][1] = 1;\\n        for (int i = 2; i < N; i++) {\\n            dp[i][0] = (dp[i-2][0] + dp[i-1][1] * 2 + dp[i-1][0]) % r;\\n            dp[i][1] = (dp[i-2][0] + dp[i-1][1]) % r;\\n        }\\n        return dp[N-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493004,
                "title": "python-simple-and-easy-to-understand-dp-solution",
                "content": "```\\nclass Solution(object):\\n    def numTilings(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[[0,0,0] for i in range(N+1)]\\n        dp[0][0]=dp[1][0]=1\\n        \\n         #Define: dp[i][0] is number of ways to cover i column, in which both top row and bottom row are coverd: e.g. XXX\\n         #                                                                                                            XXX\\n         #        dp[i][1] is number of ways to cover i column, in which the last spot of bottom row is empty:   e.g. XXX\\n         #                                                                                                            XX   \\n         #        dp[i][2] is number of ways to cover i column, in which the last spot of top row is empty:      e.g. XX\\n         #                                                                                                            XXX\\n        \\n        #   Thus for dp[i][0], there are four ways to form from previous dp[i-1] and dp[i-2], which are:\\n        #       XXXY XXYY XXXY XXYY\\n        #       XXXY XXZZ XXYY XXXY\\n        \\n        \\n        #   Thus for dp[i][1], there are two ways to form from previous dp[i-1] and dp[i-2], which are:\\n        #       XXYY XXYY\\n        #       XXY  XXX\\n        \\n        \\n        #   Similarly for dp[i][2], there are two ways to form from previous dp[i-1] and dp[i-2], which are:\\n        #       XXY   XXX\\n        #       XXYY  XXYY\\n        \\n        for i in range(2,N+1):\\n            dp[i][0]=dp[i-1][0]+dp[i-2][0]+dp[i-1][1]+dp[i-1][2]\\n            dp[i][1]=dp[i-2][0]+dp[i-1][2]\\n            dp[i][2]=dp[i-2][0]+dp[i-1][1]\\n        \\n        return dp[i][0]%(10**9+7)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numTilings(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[[0,0,0] for i in range(N+1)]\\n        dp[0][0]=dp[1][0]=1\\n        \\n         #Define: dp[i][0] is number of ways to cover i column, in which both top row and bottom row are coverd: e.g. XXX\\n         #                                                                                                            XXX\\n         #        dp[i][1] is number of ways to cover i column, in which the last spot of bottom row is empty:   e.g. XXX\\n         #                                                                                                            XX   \\n         #        dp[i][2] is number of ways to cover i column, in which the last spot of top row is empty:      e.g. XX\\n         #                                                                                                            XXX\\n        \\n        #   Thus for dp[i][0], there are four ways to form from previous dp[i-1] and dp[i-2], which are:\\n        #       XXXY XXYY XXXY XXYY\\n        #       XXXY XXZZ XXYY XXXY\\n        \\n        \\n        #   Thus for dp[i][1], there are two ways to form from previous dp[i-1] and dp[i-2], which are:\\n        #       XXYY XXYY\\n        #       XXY  XXX\\n        \\n        \\n        #   Similarly for dp[i][2], there are two ways to form from previous dp[i-1] and dp[i-2], which are:\\n        #       XXY   XXX\\n        #       XXYY  XXYY\\n        \\n        for i in range(2,N+1):\\n            dp[i][0]=dp[i-1][0]+dp[i-2][0]+dp[i-1][1]+dp[i-1][2]\\n            dp[i][1]=dp[i-2][0]+dp[i-1][2]\\n            dp[i][2]=dp[i-2][0]+dp[i-1][1]\\n        \\n        return dp[i][0]%(10**9+7)",
                "codeTag": "Java"
            },
            {
                "id": 393645,
                "title": "concise-dp-solution-o-n-time-o-1-space-picture-illustration-no-lengthy-math-derivation",
                "content": "It\\'s clear that DP is the best way to solve it. However, many solutions seem to have lengthy math drivation before deriving the transfer equation.\\n\\nIf we define two tilting problems, the logic seems a lot simpler:\\n* Let `a[n]` be the tiling ways for `2*n` board (i.e., the answer)\\n* Let `b[n]` be the tiling ways for `2*n+1` board (i.e., the helper DP array)\\n\\nWe have transfer equations:\\n```cpp\\na[n] = a[n-1] + a[n-2] + 2*b[n-2];\\nb[n] = a[n-1] + b[n-1];\\n```\\nwith initial conditions:\\n```cpp\\na[0] = 1, a[1] = 1, b[0] = 0, b[1] = 1;\\n```\\n\\n![image](https://assets.leetcode.com/users/zzg_zzm/image_1569793400.png)\\n\\n```cpp\\n    int numTilings(int n) {\\n      if (n == 1) return 1;\\n      \\n      // initial values\\n      long a, a_pre1 = 1, a_pre2 = 1; // 2xn solution\\n      long b, b_pre1 = 1, b_pre2 = 0; // 2xn+1 solution\\n      const long mod = 1000000007;      \\n      \\n      while (--n >= 1) // iterate n-1 times\\n      { \\n        a = (a_pre1 + a_pre2 + 2*b_pre2)%mod;\\n        b = (a_pre1 + b_pre1)%mod;\\n        \\n        // update a and b\\n        a_pre2 = a_pre1;\\n        a_pre1 = a;\\n        \\n        b_pre2 = b_pre1;\\n        b_pre1 = b;\\n      }\\n      return a;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\na[n] = a[n-1] + a[n-2] + 2*b[n-2];\\nb[n] = a[n-1] + b[n-1];\\n```\n```cpp\\na[0] = 1, a[1] = 1, b[0] = 0, b[1] = 1;\\n```\n```cpp\\n    int numTilings(int n) {\\n      if (n == 1) return 1;\\n      \\n      // initial values\\n      long a, a_pre1 = 1, a_pre2 = 1; // 2xn solution\\n      long b, b_pre1 = 1, b_pre2 = 0; // 2xn+1 solution\\n      const long mod = 1000000007;      \\n      \\n      while (--n >= 1) // iterate n-1 times\\n      { \\n        a = (a_pre1 + a_pre2 + 2*b_pre2)%mod;\\n        b = (a_pre1 + b_pre1)%mod;\\n        \\n        // update a and b\\n        a_pre2 = a_pre1;\\n        a_pre1 = a;\\n        \\n        b_pre2 = b_pre1;\\n        b_pre1 = b;\\n      }\\n      return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 317471,
                "title": "python-intuitive-dfs-based-solution",
                "content": "This solution is intuitive enough to answer in an interview scenario, and greatly demonstrates the analytical skills when approaching such problem.\\n\\nFirst, imagine we are putting the tiles one by one.  We have 8 types of tiles:\\n```\\n        Types # 0  1   2   3   4   5   6   7 \\n        of      X  XX      X   XX  XX   X  XX\\n        Tile    X      XX  XX  X    X  XX  YY\\n```\\nSide note, you might notice that #1 and #2 is identical to #7, this will be explained later.\\n\\nThen, we define 3 kinds of **states**, which represents that after we finished putting first k columns, there should be either: **No additional block**, **one block at top** or **one block at bottom**, illustrates as below:\\n```\\n        States:\\n        \\n        #0 - Empty: .......\\n                    .......\\n                   \\n        #1 - Up:    ......X\\n                    ......\\n        \\n        #2 - Down:  ......\\n                    ......X\\n```\\n\\nThen, we can define the process of putting the tile.  For example, In state 0, we can put an additional tile #0, #3, #4 or #7.  \\n\\n```\\n        Transitions:\\n        State #0: Accepts tile 0, 3, 4, 7\\n        State #1: Accepts tile 2, 6\\n        State #2: Accepts tile 1, 5\\n```\\nAs for why we separate the tile #1 #2 and tile #7, it\\'s because we want to keep the states simple, we dont want something like state #0 plus a tile #1, results in two more additional blocks at top.\\n\\nHaving defined all these, we can simply just run a DFS with a dictionary to keep intermediate results:\\n```\\nclass Solution(object):\\n    def numTilings(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        self.h = {}\\n        self.M = 10**9 + 7\\n        return self.dfs(N, 0)\\n        \\n    def dfs(self, N, state):\\n        key = (N,state)\\n        \\n        if key in self.h:\\n            return self.h[key]\\n        \\n        if N<=1:\\n            ans = 1\\n\\n        elif N==2:\\n            ans = 2 if state==0 else 1\\n            \\n        elif state==0:\\n            ans = self.dfs(N-1,0) + self.dfs(N-1,2) + self.dfs(N-1,1) + self.dfs(N-2,0)\\n        \\n        elif state==1:\\n            ans = self.dfs(N-1,2) + self.dfs(N-2,0)\\n        \\n        elif state==2:\\n            ans = self.dfs(N-1,1) + self.dfs(N-2,0)\\n            \\n        ans %= self.M\\n        self.h[key] = ans\\n        return ans\\n```\\n        \\n        \\n",
                "solutionTags": [],
                "code": "```\\n        Types # 0  1   2   3   4   5   6   7 \\n        of      X  XX      X   XX  XX   X  XX\\n        Tile    X      XX  XX  X    X  XX  YY\\n```\n```\\n        States:\\n        \\n        #0 - Empty: .......\\n                    .......\\n                   \\n        #1 - Up:    ......X\\n                    ......\\n        \\n        #2 - Down:  ......\\n                    ......X\\n```\n```\\n        Transitions:\\n        State #0: Accepts tile 0, 3, 4, 7\\n        State #1: Accepts tile 2, 6\\n        State #2: Accepts tile 1, 5\\n```\n```\\nclass Solution(object):\\n    def numTilings(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        self.h = {}\\n        self.M = 10**9 + 7\\n        return self.dfs(N, 0)\\n        \\n    def dfs(self, N, state):\\n        key = (N,state)\\n        \\n        if key in self.h:\\n            return self.h[key]\\n        \\n        if N<=1:\\n            ans = 1\\n\\n        elif N==2:\\n            ans = 2 if state==0 else 1\\n            \\n        elif state==0:\\n            ans = self.dfs(N-1,0) + self.dfs(N-1,2) + self.dfs(N-1,1) + self.dfs(N-2,0)\\n        \\n        elif state==1:\\n            ans = self.dfs(N-1,2) + self.dfs(N-2,0)\\n        \\n        elif state==2:\\n            ans = self.dfs(N-1,1) + self.dfs(N-2,0)\\n            \\n        ans %= self.M\\n        self.h[key] = ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182594,
                "title": "python-1-liner-o-log-n-time-o-1-space-with-explanation",
                "content": "1-liner:\\n```python\\ndef numTilings(self, N):\\n    return (lambda m: m[0][0] - m[1][0])(numpy.linalg.matrix_power(numpy.array([[2,0,1],[1,0,0],[0,1,0]], dtype=object), N)) % 1000000007\\n```\\n---\\n\\n### Explanation\\n\\n**Short version:** If you already know why the recurrence relation `t[k] = 2 * t[k-1] + t[k-3]` is true, then just observe that it can be written as follows:\\n```\\nt[k]   = 2 * t[k-1] + 0 * t[k-2] + 1 * t[k-3]\\nt[k-1] = 1 * t[k-1] + 0 * t[k-2] + 0 * t[k-3]\\nt[k-2] = 0 * t[k-1] + 1 * t[k-2] + 0 * t[k-3]\\n```\\n**Long version:** This is easiest to understand if you try to answer _two_ questions instead of one:\\n1. Let `d(k)` be the number of ways can you tile a `2 * k` board.\\n2. Let `t(k)` be the number of ways you can tile a `2 * k + 1` board.\\n\\nFor example, a `2 * 3 + 1` board looks like this:\\n```abc\\n    +---+---+---+\\n    |   |   |   |\\n+---+---+---+---+\\n|   |   |   |   |\\n+---+---+---+---+\\n```\\nThere is a mutually recursive relation between `d(k)` and `t(k)`. First note that `t(k) == t(k-1) + d(k-1)`:\\n```\\n    +---+---+---+        +---+---+---+        +---+---+---+\\n    |   |   |   |        |   |   |   |        | X |   |   |\\n+---+---+---+---+    +---+---+---+---+    +---+---+---+---+\\n|   |   |   |   |    | X | X |   |   |    | X | X |   |   |\\n+---+---+---+---+    +---+---+---+---+    +---+---+---+---+\\n\\n      t(3)        ==       t(2)        +        d(2)\\n```\\nMore to come...\\n",
                "solutionTags": [],
                "code": "```python\\ndef numTilings(self, N):\\n    return (lambda m: m[0][0] - m[1][0])(numpy.linalg.matrix_power(numpy.array([[2,0,1],[1,0,0],[0,1,0]], dtype=object), N)) % 1000000007\\n```\n```\\nt[k]   = 2 * t[k-1] + 0 * t[k-2] + 1 * t[k-3]\\nt[k-1] = 1 * t[k-1] + 0 * t[k-2] + 0 * t[k-3]\\nt[k-2] = 0 * t[k-1] + 1 * t[k-2] + 0 * t[k-3]\\n```\n```abc\\n    +---+---+---+\\n    |   |   |   |\\n+---+---+---+---+\\n|   |   |   |   |\\n+---+---+---+---+\\n```\n```\\n    +---+---+---+        +---+---+---+        +---+---+---+\\n    |   |   |   |        |   |   |   |        | X |   |   |\\n+---+---+---+---+    +---+---+---+---+    +---+---+---+---+\\n|   |   |   |   |    | X | X |   |   |    | X | X |   |   |\\n+---+---+---+---+    +---+---+---+---+    +---+---+---+---+\\n\\n      t(3)        ==       t(2)        +        d(2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 116649,
                "title": "790-domino-and-tromino-tiling-c-with-brief-explanation-pics",
                "content": "The following is the my way to solve the problem, for better graphs (sorry for my poor draw skills), please check [Stack Exchange: Domino and Tromino Combined Tiling](https://cs.stackexchange.com/questions/66658/domino-and-tromino-combined-tiling)\nI use 2 * 7 as an example, f(n) means the ways of tiling for 2 * n.\nFor f(7), we can split it into different part, and remeber, for the Tromino, they must appear by pairs.\n\n**f(6)** : In my graph, if the f(7) comes from f(6), obviously, there is only 1 way for tiling.\n**f(5)**:  if the f(7) comes from f(5), there is a 2 * 2 region, also only 1 way. I also stated that why not another possible (lets call it as possible **A5** ) arrangement, because it has been considered in the f(6).\n\nThen you should note that we are caring about the tails of each arragement, for f(5), the possible **A5** has the same tail as the possible in the f(6). Then possible **A5** in f(5) must be considered in f(6). The same logic for the following analysis. So here we find out that each time when we consider some possible arrangement, we will compare the tail of new possible way with the previous possibilities.\n\nThen by my analysis, we have the formula:\n\n**f(n) = f(n-3) + 2 * f(n-1)**\n\nAlso, boundaries: \nf(0) = 0\nf(1) = 1\nf(2) = 2\nf(3) = 5\n![image](https://s3-lc-upload.s3.amazonaws.com/users/jasonshieh/image_1519577577.png)\n\n\n\nC++ code:\n\n\tclass Solution {\n\tpublic:\n\t\t\tint numTilings(int N) {\n\t\t\t\t\tint MOD =  1000000007;\n\t\t\t\t\tvector<long> dp = {0,1,2,5};\n\t\t\t\t\tfor(int i = 4; i <= N; ++i){\n\t\t\t\t\t\t\tdp.push_back((dp[i-3] + 2*dp[i-1])%MOD);\n\t\t\t\t\t}\n\t\t\t\t\treturn dp[N]%MOD;\n\t\t\t}\n\t};\n\t\n\t\n\n*So any commentaries for saving time/space complexity?\nThanks.*\n",
                "solutionTags": [],
                "code": "class Solution {\n\tpublic:\n\t\t\tint numTilings(int N) {\n\t\t\t\t\tint MOD =  1000000007;\n\t\t\t\t\tvector<long> dp = {0,1,2,5}",
                "codeTag": "Java"
            },
            {
                "id": 116558,
                "title": "easy-python-4-liner-memoization-with-explanation",
                "content": "Let's look at the cases for the last column(s), i.e. the end of the tiling.  It is either of:\n```\nX\nX\n```\n```\nXX\nYY\n```\n```\n*X\nXX\n```\nIf we denote the function `c(N)` as the number of tilings on a 2xN board, then the number of tilings in the first two cases are `c(N-1)` and `c(N-2)` respectively.\n\nFor the last case, observe that the first L-tromino *before* the one we have completes a rectangular board, and furthermore that tromino must be one of the cases:\n```\nY****X\nYY**XX\n```\nor\n```\nYY**X\nY**XX\n```\nThe number of possibilities of the former is `sum([c(i) for i in range(N-4, -1, -2)])` and the number of possibilities of the latter is `sum([c(i) for i in range(N-3, -1, -2)])`.  Remember that the stars can be any number of (horizontal) regular dominoes.\n\nWe have the analogous case of the last L tromino being\n```\nXX\n*X\n```\nso we double the count.\n\nHere is the solution:\n```\n    def numTilings(self, N):\n        c = [1, 1, 2, 5] + [1 for i in range(N+1-4)]\n        for i in range(4, N+1):\n            c[i] = 2*sum(c[:i-2]) + c[i-2] + c[i-1]\n        return c[N] % (10**9 + 7)\n```",
                "solutionTags": [],
                "code": "```\nX\nX\n```\n```\nXX\nYY\n```\n```\n*X\nXX\n```\n```\nY****X\nYY**XX\n```\n```\nYY**X\nY**XX\n```\n```\nXX\n*X\n```\n```\n    def numTilings(self, N):\n        c = [1, 1, 2, 5] + [1 for i in range(N+1-4)]\n        for i in range(4, N+1):\n            c[i] = 2*sum(c[:i-2]) + c[i-2] + c[i-1]\n        return c[N] % (10**9 + 7)\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4036760,
                "title": "domino-and-tromino-tiling-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int first  = 0 ,second = 1 , third = 1 , next , mod = 1e9+7 ;\\n        while(--n)\\n        {\\n            next = ((third * 2) %mod + first)%mod ;\\n            first = second ;\\n            second = third ;\\n            third = next ;\\n        }\\n        return third ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int first  = 0 ,second = 1 , third = 1 , next , mod = 1e9+7 ;\\n        while(--n)\\n        {\\n            next = ((third * 2) %mod + first)%mod ;\\n            first = second ;\\n            second = third ;\\n            third = next ;\\n        }\\n        return third ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574732,
                "title": "java-easy-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used concept of recurison .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n==0||n==1) return 1;\\n        \\n        if(n==2) return n;\\n        if(n==3) return 5;\\n      long f1=1;\\n      long f2=2;\\n      long f3=5;\\n      long mod=1000000007;\\n      for(int i=4;i<=n;i++){\\n        long ans=(f3*2+f1)%mod;\\n        f1=f2;\\n        f2=f3;\\n        f3=ans;\\n      }\\n       return (int)f3;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n==0||n==1) return 1;\\n        \\n        if(n==2) return n;\\n        if(n==3) return 5;\\n      long f1=1;\\n      long f2=2;\\n      long f3=5;\\n      long mod=1000000007;\\n      for(int i=4;i<=n;i++){\\n        long ans=(f3*2+f1)%mod;\\n        f1=f2;\\n        f2=f3;\\n        f3=ans;\\n      }\\n       return (int)f3;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468199,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int MOD = 1e9+ 7;\\n        if (n <= 2) {\\n            return n;\\n        }\\n        long fCurrent = 5L;\\n        long fPrevious = 2L; \\n        long fBeforePrevious = 1L; \\n        for (int k = 4; k < n + 1; ++k) {\\n            long tmp = fPrevious;\\n            fPrevious = fCurrent; \\n            fCurrent = (2 * fCurrent + fBeforePrevious) % MOD;\\n            fBeforePrevious = tmp;\\n        }\\n        return fCurrent;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n\\n        dp = [1, 2, 5] + [0] * n\\n        for i in range(3, n):\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007\\n        return dp[n - 1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n==1)\\n        return 1;\\n        else if(n==2)\\n        return 2;\\n      int mod = 1000000007;\\n\\n    int [] dp=new int[n+1];\\n\\n    dp[1]=1;\\n    dp[2]=2;\\n    dp[3]=5;\\n    for(int i =4;i<=n;i++){\\n        dp[i]=(2*dp[i-1]%mod+dp[i-3]%mod)%mod;\\n    }\\n    return dp[n];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int MOD = 1e9+ 7;\\n        if (n <= 2) {\\n            return n;\\n        }\\n        long fCurrent = 5L;\\n        long fPrevious = 2L; \\n        long fBeforePrevious = 1L; \\n        for (int k = 4; k < n + 1; ++k) {\\n            long tmp = fPrevious;\\n            fPrevious = fCurrent; \\n            fCurrent = (2 * fCurrent + fBeforePrevious) % MOD;\\n            fBeforePrevious = tmp;\\n        }\\n        return fCurrent;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n\\n        dp = [1, 2, 5] + [0] * n\\n        for i in range(3, n):\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007\\n        return dp[n - 1]\\n```\n```Java []\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n==1)\\n        return 1;\\n        else if(n==2)\\n        return 2;\\n      int mod = 1000000007;\\n\\n    int [] dp=new int[n+1];\\n\\n    dp[1]=1;\\n    dp[2]=2;\\n    dp[3]=5;\\n    for(int i =4;i<=n;i++){\\n        dp[i]=(2*dp[i-1]%mod+dp[i-3]%mod)%mod;\\n    }\\n    return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452574,
                "title": "o-n-solution-different-approach-to-divide-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is best explained by drawing out the case for `n = 4`, see below\\n\\n![IMG_4469.jpg](https://assets.leetcode.com/users/images/38aaac09-39b5-420e-8bcf-b1226c4e435e_1682396413.6945324.jpeg)\\n\\nHere, we define a function `no_div(n)`, meaning the number of non-subdivisible patterns that can form a complete rectangle of size `2 * n`. Draw out some example. You\\'ll notice that for `no_div(1) = 1, no_div(2) = 1, no_div(n) = 2 for n > 2`. Such non-subdivisible pattern is found on the top right of the image for `n = 4`, and you can similarly draw out for other `n`s (these 2 will be mirroring images).\\n\\nOnce noticing this, following my drawing that uses the subproblem division. This shrinking subproblem division approach is likely to be the most common first idea for many people. We start from the first subproblem where `n = 3`, and from the example of the question we already have the answer. Then for `n = 2`, and we start to notice some duplicates.\\n\\nHowever, you\\'ll find that all the duplicates that we crossed out are ones that has __subdivisible patterns__ for the part that is NOT covered by the subproblem, such as `||` (which can be subdivided into `|` and `|`). On the other hand, the pattern `\\u4E8C` is not subdivisible.\\n\\nThis trend also applies to `n = 1`, where the solutions with subdivisible patterns `\\u4E8C|`, `|\\u4E8C`, `|||` are all crossed out. Therefore, we will only multiply the count of non-subdivisble patterns with the remaining subproblem\\'s solution to add to our solution.\\n\\n# Approach\\n\\nAbove arrives at the following formula:\\n\\n```\\ndp[i] = no_div(i) + no_div(1)*dp[i-1] + no_div(2)*dp[i-2] + no_div(3)*dp[i-3] + ... + no_div(i-1)*dp[1]\\n      = 2 + dp[i-1] + dp[i-2] + 2*dp[i-3] + ... + 2*dp[1]\\n```\\n\\nNow the optimization: reading this formula, it will make clear that many of the terms here are likely also present in `dp[i-1]`, which is\\n\\n```\\ndp[i-1] = no_div(i) + no_div(1)*dp[i-2] + no_div(2)*dp[i-3] + ... + no_div(i-3)*dp[2] + no_div(i-2)*dp[1]\\n        = 2 + dp[i-2] + dp[i-3] + 2*dp[i-4] + ... + 2*dp[1]\\n\\n```\\n\\nSubtract, and you\\'ll get\\n\\n```\\ndp[i] - dp[i-1] = dp[i-1] + dp[i-3]\\ndp[i] = 2*dp[i-1] + dp[i-3]\\n```\\n\\nAnd we got our O(n) formula!\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n), but apparently can be optimized to O(1) by reducing storage.\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        dp = [0] * (n+1)\\n        dp[0] = 1\\n        dp[1] = 1\\n        dp[2] = 2\\n\\n        for i in range(3, n+1):\\n            dp[i] = (2*dp[i-1] + dp[i-3]) % (10**9 + 7)\\n        \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndp[i] = no_div(i) + no_div(1)*dp[i-1] + no_div(2)*dp[i-2] + no_div(3)*dp[i-3] + ... + no_div(i-1)*dp[1]\\n      = 2 + dp[i-1] + dp[i-2] + 2*dp[i-3] + ... + 2*dp[1]\\n```\n```\\ndp[i-1] = no_div(i) + no_div(1)*dp[i-2] + no_div(2)*dp[i-3] + ... + no_div(i-3)*dp[2] + no_div(i-2)*dp[1]\\n        = 2 + dp[i-2] + dp[i-3] + 2*dp[i-4] + ... + 2*dp[1]\\n\\n```\n```\\ndp[i] - dp[i-1] = dp[i-1] + dp[i-3]\\ndp[i] = 2*dp[i-1] + dp[i-3]\\n```\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        dp = [0] * (n+1)\\n        dp[0] = 1\\n        dp[1] = 1\\n        dp[2] = 2\\n\\n        for i in range(3, n+1):\\n            dp[i] = (2*dp[i-1] + dp[i-3]) % (10**9 + 7)\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387487,
                "title": "best-solution-simple-approach",
                "content": "\\n# Approach\\nthink like in start we have the 0th column empty so we need to fill it first we have four ways to fill it(here 0 means emplty cell 1 means filled) see last ifelse condition. u^d means if upper is epmty ans lower is filled or vice verca then we have 2 ways use a trainagular peice or a horizonatal peice . if both is 1 then simply we ask i+1 for 0 0.\\nbase case is wehn we go ou of block i.e i==n then both up and down shuould be 0 0\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n;\\nint mod=1e9+7;\\nint dp[1001][2][2];\\nint fun(int i,bool u,bool l){\\n\\n    if(i>n) return 0;\\n    if(i==n){\\n        if(u==0 && l==0) return 1;\\n        return 0;\\n    }\\n    if(dp[i][u][l]!=-1) return dp[i][u][l];\\n        int ans=0;\\n    if(u==0 && l==0){\\n        //vertical\\n        ans=(ans+fun(i+1,0,0))%mod;\\n        //horizontal\\n        ans=(ans+fun(i+2,0,0))%mod;\\n        //triangular\\n        ans=(ans+fun(i+1,1,0))%mod;\\n        //ulta tragunlar\\n        ans=(ans+fun(i+1,0,1))%mod;\\n    }\\n\\n    if(u==1 && l==1){\\n        ans=(ans+fun(i+1,0,0))%mod;\\n    }\\n\\n    if(u^l){\\n        // if(u==1)\\n         ans=(ans+fun(i+1,!u,!l))%mod;\\n\\n        ans=(ans+fun(i+1,1,1))%mod;\\n    }\\n\\n    // if(u==1 && l==0){\\n    //     //domino\\n    //     ans=(ans+fun(i+1,0,1))%mod;\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n    // else if(u==0 && l==1){\\n    //      ans=(ans+fun(i+1,1,0))%mod;\\n    //      //tromino\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n\\n    return dp[i][u][l]=ans;\\n}\\n    int numTilings(int n) {\\n        this->n=n;\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n;\\nint mod=1e9+7;\\nint dp[1001][2][2];\\nint fun(int i,bool u,bool l){\\n\\n    if(i>n) return 0;\\n    if(i==n){\\n        if(u==0 && l==0) return 1;\\n        return 0;\\n    }\\n    if(dp[i][u][l]!=-1) return dp[i][u][l];\\n        int ans=0;\\n    if(u==0 && l==0){\\n        //vertical\\n        ans=(ans+fun(i+1,0,0))%mod;\\n        //horizontal\\n        ans=(ans+fun(i+2,0,0))%mod;\\n        //triangular\\n        ans=(ans+fun(i+1,1,0))%mod;\\n        //ulta tragunlar\\n        ans=(ans+fun(i+1,0,1))%mod;\\n    }\\n\\n    if(u==1 && l==1){\\n        ans=(ans+fun(i+1,0,0))%mod;\\n    }\\n\\n    if(u^l){\\n        // if(u==1)\\n         ans=(ans+fun(i+1,!u,!l))%mod;\\n\\n        ans=(ans+fun(i+1,1,1))%mod;\\n    }\\n\\n    // if(u==1 && l==0){\\n    //     //domino\\n    //     ans=(ans+fun(i+1,0,1))%mod;\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n    // else if(u==0 && l==1){\\n    //      ans=(ans+fun(i+1,1,0))%mod;\\n    //      //tromino\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n\\n    return dp[i][u][l]=ans;\\n}\\n    int numTilings(int n) {\\n        this->n=n;\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387483,
                "title": "very-simple-approach-with-simple-intuition",
                "content": "\\n# Approach\\nThink like in start we have the 0th column empty so we need to fill it first we have four ways to fill it(here 0 means emplty cell 1 means filled) see last ifelse condition. u^d means if upper is epmty ans lower is filled or vice verca then we have 2 ways use a trainagular peice or a horizonatal peice . if both is 1 then simply we ask i+1 for 0 0.\\nbase case is wehn we go ou of block i.e i==n then both up and down shuould be 0 0\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n;\\nint mod=1e9+7;\\nint dp[1001][2][2];\\nint fun(int i,bool u,bool l){\\n\\n    if(i>n) return 0;\\n    if(i==n){\\n        if(u==0 && l==0) return 1;\\n        return 0;\\n    }\\n    if(dp[i][u][l]!=-1) return dp[i][u][l];\\n        int ans=0;\\n    if(u==0 && l==0){\\n        //vertical\\n        ans=(ans+fun(i+1,0,0))%mod;\\n        //horizontal\\n        ans=(ans+fun(i+2,0,0))%mod;\\n        //triangular\\n        ans=(ans+fun(i+1,1,0))%mod;\\n        //ulta tragunlar\\n        ans=(ans+fun(i+1,0,1))%mod;\\n    }\\n\\n    if(u==1 && l==1){\\n        ans=(ans+fun(i+1,0,0))%mod;\\n    }\\n\\n    if(u^l){\\n        // if(u==1)\\n         ans=(ans+fun(i+1,!u,!l))%mod;\\n\\n        ans=(ans+fun(i+1,1,1))%mod;\\n    }\\n\\n    // if(u==1 && l==0){\\n    //     //domino\\n    //     ans=(ans+fun(i+1,0,1))%mod;\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n    // else if(u==0 && l==1){\\n    //      ans=(ans+fun(i+1,1,0))%mod;\\n    //      //tromino\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n\\n    return dp[i][u][l]=ans;\\n}\\n    int numTilings(int n) {\\n        this->n=n;\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n;\\nint mod=1e9+7;\\nint dp[1001][2][2];\\nint fun(int i,bool u,bool l){\\n\\n    if(i>n) return 0;\\n    if(i==n){\\n        if(u==0 && l==0) return 1;\\n        return 0;\\n    }\\n    if(dp[i][u][l]!=-1) return dp[i][u][l];\\n        int ans=0;\\n    if(u==0 && l==0){\\n        //vertical\\n        ans=(ans+fun(i+1,0,0))%mod;\\n        //horizontal\\n        ans=(ans+fun(i+2,0,0))%mod;\\n        //triangular\\n        ans=(ans+fun(i+1,1,0))%mod;\\n        //ulta tragunlar\\n        ans=(ans+fun(i+1,0,1))%mod;\\n    }\\n\\n    if(u==1 && l==1){\\n        ans=(ans+fun(i+1,0,0))%mod;\\n    }\\n\\n    if(u^l){\\n        // if(u==1)\\n         ans=(ans+fun(i+1,!u,!l))%mod;\\n\\n        ans=(ans+fun(i+1,1,1))%mod;\\n    }\\n\\n    // if(u==1 && l==0){\\n    //     //domino\\n    //     ans=(ans+fun(i+1,0,1))%mod;\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n    // else if(u==0 && l==1){\\n    //      ans=(ans+fun(i+1,1,0))%mod;\\n    //      //tromino\\n    //     ans=(ans+fun(i+1,1,1))%mod;\\n    // }\\n\\n    return dp[i][u][l]=ans;\\n}\\n    int numTilings(int n) {\\n        this->n=n;\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950979,
                "title": "o-1-time-complexity-python-solution",
                "content": "# Intuition\\nUse your O(n) solution to create an array of size 1000. Next, perform dp[i] % (10**9+7) for each dp of i so that leetcode can fit your answer! The following dp array looks like this:\\n\\n# Code\\n```\\nclass Solution(object):\\n        def numTilings(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        # dp = [1,2,5,11]\\n        \\n        # for i in range (4,n):\\n        #     dp.append(dp[i-3] + 2*dp[i-1])\\n\\n        dp = [1, 2, 5, 11, 24, 53, 117, 258, 569, 1255, 2768, 6105, 13465, 29698, 65501, 144467, 318632, 702765, 1549997, 3418626, 7540017, 16630031, 36678688, 80897393, 178424817, 393528322, 867954037, 914332884, 222194076, 312342182, 539017241, 300228551, 912799284, 364615795, 29460134, 971719552, 308054885, 645569904, 262859346, 833773577, 313117044, 889093434, 611960431, 537037899, 963169225, 538298867, 613635626, 190440463, 919179793, 451995198, 94430852, 108041490, 668078178, 430587201, 969215892, 606509948, 643607090, 256430058, 119370057, 882347204, 21124452, 161618961, 205585119, 432294690, 26208334, 258001787, 948298264, 922804855, 103611483, 155521223, 233847294, 571306071, 298133358, 830114010, 231534077, 761201512, 352517020, 936568117, 634337732, 621192477, 178953057, 992243846, 605680155, 390313360, 772870559, 151421259, 693155878, 159182301, 469785861, 632727593, 424637480, 319060814, 270849214, 966335908, 251732616, 774314446, 514964786, 281662181, 337638801, 190242381, 662146943, 661932680, 514107734, 690362404, 42657474, 599422682, 889207761, 821072989, 241568646, 372345046, 565763074, 373094787, 118534613, 802832300, 978759380, 76053359, 954939018, 888637402, 853328156, 661595316, 211828020, 276984189, 215563687, 642955394, 562894970, 341353620, 325662627, 214220217, 769794054, 865250728, 944721666, 659237372, 183725458, 312172575, 283582515, 750890488, 813953544, 911489596, 573869666, 961692869, 834875320, 243620292, 448933446, 732742205, 709104695, 867142829, 467027849, 643160386, 153463587, 773955023, 191070418, 535604423, 845163862, 881398135, 298400679, 441965213, 765328554, 829057780, 100080759, 965490072, 760037910, 620156572, 205803202, 171644307, 963445186, 132693560, 437031427, 837508033, 807709619, 52450651, 942409335, 692528275, 437507194, 817423716, 327375693, 92258573, 1940855, 331257403, 754773379, 511487606, 354232608, 463238588, 437964775, 230162151, 923562890, 285090541, 800343233, 524249342, 333589218, 467521662, 459292659, 252174529, 971870720, 403034085, 58242692, 88356097, 579746279, 217735243, 523826583, 627399438, 472534112, 468894800, 565189031, 602912167, 674719127, 914627278, 432166709, 539052538, 992732347, 417631389, 374315309, 741362958, 900357298, 175029891, 91422733, 83202757, 341435405, 774293543, 631789836, 605015070, 984323676, 600437174, 805889411, 596102484, 792642135, 391173667, 378449811, 549541750, 490257160, 358964124, 267469991, 25197135, 409358394, 86186772, 197570679, 804499752, 695186269, 587943210, 980386165, 655958585, 899860373, 780106897, 216172365, 332205096, 444517082, 105206522, 542618140, 529753355, 164713225, 872044590, 273842521, 712398267, 296841110, 867524741, 447447735, 191736573, 250997880, 949443495, 90623549, 432244978, 813933444, 718490430, 869225831, 552385092, 823260607, 515747031, 583879147, 991018894, 497784805, 579448750, 149916380, 797617565, 174683866, 499284112, 796185782, 767055423, 33394944, 862975670, 493006749, 19408435, 901792540, 296591815, 612592065, 126976656, 550545127, 713682312, 554341273, 659227666, 32137630, 618616533, 896460725, 825059073, 268734665, 433930048, 692919162, 654572982, 743076005, 179071158, 12715291, 768506587, 716084325, 444883934, 658274448, 32633207, 510150348, 678575137, 389783474, 289717289, 258009708, 905802890, 101323055, 460655818, 827114519, 755552086, 971759983, 770634471, 296821014, 565402004, 901438472, 99697944, 764797892, 431034242, 961766428, 688330734, 807695703, 577157820, 842646367, 492988423, 563134659, 968915678, 430819765, 424774182, 818464035, 67747821, 560269824, 939003676, 945755166, 451780142, 842563953, 630883058, 713546251, 269656441, 170195933, 53938110, 377532661, 925261255, 904460613, 186453873, 298168994, 500798594, 188051054, 674271102, 849340791, 886732629, 447736346, 744813476, 376359567, 200455473, 145724415, 667808397, 536072260, 217868928, 103546246, 743164752, 704198425, 511943089, 767050923, 238300257, 988543603, 744138115, 726576480, 441696549, 627531206, 981638885, 404974305, 437479809, 856598496, 118171283, 673822375, 204243232, 526657747, 727137862, 658518949, 843695638, 414529124, 487577190, 818850011, 52229132, 592035454, 2920905, 58070942, 708177338, 419275574, 896622090, 501421504, 422118575, 740859233, 983139963, 388398487, 517656200, 18452349, 425303185, 368262563, 754977475, 935258128, 238778805, 232535078, 400328277, 39435352, 311405782, 23139834, 85715020, 482835822, 988811478, 63337962, 609511746, 207834956, 479007874, 567527487, 342889923, 164787713, 897102913, 137095735, 438979183, 775061272, 687218272, 813415720, 401892698, 491003661, 795423035, 992738761, 476481169, 748385366, 489509479, 455500120, 659385599, 808280670, 72061446, 803508491, 415297638, 902656722, 608821921, 632941473, 168539654, 945901229, 524743917, 218027481, 381956184, 288656278, 795340037, 972636251, 233928766, 263197562, 499031368, 231991495, 727180552, 953392465, 138776411, 4733367, 962859199, 64494795, 133722957, 230305106, 525105007, 183932964, 598171034, 721447068, 626827093, 851825213, 425097480, 477022046, 805869298, 36836062, 550694170, 907257631, 851351317, 253396790, 414051204, 679453718, 612304219, 638659635, 956772981, 525850167, 690359962, 337492891, 200835942, 92031839, 521556569, 243949073, 579929985, 681416532, 606782130, 793494238, 268404994, 143592111, 80678453, 429761900, 3115904, 86910261, 603582422, 210280741, 507471743, 618525901, 447332536, 402136808, 422799510, 292931549, 987999906, 398799308, 90530158, 169060215, 736919738, 564369627, 297799462, 332518655, 229406930, 756613322, 845745292, 920897507, 598408322, 42561922, 6021344, 610451010, 263463935, 532949214, 676349431, 616162790, 765274787, 206898991, 29960765, 825196317, 857291618, 744543994, 314284291, 485860193, 716264373, 746813030, 979486246, 675236851, 97286718, 174059675, 23356194, 143999106, 462057887, 947471968, 38943028, 539943943, 27359840, 93662708, 727269359, 481898551, 57459803, 842188965, 166276467, 390012737, 622214432, 410705324, 211423378, 45061181, 500827686, 213078743, 471218667, 443265013, 99608762, 670436191, 784137388, 667883531, 6203239, 796543866, 260971249, 528145737, 852835333, 966641908, 461429539, 775694404, 518030702, 497490936, 770676269, 59383226, 616257388, 3191031, 65765288, 747787964, 498766952, 63299185, 874386334, 247539606, 558378397, 991143121, 229825834, 18030058, 27203230, 284232294, 586494646, 200192515, 684617324, 955729287, 111651075, 907919474, 771568221, 654787510, 217494480, 206557174, 67901851, 353298182, 913153538, 894208920, 141716008, 196585547, 287380007, 716476022, 629537584, 546455168, 809386351, 248310272, 43075705, 895537761, 39385780, 121847265, 139232284, 317850348, 757547961, 654328199, 626506739, 10561425, 675451049, 977408830, 965379078, 606209191, 189827198, 345033467, 296276118, 782379434, 909792328, 115860760, 14100947, 937994222, 991849197, 997799334, 933592876, 859034935, 715869190, 365331242, 589697412, 895264007, 155859242, 901415896, 698095785, 552050805, 5517492, 709130769, 970312336, 946142157, 601415069, 173142460, 292427070, 186269202, 545680864, 383788791, 953846784, 453374418, 290537620, 534922017, 523218445, 336974503, 208871016, 940960477, 218895443, 646661902, 234284267, 687463977, 21589842, 277463951, 242391872, 506373586, 290211116, 822814104, 152001780, 594214676, 11243442, 174488664, 943192004, 897627443, 969743543, 882679076, 662985581, 295714691, 474108451, 611202476, 518119636, 510347716, 631897901, 781915431, 74178564, 780255029, 342425475, 759029514, 298314043, 939053561, 637136622, 572587280, 84228107, 805592836, 183772938, 451773983, 709140795, 602054521, 655883018, 20906817, 643868155, 943619321, 908145452, 460159045, 863937404, 636020246, 732199530, 328336450, 292693139, 317585801, 963508052, 219709229, 757004259, 477516556, 174742334, 106488920, 690494396, 555731119, 217951151, 126396691, 808524501, 835000146, 796396976, 401318439, 637637017, 71670996, 544660431, 726957872, 525586733, 595833890, 918625645, 362838009, 321509901, 561645440, 486128882, 293767658, 149180749, 784490380, 862748411, 874677564, 533845494, 930439392, 735556334, 4958148, 940355688, 616267696, 237493533, 415342747, 446953183, 131399892, 678142531, 803238238, 737876361, 153895239, 111028709, 959933779, 73762783, 258554275, 477042322, 27847420, 314249115, 105540545, 238928510, 792106135, 689752808, 618434119, 28974359, 747701526, 113837157, 256648673, 260998865, 635834887, 528318440, 317635738, 271106356, 70531145, 458698028, 188502405, 447535955, 353769931, 896042267, 239620475, 833010881, 562064015, 363748498, 560507870, 683079748, 729907987, 20323830, 723727408, 177362789, 375049408, 473826217, 125015216, 625079840, 723985890, 572986989, 771053811, 266093498, 105173978, 981401767, 228897018, 562968014, 107337781, 443572580, 450113167, 7564108, 458700796, 367514752, 742593612, 943888013, 255290764, 253175133, 450238272, 155767301, 564709735, 579657735, 315082764, 194875256, 969408247, 253899244, 702673744, 374755721, 3410679, 709495102, 793745918, 590902508, 891300111, 576346126, 743594753, 378489603, 333325325, 410245396, 198980388, 731286101, 872817591, 944615563, 620517213, 113852003, 172319562, 965156337, 44164663, 260648888, 486454106, 17072868, 294794624, 76043347, 169159562, 633113748, 342270836, 853701234, 340516202, 23303233, 900307700, 141131588, 305566409, 511440511, 164012603, 633591615, 778623734, 721260064, 76111729, 930847192, 582954434, 242020590, 414888365, 412731157, 67482897, 549854159, 512439468, 92361826, 734577811, 981595083, 55551978, 845681767, 672958603, 401469177, 648620114, 970198824, 341866811, 332353729, 634906275, 611679354, 555712430, 746331128, 104341596, 764395622, 275122358, 654586312, 73568232, 422258822, 499103949, 71776123, 565811068, 630726078, 333228272, 232267605, 95261281, 523750834, 279769266, 654799813, 833350453, 946470165, 547740129, 928830704, 804131559, 156003233, 240837163, 285805878, 727614989, 696067134, 677940139, 83495253, 863057640, 404055405, 891606063, 646269752, 696594902, 284795853, 215861451, 128317797, 541431447, 298724338, 725766473, 992964386, 284653096, 295072658, 583109695, 450872479, 196817609, 976744913, 404362291, 5542184, 987829281, 380020839, 765583862, 518996991, 418014814, 601613483, 722223950, 862462707, 326538883, 375301709, 613066118, 552671112, 480643926, 574353963, 701379031, 883401981, 341157911, 383694846, 650791666, 642741236, 669177311, 989146281, 621033784, 911244872, 811636011, 244305792, 399856449, 611348902, 467003589, 333863620, 279076135, 25155852, 384175324, 47426776, 120009404, 624194132, 295815033, 711639470, 47473058, 390761149, 493161761, 33796573, 458354295, 409870344, 853537261, 165428803, 740727950, 334993147, 835415097, 411558130, 158109400, 151633890, 714825910, 587761213, 327156309, 369138521, 326038248, 979232805]\\n\\n        return dp[n-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n        def numTilings(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        # dp = [1,2,5,11]\\n        \\n        # for i in range (4,n):\\n        #     dp.append(dp[i-3] + 2*dp[i-1])\\n\\n        dp = [1, 2, 5, 11, 24, 53, 117, 258, 569, 1255, 2768, 6105, 13465, 29698, 65501, 144467, 318632, 702765, 1549997, 3418626, 7540017, 16630031, 36678688, 80897393, 178424817, 393528322, 867954037, 914332884, 222194076, 312342182, 539017241, 300228551, 912799284, 364615795, 29460134, 971719552, 308054885, 645569904, 262859346, 833773577, 313117044, 889093434, 611960431, 537037899, 963169225, 538298867, 613635626, 190440463, 919179793, 451995198, 94430852, 108041490, 668078178, 430587201, 969215892, 606509948, 643607090, 256430058, 119370057, 882347204, 21124452, 161618961, 205585119, 432294690, 26208334, 258001787, 948298264, 922804855, 103611483, 155521223, 233847294, 571306071, 298133358, 830114010, 231534077, 761201512, 352517020, 936568117, 634337732, 621192477, 178953057, 992243846, 605680155, 390313360, 772870559, 151421259, 693155878, 159182301, 469785861, 632727593, 424637480, 319060814, 270849214, 966335908, 251732616, 774314446, 514964786, 281662181, 337638801, 190242381, 662146943, 661932680, 514107734, 690362404, 42657474, 599422682, 889207761, 821072989, 241568646, 372345046, 565763074, 373094787, 118534613, 802832300, 978759380, 76053359, 954939018, 888637402, 853328156, 661595316, 211828020, 276984189, 215563687, 642955394, 562894970, 341353620, 325662627, 214220217, 769794054, 865250728, 944721666, 659237372, 183725458, 312172575, 283582515, 750890488, 813953544, 911489596, 573869666, 961692869, 834875320, 243620292, 448933446, 732742205, 709104695, 867142829, 467027849, 643160386, 153463587, 773955023, 191070418, 535604423, 845163862, 881398135, 298400679, 441965213, 765328554, 829057780, 100080759, 965490072, 760037910, 620156572, 205803202, 171644307, 963445186, 132693560, 437031427, 837508033, 807709619, 52450651, 942409335, 692528275, 437507194, 817423716, 327375693, 92258573, 1940855, 331257403, 754773379, 511487606, 354232608, 463238588, 437964775, 230162151, 923562890, 285090541, 800343233, 524249342, 333589218, 467521662, 459292659, 252174529, 971870720, 403034085, 58242692, 88356097, 579746279, 217735243, 523826583, 627399438, 472534112, 468894800, 565189031, 602912167, 674719127, 914627278, 432166709, 539052538, 992732347, 417631389, 374315309, 741362958, 900357298, 175029891, 91422733, 83202757, 341435405, 774293543, 631789836, 605015070, 984323676, 600437174, 805889411, 596102484, 792642135, 391173667, 378449811, 549541750, 490257160, 358964124, 267469991, 25197135, 409358394, 86186772, 197570679, 804499752, 695186269, 587943210, 980386165, 655958585, 899860373, 780106897, 216172365, 332205096, 444517082, 105206522, 542618140, 529753355, 164713225, 872044590, 273842521, 712398267, 296841110, 867524741, 447447735, 191736573, 250997880, 949443495, 90623549, 432244978, 813933444, 718490430, 869225831, 552385092, 823260607, 515747031, 583879147, 991018894, 497784805, 579448750, 149916380, 797617565, 174683866, 499284112, 796185782, 767055423, 33394944, 862975670, 493006749, 19408435, 901792540, 296591815, 612592065, 126976656, 550545127, 713682312, 554341273, 659227666, 32137630, 618616533, 896460725, 825059073, 268734665, 433930048, 692919162, 654572982, 743076005, 179071158, 12715291, 768506587, 716084325, 444883934, 658274448, 32633207, 510150348, 678575137, 389783474, 289717289, 258009708, 905802890, 101323055, 460655818, 827114519, 755552086, 971759983, 770634471, 296821014, 565402004, 901438472, 99697944, 764797892, 431034242, 961766428, 688330734, 807695703, 577157820, 842646367, 492988423, 563134659, 968915678, 430819765, 424774182, 818464035, 67747821, 560269824, 939003676, 945755166, 451780142, 842563953, 630883058, 713546251, 269656441, 170195933, 53938110, 377532661, 925261255, 904460613, 186453873, 298168994, 500798594, 188051054, 674271102, 849340791, 886732629, 447736346, 744813476, 376359567, 200455473, 145724415, 667808397, 536072260, 217868928, 103546246, 743164752, 704198425, 511943089, 767050923, 238300257, 988543603, 744138115, 726576480, 441696549, 627531206, 981638885, 404974305, 437479809, 856598496, 118171283, 673822375, 204243232, 526657747, 727137862, 658518949, 843695638, 414529124, 487577190, 818850011, 52229132, 592035454, 2920905, 58070942, 708177338, 419275574, 896622090, 501421504, 422118575, 740859233, 983139963, 388398487, 517656200, 18452349, 425303185, 368262563, 754977475, 935258128, 238778805, 232535078, 400328277, 39435352, 311405782, 23139834, 85715020, 482835822, 988811478, 63337962, 609511746, 207834956, 479007874, 567527487, 342889923, 164787713, 897102913, 137095735, 438979183, 775061272, 687218272, 813415720, 401892698, 491003661, 795423035, 992738761, 476481169, 748385366, 489509479, 455500120, 659385599, 808280670, 72061446, 803508491, 415297638, 902656722, 608821921, 632941473, 168539654, 945901229, 524743917, 218027481, 381956184, 288656278, 795340037, 972636251, 233928766, 263197562, 499031368, 231991495, 727180552, 953392465, 138776411, 4733367, 962859199, 64494795, 133722957, 230305106, 525105007, 183932964, 598171034, 721447068, 626827093, 851825213, 425097480, 477022046, 805869298, 36836062, 550694170, 907257631, 851351317, 253396790, 414051204, 679453718, 612304219, 638659635, 956772981, 525850167, 690359962, 337492891, 200835942, 92031839, 521556569, 243949073, 579929985, 681416532, 606782130, 793494238, 268404994, 143592111, 80678453, 429761900, 3115904, 86910261, 603582422, 210280741, 507471743, 618525901, 447332536, 402136808, 422799510, 292931549, 987999906, 398799308, 90530158, 169060215, 736919738, 564369627, 297799462, 332518655, 229406930, 756613322, 845745292, 920897507, 598408322, 42561922, 6021344, 610451010, 263463935, 532949214, 676349431, 616162790, 765274787, 206898991, 29960765, 825196317, 857291618, 744543994, 314284291, 485860193, 716264373, 746813030, 979486246, 675236851, 97286718, 174059675, 23356194, 143999106, 462057887, 947471968, 38943028, 539943943, 27359840, 93662708, 727269359, 481898551, 57459803, 842188965, 166276467, 390012737, 622214432, 410705324, 211423378, 45061181, 500827686, 213078743, 471218667, 443265013, 99608762, 670436191, 784137388, 667883531, 6203239, 796543866, 260971249, 528145737, 852835333, 966641908, 461429539, 775694404, 518030702, 497490936, 770676269, 59383226, 616257388, 3191031, 65765288, 747787964, 498766952, 63299185, 874386334, 247539606, 558378397, 991143121, 229825834, 18030058, 27203230, 284232294, 586494646, 200192515, 684617324, 955729287, 111651075, 907919474, 771568221, 654787510, 217494480, 206557174, 67901851, 353298182, 913153538, 894208920, 141716008, 196585547, 287380007, 716476022, 629537584, 546455168, 809386351, 248310272, 43075705, 895537761, 39385780, 121847265, 139232284, 317850348, 757547961, 654328199, 626506739, 10561425, 675451049, 977408830, 965379078, 606209191, 189827198, 345033467, 296276118, 782379434, 909792328, 115860760, 14100947, 937994222, 991849197, 997799334, 933592876, 859034935, 715869190, 365331242, 589697412, 895264007, 155859242, 901415896, 698095785, 552050805, 5517492, 709130769, 970312336, 946142157, 601415069, 173142460, 292427070, 186269202, 545680864, 383788791, 953846784, 453374418, 290537620, 534922017, 523218445, 336974503, 208871016, 940960477, 218895443, 646661902, 234284267, 687463977, 21589842, 277463951, 242391872, 506373586, 290211116, 822814104, 152001780, 594214676, 11243442, 174488664, 943192004, 897627443, 969743543, 882679076, 662985581, 295714691, 474108451, 611202476, 518119636, 510347716, 631897901, 781915431, 74178564, 780255029, 342425475, 759029514, 298314043, 939053561, 637136622, 572587280, 84228107, 805592836, 183772938, 451773983, 709140795, 602054521, 655883018, 20906817, 643868155, 943619321, 908145452, 460159045, 863937404, 636020246, 732199530, 328336450, 292693139, 317585801, 963508052, 219709229, 757004259, 477516556, 174742334, 106488920, 690494396, 555731119, 217951151, 126396691, 808524501, 835000146, 796396976, 401318439, 637637017, 71670996, 544660431, 726957872, 525586733, 595833890, 918625645, 362838009, 321509901, 561645440, 486128882, 293767658, 149180749, 784490380, 862748411, 874677564, 533845494, 930439392, 735556334, 4958148, 940355688, 616267696, 237493533, 415342747, 446953183, 131399892, 678142531, 803238238, 737876361, 153895239, 111028709, 959933779, 73762783, 258554275, 477042322, 27847420, 314249115, 105540545, 238928510, 792106135, 689752808, 618434119, 28974359, 747701526, 113837157, 256648673, 260998865, 635834887, 528318440, 317635738, 271106356, 70531145, 458698028, 188502405, 447535955, 353769931, 896042267, 239620475, 833010881, 562064015, 363748498, 560507870, 683079748, 729907987, 20323830, 723727408, 177362789, 375049408, 473826217, 125015216, 625079840, 723985890, 572986989, 771053811, 266093498, 105173978, 981401767, 228897018, 562968014, 107337781, 443572580, 450113167, 7564108, 458700796, 367514752, 742593612, 943888013, 255290764, 253175133, 450238272, 155767301, 564709735, 579657735, 315082764, 194875256, 969408247, 253899244, 702673744, 374755721, 3410679, 709495102, 793745918, 590902508, 891300111, 576346126, 743594753, 378489603, 333325325, 410245396, 198980388, 731286101, 872817591, 944615563, 620517213, 113852003, 172319562, 965156337, 44164663, 260648888, 486454106, 17072868, 294794624, 76043347, 169159562, 633113748, 342270836, 853701234, 340516202, 23303233, 900307700, 141131588, 305566409, 511440511, 164012603, 633591615, 778623734, 721260064, 76111729, 930847192, 582954434, 242020590, 414888365, 412731157, 67482897, 549854159, 512439468, 92361826, 734577811, 981595083, 55551978, 845681767, 672958603, 401469177, 648620114, 970198824, 341866811, 332353729, 634906275, 611679354, 555712430, 746331128, 104341596, 764395622, 275122358, 654586312, 73568232, 422258822, 499103949, 71776123, 565811068, 630726078, 333228272, 232267605, 95261281, 523750834, 279769266, 654799813, 833350453, 946470165, 547740129, 928830704, 804131559, 156003233, 240837163, 285805878, 727614989, 696067134, 677940139, 83495253, 863057640, 404055405, 891606063, 646269752, 696594902, 284795853, 215861451, 128317797, 541431447, 298724338, 725766473, 992964386, 284653096, 295072658, 583109695, 450872479, 196817609, 976744913, 404362291, 5542184, 987829281, 380020839, 765583862, 518996991, 418014814, 601613483, 722223950, 862462707, 326538883, 375301709, 613066118, 552671112, 480643926, 574353963, 701379031, 883401981, 341157911, 383694846, 650791666, 642741236, 669177311, 989146281, 621033784, 911244872, 811636011, 244305792, 399856449, 611348902, 467003589, 333863620, 279076135, 25155852, 384175324, 47426776, 120009404, 624194132, 295815033, 711639470, 47473058, 390761149, 493161761, 33796573, 458354295, 409870344, 853537261, 165428803, 740727950, 334993147, 835415097, 411558130, 158109400, 151633890, 714825910, 587761213, 327156309, 369138521, 326038248, 979232805]\\n\\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947652,
                "title": "python3-dp-non-mathematical-detailed-explanation-with-plots",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are 3 steps to come up with the final solution:\\n1. recognize it is a DP problem (given examples with smaller n, ask what is the total number of ways for large n)\\n2. top-down relationship to fill up the entire 2 * n grid\\n3. identify the base case to construct bottom-up DP solution\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Step 1.\\nThis is easy to identify. If not you just have to do more problems to become sensitive of the keywords in the problem statement. I will explain 2. and 3.\\n\\n\\n# Step 2.\\nTo fill up the entire 2 * n grid with tiles, at the nth and (n-1)th column, it has to look like one of the followings:\\n- type A: nth column filled by a vertical tile \\n- type B: nth and (n-1)th columns filled by two horizontal tiles\\n- type C: a corner tile at nth and (n-1)th columns but leaves the bottom cell at the (n-1)th column\\n- type D: nth and (n-1)th columns but leaves the upper cell at the (n-1)th column\\n![Screen Shot 2022-12-24 at 4.27.37 PM.png](https://assets.leetcode.com/users/images/03869694-2fed-454e-888f-258fafc7f563_1671928369.2005029.png)\\n\\n\\nIf we could figure out the number of ways to construct each of the above types, we can derive the total number of ways to fill up the entire 2 * n grid. And this number will essentially be equal to the total number of ways to fill up the grey area in the above pictures.\\n\\nWe will need 3 different arrays (x[i], y[i], z[i], where i denotes at the ith column) to calculate the total number of ways to fill up the grey area:\\n- x[i]: total number of ways to fill up the entire 2 * i grid (used by typeA and type B)\\n- y[i]: total number of ways to fill up the entire 2 * (i-1) grid & bottom cell at the ith column (used by typeC)\\n- z[i]: total number of ways to fill up the entire 2 * (i-1) grid & upper cell at the ith column (used by typeD)\\n\\nIn particular, we can further investigate the way to get y[i] and z[i]:\\n- y has to be one of the following conditions (I & II):\\n![Screen Shot 2022-12-24 at 4.28.14 PM.png](https://assets.leetcode.com/users/images/5c5f4a53-d85b-4317-a5d4-4739abacb73a_1671928394.0732508.png)\\n\\nyielding y[i] = z[i-1] + x[i-2]\\n- z has to be one of the following conditions (I & II):\\n![Screen Shot 2022-12-24 at 4.28.26 PM.png](https://assets.leetcode.com/users/images/588ce874-f23f-4389-beb6-bcd23035582a_1671928420.0176294.png)\\n\\nyielding z[i] = y[i-1] + x[i-2]\\n\\ncombining the above relationships, x[i] = typeA + typeB + typeC + typeD = x[i-1] + x[i-2] + y[i-1] + z[i-1], with the final answer being i = n\\n\\n\\n# Step 3.\\nThe base cases are as the followings:\\nwhen i = 1, \\nx[1] = 1 (vertical tile to fill the 1st column)\\ny[1] = 0 (no way can fill in a bottom corner tile)\\nz[1] = 0 (no way can fill in a upper corner tile)\\n![Screen Shot 2022-12-24 at 4.41.01 PM.png](https://assets.leetcode.com/users/images/7748abf3-1a2e-43dc-82a6-b7bed997bf1f_1671928899.1086092.png)\\n\\nwhen i = 2, \\nx[2] = 2 (2 ways, 2 vertical tiles or 2 horizontal tiles)\\ny[2] = 1\\nz[2] = 1\\n![Screen Shot 2022-12-24 at 4.41.07 PM.png](https://assets.leetcode.com/users/images/cdb0d408-f80a-402d-91b1-6d426d602fa0_1671928910.0415542.png)\\n\\nCombining step 2 and 3, we can construct a 2D DP table. The picture below shows an example how to compute the column when i = 3 where the red cell is the sum of the yellow cells using the relationship derived in step 2. :\\n![Screen Shot 2022-12-24 at 4.41.20 PM.png](https://assets.leetcode.com/users/images/0ea9a513-40f2-4970-8975-32347201d26a_1671929018.047585.png)\\n\\nThe following table goes up t0 i = 5:\\n![Screen Shot 2022-12-24 at 4.48.06 PM.png](https://assets.leetcode.com/users/images/9321c969-4fb3-4a81-ad23-da2ce2f89e9b_1671929300.3436341.png)\\n\\n\\nThe final answer will be the last element in array x (representing the total number of ways to fill up the entire 2 * n grid).\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ but can be reduced to $$O(1)$$ as one only needs the previous two columns to compute the current column\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        # 2D DP\\n        dp = [[0] * n for i in range(3)]\\n        # initialize\\n        dp[0][0], dp[0][1], dp[1][1], dp[2][1] = 1, 2, 1, 1\\n        for i in range(2, n):\\n            dp[0][i] = dp[0][i - 1] + dp[1][i - 1] + dp[2][i - 1] + dp[0][i - 2]\\n            dp[1][i] = dp[2][i - 1] + dp[0][i - 2]\\n            dp[2][i] = dp[1][i - 1] + dp[0][i - 2]\\n        return dp[0][-1] % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        # 2D DP\\n        dp = [[0] * n for i in range(3)]\\n        # initialize\\n        dp[0][0], dp[0][1], dp[1][1], dp[2][1] = 1, 2, 1, 1\\n        for i in range(2, n):\\n            dp[0][i] = dp[0][i - 1] + dp[1][i - 1] + dp[2][i - 1] + dp[0][i - 2]\\n            dp[1][i] = dp[2][i - 1] + dp[0][i - 2]\\n            dp[2][i] = dp[1][i - 1] + dp[0][i - 2]\\n        return dp[0][-1] % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947410,
                "title": "c-easy-to-understand-dp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int modulo = 1e9 + 7;\\n    int solver(int n, bool usedTromino, vector<vector<int>> &dp) {\\n        if(n < 0) return 0;\\n        if(n == 0) {\\n            if(usedTromino) return 0;\\n            return 1;\\n        } \\n        \\n        if(dp[n][usedTromino] != -1) return dp[n][usedTromino];\\n        \\n        long long way1 = 0 , way2 = 0 , way3 = 0, way4 = 0;\\n        \\n        // Using Dominos\\n        if(n >= 2 && !usedTromino) way1 = solver(n - 2, usedTromino, dp);\\n        if(n >= 1) way2 = solver(n - 1, usedTromino, dp);\\n        \\n        // Using Trominos . These must be used as a pair i.e even no. times because using a tromino but not coupling with an opposite tromino  will result in a tile being uncovered.\\n        \\n        // Opening Tromino \\n        if(n >= 3 && !usedTromino) way3 = 2 * solver(n - 2, !usedTromino, dp);\\n        // Closing Tromino to fit into the space left by opening tromino\\n        if(n >= 1 && usedTromino) way4 = solver(n - 1, !usedTromino, dp);\\n        \\n        return dp[n][usedTromino] = (way1 + way2 + way3 + way4) % modulo;\\n    }\\n    \\n    int numTilings(int n) {\\n        vector<vector<int>> dp(n  + 1, vector<int>(2, -1));\\n        \\n        return solver(n, false, dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int modulo = 1e9 + 7;\\n    int solver(int n, bool usedTromino, vector<vector<int>> &dp) {\\n        if(n < 0) return 0;\\n        if(n == 0) {\\n            if(usedTromino) return 0;\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2947086,
                "title": "java-1d-dp",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int numTilings(int n) {\\n        if (n < 3) {\\n            return n;\\n        }\\n\\n        int mod = 1000000007;\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n\\n        for (int i = 4; i <= n; i++) {\\n            dp[i] = (2 * dp[i - 1] % mod + dp[i - 3] % mod) % mod;\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int numTilings(int n) {\\n        if (n < 3) {\\n            return n;\\n        }\\n\\n        int mod = 1000000007;\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n\\n        for (int i = 4; i <= n; i++) {\\n            dp[i] = (2 * dp[i - 1] % mod + dp[i - 3] % mod) % mod;\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947010,
                "title": "faster-than-100-tabulation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int md=1e9+7;\\n    int numTilings(int n) {\\n        int dp[n+1];\\n        if(n<=2)\\n        return n;\\n\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++)\\n        {\\n            dp[i]=((dp[i-1]*2)%md+(dp[i-3])%md)%md;\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int md=1e9+7;\\n    int numTilings(int n) {\\n        int dp[n+1];\\n        if(n<=2)\\n        return n;\\n\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++)\\n        {\\n            dp[i]=((dp[i-1]*2)%md+(dp[i-3])%md)%md;\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946911,
                "title": "easy-c-solution-must-check",
                "content": "**Intuition:**\\n\\nFrom observation\\n\\n`v[0] = 0;\\nv[1] = 1;\\nv[2] = 2;\\nv[3] = 5;`\\n\\n\\nNow we can find the value using the formula ``` v[i] = 2*v[i-1] + v[i-3] ```\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int md = 1e9;\\n        md += 7;\\n\\n        vector<long long> v(1001,0);\\n\\n        v[0] = 0;\\n        v[1] = 1;\\n        v[2] = 2;\\n        v[3] = 5;\\n\\n        if(n <= 3)\\n            return v[n];\\n\\n        for(int i = 4; i <=n;i++)\\n        {\\n            v[i] = 2*v[i-1] + v[i-3];\\n            v[i] = v[i] % md;\\n        }    \\n        return v[n];\\n\\n    }\\n};\\n```\\n\\n\\n\\n**Complexity:**\\n- Time complexity:```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:```O(n)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n----\\n\\n\\nIf this solution helps you, then please ```UPVOTE``` .\\nTill then **keep Learning, Keep Exploring !!!**\\n\\n**Thank you !!**\\n\\n\\n---",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "``` v[i] = 2*v[i-1] + v[i-3] ```\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int md = 1e9;\\n        md += 7;\\n\\n        vector<long long> v(1001,0);\\n\\n        v[0] = 0;\\n        v[1] = 1;\\n        v[2] = 2;\\n        v[3] = 5;\\n\\n        if(n <= 3)\\n            return v[n];\\n\\n        for(int i = 4; i <=n;i++)\\n        {\\n            v[i] = 2*v[i-1] + v[i-3];\\n            v[i] = v[i] % md;\\n        }    \\n        return v[n];\\n\\n    }\\n};\\n```\n```O(n)```\n```O(n)```\n```UPVOTE```",
                "codeTag": "Java"
            },
            {
                "id": 2946779,
                "title": "c-explained-recursion-memorization-dp-tabulation-dp",
                "content": "# Intuition\\nWhenever we are asked to find the number of ways we try to think from recursion point of view (Not everytime but mostly we get a way to proceed ahead)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n![image.png](https://assets.leetcode.com/users/images/6b54c7a3-df31-4473-8199-81a4b93c2c81_1671903084.671635.png)\\n![image.png](https://assets.leetcode.com/users/images/95ec3884-a58f-4ace-b8c7-cd53732dcf1e_1671903222.124374.png)\\n\\nThus we get two recurrence relations\\nf(n) = f(n-1) + f(n-2) + 2*(n-2)\\ng(n) = f(n-1) + g(n-1)\\n\\n# Recursion - TLE\\n\\n-> instead of taking a seperate function call for g(n), I have written g(n) = f(n, true)\\n```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    long long f(int n, bool flag){\\n        if (n < 3) return n;\\n        if (flag)\\n            return (f(n-1, false) + f(n-1, true)) % m;\\n        return (f(n-1, false) + f(n-2, false) + 2*f(n-2, true)) % m;\\n    }\\n    int numTilings(int n) {\\n        int ans = f(n, false);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Memorization \\n-> dp[1001][2] is created as n can take a maximum of 1000\\n-> repeated calls are pruned\\n```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    long long f(int n, bool flag, vector<vector<int>> &dp){\\n        if (n < 3) return n;\\n        if (dp[n][flag] != -1) return dp[n][flag];\\n        if (flag)\\n            return dp[n][flag] = (f(n-1, false, dp) + f(n-1, true, dp)) % m;\\n        return dp[n][flag] = (f(n-1, false, dp) + f(n-2, false, dp) + 2*f(n-2, true, dp)) % m;\\n    }\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(1001, vector<int>(2, -1));\\n        int ans = f(n, false, dp);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Tabular \\n```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    int numTilings(int n) {\\n        vector<long long> f(1001, 0);\\n        vector<long long> g(1001, 0);\\n        f[1] = g[1] = 1;\\n        f[2] = g[2] = 2;\\n        for(int i = 3;i <= n; i++){\\n            g[i] = (f[i-1] + g[i-1])%m ;\\n            f[i] = (f[i-1] + f[i-2] + 2*g[i-2])%m;\\n        }\\n        return f[n];\\n    }\\n};\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    Recursion - O(3**n) for each state we are trying to explore 3 sub states\\n    Memorization and Tabular form - O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    long long f(int n, bool flag){\\n        if (n < 3) return n;\\n        if (flag)\\n            return (f(n-1, false) + f(n-1, true)) % m;\\n        return (f(n-1, false) + f(n-2, false) + 2*f(n-2, true)) % m;\\n    }\\n    int numTilings(int n) {\\n        int ans = f(n, false);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    long long f(int n, bool flag, vector<vector<int>> &dp){\\n        if (n < 3) return n;\\n        if (dp[n][flag] != -1) return dp[n][flag];\\n        if (flag)\\n            return dp[n][flag] = (f(n-1, false, dp) + f(n-1, true, dp)) % m;\\n        return dp[n][flag] = (f(n-1, false, dp) + f(n-2, false, dp) + 2*f(n-2, true, dp)) % m;\\n    }\\n    int numTilings(int n) {\\n        vector<vector<int>> dp(1001, vector<int>(2, -1));\\n        int ans = f(n, false, dp);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m = 1e9 + 7;\\n    int numTilings(int n) {\\n        vector<long long> f(1001, 0);\\n        vector<long long> g(1001, 0);\\n        f[1] = g[1] = 1;\\n        f[2] = g[2] = 2;\\n        for(int i = 3;i <= n; i++){\\n            g[i] = (f[i-1] + g[i-1])%m ;\\n            f[i] = (f[i-1] + f[i-2] + 2*g[i-2])%m;\\n        }\\n        return f[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946271,
                "title": "brute-force-to-space-optimized-c-solution",
                "content": "# 1               2\\n# 3               4\\n**tromino1** : 2->1->3  (works as **gap maker**)\\n**tromino2** : 1->3->4  (works as **gap maker**)\\n**tromino3** : 3->4->2  (works as **gap remover**)\\n**tromino4** : 1->2->4  (works as **gap remover**)\\n       \\n**normalchoice1** -> adding a **domino(verical)**, it **will not create any gap**, go to i + 1\\n**normalchoice2** -> adding **dominoes(horizontal) in pairs**, it **will not create any gap**, go to i + 2       \\n**normalchoice3** -> adding a **tromino1/ tromino2** it will **create a gap**, go to i + 2\\n\\n**NOTE** : you have to consider normalchoice3 two times, because - \\n\\t\\t\\t\\t there will be situation where you can use tromino1 **OR** tromino2\\n\\t\\t\\t\\t \\n**gapchoice1** -> adding a **domino(horizontal)** to fill the prev gap but it will **create a gap**\\n**gapchoice2** -> adding a **tromino3 / tromino4** to fill the prev gap but it will **not create any gap**\\n\\t\\n**NOTE** : you have to consider gapchoice2 **only one time**, because -\\n\\n**(1)** there will **no** situation where you can use tromino3 **OR** tromino4\\n**(2)** there will be **(** a situation where you have to use tromino3 **)**\\n\\t\\t\\t **OR** **(** a situation where you have to use tromino4 **)**\\n\\n**BASIC RECURSIVE SOLUTION :**\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int helper(int i,bool empty,int n) {\\n        if(i == n && !empty) return 1;\\n        if(i >= n) return 0;\\n        if(empty) {\\n            long gapchoice1 = helper(i + 1,true,n);\\n            long gapchoice2 = helper(i + 1,false,n);\\n            return (gapchoice1 + gapchoice2) % mod;\\n        }\\n        else {\\n            long normalchoice1 = helper(i + 1,false,n);\\n            long normalchoice2 = helper(i + 2,false,n);\\n            long normalchoice3 = helper(i + 2,true,n);\\n            return  (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n        }\\n    }\\n    \\n    int numTilings(int n) {\\n        return helper(0,false,n);\\n    }\\n};\\n```\\n**Time** : O(3^N)\\n**Space** : O(N)\\n\\n**MEMOIZATION :**\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int helper(int i,bool empty,int n,vector<vector<int>>& dp) {\\n        if(i == n && !empty) return 1;\\n        if(i >= n) return 0;\\n        if(dp[i][empty] != -1) return dp[i][empty];\\n        if(empty) {\\n            long gapchoice1 = helper(i + 1,true,n,dp);\\n            long gapchoice2 = helper(i + 1,false,n,dp);\\n            return dp[i][empty] = (gapchoice1 + gapchoice2) % mod;\\n        }\\n        else {\\n            long normalchoice1 = helper(i + 1,false,n,dp);\\n            long normalchoice2 = helper(i + 2,false,n,dp);\\n            long normalchoice3 = helper(i + 2,true,n,dp);\\n            return dp[i][empty] = (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n        }\\n    }\\n    \\n    int numTilings(int n) {\\n        vector<vector<int>>dp(n,vector<int>(2,-1));\\n        return helper(0,false,n,dp);\\n    }\\n};\\n```\\n**Time** : O(N)\\n**Space** : O(N)\\n\\n**ITERATIVE SOLUTION (TABULATION) :**\\n```\\nclass Solution {\\npublic:\\n\\n    int numTilings(int n) {\\n        int mod = 1e9 + 7;\\n        vector<vector<int>>dp(n + 2,vector<int>(2,0));\\n        dp[n][0] = 1;\\n        \\n        for(int i = n - 1;i >= 0;i--) {\\n            for(int j = 1;j >= 0;j--) {\\n                if(j) {\\n                    long gapchoice1 = dp[i + 1][1];\\n                    long gapchoice2 = dp[i + 1][0];\\n                    dp[i][j] = (gapchoice1 + gapchoice2) % mod;\\n                }\\n                else {\\n                    long normalchoice1 = dp[i + 1][0];\\n                    long normalchoice2 = dp[i + 2][0];\\n                    long normalchoice3 = dp[i + 2][1];\\n                    dp[i][j] = (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n**Time** : O(N)\\n**Space** : O(N)\\n\\n**ITERATIVE SOLUTION (SPACE OPTIMIZED) :**\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int mod = 1e9 + 7;\\n        vector<int>second(2,0);\\n        vector<int>first(2,0);\\n        vector<int>curr(2,0);\\n        first[0] = 1;\\n        for(int i = n - 1;i >= 0;i--) {\\n            for(int j = 1;j >= 0;j--) {\\n                if(j) {\\n                    long gapchoice1 = first[1];\\n                    long gapchoice2 = first[0];\\n                    curr[j] = (gapchoice1 + gapchoice2) % mod;\\n                }\\n                else {\\n                    long normalchoice1 = first[0];\\n                    long normalchoice2 = second[0];\\n                    long normalchoice3 = second[1];\\n                    curr[j] = (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n                }\\n            }\\n            second = first;\\n            first = curr;\\n        }\\n        return first[0];\\n    }\\n};\\n```\\n**Time** : O(N)\\n**Space** : O(1)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int helper(int i,bool empty,int n) {\\n        if(i == n && !empty) return 1;\\n        if(i >= n) return 0;\\n        if(empty) {\\n            long gapchoice1 = helper(i + 1,true,n);\\n            long gapchoice2 = helper(i + 1,false,n);\\n            return (gapchoice1 + gapchoice2) % mod;\\n        }\\n        else {\\n            long normalchoice1 = helper(i + 1,false,n);\\n            long normalchoice2 = helper(i + 2,false,n);\\n            long normalchoice3 = helper(i + 2,true,n);\\n            return  (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n        }\\n    }\\n    \\n    int numTilings(int n) {\\n        return helper(0,false,n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int helper(int i,bool empty,int n,vector<vector<int>>& dp) {\\n        if(i == n && !empty) return 1;\\n        if(i >= n) return 0;\\n        if(dp[i][empty] != -1) return dp[i][empty];\\n        if(empty) {\\n            long gapchoice1 = helper(i + 1,true,n,dp);\\n            long gapchoice2 = helper(i + 1,false,n,dp);\\n            return dp[i][empty] = (gapchoice1 + gapchoice2) % mod;\\n        }\\n        else {\\n            long normalchoice1 = helper(i + 1,false,n,dp);\\n            long normalchoice2 = helper(i + 2,false,n,dp);\\n            long normalchoice3 = helper(i + 2,true,n,dp);\\n            return dp[i][empty] = (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n        }\\n    }\\n    \\n    int numTilings(int n) {\\n        vector<vector<int>>dp(n,vector<int>(2,-1));\\n        return helper(0,false,n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int numTilings(int n) {\\n        int mod = 1e9 + 7;\\n        vector<vector<int>>dp(n + 2,vector<int>(2,0));\\n        dp[n][0] = 1;\\n        \\n        for(int i = n - 1;i >= 0;i--) {\\n            for(int j = 1;j >= 0;j--) {\\n                if(j) {\\n                    long gapchoice1 = dp[i + 1][1];\\n                    long gapchoice2 = dp[i + 1][0];\\n                    dp[i][j] = (gapchoice1 + gapchoice2) % mod;\\n                }\\n                else {\\n                    long normalchoice1 = dp[i + 1][0];\\n                    long normalchoice2 = dp[i + 2][0];\\n                    long normalchoice3 = dp[i + 2][1];\\n                    dp[i][j] = (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int mod = 1e9 + 7;\\n        vector<int>second(2,0);\\n        vector<int>first(2,0);\\n        vector<int>curr(2,0);\\n        first[0] = 1;\\n        for(int i = n - 1;i >= 0;i--) {\\n            for(int j = 1;j >= 0;j--) {\\n                if(j) {\\n                    long gapchoice1 = first[1];\\n                    long gapchoice2 = first[0];\\n                    curr[j] = (gapchoice1 + gapchoice2) % mod;\\n                }\\n                else {\\n                    long normalchoice1 = first[0];\\n                    long normalchoice2 = second[0];\\n                    long normalchoice3 = second[1];\\n                    curr[j] = (normalchoice1 + normalchoice2 + 2*normalchoice3) % mod;\\n                }\\n            }\\n            second = first;\\n            first = curr;\\n        }\\n        return first[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946235,
                "title": "c-solution-with-explanation-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given a 2*n grid and we need to return the number of ways to tile the grid using domino (2x1 shape) and tromino(L shape) tiles.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this problem we have to observe the pattern\\nBy Observation \\n When n is equal to 0 and 1, the number of ways to tile the grid is 1 using a single domino.\\nWhen n is equal to 2, the number of ways to tile the grid is 2 using two domino.\\nWhen n is equal to 3, the number of ways to tile the grid is 5 using a both domino and tronimo.\\n \\nTherefore, Number of ways = 2*(n-1) + (n-3) \\n```\\ncolumns, n   = 0 1 2 3 4  5  6  7   8  .......so on.\\nno. of ways  = 1 1 2 5 11 24 53 117 258 ......so on.\\n```\\n# Recursive Solution- Gives TLE\\n```\\n    long mod = 1e9+7;\\n    int find(int n){\\n        //Base case\\n        if(n<=1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        return (2*find(n-1)%mod +find(n-3)%mod)%mod;\\n    }\\n\\n    int numTilings(int n) {\\n        return find(n);\\n    }\\n```\\n \\n#   Memoization - Recursive Solution \\n   ```\\n long mod = 1e9+7;\\n    int find(int n,vector<int>&dp){\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        dp[n] = (2*find(n-1,dp)%mod +find(n-3,dp)%mod)%mod;\\n        return dp[n];\\n    }\\n\\n    int numTilings(int n){\\n        vector<int>dp(1001,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n        return find(n,dp);\\n    }\\n```\\n\\n# Complexity\\n- Time complexity:O(n) - *where N is the given number of columns of grid*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)  -*required for recursive stack and maintaining dp*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# DP Solution\\n  ```\\n  long mod = 1e9+7;\\n\\n    int numTilings(int n){\\n        vector<int>dp(1001,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n              dp[i] = (2*dp[i-1]%mod +dp[i-3]%mod)%mod;\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:O(n) - *where N is the given number of columns of grid*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)  -*required for maintaining dp*",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ncolumns, n   = 0 1 2 3 4  5  6  7   8  .......so on.\\nno. of ways  = 1 1 2 5 11 24 53 117 258 ......so on.\\n```\n```\\n    long mod = 1e9+7;\\n    int find(int n){\\n        //Base case\\n        if(n<=1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        return (2*find(n-1)%mod +find(n-3)%mod)%mod;\\n    }\\n\\n    int numTilings(int n) {\\n        return find(n);\\n    }\\n```\n```\\n long mod = 1e9+7;\\n    int find(int n,vector<int>&dp){\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        dp[n] = (2*find(n-1,dp)%mod +find(n-3,dp)%mod)%mod;\\n        return dp[n];\\n    }\\n\\n    int numTilings(int n){\\n        vector<int>dp(1001,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n        return find(n,dp);\\n    }\\n```\n```\\n  long mod = 1e9+7;\\n\\n    int numTilings(int n){\\n        vector<int>dp(1001,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n              dp[i] = (2*dp[i-1]%mod +dp[i-3]%mod)%mod;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946000,
                "title": "simple-c-solution-with-explanation-tc-o-n-and-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe value starts repeating after 4.\\n1 -> 1\\n2 -> 2\\n3 -> 5\\n4 -> 11 -> (2 X 5)+1\\n5 -> 24 -> (2 X 11)+1\\n6 -> 53 -> (2 X 24)+5\\n7 -> 117 -> (2 X 53)+11\\n8 -> 258 -> (2 X 117)+24\\n9 -> 569 -> (2 X 258)+53\\n10 -> 1255 -> (2 X 569)+117\\n\\nformula = 2*a[n-1]+a[n-3]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are taking list of size 4. Therefore, The size complexity is O(1).\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        list<long> l;\\n        l.push_back(1);\\n        for(int i=1;i<=n;i++)\\n            if(i < 3)\\n                l.push_back(i);\\n            else {\\n                int t = l.front();\\n                l.pop_front();\\n                l.push_back((2*l.back() + t)%1000000007);\\n            }\\n        return l.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        list<long> l;\\n        l.push_back(1);\\n        for(int i=1;i<=n;i++)\\n            if(i < 3)\\n                l.push_back(i);\\n            else {\\n                int t = l.front();\\n                l.pop_front();\\n                l.push_back((2*l.back() + t)%1000000007);\\n            }\\n        return l.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945945,
                "title": "790-domino-and-tromino-tiling-beats-100-c-solutions-explanation-with-images",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Idea here is to maintain a state variable. There are three states possible -> \\n\\n![image.png](https://assets.leetcode.com/users/images/30037b2d-5aaa-4a00-9f1f-887ae68382b2_1671886948.9766946.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we divide the problem into 3 states it\\'ll be easier to solve.\\n\\n### Recursive Calls\\nFor state = 0\\n![image.png](https://assets.leetcode.com/users/images/4e44b1a5-3660-41a1-9e1a-628131f8a0e3_1671888862.7674236.png)\\n![image.png](https://assets.leetcode.com/users/images/a8a05fb5-c95a-4b6c-af3d-f15a2b5da646_1671889209.8903918.png)\\n![image.png](https://assets.leetcode.com/users/images/157037b1-5d85-4f09-ae55-4cecb8bfd894_1671889328.8098805.png)\\n\\n\\n\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/601461d9-dc1f-4ce7-8a9c-c1495940d184_1671888019.2720866.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int cache[1001][3];\\n    int m = 1000000007;\\n    long helper(int n, int state) {\\n        if(n<0) return 0;\\n        if(state==0 && n<=2) {\\n            return n;\\n        }\\n        if(cache[n][state]!=-1) return cache[n][state];\\n        if(n==1) return 0;\\n        if(n==2) return 1;\\n        if(state == 0) {\\n            cache[n][state] = (helper(n-1, 0)%m + helper(n-1, 1)%m + helper(n-1, 2)%m + helper(n-2, 0)%m)%m;\\n        }\\n        else if(state == 1) {\\n            cache[n][state] = (helper(n-2, 0)%m + helper(n-1, 2)%m)%m;\\n        }\\n        else {\\n            cache[n][state] = (helper(n-2, 0)%m + helper(n-1, 1)%m)%m;\\n        }\\n        \\n        return cache[n][state];\\n    }\\npublic:\\n    int numTilings(int n) {\\n        /*\\n        state = 0 - column empty\\n        state = 1 - column top filled, bottom empty\\n        state = 2 - column bottom filled top empty\\n         */\\n        memset(cache, -1, sizeof cache); \\n        return helper(n, 0);\\n    }\\n};\\n```\\n// Please Comment your complexity analysis for this solution!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int cache[1001][3];\\n    int m = 1000000007;\\n    long helper(int n, int state) {\\n        if(n<0) return 0;\\n        if(state==0 && n<=2) {\\n            return n;\\n        }\\n        if(cache[n][state]!=-1) return cache[n][state];\\n        if(n==1) return 0;\\n        if(n==2) return 1;\\n        if(state == 0) {\\n            cache[n][state] = (helper(n-1, 0)%m + helper(n-1, 1)%m + helper(n-1, 2)%m + helper(n-2, 0)%m)%m;\\n        }\\n        else if(state == 1) {\\n            cache[n][state] = (helper(n-2, 0)%m + helper(n-1, 2)%m)%m;\\n        }\\n        else {\\n            cache[n][state] = (helper(n-2, 0)%m + helper(n-1, 1)%m)%m;\\n        }\\n        \\n        return cache[n][state];\\n    }\\npublic:\\n    int numTilings(int n) {\\n        /*\\n        state = 0 - column empty\\n        state = 1 - column top filled, bottom empty\\n        state = 2 - column bottom filled top empty\\n         */\\n        memset(cache, -1, sizeof cache); \\n        return helper(n, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945942,
                "title": "0ms-faster-than-100-easy-solution-series-formation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate first 8/9 values and identify the pattern.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long dp[n+1];\\n        dp[0]=1;\\n        for(int i=1; i<=n; i++){\\n            if(i<3)\\n                dp[i]=i;\\n            else\\n                dp[i] = (dp[i-1]*2+dp[i-3])%1000000007;\\n        }\\n        return (int)dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long dp[n+1];\\n        dp[0]=1;\\n        for(int i=1; i<=n; i++){\\n            if(i<3)\\n                dp[i]=i;\\n            else\\n                dp[i] = (dp[i-1]*2+dp[i-3])%1000000007;\\n        }\\n        return (int)dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945859,
                "title": "swift-solution-100-runtime-and-100-memory-with-explanations",
                "content": "![image.png](https://assets.leetcode.com/users/images/4befac27-e42c-434e-bedc-b2fa6e240b8a_1671887797.8681915.png)\\n\\n# Approach\\nThis solution uses dynamic programming to solve the problem. The basic idea is to start from small cases and build up to the final solution.\\n\\nWe use an array dp to store the number of ways to tile a board of size 2 x i. We start by setting dp[0] = 1, dp[1] = 1, and dp[2] = 2, because there is only 1 way to tile a board of size 2 x 0 (no tiles), 1 way to tile a board of size 2 x 1 (1 domino tile), and 2 ways to tile a board of size 2 x 2 (2 domino tiles or 1 tromino tile).\\n\\nThen, we iterate through i from 3 to n, and for each i, we calculate the number of ways to tile a board of size 2 x i by adding the number of ways to tile a board of size 2 x (i - 1) (1 domino tile), the number of ways to tile a board of size 2 x (i - 2) (1 tromino tile), and the number of ways to tile a board of size 2 x (i - 3) (2 domino tiles). We store the result in dp[i] and return dp[n] as the final answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ since we only need to iterate through n once to calculate the result.\\n\\n# Code\\n```\\nclass Solution {\\n    func numTilings(_ n: Int) -> Int {\\n        if n < 3 { return n }\\n        let mod = 1_000_000_007\\n        var dp = [1,1,2]\\n        for i in 3...n {\\n            dp.append((dp[i-1] * 2 + dp[i-3]) % mod)\\n        }\\n        return dp[n]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numTilings(_ n: Int) -> Int {\\n        if n < 3 { return n }\\n        let mod = 1_000_000_007\\n        var dp = [1,1,2]\\n        for i in 3...n {\\n            dp.append((dp[i-1] * 2 + dp[i-3]) % mod)\\n        }\\n        return dp[n]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945613,
                "title": "very-easy-simple-c-solution-clean-concise-code-math-s-trick",
                "content": "*If you like it Kindly **Upvote** this solution!*\\n# Cpp Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int mod = 1e9;\\n        mod += 7;\\n\\n        vector<long long> X(1001, 0);\\n        X[1] = 1;\\n        X[2] = 2;\\n        X[3] = 5;\\n        if(n <= 3) {\\n            return X[n];\\n        }\\n        for(int i = 4; i <= n; ++i) {\\n            X[i] = 2 * X[i - 1] + X[i - 3];\\n            X[i] %= mod;\\n        }\\n        return X[n];\\n    }\\n};\\n```\\n\\n# Happy Coding:)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int mod = 1e9;\\n        mod += 7;\\n\\n        vector<long long> X(1001, 0);\\n        X[1] = 1;\\n        X[2] = 2;\\n        X[3] = 5;\\n        if(n <= 3) {\\n            return X[n];\\n        }\\n        for(int i = 4; i <= n; ++i) {\\n            X[i] = 2 * X[i - 1] + X[i - 3];\\n            X[i] %= mod;\\n        }\\n        return X[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945550,
                "title": "c-easy-dp-solution-with-0ms-and-100-acceptance",
                "content": "\\n# Approach\\nfor each value of i in range of n the value can be calculated using \\n**f(i) = 2 * f(i-1) * f(i-3)**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long mod = 1e9+7;\\n    int f(int n, vector<int> &dp){\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n]=(2*f(n-1,dp)%mod+f(n-3,dp)%mod)%mod;\\n    }\\n    int numTilings(int n) {\\n        if(n<=2) return n;\\n        vector<int> dp(n+1,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n        return f(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long mod = 1e9+7;\\n    int f(int n, vector<int> &dp){\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n]=(2*f(n-1,dp)%mod+f(n-3,dp)%mod)%mod;\\n    }\\n    int numTilings(int n) {\\n        if(n<=2) return n;\\n        vector<int> dp(n+1,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n        return f(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945548,
                "title": "c-easy-dp-solution-with-0ms-and-100-acceptance",
                "content": "\\n# Approach\\nfor each value of i in range of n the value can be calculated using \\n**f(i) = 2 * f(i-1) * f(i-3)**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long mod = 1e9+7;\\n    int f(int n, vector<int> &dp){\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n]=(2*f(n-1,dp)%mod+f(n-3,dp)%mod)%mod;\\n    }\\n    int numTilings(int n) {\\n        if(n<=2) return n;\\n        vector<int> dp(n+1,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n        return f(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long mod = 1e9+7;\\n    int f(int n, vector<int> &dp){\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n]=(2*f(n-1,dp)%mod+f(n-3,dp)%mod)%mod;\\n    }\\n    int numTilings(int n) {\\n        if(n<=2) return n;\\n        vector<int> dp(n+1,-1);\\n        dp[0]=1,dp[1]=1,dp[2]=2;\\n        return f(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945389,
                "title": "cpp-simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) \\n    {\\n        int mod = 1e9 + 7;\\n        // dynamic Programming approach\\n        // for n = 1, ans => 1;\\n        // for n = 2, ans => 2;\\n\\t\\t// for n = 3, ans => 5;\\n\\t\\t// for n = 4, ans => 11; \\n        // for n > 5, \\n        // the pattern is :-\\n        // dp[n] = dp[n-1] + dp[n-2] + 2dp[n-3] + 2dp[n-4] + ... + 2*dp[0].\\n        \\n        // for n-1\\n        // dp[n-1] = dp[n-2] + dp[n-3] + 2dp[n-4] + 2dp[n-5] + ... + 2dp[0] + 2dp[-1].\\n        \\n        // assuming dp[neg] = 0 AND dp[0] = 1\\n        \\n        // which gives us\\n        // => dp[i] = 2 * dp[i-1] + dp[i-3];\\n        \\n        vector<long long> dp(1000, -1);\\n        \\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        \\n        for(long long i = 3; i <= n; i++)\\n        {\\n            dp[i] = (2 * dp[i-1] + dp[i-3]) % mod;\\n        }\\n         \\n        return dp[n] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) \\n    {\\n        int mod = 1e9 + 7;\\n        // dynamic Programming approach\\n        // for n = 1, ans => 1;\\n        // for n = 2, ans => 2;\\n\\t\\t// for n = 3, ans => 5;\\n\\t\\t// for n = 4, ans => 11; \\n        // for n > 5, \\n        // the pattern is :-\\n        // dp[n] = dp[n-1] + dp[n-2] + 2dp[n-3] + 2dp[n-4] + ... + 2*dp[0].\\n        \\n        // for n-1\\n        // dp[n-1] = dp[n-2] + dp[n-3] + 2dp[n-4] + 2dp[n-5] + ... + 2dp[0] + 2dp[-1].\\n        \\n        // assuming dp[neg] = 0 AND dp[0] = 1\\n        \\n        // which gives us\\n        // => dp[i] = 2 * dp[i-1] + dp[i-3];\\n        \\n        vector<long long> dp(1000, -1);\\n        \\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        \\n        for(long long i = 3; i <= n; i++)\\n        {\\n            dp[i] = (2 * dp[i-1] + dp[i-3]) % mod;\\n        }\\n         \\n        return dp[n] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945198,
                "title": "java-0ms-100-faster-explanation-with-images-dynamic-programming-recursion-and-memoization",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![Dynamic Programming States.png](https://assets.leetcode.com/users/images/987ad196-d270-43f9-b3dc-3fd9d1b92707_1671874076.345487.png)\\n\\n![Dynamic Programming States 2.png](https://assets.leetcode.com/users/images/cd5a419c-565f-4945-acc2-a3eb58ac3ce4_1671874102.624622.png)\\n\\n![Dynamic Programming States 3.png](https://assets.leetcode.com/users/images/14f148d2-d15a-485d-80af-b4aaefcd9bbb_1671874125.3365417.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    Integer[][] dp;\\n    int MOD = 1000000007;\\n    private int stateOne(int n) {\\n        if(n < 0) return 0;\\n        if(n == 0 || n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        if(dp[0][n] != null) return dp[0][n];\\n\\n        int a = stateOne(n-1);\\n        int b = stateOne(n-2);\\n        int c = stateTwo(n-1);\\n        int d = stateThree(n-1);\\n\\n        return dp[0][n] = (((((a % MOD) + (b % MOD)) % MOD) + ((c % MOD) + (d % MOD)) % MOD) % MOD);\\n    }\\n    private int stateTwo(int n) {\\n        if(n <= 1) return 0; \\n        if(n == 2) return 1;\\n\\n        if(dp[1][n] != null) return dp[1][n];\\n\\n        int a = stateThree(n-1);\\n        int b = stateOne(n-2);\\n\\n        return dp[1][n] = (((a % MOD) + (b % MOD)) % MOD);\\n\\n    }\\n    private int stateThree(int n) {\\n        if(n <= 1) return 0;\\n        if(n == 2) return 1;\\n\\n        if(dp[2][n] != null) return dp[2][n];\\n\\n        int a = stateTwo(n-1);\\n        int b = stateOne(n-2);\\n\\n        return dp[2][n] = (((a % MOD) + (b % MOD)) % MOD);\\n    }\\n    public int numTilings(int n) {\\n        this.dp = new Integer[3][n+1];\\n        return stateOne(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][] dp;\\n    int MOD = 1000000007;\\n    private int stateOne(int n) {\\n        if(n < 0) return 0;\\n        if(n == 0 || n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        if(dp[0][n] != null) return dp[0][n];\\n\\n        int a = stateOne(n-1);\\n        int b = stateOne(n-2);\\n        int c = stateTwo(n-1);\\n        int d = stateThree(n-1);\\n\\n        return dp[0][n] = (((((a % MOD) + (b % MOD)) % MOD) + ((c % MOD) + (d % MOD)) % MOD) % MOD);\\n    }\\n    private int stateTwo(int n) {\\n        if(n <= 1) return 0; \\n        if(n == 2) return 1;\\n\\n        if(dp[1][n] != null) return dp[1][n];\\n\\n        int a = stateThree(n-1);\\n        int b = stateOne(n-2);\\n\\n        return dp[1][n] = (((a % MOD) + (b % MOD)) % MOD);\\n\\n    }\\n    private int stateThree(int n) {\\n        if(n <= 1) return 0;\\n        if(n == 2) return 1;\\n\\n        if(dp[2][n] != null) return dp[2][n];\\n\\n        int a = stateTwo(n-1);\\n        int b = stateOne(n-2);\\n\\n        return dp[2][n] = (((a % MOD) + (b % MOD)) % MOD);\\n    }\\n    public int numTilings(int n) {\\n        this.dp = new Integer[3][n+1];\\n        return stateOne(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945121,
                "title": "c-memoization-tabulation-space-optimization",
                "content": "# Observation\\nn ---> no. of ways\\n1 ---> 1\\n2 ---> 2\\n3 ---> 5\\n4 ---> 11\\n5 ---> 24\\n6 ---> 53\\n\\n# Approach\\nAs per the Observation we can formulate it as\\n```ans(n) = 2 * ans(n - 1) + ans(n - 3);```\\n\\n# Code\\n```\\n//Memoization\\nclass Solution {\\nconst int mod = 1e9+7;\\npublic:\\n    int solve(int n, vector<int>& dp){\\n        //base case\\n        if(n == 2 || n == 1)\\n            return n;\\n        if(n == 3)\\n            return 5;\\n\\n        //DP table\\n        if(dp[n] != -1)\\n            return dp[n];\\n        \\n        return dp[n] = ((2 * solve(n-1, dp)) % mod + solve(n - 3, dp) % mod) % mod;\\n    }\\n\\n    int numTilings(int n) {\\n        vector<int> dp(n+1, -1);\\n        return solve(n, dp);\\n    }\\n};\\n\\n//Time Complexity : O(N)\\n//Space Complexity : O(N+1 + N)\\n```\\n```\\n//Tabulation\\nclass Solution {\\nconst int mod = 1e9+7;\\npublic:\\n    int numTilings(int n) {\\n        vector<int> dp(n+1, 0);\\n           \\n        // Base case \\n        if(n==1 || n==2)\\n            return n;\\n        \\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;   \\n        \\n        for(int i = 4; i <= n; i++){\\n            dp[i] = ((2 * dp[i-1]) % mod + dp[i-3] % mod) % mod;\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n\\n//Time Complexity : O(N)\\n//Space Complexity : O(N+1)\\n```\\n\\n```\\n//Space Optimization\\nclass Solution {\\nconst int mod = 1e9+7; \\npublic:\\n    int numTilings(int n) {\\n        // Base case        \\n        if(n==1 || n==2)\\n            return n;\\n        \\n        int n1 = 1;\\n        int n2 = 2;\\n        int n3 = 5;   \\n        \\n        int ans = n3;\\n\\n        for(int i = 4; i <= n; i++){\\n            ans = ((2 * n3) % mod + n1 % mod) % mod;\\n            n1 = n2;\\n            n2 = n3;\\n            n3 = ans;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n//Time Complexity : O(N)\\n//Space Complexity : O(1)\\n```\\n\\n# Pls. Upvote if the solution was helpful. \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```ans(n) = 2 * ans(n - 1) + ans(n - 3);```\n```\\n//Memoization\\nclass Solution {\\nconst int mod = 1e9+7;\\npublic:\\n    int solve(int n, vector<int>& dp){\\n        //base case\\n        if(n == 2 || n == 1)\\n            return n;\\n        if(n == 3)\\n            return 5;\\n\\n        //DP table\\n        if(dp[n] != -1)\\n            return dp[n];\\n        \\n        return dp[n] = ((2 * solve(n-1, dp)) % mod + solve(n - 3, dp) % mod) % mod;\\n    }\\n\\n    int numTilings(int n) {\\n        vector<int> dp(n+1, -1);\\n        return solve(n, dp);\\n    }\\n};\\n\\n//Time Complexity : O(N)\\n//Space Complexity : O(N+1 + N)\\n```\n```\\n//Tabulation\\nclass Solution {\\nconst int mod = 1e9+7;\\npublic:\\n    int numTilings(int n) {\\n        vector<int> dp(n+1, 0);\\n           \\n        // Base case \\n        if(n==1 || n==2)\\n            return n;\\n        \\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;   \\n        \\n        for(int i = 4; i <= n; i++){\\n            dp[i] = ((2 * dp[i-1]) % mod + dp[i-3] % mod) % mod;\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n\\n//Time Complexity : O(N)\\n//Space Complexity : O(N+1)\\n```\n```\\n//Space Optimization\\nclass Solution {\\nconst int mod = 1e9+7; \\npublic:\\n    int numTilings(int n) {\\n        // Base case        \\n        if(n==1 || n==2)\\n            return n;\\n        \\n        int n1 = 1;\\n        int n2 = 2;\\n        int n3 = 5;   \\n        \\n        int ans = n3;\\n\\n        for(int i = 4; i <= n; i++){\\n            ans = ((2 * n3) % mod + n1 % mod) % mod;\\n            n1 = n2;\\n            n2 = n3;\\n            n3 = ans;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n//Time Complexity : O(N)\\n//Space Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944995,
                "title": "0ms-faster-than-100-c-3d-dp-easy-understand-commented-nearly-0-n",
                "content": "![image.png](https://assets.leetcode.com/users/images/f5e3b559-3164-47b7-b7ac-a67dea6f7617_1671870750.559493.png)\\nThe shapes which we can choose are vertical I, horizontal I, L-shape and inverted L-shape. We can decide to choose shape for currIndex after having look at previous block.\\n\\nBasically previous 2 vertical blocks can either be fully filled or it can have one of the block unfilled.\\n\\nif previous block is filled then we can \\n1] Add a vertical I\\n2] Add 2 horizontal I\\'s\\n3] Add L\\n4] Add inverted L\\n\\nIf previos block is partially filled we can\\n1] Add opposite L shape to complete the block\\n2] Add horizontal block to vacant block\\n\\nWe will keep a track of previous block and decide to choose shapes for current index.\\n\\n\\n# Code\\n```\\nconst int MOD = (int) 1e9 + 7;\\nint dp[1005][2][2];\\nclass Solution {\\npublic:\\nint findCompleteBlock(pair<int, int> &prev, int ind, int n) {\\n    int up = prev.first;\\n    int dwn = prev.second;\\n\\n    if (ind == n) return (up == 1 && dwn == 1);\\n    \\n    if(dp[ind][up][dwn] != -1) return dp[ind][up][dwn];\\n\\n    int ans = 0;\\n\\n    //prev block is complete\\n    if (prev.first == 1 && prev.second == 1) {\\n        //add a vertical block\\n        prev.first = 1;\\n        prev.second = 1;\\n        ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n\\n        //add 2 horizontal blocks\\n        prev.first = 1;\\n        prev.second = 1;\\n        if (ind + 2 <= n) ans = (ans % MOD + findCompleteBlock(prev, ind + 2, n) % MOD) % MOD;\\n\\n        //add a L\\n        prev.first = 0;\\n        prev.second = 1;\\n        if (ind + 2 <= n) ans = (ans % MOD + findCompleteBlock(prev, ind + 2, n) % MOD) % MOD;\\n\\n        //add inverted L\\n        prev.first = 1;\\n        prev.second = 0;\\n        if (ind + 2 <= n) ans = (ans % MOD + findCompleteBlock(prev, ind + 2, n) % MOD) % MOD;\\n    }\\n    //prev block is half vacant\\n    else {\\n        //upper prev block is vacant\\n        if (prev.first == 0 && prev.second == 1) {\\n            //add opposite L shape to complete the block\\n            prev.first = 1;\\n            prev.second = 1;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n\\n            //add horizontal block to upper vacant block\\n            prev.first = 1;\\n            prev.second = 0;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n        }\\n        //lower prev block is vacant\\n        else {\\n            //add opposite L shape to complete the block\\n            prev.first = 1;\\n            prev.second = 1;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n\\n            //add horizontal block to upper vacant block\\n            prev.first = 0;\\n            prev.second = 1;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n        }\\n    }\\n\\n    return dp[ind][up][dwn] = ans;\\n}\\n    int numTilings(int n) {\\n        pair<int, int> p1 = {1, 1};\\n        memset(dp, -1, sizeof(dp));\\n        return findCompleteBlock(p1, 0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nconst int MOD = (int) 1e9 + 7;\\nint dp[1005][2][2];\\nclass Solution {\\npublic:\\nint findCompleteBlock(pair<int, int> &prev, int ind, int n) {\\n    int up = prev.first;\\n    int dwn = prev.second;\\n\\n    if (ind == n) return (up == 1 && dwn == 1);\\n    \\n    if(dp[ind][up][dwn] != -1) return dp[ind][up][dwn];\\n\\n    int ans = 0;\\n\\n    //prev block is complete\\n    if (prev.first == 1 && prev.second == 1) {\\n        //add a vertical block\\n        prev.first = 1;\\n        prev.second = 1;\\n        ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n\\n        //add 2 horizontal blocks\\n        prev.first = 1;\\n        prev.second = 1;\\n        if (ind + 2 <= n) ans = (ans % MOD + findCompleteBlock(prev, ind + 2, n) % MOD) % MOD;\\n\\n        //add a L\\n        prev.first = 0;\\n        prev.second = 1;\\n        if (ind + 2 <= n) ans = (ans % MOD + findCompleteBlock(prev, ind + 2, n) % MOD) % MOD;\\n\\n        //add inverted L\\n        prev.first = 1;\\n        prev.second = 0;\\n        if (ind + 2 <= n) ans = (ans % MOD + findCompleteBlock(prev, ind + 2, n) % MOD) % MOD;\\n    }\\n    //prev block is half vacant\\n    else {\\n        //upper prev block is vacant\\n        if (prev.first == 0 && prev.second == 1) {\\n            //add opposite L shape to complete the block\\n            prev.first = 1;\\n            prev.second = 1;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n\\n            //add horizontal block to upper vacant block\\n            prev.first = 1;\\n            prev.second = 0;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n        }\\n        //lower prev block is vacant\\n        else {\\n            //add opposite L shape to complete the block\\n            prev.first = 1;\\n            prev.second = 1;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n\\n            //add horizontal block to upper vacant block\\n            prev.first = 0;\\n            prev.second = 1;\\n            ans = (ans % MOD + findCompleteBlock(prev, ind + 1, n) % MOD) % MOD;\\n        }\\n    }\\n\\n    return dp[ind][up][dwn] = ans;\\n}\\n    int numTilings(int n) {\\n        pair<int, int> p1 = {1, 1};\\n        memset(dp, -1, sizeof(dp));\\n        return findCompleteBlock(p1, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944908,
                "title": "c-dp-n-2-dp-n-1-dp-n-3-with-picture-explanation",
                "content": "# Picture\\n![DocScanner 24-Dec-2022 1-24 pm_1.jpg](https://assets.leetcode.com/users/images/1161f5f0-4a87-4255-bf01-e7d4b0127806_1671868753.481655.jpeg)\\n\\n![DocScanner 24-Dec-2022 1-24 pm_2.jpg](https://assets.leetcode.com/users/images/77fa1f82-4e2f-4b10-98d8-313263d52a3b_1671868765.8293238.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) We can reduce it to constant space by taking 3 variable\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<int> dp(n+1,0);\\n        dp[1]=1;\\n        if(n==1 || n==2){\\n            return n;\\n        }\\n        dp[2]=2;\\n        dp[3]=5;\\n        if(n==3){\\n            return 5;\\n        }\\n        long mod=1e9+7;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=((2*dp[i-1])%mod+dp[i-3]%mod)%1000000007;\\n        }\\n\\n        return dp[n];\\n    }\\n    //code by sachin\\n};\\n```\\n\\nSC: O(N)\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int T_3=1,T_2=2,T_1=5;;\\n        if(n==1 || n==2){\\n            return n;\\n        }\\n        if(n==3){\\n            return 5;\\n        }\\n        int ans=0;\\n        long mod=1e9+7;\\n        for(int i=4;i<=n;i++){\\n            ans=((2*T_1)%mod+T_3%mod)%1000000007;\\n            T_3=T_2;\\n            T_2=T_1;\\n            T_1=ans;\\n        }\\n\\n        return ans;\\n    }\\n};\\n//code by sachin\\n```\\n\\n\\n\\n**Upvote if solution was helpful**\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<int> dp(n+1,0);\\n        dp[1]=1;\\n        if(n==1 || n==2){\\n            return n;\\n        }\\n        dp[2]=2;\\n        dp[3]=5;\\n        if(n==3){\\n            return 5;\\n        }\\n        long mod=1e9+7;\\n        for(int i=4;i<=n;i++){\\n            dp[i]=((2*dp[i-1])%mod+dp[i-3]%mod)%1000000007;\\n        }\\n\\n        return dp[n];\\n    }\\n    //code by sachin\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int T_3=1,T_2=2,T_1=5;;\\n        if(n==1 || n==2){\\n            return n;\\n        }\\n        if(n==3){\\n            return 5;\\n        }\\n        int ans=0;\\n        long mod=1e9+7;\\n        for(int i=4;i<=n;i++){\\n            ans=((2*T_1)%mod+T_3%mod)%1000000007;\\n            T_3=T_2;\\n            T_2=T_1;\\n            T_1=ans;\\n        }\\n\\n        return ans;\\n    }\\n};\\n//code by sachin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944723,
                "title": "not-easy-to-discover-the-pattern-dp-o-n-c",
                "content": "\\n# Pattern\\ndp[i] = dp[i - 1] * 2 + dp[i - 3]\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int MOD = 1e9 + 7;\\n    int numTilings(int n) {\\n        long long dp[1001] = {0};\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for(int i = 3; i <= n; i++){\\n            dp[i] = ((dp[i - 1]*2)%MOD + dp[i - 3])%MOD;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int MOD = 1e9 + 7;\\n    int numTilings(int n) {\\n        long long dp[1001] = {0};\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for(int i = 3; i <= n; i++){\\n            dp[i] = ((dp[i - 1]*2)%MOD + dp[i - 3])%MOD;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944680,
                "title": "math-solution-with-the-result-pattern-tc-o-n-sc-constant",
                "content": "# Intuition\\nCalculate the number of ways to tile an 2 * n board for first fews values (n = 1 to 4). You can see a **pattern** in the series of results. With this **Number of Ways** for next value can be calculated.\\n\\n![Screenshot 2022-12-24 at 12.07.21 PM.png](https://assets.leetcode.com/users/images/98951764-a789-4ded-93be-a3d87b4476f5_1671863856.6848295.png)\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIt looks like a pattern. \\nthe result for n (from n = 4), can be calulated using \\n```\\nres[n] = (res[n-1] * 2) + res[n-3]\\n\\n```\\nThis problem can be solved using Math calculations for the pattern.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.*;\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n <= 3)\\n        {\\n            if(n == 1)\\n            {\\n                return 1;\\n            }\\n            if(n == 2)\\n            {\\n                return 2;\\n            }\\n            if(n == 3)\\n            {\\n                return 5;\\n            }\\n        }\\n\\n        int a1 = 1;\\n        int b1 = 2;\\n        int c1 = 5;\\n        int mod = 1000000007;\\n        \\n        \\n        for(int i = 3; i < n; i++)\\n        {\\n            int rest = (((2*c1) % mod) + (a1 % mod)) % mod;\\n            a1 = b1;\\n            b1 = c1;\\n            c1 = rest;\\n        }\\n        \\n        return c1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nres[n] = (res[n-1] * 2) + res[n-3]\\n\\n```\n```\\nimport java.math.*;\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n <= 3)\\n        {\\n            if(n == 1)\\n            {\\n                return 1;\\n            }\\n            if(n == 2)\\n            {\\n                return 2;\\n            }\\n            if(n == 3)\\n            {\\n                return 5;\\n            }\\n        }\\n\\n        int a1 = 1;\\n        int b1 = 2;\\n        int c1 = 5;\\n        int mod = 1000000007;\\n        \\n        \\n        for(int i = 3; i < n; i++)\\n        {\\n            int rest = (((2*c1) % mod) + (a1 % mod)) % mod;\\n            a1 = b1;\\n            b1 = c1;\\n            c1 = rest;\\n        }\\n        \\n        return c1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944634,
                "title": "c-explanation-with-visuals-memoization-dp",
                "content": "**Intution** : During *recursion* keep checking the **no of rows and columns left** because they can decide what kind of shape we can take at this moment. Check the below visuals by **archit91**\\n\\n![image](https://assets.leetcode.com/users/images/33647289-7e10-43fd-92e4-2d3bb81cd9d1_1671863274.7920697.png)\\n\\n![image](https://assets.leetcode.com/users/images/f8ba9cb6-bc35-44b0-9265-f5541b46d363_1671863217.9040167.png)\\n\\n\\nHere is the solution to that !\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<vector<int>> dp;\\n    int numTilings(int n) {\\n        dp.resize(n+1, vector<int> (n+1, -1));\\n        return solve(n,n);\\n    }\\n    \\n    int solve(int top,int bot){\\n        if(top<0 or bot<0) return 0;\\n        if(top==0 and bot ==0) return 1;\\n        \\n        if(dp[top][bot]!=-1) return dp[top][bot];\\n            \\n        long long ans=0;\\n        if(top>bot){   //                      __      __\\n            // we can take two shapes from here  | and \\n            ans=(solve(top-2,bot-1)%mod+solve(top-2,bot)%mod)%mod;\\n        }\\n        else if(bot>top){                 \\n            // we can take two shapes from here _| and __\\n            ans=(solve(top-1,bot-2)%mod+solve(top,bot-2)%mod)%mod;\\n        }\\n        else if(bot==top){ //                __   __\\n\\t\\t// we can any of the four types | ,  __ ,   | ,  __|\\n            ans=((solve(top-1,bot-1)%mod+solve(top-2,bot-2)%mod)%mod+(solve(top-1,bot-2)%mod+solve(top-2,bot-1)%mod)%mod)%mod;\\n        }\\n        \\n        return dp[top][bot] = ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<vector<int>> dp;\\n    int numTilings(int n) {\\n        dp.resize(n+1, vector<int> (n+1, -1));\\n        return solve(n,n);\\n    }\\n    \\n    int solve(int top,int bot){\\n        if(top<0 or bot<0) return 0;\\n        if(top==0 and bot ==0) return 1;\\n        \\n        if(dp[top][bot]!=-1) return dp[top][bot];\\n            \\n        long long ans=0;\\n        if(top>bot){   //                      __      __\\n            // we can take two shapes from here  | and \\n            ans=(solve(top-2,bot-1)%mod+solve(top-2,bot)%mod)%mod;\\n        }\\n        else if(bot>top){                 \\n            // we can take two shapes from here _| and __\\n            ans=(solve(top-1,bot-2)%mod+solve(top,bot-2)%mod)%mod;\\n        }\\n        else if(bot==top){ //                __   __\\n\\t\\t// we can any of the four types | ,  __ ,   | ,  __|\\n            ans=((solve(top-1,bot-1)%mod+solve(top-2,bot-2)%mod)%mod+(solve(top-1,bot-2)%mod+solve(top-2,bot-1)%mod)%mod)%mod;\\n        }\\n        \\n        return dp[top][bot] = ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944627,
                "title": "runtime-beats-100-memory-beats-93-27",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long long f[1009],MOD=1e9+7;\\n        f[0]=1;\\n        f[1]=1;\\n        f[2]=2;\\n        f[3]=5;\\n        for(int i=4;i<=n;i++){\\n            f[i]=(f[i-1]+f[i-2]*2+f[i-3]+f[i-4])%MOD;\\n        }\\n        return f[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long long f[1009],MOD=1e9+7;\\n        f[0]=1;\\n        f[1]=1;\\n        f[2]=2;\\n        f[3]=5;\\n        for(int i=4;i<=n;i++){\\n            f[i]=(f[i-1]+f[i-2]*2+f[i-3]+f[i-4])%MOD;\\n        }\\n        return f[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944568,
                "title": "simple-c-solution-using-dp",
                "content": "# Intuition\\nAt each possible length, try to check for different combinations at the right most end. For each such combination, count the number of  ways of filling the previous tiles (Dynamic Programming).\\n\\n# Approach\\n`dp[i]` indictes the number of ways of filling a `2 * (i+1)` board.\\nUpdate each `dp[i]` by using the above logic.\\n\\n# Complexity\\n- Time complexity: `O(n * n)`\\n\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        const int mod = 1e9 + 7;\\n        vector<long> dp(max(3, n), 0);\\n        dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n        for(int i=3; i<n; i++) {\\n            //          |       --      |-   |\\n            //          |       --      |   -|\\n            dp[i] = (dp[i-1] + dp[i-2] + 2*dp[i-3]) % mod;\\n            long k = 1;\\n            for(int j=i-4; j>=0; --j) {\\n                //       |  --  --  --  |\\n                //       |-   --  --   -|\\n                k = (k + dp[j]) % mod;\\n            }\\n            dp[i] = (dp[i] + 2*k) % mod;\\n\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        const int mod = 1e9 + 7;\\n        vector<long> dp(max(3, n), 0);\\n        dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n        for(int i=3; i<n; i++) {\\n            //          |       --      |-   |\\n            //          |       --      |   -|\\n            dp[i] = (dp[i-1] + dp[i-2] + 2*dp[i-3]) % mod;\\n            long k = 1;\\n            for(int j=i-4; j>=0; --j) {\\n                //       |  --  --  --  |\\n                //       |-   --  --   -|\\n                k = (k + dp[j]) % mod;\\n            }\\n            dp[i] = (dp[i] + 2*k) % mod;\\n\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944515,
                "title": "please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthere are 2 rows only and we have 2 tiles to play with. start building tiles from the start and memoize the repetivie work.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have 2 rows lets say first row be x and second be y\\nif we place L tile it will be x+1, y+2 right. \\n\\n@@   x+2,y+1\\n@\\n\\n@    x+1,y+1\\n@\\n\\n@@   x+2,y\\n\\n\\n\\nand so on.. \\nnow there are 2 things to wonder here. \\n\\n1) what if we have this state. (@) represents tile / filled.\\n@@@\\n@@\\n\\n    we can\\'t put x+1, y+1 tile here right, since it will create a gap in the y\\'th row. think about this. for this kind of state we have to choose specific tiles only that doesn\\'t lead to any gap.\\n\\n2) when we have x == y, lets say \\n@@\\n@@\\n    in this time you might place x+2,y tile and for the other call x,y+2 tile. but this will overlap the solution. So we need to do x+2,y+2\\n\\n# Complexity\\n- Time complexity: O(N) Reason is for each x we can have (x+1, x-1 or x)values for y. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        dp = {}\\n        return self.helper(n, 0,0, dp)%(10**9+7)\\n\\n    def helper(self, n, x, y, dp):\\n        if x>n or y>n:\\n            return 0\\n        if x==n and y==n:\\n            return 1\\n        if (x,y) in dp:\\n            return dp[(x,y)]\\n        ans = 0\\n        if x==y:\\n            ans+=self.helper(n, x+1, y+1, dp)\\n            ans+=self.helper(n, x+2, y+2, dp)\\n            ans+=self.helper(n, x+1, y+2, dp)\\n            ans+=self.helper(n, x+2, y+1, dp)\\n        elif (x-y)==1:\\n            ans+=self.helper(n, x+1, y+2, dp)\\n            ans+=self.helper(n, x, y+2, dp)\\n        else:\\n            ans+=self.helper(n, x+2, y+1, dp)\\n            ans+=self.helper(n, x+2, y, dp)\\n        dp[(x,y)]=ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        dp = {}\\n        return self.helper(n, 0,0, dp)%(10**9+7)\\n\\n    def helper(self, n, x, y, dp):\\n        if x>n or y>n:\\n            return 0\\n        if x==n and y==n:\\n            return 1\\n        if (x,y) in dp:\\n            return dp[(x,y)]\\n        ans = 0\\n        if x==y:\\n            ans+=self.helper(n, x+1, y+1, dp)\\n            ans+=self.helper(n, x+2, y+2, dp)\\n            ans+=self.helper(n, x+1, y+2, dp)\\n            ans+=self.helper(n, x+2, y+1, dp)\\n        elif (x-y)==1:\\n            ans+=self.helper(n, x+1, y+2, dp)\\n            ans+=self.helper(n, x, y+2, dp)\\n        else:\\n            ans+=self.helper(n, x+2, y+1, dp)\\n            ans+=self.helper(n, x+2, y, dp)\\n        dp[(x,y)]=ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944408,
                "title": "top-down-dp-easy-to-understand",
                "content": "# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        // we can solve this problem using dynamic programming\\n        int MOD = 1e9 + 7;\\n        vector<vector<int>> memo(n+1, vector<int>(2, -1));\\n\\n        function<int(int,bool)> solve = [&](int i, bool flag) {\\n            // if we go out of bounds\\n            if(i < 0) return 0;\\n\\n            // if we tiled the entire board\\n            if(i == 0) return (int)!flag;\\n\\n            // if we memoized the current state\\n            if(memo[i][flag] != -1) return memo[i][flag];\\n\\n            long result = 0;\\n\\n            // if we have 1 cell covered in the current column\\n            if(flag) {\\n                // we can use a horizontal domino\\n                long val1 = solve(i-1, true);\\n\\n                // we can use a tromino\\n                long val2 = solve(i-2, false);\\n\\n                result = val1 + val2;\\n            }\\n            else {\\n                // we can use a vertical domino\\n                long val1 = solve(i-1, false);\\n\\n                // we can use 2 horizontal dominos\\n                long val2 = solve(i-2, false);\\n\\n                // we can use a tromino\\n                // there are two ways of placing it\\n                long val3 = 2*solve(i-1, true);\\n\\n                result = val1 + val2 + val3;\\n            }\\n\\n            return memo[i][flag] = result%MOD;\\n        };\\n\\n        // start with an empty board\\n        return solve(n, false);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        // we can solve this problem using dynamic programming\\n        int MOD = 1e9 + 7;\\n        vector<vector<int>> memo(n+1, vector<int>(2, -1));\\n\\n        function<int(int,bool)> solve = [&](int i, bool flag) {\\n            // if we go out of bounds\\n            if(i < 0) return 0;\\n\\n            // if we tiled the entire board\\n            if(i == 0) return (int)!flag;\\n\\n            // if we memoized the current state\\n            if(memo[i][flag] != -1) return memo[i][flag];\\n\\n            long result = 0;\\n\\n            // if we have 1 cell covered in the current column\\n            if(flag) {\\n                // we can use a horizontal domino\\n                long val1 = solve(i-1, true);\\n\\n                // we can use a tromino\\n                long val2 = solve(i-2, false);\\n\\n                result = val1 + val2;\\n            }\\n            else {\\n                // we can use a vertical domino\\n                long val1 = solve(i-1, false);\\n\\n                // we can use 2 horizontal dominos\\n                long val2 = solve(i-2, false);\\n\\n                // we can use a tromino\\n                // there are two ways of placing it\\n                long val3 = 2*solve(i-1, true);\\n\\n                result = val1 + val2 + val3;\\n            }\\n\\n            return memo[i][flag] = result%MOD;\\n        };\\n\\n        // start with an empty board\\n        return solve(n, false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944067,
                "title": "golang-bottom-up-1d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Golang implementation of solution from https://leetcode.com/problems/domino-and-tromino-tiling/discussion/comments/1566271\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc numTilings(n int) int {\\n    if n == 0 {\\n        return 0\\n    }\\n    if n == 1 {\\n        return 1\\n    }\\n    if n == 2 {\\n        return 2\\n    }\\n    m := make([]int, n+1)\\n    m[0] = 1\\n    m[1] = 1\\n    m[2] = 2\\n    for i := 3; i < n+1; i++ {\\n        m[i] = (2 * m[i-1] + m[i-3]) % 1_000_000_007\\n    } \\n    return m[n]\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numTilings(n int) int {\\n    if n == 0 {\\n        return 0\\n    }\\n    if n == 1 {\\n        return 1\\n    }\\n    if n == 2 {\\n        return 2\\n    }\\n    m := make([]int, n+1)\\n    m[0] = 1\\n    m[1] = 1\\n    m[2] = 2\\n    for i := 3; i < n+1; i++ {\\n        m[i] = (2 * m[i-1] + m[i-3]) % 1_000_000_007\\n    } \\n    return m[n]\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2943991,
                "title": "linear-loop-o-n-o-1-better-than-99-5-time-and-99-2-memory-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing recursive formula f(n) = f(n-1) * 2 + f(n-3).\\nThen unwinding recursion into linear loop over array.\\nFinally optimizing memory by storing only last 3 values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        nums = [1, 1, 2]\\n        if n < 3:\\n            return n\\n        for i in range(3, n+1):\\n            nums = [nums[1], nums[2], nums[2] * 2 + nums[0]]\\n        return nums[2] % (10 ** 9 + 7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        nums = [1, 1, 2]\\n        if n < 3:\\n            return n\\n        for i in range(3, n+1):\\n            nums = [nums[1], nums[2], nums[2] * 2 + nums[0]]\\n        return nums[2] % (10 ** 9 + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943965,
                "title": "python",
                "content": "There are 3 states:\\n* top and bottom have the same length\\n* top is longer than bottom by 1\\n* bottom is longer than top by 1\\n\\nWe make choices based on the current state\\n```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n\\n        @cache\\n        def dp(t, b):\\n            if t > n or b > n:\\n                return 0\\n            if t == b == n:\\n                return 1\\n            if t > b:\\n                return dp(t, b+2) + dp(t+1, b+2)\\n            if t < b:\\n                return dp(t+2, b) + dp(t+2, b+1)\\n            return dp(t+1, b+1) + dp(t+2, b+2) + dp(t+2, b+1) + dp(t+1, b+2)\\n\\n        return dp(0, 0) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n\\n        @cache\\n        def dp(t, b):\\n            if t > n or b > n:\\n                return 0\\n            if t == b == n:\\n                return 1\\n            if t > b:\\n                return dp(t, b+2) + dp(t+1, b+2)\\n            if t < b:\\n                return dp(t+2, b) + dp(t+2, b+1)\\n            return dp(t+1, b+1) + dp(t+2, b+2) + dp(t+2, b+1) + dp(t+1, b+2)\\n\\n        return dp(0, 0) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943889,
                "title": "c-solution-with-comments-and-explanation",
                "content": "# Intuition\\n![image.png](https://assets.leetcode.com/users/images/b7dbe13d-ff96-4bab-b6f4-64a79c4eaafc_1671841615.5294669.png)\\nFirst, picture we have a `2 x n` grid, and we are filling the grid from left to right. One thing that comes to mind is top-down memoization. Intuitively, for every `n`, there are two cases on the right-most column that we are examining: \\n1. only one grid in the column is empty\\n2. both grids in the column are empty\\n\\nWhen both grids are empty, we can have the following:\\n- place one domino vertically\\n- place two domino horizontally\\n- place one tromino, but since there are two orientations, we have two ways of doing so\\n\\nWhen only one grid is empty, we can have the following:\\n- place one domino horizontally\\n- place one tromino\\n\\nAfter understanding the two cases, simply memoize on `n` and `isBothEmpty`. Remember to take the modulo after the calculation :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long int solve(vector<vector<long long int>> &dp, int n, bool isBothEmpty){\\n        // base cases\\n        if(n <= 1) return (isBothEmpty ? 1 : 0);\\n        if(n <= 2) return (isBothEmpty ? 2 : 1);\\n        if(dp[n][isBothEmpty] != -1) return dp[n][isBothEmpty];\\n        long long int ans = 0;\\n        if(isBothEmpty){\\n            // place one domino vertically\\n            ans += solve(dp,n-1,true);\\n            // place two domino horizontally\\n            ans += solve(dp,n-2,true);\\n            // place one tromino (2 ways)\\n            ans += 2*solve(dp,n-1,false);\\n        } else {\\n            // place one domino horizontally\\n            ans += solve(dp,n-1,false);\\n            // place one tromino \\n            ans += solve(dp,n-2,true);\\n        }\\n        return dp[n][isBothEmpty] = ans%mod;\\n    }\\n    int numTilings(int n) {\\n        vector<vector<long long int>> dp(n+1, vector<long long int>(2,-1));\\n        return solve(dp, n, true);\\n    }\\n};\\n```\\n\\n# Compact Version\\n```\\nclass Solution {\\npublic:\\n    long long int solve(vector<vector<long long int>> &dp, int n, bool isBothEmpty){\\n        if(n <= 2) return (isBothEmpty ? n : n-1);\\n        if(dp[n][isBothEmpty] != -1) return dp[n][isBothEmpty];\\n        long long int ans = 0;\\n        if(isBothEmpty)\\n            ans = solve(dp,n-1,true) + solve(dp,n-2,true) + 2*solve(dp,n-1,false);\\n        else \\n            ans = solve(dp,n-1,false) + solve(dp,n-2,true);\\n        return dp[n][isBothEmpty] = ans%((int)1e9+7);\\n    }\\n    int numTilings(int n) {\\n        vector<vector<long long int>> dp(n+1, vector<long long int>(2,-1));\\n        return solve(dp, n, true);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long int solve(vector<vector<long long int>> &dp, int n, bool isBothEmpty){\\n        // base cases\\n        if(n <= 1) return (isBothEmpty ? 1 : 0);\\n        if(n <= 2) return (isBothEmpty ? 2 : 1);\\n        if(dp[n][isBothEmpty] != -1) return dp[n][isBothEmpty];\\n        long long int ans = 0;\\n        if(isBothEmpty){\\n            // place one domino vertically\\n            ans += solve(dp,n-1,true);\\n            // place two domino horizontally\\n            ans += solve(dp,n-2,true);\\n            // place one tromino (2 ways)\\n            ans += 2*solve(dp,n-1,false);\\n        } else {\\n            // place one domino horizontally\\n            ans += solve(dp,n-1,false);\\n            // place one tromino \\n            ans += solve(dp,n-2,true);\\n        }\\n        return dp[n][isBothEmpty] = ans%mod;\\n    }\\n    int numTilings(int n) {\\n        vector<vector<long long int>> dp(n+1, vector<long long int>(2,-1));\\n        return solve(dp, n, true);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long int solve(vector<vector<long long int>> &dp, int n, bool isBothEmpty){\\n        if(n <= 2) return (isBothEmpty ? n : n-1);\\n        if(dp[n][isBothEmpty] != -1) return dp[n][isBothEmpty];\\n        long long int ans = 0;\\n        if(isBothEmpty)\\n            ans = solve(dp,n-1,true) + solve(dp,n-2,true) + 2*solve(dp,n-1,false);\\n        else \\n            ans = solve(dp,n-1,false) + solve(dp,n-2,true);\\n        return dp[n][isBothEmpty] = ans%((int)1e9+7);\\n    }\\n    int numTilings(int n) {\\n        vector<vector<long long int>> dp(n+1, vector<long long int>(2,-1));\\n        return solve(dp, n, true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943847,
                "title": "daily-leetcoding-challenge-december-day-24",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 1:** Dynamic Programming (Top-down)\n**Approach 2:** Dynamic Programming (Bottom-up)\n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n**Approach 6:** Math optimization (Fibonacci sequence like)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2276743,
                "title": "stumbling-our-way-to-o-n-solution-eventually",
                "content": "Let us form a 2-D table (i.e. simply an array) by the name dp such that it contains the no. of ways to tile a floor. The n\\'th element in the array denotes the no. of ways to tile 2xn floor. dp[n=N] will be the anwer.\\nLet us consider the a few tile configurations added to the right end.\\n![image](https://assets.leetcode.com/users/images/08da9ec1-2710-4ae1-8a04-6131844c89a6_1657712108.71259.jpeg)\\nThus the code for the following will be:\\n```\\ndef numTilings(self, n: int) -> int:\\n\\tdp = [0] * (n+1)\\n\\tdp[0] = 1\\n\\tfor i in range(1,n+1):\\n\\t\\tfor j in range(1,i+1):\\n\\t\\t\\tif j<=2:\\n\\t\\t\\t\\tdp[i] += dp[i-j]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp[i] += dp[i-j]*2                \\n\\treturn dp[n]%(10**9+7)\\n```\\nIt\\'s Dynamic Programming but a bit slow, actually a lot slow, on leetcode it beats only 5% of the solutions in time. Clearly, it is O(n^2). Can we optimize it to O(n)? Yes. Let\\'s do some maths :)\\n\\n![image](https://assets.leetcode.com/users/images/7ca27c26-bffb-40c3-9353-661f0f780dc3_1657712258.206752.jpeg)\\n\\nWow, math saves our little pc a lot of unnecessary manual work, let\\'s use it in our code now.\\n```\\ndef numTilings(self, n: int) -> int:\\n\\tdp = [0] * (n+1)\\n\\tif n<=1:\\n\\t\\treturn 1\\n\\telif n<=2:\\n\\t\\treturn 2\\n\\telif n<=3:\\n\\t\\treturn 5\\n\\tdp[0] = 1\\n\\tdp[1] = 1\\n\\tdp[2] = 2\\n\\tdp[3] = 5\\n\\n\\tfor i in range(4,n+1):\\n\\t\\tdp[i] = 2*dp[i-1] + dp[i-3]              \\n\\treturn dp[n]%(10**9+7)\\n```\\nNow, its 0(n)! It beats 90% on leetcode. Great job!\\nThank you :)\\n\\nIf what I ment by last configurations on the very begining didn\\'t make a clear understanding, allow me to explain it well and with clarity using a video.\\n[->Click Here To Watch](https://youtu.be/sZ3d1gkOQeE)",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef numTilings(self, n: int) -> int:\\n\\tdp = [0] * (n+1)\\n\\tdp[0] = 1\\n\\tfor i in range(1,n+1):\\n\\t\\tfor j in range(1,i+1):\\n\\t\\t\\tif j<=2:\\n\\t\\t\\t\\tdp[i] += dp[i-j]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp[i] += dp[i-j]*2                \\n\\treturn dp[n]%(10**9+7)\\n```\n```\\ndef numTilings(self, n: int) -> int:\\n\\tdp = [0] * (n+1)\\n\\tif n<=1:\\n\\t\\treturn 1\\n\\telif n<=2:\\n\\t\\treturn 2\\n\\telif n<=3:\\n\\t\\treturn 5\\n\\tdp[0] = 1\\n\\tdp[1] = 1\\n\\tdp[2] = 2\\n\\tdp[3] = 5\\n\\n\\tfor i in range(4,n+1):\\n\\t\\tdp[i] = 2*dp[i-1] + dp[i-3]              \\n\\treturn dp[n]%(10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1622465,
                "title": "java-solution-recursion-dp",
                "content": "So what we essentially wanna do is put the tilings in such a way that whole area is covered. Now we have two types of tilings domino and tromino. Taking a high level view of the problem we get that at every step we have to make a choice whether to pick a domino or tromino and if a domino which orientation and if a tromino then which orientation. Sounds like recursion to me!\\n\\nLet\\'s start recursion then.\\n\\nSo let\\u2019s say we are at position x now we look into our options:\\n1.\\tPick a domino: Here again we got two choices:\\n\\ta.\\tWe take vertical domino. So when we take a vertical domino this whole column is covered and we can move to x-1.![image](https://assets.leetcode.com/users/images/c3f52349-593b-410d-b9c6-822304f3ca12_1639195839.8293874.png)\\n\\tb.\\tWe take a horizontal domino. So when we take a horizontal domino two columns of a row are covered and the row other than this has only one option to place a horizontal domino, hence we can move to x-2.![image](https://assets.leetcode.com/users/images/8221f839-eb26-4e2d-a880-b9dabde93eb7_1639195865.765447.png)\\n2.\\tPick a tromino: Now when we pick a tromino we will fill one column and fill the other one partially. Now in the partial filled column we have two options:![image](https://assets.leetcode.com/users/images/ca1ff0b7-56d7-4046-9b4e-2c04904a3777_1639195892.081208.png)\\n\\ta.\\tWe can start a tromino from there. By doing this we would have filled 3 columns completely.![image](https://assets.leetcode.com/users/images/4c8465a6-1b8f-424c-a9c4-18edeb015278_1639195923.0817401.png)\\nb.\\tWe can start a horizontal domino from the partially unfilled area.![image](https://assets.leetcode.com/users/images/7ef8b8cd-c16a-4b23-9664-291b5d1119ba_1639195945.061751.png)\\n\\nSo talking mathematically, \\n\\nf(x) = part1 + part2 + part3 where, \\npart1 = f(x-1) => the case of vertical domino \\npart2 = f(x-2) => the case of horizontal domino \\npart3 = 2*p(x-1) => the case for tromino \\n\\nNow we know f(x), let\\u2019s define p(x). \\n\\np(x) is for the partially filled column. So whenever we put a tromino we call p(x-1) where tromino is put at x so the column previous to that would be partially filled right. Now, \\n\\np(x) = part4 + part5 \\npart4 = f(x-2) => case where we put another domino and completely fill the columns \\npart5 = p(x-1) => case where we put horizontal domino in the partially unfilled column, thus creating another partially filled column. \\n\\nNow you might think why I multiplied by 2 in part3. The reason is that we can place a tromino in 2 ways either its \\u2018L\\u2019 shaped or mirror image of \\u2018L\\u2019. Hence multiplication by 2.\\n\\nRecursive Code:\\n\\n```\\nclass Solution {\\n    int mod = (int)Math.pow(10,9)+7;\\n    public int numTilings(int n) {\\n        return (int)(recur( n ) % mod);\\n    }\\n    public long recur ( int x ) {\\n        if ( x==0 ) {\\n            return 1;\\n        }\\n        if ( x<0 ) {\\n            return 0;\\n        }\\n        return (long)2*partial(x-1) + recur(x-2) + recur(x-1);\\n    }\\n    public long partial( int x ) {\\n        if ( x==0 ) {\\n            return 0;\\n        }\\n        if ( x<3 ) {\\n            return x-1;\\n        }\\n        return (long)partial(x-1) + recur(x-2);\\n    }\\n}\\n```\\n\\nNow recursion leads to TLE. What to we do know?\\nAnswer: Memoization\\n\\n```\\nclass Solution {\\n    int mod = (int)Math.pow(10,9)+7;\\n    Long[] full;\\n    Long[] part;\\n    public int numTilings(int n) {\\n        full = new Long[n+1];\\n        part = new Long[n+1];\\n        return recur( n );\\n    }\\n    public int recur ( int x ) {\\n        if ( x==0 ) {\\n            return 1;\\n        }\\n        if ( x<0 ) {\\n            return 0;\\n        }\\n        int temp = 0;\\n        if ( full[x]!=null ) {\\n            temp = (int)(full[x]%mod);\\n            return temp;\\n        }\\n        full[x] = (long)2*partial(x-1) + recur(x-2) + recur(x-1);\\n        temp = (int)(full[x]%mod);\\n        return temp;\\n    }\\n    public int partial( int x ) {\\n        if ( x==0 ) {\\n            return 0;\\n        }\\n        if ( x<3 ) {\\n            return x-1;\\n        }\\n        int temp = 0;\\n        if ( part[x]!=null ) {\\n            temp = (int)(part[x]%mod);\\n            return temp;\\n        }\\n        part[x] = (long)partial(x-1) + recur(x-2);\\n        temp = (int)(part[x]%mod);\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)Math.pow(10,9)+7;\\n    public int numTilings(int n) {\\n        return (int)(recur( n ) % mod);\\n    }\\n    public long recur ( int x ) {\\n        if ( x==0 ) {\\n            return 1;\\n        }\\n        if ( x<0 ) {\\n            return 0;\\n        }\\n        return (long)2*partial(x-1) + recur(x-2) + recur(x-1);\\n    }\\n    public long partial( int x ) {\\n        if ( x==0 ) {\\n            return 0;\\n        }\\n        if ( x<3 ) {\\n            return x-1;\\n        }\\n        return (long)partial(x-1) + recur(x-2);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod = (int)Math.pow(10,9)+7;\\n    Long[] full;\\n    Long[] part;\\n    public int numTilings(int n) {\\n        full = new Long[n+1];\\n        part = new Long[n+1];\\n        return recur( n );\\n    }\\n    public int recur ( int x ) {\\n        if ( x==0 ) {\\n            return 1;\\n        }\\n        if ( x<0 ) {\\n            return 0;\\n        }\\n        int temp = 0;\\n        if ( full[x]!=null ) {\\n            temp = (int)(full[x]%mod);\\n            return temp;\\n        }\\n        full[x] = (long)2*partial(x-1) + recur(x-2) + recur(x-1);\\n        temp = (int)(full[x]%mod);\\n        return temp;\\n    }\\n    public int partial( int x ) {\\n        if ( x==0 ) {\\n            return 0;\\n        }\\n        if ( x<3 ) {\\n            return x-1;\\n        }\\n        int temp = 0;\\n        if ( part[x]!=null ) {\\n            temp = (int)(part[x]%mod);\\n            return temp;\\n        }\\n        part[x] = (long)partial(x-1) + recur(x-2);\\n        temp = (int)(part[x]%mod);\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621978,
                "title": "cpp-solution-better-than-100-using-dp-bottom-up-top-down",
                "content": "CPP SOLUTION\\n\\n**Top Down**\\n\\n\\tclass Solution\\n\\t{\\n\\tpublic:\\n\\t\\tvector<vector<int>> dp;\\n\\n\\t\\tconst int mod = 1e9 + 7;\\n\\t\\tint findState(bool t1, bool t2)\\n\\t\\t{\\n\\t\\t\\tint state = 0;\\n\\t\\t\\tif (t1)\\n\\t\\t\\t\\tstate |= 1;\\n\\t\\t\\tif (t2)\\n\\t\\t\\t\\tstate |= 2;\\n\\t\\t\\treturn state;\\n\\t\\t}\\n\\t\\tint numTilings(int &n, int i, int t1 = true, int t2 = true)\\n\\t\\t{\\n\\t\\t\\tif (i == n)\\n\\t\\t\\t\\treturn 1;\\n\\n\\t\\t\\tint state = findState(t1, t2);\\n\\n\\t\\t\\tif (dp[i][state] != -1)\\n\\t\\t\\t\\treturn dp[i][state];\\n\\n\\t\\t\\tbool t3 = i + 1 < n;\\n\\t\\t\\tbool t4 = i + 1 < n;\\n\\n\\t\\t\\tlong long count = 0;\\n\\t\\t\\tif (t1 && t2 && t3)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, false, true);\\n\\t\\t\\tif (t1 && t2 && t4)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, true, false);\\n\\t\\t\\tif (t1 && !t2 && t3 && t4)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, false, false);\\n\\t\\t\\tif (!t1 && t2 && t3 && t4)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, false, false);\\n\\t\\t\\tif (t1 && t2 && t3 && t4)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, false, false);\\n\\t\\t\\tif (t1 && t2)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, true, true);\\n\\t\\t\\tif (!t1 && !t2)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, true, true);\\n\\t\\t\\tif (t1 && !t2 && t3)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, false, true);\\n\\t\\t\\tif (!t1 && t2 && t4)\\n\\t\\t\\t\\tcount += numTilings(n, i + 1, true, false);\\n\\t\\t\\treturn dp[i][state] = count % mod;\\n\\t\\t}\\n\\t\\tint numTilings(int n)\\n\\t\\t{\\n\\t\\t\\tdp.resize(n + 1, vector<int>(4, -1));\\n\\t\\t\\treturn numTilings(n, 0);\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\n**Using Bottom UP **\\nBetter than 100%  submissions\\n\\t\\n\\tclass Solution\\n\\t{\\n\\tpublic:\\n\\t\\tlong long dp[1001][4];\\n\\t\\tconst int mod = 1e9 + 7;\\n\\t\\tint numTilings(int n)\\n\\t\\t{\\n\\t\\t\\tmemset(dp, 0, sizeof(dp));\\n\\t\\t\\tdp[0][3] = 1;\\n\\t\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; j < 4; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch (j)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase 0:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][3];\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 1:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][2] + dp[i - 1][0];\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 2:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][1] + dp[i - 1][0];\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 3:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][0] + dp[i - 1][3] + dp[i - 1][2] + dp[i - 1][1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdp[i][j] %= mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[n][3];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution\\n\\t{\\n\\tpublic:\\n\\t\\tvector<vector<int>> dp;\\n\\n\\t\\tconst int mod = 1e9 + 7;\\n\\t\\tint findState(bool t1, bool t2)\\n\\t\\t{\\n\\t\\t\\tint state = 0;\\n\\t\\t\\tif (t1)\\n\\t\\t\\t\\tstate |= 1;\\n\\t\\t\\tif (t2)\\n\\t\\t\\t\\tstate |= 2;\\n\\t\\t\\treturn state;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1621804,
                "title": "100ms-c-super-easy-observation-dp-soultion",
                "content": "I loved how beautifully other people are providing recursive and DP solution of this problem. These all solutions are no doubt excellent but I think they should also provide this observation solution which makes this question super easy.\\nMy solution is a Observation DP solution. \\n*I want that people should learn to observe patterns*. Many problems which seem too difficult/complicated to solve can be easily solved if you find the pattern.\\n**Pattern**\\n![image](https://assets.leetcode.com/users/images/742800c0-4b41-4a28-ad08-a07cfdc44cc2_1639156314.7856784.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int a[n+1];\\n        a[0] = 0;\\n        a[1] = 1;\\n        if(n>=2)\\n            a[2] = 2;\\n        if(n>=3)\\n            a[3] = 5;\\n        \\n        unsigned int M = 1e9+7;\\n        for(int i=4; i<n+1; i++){\\n            unsigned long long val = 1; \\n\\t\\t\\t// our val at a[i] is simply, val = (2*a[i-1]) + a[i-3] \\n\\t\\t\\t//but because this val is tool large \\n\\t\\t\\t//we have to take modulo at each step\\n\\t\\t\\tval = (val * a[i-1]) % M;\\n            val = (2 * val) % M;\\n            val = (val + a[i-3])%M;\\n            a[i] = val;\\n        }\\n        \\n        return a[n]; // returned our ans at a[n]\\n    }\\n};\\n```\\n**Please upvote!! If you understand the solution.**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        int a[n+1];\\n        a[0] = 0;\\n        a[1] = 1;\\n        if(n>=2)\\n            a[2] = 2;\\n        if(n>=3)\\n            a[3] = 5;\\n        \\n        unsigned int M = 1e9+7;\\n        for(int i=4; i<n+1; i++){\\n            unsigned long long val = 1; \\n\\t\\t\\t// our val at a[i] is simply, val = (2*a[i-1]) + a[i-3] \\n\\t\\t\\t//but because this val is tool large \\n\\t\\t\\t//we have to take modulo at each step\\n\\t\\t\\tval = (val * a[i-1]) % M;\\n            val = (2 * val) % M;\\n            val = (val + a[i-3])%M;\\n            a[i] = val;\\n        }\\n        \\n        return a[n]; // returned our ans at a[n]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621772,
                "title": "javscript-dp",
                "content": "```\\nvar numTilings = function(n) {\\n    if(n==1) return 1;\\n    if(n==2) return 2;\\n    if(n==3) return 5;\\n    let dp =[];\\n    dp[1] =1;\\n    dp[2] =2;\\n    dp[3] =5;\\n    let mod = 1e9 ;\\n    mod+=7;\\n    for(let i =4; i<=n; i++){\\n        dp[i] = (2*dp[i-1]%mod + dp[i-3]%mod) % mod;\\n    }\\n    return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTilings = function(n) {\\n    if(n==1) return 1;\\n    if(n==2) return 2;\\n    if(n==3) return 5;\\n    let dp =[];\\n    dp[1] =1;\\n    dp[2] =2;\\n    dp[3] =5;\\n    let mod = 1e9 ;\\n    mod+=7;\\n    for(let i =4; i<=n; i++){\\n        dp[i] = (2*dp[i-1]%mod + dp[i-3]%mod) % mod;\\n    }\\n    return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1621154,
                "title": "c-and-java-easy-explained-in-o-n-and-o-1-space",
                "content": "If you see the values for n, like (n = 1 ans  = 1), (n = 2 ans = 2), (n = 3 ans = 5), (n = 4 ans = 11), (n = 5 ans = 24), (n=6 ans = 53)....\\nWe can observe that in general for n, ans[n] = 2*(ans[n-1]) + ans[n-3]\\nNow this is simple DP problem!!\\n\\n***C++ Solution:***\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        \\n        vector<long long> dp(1001,0);\\n        dp[1]=1, dp[2]=2, dp[3]=5;\\n        \\n        if(n<=3)\\n            return dp[n];\\n        \\n        for(int i=4;i<=n;++i)\\n            dp[i]=(2*dp[i-1]+dp[i-3])%1000000007; \\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n***Java Solution:***\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n<=2) \\n            return n;\\n        \\n        int[] dp=new int[n+1];\\n        int mod = (int)(Math.pow(10,9)+7);\\n        dp[0]=1;dp[1]=1;dp[2]=2;\\n        \\n\\t\\tfor(int i=3;i<=n;i++) {\\n            dp[i]=(2*dp[i-1])%mod+dp[i-3];\\n            dp[i]%=mod;\\n        }\\n\\t\\t\\n        return dp[n];\\n    }\\n}\\n```\\n***Time:*** O(n) ***Space:*** O(n)\\n\\nBut what if we want to decrease space too.... \\uD83E\\uDDD0\\uD83E\\uDD14\\n\\nWe can observe that ans[n] is just being dependent on ans[n-1] and ans[n-3]. So we will take 4 variables (namely one, two, three, res). Now we can store dp[1], dp[2], dp[3] into one, two, three variables resp. And res = 2 * three + one. Thats it!!!\\n\\n***C++ Solution:***\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        \\n        long long one=1, two=2, three=5, total;\\n        \\n        if (n==1)\\n            return one;\\n        if (n==2)\\n            return two;\\n        if (n==3)\\n            return three;\\n        \\n        for(int i=4; i<=n; i++){\\n            total = (2*three + one)%1000000007;\\n            one = two;\\n            two = three;\\n            three = total;\\n        }\\n        \\n        return total%1000000007;\\n    }\\n};\\n```\\n\\n***Java Solution:***\\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        int one=1, two=2, three=5, total=0;\\n        \\n        if (n==1)\\n            return 1;\\n        if (n==2)\\n            return 2;\\n        if (n==3)\\n            return 5;\\n        \\n        for(int i=4; i<=n; i++){\\n            total = (2*three%1000000007 + one)%1000000007;\\n            one = two;\\n            two = three;\\n            three = total;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```\\n\\n***Time:*** O(n)         ***Space:*** O(1)\\n\\nPlease upvote if you found helpful!!\\u263A\\uFE0F",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        \\n        vector<long long> dp(1001,0);\\n        dp[1]=1, dp[2]=2, dp[3]=5;\\n        \\n        if(n<=3)\\n            return dp[n];\\n        \\n        for(int i=4;i<=n;++i)\\n            dp[i]=(2*dp[i-1]+dp[i-3])%1000000007; \\n        \\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        if(n<=2) \\n            return n;\\n        \\n        int[] dp=new int[n+1];\\n        int mod = (int)(Math.pow(10,9)+7);\\n        dp[0]=1;dp[1]=1;dp[2]=2;\\n        \\n\\t\\tfor(int i=3;i<=n;i++) {\\n            dp[i]=(2*dp[i-1])%mod+dp[i-3];\\n            dp[i]%=mod;\\n        }\\n\\t\\t\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        \\n        long long one=1, two=2, three=5, total;\\n        \\n        if (n==1)\\n            return one;\\n        if (n==2)\\n            return two;\\n        if (n==3)\\n            return three;\\n        \\n        for(int i=4; i<=n; i++){\\n            total = (2*three + one)%1000000007;\\n            one = two;\\n            two = three;\\n            three = total;\\n        }\\n        \\n        return total%1000000007;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int numTilings(int n) {\\n        int one=1, two=2, three=5, total=0;\\n        \\n        if (n==1)\\n            return 1;\\n        if (n==2)\\n            return 2;\\n        if (n==3)\\n            return 5;\\n        \\n        for(int i=4; i<=n; i++){\\n            total = (2*three%1000000007 + one)%1000000007;\\n            one = two;\\n            two = three;\\n            three = total;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620998,
                "title": "c-simple-o-n-time-and-space-complexity-solution-using-only-one-array",
                "content": "We use a 2d dp array having two states 0 and 1 .\\n\\nWhere 0 represent that both block in this column are empty and 1 represent one block of this colum is filled and one is empty.\\n\\ndp[i][0] gives the possible number of ways of tiling tiles from i to n when ith column is empty\\ndp[i][1] gives the possible number of ways of tiling tiles from i to n when ith column has one filled block.\\n\\nNow dp[i][0] will be \\n\\ndp[i+1][0](we filled the ith column with a vertical domino and moves to next column which is empty )\\n                                         + \\n 2*dp[i+1][1](we fill ith column with a tromino and move to next column which is half filled and we have multiplied it by 2 because there are two ways of putting the tromino  )\\n                                         + \\n dp[i+2][0] (we filled the ith and (i+1)th column with two horizontal domino and moves to i+2 th column which is empty )\\n\\ndp[i][1] will be \\n\\ndp[i+1][1] (we filled the empty block with a horizontal domino which completes this column and makes the next column half filled) \\n                             + \\n dp[i+2][0](we filled this half empty and next column with a tromino and move to i+2 th column)\\n \\n Now the base cases:-\\n \\n if we reach the nth column which is empty we can fill it with vertical domino and complete our tiling so we return 1 but if the nth column is half filled then there is no way to complete the tiling so we return 0.\\n \\nif we reach the n+1th colum directly from n-1 then we will return 1 because all the column till n is completrly filled beacuse whenever we have jumped to i+2 we have always completrd all the column till i+1.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long dp[1001][2];\\n    int mod=1e9+7;\\n    long long solve(int i,int c,int n){\\n        if(i>n){\\n            return 1;\\n        }\\n        if(i==n){\\n            if(c==0)return 1;\\n            return 0;\\n        }\\n        if(dp[i][c]!=-1)return dp[i][c];\\n        if(c==0){\\n            return dp[i][c]=(solve(i+1,0,n)%mod+(2*solve(i+1,1,n)%mod)%mod + solve(i+2,0,n)%mod)%mod;\\n        }else{\\n            return dp[i][c]=(solve(i+1,1,n)%mod+solve(i+2,0,n)%mod)%mod;\\n        }\\n    }\\n    int numTilings(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(1,0,n)%mod;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[1001][2];\\n    int mod=1e9+7;\\n    long long solve(int i,int c,int n){\\n        if(i>n){\\n            return 1;\\n        }\\n        if(i==n){\\n            if(c==0)return 1;\\n            return 0;\\n        }\\n        if(dp[i][c]!=-1)return dp[i][c];\\n        if(c==0){\\n            return dp[i][c]=(solve(i+1,0,n)%mod+(2*solve(i+1,1,n)%mod)%mod + solve(i+2,0,n)%mod)%mod;\\n        }else{\\n            return dp[i][c]=(solve(i+1,1,n)%mod+solve(i+2,0,n)%mod)%mod;\\n        }\\n    }\\n    int numTilings(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(1,0,n)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481663,
                "title": "fastest-c-solution-bottom-up-dp-dp-n-2-dp-n-1-dp-n-3",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<long long >dp(n+1,0);\\n        if(n==1) return 1;\\n        if(n==2) return 2;                            //Base Cases\\n        if(n==3) return 5;\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        int mod=1000000007;\\n        for(int i=4;i<=n;i++)\\n        {\\n            dp[i]=((2*dp[i-1])%mod+(dp[i-3])%mod)%mod;\\n        }\\n        return dp[n];\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        vector<long long >dp(n+1,0);\\n        if(n==1) return 1;\\n        if(n==2) return 2;                            //Base Cases\\n        if(n==3) return 5;\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        dp[3]=5;\\n        int mod=1000000007;\\n        for(int i=4;i<=n;i++)\\n        {\\n            dp[i]=((2*dp[i-1])%mod+(dp[i-3])%mod)%mod;\\n        }\\n        return dp[n];\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343202,
                "title": "lol",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numTilings(int n) {\\n\\t\\t\\tint arr[1001] = {0, 1, 2, 5, 11, 24, 53, 117, 258, 569, 1255, 2768, 6105, 13465, 29698, 65501, 144467, 318632, 702765, 1549997, 3418626, 7540017, 16630031, 36678688, 80897393, 178424817, 393528322, 867954037, 914332884, 222194076, 312342182, 539017241, 300228551, 912799284, 364615795, 29460134, 971719552, 308054885, 645569904, 262859346, 833773577, 313117044, 889093434, 611960431, 537037899, 963169225, 538298867, 613635626, 190440463, 919179793, 451995198, 94430852, 108041490, 668078178, 430587201, 969215892, 606509948, 643607090, 256430058, 119370057, 882347204, 21124452, 161618961, 205585119, 432294690, 26208334, 258001787, 948298264, 922804855, 103611483, 155521223, 233847294, 571306071, 298133358, 830114010, 231534077, 761201512, 352517020, 936568117, 634337732, 621192477, 178953057, 992243846, 605680155, 390313360, 772870559, 151421259, 693155878, 159182301, 469785861, 632727593, 424637480, 319060814, 270849214, 966335908, 251732616, 774314446, 514964786, 281662181, 337638801, 190242381, 662146943, 661932680, 514107734, 690362404, 42657474, 599422682, 889207761, 821072989, 241568646, 372345046, 565763074, 373094787, 118534613, 802832300, 978759380, 76053359, 954939018, 888637402, 853328156, 661595316, 211828020, 276984189, 215563687, 642955394, 562894970, 341353620, 325662627, 214220217, 769794054, 865250728, 944721666, 659237372, 183725458, 312172575, 283582515, 750890488, 813953544, 911489596, 573869666, 961692869, 834875320, 243620292, 448933446, 732742205, 709104695, 867142829, 467027849, 643160386, 153463587, 773955023, 191070418, 535604423, 845163862, 881398135, 298400679, 441965213, 765328554, 829057780, 100080759, 965490072, 760037910, 620156572, 205803202, 171644307, 963445186, 132693560, 437031427, 837508033, 807709619, 52450651, 942409335, 692528275, 437507194, 817423716, 327375693, 92258573, 1940855, 331257403, 754773379, 511487606, 354232608, 463238588, 437964775, 230162151, 923562890, 285090541, 800343233, 524249342, 333589218, 467521662, 459292659, 252174529, 971870720, 403034085, 58242692, 88356097, 579746279, 217735243, 523826583, 627399438, 472534112, 468894800, 565189031, 602912167, 674719127, 914627278, 432166709, 539052538, 992732347, 417631389, 374315309, 741362958, 900357298, 175029891, 91422733, 83202757, 341435405, 774293543, 631789836, 605015070, 984323676, 600437174, 805889411, 596102484, 792642135, 391173667, 378449811, 549541750, 490257160, 358964124, 267469991, 25197135, 409358394, 86186772, 197570679, 804499752, 695186269, 587943210, 980386165, 655958585, 899860373, 780106897, 216172365, 332205096, 444517082, 105206522, 542618140, 529753355, 164713225, 872044590, 273842521, 712398267, 296841110, 867524741, 447447735, 191736573, 250997880, 949443495, 90623549, 432244978, 813933444, 718490430, 869225831, 552385092, 823260607, 515747031, 583879147, 991018894, 497784805, 579448750, 149916380, 797617565, 174683866, 499284112, 796185782, 767055423, 33394944, 862975670, 493006749, 19408435, 901792540, 296591815, 612592065, 126976656, 550545127, 713682312, 554341273, 659227666, 32137630, 618616533, 896460725, 825059073, 268734665, 433930048, 692919162, 654572982, 743076005, 179071158, 12715291, 768506587, 716084325, 444883934, 658274448, 32633207, 510150348, 678575137, 389783474, 289717289, 258009708, 905802890, 101323055, 460655818, 827114519, 755552086, 971759983, 770634471, 296821014, 565402004, 901438472, 99697944, 764797892, 431034242, 961766428, 688330734, 807695703, 577157820, 842646367, 492988423, 563134659, 968915678, 430819765, 424774182, 818464035, 67747821, 560269824, 939003676, 945755166, 451780142, 842563953, 630883058, 713546251, 269656441, 170195933, 53938110, 377532661, 925261255, 904460613, 186453873, 298168994, 500798594, 188051054, 674271102, 849340791, 886732629, 447736346, 744813476, 376359567, 200455473, 145724415, 667808397, 536072260, 217868928, 103546246, 743164752, 704198425, 511943089, 767050923, 238300257, 988543603, 744138115, 726576480, 441696549, 627531206, 981638885, 404974305, 437479809, 856598496, 118171283, 673822375, 204243232, 526657747, 727137862, 658518949, 843695638, 414529124, 487577190, 818850011, 52229132, 592035454, 2920905, 58070942, 708177338, 419275574, 896622090, 501421504, 422118575, 740859233, 983139963, 388398487, 517656200, 18452349, 425303185, 368262563, 754977475, 935258128, 238778805, 232535078, 400328277, 39435352, 311405782, 23139834, 85715020, 482835822, 988811478, 63337962, 609511746, 207834956, 479007874, 567527487, 342889923, 164787713, 897102913, 137095735, 438979183, 775061272, 687218272, 813415720, 401892698, 491003661, 795423035, 992738761, 476481169, 748385366, 489509479, 455500120, 659385599, 808280670, 72061446, 803508491, 415297638, 902656722, 608821921, 632941473, 168539654, 945901229, 524743917, 218027481, 381956184, 288656278, 795340037, 972636251, 233928766, 263197562, 499031368, 231991495, 727180552, 953392465, 138776411, 4733367, 962859199, 64494795, 133722957, 230305106, 525105007, 183932964, 598171034, 721447068, 626827093, 851825213, 425097480, 477022046, 805869298, 36836062, 550694170, 907257631, 851351317, 253396790, 414051204, 679453718, 612304219, 638659635, 956772981, 525850167, 690359962, 337492891, 200835942, 92031839, 521556569, 243949073, 579929985, 681416532, 606782130, 793494238, 268404994, 143592111, 80678453, 429761900, 3115904, 86910261, 603582422, 210280741, 507471743, 618525901, 447332536, 402136808, 422799510, 292931549, 987999906, 398799308, 90530158, 169060215, 736919738, 564369627, 297799462, 332518655, 229406930, 756613322, 845745292, 920897507, 598408322, 42561922, 6021344, 610451010, 263463935, 532949214, 676349431, 616162790, 765274787, 206898991, 29960765, 825196317, 857291618, 744543994, 314284291, 485860193, 716264373, 746813030, 979486246, 675236851, 97286718, 174059675, 23356194, 143999106, 462057887, 947471968, 38943028, 539943943, 27359840, 93662708, 727269359, 481898551, 57459803, 842188965, 166276467, 390012737, 622214432, 410705324, 211423378, 45061181, 500827686, 213078743, 471218667, 443265013, 99608762, 670436191, 784137388, 667883531, 6203239, 796543866, 260971249, 528145737, 852835333, 966641908, 461429539, 775694404, 518030702, 497490936, 770676269, 59383226, 616257388, 3191031, 65765288, 747787964, 498766952, 63299185, 874386334, 247539606, 558378397, 991143121, 229825834, 18030058, 27203230, 284232294, 586494646, 200192515, 684617324, 955729287, 111651075, 907919474, 771568221, 654787510, 217494480, 206557174, 67901851, 353298182, 913153538, 894208920, 141716008, 196585547, 287380007, 716476022, 629537584, 546455168, 809386351, 248310272, 43075705, 895537761, 39385780, 121847265, 139232284, 317850348, 757547961, 654328199, 626506739, 10561425, 675451049, 977408830, 965379078, 606209191, 189827198, 345033467, 296276118, 782379434, 909792328, 115860760, 14100947, 937994222, 991849197, 997799334, 933592876, 859034935, 715869190, 365331242, 589697412, 895264007, 155859242, 901415896, 698095785, 552050805, 5517492, 709130769, 970312336, 946142157, 601415069, 173142460, 292427070, 186269202, 545680864, 383788791, 953846784, 453374418, 290537620, 534922017, 523218445, 336974503, 208871016, 940960477, 218895443, 646661902, 234284267, 687463977, 21589842, 277463951, 242391872, 506373586, 290211116, 822814104, 152001780, 594214676, 11243442, 174488664, 943192004, 897627443, 969743543, 882679076, 662985581, 295714691, 474108451, 611202476, 518119636, 510347716, 631897901, 781915431, 74178564, 780255029, 342425475, 759029514, 298314043, 939053561, 637136622, 572587280, 84228107, 805592836, 183772938, 451773983, 709140795, 602054521, 655883018, 20906817, 643868155, 943619321, 908145452, 460159045, 863937404, 636020246, 732199530, 328336450, 292693139, 317585801, 963508052, 219709229, 757004259, 477516556, 174742334, 106488920, 690494396, 555731119, 217951151, 126396691, 808524501, 835000146, 796396976, 401318439, 637637017, 71670996, 544660431, 726957872, 525586733, 595833890, 918625645, 362838009, 321509901, 561645440, 486128882, 293767658, 149180749, 784490380, 862748411, 874677564, 533845494, 930439392, 735556334, 4958148, 940355688, 616267696, 237493533, 415342747, 446953183, 131399892, 678142531, 803238238, 737876361, 153895239, 111028709, 959933779, 73762783, 258554275, 477042322, 27847420, 314249115, 105540545, 238928510, 792106135, 689752808, 618434119, 28974359, 747701526, 113837157, 256648673, 260998865, 635834887, 528318440, 317635738, 271106356, 70531145, 458698028, 188502405, 447535955, 353769931, 896042267, 239620475, 833010881, 562064015, 363748498, 560507870, 683079748, 729907987, 20323830, 723727408, 177362789, 375049408, 473826217, 125015216, 625079840, 723985890, 572986989, 771053811, 266093498, 105173978, 981401767, 228897018, 562968014, 107337781, 443572580, 450113167, 7564108, 458700796, 367514752, 742593612, 943888013, 255290764, 253175133, 450238272, 155767301, 564709735, 579657735, 315082764, 194875256, 969408247, 253899244, 702673744, 374755721, 3410679, 709495102, 793745918, 590902508, 891300111, 576346126, 743594753, 378489603, 333325325, 410245396, 198980388, 731286101, 872817591, 944615563, 620517213, 113852003, 172319562, 965156337, 44164663, 260648888, 486454106, 17072868, 294794624, 76043347, 169159562, 633113748, 342270836, 853701234, 340516202, 23303233, 900307700, 141131588, 305566409, 511440511, 164012603, 633591615, 778623734, 721260064, 76111729, 930847192, 582954434, 242020590, 414888365, 412731157, 67482897, 549854159, 512439468, 92361826, 734577811, 981595083, 55551978, 845681767, 672958603, 401469177, 648620114, 970198824, 341866811, 332353729, 634906275, 611679354, 555712430, 746331128, 104341596, 764395622, 275122358, 654586312, 73568232, 422258822, 499103949, 71776123, 565811068, 630726078, 333228272, 232267605, 95261281, 523750834, 279769266, 654799813, 833350453, 946470165, 547740129, 928830704, 804131559, 156003233, 240837163, 285805878, 727614989, 696067134, 677940139, 83495253, 863057640, 404055405, 891606063, 646269752, 696594902, 284795853, 215861451, 128317797, 541431447, 298724338, 725766473, 992964386, 284653096, 295072658, 583109695, 450872479, 196817609, 976744913, 404362291, 5542184, 987829281, 380020839, 765583862, 518996991, 418014814, 601613483, 722223950, 862462707, 326538883, 375301709, 613066118, 552671112, 480643926, 574353963, 701379031, 883401981, 341157911, 383694846, 650791666, 642741236, 669177311, 989146281, 621033784, 911244872, 811636011, 244305792, 399856449, 611348902, 467003589, 333863620, 279076135, 25155852, 384175324, 47426776, 120009404, 624194132, 295815033, 711639470, 47473058, 390761149, 493161761, 33796573, 458354295, 409870344, 853537261, 165428803, 740727950, 334993147, 835415097, 411558130, 158109400, 151633890, 714825910, 587761213, 327156309, 369138521, 326038248, 979232805};\\n\\t\\t\\treturn arr[n];\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numTilings(int n) {\\n\\t\\t\\tint arr[1001] = {0, 1, 2, 5, 11, 24, 53, 117, 258, 569, 1255, 2768, 6105, 13465, 29698, 65501, 144467, 318632, 702765, 1549997, 3418626, 7540017, 16630031, 36678688, 80897393, 178424817, 393528322, 867954037, 914332884, 222194076, 312342182, 539017241, 300228551, 912799284, 364615795, 29460134, 971719552, 308054885, 645569904, 262859346, 833773577, 313117044, 889093434, 611960431, 537037899, 963169225, 538298867, 613635626, 190440463, 919179793, 451995198, 94430852, 108041490, 668078178, 430587201, 969215892, 606509948, 643607090, 256430058, 119370057, 882347204, 21124452, 161618961, 205585119, 432294690, 26208334, 258001787, 948298264, 922804855, 103611483, 155521223, 233847294, 571306071, 298133358, 830114010, 231534077, 761201512, 352517020, 936568117, 634337732, 621192477, 178953057, 992243846, 605680155, 390313360, 772870559, 151421259, 693155878, 159182301, 469785861, 632727593, 424637480, 319060814, 270849214, 966335908, 251732616, 774314446, 514964786, 281662181, 337638801, 190242381, 662146943, 661932680, 514107734, 690362404, 42657474, 599422682, 889207761, 821072989, 241568646, 372345046, 565763074, 373094787, 118534613, 802832300, 978759380, 76053359, 954939018, 888637402, 853328156, 661595316, 211828020, 276984189, 215563687, 642955394, 562894970, 341353620, 325662627, 214220217, 769794054, 865250728, 944721666, 659237372, 183725458, 312172575, 283582515, 750890488, 813953544, 911489596, 573869666, 961692869, 834875320, 243620292, 448933446, 732742205, 709104695, 867142829, 467027849, 643160386, 153463587, 773955023, 191070418, 535604423, 845163862, 881398135, 298400679, 441965213, 765328554, 829057780, 100080759, 965490072, 760037910, 620156572, 205803202, 171644307, 963445186, 132693560, 437031427, 837508033, 807709619, 52450651, 942409335, 692528275, 437507194, 817423716, 327375693, 92258573, 1940855, 331257403, 754773379, 511487606, 354232608, 463238588, 437964775, 230162151, 923562890, 285090541, 800343233, 524249342, 333589218, 467521662, 459292659, 252174529, 971870720, 403034085, 58242692, 88356097, 579746279, 217735243, 523826583, 627399438, 472534112, 468894800, 565189031, 602912167, 674719127, 914627278, 432166709, 539052538, 992732347, 417631389, 374315309, 741362958, 900357298, 175029891, 91422733, 83202757, 341435405, 774293543, 631789836, 605015070, 984323676, 600437174, 805889411, 596102484, 792642135, 391173667, 378449811, 549541750, 490257160, 358964124, 267469991, 25197135, 409358394, 86186772, 197570679, 804499752, 695186269, 587943210, 980386165, 655958585, 899860373, 780106897, 216172365, 332205096, 444517082, 105206522, 542618140, 529753355, 164713225, 872044590, 273842521, 712398267, 296841110, 867524741, 447447735, 191736573, 250997880, 949443495, 90623549, 432244978, 813933444, 718490430, 869225831, 552385092, 823260607, 515747031, 583879147, 991018894, 497784805, 579448750, 149916380, 797617565, 174683866, 499284112, 796185782, 767055423, 33394944, 862975670, 493006749, 19408435, 901792540, 296591815, 612592065, 126976656, 550545127, 713682312, 554341273, 659227666, 32137630, 618616533, 896460725, 825059073, 268734665, 433930048, 692919162, 654572982, 743076005, 179071158, 12715291, 768506587, 716084325, 444883934, 658274448, 32633207, 510150348, 678575137, 389783474, 289717289, 258009708, 905802890, 101323055, 460655818, 827114519, 755552086, 971759983, 770634471, 296821014, 565402004, 901438472, 99697944, 764797892, 431034242, 961766428, 688330734, 807695703, 577157820, 842646367, 492988423, 563134659, 968915678, 430819765, 424774182, 818464035, 67747821, 560269824, 939003676, 945755166, 451780142, 842563953, 630883058, 713546251, 269656441, 170195933, 53938110, 377532661, 925261255, 904460613, 186453873, 298168994, 500798594, 188051054, 674271102, 849340791, 886732629, 447736346, 744813476, 376359567, 200455473, 145724415, 667808397, 536072260, 217868928, 103546246, 743164752, 704198425, 511943089, 767050923, 238300257, 988543603, 744138115, 726576480, 441696549, 627531206, 981638885, 404974305, 437479809, 856598496, 118171283, 673822375, 204243232, 526657747, 727137862, 658518949, 843695638, 414529124, 487577190, 818850011, 52229132, 592035454, 2920905, 58070942, 708177338, 419275574, 896622090, 501421504, 422118575, 740859233, 983139963, 388398487, 517656200, 18452349, 425303185, 368262563, 754977475, 935258128, 238778805, 232535078, 400328277, 39435352, 311405782, 23139834, 85715020, 482835822, 988811478, 63337962, 609511746, 207834956, 479007874, 567527487, 342889923, 164787713, 897102913, 137095735, 438979183, 775061272, 687218272, 813415720, 401892698, 491003661, 795423035, 992738761, 476481169, 748385366, 489509479, 455500120, 659385599, 808280670, 72061446, 803508491, 415297638, 902656722, 608821921, 632941473, 168539654, 945901229, 524743917, 218027481, 381956184, 288656278, 795340037, 972636251, 233928766, 263197562, 499031368, 231991495, 727180552, 953392465, 138776411, 4733367, 962859199, 64494795, 133722957, 230305106, 525105007, 183932964, 598171034, 721447068, 626827093, 851825213, 425097480, 477022046, 805869298, 36836062, 550694170, 907257631, 851351317, 253396790, 414051204, 679453718, 612304219, 638659635, 956772981, 525850167, 690359962, 337492891, 200835942, 92031839, 521556569, 243949073, 579929985, 681416532, 606782130, 793494238, 268404994, 143592111, 80678453, 429761900, 3115904, 86910261, 603582422, 210280741, 507471743, 618525901, 447332536, 402136808, 422799510, 292931549, 987999906, 398799308, 90530158, 169060215, 736919738, 564369627, 297799462, 332518655, 229406930, 756613322, 845745292, 920897507, 598408322, 42561922, 6021344, 610451010, 263463935, 532949214, 676349431, 616162790, 765274787, 206898991, 29960765, 825196317, 857291618, 744543994, 314284291, 485860193, 716264373, 746813030, 979486246, 675236851, 97286718, 174059675, 23356194, 143999106, 462057887, 947471968, 38943028, 539943943, 27359840, 93662708, 727269359, 481898551, 57459803, 842188965, 166276467, 390012737, 622214432, 410705324, 211423378, 45061181, 500827686, 213078743, 471218667, 443265013, 99608762, 670436191, 784137388, 667883531, 6203239, 796543866, 260971249, 528145737, 852835333, 966641908, 461429539, 775694404, 518030702, 497490936, 770676269, 59383226, 616257388, 3191031, 65765288, 747787964, 498766952, 63299185, 874386334, 247539606, 558378397, 991143121, 229825834, 18030058, 27203230, 284232294, 586494646, 200192515, 684617324, 955729287, 111651075, 907919474, 771568221, 654787510, 217494480, 206557174, 67901851, 353298182, 913153538, 894208920, 141716008, 196585547, 287380007, 716476022, 629537584, 546455168, 809386351, 248310272, 43075705, 895537761, 39385780, 121847265, 139232284, 317850348, 757547961, 654328199, 626506739, 10561425, 675451049, 977408830, 965379078, 606209191, 189827198, 345033467, 296276118, 782379434, 909792328, 115860760, 14100947, 937994222, 991849197, 997799334, 933592876, 859034935, 715869190, 365331242, 589697412, 895264007, 155859242, 901415896, 698095785, 552050805, 5517492, 709130769, 970312336, 946142157, 601415069, 173142460, 292427070, 186269202, 545680864, 383788791, 953846784, 453374418, 290537620, 534922017, 523218445, 336974503, 208871016, 940960477, 218895443, 646661902, 234284267, 687463977, 21589842, 277463951, 242391872, 506373586, 290211116, 822814104, 152001780, 594214676, 11243442, 174488664, 943192004, 897627443, 969743543, 882679076, 662985581, 295714691, 474108451, 611202476, 518119636, 510347716, 631897901, 781915431, 74178564, 780255029, 342425475, 759029514, 298314043, 939053561, 637136622, 572587280, 84228107, 805592836, 183772938, 451773983, 709140795, 602054521, 655883018, 20906817, 643868155, 943619321, 908145452, 460159045, 863937404, 636020246, 732199530, 328336450, 292693139, 317585801, 963508052, 219709229, 757004259, 477516556, 174742334, 106488920, 690494396, 555731119, 217951151, 126396691, 808524501, 835000146, 796396976, 401318439, 637637017, 71670996, 544660431, 726957872, 525586733, 595833890, 918625645, 362838009, 321509901, 561645440, 486128882, 293767658, 149180749, 784490380, 862748411, 874677564, 533845494, 930439392, 735556334, 4958148, 940355688, 616267696, 237493533, 415342747, 446953183, 131399892, 678142531, 803238238, 737876361, 153895239, 111028709, 959933779, 73762783, 258554275, 477042322, 27847420, 314249115, 105540545, 238928510, 792106135, 689752808, 618434119, 28974359, 747701526, 113837157, 256648673, 260998865, 635834887, 528318440, 317635738, 271106356, 70531145, 458698028, 188502405, 447535955, 353769931, 896042267, 239620475, 833010881, 562064015, 363748498, 560507870, 683079748, 729907987, 20323830, 723727408, 177362789, 375049408, 473826217, 125015216, 625079840, 723985890, 572986989, 771053811, 266093498, 105173978, 981401767, 228897018, 562968014, 107337781, 443572580, 450113167, 7564108, 458700796, 367514752, 742593612, 943888013, 255290764, 253175133, 450238272, 155767301, 564709735, 579657735, 315082764, 194875256, 969408247, 253899244, 702673744, 374755721, 3410679, 709495102, 793745918, 590902508, 891300111, 576346126, 743594753, 378489603, 333325325, 410245396, 198980388, 731286101, 872817591, 944615563, 620517213, 113852003, 172319562, 965156337, 44164663, 260648888, 486454106, 17072868, 294794624, 76043347, 169159562, 633113748, 342270836, 853701234, 340516202, 23303233, 900307700, 141131588, 305566409, 511440511, 164012603, 633591615, 778623734, 721260064, 76111729, 930847192, 582954434, 242020590, 414888365, 412731157, 67482897, 549854159, 512439468, 92361826, 734577811, 981595083, 55551978, 845681767, 672958603, 401469177, 648620114, 970198824, 341866811, 332353729, 634906275, 611679354, 555712430, 746331128, 104341596, 764395622, 275122358, 654586312, 73568232, 422258822, 499103949, 71776123, 565811068, 630726078, 333228272, 232267605, 95261281, 523750834, 279769266, 654799813, 833350453, 946470165, 547740129, 928830704, 804131559, 156003233, 240837163, 285805878, 727614989, 696067134, 677940139, 83495253, 863057640, 404055405, 891606063, 646269752, 696594902, 284795853, 215861451, 128317797, 541431447, 298724338, 725766473, 992964386, 284653096, 295072658, 583109695, 450872479, 196817609, 976744913, 404362291, 5542184, 987829281, 380020839, 765583862, 518996991, 418014814, 601613483, 722223950, 862462707, 326538883, 375301709, 613066118, 552671112, 480643926, 574353963, 701379031, 883401981, 341157911, 383694846, 650791666, 642741236, 669177311, 989146281, 621033784, 911244872, 811636011, 244305792, 399856449, 611348902, 467003589, 333863620, 279076135, 25155852, 384175324, 47426776, 120009404, 624194132, 295815033, 711639470, 47473058, 390761149, 493161761, 33796573, 458354295, 409870344, 853537261, 165428803, 740727950, 334993147, 835415097, 411558130, 158109400, 151633890, 714825910, 587761213, 327156309, 369138521, 326038248, 979232805}",
                "codeTag": "Java"
            },
            {
                "id": 1150428,
                "title": "python3-memoization",
                "content": "Use `i` and `j` to record the next tile to fill for row 0 and row 1, respectively.\\n\\n```python\\nclass Solution:\\n    def numTilings(self, N: int) -> int:\\n        MOD = 10**9 + 7\\n\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == j == N:\\n                return 1\\n            if i > N or j > N:\\n                return 0\\n            if i == j:\\n                return dp(i+1, j+1) + dp(i+2, j+2) + dp(i+1, j+2) + dp(i+2, j+1)\\n            elif i > j:\\n                return dp(i, j+2) + dp(i+1, j+2)\\n            else:\\n                return dp(i+2, j) + dp(i+2, j+1)\\n        \\n        return dp(0, 0) % MOD\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numTilings(self, N: int) -> int:\\n        MOD = 10**9 + 7\\n\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == j == N:\\n                return 1\\n            if i > N or j > N:\\n                return 0\\n            if i == j:\\n                return dp(i+1, j+1) + dp(i+2, j+2) + dp(i+1, j+2) + dp(i+2, j+1)\\n            elif i > j:\\n                return dp(i, j+2) + dp(i+1, j+2)\\n            else:\\n                return dp(i+2, j) + dp(i+2, j+1)\\n        \\n        return dp(0, 0) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088361,
                "title": "a-proof-and-explanation-for-the-problem",
                "content": "Let us construct a dp[N+1][3] , such that dp[i][0] = count of ways such that at ith position both the rows are filled , dp[i][1] = number of ways such that only lower row is filled , and dp[i][2] = number of ways sucht that only upper row is filled at i. \\n\\nNow, the base cases can be \\n```\\n\\t\\tdp[1][0] = 1;  // vertical\\n        dp[1][1] = 0; // not possible\\n        dp[1][2] = 0; // not possible \\n        dp[2][0] = 2; // two vertical or two horizontal \\n        dp[2][1] = 1; // L\\n        dp[2][2] = 1; // inverted L\\n\\t\\n```\\nNow, we can calculate the next states using the following recurssions :\\n```\\ndp[i][0] = (dp[i-1][0] + dp[i-2][0] + dp[i-1][1] + dp[i-1][2]); \\n(vertical + two horizontal + L  + inverted Ll)\\n            \\ndp[i][1] = (dp[i-2][0] + dp[i-1][2]);\\n(L + horizontal)\\n            \\ndp[i][2] = (dp[i-2][0] + dp[i-1][1]);\\n(inverted L + horizontal )\\n```\\n\\nAlso, these equations can be reduced to \\n```\\ndp[i] = 2*dp[i-1] + dp[i-3]\\n```\\nThe complete approach \\ndp[i][0] is replaced by dp[i] \\n```\\ndp[i][0] = (dp[i-1][0] + dp[i-2][0] + dp[i-1][1] + dp[i-1][2]);      (1) \\n            \\ndp[i][1] = (dp[i-2][0] + dp[i-1][2]);     (2)\\n            \\ndp[i][2] = (dp[i-2][0] + dp[i-1][1]);      (3)\\n\\n```\\n```\\nfrom 2 and 3\\n\\ndp[i-1][1] = dp[i-3] + dp[i-2][2]\\n\\ndp[i-1][2] = dp[i-3] + dp[i-2][1]\\n\\ndp[i-1][1] + dp[i-1][2] = 2*dp[i-3] + (dp[i-2][2] + dp[i-2][1]);\\n\\n(dp[i-1][1] + dp[i-1][2]) - (dp[i-2][2] + dp[i-2][1]) = 2*dp[i-3];\\n```\\n```\\nfrom 1\\n\\ndp[i-1][0] = (dp[i-2][0] + dp[i-3][0] + dp[i-2][1] + dp[i-2][2]); ---2\\n\\n\\ndp[i] - dp[i-1] = dp[i-1] - dp[i-3] + dp[i-1][1] + dp[i-1][2]   - dp[i-2][1] - dp[i-2][2]\\n\\ndp[i] - dp[i-1] = dp[i-1] - dp[i-3] + 2*dp[i-3];\\n\\ndp[i] = 2*dp[i-1] + dp[i-3] \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\t\\tdp[1][0] = 1;  // vertical\\n        dp[1][1] = 0; // not possible\\n        dp[1][2] = 0; // not possible \\n        dp[2][0] = 2; // two vertical or two horizontal \\n        dp[2][1] = 1; // L\\n        dp[2][2] = 1; // inverted L\\n\\t\\n```\n```\\ndp[i][0] = (dp[i-1][0] + dp[i-2][0] + dp[i-1][1] + dp[i-1][2]); \\n(vertical + two horizontal + L  + inverted Ll)\\n            \\ndp[i][1] = (dp[i-2][0] + dp[i-1][2]);\\n(L + horizontal)\\n            \\ndp[i][2] = (dp[i-2][0] + dp[i-1][1]);\\n(inverted L + horizontal )\\n```\n```\\ndp[i] = 2*dp[i-1] + dp[i-3]\\n```\n```\\ndp[i][0] = (dp[i-1][0] + dp[i-2][0] + dp[i-1][1] + dp[i-1][2]);      (1) \\n            \\ndp[i][1] = (dp[i-2][0] + dp[i-1][2]);     (2)\\n            \\ndp[i][2] = (dp[i-2][0] + dp[i-1][1]);      (3)\\n\\n```\n```\\nfrom 2 and 3\\n\\ndp[i-1][1] = dp[i-3] + dp[i-2][2]\\n\\ndp[i-1][2] = dp[i-3] + dp[i-2][1]\\n\\ndp[i-1][1] + dp[i-1][2] = 2*dp[i-3] + (dp[i-2][2] + dp[i-2][1]);\\n\\n(dp[i-1][1] + dp[i-1][2]) - (dp[i-2][2] + dp[i-2][1]) = 2*dp[i-3];\\n```\n```\\nfrom 1\\n\\ndp[i-1][0] = (dp[i-2][0] + dp[i-3][0] + dp[i-2][1] + dp[i-2][2]); ---2\\n\\n\\ndp[i] - dp[i-1] = dp[i-1] - dp[i-3] + dp[i-1][1] + dp[i-1][2]   - dp[i-2][1] - dp[i-2][2]\\n\\ndp[i] - dp[i-1] = dp[i-1] - dp[i-3] + 2*dp[i-3];\\n\\ndp[i] = 2*dp[i-1] + dp[i-3] \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059526,
                "title": "javascript-short-recursion-memoization",
                "content": "```\\nvar numTilings = function(N) {\\n  const mod = 1e9 + 7\\n  const cash = new Map([[1,1],[2,2],[3,5]])\\n  const count = (n) => {\\n    if (!cash.has(n)) cash.set(n, count(n-1)*2 + count(n-3))\\n    return cash.get(n) % mod\\n  }\\n  return count(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar numTilings = function(N) {\\n  const mod = 1e9 + 7\\n  const cash = new Map([[1,1],[2,2],[3,5]])\\n  const count = (n) => {\\n    if (!cash.has(n)) cash.set(n, count(n-1)*2 + count(n-3))\\n    return cash.get(n) % mod\\n  }\\n  return count(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 857627,
                "title": "0-ms-beats-100-learn-to-solve-all-variations-of-tiling-problem",
                "content": "concept used in my code is very well explained in this link:\\nhttps://journeywithdp.blogspot.com/2018/07/way-to-solve-tiling-problems.html\\nthis will help u to code all variations of tiling problem.\\n![IMG_20230609_203911.jpg](https://assets.leetcode.com/users/images/63eb86fd-c52c-421c-891f-61242e67b09f_1686323520.3678138.jpeg)\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long long  f[n+3],g[n+4];\\n        f[1]=1,f[2]=2,g[1]=1,g[2]=2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            f[i]=(f[i-1]+f[i-2]+2*g[i-2])%(1000000007);\\n            g[i]=(f[i-1]+g[i-1])%(1000000007);\\n        }    \\n        return f[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long long  f[n+3],g[n+4];\\n        f[1]=1,f[2]=2,g[1]=1,g[2]=2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            f[i]=(f[i-1]+f[i-2]+2*g[i-2])%(1000000007);\\n            g[i]=(f[i-1]+g[i-1])%(1000000007);\\n        }    \\n        return f[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857241,
                "title": "python-visual-explanation",
                "content": "Filling the array from left to right, where the current index is the first column that is not full, the array only has four possible states.\\n<img src=\"https://assets.leetcode.com/users/images/a9382830-233d-445e-9b9d-04f76686d9ab_1600671880.5346115.png\" width=\"80%\">\\nHere is an example of state \"0010\" when i = 3.  \\n<img src=\"https://assets.leetcode.com/users/images/4a06f63d-1351-4481-b35d-91c443dae945_1600671875.1838691.png\" width=\"50%\">\\nIn the above example, there are only two possible items that could be placed next:\\n1. a horizontal domino in the top row.\\n2. a tromino that fills the first 3 open spaces.\\n\\nSo the number of ways to fill the array will be the sum of the number of ways to fill the array after picking option 1 and the number of ways to fill the array after picking option 2.  \\n\\nEach state will have different options, for example in state \\'0000\\' we could choose:\\n1. a horizontal domino in the top row\\n2. a vertical domino\\n3. an L shaped tromino\\n4. or a backward\\'s 7 shaped tromino\\n\\nThe number of ways the array can be filled is the sum of all the ways the array can be filled for each choice.  \\n\\nThe way each choice is represented in the code is by increasing ```i``` to the first row that has an empty space and passing in the state of the four squares made up by columns ```i``` and ```i + 1```.  \\n\\n```python\\n    def numTilings(self, N: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def helper(i, state):\\n            nonlocal N\\n            \\n            if (i == N) and (state == \\'0000\\'): return 1\\n            if i >= N: return 0\\n            \\n            ways = 0\\n            if state == \\'0000\\':\\n                ways += helper(i+1, \\'0000\\') # vertical domino added\\n                ways += helper(i, \\'1100\\')   # horizontal domino top row added\\n                #ways += helper(i, \\'0011\\')  # horizontal domino bottom row added\\n                ways += helper(i+1, \\'0010\\') # tromino up added\\n                ways += helper(i+1, \\'1000\\') # tromino down added\\n                return ways\\n            \\n            if state == \\'1100\\':\\n                ways += helper(i+2, \\'0000\\') # horizontal domino bottom row added\\n                return ways\\n            \\n            if state == \\'0010\\':\\n                ways += helper(i+1, \\'1000\\') # horizontal domino top row added\\n                ways += helper(i+2, \\'0000\\') # tromino added\\n                return ways\\n            \\n            if state == \\'1000\\':\\n                ways += helper(i+1, \\'0010\\') # horizontal domino bottom row added\\n                ways += helper(i+2, \\'0000\\') # tromino added\\n                return ways\\n                \\n        return helper(0, \\'0000\\') % (10**9 + 7)\\n```\\n**Notice the line that has been commented out.**  This is because adding \\'0011\\' (horizontal domino on bottom row) and then \\'1100\\' (horizontal domino in top row) is the exact same as adding \\'1100\\' and then \\'0011\\'.  Because these two ways are not distinct we omit one of them while keeping the other.  \\n\\n**Lastly, here is a cleaned up version where the states have been renamed 0, 2, 1, 3 respectively.**\\n\\n```python\\ndef numTilings(self, N: int) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, state):\\n\\t\\tnonlocal N\\n\\n\\t\\tif (i == N) and (state == 0): return 1\\n\\t\\tif i >= N: return 0\\n\\n\\t\\tif state == 0:\\n\\t\\t\\treturn helper(i+1, 0) + helper(i+1, 1) + helper(i+1, 2) + helper(i, 3)\\n\\t\\telif state == 1:\\n\\t\\t\\treturn helper(i+2, 0) + helper(i+1, 2)\\n\\t\\telif state == 2:\\n\\t\\t\\treturn helper(i+2, 0) + helper(i+1, 1)\\n\\t\\telse:\\n\\t\\t\\treturn helper(i+2, 0)\\n\\n\\treturn helper(0, 0) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```i```\n```i```\n```i + 1```\n```python\\n    def numTilings(self, N: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def helper(i, state):\\n            nonlocal N\\n            \\n            if (i == N) and (state == \\'0000\\'): return 1\\n            if i >= N: return 0\\n            \\n            ways = 0\\n            if state == \\'0000\\':\\n                ways += helper(i+1, \\'0000\\') # vertical domino added\\n                ways += helper(i, \\'1100\\')   # horizontal domino top row added\\n                #ways += helper(i, \\'0011\\')  # horizontal domino bottom row added\\n                ways += helper(i+1, \\'0010\\') # tromino up added\\n                ways += helper(i+1, \\'1000\\') # tromino down added\\n                return ways\\n            \\n            if state == \\'1100\\':\\n                ways += helper(i+2, \\'0000\\') # horizontal domino bottom row added\\n                return ways\\n            \\n            if state == \\'0010\\':\\n                ways += helper(i+1, \\'1000\\') # horizontal domino top row added\\n                ways += helper(i+2, \\'0000\\') # tromino added\\n                return ways\\n            \\n            if state == \\'1000\\':\\n                ways += helper(i+1, \\'0010\\') # horizontal domino bottom row added\\n                ways += helper(i+2, \\'0000\\') # tromino added\\n                return ways\\n                \\n        return helper(0, \\'0000\\') % (10**9 + 7)\\n```\n```python\\ndef numTilings(self, N: int) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, state):\\n\\t\\tnonlocal N\\n\\n\\t\\tif (i == N) and (state == 0): return 1\\n\\t\\tif i >= N: return 0\\n\\n\\t\\tif state == 0:\\n\\t\\t\\treturn helper(i+1, 0) + helper(i+1, 1) + helper(i+1, 2) + helper(i, 3)\\n\\t\\telif state == 1:\\n\\t\\t\\treturn helper(i+2, 0) + helper(i+1, 2)\\n\\t\\telif state == 2:\\n\\t\\t\\treturn helper(i+2, 0) + helper(i+1, 1)\\n\\t\\telse:\\n\\t\\t\\treturn helper(i+2, 0)\\n\\n\\treturn helper(0, 0) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 792345,
                "title": "go-0ms-dp",
                "content": "```go\\nfunc numTilings(N int) int {\\n\\tif N == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\tdp1 := make([]int, N+1)\\n\\tdp2 := make([]int, N+1)\\n\\tdp1[1], dp1[2] = 1, 2\\n\\tdp2[2] = 1\\n\\tfor i := 3; i <= N; i++ {\\n\\t\\tdp1[i] = (dp1[i-2] + dp1[i-1] + dp2[i-1]*2) % 1000000007\\n\\t\\tdp2[i] = (dp1[i-2] + dp2[i-1]) % 1000000007\\n\\t}\\n\\treturn dp1[N]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc numTilings(N int) int {\\n\\tif N == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\tdp1 := make([]int, N+1)\\n\\tdp2 := make([]int, N+1)\\n\\tdp1[1], dp1[2] = 1, 2\\n\\tdp2[2] = 1\\n\\tfor i := 3; i <= N; i++ {\\n\\t\\tdp1[i] = (dp1[i-2] + dp1[i-1] + dp2[i-1]*2) % 1000000007\\n\\t\\tdp2[i] = (dp1[i-2] + dp2[i-1]) % 1000000007\\n\\t}\\n\\treturn dp1[N]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 734055,
                "title": "psa-for-fast-matrix-exponentiation-o-log-n-solution-c-implementation-100-speed",
                "content": "The idea is very simple, almost every linear recurrence relation can be calculated in O(log n) time and O(1) space. This relies on a process called fast matrix exponentiation.\\nThere are many posts that explain the reasoning behind the recurrence relation. This post will not go into that. It will take the recurrence relation and implement it in O(log n) time complexity.\\nWith that out of the way, let f(N) represent the number of ways to tile a 2xN matrix. The recurrence relation is\\nf(n) = 2 * f(n-1) + f(n-3)\\nNow label the following matrix as A:\\n![image](https://assets.leetcode.com/users/images/1a4d8870-9083-4b51-a04b-62e3ee5ed34d_1594640964.948474.png)\\nand label the following matrix as B(n):\\n![image](https://assets.leetcode.com/users/images/15816a38-847c-4a8c-a656-f9e660581944_1594636909.6774485.png)\\nWhat is the product of A and B(n-1)? It is shown below.\\n![image](https://assets.leetcode.com/users/images/1988c7ee-5a2e-4efb-81f9-d0d063d997ed_1594637598.9115956.png)\\nThis product, from the recurrence relation, is clearly B(n).\\nThus, from our original recurrence, we have found a new recurrence relation:\\nB(n) = A * B(n-1).\\nWhat is the base case for this recurrence? Define B(2) as \\n![image](https://assets.leetcode.com/users/images/a32c9faf-c902-4225-bf33-ef77eec40d17_1594640490.3104377.png)\\nNow, from the recurrence,\\nB(3) = A * B(2)\\nB(4) = A * B(3) = A * A * B(2) = A^2 * B(2)\\nB(5) = A * B(4) = A^3 * B(2)\\nFrom this pattern,\\nB(n) = A^(n-2) * B(2)\\nAnd how is A^(n-2) calculated? We return to the title of this post, fast matrix exponentiation.\\nThe fact of the matter is that a constant time formula for this recurrence can also be derived. However, as in the formula for the Fibonacci sequence, it may contain irrational numbers, which cannot accurately be represented on computers. This post contains an O(log n) procedure for this exponentiation.\\nThe process is very simple. If X is a matrix, then\\nX^n = X * X^(n-1)                      if n is odd\\nX^n = (X^2)^(n/2)                     if n is even\\nThere are atmost two multiplications for each digit in the binary representation of n (which has log n digits). Thus, this algorithm takes O(log n) time.\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n==1) return 1;\\n        else if(n==2) return 2;\\n        vector<vector<long long>> a{\\n            {2, 0, 1},\\n            {1, 0, 0},\\n            {0, 1, 0}\\n        }, res{\\n            {1, 0, 0},\\n            {0, 1, 0},\\n            {0, 0, 1}\\n        }, temp(3,vector<long long>(3));\\n        n-=2;\\n        while(n){\\n            if(n&1){\\n                for(int i=0;i<3;i++){\\n                    for(int j=0;j<3;j++){\\n                        temp[i][j]=0;\\n                        for(int k=0;k<3;k++){\\n                            temp[i][j]+=(res[i][k]*a[k][j])%1000000007;\\n                        }\\n                        temp[i][j]%=1000000007;\\n                    }\\n                }\\n                res=temp;\\n                n--;\\n            }\\n            if(n){\\n                for(int i=0;i<3;i++){\\n                    for(int j=0;j<3;j++){\\n                        temp[i][j]=0;\\n                        for(int k=0;k<3;k++){\\n                            temp[i][j]+=(a[i][k]*a[k][j])%1000000007;\\n                        }\\n                        temp[i][j]%=1000000007;\\n                    }\\n                }\\n                a=temp;\\n            }\\n            n>>=1;\\n        }\\n        return (2*res[0][0]+res[0][1]+res[0][2])%1000000007;\\n    }\\n};\\n```\\nComplexity: O(log n) time\\n\\t\\t\\t\\t\\tO(1) space (only three 3x3 matrices and one variable)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        if(n==1) return 1;\\n        else if(n==2) return 2;\\n        vector<vector<long long>> a{\\n            {2, 0, 1},\\n            {1, 0, 0},\\n            {0, 1, 0}\\n        }, res{\\n            {1, 0, 0},\\n            {0, 1, 0},\\n            {0, 0, 1}\\n        }, temp(3,vector<long long>(3));\\n        n-=2;\\n        while(n){\\n            if(n&1){\\n                for(int i=0;i<3;i++){\\n                    for(int j=0;j<3;j++){\\n                        temp[i][j]=0;\\n                        for(int k=0;k<3;k++){\\n                            temp[i][j]+=(res[i][k]*a[k][j])%1000000007;\\n                        }\\n                        temp[i][j]%=1000000007;\\n                    }\\n                }\\n                res=temp;\\n                n--;\\n            }\\n            if(n){\\n                for(int i=0;i<3;i++){\\n                    for(int j=0;j<3;j++){\\n                        temp[i][j]=0;\\n                        for(int k=0;k<3;k++){\\n                            temp[i][j]+=(a[i][k]*a[k][j])%1000000007;\\n                        }\\n                        temp[i][j]%=1000000007;\\n                    }\\n                }\\n                a=temp;\\n            }\\n            n>>=1;\\n        }\\n        return (2*res[0][0]+res[0][1]+res[0][2])%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630232,
                "title": "python-dp-super-easy-to-understand-solution",
                "content": "```py\\nclass Solution:\\n    def numTilings(self, N: int) -> int:\\n        \\'\\'\\'\\n        Let D(N) be the number of ways to fill a 2 X N rectangle with dominoes and trominos\\n        \\n        Now, the possible first moves are:\\n        \\n        1. using a vertical domino\\n          \\n            X |..........\\n            X |..........\\n           The result boils down to filling 2 X (N-1) rectangle, i.e. D(N-1)\\n          \\n        2. using a horizontal domino, since we can\\'t fill the bottom portion with a vertical domino or a tromino, \\n           it can only be filled with a horizontal domino, as such\\n           \\n            X X |.........\\n            Y Y |.........\\n           The result is then D(N-2)\\n        \\n        3 and 4. using a tromino (both orientations are equivalent)(so, just 2 times one orientation), it can be filled\\n          as:\\n        \\n            X X Y |......... \\n            X Y Y |.........  D(N-3)\\n            \\n            or \\n            \\n            X X Y Y |.......\\n            X W W Y |.......  D(N-4)\\n            \\n            or\\n            \\n            X X V V Y |.....\\n            X W W Y Y |.....  D(N-5)\\n            \\n            or so on till D(N-N)\\n        \\n        So, we can see a recursive relation:\\n          \\n          D(N) = D(N-1) + D(N-2) + 2 * (D(N-3) + D(N-4) + D(N-5) + ... + D(N-N))  where D(0) = 1, D(x < 0) = 0 (it restricts wrong solutions)\\n        \\'\\'\\'\\n        mod = 10**9 + 7\\n        \\n        DP = [1]\\n        sumsDP = [1]\\n        \\n        for i in range(1, N+1):\\n            res = 0\\n            res += DP[i-1] if i >= 1 else 0\\n            res += DP[i-2] if i >= 2 else 0\\n            res += 2*sumsDP[i-3] if i >= 3 else 0\\n            \\n            res = res % mod\\n            \\n            DP.append(res)\\n            sumsDP.append((sumsDP[-1] + res) % mod)\\n        \\n        return DP[N]\\n\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def numTilings(self, N: int) -> int:\\n        \\'\\'\\'\\n        Let D(N) be the number of ways to fill a 2 X N rectangle with dominoes and trominos\\n        \\n        Now, the possible first moves are:\\n        \\n        1. using a vertical domino\\n          \\n            X |..........\\n            X |..........\\n           The result boils down to filling 2 X (N-1) rectangle, i.e. D(N-1)\\n          \\n        2. using a horizontal domino, since we can\\'t fill the bottom portion with a vertical domino or a tromino, \\n           it can only be filled with a horizontal domino, as such\\n           \\n            X X |.........\\n            Y Y |.........\\n           The result is then D(N-2)\\n        \\n        3 and 4. using a tromino (both orientations are equivalent)(so, just 2 times one orientation), it can be filled\\n          as:\\n        \\n            X X Y |......... \\n            X Y Y |.........  D(N-3)\\n            \\n            or \\n            \\n            X X Y Y |.......\\n            X W W Y |.......  D(N-4)\\n            \\n            or\\n            \\n            X X V V Y |.....\\n            X W W Y Y |.....  D(N-5)\\n            \\n            or so on till D(N-N)\\n        \\n        So, we can see a recursive relation:\\n          \\n          D(N) = D(N-1) + D(N-2) + 2 * (D(N-3) + D(N-4) + D(N-5) + ... + D(N-N))  where D(0) = 1, D(x < 0) = 0 (it restricts wrong solutions)\\n        \\'\\'\\'\\n        mod = 10**9 + 7\\n        \\n        DP = [1]\\n        sumsDP = [1]\\n        \\n        for i in range(1, N+1):\\n            res = 0\\n            res += DP[i-1] if i >= 1 else 0\\n            res += DP[i-2] if i >= 2 else 0\\n            res += 2*sumsDP[i-3] if i >= 3 else 0\\n            \\n            res = res % mod\\n            \\n            DP.append(res)\\n            sumsDP.append((sumsDP[-1] + res) % mod)\\n        \\n        return DP[N]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560106,
                "title": "c-dp-solution-o-n-for-both-time-and-space-the-post-includes-tutorial-of-mine",
                "content": "The idea of this problem is demonstrated in the picture below, after some failure and this is the thing I finally came up.\\n![image](https://assets.leetcode.com/users/baonguyentqt/image_1585811937.png)\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        int mod=1000000007;\\n        int n=N;\\n        if (n==1)\\n            return 1;\\n        vector<vector<int>> dp(n+2,vector<int>(3));//dp[index][type]\\n        //base\\n        dp[0][0]=dp[1][0]=dp[1][1]=dp[1][2]=1;\\n        //rest\\n        for (int i=0; i<n; i++)\\n            for (int j=0; j<3; j++)\\n                switch (j){\\n                    case 0:{\\n                        dp[i+1][0]+=dp[i][0],dp[i+1][0]%=mod;\\n                        dp[i+2][0]+=dp[i][0],dp[i+2][0]%=mod;\\n                        dp[i+2][1]+=dp[i][0],dp[i+2][1]%=mod;\\n                        dp[i+2][2]+=dp[i][0],dp[i+2][2]%=mod;\\n                        break;\\n                    }\\n                    case 1:{\\n                        dp[i+1][2]+=dp[i][1],dp[i+1][2]%=mod;\\n                        dp[i+1][0]+=dp[i][1],dp[i+1][0]%=mod;\\n                        break;\\n                    }\\n                    case 2:{\\n                        dp[i+1][1]+=dp[i][2],dp[i+1][1]%=mod;\\n                        dp[i+1][0]+=dp[i][2],dp[i+1][0]%=mod;\\n                        break;\\n                    }\\n                }        \\n        return dp[n-1][0];        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTilings(int N) {\\n        int mod=1000000007;\\n        int n=N;\\n        if (n==1)\\n            return 1;\\n        vector<vector<int>> dp(n+2,vector<int>(3));//dp[index][type]\\n        //base\\n        dp[0][0]=dp[1][0]=dp[1][1]=dp[1][2]=1;\\n        //rest\\n        for (int i=0; i<n; i++)\\n            for (int j=0; j<3; j++)\\n                switch (j){\\n                    case 0:{\\n                        dp[i+1][0]+=dp[i][0],dp[i+1][0]%=mod;\\n                        dp[i+2][0]+=dp[i][0],dp[i+2][0]%=mod;\\n                        dp[i+2][1]+=dp[i][0],dp[i+2][1]%=mod;\\n                        dp[i+2][2]+=dp[i][0],dp[i+2][2]%=mod;\\n                        break;\\n                    }\\n                    case 1:{\\n                        dp[i+1][2]+=dp[i][1],dp[i+1][2]%=mod;\\n                        dp[i+1][0]+=dp[i][1],dp[i+1][0]%=mod;\\n                        break;\\n                    }\\n                    case 2:{\\n                        dp[i+1][1]+=dp[i][2],dp[i+1][1]%=mod;\\n                        dp[i+1][0]+=dp[i][2],dp[i+1][0]%=mod;\\n                        break;\\n                    }\\n                }        \\n        return dp[n-1][0];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558372,
                "title": "python-dp-with-explanation",
                "content": "The first i layers has dp[i] ways to construct.\\n`dp[i] = dp[i-1] + dp[i-2] + 2*sum(dp[j] for j in range(i-3))`\\n\\nFirstly, let\\'s name these tiles.\\n```\\nXX  <- domino1 (abbr. D1)\\n\\nX  <- D2\\nX\\n\\nXX  <- L1\\nX\\n\\nX\\nXX <- L2\\n\\nXX <- L3\\n X\\n \\n X\\nXX  <- L4\\n```\\n\\nThink of how we get first i layers, we can derive from i-1 layers only with the last layer a D2, from i-2 layers only with the last two layers 2 D1, from i-3 layers with two ways: a. L2+L3 b. L1+L4, from i-3 layers before also with two ways (similar to i-3).\\n\\nSo we get this equation: `dp[i] = dp[i-1] + dp[i-2] + 2*sum(dp[j] for j in range(i-3))`\\n\\n```Python\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        dp = [0]*(1+n)\\n        dp[0] = 1\\n        dp[1] = 1\\n        dp[2] = 2\\n        s = 0\\n        for i in range(3, n+1):\\n            s += dp[i-3]\\n            dp[i] =dp[i-1]+dp[i-2]+s*2\\n        return dp[-1]%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nXX  <- domino1 (abbr. D1)\\n\\nX  <- D2\\nX\\n\\nXX  <- L1\\nX\\n\\nX\\nXX <- L2\\n\\nXX <- L3\\n X\\n \\n X\\nXX  <- L4\\n```\n```Python\\nclass Solution:\\n    def numTilings(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        dp = [0]*(1+n)\\n        dp[0] = 1\\n        dp[1] = 1\\n        dp[2] = 2\\n        s = 0\\n        for i in range(3, n+1):\\n            s += dp[i-3]\\n            dp[i] =dp[i-1]+dp[i-2]+s*2\\n        return dp[-1]%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530954,
                "title": "o-n-dp-solution-with-picture-illustration-hope-it-helps",
                "content": "```\\npackage DP;\\n\\npublic class DominoAndTrominoTiling {\\n    class Solution {\\n        public int numTilings(int N) {\\n            int kMod = 1000000007;\\n            long[][] dp = new long[N + 1][2];\\n            dp[0][0] = dp[1][0] = 1;\\n            for (int i = 2; i <= N; ++i) {\\n                dp[i][0] = (dp[i-1][0] + dp[i - 2][0] + 2 * dp[i-1][1]) % kMod;\\n                dp[i][1] = (dp[i - 2][0] + dp[i - 1][1]) % kMod;\\n            }\\n            return (int)dp[N][0];\\n        }\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/thinkanddo/image_1583528989.png)\\n",
                "solutionTags": [],
                "code": "```\\npackage DP;\\n\\npublic class DominoAndTrominoTiling {\\n    class Solution {\\n        public int numTilings(int N) {\\n            int kMod = 1000000007;\\n            long[][] dp = new long[N + 1][2];\\n            dp[0][0] = dp[1][0] = 1;\\n            for (int i = 2; i <= N; ++i) {\\n                dp[i][0] = (dp[i-1][0] + dp[i - 2][0] + 2 * dp[i-1][1]) % kMod;\\n                dp[i][1] = (dp[i - 2][0] + dp[i - 1][1]) % kMod;\\n            }\\n            return (int)dp[N][0];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382898,
                "title": "java-1ms-very-simple-dp-solution",
                "content": "dp[i][0]: both rows have length i;\\ndp[i][1]: one row has length i and the other i - 1;\\ndp[i][2]: one row has length i and the other i - 2.\\n\\n```\\n    public int numTilings(int N) {\\n        final int mod = 1000000007;\\n        int[][] dp = new int[N + 1][3];\\n        dp[0][0] = 1;\\n        dp[1][0] = 1;\\n        for (int i = 2; i <= N; i++) {\\n            dp[i][2] = dp[i - 2][0];\\n            dp[i][1] = (dp[i - 1][1] + dp[i - 2][0]) % mod;\\n            dp[i][0] = ((dp[i][2] + dp[i - 1][0]) % mod + (dp[i - 1][1] * 2) % mod) % mod;\\n        }\\n        return dp[N][0];\\n    }",
                "solutionTags": [],
                "code": "dp[i][0]: both rows have length i;\\ndp[i][1]: one row has length i and the other i - 1;\\ndp[i][2]: one row has length i and the other i - 2.\\n\\n```\\n    public int numTilings(int N) {\\n        final int mod = 1000000007;\\n        int[][] dp = new int[N + 1][3];\\n        dp[0][0] = 1;\\n        dp[1][0] = 1;\\n        for (int i = 2; i <= N; i++) {\\n            dp[i][2] = dp[i - 2][0];\\n            dp[i][1] = (dp[i - 1][1] + dp[i - 2][0]) % mod;\\n            dp[i][0] = ((dp[i][2] + dp[i - 1][0]) % mod + (dp[i - 1][1] * 2) % mod) % mod;\\n        }\\n        return dp[N][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 121121,
                "title": "clear-java-code-and-detail-about-dp-n-2-dp-n-1-dp-n-3",
                "content": "```\\nclass Solution {\\n    int MOD = (int)Math.pow(10, 9) + 7;\\n    public int numTilings(int N) {\\n        if (N == 1) return 1;\\n        if (N == 2) return 2;\\n        if (N == 3) return 5;\\n        int[] dp = new int[4];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        for (int i = 4; i <= N; ++i) {\\n                dp[i % 4] = (2 * dp[(i - 1)%4]%MOD + dp[(i - 3)%4]) % MOD;\\n        }\\n        return dp[N%4];\\n    }\\n}\\n```\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nick_uw/image_1522163280.png)\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nick_uw/image_1522163367.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nick_uw/image_1522163614.png)\\n\\n\\nFor more details, you can visit https://www.jianshu.com/p/33f739a4ba9c\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MOD = (int)Math.pow(10, 9) + 7;\\n    public int numTilings(int N) {\\n        if (N == 1) return 1;\\n        if (N == 2) return 2;\\n        if (N == 3) return 5;\\n        int[] dp = new int[4];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 5;\\n        for (int i = 4; i <= N; ++i) {\\n                dp[i % 4] = (2 * dp[(i - 1)%4]%MOD + dp[(i - 3)%4]) % MOD;\\n        }\\n        return dp[N%4];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116567,
                "title": "those-who-posted-only-code-for-the-equatio-did-you-really-originally-solve-it-during-contest",
                "content": "Many posted there solution that simply encodes the equation without identifying how they came up with the approach. It seems pretty hard to come up with the final correct equation in contest like conditions, but some people have posted code for it within minutes of contest.\n\nDid you really originally solve the problem without seeing it first anywhere? or copied code or solution from somewhere?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 116538,
                "title": "python-explanation",
                "content": "Calculate the number of tilings with both cells in the final row (even) and with only a single cell in the final row (odd).\nWe can make a new even row from the previous even row and a horizontal domino, or the even row before that and 2 vertical dominos, or the previous odd row and a tromino.\nWe can make a new odd row from the previous odd row and a vertical domino, or the i - 2 even row and a tromino in 2 possible orientations.\n\nSpace complexity can be reduced by not storing all the even and odd lists.\n```\nclass Solution(object):\n    def numTilings(self, N):\n        MOD = (10 ** 9) + 7\n\n        even = [0, 1, 2, 5]\n        odd = [0, 0, 2, 4]\n\n        for i in range(4, N + 1):\n\n            new_even = (even[i - 1] + even[i - 2] + odd[i - 1]) % MOD\n            even.append(new_even)\n\n            new_odd = (odd[i - 1] + 2 * even[i - 2]) % MOD\n            odd.append(new_odd)\n\n        return clean[N] % MOD\n\t\t\t\t",
                "solutionTags": [],
                "code": "Calculate the number of tilings with both cells in the final row (even) and with only a single cell in the final row (odd).\nclass Solution(object):\n    def numTilings(self, N):\n        MOD = (10 ** 9) + 7\n        even = [0, 1, 2, 5]\n        odd = [0, 0, 2, 4]\n        for i in range(4, N + 1):\n            new_even = (even[i - 1] + even[i - 2] + odd[i - 1]) % MOD\n            even.append(new_even)\n            new_odd = (odd[i - 1] + 2 * even[i - 2]) % MOD\n            odd.append(new_odd)",
                "codeTag": "Java"
            },
            {
                "id": 3959857,
                "title": "beginner-dp-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n int mod=1e9+7;\\n\\n   int solve(int n,vector<int>&dp){\\n\\n         if(n==1){\\n             return 1;\\n         }\\n\\n         if(n==2){\\n             return 2;\\n         }\\n\\n         if(n==3)\\n         {\\n             return 5;\\n         }\\n\\n         if(dp[n]!=-1){\\n             return dp[n];\\n         }\\n\\n\\n         return dp[n]=((solve(n-1,dp)*2)%mod+(solve(n-3,dp))%mod)%mod;\\n   }\\n    int numTilings(int n) {\\n        \\n\\n        vector<int>dp(n+1,-1);\\n\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n int mod=1e9+7;\\n\\n   int solve(int n,vector<int>&dp){\\n\\n         if(n==1){\\n             return 1;\\n         }\\n\\n         if(n==2){\\n             return 2;\\n         }\\n\\n         if(n==3)\\n         {\\n             return 5;\\n         }\\n\\n         if(dp[n]!=-1){\\n             return dp[n];\\n         }\\n\\n\\n         return dp[n]=((solve(n-1,dp)*2)%mod+(solve(n-3,dp))%mod)%mod;\\n   }\\n    int numTilings(int n) {\\n        \\n\\n        vector<int>dp(n+1,-1);\\n\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564770,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566271,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726442,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565446,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726085,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1725925,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576070,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726120,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1656867,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566040,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1564770,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566271,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726442,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565446,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726085,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1725925,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576070,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726120,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1656867,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566040,
                "content": [
                    {
                        "username": "mshah890",
                        "content": " I cannot understand what \"Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile\""
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This should stay at the top."
                    },
                    {
                        "username": "yash504",
                        "content": "[@digvijaysinghrajput5490](/digvijaysinghrajput5490) There can be adjacent pairs of cells occupied by the same tiles for two different tilings. But there must exist one which is different. Not all of them have to be different."
                    },
                    {
                        "username": "clock330",
                        "content": "My way of understanding if two tilings are different is: forget about the color shown in example and just check the line pattern of the tiling formed by the perimeter of dominos or trominos , if the pattern is different, then the tilings are different.\\n- Example 1: one tiling for `n = 3` is `|||`, now adding a vertical `|` to the left or the right side of `|||` will result in the same tiling because `||||` is the same pattern as `||||`. \\n- Example 2: one tiling for `n = 3` is `=|`, now adding a vertical `|` to the left or the right side of `=|` will result in different tilings because `|=|` is not the same pattern as `=||`"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "[@yash504](/yash504) thanks a lot"
                    },
                    {
                        "username": "Nanorth",
                        "content": "Thanks god, I am not the only one cannot understand it"
                    },
                    {
                        "username": "digvijay54901singhrajput",
                        "content": "[@yash504](/yash504) but isn\\'t in the given example diagram, there are many adjacent pairs of cells that are occupied by the same tile in more than one combination and are still treated differently."
                    },
                    {
                        "username": "yash504",
                        "content": "Four-directionally adjacent cells mean two cells which are adjacent to each other in one of the four directions. This means that the two cells should be vertically or horizontally adjacent. Hence, two tilings are different iff. for the same pair of adjacent tiles in the two tilings, only one of them is occupied by the same tile. \n\nHave to admit, the phrasing of the question is awful."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "its been 4 years and they still haven\\'t changed it lol smh."
                    },
                    {
                        "username": "iammateus",
                        "content": "Very badly worded"
                    },
                    {
                        "username": "1120131418",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/1120131418/image_1519740030.png)\n"
                    },
                    {
                        "username": "zhang60",
                        "content": "Your thinking process is instrumental."
                    },
                    {
                        "username": "hwalters361",
                        "content": "Our papers look really similar! I\\'m glad we had the same thought process!"
                    },
                    {
                        "username": "AshwaniV",
                        "content": "thanks!"
                    },
                    {
                        "username": "Sriram_Kalyan",
                        "content": "It\\'s interesting and we got a pattern for finding the next possible ways from the previous. Like A[n] = 2*A[n-1] + A[n-3]\\nInitialize a dp array and run a for loop with the above expression. Return the last element in the dp array."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Definitely not medium."
                    },
                    {
                        "username": "benjie",
                        "content": "I find this question unclear the way it is currently being asked.\\n\\nThe first part of the explanation says that there are two different types of tiles: a 2x1, and an L, so a 2x2. Then, the example has XYZ as tiles in configurations that would not be possible if those represented the tiles we supposedly have to use.\\n\\nAdditionally, what is Z, if X is the 2x1 and Y is the 2x2 L shape? \\n\\nI think this question needs to be rewritten."
                    },
                    {
                        "username": "el_harbin",
                        "content": "This question is not that easy. \\nIf you don\\'t want to look at the answer here is some hints :\\n\\nHint 1 : you want to find answer for number n. So maybe you can find it from previous n answers. \\n\\nHint 2 : find answers for at n = 1 to n = 10 and write it to your note book. then try to find the pattern.\\n\\nHope this will help.\\n"
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'s easy to find the pattern in this problem. However, it\\'s impossible to do so during an interview. Even if I can find the rules and solve it, the most difficult part is still to explain the pattern."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@matttmaloney](/matttmaloney) Not Exactly arrangements but relatation between them."
                    },
                    {
                        "username": "el_harbin",
                        "content": "[@tejasX](/tejasX)  The simple way to use console of leetcode. Add your testcases to it and note down the answers to your notebook. You its easy to find the pattern But this trick will not work in contest."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "[@tejasX](/tejasX)  just draw them and see how many arrangements can be made"
                    },
                    {
                        "username": "tejasX",
                        "content": "How can i come up answers for n=1to10?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Saw this problem during my very first intern onsite interview and I failed it so hard LOL. Knew it should be dynamic programming but just couldn\\'t find the pattern under the pressure. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i found it finally and its really easy.. https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "chris0420",
                        "content": "\\tIf anyone can spare a minute to explain why the solution for\\n\\tn = 4 is 11 that would be much appreciated. I\\'ve been \\n\\tstaring at my paper for like an hour and I can only \\n\\tfind 9 possible tilings when n is 4."
                    },
                    {
                        "username": "manicko",
                        "content": "[@koralski](/koralski) i count 10"
                    },
                    {
                        "username": "yasser_issa20",
                        "content": "** for only 2\\'s there are 5 ways :- **\\n==\\n== \\n\\n||||\\n\\n||=\\n\\n=||\\n\\n|=|\\n** and for 2\\'s and 3\\'s there are 6 ways :- **\\n| \\u02FB \\u02FA\\n\\n\\u02FB \\u02FA |\\n\\n| \\u02F9\\u02FC\\n\\n\\u02F9\\u02FC |\\n\\n\\u02FB-\\u02FC\\n\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@koralski](/koralski) Now that\\'s creative !  XD"
                    },
                    {
                        "username": "dkashi",
                        "content": "These are all 11 ways\n\n[![Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg](https://i.postimg.cc/fyKfwvw7/Whats-App-Image-2022-12-23-at-7-51-24-PM.jpg)](https://postimg.cc/7J5290Jb)"
                    },
                    {
                        "username": "koralski",
                        "content": "11 cases:\\n||=\\n=||\\n|=|\\n||||\\n==\\n| \\u02FB \\u02FA\\n \\u02FB \\u02FA |\\n| \\u02F9\\u02FC\\n\\u02F9\\u02FC |\\n\\u02FB-\\u02FC\\n\\u02F9-\\u02FA"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Step 1: Run test cases for 1 to 8.\\nStep 2: Observe the relation among A[i], a[i-1] and a[i-3]"
                    },
                    {
                        "username": "512kb",
                        "content": "But HOW?"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "[@nirutgupta78](/nirutgupta78) Yup. a[i]=2*a[i-1]+a[i-3] \\na[1]=1, a[2]=2, a[3]=5... Now you can use an array with a loop to find a[n]. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I came after solving, are you doing it in O(N)?"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "I think this problem should be tagged with sequence series of mathematics that we used to learn in high schools mathematics."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "[@nirutgupta78](/nirutgupta78) no need to post the solution in the discussions tab. Anyone that wants it can go to the Solutions tab. This is is for discussing the problem without seeing the solution, thanks. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Lets keep it simple https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944515/please-checkout-intuitive-python-solution-this-is-definitely-different-from-others-tc-o-n/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/domino-and-tromino-tiling/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Top-down)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up, space optimization)\n\n  \n**Approach 4:** Matrix Exponentiation\n\n  \n**Approach 5:** Matrix Exponentiation (time optimization, space/time trade off)\n\n  \n**Approach 6:** Math optimization (Fibonacci sequence like)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1726877,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1729670,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1986157,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1921355,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1802790,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1728299,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1726549,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1725975,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1570700,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 1726092,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**understand the sequence**\\n5 = 2 * 2 + 1\\n11 = 5 * 2 + 1\\n24 = 11 * 2 + 2\\n53 = 24 * 2 + 5\\n117 = 53 * 2 + 11\\nA[N] = A[N-1] * 2 + A[N-3]\\nnow try implementing"
                    },
                    {
                        "username": "psionl0",
                        "content": "That was a nice Christmas gift."
                    },
                    {
                        "username": "djslim",
                        "content": "Tbh it should be marked as hard"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "[@lucasscodes](/lucasscodes) What\\'s about the case when you have no answers to guess the pattern?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "only if u use a bad solution!\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-9889-138mb-9921-python-explained/\nnot that hard if u do the math before right."
                    },
                    {
                        "username": "harmonicfunc",
                        "content": "is it too difficult for my brain ??"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Why the formula is not `dp(n-1) + dp(n-2) + 2 * dp(n-3)`?\\nI still don\\'t understand."
                    },
                    {
                        "username": "XOFJO",
                        "content": "it is easy once you know how to do it. However it is really difficult to come up with the solution when you first meet the problem."
                    },
                    {
                        "username": "piyush4299",
                        "content": "I just couldn\\'t get the base idea or core reason of these types of questions of what that pattern signifies. Just finding pattern seems to be so much unsatisfying. Might be I am not big fan of these questions. "
                    },
                    {
                        "username": "user7407SA",
                        "content": "I have implemented a solution for this problem. But the issue is I always find it difficult to do modulo of 10e9 + 7. Can someone please help me how to do modulo as I am not getting the right answer for higher values of n. Thanks in advance.\\n\\n  `static final int mod = 1000000007;\\n\\t\\n\\t public static int numTilings(int n) {\\n\\t \\t\\t \\n\\t\\t int dp[][] = new int[n+1][n+1];\\n\\t\\t \\n\\t\\t for(int i=0;i<=n;++i)\\n\\t\\t\\t for(int j=0; j<=n; ++j)\\n\\t\\t\\t\\t dp[i][j] = -1;\\n\\t\\t \\n\\t\\t return function(0,0,n,dp);\\t\\t \\n\\t\\t \\t\\t \\n\\t }\\n\\t \\n\\t public static int function(int x, int y, int n, int dp[][]) {\\t\\t \\n\\t\\t \\n\\t\\t if(x > n || y > n)\\n\\t\\t\\t return 0;\\n\\t\\t \\n\\t\\t if(dp[x][y] != -1)\\n\\t\\t\\t return dp[x][y];\\n\\t\\t \\n\\t\\t if(x == n && y == n)\\n\\t\\t\\t return dp[x][y] = 1;\\t\\t\\t\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t else {\\n\\t\\t \\n\\t\\t if(x == y) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(x == y+1) {\\n\\t\\t\\t \\n\\t\\t\\treturn dp[x][y] = ((function(x+1, y+2, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x, y+2, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else if(y == x+1) {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = ((function(x+2, y+1, n, dp))\\n\\t\\t\\t +\\n\\t\\t\\t (function(x+2, y, n, dp))) % mod;\\n\\t\\t }\\n\\t\\t \\n\\t\\t else {\\n\\t\\t\\t \\n\\t\\t\\t return dp[x][y] = function(x, y+2, n, dp);\\n\\t\\t }\\n\\t\\t \\n\\t\\t }\\n\\t\\t \\n\\t }\\n`"
                    },
                    {
                        "username": "olchik",
                        "content": "You could use long for dp to avoid overflowing `int` during calculations. In this case your use of modulo should be fine. "
                    },
                    {
                        "username": "msoni00005",
                        "content": "for returning answers after modulo , try doing mod at every step for example in your function you have\\n\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp))\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp))) % mod;\\n\\t\\t \\n\\t }\\n\\nHere your return statement includes 4 further function calls so do mod after calculating answer for each function call then doing mod after adding answer for all 4 calls.\\nif(x == y) {\\n\\t\\t \\n\\t\\treturn dp[x][y] = ((function(x+1,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y+1,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+1,y+2,n,dp)%mod)\\n\\t\\t +\\n\\t\\t (function(x+2,y,n,dp)%mod)) % mod;\\n\\t\\t \\n\\t }\\n"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "U need the \"whole\" thinking process?\\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/2944113/27ms-98-89-13-8mb-99-21-python-explained/"
                    },
                    {
                        "username": "dkashi",
                        "content": "Here is some intuition on why this formula works \\nhttps://leetcode.com/problems/domino-and-tromino-tiling/solutions/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1+dpn-3/"
                    },
                    {
                        "username": "Electronaota",
                        "content": "![image](https://assets.leetcode.com/users/images/07f136a4-213b-4fbc-9bc5-4c8f4bf2c1e0_1639120210.1616757.png)\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "Gosh!!! Which high school did you go to?"
                    },
                    {
                        "username": "guyses",
                        "content": " `vector<int> dp(n+1)`\\n`for(int i = 3; i <= n; i++)`\\n\\nWhen i use this for loop for size n + 1, it gets address overflow idk why"
                    },
                    {
                        "username": "guyses",
                        "content": "[@santanusen](/santanusen) ohh ok. Thanks mate!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you initializing ```dp[2]``` (base case) even when n is 1?"
                    }
                ]
            },
            {
                "id": 2066958,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 2064286,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 2046687,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 2019433,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 2012378,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 1813595,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 1797226,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 1729325,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 1729040,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            },
            {
                "id": 1727034,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "this can\\'t be solved in an interview if not solved earlier!"
                    },
                    {
                        "username": "rajender7",
                        "content": "Only if we have the time to draw at least the first 10 testcases will we be able to solve it."
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "Bro wth is this."
                    },
                    {
                        "username": "Domesan",
                        "content": "This is actually easy problem if you list out all the answers from n=1 to n=10 and find the logic behind the answer sequence.  This is fully based on aptitude knowledge :)\n\nhint: assume ans for n=0 is 1 for convenience"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This was more like an Aptitude question"
                    },
                    {
                        "username": "Furies",
                        "content": "A hint: mod on the intermediate sums too. Even if you use a long, you will run over its limit in the middle of the calculation. Don\\'t just mod on the final sum."
                    },
                    {
                        "username": "Krrabs",
                        "content": "This is a really one of a kind question.\\n\\nI mean the solution involves calculating states using two functions. \\nWhy did nobody told me you can do this? before I only knew to calculate different states by changing the inputs of a function.\\n\\nMy mind was blown after looking at the solution."
                    },
                    {
                        "username": "vibhuvivekverma",
                        "content": "can we do it with dp ? \\nwondering how to do it still not got states, state idea are appreciated "
                    },
                    {
                        "username": "Dragon_of_the_west",
                        "content": "This is the solution I was able to generte using without any equation but logic with DP = Recursion + Memorization\\n\\nclass Solution {\\npublic:\\n    int power(int& p)\\n    {\\n        int i, a;\\n        long long ans=1;\\n        for(i=1;i<=p;i++)\\n        {\\n            ans=(ans*2)%1000000007;\\n        }\\n\\n        a=ans;\\n\\n        return a;\\n    }\\n\\n    int find_tiles(double length, int p, vector<vector<int>>& dp)\\n    {\\n        double zero=0.0;\\n        if(length==zero)\\n        {\\n            int pair=0;\\n            if(p>0)\\n            {\\n                if(p>1)\\n                {\\n                    double p1, p2=p;\\n                    p1=power(p);\\n                    pair=p1;\\n\\n                    return dp[length][p]= pair;\\n                }\\n\\n                return dp[length][p]=2;\\n            }\\n\\n            return dp[length][p]=1;\\n        }\\n\\n        int len_in=length;\\n\\n        if(length - len_in == 0 && dp[length][p] != -1)\\n        {\\n            return dp[length][p];\\n        }\\n\\n        int c1=0, c2=0, c3=0;\\n        \\n        if( !(length - len_in > 0) && (length-2.0 >= zero))\\n        {\\n            c1=(find_tiles(length-2, p, dp))%1000000007;\\n        }\\n\\n        \\n\\n        if(length-1.5 >= zero)\\n        {\\n            if(length - len_in > 0)\\n            {\\n                c2=(find_tiles(length-1.5, p+1, dp))%1000000007;\\n            }\\n            else if(length - len_in == 0)\\n            {\\n                c2=(find_tiles(length-1.5, p, dp))%1000000007;\\n            }\\n\\n        }\\n\\n        if(length-1.0 >= zero)\\n        {\\n            c3=(find_tiles(length-1, p, dp))%1000000007;\\n        }\\n\\n        if(length - len_in == 0)\\n        {\\n            dp[length][p]=(((c1+c2)%1000000007+c3)%1000000007);\\n        }\\n\\n        return (((c1+c2)%1000000007)+c3)%1000000007;\\n    }\\n\\n    int numTilings(int& n) {\\n        \\n        int max_comb;\\n        double length=n;\\n        vector<vector<int>> dp(1002, vector<int> (502, -1));\\n\\n        max_comb=find_tiles(length, 0, dp);\\n        return max_comb;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "Took me some time to figure out that there\\'s no need to use array at all in my DP solution. Just use four variables and update them on each iteration"
                    }
                ]
            }
        ]
    }
]